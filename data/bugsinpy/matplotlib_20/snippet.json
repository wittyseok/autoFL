[
    {
        "name": "lib.matplotlib.mlab.window_none#77",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.window_none(x)",
        "snippet": "def window_none(x):\n    '''\n    No window function; simply return x.\n\n    See Also\n    --------\n    window_hanning : Another window algorithm.\n    '''\n    return x",
        "begin_line": 77,
        "end_line": 85,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.633005114113426e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.apply_window#89",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.apply_window(x, window, axis=0, return_window=None)",
        "snippet": "def apply_window(x, window, axis=0, return_window=None):\n    '''\n    Apply the given window to the given 1D or 2D array along the given axis.\n\n    Parameters\n    ----------\n    x : 1D or 2D array or sequence\n        Array or sequence containing the data.\n\n    window : function or array.\n        Either a function to generate a window or an array with length\n        *x*.shape[*axis*]\n\n    axis : integer\n        The axis over which to do the repetition.\n        Must be 0 or 1.  The default is 0\n\n    return_window : bool\n        If true, also return the 1D values of the window that was applied\n    '''\n    x = np.asarray(x)\n\n    if x.ndim < 1 or x.ndim > 2:\n        raise ValueError('only 1D or 2D arrays can be used')\n    if axis+1 > x.ndim:\n        raise ValueError('axis(=%s) out of bounds' % axis)\n\n    xshape = list(x.shape)\n    xshapetarg = xshape.pop(axis)\n\n    if np.iterable(window):\n        if len(window) != xshapetarg:\n            raise ValueError('The len(window) must be the same as the shape '\n                             'of x for the chosen axis')\n        windowVals = window\n    else:\n        windowVals = window(np.ones(xshapetarg, dtype=x.dtype))\n\n    if x.ndim == 1:\n        if return_window:\n            return windowVals * x, windowVals\n        else:\n            return windowVals * x\n\n    xshapeother = xshape.pop()\n\n    otheraxis = (axis+1) % 2\n\n    windowValsRep = stride_repeat(windowVals, xshapeother, axis=otheraxis)\n\n    if return_window:\n        return windowValsRep * x, windowVals\n    else:\n        return windowValsRep * x",
        "begin_line": 89,
        "end_line": 142,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.detrend#145",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.detrend(x, key=None, axis=None)",
        "snippet": "def detrend(x, key=None, axis=None):\n    '''\n    Return x with its trend removed.\n\n    Parameters\n    ----------\n    x : array or sequence\n        Array or sequence containing the data.\n\n    key : {'default', 'constant', 'mean', 'linear', 'none'} or function\n        Specifies the detrend algorithm to use. 'default' is 'mean', which is\n        the same as `detrend_mean`. 'constant' is the same. 'linear' is\n        the same as `detrend_linear`. 'none' is the same as\n        `detrend_none`. The default is 'mean'. See the corresponding\n        functions for more details regarding the algorithms. Can also be a\n        function that carries out the detrend operation.\n\n    axis : integer\n        The axis along which to do the detrending.\n\n    See Also\n    --------\n    detrend_mean : Implementation of the 'mean' algorithm.\n    detrend_linear : Implementation of the 'linear' algorithm.\n    detrend_none : Implementation of the 'none' algorithm.\n    '''\n    if key is None or key in ['constant', 'mean', 'default']:\n        return detrend(x, key=detrend_mean, axis=axis)\n    elif key == 'linear':\n        return detrend(x, key=detrend_linear, axis=axis)\n    elif key == 'none':\n        return detrend(x, key=detrend_none, axis=axis)\n    elif callable(key):\n        x = np.asarray(x)\n        if axis is not None and axis + 1 > x.ndim:\n            raise ValueError(f'axis(={axis}) out of bounds')\n        if (axis is None and x.ndim == 0) or (not axis and x.ndim == 1):\n            return key(x)\n        # try to use the 'axis' argument if the function supports it,\n        # otherwise use apply_along_axis to do it\n        try:\n            return key(x, axis=axis)\n        except TypeError:\n            return np.apply_along_axis(key, axis=axis, arr=x)\n    else:\n        raise ValueError(\n            f\"Unknown value for key: {key!r}, must be one of: 'default', \"\n            f\"'constant', 'mean', 'linear', or a function\")",
        "begin_line": 145,
        "end_line": 192,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.demean#196",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.demean(x, axis=0)",
        "snippet": "def demean(x, axis=0):\n    '''\n    Return x minus its mean along the specified axis.\n\n    Parameters\n    ----------\n    x : array or sequence\n        Array or sequence containing the data\n        Can have any dimensionality\n\n    axis : integer\n        The axis along which to take the mean.  See numpy.mean for a\n        description of this argument.\n\n    See Also\n    --------\n    detrend_mean : Same as `demean` except for the default *axis*.\n    '''\n    return detrend_mean(x, axis=axis)",
        "begin_line": 196,
        "end_line": 214,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.905138339920949e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.detrend_none#245",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.detrend_none(x, axis=None)",
        "snippet": "def detrend_none(x, axis=None):\n    '''\n    Return x: no detrending.\n\n    Parameters\n    ----------\n    x : any object\n        An object containing the data\n\n    axis : integer\n        This parameter is ignored.\n        It is included for compatibility with detrend_mean\n\n    See Also\n    --------\n    detrend_mean : Another detrend algorithm.\n    detrend_linear : Another detrend algorithm.\n    detrend : A wrapper around all the detrend algorithms.\n    '''\n    return x",
        "begin_line": 245,
        "end_line": 264,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011519410206197443,
            "pseudo_dstar_susp": 0.00011405109489051095,
            "pseudo_tarantula_susp": 0.0001168907071887785,
            "pseudo_op2_susp": 0.00011405109489051095,
            "pseudo_barinel_susp": 0.0001168907071887785
        }
    },
    {
        "name": "lib.matplotlib.mlab.stride_windows#305",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.stride_windows(x, n, noverlap=None, axis=0)",
        "snippet": "def stride_windows(x, n, noverlap=None, axis=0):\n    '''\n    Get all windows of x with length n as a single array,\n    using strides to avoid data duplication.\n\n    .. warning::\n\n        It is not safe to write to the output array.  Multiple\n        elements may point to the same piece of memory,\n        so modifying one value may change others.\n\n    Parameters\n    ----------\n    x : 1D array or sequence\n        Array or sequence containing the data.\n\n    n : integer\n        The number of data points in each window.\n\n    noverlap : integer\n        The overlap between adjacent windows.\n        Default is 0 (no overlap)\n\n    axis : integer\n        The axis along which the windows will run.\n\n    References\n    ----------\n    `stackoverflow: Rolling window for 1D arrays in Numpy?\n    <http://stackoverflow.com/a/6811241>`_\n    `stackoverflow: Using strides for an efficient moving average filter\n    <http://stackoverflow.com/a/4947453>`_\n    '''\n    if noverlap is None:\n        noverlap = 0\n\n    if noverlap >= n:\n        raise ValueError('noverlap must be less than n')\n    if n < 1:\n        raise ValueError('n cannot be less than 1')\n\n    x = np.asarray(x)\n\n    if x.ndim != 1:\n        raise ValueError('only 1-dimensional arrays can be used')\n    if n == 1 and noverlap == 0:\n        if axis == 0:\n            return x[np.newaxis]\n        else:\n            return x[np.newaxis].transpose()\n    if n > x.size:\n        raise ValueError('n cannot be greater than the length of x')\n\n    # np.lib.stride_tricks.as_strided easily leads to memory corruption for\n    # non integer shape and strides, i.e. noverlap or n. See #3845.\n    noverlap = int(noverlap)\n    n = int(n)\n\n    step = n - noverlap\n    if axis == 0:\n        shape = (n, (x.shape[-1]-noverlap)//step)\n        strides = (x.strides[0], step*x.strides[0])\n    else:\n        shape = ((x.shape[-1]-noverlap)//step, n)\n        strides = (step*x.strides[0], x.strides[0])\n    return np.lib.stride_tricks.as_strided(x, shape=shape, strides=strides)",
        "begin_line": 305,
        "end_line": 370,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.stride_repeat#374",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.stride_repeat(x, n, axis=0)",
        "snippet": "def stride_repeat(x, n, axis=0):\n    '''\n    Repeat the values in an array in a memory-efficient manner.  Array x is\n    stacked vertically n times.\n\n    .. warning::\n\n        It is not safe to write to the output array.  Multiple\n        elements may point to the same piece of memory, so\n        modifying one value may change others.\n\n    Parameters\n    ----------\n    x : 1D array or sequence\n        Array or sequence containing the data.\n\n    n : integer\n        The number of time to repeat the array.\n\n    axis : integer\n        The axis along which the data will run.\n\n    References\n    ----------\n    `stackoverflow: Repeat NumPy array without replicating data?\n    <http://stackoverflow.com/a/5568169>`_\n    '''\n    if axis not in [0, 1]:\n        raise ValueError('axis must be 0 or 1')\n    x = np.asarray(x)\n    if x.ndim != 1:\n        raise ValueError('only 1-dimensional arrays can be used')\n\n    if n == 1:\n        if axis == 0:\n            return np.atleast_2d(x)\n        else:\n            return np.atleast_2d(x).T\n    if n < 1:\n        raise ValueError('n cannot be less than 1')\n\n    # np.lib.stride_tricks.as_strided easily leads to memory corruption for\n    # non integer shape and strides, i.e. n. See #3845.\n    n = int(n)\n\n    if axis == 0:\n        shape = (n, x.size)\n        strides = (0, x.strides[0])\n    else:\n        shape = (x.size, n)\n        strides = (x.strides[0], 0)\n\n    return np.lib.stride_tricks.as_strided(x, shape=shape, strides=strides)",
        "begin_line": 374,
        "end_line": 426,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab._spectral_helper#429",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab._spectral_helper(x, y=None, NFFT=None, Fs=None, detrend_func=None, window=None, noverlap=None, pad_to=None, sides=None, scale_by_freq=None, mode=None)",
        "snippet": "def _spectral_helper(x, y=None, NFFT=None, Fs=None, detrend_func=None,\n                     window=None, noverlap=None, pad_to=None,\n                     sides=None, scale_by_freq=None, mode=None):\n    '''\n    This is a helper function that implements the commonality between the\n    psd, csd, spectrogram and complex, magnitude, angle, and phase spectrums.\n    It is *NOT* meant to be used outside of mlab and may change at any time.\n    '''\n    if y is None:\n        # if y is None use x for y\n        same_data = True\n    else:\n        # The checks for if y is x are so that we can use the same function to\n        # implement the core of psd(), csd(), and spectrogram() without doing\n        # extra calculations.  We return the unaveraged Pxy, freqs, and t.\n        same_data = y is x\n\n    if Fs is None:\n        Fs = 2\n    if noverlap is None:\n        noverlap = 0\n    if detrend_func is None:\n        detrend_func = detrend_none\n    if window is None:\n        window = window_hanning\n\n    # if NFFT is set to None use the whole signal\n    if NFFT is None:\n        NFFT = 256\n\n    if mode is None or mode == 'default':\n        mode = 'psd'\n    cbook._check_in_list(\n        ['default', 'psd', 'complex', 'magnitude', 'angle', 'phase'],\n        mode=mode)\n\n    if not same_data and mode != 'psd':\n        raise ValueError(\"x and y must be equal if mode is not 'psd'\")\n\n    # Make sure we're dealing with a numpy array. If y and x were the same\n    # object to start with, keep them that way\n    x = np.asarray(x)\n    if not same_data:\n        y = np.asarray(y)\n\n    if sides is None or sides == 'default':\n        if np.iscomplexobj(x):\n            sides = 'twosided'\n        else:\n            sides = 'onesided'\n    cbook._check_in_list(['default', 'onesided', 'twosided'], sides=sides)\n\n    # zero pad x and y up to NFFT if they are shorter than NFFT\n    if len(x) < NFFT:\n        n = len(x)\n        x = np.resize(x, NFFT)\n        x[n:] = 0\n\n    if not same_data and len(y) < NFFT:\n        n = len(y)\n        y = np.resize(y, NFFT)\n        y[n:] = 0\n\n    if pad_to is None:\n        pad_to = NFFT\n\n    if mode != 'psd':\n        scale_by_freq = False\n    elif scale_by_freq is None:\n        scale_by_freq = True\n\n    # For real x, ignore the negative frequencies unless told otherwise\n    if sides == 'twosided':\n        numFreqs = pad_to\n        if pad_to % 2:\n            freqcenter = (pad_to - 1)//2 + 1\n        else:\n            freqcenter = pad_to//2\n        scaling_factor = 1.\n    elif sides == 'onesided':\n        if pad_to % 2:\n            numFreqs = (pad_to + 1)//2\n        else:\n            numFreqs = pad_to//2 + 1\n        scaling_factor = 2.\n\n    if not np.iterable(window):\n        window = window(np.ones(NFFT, x.dtype))\n    if len(window) != NFFT:\n        raise ValueError(\n            \"The window length must match the data's first dimension\")\n\n    result = stride_windows(x, NFFT, noverlap, axis=0)\n    result = detrend(result, detrend_func, axis=0)\n    result = result * window.reshape((-1, 1))\n    result = np.fft.fft(result, n=pad_to, axis=0)[:numFreqs, :]\n    freqs = np.fft.fftfreq(pad_to, 1/Fs)[:numFreqs]\n\n    if not same_data:\n        # if same_data is False, mode must be 'psd'\n        resultY = stride_windows(y, NFFT, noverlap)\n        resultY = detrend(resultY, detrend_func, axis=0)\n        resultY = resultY * window.reshape((-1, 1))\n        resultY = np.fft.fft(resultY, n=pad_to, axis=0)[:numFreqs, :]\n        result = np.conj(result) * resultY\n    elif mode == 'psd':\n        result = np.conj(result) * result\n    elif mode == 'magnitude':\n        result = np.abs(result) / np.abs(window).sum()\n    elif mode == 'angle' or mode == 'phase':\n        # we unwrap the phase later to handle the onesided vs. twosided case\n        result = np.angle(result)\n    elif mode == 'complex':\n        result /= np.abs(window).sum()\n\n    if mode == 'psd':\n\n        # Also include scaling factors for one-sided densities and dividing by\n        # the sampling frequency, if desired. Scale everything, except the DC\n        # component and the NFFT/2 component:\n\n        # if we have a even number of frequencies, don't scale NFFT/2\n        if not NFFT % 2:\n            slc = slice(1, -1, None)\n        # if we have an odd number, just don't scale DC\n        else:\n            slc = slice(1, None, None)\n\n        result[slc] *= scaling_factor\n\n        # MATLAB divides by the sampling frequency so that density function\n        # has units of dB/Hz and can be integrated by the plotted frequency\n        # values. Perform the same scaling here.\n        if scale_by_freq:\n            result /= Fs\n            # Scale the spectrum by the norm of the window to compensate for\n            # windowing loss; see Bendat & Piersol Sec 11.5.2.\n            result /= (np.abs(window)**2).sum()\n        else:\n            # In this case, preserve power in the segment, not amplitude\n            result /= np.abs(window).sum()**2\n\n    t = np.arange(NFFT/2, len(x) - NFFT/2 + 1, NFFT - noverlap)/Fs\n\n    if sides == 'twosided':\n        # center the frequency range at zero\n        freqs = np.concatenate((freqs[freqcenter:], freqs[:freqcenter]))\n        result = np.concatenate((result[freqcenter:, :],\n                                 result[:freqcenter, :]), 0)\n    elif not pad_to % 2:\n        # get the last value correctly, it is negative otherwise\n        freqs[-1] *= -1\n\n    # we unwrap the phase here to handle the onesided vs. twosided case\n    if mode == 'phase':\n        result = np.unwrap(result, axis=0)\n\n    return result, freqs, t",
        "begin_line": 429,
        "end_line": 586,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.34306691139663e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab._single_spectrum_helper#589",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab._single_spectrum_helper(x, mode, Fs=None, window=None, pad_to=None, sides=None)",
        "snippet": "def _single_spectrum_helper(x, mode, Fs=None, window=None, pad_to=None,\n                            sides=None):\n    '''\n    This is a helper function that implements the commonality between the\n    complex, magnitude, angle, and phase spectrums.\n    It is *NOT* meant to be used outside of mlab and may change at any time.\n    '''\n    cbook._check_in_list(['complex', 'magnitude', 'angle', 'phase'], mode=mode)\n\n    if pad_to is None:\n        pad_to = len(x)\n\n    spec, freqs, _ = _spectral_helper(x=x, y=None, NFFT=len(x), Fs=Fs,\n                                      detrend_func=detrend_none, window=window,\n                                      noverlap=0, pad_to=pad_to,\n                                      sides=sides,\n                                      scale_by_freq=False,\n                                      mode=mode)\n    if mode != 'complex':\n        spec = spec.real\n\n    if spec.ndim == 2 and spec.shape[1] == 1:\n        spec = spec[:, 0]\n\n    return spec, freqs",
        "begin_line": 589,
        "end_line": 613,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.602828252109785e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.psd#687",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.psd(x, NFFT=None, Fs=None, detrend=None, window=None, noverlap=None, pad_to=None, sides=None, scale_by_freq=None)",
        "snippet": "def psd(x, NFFT=None, Fs=None, detrend=None, window=None,\n        noverlap=None, pad_to=None, sides=None, scale_by_freq=None):\n    r\"\"\"\n    Compute the power spectral density.\n\n    The power spectral density :math:`P_{xx}` by Welch's average\n    periodogram method.  The vector *x* is divided into *NFFT* length\n    segments.  Each segment is detrended by function *detrend* and\n    windowed by function *window*.  *noverlap* gives the length of\n    the overlap between segments.  The :math:`|\\mathrm{fft}(i)|^2`\n    of each segment :math:`i` are averaged to compute :math:`P_{xx}`.\n\n    If len(*x*) < *NFFT*, it will be zero padded to *NFFT*.\n\n    Parameters\n    ----------\n    x : 1-D array or sequence\n        Array or sequence containing the data\n\n    %(Spectral)s\n\n    %(PSD)s\n\n    noverlap : integer\n        The number of points of overlap between segments.\n        The default value is 0 (no overlap).\n\n    Returns\n    -------\n    Pxx : 1-D array\n        The values for the power spectrum `P_{xx}` (real valued)\n\n    freqs : 1-D array\n        The frequencies corresponding to the elements in *Pxx*\n\n    References\n    ----------\n    Bendat & Piersol -- Random Data: Analysis and Measurement Procedures, John\n    Wiley & Sons (1986)\n\n    See Also\n    --------\n    specgram\n        `specgram` differs in the default overlap; in not returning the mean of\n        the segment periodograms; and in returning the times of the segments.\n\n    magnitude_spectrum : returns the magnitude spectrum.\n\n    csd : returns the spectral density between two signals.\n    \"\"\"\n    Pxx, freqs = csd(x=x, y=None, NFFT=NFFT, Fs=Fs, detrend=detrend,\n                     window=window, noverlap=noverlap, pad_to=pad_to,\n                     sides=sides, scale_by_freq=scale_by_freq)\n    return Pxx.real, freqs",
        "begin_line": 687,
        "end_line": 740,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.576331540268203e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.csd#744",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.csd(x, y, NFFT=None, Fs=None, detrend=None, window=None, noverlap=None, pad_to=None, sides=None, scale_by_freq=None)",
        "snippet": "def csd(x, y, NFFT=None, Fs=None, detrend=None, window=None,\n        noverlap=None, pad_to=None, sides=None, scale_by_freq=None):\n    \"\"\"\n    Compute the cross-spectral density.\n\n    The cross spectral density :math:`P_{xy}` by Welch's average\n    periodogram method.  The vectors *x* and *y* are divided into\n    *NFFT* length segments.  Each segment is detrended by function\n    *detrend* and windowed by function *window*.  *noverlap* gives\n    the length of the overlap between segments.  The product of\n    the direct FFTs of *x* and *y* are averaged over each segment\n    to compute :math:`P_{xy}`, with a scaling to correct for power\n    loss due to windowing.\n\n    If len(*x*) < *NFFT* or len(*y*) < *NFFT*, they will be zero\n    padded to *NFFT*.\n\n    Parameters\n    ----------\n    x, y : 1-D arrays or sequences\n        Arrays or sequences containing the data\n\n    %(Spectral)s\n\n    %(PSD)s\n\n    noverlap : integer\n        The number of points of overlap between segments.\n        The default value is 0 (no overlap).\n\n    Returns\n    -------\n    Pxy : 1-D array\n        The values for the cross spectrum `P_{xy}` before scaling (real valued)\n\n    freqs : 1-D array\n        The frequencies corresponding to the elements in *Pxy*\n\n    References\n    ----------\n    Bendat & Piersol -- Random Data: Analysis and Measurement Procedures, John\n    Wiley & Sons (1986)\n\n    See Also\n    --------\n    psd : equivalent to setting ``y = x``.\n    \"\"\"\n    if NFFT is None:\n        NFFT = 256\n    Pxy, freqs, _ = _spectral_helper(x=x, y=y, NFFT=NFFT, Fs=Fs,\n                                     detrend_func=detrend, window=window,\n                                     noverlap=noverlap, pad_to=pad_to,\n                                     sides=sides, scale_by_freq=scale_by_freq,\n                                     mode='psd')\n\n    if Pxy.ndim == 2:\n        if Pxy.shape[1] > 1:\n            Pxy = Pxy.mean(axis=1)\n        else:\n            Pxy = Pxy[:, 0]\n    return Pxy, freqs",
        "begin_line": 744,
        "end_line": 804,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.800312012480499e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.specgram#970",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.specgram(x, NFFT=None, Fs=None, detrend=None, window=None, noverlap=None, pad_to=None, sides=None, scale_by_freq=None, mode=None)",
        "snippet": "def specgram(x, NFFT=None, Fs=None, detrend=None, window=None,\n             noverlap=None, pad_to=None, sides=None, scale_by_freq=None,\n             mode=None):\n    \"\"\"\n    Compute a spectrogram.\n\n    Compute and plot a spectrogram of data in x.  Data are split into\n    NFFT length segments and the spectrum of each section is\n    computed.  The windowing function window is applied to each\n    segment, and the amount of overlap of each segment is\n    specified with noverlap.\n\n    Parameters\n    ----------\n    x : array-like\n        1-D array or sequence.\n\n    %(Spectral)s\n\n    %(PSD)s\n\n    noverlap : int, optional\n        The number of points of overlap between blocks.  The default\n        value is 128.\n    mode : str, optional\n        What sort of spectrum to use, default is 'psd'.\n            'psd'\n                Returns the power spectral density.\n\n            'complex'\n                Returns the complex-valued frequency spectrum.\n\n            'magnitude'\n                Returns the magnitude spectrum.\n\n            'angle'\n                Returns the phase spectrum without unwrapping.\n\n            'phase'\n                Returns the phase spectrum with unwrapping.\n\n    Returns\n    -------\n    spectrum : array-like\n        2-D array, columns are the periodograms of successive segments.\n\n    freqs : array-like\n        1-D array, frequencies corresponding to the rows in *spectrum*.\n\n    t : array-like\n        1-D array, the times corresponding to midpoints of segments\n        (i.e the columns in *spectrum*).\n\n    See Also\n    --------\n    psd : differs in the overlap and in the return values.\n    complex_spectrum : similar, but with complex valued frequencies.\n    magnitude_spectrum : similar single segment when mode is 'magnitude'.\n    angle_spectrum : similar to single segment when mode is 'angle'.\n    phase_spectrum : similar to single segment when mode is 'phase'.\n\n    Notes\n    -----\n    detrend and scale_by_freq only apply when *mode* is set to 'psd'.\n\n    \"\"\"\n    if noverlap is None:\n        noverlap = 128  # default in _spectral_helper() is noverlap = 0\n    if NFFT is None:\n        NFFT = 256  # same default as in _spectral_helper()\n    if len(x) <= NFFT:\n        cbook._warn_external(\"Only one segment is calculated since parameter \"\n                             \"NFFT (=%d) >= signal length (=%d).\" %\n                             (NFFT, len(x)))\n\n    spec, freqs, t = _spectral_helper(x=x, y=None, NFFT=NFFT, Fs=Fs,\n                                      detrend_func=detrend, window=window,\n                                      noverlap=noverlap, pad_to=pad_to,\n                                      sides=sides,\n                                      scale_by_freq=scale_by_freq,\n                                      mode=mode)\n\n    if mode != 'complex':\n        spec = spec.real  # Needed since helper implements generically\n\n    return spec, freqs, t",
        "begin_line": 970,
        "end_line": 1055,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.575183698204681e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.cohere#1059",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.cohere(x, y, NFFT=256, Fs=2, detrend=detrend_none, window=window_hanning, noverlap=0, pad_to=None, sides='default', scale_by_freq=None)",
        "snippet": "def cohere(x, y, NFFT=256, Fs=2, detrend=detrend_none, window=window_hanning,\n           noverlap=0, pad_to=None, sides='default', scale_by_freq=None):\n    r\"\"\"\n    The coherence between *x* and *y*.  Coherence is the normalized\n    cross spectral density:\n\n    .. math::\n\n        C_{xy} = \\frac{|P_{xy}|^2}{P_{xx}P_{yy}}\n\n    Parameters\n    ----------\n    x, y\n        Array or sequence containing the data\n\n    %(Spectral)s\n\n    %(PSD)s\n\n    noverlap : integer\n        The number of points of overlap between blocks.  The default value\n        is 0 (no overlap).\n\n    Returns\n    -------\n    The return value is the tuple (*Cxy*, *f*), where *f* are the\n    frequencies of the coherence vector. For cohere, scaling the\n    individual densities by the sampling frequency has no effect,\n    since the factors cancel out.\n\n    See Also\n    --------\n    :func:`psd`, :func:`csd` :\n        For information about the methods used to compute :math:`P_{xy}`,\n        :math:`P_{xx}` and :math:`P_{yy}`.\n    \"\"\"\n    if len(x) < 2 * NFFT:\n        raise ValueError(\n            \"Coherence is calculated by averaging over *NFFT* length \"\n            \"segments.  Your signal is too short for your choice of *NFFT*.\")\n    Pxx, f = psd(x, NFFT, Fs, detrend, window, noverlap, pad_to, sides,\n                 scale_by_freq)\n    Pyy, f = psd(y, NFFT, Fs, detrend, window, noverlap, pad_to, sides,\n                 scale_by_freq)\n    Pxy, f = csd(x, y, NFFT, Fs, detrend, window, noverlap, pad_to, sides,\n                 scale_by_freq)\n    Cxy = np.abs(Pxy) ** 2 / (Pxx * Pyy)\n    return Cxy, f",
        "begin_line": 1059,
        "end_line": 1106,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab._csv2rec#1109",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab._csv2rec(fname, comments='#', skiprows=0, checkrows=0, delimiter=',', converterd=None, names=None, missing='', missingd=None, use_mrecords=False, dayfirst=False, yearfirst=False)",
        "snippet": "def _csv2rec(fname, comments='#', skiprows=0, checkrows=0, delimiter=',',\n             converterd=None, names=None, missing='', missingd=None,\n             use_mrecords=False, dayfirst=False, yearfirst=False):\n    \"\"\"\n    Load data from comma/space/tab delimited file in *fname* into a\n    numpy record array and return the record array.\n\n    If *names* is *None*, a header row is required to automatically\n    assign the recarray names.  The headers will be lower cased,\n    spaces will be converted to underscores, and illegal attribute\n    name characters removed.  If *names* is not *None*, it is a\n    sequence of names to use for the column names.  In this case, it\n    is assumed there is no header row.\n\n\n    - *fname*: can be a filename or a file handle.  Support for gzipped\n      files is automatic, if the filename ends in '.gz'\n\n    - *comments*: the character used to indicate the start of a comment\n      in the file, or *None* to switch off the removal of comments\n\n    - *skiprows*: is the number of rows from the top to skip\n\n    - *checkrows*: is the number of rows to check to validate the column\n      data type.  When set to zero all rows are validated.\n\n    - *converterd*: if not *None*, is a dictionary mapping column number or\n      munged column name to a converter function.\n\n    - *names*: if not None, is a list of header names.  In this case, no\n      header will be read from the file\n\n    - *missingd* is a dictionary mapping munged column names to field values\n      which signify that the field does not contain actual data and should\n      be masked, e.g., '0000-00-00' or 'unused'\n\n    - *missing*: a string whose value signals a missing field regardless of\n      the column it appears in\n\n    - *use_mrecords*: if True, return an mrecords.fromrecords record array if\n      any of the data are missing\n\n    - *dayfirst*: default is False so that MM-DD-YY has precedence over\n      DD-MM-YY.  See\n      http://labix.org/python-dateutil#head-b95ce2094d189a89f80f5ae52a05b4ab7b41af47\n      for further information.\n\n    - *yearfirst*: default is False so that MM-DD-YY has precedence over\n      YY-MM-DD. See\n      http://labix.org/python-dateutil#head-b95ce2094d189a89f80f5ae52a05b4ab7b41af47\n      for further information.\n\n      If no rows are found, *None* is returned\n    \"\"\"\n\n    if converterd is None:\n        converterd = dict()\n\n    if missingd is None:\n        missingd = {}\n\n    import dateutil.parser\n    import datetime\n\n    fh = cbook.to_filehandle(fname)\n\n    delimiter = str(delimiter)\n\n    class FH:\n        \"\"\"\n        For space-delimited files, we want different behavior than\n        comma or tab.  Generally, we want multiple spaces to be\n        treated as a single separator, whereas with comma and tab we\n        want multiple commas to return multiple (empty) fields.  The\n        join/strip trick below effects this.\n        \"\"\"\n        def __init__(self, fh):\n            self.fh = fh\n\n        def close(self):\n            self.fh.close()\n\n        def seek(self, arg):\n            self.fh.seek(arg)\n\n        def fix(self, s):\n            return ' '.join(s.split())\n\n        def __next__(self):\n            return self.fix(next(self.fh))\n\n        def __iter__(self):\n            for line in self.fh:\n                yield self.fix(line)\n\n    if delimiter == ' ':\n        fh = FH(fh)\n\n    reader = csv.reader(fh, delimiter=delimiter)\n\n    def process_skiprows(reader):\n        if skiprows:\n            for i, row in enumerate(reader):\n                if i >= (skiprows-1):\n                    break\n\n        return fh, reader\n\n    process_skiprows(reader)\n\n    def ismissing(name, val):\n        \"Should the value val in column name be masked?\"\n        return val == missing or val == missingd.get(name) or val == ''\n\n    def with_default_value(func, default):\n        def newfunc(name, val):\n            if ismissing(name, val):\n                return default\n            else:\n                return func(val)\n        return newfunc\n\n    def mybool(x):\n        if x == 'True':\n            return True\n        elif x == 'False':\n            return False\n        else:\n            raise ValueError('invalid bool')\n\n    dateparser = dateutil.parser.parse\n\n    def mydateparser(x):\n        # try and return a datetime object\n        d = dateparser(x, dayfirst=dayfirst, yearfirst=yearfirst)\n        return d\n\n    mydateparser = with_default_value(mydateparser, datetime.datetime(1, 1, 1))\n\n    myfloat = with_default_value(float, np.nan)\n    myint = with_default_value(int, -1)\n    mystr = with_default_value(str, '')\n    mybool = with_default_value(mybool, None)\n\n    def mydate(x):\n        # try and return a date object\n        d = dateparser(x, dayfirst=dayfirst, yearfirst=yearfirst)\n\n        if d.hour > 0 or d.minute > 0 or d.second > 0:\n            raise ValueError('not a date')\n        return d.date()\n    mydate = with_default_value(mydate, datetime.date(1, 1, 1))\n\n    def get_func(name, item, func):\n        # promote functions in this order\n        funcs = [mybool, myint, myfloat, mydate, mydateparser, mystr]\n        for func in funcs[funcs.index(func):]:\n            try:\n                func(name, item)\n            except Exception:\n                continue\n            return func\n        raise ValueError('Could not find a working conversion function')\n\n    # map column names that clash with builtins -- TODO - extend this list\n    itemd = {\n        'return': 'return_',\n        'file':   'file_',\n        'print':  'print_',\n        }\n\n    def get_converters(reader, comments):\n\n        converters = None\n        i = 0\n        for row in reader:\n            if (len(row) and comments is not None and\n                    row[0].startswith(comments)):\n                continue\n            if i == 0:\n                converters = [mybool]*len(row)\n            if checkrows and i > checkrows:\n                break\n            i += 1\n\n            for j, (name, item) in enumerate(zip(names, row)):\n                func = converterd.get(j)\n                if func is None:\n                    func = converterd.get(name)\n                if func is None:\n                    func = converters[j]\n                    if len(item.strip()):\n                        func = get_func(name, item, func)\n                else:\n                    # how should we handle custom converters and defaults?\n                    func = with_default_value(func, None)\n                converters[j] = func\n        return converters\n\n    # Get header and remove invalid characters\n    needheader = names is None\n\n    if needheader:\n        for row in reader:\n            if (len(row) and comments is not None and\n                    row[0].startswith(comments)):\n                continue\n            headers = row\n            break\n\n        # remove these chars\n        delete = set(r\"\"\"~!@#$%^&*()-=+~\\|}[]{';: /?.>,<\"\"\")\n        delete.add('\"')\n\n        names = []\n        seen = dict()\n        for i, item in enumerate(headers):\n            item = item.strip().lower().replace(' ', '_')\n            item = ''.join([c for c in item if c not in delete])\n            if not len(item):\n                item = 'column%d' % i\n\n            item = itemd.get(item, item)\n            cnt = seen.get(item, 0)\n            if cnt > 0:\n                names.append(item + '_%d' % cnt)\n            else:\n                names.append(item)\n            seen[item] = cnt+1\n\n    else:\n        if isinstance(names, str):\n            names = [n.strip() for n in names.split(',')]\n\n    # get the converter functions by inspecting checkrows\n    converters = get_converters(reader, comments)\n    if converters is None:\n        raise ValueError('Could not find any valid data in CSV file')\n\n    # reset the reader and start over\n    fh.seek(0)\n    reader = csv.reader(fh, delimiter=delimiter)\n    process_skiprows(reader)\n\n    if needheader:\n        while True:\n            # skip past any comments and consume one line of column header\n            row = next(reader)\n            if (len(row) and comments is not None and\n                    row[0].startswith(comments)):\n                continue\n            break\n\n    # iterate over the remaining rows and convert the data to date\n    # objects, ints, or floats as appropriate\n    rows = []\n    rowmasks = []\n    for i, row in enumerate(reader):\n        if not len(row):\n            continue\n        if comments is not None and row[0].startswith(comments):\n            continue\n        # Ensure that the row returned always has the same nr of elements\n        row.extend([''] * (len(converters) - len(row)))\n        rows.append([func(name, val)\n                     for func, name, val in zip(converters, names, row)])\n        rowmasks.append([ismissing(name, val)\n                         for name, val in zip(names, row)])\n    fh.close()\n\n    if not len(rows):\n        return None\n\n    if use_mrecords and np.any(rowmasks):\n        r = np.ma.mrecords.fromrecords(rows, names=names, mask=rowmasks)\n    else:\n        r = np.rec.fromrecords(rows, names=names)\n    return r",
        "begin_line": 1109,
        "end_line": 1386,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.FH._csv2rec#1109",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab.FH",
        "signature": "lib.matplotlib.mlab.FH._csv2rec(fname, comments='#', skiprows=0, checkrows=0, delimiter=',', converterd=None, names=None, missing='', missingd=None, use_mrecords=False, dayfirst=False, yearfirst=False)",
        "snippet": "def _csv2rec(fname, comments='#', skiprows=0, checkrows=0, delimiter=',',\n             converterd=None, names=None, missing='', missingd=None,\n             use_mrecords=False, dayfirst=False, yearfirst=False):\n    \"\"\"\n    Load data from comma/space/tab delimited file in *fname* into a\n    numpy record array and return the record array.\n\n    If *names* is *None*, a header row is required to automatically\n    assign the recarray names.  The headers will be lower cased,\n    spaces will be converted to underscores, and illegal attribute\n    name characters removed.  If *names* is not *None*, it is a\n    sequence of names to use for the column names.  In this case, it\n    is assumed there is no header row.\n\n\n    - *fname*: can be a filename or a file handle.  Support for gzipped\n      files is automatic, if the filename ends in '.gz'\n\n    - *comments*: the character used to indicate the start of a comment\n      in the file, or *None* to switch off the removal of comments\n\n    - *skiprows*: is the number of rows from the top to skip\n\n    - *checkrows*: is the number of rows to check to validate the column\n      data type.  When set to zero all rows are validated.\n\n    - *converterd*: if not *None*, is a dictionary mapping column number or\n      munged column name to a converter function.\n\n    - *names*: if not None, is a list of header names.  In this case, no\n      header will be read from the file\n\n    - *missingd* is a dictionary mapping munged column names to field values\n      which signify that the field does not contain actual data and should\n      be masked, e.g., '0000-00-00' or 'unused'\n\n    - *missing*: a string whose value signals a missing field regardless of\n      the column it appears in\n\n    - *use_mrecords*: if True, return an mrecords.fromrecords record array if\n      any of the data are missing\n\n    - *dayfirst*: default is False so that MM-DD-YY has precedence over\n      DD-MM-YY.  See\n      http://labix.org/python-dateutil#head-b95ce2094d189a89f80f5ae52a05b4ab7b41af47\n      for further information.\n\n    - *yearfirst*: default is False so that MM-DD-YY has precedence over\n      YY-MM-DD. See\n      http://labix.org/python-dateutil#head-b95ce2094d189a89f80f5ae52a05b4ab7b41af47\n      for further information.\n\n      If no rows are found, *None* is returned\n    \"\"\"\n\n    if converterd is None:\n        converterd = dict()\n\n    if missingd is None:\n        missingd = {}\n\n    import dateutil.parser\n    import datetime\n\n    fh = cbook.to_filehandle(fname)\n\n    delimiter = str(delimiter)\n\n    class FH:\n        \"\"\"\n        For space-delimited files, we want different behavior than\n        comma or tab.  Generally, we want multiple spaces to be\n        treated as a single separator, whereas with comma and tab we\n        want multiple commas to return multiple (empty) fields.  The\n        join/strip trick below effects this.\n        \"\"\"\n        def __init__(self, fh):\n            self.fh = fh\n\n        def close(self):\n            self.fh.close()\n\n        def seek(self, arg):\n            self.fh.seek(arg)\n\n        def fix(self, s):\n            return ' '.join(s.split())\n\n        def __next__(self):\n            return self.fix(next(self.fh))\n\n        def __iter__(self):\n            for line in self.fh:\n                yield self.fix(line)\n\n    if delimiter == ' ':\n        fh = FH(fh)\n\n    reader = csv.reader(fh, delimiter=delimiter)\n\n    def process_skiprows(reader):\n        if skiprows:\n            for i, row in enumerate(reader):\n                if i >= (skiprows-1):\n                    break\n\n        return fh, reader\n\n    process_skiprows(reader)\n\n    def ismissing(name, val):\n        \"Should the value val in column name be masked?\"\n        return val == missing or val == missingd.get(name) or val == ''\n\n    def with_default_value(func, default):\n        def newfunc(name, val):\n            if ismissing(name, val):\n                return default\n            else:\n                return func(val)\n        return newfunc\n\n    def mybool(x):\n        if x == 'True':\n            return True\n        elif x == 'False':\n            return False\n        else:\n            raise ValueError('invalid bool')\n\n    dateparser = dateutil.parser.parse\n\n    def mydateparser(x):\n        # try and return a datetime object\n        d = dateparser(x, dayfirst=dayfirst, yearfirst=yearfirst)\n        return d\n\n    mydateparser = with_default_value(mydateparser, datetime.datetime(1, 1, 1))\n\n    myfloat = with_default_value(float, np.nan)\n    myint = with_default_value(int, -1)\n    mystr = with_default_value(str, '')\n    mybool = with_default_value(mybool, None)\n\n    def mydate(x):\n        # try and return a date object\n        d = dateparser(x, dayfirst=dayfirst, yearfirst=yearfirst)\n\n        if d.hour > 0 or d.minute > 0 or d.second > 0:\n            raise ValueError('not a date')\n        return d.date()\n    mydate = with_default_value(mydate, datetime.date(1, 1, 1))\n\n    def get_func(name, item, func):\n        # promote functions in this order\n        funcs = [mybool, myint, myfloat, mydate, mydateparser, mystr]\n        for func in funcs[funcs.index(func):]:\n            try:\n                func(name, item)\n            except Exception:\n                continue\n            return func\n        raise ValueError('Could not find a working conversion function')\n\n    # map column names that clash with builtins -- TODO - extend this list\n    itemd = {\n        'return': 'return_',\n        'file':   'file_',\n        'print':  'print_',\n        }\n\n    def get_converters(reader, comments):\n\n        converters = None\n        i = 0\n        for row in reader:\n            if (len(row) and comments is not None and\n                    row[0].startswith(comments)):\n                continue\n            if i == 0:\n                converters = [mybool]*len(row)\n            if checkrows and i > checkrows:\n                break\n            i += 1\n\n            for j, (name, item) in enumerate(zip(names, row)):\n                func = converterd.get(j)\n                if func is None:\n                    func = converterd.get(name)\n                if func is None:\n                    func = converters[j]\n                    if len(item.strip()):\n                        func = get_func(name, item, func)\n                else:\n                    # how should we handle custom converters and defaults?\n                    func = with_default_value(func, None)\n                converters[j] = func\n        return converters\n\n    # Get header and remove invalid characters\n    needheader = names is None\n\n    if needheader:\n        for row in reader:\n            if (len(row) and comments is not None and\n                    row[0].startswith(comments)):\n                continue\n            headers = row\n            break\n\n        # remove these chars\n        delete = set(r\"\"\"~!@#$%^&*()-=+~\\|}[]{';: /?.>,<\"\"\")\n        delete.add('\"')\n\n        names = []\n        seen = dict()\n        for i, item in enumerate(headers):\n            item = item.strip().lower().replace(' ', '_')\n            item = ''.join([c for c in item if c not in delete])\n            if not len(item):\n                item = 'column%d' % i\n\n            item = itemd.get(item, item)\n            cnt = seen.get(item, 0)\n            if cnt > 0:\n                names.append(item + '_%d' % cnt)\n            else:\n                names.append(item)\n            seen[item] = cnt+1\n\n    else:\n        if isinstance(names, str):\n            names = [n.strip() for n in names.split(',')]\n\n    # get the converter functions by inspecting checkrows\n    converters = get_converters(reader, comments)\n    if converters is None:\n        raise ValueError('Could not find any valid data in CSV file')\n\n    # reset the reader and start over\n    fh.seek(0)\n    reader = csv.reader(fh, delimiter=delimiter)\n    process_skiprows(reader)\n\n    if needheader:\n        while True:\n            # skip past any comments and consume one line of column header\n            row = next(reader)\n            if (len(row) and comments is not None and\n                    row[0].startswith(comments)):\n                continue\n            break\n\n    # iterate over the remaining rows and convert the data to date\n    # objects, ints, or floats as appropriate\n    rows = []\n    rowmasks = []\n    for i, row in enumerate(reader):\n        if not len(row):\n            continue\n        if comments is not None and row[0].startswith(comments):\n            continue\n        # Ensure that the row returned always has the same nr of elements\n        row.extend([''] * (len(converters) - len(row)))\n        rows.append([func(name, val)\n                     for func, name, val in zip(converters, names, row)])\n        rowmasks.append([ismissing(name, val)\n                         for name, val in zip(names, row)])\n    fh.close()\n\n    if not len(rows):\n        return None\n\n    if use_mrecords and np.any(rowmasks):\n        r = np.ma.mrecords.fromrecords(rows, names=names, mask=rowmasks)\n    else:\n        r = np.rec.fromrecords(rows, names=names)\n    return r",
        "begin_line": 1109,
        "end_line": 1386,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.FH.__init__#1185",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab.FH",
        "signature": "lib.matplotlib.mlab.FH.__init__(self, fh)",
        "snippet": "        def __init__(self, fh):\n            self.fh = fh",
        "begin_line": 1185,
        "end_line": 1186,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.667764583513912e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.FH.close#1188",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab.FH",
        "signature": "lib.matplotlib.mlab.FH.close(self)",
        "snippet": "        def close(self):\n            self.fh.close()",
        "begin_line": 1188,
        "end_line": 1189,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.667764583513912e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.FH.fix#1194",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab.FH",
        "signature": "lib.matplotlib.mlab.FH.fix(self, s)",
        "snippet": "        def fix(self, s):\n            return ' '.join(s.split())",
        "begin_line": 1194,
        "end_line": 1195,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.667764583513912e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.FH.__next__#1197",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab.FH",
        "signature": "lib.matplotlib.mlab.FH.__next__(self)",
        "snippet": "        def __next__(self):\n            return self.fix(next(self.fh))",
        "begin_line": 1197,
        "end_line": 1198,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.667764583513912e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.FH.__iter__#1200",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab.FH",
        "signature": "lib.matplotlib.mlab.FH.__iter__(self)",
        "snippet": "        def __iter__(self):\n            for line in self.fh:\n                yield self.fix(line)",
        "begin_line": 1200,
        "end_line": 1202,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.667764583513912e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.process_skiprows#1209",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.process_skiprows(reader)",
        "snippet": "    def process_skiprows(reader):\n        if skiprows:\n            for i, row in enumerate(reader):\n                if i >= (skiprows-1):\n                    break\n\n        return fh, reader",
        "begin_line": 1209,
        "end_line": 1215,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.ismissing#1219",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.ismissing(name, val)",
        "snippet": "    def ismissing(name, val):\n        \"Should the value val in column name be masked?\"\n        return val == missing or val == missingd.get(name) or val == ''",
        "begin_line": 1219,
        "end_line": 1221,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.with_default_value#1223",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.with_default_value(func, default)",
        "snippet": "    def with_default_value(func, default):\n        def newfunc(name, val):\n            if ismissing(name, val):\n                return default\n            else:\n                return func(val)\n        return newfunc",
        "begin_line": 1223,
        "end_line": 1229,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.newfunc#1224",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.newfunc(name, val)",
        "snippet": "        def newfunc(name, val):\n            if ismissing(name, val):\n                return default\n            else:\n                return func(val)",
        "begin_line": 1224,
        "end_line": 1228,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.mybool#1231",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.mybool(x)",
        "snippet": "    def mybool(x):\n        if x == 'True':\n            return True\n        elif x == 'False':\n            return False\n        else:\n            raise ValueError('invalid bool')",
        "begin_line": 1231,
        "end_line": 1237,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.mydateparser#1241",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.mydateparser(x)",
        "snippet": "    def mydateparser(x):\n        # try and return a datetime object\n        d = dateparser(x, dayfirst=dayfirst, yearfirst=yearfirst)\n        return d",
        "begin_line": 1241,
        "end_line": 1244,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.mydate#1253",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.mydate(x)",
        "snippet": "    def mydate(x):\n        # try and return a date object\n        d = dateparser(x, dayfirst=dayfirst, yearfirst=yearfirst)\n\n        if d.hour > 0 or d.minute > 0 or d.second > 0:\n            raise ValueError('not a date')\n        return d.date()",
        "begin_line": 1253,
        "end_line": 1259,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.get_func#1262",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.get_func(name, item, func)",
        "snippet": "    def get_func(name, item, func):\n        # promote functions in this order\n        funcs = [mybool, myint, myfloat, mydate, mydateparser, mystr]\n        for func in funcs[funcs.index(func):]:\n            try:\n                func(name, item)\n            except Exception:\n                continue\n            return func\n        raise ValueError('Could not find a working conversion function')",
        "begin_line": 1262,
        "end_line": 1271,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.get_converters#1280",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.get_converters(reader, comments)",
        "snippet": "    def get_converters(reader, comments):\n\n        converters = None\n        i = 0\n        for row in reader:\n            if (len(row) and comments is not None and\n                    row[0].startswith(comments)):\n                continue\n            if i == 0:\n                converters = [mybool]*len(row)\n            if checkrows and i > checkrows:\n                break\n            i += 1\n\n            for j, (name, item) in enumerate(zip(names, row)):\n                func = converterd.get(j)\n                if func is None:\n                    func = converterd.get(name)\n                if func is None:\n                    func = converters[j]\n                    if len(item.strip()):\n                        func = get_func(name, item, func)\n                else:\n                    # how should we handle custom converters and defaults?\n                    func = with_default_value(func, None)\n                converters[j] = func\n        return converters",
        "begin_line": 1280,
        "end_line": 1306,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.GaussianKDE.__init__#1441",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab.GaussianKDE",
        "signature": "lib.matplotlib.mlab.GaussianKDE.__init__(self, dataset, bw_method=None)",
        "snippet": "    def __init__(self, dataset, bw_method=None):\n        self.dataset = np.atleast_2d(dataset)\n        if not np.array(self.dataset).size > 1:\n            raise ValueError(\"`dataset` input should have multiple elements.\")\n\n        self.dim, self.num_dp = np.array(self.dataset).shape\n\n        if bw_method is None:\n            pass\n        elif cbook._str_equal(bw_method, 'scott'):\n            self.covariance_factor = self.scotts_factor\n        elif cbook._str_equal(bw_method, 'silverman'):\n            self.covariance_factor = self.silverman_factor\n        elif isinstance(bw_method, Number):\n            self._bw_method = 'use constant'\n            self.covariance_factor = lambda: bw_method\n        elif callable(bw_method):\n            self._bw_method = bw_method\n            self.covariance_factor = lambda: self._bw_method(self)\n        else:\n            raise ValueError(\"`bw_method` should be 'scott', 'silverman', a \"\n                             \"scalar or a callable\")\n\n        # Computes the covariance matrix for each Gaussian kernel using\n        # covariance_factor().\n\n        self.factor = self.covariance_factor()\n        # Cache covariance and inverse covariance of the data\n        if not hasattr(self, '_data_inv_cov'):\n            self.data_covariance = np.atleast_2d(\n                np.cov(\n                    self.dataset,\n                    rowvar=1,\n                    bias=False))\n            self.data_inv_cov = np.linalg.inv(self.data_covariance)\n\n        self.covariance = self.data_covariance * self.factor ** 2\n        self.inv_cov = self.data_inv_cov / self.factor ** 2\n        self.norm_factor = (np.sqrt(np.linalg.det(2 * np.pi * self.covariance))\n                            * self.num_dp)",
        "begin_line": 1441,
        "end_line": 1480,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.87959971633441e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mlab.GaussianKDE.evaluate#1492",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab.GaussianKDE",
        "signature": "lib.matplotlib.mlab.GaussianKDE.evaluate(self, points)",
        "snippet": "    def evaluate(self, points):\n        \"\"\"Evaluate the estimated pdf on a set of points.\n\n        Parameters\n        ----------\n        points : (# of dimensions, # of points)-array\n            Alternatively, a (# of dimensions,) vector can be passed in and\n            treated as a single point.\n\n        Returns\n        -------\n        values : (# of points,)-array\n            The values at each point.\n\n        Raises\n        ------\n        ValueError : if the dimensionality of the input points is different\n                     than the dimensionality of the KDE.\n\n        \"\"\"\n        points = np.atleast_2d(points)\n\n        dim, num_m = np.array(points).shape\n        if dim != self.dim:\n            raise ValueError(\"points have dimension {}, dataset has dimension \"\n                             \"{}\".format(dim, self.dim))\n\n        result = np.zeros(num_m)\n\n        if num_m >= self.num_dp:\n            # there are more points than data, so loop over data\n            for i in range(self.num_dp):\n                diff = self.dataset[:, i, np.newaxis] - points\n                tdiff = np.dot(self.inv_cov, diff)\n                energy = np.sum(diff * tdiff, axis=0) / 2.0\n                result = result + np.exp(-energy)\n        else:\n            # loop over points\n            for i in range(num_m):\n                diff = self.dataset - points[:, i, np.newaxis]\n                tdiff = np.dot(self.inv_cov, diff)\n                energy = np.sum(diff * tdiff, axis=0) / 2.0\n                result[i] = np.sum(np.exp(-energy), axis=0)\n\n        result = result / self.norm_factor\n\n        return result",
        "begin_line": 1492,
        "end_line": 1538,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023353573096683791,
            "pseudo_dstar_susp": 0.0002205071664829107,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0002205071664829107,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.textpath.TextToPath.__init__#24",
        "src_path": "lib/matplotlib/textpath.py",
        "class_name": "lib.matplotlib.textpath.TextToPath",
        "signature": "lib.matplotlib.textpath.TextToPath.__init__(self)",
        "snippet": "    def __init__(self):\n        self.mathtext_parser = MathTextParser('path')\n        self._texmanager = None",
        "begin_line": 24,
        "end_line": 26,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02040816326530612,
            "pseudo_dstar_susp": 0.01818181818181818,
            "pseudo_tarantula_susp": 0.00036589828027808267,
            "pseudo_op2_susp": 0.01818181818181818,
            "pseudo_barinel_susp": 0.00036589828027808267
        }
    },
    {
        "name": "lib.matplotlib.dviread.PsfontsMap.__new__#804",
        "src_path": "lib/matplotlib/dviread.py",
        "class_name": "lib.matplotlib.dviread.PsfontsMap",
        "signature": "lib.matplotlib.dviread.PsfontsMap.__new__(cls, filename)",
        "snippet": "    def __new__(cls, filename):\n        self = object.__new__(cls)\n        self._font = {}\n        self._filename = os.fsdecode(filename)\n        with open(filename, 'rb') as file:\n            self._parse(file)\n        return self",
        "begin_line": 804,
        "end_line": 810,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.dviread.PsfontsMap.__getitem__#812",
        "src_path": "lib/matplotlib/dviread.py",
        "class_name": "lib.matplotlib.dviread.PsfontsMap",
        "signature": "lib.matplotlib.dviread.PsfontsMap.__getitem__(self, texname)",
        "snippet": "    def __getitem__(self, texname):\n        assert isinstance(texname, bytes)\n        try:\n            result = self._font[texname]\n        except KeyError:\n            fmt = ('A PostScript file for the font whose TeX name is \"{0}\" '\n                   'could not be found in the file \"{1}\". The dviread module '\n                   'can only handle fonts that have an associated PostScript '\n                   'font file. '\n                   'This problem can often be solved by installing '\n                   'a suitable PostScript font package in your (TeX) '\n                   'package manager.')\n            msg = fmt.format(texname.decode('ascii'), self._filename)\n            msg = textwrap.fill(msg, break_on_hyphens=False,\n                                break_long_words=False)\n            _log.info(msg)\n            raise\n        fn, enc = result.filename, result.encoding\n        if fn is not None and not fn.startswith(b'/'):\n            fn = find_tex_file(fn)\n        if enc is not None and not enc.startswith(b'/'):\n            enc = find_tex_file(result.encoding)\n        return result._replace(filename=fn, encoding=enc)",
        "begin_line": 812,
        "end_line": 834,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.dviread.PsfontsMap._parse#836",
        "src_path": "lib/matplotlib/dviread.py",
        "class_name": "lib.matplotlib.dviread.PsfontsMap",
        "signature": "lib.matplotlib.dviread.PsfontsMap._parse(self, file)",
        "snippet": "    def _parse(self, file):\n        \"\"\"\n        Parse the font mapping file.\n\n        The format is, AFAIK: texname fontname [effects and filenames]\n        Effects are PostScript snippets like \".177 SlantFont\",\n        filenames begin with one or two less-than signs. A filename\n        ending in enc is an encoding file, other filenames are font\n        files. This can be overridden with a left bracket: <[foobar\n        indicates an encoding file named foobar.\n\n        There is some difference between <foo.pfb and <<bar.pfb in\n        subsetting, but I have no example of << in my TeX installation.\n        \"\"\"\n        # If the map file specifies multiple encodings for a font, we\n        # follow pdfTeX in choosing the last one specified. Such\n        # entries are probably mistakes but they have occurred.\n        # http://tex.stackexchange.com/questions/10826/\n        # http://article.gmane.org/gmane.comp.tex.pdftex/4914\n\n        empty_re = re.compile(br'%|\\s*$')\n        word_re = re.compile(\n            br'''(?x) (?:\n                 \"<\\[ (?P<enc1>  [^\"]+    )\" | # quoted encoding marked by [\n                 \"<   (?P<enc2>  [^\"]+.enc)\" | # quoted encoding, ends in .enc\n                 \"<<? (?P<file1> [^\"]+    )\" | # quoted font file name\n                 \"    (?P<eff1>  [^\"]+    )\" | # quoted effects or font name\n                 <\\[  (?P<enc3>  \\S+      )  | # encoding marked by [\n                 <    (?P<enc4>  \\S+  .enc)  | # encoding, ends in .enc\n                 <<?  (?P<file2> \\S+      )  | # font file name\n                      (?P<eff2>  \\S+      )    # effects or font name\n            )''')\n        effects_re = re.compile(\n            br'''(?x) (?P<slant> -?[0-9]*(?:\\.[0-9]+)) \\s* SlantFont\n                    | (?P<extend>-?[0-9]*(?:\\.[0-9]+)) \\s* ExtendFont''')\n\n        lines = (line.strip()\n                 for line in file\n                 if not empty_re.match(line))\n        for line in lines:\n            effects, encoding, filename = b'', None, None\n            words = word_re.finditer(line)\n\n            # The named groups are mutually exclusive and are\n            # referenced below at an estimated order of probability of\n            # occurrence based on looking at my copy of pdftex.map.\n            # The font names are probably unquoted:\n            w = next(words)\n            texname = w.group('eff2') or w.group('eff1')\n            w = next(words)\n            psname = w.group('eff2') or w.group('eff1')\n\n            for w in words:\n                # Any effects are almost always quoted:\n                eff = w.group('eff1') or w.group('eff2')\n                if eff:\n                    effects = eff\n                    continue\n                # Encoding files usually have the .enc suffix\n                # and almost never need quoting:\n                enc = (w.group('enc4') or w.group('enc3') or\n                       w.group('enc2') or w.group('enc1'))\n                if enc:\n                    if encoding is not None:\n                        _log.debug('Multiple encodings for %s = %s',\n                                   texname, psname)\n                    encoding = enc\n                    continue\n                # File names are probably unquoted:\n                filename = w.group('file2') or w.group('file1')\n\n            effects_dict = {}\n            for match in effects_re.finditer(effects):\n                slant = match.group('slant')\n                if slant:\n                    effects_dict['slant'] = float(slant)\n                else:\n                    effects_dict['extend'] = float(match.group('extend'))\n\n            self._font[texname] = PsFont(\n                texname=texname, psname=psname, effects=effects_dict,\n                encoding=encoding, filename=filename)",
        "begin_line": 836,
        "end_line": 917,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._reset_locator_formatter_scale#620",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._reset_locator_formatter_scale(self)",
        "snippet": "    def _reset_locator_formatter_scale(self):\n        \"\"\"\n        Reset the locator et al to defaults.  Any user-hardcoded changes\n        need to be re-entered if this gets called (either at init, or when\n        the mappable normal gets changed: Colorbar.update_normal)\n        \"\"\"\n        self.locator = None\n        self.formatter = None\n        if (isinstance(self.norm, colors.LogNorm)):\n            # *both* axes are made log so that determining the\n            # mid point is easier.\n            self.ax.set_xscale('log')\n            self.ax.set_yscale('log')\n            self.minorticks_on()\n        else:\n            self.ax.set_xscale('linear')\n            self.ax.set_yscale('linear')",
        "begin_line": 620,
        "end_line": 636,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019179133103183735,
            "pseudo_dstar_susp": 0.00021303792074989347,
            "pseudo_tarantula_susp": 0.00017739932588256165,
            "pseudo_op2_susp": 0.00021303792074989347,
            "pseudo_barinel_susp": 0.00017739932588256165
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase.update_ticks#638",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase.update_ticks(self)",
        "snippet": "    def update_ticks(self):\n        \"\"\"\n        Force the update of the ticks and ticklabels. This must be\n        called whenever the tick locator and/or tick formatter changes.\n        \"\"\"\n        ax = self.ax\n        # Get the locator and formatter; defaults to self.locator if not None.\n        locator, formatter = self._get_ticker_locator_formatter()\n        long_axis = ax.yaxis if self.orientation == 'vertical' else ax.xaxis\n        if self._use_auto_colorbar_locator():\n            _log.debug('Using auto colorbar locator on colorbar')\n            _log.debug('locator: %r', locator)\n            long_axis.set_major_locator(locator)\n            long_axis.set_major_formatter(formatter)\n        else:\n            _log.debug('Using fixed locator on colorbar')\n            ticks, ticklabels, offset_string = self._ticker(locator, formatter)\n            long_axis.set_ticks(ticks)\n            long_axis.set_ticklabels(ticklabels)\n            long_axis.get_major_formatter().set_offset_string(offset_string)",
        "begin_line": 638,
        "end_line": 657,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019091256204658267,
            "pseudo_dstar_susp": 0.00019817677368212446,
            "pseudo_tarantula_susp": 0.0001904036557501904,
            "pseudo_op2_susp": 0.00019817677368212446,
            "pseudo_barinel_susp": 0.0001904036557501904
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._config_axes#733",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._config_axes(self, X, Y)",
        "snippet": "    def _config_axes(self, X, Y):\n        '''\n        Make an axes patch and outline.\n        '''\n        ax = self.ax\n        ax.set_frame_on(False)\n        ax.set_navigate(False)\n        xy = self._outline(X, Y)\n        ax.ignore_existing_data_limits = True\n        ax.update_datalim(xy)\n        ax.set_xlim(*ax.dataLim.intervalx)\n        ax.set_ylim(*ax.dataLim.intervaly)\n        if self.outline is not None:\n            self.outline.remove()\n        self.outline = mpatches.Polygon(\n            xy, edgecolor=mpl.rcParams['axes.edgecolor'],\n            facecolor='none',\n            linewidth=mpl.rcParams['axes.linewidth'],\n            closed=True,\n            zorder=2)\n        ax.add_artist(self.outline)\n        self.outline.set_clip_box(None)\n        self.outline.set_clip_path(None)\n        c = mpl.rcParams['axes.facecolor']\n        if self.patch is not None:\n            self.patch.remove()\n        self.patch = mpatches.Polygon(xy, edgecolor=c,\n                                      facecolor=c,\n                                      linewidth=0.01,\n                                      zorder=-1)\n        ax.add_artist(self.patch)\n\n        self.update_ticks()",
        "begin_line": 733,
        "end_line": 765,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022471910112359551,
            "pseudo_dstar_susp": 0.00020855057351407716,
            "pseudo_tarantula_susp": 0.00029859659599880563,
            "pseudo_op2_susp": 0.00020855057351407716,
            "pseudo_barinel_susp": 0.00029850746268656717
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._add_solids#805",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._add_solids(self, X, Y, C)",
        "snippet": "    def _add_solids(self, X, Y, C):\n        '''\n        Draw the colors using :meth:`~matplotlib.axes.Axes.pcolormesh`;\n        optionally add separators.\n        '''\n        if self.orientation == 'vertical':\n            args = (X, Y, C)\n        else:\n            args = (np.transpose(Y), np.transpose(X), np.transpose(C))\n        kw = dict(cmap=self.cmap,\n                  norm=self.norm,\n                  alpha=self.alpha,\n                  edgecolors='None')\n        _log.debug('Setting pcolormesh')\n        col = self.ax.pcolormesh(*args, **kw)\n        # self.add_observer(col) # We should observe, not be observed...\n\n        if self.solids is not None:\n            self.solids.remove()\n        self.solids = col\n        if self.dividers is not None:\n            self.dividers.remove()\n            self.dividers = None\n        if self.drawedges:\n            linewidths = (0.5 * mpl.rcParams['axes.linewidth'],)\n            self.dividers = collections.LineCollection(\n                    self._edges(X, Y),\n                    colors=(mpl.rcParams['axes.edgecolor'],),\n                    linewidths=linewidths)\n            self.ax.add_collection(self.dividers)\n        elif len(self._y) >= self.n_rasterize:\n            self.solids.set_rasterized(True)",
        "begin_line": 805,
        "end_line": 836,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018656716417910448,
            "pseudo_dstar_susp": 0.00021281123643328368,
            "pseudo_tarantula_susp": 0.00017009695526450075,
            "pseudo_op2_susp": 0.00021281123643328368,
            "pseudo_barinel_susp": 0.00017009695526450075
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._process_values#901",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._process_values(self, b=None)",
        "snippet": "    def _process_values(self, b=None):\n        '''\n        Set the :attr:`_boundaries` and :attr:`_values` attributes\n        based on the input boundaries and values.  Input boundaries\n        can be *self.boundaries* or the argument *b*.\n        '''\n        if b is None:\n            b = self.boundaries\n        if b is not None:\n            self._boundaries = np.asarray(b, dtype=float)\n            if self.values is None:\n                self._values = 0.5 * (self._boundaries[:-1]\n                                      + self._boundaries[1:])\n                if isinstance(self.norm, colors.NoNorm):\n                    self._values = (self._values + 0.00001).astype(np.int16)\n            else:\n                self._values = np.array(self.values)\n            return\n        if self.values is not None:\n            self._values = np.array(self.values)\n            if self.boundaries is None:\n                b = np.zeros(len(self.values) + 1)\n                b[1:-1] = 0.5 * (self._values[:-1] + self._values[1:])\n                b[0] = 2.0 * b[1] - b[2]\n                b[-1] = 2.0 * b[-2] - b[-3]\n                self._boundaries = b\n                return\n            self._boundaries = np.array(self.boundaries)\n            return\n        # Neither boundaries nor values are specified;\n        # make reasonable ones based on cmap and norm.\n        if isinstance(self.norm, colors.NoNorm):\n            b = self._uniform_y(self.cmap.N + 1) * self.cmap.N - 0.5\n            v = np.zeros(len(b) - 1, dtype=np.int16)\n            v[self._inside] = np.arange(self.cmap.N, dtype=np.int16)\n            if self._extend_lower():\n                v[0] = -1\n            if self._extend_upper():\n                v[-1] = self.cmap.N\n            self._boundaries = b\n            self._values = v\n            return\n        elif isinstance(self.norm, colors.BoundaryNorm):\n            b = list(self.norm.boundaries)\n            if self._extend_lower():\n                b = [b[0] - 1] + b\n            if self._extend_upper():\n                b = b + [b[-1] + 1]\n            b = np.array(b)\n            v = np.zeros(len(b) - 1)\n            bi = self.norm.boundaries\n            v[self._inside] = 0.5 * (bi[:-1] + bi[1:])\n            if self._extend_lower():\n                v[0] = b[0] - 1\n            if self._extend_upper():\n                v[-1] = b[-1] + 1\n            self._boundaries = b\n            self._values = v\n            return\n        else:\n            if not self.norm.scaled():\n                self.norm.vmin = 0\n                self.norm.vmax = 1\n\n            self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n                self.norm.vmin,\n                self.norm.vmax,\n                expander=0.1)\n\n            b = self.norm.inverse(self._uniform_y(self.cmap.N + 1))\n\n            if isinstance(self.norm, (colors.PowerNorm, colors.LogNorm)):\n                # If using a lognorm or powernorm, ensure extensions don't\n                # go negative\n                if self._extend_lower():\n                    b[0] = 0.9 * b[0]\n                if self._extend_upper():\n                    b[-1] = 1.1 * b[-1]\n            else:\n                if self._extend_lower():\n                    b[0] = b[0] - 1\n                if self._extend_upper():\n                    b[-1] = b[-1] + 1\n        self._process_values(b)",
        "begin_line": 901,
        "end_line": 984,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.03793907242183e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._central_N#995",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._central_N(self)",
        "snippet": "    def _central_N(self):\n        \"\"\"Return the number of boundaries excluding end extensions.\"\"\"\n        nb = len(self._boundaries)\n        if self.extend == 'both':\n            nb -= 2\n        elif self.extend in ('min', 'max'):\n            nb -= 1\n        return nb",
        "begin_line": 995,
        "end_line": 1002,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019308746862328635,
            "pseudo_dstar_susp": 0.00021542438604049978,
            "pseudo_tarantula_susp": 0.00017618040873854828,
            "pseudo_op2_susp": 0.00021542438604049978,
            "pseudo_barinel_susp": 0.00017618040873854828
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._uniform_y#1041",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._uniform_y(self, N)",
        "snippet": "    def _uniform_y(self, N):\n        '''\n        Return colorbar data coordinates for *N* uniformly\n        spaced boundaries, plus ends if required.\n        '''\n        if self.extend == 'neither':\n            y = np.linspace(0, 1, N)\n        else:\n            automin = automax = 1. / (N - 1.)\n            extendlength = self._get_extension_lengths(self.extendfrac,\n                                                       automin, automax,\n                                                       default=0.05)\n            if self.extend == 'both':\n                y = np.zeros(N + 2, 'd')\n                y[0] = 0. - extendlength[0]\n                y[-1] = 1. + extendlength[1]\n            elif self.extend == 'min':\n                y = np.zeros(N + 1, 'd')\n                y[0] = 0. - extendlength[0]\n            else:\n                y = np.zeros(N + 1, 'd')\n                y[-1] = 1. + extendlength[1]\n            y[self._inside] = np.linspace(0, 1, N)\n        return y",
        "begin_line": 1041,
        "end_line": 1064,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001257071024512885,
            "pseudo_dstar_susp": 0.0001350621285791464,
            "pseudo_tarantula_susp": 0.000129315918789603,
            "pseudo_op2_susp": 0.0001350621285791464,
            "pseudo_barinel_susp": 0.000129315918789603
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._proportional_y#1066",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._proportional_y(self)",
        "snippet": "    def _proportional_y(self):\n        '''\n        Return colorbar data coordinates for the boundaries of\n        a proportional colorbar.\n        '''\n        if isinstance(self.norm, colors.BoundaryNorm):\n            y = (self._boundaries - self._boundaries[0])\n            y = y / (self._boundaries[-1] - self._boundaries[0])\n        else:\n            y = self.norm(self._boundaries.copy())\n            y = np.ma.filled(y, np.nan)\n        if self.extend == 'min':\n            # Exclude leftmost interval of y.\n            clen = y[-1] - y[1]\n            automin = (y[2] - y[1]) / clen\n            automax = (y[-1] - y[-2]) / clen\n        elif self.extend == 'max':\n            # Exclude rightmost interval in y.\n            clen = y[-2] - y[0]\n            automin = (y[1] - y[0]) / clen\n            automax = (y[-2] - y[-3]) / clen\n        elif self.extend == 'both':\n            # Exclude leftmost and rightmost intervals in y.\n            clen = y[-2] - y[1]\n            automin = (y[2] - y[1]) / clen\n            automax = (y[-2] - y[-3]) / clen\n        if self.extend in ('both', 'min', 'max'):\n            extendlength = self._get_extension_lengths(self.extendfrac,\n                                                       automin, automax,\n                                                       default=0.05)\n        if self.extend in ('both', 'min'):\n            y[0] = 0. - extendlength[0]\n        if self.extend in ('both', 'max'):\n            y[-1] = 1. + extendlength[1]\n        yi = y[self._inside]\n        norm = colors.Normalize(yi[0], yi[-1])\n        y[self._inside] = np.ma.filled(norm(yi), np.nan)\n        return y",
        "begin_line": 1066,
        "end_line": 1103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._mesh#1105",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._mesh(self)",
        "snippet": "    def _mesh(self):\n        '''\n        Return ``(X, Y)``, the coordinate arrays for the colorbar pcolormesh.\n        These are suitable for a vertical colorbar; swapping and transposition\n        for a horizontal colorbar are done outside this function.\n\n        These are scaled between vmin and vmax.\n        '''\n        # copy the norm and change the vmin and vmax to the vmin and\n        # vmax of the colorbar, not the norm.  This allows the situation\n        # where the colormap has a narrower range than the colorbar, to\n        # accomodate extra contours:\n        norm = copy.copy(self.norm)\n        norm.vmin = self.vmin\n        norm.vmax = self.vmax\n        x = np.array([0.0, 1.0])\n        if self.spacing == 'uniform':\n            y = self._uniform_y(self._central_N())\n        else:\n            y = self._proportional_y()\n        xmid = np.array([0.5])\n        try:\n            y = norm.inverse(y)\n            x = norm.inverse(x)\n            xmid = norm.inverse(xmid)\n        except ValueError:\n            # occurs for norms that don't have an inverse, in\n            # which case manually scale:\n            dv = self.vmax - self.vmin\n            x = x * dv + self.vmin\n            y = y * dv + self.vmin\n            xmid = xmid * dv + self.vmin\n        self._y = y\n        X, Y = np.meshgrid(x, y)\n        if self._extend_lower() and not self.extendrect:\n            X[0, :] = xmid\n        if self._extend_upper() and not self.extendrect:\n            X[-1, :] = xmid\n        return X, Y",
        "begin_line": 1105,
        "end_line": 1143,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019584802193497845,
            "pseudo_dstar_susp": 0.00021547080370609782,
            "pseudo_tarantula_susp": 0.00017917935853789643,
            "pseudo_op2_susp": 0.00021547080370609782,
            "pseudo_barinel_susp": 0.00017917935853789643
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._locate#1145",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._locate(self, x)",
        "snippet": "    def _locate(self, x):\n        '''\n        Given a set of color data values, return their\n        corresponding colorbar data coordinates.\n        '''\n        if isinstance(self.norm, (colors.NoNorm, colors.BoundaryNorm)):\n            b = self._boundaries\n            xn = x\n        else:\n            # Do calculations using normalized coordinates so\n            # as to make the interpolation more accurate.\n            b = self.norm(self._boundaries, clip=False).filled()\n            xn = self.norm(x, clip=False).filled()\n\n        bunique = b\n        yunique = self._y\n        # trim extra b values at beginning and end if they are\n        # not unique.  These are here for extended colorbars, and are not\n        # wanted for the interpolation.\n        if b[0] == b[1]:\n            bunique = bunique[1:]\n            yunique = yunique[1:]\n        if b[-1] == b[-2]:\n            bunique = bunique[:-1]\n            yunique = yunique[:-1]\n\n        z = np.interp(xn, bunique, yunique)\n        return z",
        "begin_line": 1145,
        "end_line": 1172,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.0001505797319680771,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0001505797319680771,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase.remove#1177",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase.remove(self)",
        "snippet": "    def remove(self):\n        \"\"\"\n        Remove this colorbar from the figure\n        \"\"\"\n\n        fig = self.ax.figure\n        fig.delaxes(self.ax)",
        "begin_line": 1177,
        "end_line": 1183,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colorbar.Colorbar.__init__#1198",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.Colorbar",
        "signature": "lib.matplotlib.colorbar.Colorbar.__init__(self, ax, mappable, **kw)",
        "snippet": "    def __init__(self, ax, mappable, **kw):\n        # Ensure the given mappable's norm has appropriate vmin and vmax set\n        # even if mappable.draw has not yet been called.\n        if mappable.get_array() is not None:\n            mappable.autoscale_None()\n\n        self.mappable = mappable\n        kw['cmap'] = cmap = mappable.cmap\n        kw['norm'] = mappable.norm\n\n        if isinstance(mappable, contour.ContourSet):\n            CS = mappable\n            kw['alpha'] = mappable.get_alpha()\n            kw['boundaries'] = CS._levels\n            kw['values'] = CS.cvalues\n            kw['extend'] = CS.extend\n            kw.setdefault('ticks', ticker.FixedLocator(CS.levels, nbins=10))\n            kw['filled'] = CS.filled\n            ColorbarBase.__init__(self, ax, **kw)\n            if not CS.filled:\n                self.add_lines(CS)\n        else:\n            if getattr(cmap, 'colorbar_extend', False) is not False:\n                kw.setdefault('extend', cmap.colorbar_extend)\n\n            if isinstance(mappable, martist.Artist):\n                kw['alpha'] = mappable.get_alpha()\n\n            ColorbarBase.__init__(self, ax, **kw)",
        "begin_line": 1198,
        "end_line": 1226,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019402405898331392,
            "pseudo_dstar_susp": 0.00021312872975277067,
            "pseudo_tarantula_susp": 0.0001847063169560399,
            "pseudo_op2_susp": 0.00021312872975277067,
            "pseudo_barinel_susp": 0.0001847063169560399
        }
    },
    {
        "name": "lib.matplotlib.colorbar.Colorbar.on_mappable_changed#1228",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.Colorbar",
        "signature": "lib.matplotlib.colorbar.Colorbar.on_mappable_changed(self, mappable)",
        "snippet": "    def on_mappable_changed(self, mappable):\n        \"\"\"\n        Updates this colorbar to match the mappable's properties.\n\n        Typically this is automatically registered as an event handler\n        by :func:`colorbar_factory` and should not be called manually.\n\n        \"\"\"\n        _log.debug('colorbar mappable changed')\n        self.update_normal(mappable)",
        "begin_line": 1228,
        "end_line": 1237,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colorbar.Colorbar.update_normal#1261",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.Colorbar",
        "signature": "lib.matplotlib.colorbar.Colorbar.update_normal(self, mappable)",
        "snippet": "    def update_normal(self, mappable):\n        \"\"\"\n        Update solid patches, lines, etc.\n\n        Unlike `.update_bruteforce`, this does not clear the axes.  This is\n        meant to be called when the norm of the image or contour plot to which\n        this colorbar belongs changes.\n\n        If the norm on the mappable is different than before, this resets the\n        locator and formatter for the axis, so if these have been customized,\n        they will need to be customized again.  However, if the norm only\n        changes values of *vmin*, *vmax* or *cmap* then the old formatter\n        and locator will be preserved.\n        \"\"\"\n\n        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n        self.mappable = mappable\n        self.set_alpha(mappable.get_alpha())\n        self.cmap = mappable.cmap\n        if mappable.norm != self.norm:\n            self.norm = mappable.norm\n            self._reset_locator_formatter_scale()\n\n        self.draw_all()\n        if isinstance(self.mappable, contour.ContourSet):\n            CS = self.mappable\n            if not CS.filled:\n                self.add_lines(CS)\n        self.stale = True",
        "begin_line": 1261,
        "end_line": 1289,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011625203441060219,
            "pseudo_dstar_susp": 0.00011492931846914148,
            "pseudo_tarantula_susp": 0.00012138868657441127,
            "pseudo_op2_susp": 0.00011492931846914148,
            "pseudo_barinel_susp": 0.00012134449702705982
        }
    },
    {
        "name": "lib.matplotlib.colorbar.make_axes#1357",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar",
        "signature": "lib.matplotlib.colorbar.make_axes(parents, location=None, orientation=None, fraction=0.15, shrink=1.0, aspect=20, **kw)",
        "snippet": "def make_axes(parents, location=None, orientation=None, fraction=0.15,\n              shrink=1.0, aspect=20, **kw):\n    '''\n    Resize and reposition parent axes, and return a child\n    axes suitable for a colorbar.\n\n    Keyword arguments may include the following (with defaults):\n\n        location : [None|'left'|'right'|'top'|'bottom']\n            The position, relative to **parents**, where the colorbar axes\n            should be created. If None, the value will either come from the\n            given ``orientation``, else it will default to 'right'.\n\n        orientation :  [None|'vertical'|'horizontal']\n            The orientation of the colorbar. Typically, this keyword shouldn't\n            be used, as it can be derived from the ``location`` keyword.\n\n    %s\n\n    Returns (cax, kw), the child axes and the reduced kw dictionary to be\n    passed when creating the colorbar instance.\n    '''\n\n    locations = [\"left\", \"right\", \"top\", \"bottom\"]\n    if orientation is not None and location is not None:\n        raise TypeError('position and orientation are mutually exclusive. '\n                        'Consider setting the position to any of {}'\n                        .format(', '.join(locations)))\n\n    # provide a default location\n    if location is None and orientation is None:\n        location = 'right'\n\n    # allow the user to not specify the location by specifying the\n    # orientation instead\n    if location is None:\n        location = 'right' if orientation == 'vertical' else 'bottom'\n\n    cbook._check_in_list(locations, location=location)\n\n    default_location_settings = {'left':   {'anchor': (1.0, 0.5),\n                                            'panchor': (0.0, 0.5),\n                                            'pad': 0.10,\n                                            'orientation': 'vertical'},\n                                 'right':  {'anchor': (0.0, 0.5),\n                                            'panchor': (1.0, 0.5),\n                                            'pad': 0.05,\n                                            'orientation': 'vertical'},\n                                 'top':    {'anchor': (0.5, 0.0),\n                                            'panchor': (0.5, 1.0),\n                                            'pad': 0.05,\n                                            'orientation': 'horizontal'},\n                                 'bottom': {'anchor': (0.5, 1.0),\n                                            'panchor': (0.5, 0.0),\n                                            'pad': 0.15,  # backwards compat\n                                            'orientation': 'horizontal'},\n                                 }\n\n    loc_settings = default_location_settings[location]\n\n    # put appropriate values into the kw dict for passing back to\n    # the Colorbar class\n    kw['orientation'] = loc_settings['orientation']\n    kw['ticklocation'] = location\n\n    anchor = kw.pop('anchor', loc_settings['anchor'])\n    parent_anchor = kw.pop('panchor', loc_settings['panchor'])\n\n    parents_iterable = np.iterable(parents)\n    # turn parents into a list if it is not already. We do this w/ np\n    # because `plt.subplots` can return an ndarray and is natural to\n    # pass to `colorbar`.\n    parents = np.atleast_1d(parents).ravel()\n\n    # check if using constrained_layout:\n    try:\n        gs = parents[0].get_subplotspec().get_gridspec()\n        using_constrained_layout = (gs._layoutbox is not None)\n    except AttributeError:\n        using_constrained_layout = False\n\n    # defaults are not appropriate for constrained_layout:\n    pad0 = loc_settings['pad']\n    if using_constrained_layout:\n        pad0 = 0.02\n    pad = kw.pop('pad', pad0)\n\n    fig = parents[0].get_figure()\n    if not all(fig is ax.get_figure() for ax in parents):\n        raise ValueError('Unable to create a colorbar axes as not all '\n                         'parents share the same figure.')\n\n    # take a bounding box around all of the given axes\n    parents_bbox = mtransforms.Bbox.union(\n        [ax.get_position(original=True).frozen() for ax in parents])\n\n    pb = parents_bbox\n    if location in ('left', 'right'):\n        if location == 'left':\n            pbcb, _, pb1 = pb.splitx(fraction, fraction + pad)\n        else:\n            pb1, _, pbcb = pb.splitx(1 - fraction - pad, 1 - fraction)\n        pbcb = pbcb.shrunk(1.0, shrink).anchored(anchor, pbcb)\n    else:\n        if location == 'bottom':\n            pbcb, _, pb1 = pb.splity(fraction, fraction + pad)\n        else:\n            pb1, _, pbcb = pb.splity(1 - fraction - pad, 1 - fraction)\n        pbcb = pbcb.shrunk(shrink, 1.0).anchored(anchor, pbcb)\n\n        # define the aspect ratio in terms of y's per x rather than x's per y\n        aspect = 1.0 / aspect\n\n    # define a transform which takes us from old axes coordinates to\n    # new axes coordinates\n    shrinking_trans = mtransforms.BboxTransform(parents_bbox, pb1)\n\n    # transform each of the axes in parents using the new transform\n    for ax in parents:\n        new_posn = shrinking_trans.transform(ax.get_position(original=True))\n        new_posn = mtransforms.Bbox(new_posn)\n        ax._set_position(new_posn)\n        if parent_anchor is not False:\n            ax.set_anchor(parent_anchor)\n\n    cax = fig.add_axes(pbcb, label=\"<colorbar>\")\n\n    # OK, now make a layoutbox for the cb axis.  Later, we will use this\n    # to make the colorbar fit nicely.\n    if not using_constrained_layout:\n        # no layout boxes:\n        lb = None\n        lbpos = None\n        # and we need to set the aspect ratio by hand...\n        cax.set_aspect(aspect, anchor=anchor, adjustable='box')\n    else:\n        if not parents_iterable:\n            # this is a single axis...\n            ax = parents[0]\n            lb, lbpos = constrained_layout.layoutcolorbarsingle(\n                    ax, cax, shrink, aspect, location, pad=pad)\n        else:  # there is more than one parent, so lets use gridspec\n            # the colorbar will be a sibling of this gridspec, so the\n            # parent is the same parent as the gridspec.  Either the figure,\n            # or a subplotspec.\n\n            lb, lbpos = constrained_layout.layoutcolorbargridspec(\n                    parents, cax, shrink, aspect, location, pad)\n\n    cax._layoutbox = lb\n    cax._poslayoutbox = lbpos\n\n    return cax, kw",
        "begin_line": 1357,
        "end_line": 1509,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023803856224708403,
            "pseudo_dstar_susp": 0.00020911752404851526,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00020911752404851526,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.colorbar.make_axes_gridspec#1513",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar",
        "signature": "lib.matplotlib.colorbar.make_axes_gridspec(parent, *, fraction=0.15, shrink=1.0, aspect=20, **kw)",
        "snippet": "def make_axes_gridspec(parent, *, fraction=0.15, shrink=1.0, aspect=20, **kw):\n    '''\n    Resize and reposition a parent axes, and return a child axes\n    suitable for a colorbar. This function is similar to\n    make_axes. Prmary differences are\n\n     * *make_axes_gridspec* only handles the *orientation* keyword\n       and cannot handle the \"location\" keyword.\n\n     * *make_axes_gridspec* should only be used with a subplot parent.\n\n     * *make_axes* creates an instance of Axes. *make_axes_gridspec*\n        creates an instance of Subplot.\n\n     * *make_axes* updates the position of the\n        parent. *make_axes_gridspec* replaces the grid_spec attribute\n        of the parent with a new one.\n\n    While this function is meant to be compatible with *make_axes*,\n    there could be some minor differences.\n\n    Keyword arguments may include the following (with defaults):\n\n        *orientation*\n            'vertical' or 'horizontal'\n\n    %s\n\n    All but the first of these are stripped from the input kw set.\n\n    Returns (cax, kw), the child axes and the reduced kw dictionary to be\n    passed when creating the colorbar instance.\n    '''\n\n    orientation = kw.setdefault('orientation', 'vertical')\n    kw['ticklocation'] = 'auto'\n\n    x1 = 1 - fraction\n\n    # for shrinking\n    pad_s = (1 - shrink) * 0.5\n    wh_ratios = [pad_s, shrink, pad_s]\n\n    # we need to none the tree of layoutboxes because\n    # constrained_layout can't remove and replace the tree\n    # hierarchy w/o a seg fault.\n    gs = parent.get_subplotspec().get_gridspec()\n    layoutbox.nonetree(gs._layoutbox)\n    gs_from_subplotspec = gridspec.GridSpecFromSubplotSpec\n    if orientation == 'vertical':\n        pad = kw.pop('pad', 0.05)\n        wh_space = 2 * pad / (1 - pad)\n        gs = gs_from_subplotspec(1, 2,\n                                 subplot_spec=parent.get_subplotspec(),\n                                 wspace=wh_space,\n                                 width_ratios=[x1 - pad, fraction])\n        gs2 = gs_from_subplotspec(3, 1,\n                                  subplot_spec=gs[1],\n                                  hspace=0.,\n                                  height_ratios=wh_ratios)\n        anchor = (0.0, 0.5)\n        panchor = (1.0, 0.5)\n    else:\n        pad = kw.pop('pad', 0.15)\n        wh_space = 2 * pad / (1 - pad)\n        gs = gs_from_subplotspec(2, 1,\n                                 subplot_spec=parent.get_subplotspec(),\n                                 hspace=wh_space,\n                                 height_ratios=[x1 - pad, fraction])\n        gs2 = gs_from_subplotspec(1, 3,\n                                  subplot_spec=gs[1],\n                                  wspace=0.,\n                                  width_ratios=wh_ratios)\n        aspect = 1 / aspect\n        anchor = (0.5, 1.0)\n        panchor = (0.5, 0.0)\n\n    parent.set_subplotspec(gs[0])\n    parent.update_params()\n    parent._set_position(parent.figbox)\n    parent.set_anchor(panchor)\n\n    fig = parent.get_figure()\n    cax = fig.add_subplot(gs2[1], label=\"<colorbar>\")\n    cax.set_aspect(aspect, anchor=anchor, adjustable='box')\n    return cax, kw",
        "begin_line": 1513,
        "end_line": 1598,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013439053890606102,
            "pseudo_dstar_susp": 0.00015775358889414735,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00015775358889414735,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarPatch._add_solids#1618",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarPatch",
        "signature": "lib.matplotlib.colorbar.ColorbarPatch._add_solids(self, X, Y, C)",
        "snippet": "    def _add_solids(self, X, Y, C):\n        \"\"\"\n        Draw the colors using :class:`~matplotlib.patches.Patch`;\n        optionally add separators.\n        \"\"\"\n        n_segments = len(C)\n\n        # ensure there are sufficient hatches\n        hatches = self.mappable.hatches * n_segments\n\n        patches = []\n        for i in range(len(X) - 1):\n            val = C[i][0]\n            hatch = hatches[i]\n\n            xy = np.array([[X[i][0], Y[i][0]],\n                           [X[i][1], Y[i][0]],\n                           [X[i + 1][1], Y[i + 1][0]],\n                           [X[i + 1][0], Y[i + 1][1]]])\n\n            if self.orientation == 'horizontal':\n                # if horizontal swap the xs and ys\n                xy = xy[..., ::-1]\n\n            patch = mpatches.PathPatch(mpath.Path(xy),\n                                       facecolor=self.cmap(self.norm(val)),\n                                       hatch=hatch, linewidth=0,\n                                       antialiased=False, alpha=self.alpha)\n            self.ax.add_patch(patch)\n            patches.append(patch)\n\n        if self.solids_patches:\n            for solid in self.solids_patches:\n                solid.remove()\n\n        self.solids_patches = patches\n\n        if self.dividers is not None:\n            self.dividers.remove()\n            self.dividers = None\n\n        if self.drawedges:\n            self.dividers = collections.LineCollection(\n                    self._edges(X, Y),\n                    colors=(mpl.rcParams['axes.edgecolor'],),\n                    linewidths=(0.5 * mpl.rcParams['axes.linewidth'],))\n            self.ax.add_collection(self.dividers)",
        "begin_line": 1618,
        "end_line": 1664,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.colorbar.colorbar_factory#1667",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar",
        "signature": "lib.matplotlib.colorbar.colorbar_factory(cax, mappable, **kwargs)",
        "snippet": "def colorbar_factory(cax, mappable, **kwargs):\n    \"\"\"\n    Creates a colorbar on the given axes for the given mappable.\n\n    Typically, for automatic colorbar placement given only a mappable use\n    :meth:`~matplotlib.figure.Figure.colorbar`.\n\n    \"\"\"\n    # if the given mappable is a contourset with any hatching, use\n    # ColorbarPatch else use Colorbar\n    if (isinstance(mappable, contour.ContourSet)\n            and any(hatch is not None for hatch in mappable.hatches)):\n        cb = ColorbarPatch(cax, mappable, **kwargs)\n    else:\n        cb = Colorbar(cax, mappable, **kwargs)\n\n    cid = mappable.callbacksSM.connect('changed', cb.on_mappable_changed)\n    mappable.colorbar = cb\n    mappable.colorbar_cid = cid\n\n    return cb",
        "begin_line": 1667,
        "end_line": 1687,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019527436047646945,
            "pseudo_dstar_susp": 0.00021312872975277067,
            "pseudo_tarantula_susp": 0.00032393909944930353,
            "pseudo_op2_susp": 0.00021312872975277067,
            "pseudo_barinel_susp": 0.00032393909944930353
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformNode.__init__#82",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformNode",
        "signature": "lib.matplotlib.transforms.TransformNode.__init__(self, shorthand_name=None)",
        "snippet": "    def __init__(self, shorthand_name=None):\n        \"\"\"\n        Creates a new :class:`TransformNode`.\n\n        Parameters\n        ----------\n        shorthand_name : str\n            A string representing the \"name\" of the transform. The name carries\n            no significance other than to improve the readability of\n            ``str(transform)`` when DEBUG=True.\n        \"\"\"\n        self._parents = {}\n\n        # TransformNodes start out as invalid until their values are\n        # computed for the first time.\n        self._invalid = 1\n        self._shorthand_name = shorthand_name or ''",
        "begin_line": 82,
        "end_line": 98,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008130081300813009,
            "pseudo_dstar_susp": 0.01098901098901099,
            "pseudo_tarantula_susp": 0.00026001040041601667,
            "pseudo_op2_susp": 0.01098901098901099,
            "pseudo_barinel_susp": 0.00026001040041601667
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformNode.invalidate#126",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformNode",
        "signature": "lib.matplotlib.transforms.TransformNode.invalidate(self)",
        "snippet": "    def invalidate(self):\n        \"\"\"\n        Invalidate this `TransformNode` and triggers an invalidation of its\n        ancestors.  Should be called any time the transform changes.\n        \"\"\"\n        value = self.INVALID\n        if self.is_affine:\n            value = self.INVALID_AFFINE\n        return self._invalidate_internal(value, invalidating_node=self)",
        "begin_line": 126,
        "end_line": 134,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.03125,
            "pseudo_dstar_susp": 0.013888888888888888,
            "pseudo_tarantula_susp": 0.0004697040864255519,
            "pseudo_op2_susp": 0.013888888888888888,
            "pseudo_barinel_susp": 0.0004697040864255519
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformNode._invalidate_internal#136",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformNode",
        "signature": "lib.matplotlib.transforms.TransformNode._invalidate_internal(self, value, invalidating_node)",
        "snippet": "    def _invalidate_internal(self, value, invalidating_node):\n        \"\"\"\n        Called by :meth:`invalidate` and subsequently ascends the transform\n        stack calling each TransformNode's _invalidate_internal method.\n        \"\"\"\n        # determine if this call will be an extension to the invalidation\n        # status. If not, then a shortcut means that we needn't invoke an\n        # invalidation up the transform stack as it will already have been\n        # invalidated.\n\n        # N.B This makes the invalidation sticky, once a transform has been\n        # invalidated as NON_AFFINE, then it will always be invalidated as\n        # NON_AFFINE even when triggered with a AFFINE_ONLY invalidation.\n        # In most cases this is not a problem (i.e. for interactive panning and\n        # zooming) and the only side effect will be on performance.\n        status_changed = self._invalid < value\n\n        if self.pass_through or status_changed:\n            self._invalid = value\n\n            for parent in list(self._parents.values()):\n                # Dereference the weak reference\n                parent = parent()\n                if parent is not None:\n                    parent._invalidate_internal(\n                        value=value, invalidating_node=self)",
        "begin_line": 136,
        "end_line": 161,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.014492753623188406,
            "pseudo_dstar_susp": 0.009615384615384616,
            "pseudo_tarantula_susp": 0.0004621072088724584,
            "pseudo_op2_susp": 0.009615384615384616,
            "pseudo_barinel_susp": 0.0004621072088724584
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformNode.set_children#163",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformNode",
        "signature": "lib.matplotlib.transforms.TransformNode.set_children(self, *children)",
        "snippet": "    def set_children(self, *children):\n        \"\"\"\n        Set the children of the transform, to let the invalidation\n        system know which transforms can invalidate this transform.\n        Should be called from the constructor of any transforms that\n        depend on other transforms.\n        \"\"\"\n        # Parents are stored as weak references, so that if the\n        # parents are destroyed, references from the children won't\n        # keep them alive.\n        for child in children:\n            # Use weak references so this dictionary won't keep obsolete nodes\n            # alive; the callback deletes the dictionary entry. This is a\n            # performance improvement over using WeakValueDictionary.\n            ref = weakref.ref(self, lambda ref, sid=id(self),\n                                        target=child._parents: target.pop(sid))\n            child._parents[id(self)] = ref",
        "begin_line": 163,
        "end_line": 179,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012100677637947725,
            "pseudo_dstar_susp": 0.0001971608832807571,
            "pseudo_tarantula_susp": 0.00011460004584001834,
            "pseudo_op2_susp": 0.0001971608832807571,
            "pseudo_barinel_susp": 0.00011460004584001834
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.frozen#274",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.frozen(self)",
        "snippet": "    def frozen(self):\n        return Bbox(self.get_points().copy())",
        "begin_line": 274,
        "end_line": 275,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002838489923360772,
            "pseudo_dstar_susp": 0.000333555703802535,
            "pseudo_tarantula_susp": 0.0002913752913752914,
            "pseudo_op2_susp": 0.000333555703802535,
            "pseudo_barinel_susp": 0.0002913752913752914
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.__array__#278",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.__array__(self, *args, **kwargs)",
        "snippet": "    def __array__(self, *args, **kwargs):\n        return self.get_points()",
        "begin_line": 278,
        "end_line": 279,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002523977788995457,
            "pseudo_dstar_susp": 0.0003136762860727729,
            "pseudo_tarantula_susp": 0.00016307893020221786,
            "pseudo_op2_susp": 0.0003136762860727729,
            "pseudo_barinel_susp": 0.00016307893020221786
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.y0#297",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.y0(self)",
        "snippet": "    def y0(self):\n        \"\"\"\n        The first of the pair of *y* coordinates that define the bounding box.\n\n        This is not guaranteed to be less than :attr:`y1` (for that, use\n        :attr:`ymin`).\n        \"\"\"\n        return self.get_points()[0, 1]",
        "begin_line": 297,
        "end_line": 304,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004889975550122249,
            "pseudo_dstar_susp": 0.0003968253968253968,
            "pseudo_tarantula_susp": 0.00019113149847094801,
            "pseudo_op2_susp": 0.0003968253968253968,
            "pseudo_barinel_susp": 0.00019113149847094801
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.p1#337",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.p1(self)",
        "snippet": "    def p1(self):\n        \"\"\"\n        The second pair of (*x*, *y*) coordinates that define the bounding box.\n\n        This is not guaranteed to be the top-right corner (for that, use\n        :attr:`max`).\n        \"\"\"\n        return self.get_points()[1]",
        "begin_line": 337,
        "end_line": 344,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001336898395721925,
            "pseudo_dstar_susp": 0.0021008403361344537,
            "pseudo_tarantula_susp": 0.0003897116134060795,
            "pseudo_op2_susp": 0.0021008403361344537,
            "pseudo_barinel_susp": 0.0003897116134060795
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.xmax#357",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.xmax(self)",
        "snippet": "    def xmax(self):\n        \"\"\"The right edge of the bounding box.\"\"\"\n        return np.max(self.get_points()[:, 0])",
        "begin_line": 357,
        "end_line": 359,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00047709923664122136,
            "pseudo_dstar_susp": 0.00039323633503735744,
            "pseudo_tarantula_susp": 0.00018365472910927456,
            "pseudo_op2_susp": 0.00039323633503735744,
            "pseudo_barinel_susp": 0.00018365472910927456
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.width#395",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.width(self)",
        "snippet": "    def width(self):\n        \"\"\"The (signed) width of the bounding box.\"\"\"\n        points = self.get_points()\n        return points[1, 0] - points[0, 0]",
        "begin_line": 395,
        "end_line": 398,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023529411764705883,
            "pseudo_dstar_susp": 0.00031776294884016526,
            "pseudo_tarantula_susp": 0.00012674271229404308,
            "pseudo_op2_susp": 0.00031776294884016526,
            "pseudo_barinel_susp": 0.00012674271229404308
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.bounds#413",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.bounds(self)",
        "snippet": "    def bounds(self):\n        \"\"\"Return (:attr:`x0`, :attr:`y0`, :attr:`width`, :attr:`height`).\"\"\"\n        (x0, y0), (x1, y1) = self.get_points()\n        return (x0, y0, x1 - x0, y1 - y0)",
        "begin_line": 413,
        "end_line": 416,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014970059880239522,
            "pseudo_dstar_susp": 0.0011933174224343676,
            "pseudo_tarantula_susp": 0.00046382189239332097,
            "pseudo_op2_susp": 0.0011933174224343676,
            "pseudo_barinel_susp": 0.00046382189239332097
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.extents#419",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.extents(self)",
        "snippet": "    def extents(self):\n        \"\"\"Return (:attr:`x0`, :attr:`y0`, :attr:`x1`, :attr:`y1`).\"\"\"\n        return self.get_points().flatten()  # flatten returns a copy.",
        "begin_line": 419,
        "end_line": 421,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002676659528907923,
            "pseudo_dstar_susp": 0.0002717391304347826,
            "pseudo_tarantula_susp": 0.0002332089552238806,
            "pseudo_op2_susp": 0.0002717391304347826,
            "pseudo_barinel_susp": 0.0002332089552238806
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.fully_overlaps#486",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.fully_overlaps(self, other)",
        "snippet": "    def fully_overlaps(self, other):\n        \"\"\"\n        Return whether this bounding box overlaps with the other bounding box,\n        not including the edges.\n\n        Parameters\n        ----------\n        other : `.BboxBase`\n        \"\"\"\n        ax1, ay1, ax2, ay2 = self.extents\n        bx1, by1, bx2, by2 = other.extents\n        if ax2 < ax1:\n            ax2, ax1 = ax1, ax2\n        if ay2 < ay1:\n            ay2, ay1 = ay1, ay2\n        if bx2 < bx1:\n            bx2, bx1 = bx1, bx2\n        if by2 < by1:\n            by2, by1 = by1, by2\n        return ax1 < bx2 and bx1 < ax2 and ay1 < by2 and by1 < ay2",
        "begin_line": 486,
        "end_line": 505,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.inverse_transformed#516",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.inverse_transformed(self, transform)",
        "snippet": "    def inverse_transformed(self, transform):\n        \"\"\"\n        Construct a `Bbox` by statically transforming this one by the inverse\n        of *transform*.\n        \"\"\"\n        return self.transformed(transform.inverted())",
        "begin_line": 516,
        "end_line": 521,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00016028209648982208,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00016028209648982208,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.anchored#533",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.anchored(self, c, container=None)",
        "snippet": "    def anchored(self, c, container=None):\n        \"\"\"\n        Return a copy of the `Bbox` shifted to position *c* within *container*.\n\n        Parameters\n        ----------\n        c : (float, float) or str\n            May be either:\n\n            * A sequence (*cx*, *cy*) where *cx* and *cy* range from 0\n              to 1, where 0 is left or bottom and 1 is right or top\n\n            * a string:\n              - 'C' for centered\n              - 'S' for bottom-center\n              - 'SE' for bottom-left\n              - 'E' for left\n              - etc.\n\n        container : Bbox, optional\n            The box within which the :class:`Bbox` is positioned; it defaults\n            to the initial :class:`Bbox`.\n        \"\"\"\n        if container is None:\n            container = self\n        l, b, w, h = container.bounds\n        if isinstance(c, str):\n            cx, cy = self.coefs[c]\n        else:\n            cx, cy = c\n        L, B, W, H = self.bounds\n        return Bbox(self._points +\n                    [(l + cx * (w - W)) - L,\n                     (b + cy * (h - H)) - B])",
        "begin_line": 533,
        "end_line": 566,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00030039050765995795,
            "pseudo_dstar_susp": 0.00031259768677711783,
            "pseudo_tarantula_susp": 0.00043271311120726956,
            "pseudo_op2_susp": 0.00031259768677711783,
            "pseudo_barinel_susp": 0.00043271311120726956
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.splity#614",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.splity(self, *args)",
        "snippet": "    def splity(self, *args):\n        \"\"\"\n        Return a list of new `Bbox` objects formed by splitting the original\n        one with horizontal lines at fractional positions given by *args*.\n        \"\"\"\n        yf = [0, *args, 1]\n        x0, y0, x1, y1 = self.extents\n        h = y1 - y0\n        return [Bbox([[x0, y0 + yf0 * h], [x1, y0 + yf1 * h]])\n                for yf0, yf1 in zip(yf[:-1], yf[1:])]",
        "begin_line": 614,
        "end_line": 623,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018053800324968405,
            "pseudo_dstar_susp": 0.0001529987760097919,
            "pseudo_tarantula_susp": 0.0003450655624568668,
            "pseudo_op2_susp": 0.0001529987760097919,
            "pseudo_barinel_susp": 0.00034494653328734045
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.count_overlaps#641",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.count_overlaps(self, bboxes)",
        "snippet": "    def count_overlaps(self, bboxes):\n        \"\"\"\n        Count the number of bounding boxes that overlap this one.\n\n        Parameters\n        ----------\n        bboxes : sequence of `.BboxBase`\n        \"\"\"\n        return count_bboxes_overlapping_bbox(\n            self, np.atleast_3d([np.array(x) for x in bboxes]))",
        "begin_line": 641,
        "end_line": 650,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.intersection#710",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.intersection(bbox1, bbox2)",
        "snippet": "    def intersection(bbox1, bbox2):\n        \"\"\"\n        Return the intersection of *bbox1* and *bbox2* if they intersect, or\n        None if they don't.\n        \"\"\"\n        x0 = np.maximum(bbox1.xmin, bbox2.xmin)\n        x1 = np.minimum(bbox1.xmax, bbox2.xmax)\n        y0 = np.maximum(bbox1.ymin, bbox2.ymin)\n        y1 = np.minimum(bbox1.ymax, bbox2.ymax)\n        return Bbox([[x0, y0], [x1, y1]]) if x0 <= x1 and y0 <= y1 else None",
        "begin_line": 710,
        "end_line": 719,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00026441036488630354,
            "pseudo_dstar_susp": 0.00028653295128939826,
            "pseudo_tarantula_susp": 0.00022016732716864817,
            "pseudo_op2_susp": 0.00028653295128939826,
            "pseudo_barinel_susp": 0.00022016732716864817
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.__init__#727",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.__init__(self, points, **kwargs)",
        "snippet": "    def __init__(self, points, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        points : ndarray\n            A 2x2 numpy array of the form ``[[x0, y0], [x1, y1]]``.\n\n        Notes\n        -----\n        If you need to create a :class:`Bbox` object from another form\n        of data, consider the static methods :meth:`unit`,\n        :meth:`from_bounds` and :meth:`from_extents`.\n        \"\"\"\n        BboxBase.__init__(self, **kwargs)\n        points = np.asarray(points, float)\n        if points.shape != (2, 2):\n            raise ValueError('Bbox points must be of the form '\n                             '\"[[x0, y0], [x1, y1]]\".')\n        self._points = points\n        self._minpos = np.array([np.inf, np.inf])\n        self._ignore = True\n        # it is helpful in some contexts to know if the bbox is a\n        # default or has been mutated; we store the orig points to\n        # support the mutated methods\n        self._points_orig = self._points.copy()",
        "begin_line": 727,
        "end_line": 751,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001488095238095238,
            "pseudo_dstar_susp": 0.001984126984126984,
            "pseudo_tarantula_susp": 0.00046274872744099955,
            "pseudo_op2_susp": 0.001976284584980237,
            "pseudo_barinel_susp": 0.00046274872744099955
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.from_bounds#774",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.from_bounds(x0, y0, width, height)",
        "snippet": "    def from_bounds(x0, y0, width, height):\n        \"\"\"\n        Create a new `Bbox` from *x0*, *y0*, *width* and *height*.\n\n        *width* and *height* may be negative.\n        \"\"\"\n        return Bbox.from_extents(x0, y0, x0 + width, y0 + height)",
        "begin_line": 774,
        "end_line": 780,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020161290322580645,
            "pseudo_dstar_susp": 0.0010741138560687433,
            "pseudo_tarantula_susp": 0.0004948045522018803,
            "pseudo_op2_susp": 0.0010741138560687433,
            "pseudo_barinel_susp": 0.0004948045522018803
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.from_extents#783",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.from_extents(*args)",
        "snippet": "    def from_extents(*args):\n        \"\"\"\n        Create a new Bbox from *left*, *bottom*, *right* and *top*.\n\n        The *y*-axis increases upwards.\n        \"\"\"\n        points = np.array(args, dtype=float).reshape(2, 2)\n        return Bbox(points)",
        "begin_line": 783,
        "end_line": 790,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012626262626262627,
            "pseudo_dstar_susp": 0.0017605633802816902,
            "pseudo_tarantula_susp": 0.0004192872117400419,
            "pseudo_op2_susp": 0.0017605633802816902,
            "pseudo_barinel_susp": 0.0004192872117400419
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.ignore#803",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.ignore(self, value)",
        "snippet": "    def ignore(self, value):\n        \"\"\"\n        Set whether the existing bounds of the box should be ignored\n        by subsequent calls to :meth:`update_from_data_xy`.\n\n        value : bool\n           - When ``True``, subsequent calls to :meth:`update_from_data_xy`\n             will ignore the existing bounds of the :class:`Bbox`.\n\n           - When ``False``, subsequent calls to :meth:`update_from_data_xy`\n             will include the existing bounds of the :class:`Bbox`.\n        \"\"\"\n        self._ignore = value",
        "begin_line": 803,
        "end_line": 815,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.71366862079605e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.update_from_path#817",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.update_from_path(self, path, ignore=None, updatex=True, updatey=True)",
        "snippet": "    def update_from_path(self, path, ignore=None, updatex=True, updatey=True):\n        \"\"\"\n        Update the bounds of the :class:`Bbox` based on the passed in\n        data.  After updating, the bounds will have positive *width*\n        and *height*; *x0* and *y0* will be the minimal values.\n\n        Parameters\n        ----------\n        path : :class:`~matplotlib.path.Path`\n\n        ignore : bool, optional\n           - when ``True``, ignore the existing bounds of the :class:`Bbox`.\n           - when ``False``, include the existing bounds of the :class:`Bbox`.\n           - when ``None``, use the last value passed to :meth:`ignore`.\n\n        updatex, updatey : bool, optional\n            When ``True``, update the x/y values.\n        \"\"\"\n        if ignore is None:\n            ignore = self._ignore\n\n        if path.vertices.size == 0:\n            return\n\n        points, minpos, changed = update_path_extents(\n            path, None, self._points, self._minpos, ignore)\n\n        if changed:\n            self.invalidate()\n            if updatex:\n                self._points[:, 0] = points[:, 0]\n                self._minpos[0] = minpos[0]\n            if updatey:\n                self._points[:, 1] = points[:, 1]\n                self._minpos[1] = minpos[1]",
        "begin_line": 817,
        "end_line": 851,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003832886163280951,
            "pseudo_dstar_susp": 0.00039840637450199205,
            "pseudo_tarantula_susp": 0.00031377470975839345,
            "pseudo_op2_susp": 0.00039840637450199205,
            "pseudo_barinel_susp": 0.00031377470975839345
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.update_from_data_xy#853",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.update_from_data_xy(self, xy, ignore=None, updatex=True, updatey=True)",
        "snippet": "    def update_from_data_xy(self, xy, ignore=None, updatex=True, updatey=True):\n        \"\"\"\n        Update the bounds of the :class:`Bbox` based on the passed in\n        data.  After updating, the bounds will have positive *width*\n        and *height*; *x0* and *y0* will be the minimal values.\n\n        Parameters\n        ----------\n        xy : ndarray\n            A numpy array of 2D points.\n\n        ignore : bool, optional\n           - When ``True``, ignore the existing bounds of the :class:`Bbox`.\n           - When ``False``, include the existing bounds of the :class:`Bbox`.\n           - When ``None``, use the last value passed to :meth:`ignore`.\n\n        updatex, updatey : bool, optional\n            When ``True``, update the x/y values.\n        \"\"\"\n        if len(xy) == 0:\n            return\n\n        path = Path(xy)\n        self.update_from_path(path, ignore=ignore,\n                              updatex=updatex, updatey=updatey)",
        "begin_line": 853,
        "end_line": 877,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.667764583513912e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.y0#885",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.y0(self, val)",
        "snippet": "    def y0(self, val):\n        self._points[0, 1] = val\n        self.invalidate()",
        "begin_line": 885,
        "end_line": 887,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003031221582297666,
            "pseudo_dstar_susp": 0.0002701242571582928,
            "pseudo_tarantula_susp": 0.00031625553447185326,
            "pseudo_op2_susp": 0.0002701242571582928,
            "pseudo_barinel_susp": 0.00031625553447185326
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.y1#895",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.y1(self, val)",
        "snippet": "    def y1(self, val):\n        self._points[1, 1] = val\n        self.invalidate()",
        "begin_line": 895,
        "end_line": 897,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003031221582297666,
            "pseudo_dstar_susp": 0.0002701242571582928,
            "pseudo_tarantula_susp": 0.00031625553447185326,
            "pseudo_op2_susp": 0.0002701242571582928,
            "pseudo_barinel_susp": 0.00031625553447185326
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.p1#905",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.p1(self, val)",
        "snippet": "    def p1(self, val):\n        self._points[1] = val\n        self.invalidate()",
        "begin_line": 905,
        "end_line": 907,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020876826722338203,
            "pseudo_dstar_susp": 0.002188183807439825,
            "pseudo_tarantula_susp": 0.0003972983710766786,
            "pseudo_op2_susp": 0.002188183807439825,
            "pseudo_barinel_susp": 0.0003972983710766786
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.minposx#932",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.minposx(self)",
        "snippet": "    def minposx(self):\n        return self._minpos[0]",
        "begin_line": 932,
        "end_line": 933,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003700962250185048,
            "pseudo_dstar_susp": 0.00051440329218107,
            "pseudo_tarantula_susp": 0.00014039028499227853,
            "pseudo_op2_susp": 0.00051440329218107,
            "pseudo_barinel_susp": 0.00014039028499227853
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.minposy#936",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.minposy(self)",
        "snippet": "    def minposy(self):\n        return self._minpos[1]",
        "begin_line": 936,
        "end_line": 937,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00028074115665356543,
            "pseudo_dstar_susp": 0.00035211267605633805,
            "pseudo_tarantula_susp": 0.00013063357282821686,
            "pseudo_op2_susp": 0.00035211267605633805,
            "pseudo_barinel_susp": 0.00013063357282821686
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.get_points#939",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.get_points(self)",
        "snippet": "    def get_points(self):\n        \"\"\"\n        Get the points of the bounding box directly as a numpy array\n        of the form: ``[[x0, y0], [x1, y1]]``.\n        \"\"\"\n        self._invalid = 0\n        return self._points",
        "begin_line": 939,
        "end_line": 945,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001488095238095238,
            "pseudo_dstar_susp": 0.0011876484560570072,
            "pseudo_tarantula_susp": 0.00046274872744099955,
            "pseudo_op2_susp": 0.0011876484560570072,
            "pseudo_barinel_susp": 0.00046274872744099955
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.set_points#947",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.set_points(self, points)",
        "snippet": "    def set_points(self, points):\n        \"\"\"\n        Set the points of the bounding box directly from a numpy array\n        of the form: ``[[x0, y0], [x1, y1]]``.  No error checking is\n        performed, as this method is mainly for internal use.\n        \"\"\"\n        if np.any(self._points != points):\n            self._points = points\n            self.invalidate()",
        "begin_line": 947,
        "end_line": 955,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.71366862079605e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.set#957",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.set(self, other)",
        "snippet": "    def set(self, other):\n        \"\"\"\n        Set this bounding box from the \"frozen\" bounds of another `Bbox`.\n        \"\"\"\n        if np.any(self._points != other.get_points()):\n            self._points = other.get_points()\n            self.invalidate()",
        "begin_line": 957,
        "end_line": 963,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003076923076923077,
            "pseudo_dstar_susp": 0.0002901915264074289,
            "pseudo_tarantula_susp": 0.00035587188612099647,
            "pseudo_op2_susp": 0.0002901915264074289,
            "pseudo_barinel_susp": 0.00035587188612099647
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.mutatedx#969",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.mutatedx(self)",
        "snippet": "    def mutatedx(self):\n        'Return whether the x-limits have changed since init.'\n        return (self._points[0, 0] != self._points_orig[0, 0] or\n                self._points[1, 0] != self._points_orig[1, 0])",
        "begin_line": 969,
        "end_line": 972,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020475020475020476,
            "pseudo_dstar_susp": 0.00019204916458613405,
            "pseudo_tarantula_susp": 0.000253613999492772,
            "pseudo_op2_susp": 0.00019204916458613405,
            "pseudo_barinel_susp": 0.000253613999492772
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.mutatedy#974",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.mutatedy(self)",
        "snippet": "    def mutatedy(self):\n        'Return whether the y-limits have changed since init.'\n        return (self._points[0, 1] != self._points_orig[0, 1] or\n                self._points[1, 1] != self._points_orig[1, 1])",
        "begin_line": 974,
        "end_line": 977,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.0001490757304710793,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.0001490757304710793,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformedBbox.__init__#986",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformedBbox",
        "signature": "lib.matplotlib.transforms.TransformedBbox.__init__(self, bbox, transform, **kwargs)",
        "snippet": "    def __init__(self, bbox, transform, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        bbox : :class:`Bbox`\n\n        transform : :class:`Transform`\n        \"\"\"\n        if not bbox.is_bbox:\n            raise ValueError(\"'bbox' is not a bbox\")\n        cbook._check_isinstance(Transform, transform=transform)\n        if transform.input_dims != 2 or transform.output_dims != 2:\n            raise ValueError(\n                \"The input and output dimensions of 'transform' must be 2\")\n\n        BboxBase.__init__(self, **kwargs)\n        self._bbox = bbox\n        self._transform = transform\n        self.set_children(bbox, transform)\n        self._points = None",
        "begin_line": 986,
        "end_line": 1005,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009775171065493646,
            "pseudo_dstar_susp": 0.003115264797507788,
            "pseudo_tarantula_susp": 0.00027624309392265195,
            "pseudo_op2_susp": 0.003115264797507788,
            "pseudo_barinel_susp": 0.00027624309392265195
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformedBbox.__str__#1007",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformedBbox",
        "signature": "lib.matplotlib.transforms.TransformedBbox.__str__(self)",
        "snippet": "    def __str__(self):\n        return (\"{}(\\n\"\n                    \"{},\\n\"\n                    \"{})\"\n                .format(type(self).__name__,\n                        _indent_str(self._bbox),\n                        _indent_str(self._transform)))",
        "begin_line": 1007,
        "end_line": 1013,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformedBbox.get_points#1015",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformedBbox",
        "signature": "lib.matplotlib.transforms.TransformedBbox.get_points(self)",
        "snippet": "    def get_points(self):\n        # docstring inherited\n        if self._invalid:\n            p = self._bbox.get_points()\n            # Transform all four points, then make a new bounding box\n            # from the result, taking care to make the orientation the\n            # same.\n            points = self._transform.transform(\n                [[p[0, 0], p[0, 1]],\n                 [p[1, 0], p[0, 1]],\n                 [p[0, 0], p[1, 1]],\n                 [p[1, 0], p[1, 1]]])\n            points = np.ma.filled(points, 0.0)\n\n            xs = min(points[:, 0]), max(points[:, 0])\n            if p[0, 0] > p[1, 0]:\n                xs = xs[::-1]\n\n            ys = min(points[:, 1]), max(points[:, 1])\n            if p[0, 1] > p[1, 1]:\n                ys = ys[::-1]\n\n            self._points = np.array([\n                [xs[0], ys[0]],\n                [xs[1], ys[1]]\n            ])\n\n            self._invalid = 0\n        return self._points",
        "begin_line": 1015,
        "end_line": 1043,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015527950310559005,
            "pseudo_dstar_susp": 0.002544529262086514,
            "pseudo_tarantula_susp": 0.00046816479400749064,
            "pseudo_op2_susp": 0.002544529262086514,
            "pseudo_barinel_susp": 0.00046816479400749064
        }
    },
    {
        "name": "lib.matplotlib.transforms.LockableBbox.__init__#1061",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.LockableBbox",
        "signature": "lib.matplotlib.transforms.LockableBbox.__init__(self, bbox, x0=None, y0=None, x1=None, y1=None, **kwargs)",
        "snippet": "    def __init__(self, bbox, x0=None, y0=None, x1=None, y1=None, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        bbox : Bbox\n            The child bounding box to wrap.\n\n        x0 : float or None\n            The locked value for x0, or None to leave unlocked.\n\n        y0 : float or None\n            The locked value for y0, or None to leave unlocked.\n\n        x1 : float or None\n            The locked value for x1, or None to leave unlocked.\n\n        y1 : float or None\n            The locked value for y1, or None to leave unlocked.\n\n        \"\"\"\n        if not bbox.is_bbox:\n            raise ValueError(\"'bbox' is not a bbox\")\n\n        BboxBase.__init__(self, **kwargs)\n        self._bbox = bbox\n        self.set_children(bbox)\n        self._points = None\n        fp = [x0, y0, x1, y1]\n        mask = [val is None for val in fp]\n        self._locked_points = np.ma.array(fp, float, mask=mask).reshape((2, 2))",
        "begin_line": 1061,
        "end_line": 1090,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.transforms.LockableBbox.get_points#1100",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.LockableBbox",
        "signature": "lib.matplotlib.transforms.LockableBbox.get_points(self)",
        "snippet": "    def get_points(self):\n        # docstring inherited\n        if self._invalid:\n            points = self._bbox.get_points()\n            self._points = np.where(self._locked_points.mask,\n                                    points,\n                                    self._locked_points)\n            self._invalid = 0\n        return self._points",
        "begin_line": 1100,
        "end_line": 1108,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.transforms.LockableBbox.locked_x0#1129",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.LockableBbox",
        "signature": "lib.matplotlib.transforms.LockableBbox.locked_x0(self, x0)",
        "snippet": "    def locked_x0(self, x0):\n        self._locked_points.mask[0, 0] = x0 is None\n        self._locked_points.data[0, 0] = x0\n        self.invalidate()",
        "begin_line": 1129,
        "end_line": 1132,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.transforms.LockableBbox.locked_y0#1145",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.LockableBbox",
        "signature": "lib.matplotlib.transforms.LockableBbox.locked_y0(self, y0)",
        "snippet": "    def locked_y0(self, y0):\n        self._locked_points.mask[0, 1] = y0 is None\n        self._locked_points.data[0, 1] = y0\n        self.invalidate()",
        "begin_line": 1145,
        "end_line": 1148,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.transforms.LockableBbox.locked_x1#1151",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.LockableBbox",
        "signature": "lib.matplotlib.transforms.LockableBbox.locked_x1(self)",
        "snippet": "    def locked_x1(self):\n        \"\"\"\n        float or None: The value used for the locked x1.\n        \"\"\"\n        if self._locked_points.mask[1, 0]:\n            return None\n        else:\n            return self._locked_points[1, 0]",
        "begin_line": 1151,
        "end_line": 1158,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.transforms.LockableBbox.locked_x1#1161",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.LockableBbox",
        "signature": "lib.matplotlib.transforms.LockableBbox.locked_x1(self, x1)",
        "snippet": "    def locked_x1(self, x1):\n        self._locked_points.mask[1, 0] = x1 is None\n        self._locked_points.data[1, 0] = x1\n        self.invalidate()",
        "begin_line": 1161,
        "end_line": 1164,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.__init_subclass__#1231",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.__init_subclass__(cls)",
        "snippet": "    def __init_subclass__(cls):\n        # 1d transforms are always separable; we assume higher-dimensional ones\n        # are not but subclasses can also directly set is_separable -- this is\n        # verified by checking whether \"is_separable\" appears more than once in\n        # the class's MRO (it appears once in Transform).\n        if (sum(\"is_separable\" in vars(parent) for parent in cls.__mro__) == 1\n                and cls.input_dims == cls.output_dims == 1):\n            cls.is_separable = True\n        # Transform.inverted raises NotImplementedError; we assume that if this\n        # is overridden then the transform is invertible but subclass can also\n        # directly set has_inverse.\n        if (sum(\"has_inverse\" in vars(parent) for parent in cls.__mro__) == 1\n                and hasattr(cls, \"inverted\")\n                and cls.inverted is not Transform.inverted):\n            cls.has_inverse = True",
        "begin_line": 1231,
        "end_line": 1245,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.__add__#1247",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.__add__(self, other)",
        "snippet": "    def __add__(self, other):\n        \"\"\"\n        Composes two transforms together such that *self* is followed\n        by *other*.\n        \"\"\"\n        if isinstance(other, Transform):\n            return composite_transform_factory(self, other)\n        raise TypeError(\n            \"Can not add Transform to object of type '%s'\" % type(other))",
        "begin_line": 1247,
        "end_line": 1255,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001095290251916758,
            "pseudo_dstar_susp": 0.0019157088122605363,
            "pseudo_tarantula_susp": 0.00032175032175032174,
            "pseudo_op2_susp": 0.0019157088122605363,
            "pseudo_barinel_susp": 0.00032175032175032174
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform._iter_break_from_left_to_right#1271",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform._iter_break_from_left_to_right(self)",
        "snippet": "    def _iter_break_from_left_to_right(self):\n        \"\"\"\n        Returns an iterator breaking down this transform stack from left to\n        right recursively. If self == ((A, N), A) then the result will be an\n        iterator which yields I : ((A, N), A), followed by A : (N, A),\n        followed by (A, N) : (A), but not ((A, N), A) : I.\n\n        This is equivalent to flattening the stack then yielding\n        ``flat_stack[:i], flat_stack[i:]`` where i=0..(n-1).\n\n        \"\"\"\n        yield IdentityTransform(), self",
        "begin_line": 1271,
        "end_line": 1282,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002674511901577962,
            "pseudo_dstar_susp": 0.0003180661577608143,
            "pseudo_tarantula_susp": 0.00016716817118020728,
            "pseudo_op2_susp": 0.0003180661577608143,
            "pseudo_barinel_susp": 0.00016716817118020728
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.contains_branch#1298",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.contains_branch(self, other)",
        "snippet": "    def contains_branch(self, other):\n        \"\"\"\n        Return whether the given transform is a sub-tree of this transform.\n\n        This routine uses transform equality to identify sub-trees, therefore\n        in many situations it is object id which will be used.\n\n        For the case where the given transform represents the whole\n        of this transform, returns True.\n\n        \"\"\"\n        if self.depth < other.depth:\n            return False\n\n        # check that a subtree is equal to other (starting from self)\n        for _, sub_tree in self._iter_break_from_left_to_right():\n            if sub_tree == other:\n                return True\n        return False",
        "begin_line": 1298,
        "end_line": 1316,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00033003300330033004,
            "pseudo_dstar_susp": 0.0003645643456069996,
            "pseudo_tarantula_susp": 0.0002158894645941278,
            "pseudo_op2_susp": 0.0003645643456069996,
            "pseudo_barinel_susp": 0.00021598272138228941
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.contains_branch_seperately#1318",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.contains_branch_seperately(self, other_transform)",
        "snippet": "    def contains_branch_seperately(self, other_transform):\n        \"\"\"\n        Returns whether the given branch is a sub-tree of this transform on\n        each separate dimension.\n\n        A common use for this method is to identify if a transform is a blended\n        transform containing an axes' data transform. e.g.::\n\n            x_isdata, y_isdata = trans.contains_branch_seperately(ax.transData)\n\n        \"\"\"\n        if self.output_dims != 2:\n            raise ValueError('contains_branch_seperately only supports '\n                             'transforms with 2 output dimensions')\n        # for a non-blended transform each separate dimension is the same, so\n        # just return the appropriate shape.\n        return [self.contains_branch(other_transform)] * 2",
        "begin_line": 1318,
        "end_line": 1334,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00026483050847457627,
            "pseudo_dstar_susp": 0.00031456432840515884,
            "pseudo_tarantula_susp": 0.0002637826431020839,
            "pseudo_op2_susp": 0.00031456432840515884,
            "pseudo_barinel_susp": 0.0002637826431020839
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.__sub__#1336",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.__sub__(self, other)",
        "snippet": "    def __sub__(self, other):\n        \"\"\"\n        Returns a transform stack which goes all the way down self's transform\n        stack, and then ascends back up other's stack. If it can, this is\n        optimised::\n\n            # normally\n            A - B == a + b.inverted()\n\n            # sometimes, when A contains the tree B there is no need to\n            # descend all the way down to the base of A (via B), instead we\n            # can just stop at B.\n\n            (A + B) - (B)^-1 == A\n\n            # similarly, when B contains tree A, we can avoid descending A at\n            # all, basically:\n            A - (A + B) == ((B + A) - A).inverted() or B^-1\n\n        For clarity, the result of ``(A + B) - B + B == (A + B)``.\n\n        \"\"\"\n        # we only know how to do this operation if other is a Transform.\n        if not isinstance(other, Transform):\n            return NotImplemented\n\n        for remainder, sub_tree in self._iter_break_from_left_to_right():\n            if sub_tree == other:\n                return remainder\n\n        for remainder, sub_tree in other._iter_break_from_left_to_right():\n            if sub_tree == self:\n                if not remainder.has_inverse:\n                    raise ValueError(\n                        \"The shortcut cannot be computed since 'other' \"\n                        \"includes a non-invertible component\")\n                return remainder.inverted()\n\n        # if we have got this far, then there was no shortcut possible\n        if other.has_inverse:\n            return self + other.inverted()\n        else:\n            raise ValueError('It is not possible to compute transA - transB '\n                             'since transB cannot be inverted and there is no '\n                             'shortcut possible.')",
        "begin_line": 1336,
        "end_line": 1380,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021486892995272884,
            "pseudo_dstar_susp": 0.00019908421262193908,
            "pseudo_tarantula_susp": 0.0002587991718426501,
            "pseudo_op2_susp": 0.00019908421262193908,
            "pseudo_barinel_susp": 0.0002587991718426501
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.transform#1388",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.transform(self, values)",
        "snippet": "    def transform(self, values):\n        \"\"\"\n        Performs the transformation on the given array of values.\n\n        Accepts a numpy array of shape (N x :attr:`input_dims`) and\n        returns a numpy array of shape (N x :attr:`output_dims`).\n\n        Alternatively, accepts a numpy array of length :attr:`input_dims`\n        and returns a numpy array of length :attr:`output_dims`.\n        \"\"\"\n        # Ensure that values is a 2d array (but remember whether\n        # we started with a 1d or 2d array).\n        values = np.asanyarray(values)\n        ndim = values.ndim\n        values = values.reshape((-1, self.input_dims))\n\n        # Transform the values\n        res = self.transform_affine(self.transform_non_affine(values))\n\n        # Convert the result back to the shape of the input values.\n        if ndim == 0:\n            assert not np.ma.is_masked(res)  # just to be on the safe side\n            return res[0, 0]\n        if ndim == 1:\n            return res.reshape(-1)\n        elif ndim == 2:\n            return res\n        raise ValueError(\n            \"Input values must have shape (N x {dims}) \"\n            \"or ({dims}).\".format(dims=self.input_dims))",
        "begin_line": 1388,
        "end_line": 1417,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004970178926441351,
            "pseudo_dstar_susp": 0.0005107252298263534,
            "pseudo_tarantula_susp": 0.000302571860816944,
            "pseudo_op2_susp": 0.0005107252298263534,
            "pseudo_barinel_susp": 0.000302571860816944
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.transform_affine#1419",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.transform_affine(self, values)",
        "snippet": "    def transform_affine(self, values):\n        \"\"\"\n        Performs only the affine part of this transformation on the\n        given array of values.\n\n        ``transform(values)`` is always equivalent to\n        ``transform_affine(transform_non_affine(values))``.\n\n        In non-affine transformations, this is generally a no-op.  In\n        affine transformations, this is equivalent to\n        ``transform(values)``.\n\n        Parameters\n        ----------\n        values : array\n            The input values as NumPy array of length :attr:`input_dims` or\n            shape (N x :attr:`input_dims`).\n\n        Returns\n        -------\n        values : array\n            The output values as NumPy array of length :attr:`input_dims` or\n            shape (N x :attr:`output_dims`), depending on the input.\n        \"\"\"\n        return self.get_affine().transform(values)",
        "begin_line": 1419,
        "end_line": 1443,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022011886418666079,
            "pseudo_dstar_susp": 0.00024177949709864604,
            "pseudo_tarantula_susp": 0.00018615040953090097,
            "pseudo_op2_susp": 0.00024177949709864604,
            "pseudo_barinel_susp": 0.00018615040953090097
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.transform_bbox#1470",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.transform_bbox(self, bbox)",
        "snippet": "    def transform_bbox(self, bbox):\n        \"\"\"\n        Transform the given bounding box.\n\n        Note, for smarter transforms including caching (a common\n        requirement for matplotlib figures), see :class:`TransformedBbox`.\n        \"\"\"\n        return Bbox(self.transform(bbox.get_points()))",
        "begin_line": 1470,
        "end_line": 1477,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00025786487880350697,
            "pseudo_dstar_susp": 0.00023299161230195712,
            "pseudo_tarantula_susp": 0.0003450655624568668,
            "pseudo_op2_susp": 0.00023299161230195712,
            "pseudo_barinel_susp": 0.00034494653328734045
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.get_affine#1479",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.get_affine(self)",
        "snippet": "    def get_affine(self):\n        \"\"\"\n        Get the affine part of this transform.\n        \"\"\"\n        return IdentityTransform()",
        "begin_line": 1479,
        "end_line": 1483,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012195121951219512,
            "pseudo_dstar_susp": 0.00011855364552459988,
            "pseudo_tarantula_susp": 0.00015482272797646694,
            "pseudo_op2_susp": 0.00011855364552459988,
            "pseudo_barinel_susp": 0.00015446400988569664
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.get_matrix#1485",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.get_matrix(self)",
        "snippet": "    def get_matrix(self):\n        \"\"\"\n        Get the Affine transformation array for the affine part\n        of this transform.\n\n        \"\"\"\n        return self.get_affine().get_matrix()",
        "begin_line": 1485,
        "end_line": 1491,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004926108374384236,
            "pseudo_dstar_susp": 0.00037650602409638556,
            "pseudo_tarantula_susp": 0.00020824656393169514,
            "pseudo_op2_susp": 0.00037650602409638556,
            "pseudo_barinel_susp": 0.00020824656393169514
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.transform_path#1509",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.transform_path(self, path)",
        "snippet": "    def transform_path(self, path):\n        \"\"\"\n        Returns a transformed path.\n\n        *path*: a :class:`~matplotlib.path.Path` instance.\n\n        In some cases, this transform may insert curves into the path\n        that began as line segments.\n        \"\"\"\n        return self.transform_path_affine(self.transform_path_non_affine(path))",
        "begin_line": 1509,
        "end_line": 1518,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005353319057815846,
            "pseudo_dstar_susp": 0.00040816326530612246,
            "pseudo_tarantula_susp": 0.0003284072249589491,
            "pseudo_op2_susp": 0.00040816326530612246,
            "pseudo_barinel_susp": 0.0003284072249589491
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.transform_path_affine#1520",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.transform_path_affine(self, path)",
        "snippet": "    def transform_path_affine(self, path):\n        \"\"\"\n        Returns a path, transformed only by the affine part of\n        this transform.\n\n        *path*: a :class:`~matplotlib.path.Path` instance.\n\n        ``transform_path(path)`` is equivalent to\n        ``transform_path_affine(transform_path_non_affine(values))``.\n        \"\"\"\n        return self.get_affine().transform_path_affine(path)",
        "begin_line": 1520,
        "end_line": 1530,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00048262548262548264,
            "pseudo_dstar_susp": 0.0003763643206624012,
            "pseudo_tarantula_susp": 0.00032690421706440013,
            "pseudo_op2_susp": 0.0003763643206624012,
            "pseudo_barinel_susp": 0.00032690421706440013
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.transform_path_non_affine#1532",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.transform_path_non_affine(self, path)",
        "snippet": "    def transform_path_non_affine(self, path):\n        \"\"\"\n        Returns a path, transformed only by the non-affine\n        part of this transform.\n\n        *path*: a :class:`~matplotlib.path.Path` instance.\n\n        ``transform_path(path)`` is equivalent to\n        ``transform_path_affine(transform_path_non_affine(values))``.\n        \"\"\"\n        x = self.transform_non_affine(path.vertices)\n        return Path._fast_from_codes_and_verts(x, path.codes, path)",
        "begin_line": 1532,
        "end_line": 1543,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005339028296849973,
            "pseudo_dstar_susp": 0.00041911148365465214,
            "pseudo_tarantula_susp": 0.00031969309462915604,
            "pseudo_op2_susp": 0.00041911148365465214,
            "pseudo_barinel_susp": 0.00031969309462915604
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.transform_angles#1545",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.transform_angles(self, angles, pts, radians=False, pushoff=1e-05)",
        "snippet": "    def transform_angles(self, angles, pts, radians=False, pushoff=1e-5):\n        \"\"\"\n        Transforms a set of angles anchored at specific locations.\n\n        Parameters\n        ----------\n        angles : (N,) array-like\n            The angles to transform.\n        pts : (N, 2) array-like\n            The points where the angles are anchored.\n        radians : bool, default: False\n            Whether *angles* are radians or degrees.\n        pushoff : float\n            For each point in *pts* and angle in *angles*, the transformed\n            angle is computed by transforming a segment of length *pushoff*\n            starting at that point and making that angle relative to the\n            horizontal axis, and measuring the angle between the horizontal\n            axis and the transformed segment.\n\n        Returns\n        -------\n        transformed_angles : (N,) array\n        \"\"\"\n        # Must be 2D\n        if self.input_dims != 2 or self.output_dims != 2:\n            raise NotImplementedError('Only defined in 2D')\n        angles = np.asarray(angles)\n        pts = np.asarray(pts)\n        if angles.ndim != 1 or angles.shape[0] != pts.shape[0]:\n            raise ValueError(\"'angles' must be a column vector and have same \"\n                             \"number of rows as 'pts'\")\n        if pts.shape[1] != 2:\n            raise ValueError(\"'pts' must be array with 2 columns for x, y\")\n        # Convert to radians if desired\n        if not radians:\n            angles = np.deg2rad(angles)\n        # Move a short distance away\n        pts2 = pts + pushoff * np.c_[np.cos(angles), np.sin(angles)]\n        # Transform both sets of points\n        tpts = self.transform(pts)\n        tpts2 = self.transform(pts2)\n        # Calculate transformed angles\n        d = tpts2 - tpts\n        a = np.arctan2(d[:, 1], d[:, 0])\n        # Convert back to degrees if desired\n        if not radians:\n            a = np.rad2deg(a)\n        return a",
        "begin_line": 1545,
        "end_line": 1592,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformWrapper.__init__#1623",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformWrapper",
        "signature": "lib.matplotlib.transforms.TransformWrapper.__init__(self, child)",
        "snippet": "    def __init__(self, child):\n        \"\"\"\n        *child*: A class:`Transform` instance.  This child may later\n        be replaced with :meth:`set`.\n        \"\"\"\n        cbook._check_isinstance(Transform, child=child)\n        self._init(child)\n        self.set_children(child)",
        "begin_line": 1623,
        "end_line": 1630,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000275178866263071,
            "pseudo_dstar_susp": 0.00025412960609911054,
            "pseudo_tarantula_susp": 0.00029967036260113877,
            "pseudo_op2_susp": 0.00025412960609911054,
            "pseudo_barinel_susp": 0.00029967036260113877
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformWrapper._init#1632",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformWrapper",
        "signature": "lib.matplotlib.transforms.TransformWrapper._init(self, child)",
        "snippet": "    def _init(self, child):\n        Transform.__init__(self)\n        self.input_dims = child.input_dims\n        self.output_dims = child.output_dims\n        self._set(child)\n        self._invalid = 0",
        "begin_line": 1632,
        "end_line": 1637,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00042498937526561835,
            "pseudo_dstar_susp": 0.0006079027355623101,
            "pseudo_tarantula_susp": 0.00014703720041170417,
            "pseudo_op2_susp": 0.0006079027355623101,
            "pseudo_barinel_susp": 0.00014703720041170417
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformWrapper.__eq__#1639",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformWrapper",
        "signature": "lib.matplotlib.transforms.TransformWrapper.__eq__(self, other)",
        "snippet": "    def __eq__(self, other):\n        return self._child.__eq__(other)",
        "begin_line": 1639,
        "end_line": 1640,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00032829940906106366,
            "pseudo_dstar_susp": 0.00036010082823190496,
            "pseudo_tarantula_susp": 0.00029036004645760743,
            "pseudo_op2_susp": 0.00036010082823190496,
            "pseudo_barinel_susp": 0.00029036004645760743
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformWrapper.frozen#1648",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformWrapper",
        "signature": "lib.matplotlib.transforms.TransformWrapper.frozen(self)",
        "snippet": "    def frozen(self):\n        # docstring inherited\n        return self._child.frozen()",
        "begin_line": 1648,
        "end_line": 1650,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00030165912518853697,
            "pseudo_dstar_susp": 0.0003071253071253071,
            "pseudo_tarantula_susp": 0.0002248201438848921,
            "pseudo_op2_susp": 0.0003071253071253071,
            "pseudo_barinel_susp": 0.0002248201438848921
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformWrapper._set#1652",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformWrapper",
        "signature": "lib.matplotlib.transforms.TransformWrapper._set(self, child)",
        "snippet": "    def _set(self, child):\n        self._child = child\n\n        self.transform = child.transform\n        self.transform_affine = child.transform_affine\n        self.transform_non_affine = child.transform_non_affine\n        self.transform_path = child.transform_path\n        self.transform_path_affine = child.transform_path_affine\n        self.transform_path_non_affine = child.transform_path_non_affine\n        self.get_affine = child.get_affine\n        self.inverted = child.inverted\n        self.get_matrix = child.get_matrix",
        "begin_line": 1652,
        "end_line": 1663,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043706293706293706,
            "pseudo_dstar_susp": 0.0006222775357809583,
            "pseudo_tarantula_susp": 0.0002860411899313501,
            "pseudo_op2_susp": 0.0006222775357809583,
            "pseudo_barinel_susp": 0.0002860411899313501
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformWrapper.set#1669",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformWrapper",
        "signature": "lib.matplotlib.transforms.TransformWrapper.set(self, child)",
        "snippet": "    def set(self, child):\n        \"\"\"\n        Replace the current child of this transform with another one.\n\n        The new child must have the same number of input and output\n        dimensions as the current child.\n        \"\"\"\n        if (child.input_dims != self.input_dims or\n                child.output_dims != self.output_dims):\n            raise ValueError(\n                \"The new child must have the same number of input and output \"\n                \"dimensions as the current child\")\n\n        self.set_children(child)\n        self._set(child)\n\n        self._invalid = 0\n        self.invalidate()\n        self._invalid = 0",
        "begin_line": 1669,
        "end_line": 1687,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00038284839203675346,
            "pseudo_dstar_susp": 0.00048355899419729207,
            "pseudo_tarantula_susp": 0.0003023888720895071,
            "pseudo_op2_susp": 0.00048355899419729207,
            "pseudo_barinel_susp": 0.0003023888720895071
        }
    },
    {
        "name": "lib.matplotlib.transforms.AffineBase.__init__#1701",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.AffineBase",
        "signature": "lib.matplotlib.transforms.AffineBase.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        Transform.__init__(self, *args, **kwargs)\n        self._inverted = None",
        "begin_line": 1701,
        "end_line": 1703,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009596928982725527,
            "pseudo_dstar_susp": 0.0030120481927710845,
            "pseudo_tarantula_susp": 0.0002878526194588371,
            "pseudo_op2_susp": 0.0030120481927710845,
            "pseudo_barinel_susp": 0.0002878526194588371
        }
    },
    {
        "name": "lib.matplotlib.transforms.AffineBase.__array__#1705",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.AffineBase",
        "signature": "lib.matplotlib.transforms.AffineBase.__array__(self, *args, **kwargs)",
        "snippet": "    def __array__(self, *args, **kwargs):\n        # optimises the access of the transform matrix vs. the superclass\n        return self.get_matrix()",
        "begin_line": 1705,
        "end_line": 1707,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005336179295624333,
            "pseudo_dstar_susp": 0.00042319085907744394,
            "pseudo_tarantula_susp": 0.00022187708009762592,
            "pseudo_op2_susp": 0.00042319085907744394,
            "pseudo_barinel_susp": 0.00022187708009762592
        }
    },
    {
        "name": "lib.matplotlib.transforms.AffineBase.__eq__#1709",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.AffineBase",
        "signature": "lib.matplotlib.transforms.AffineBase.__eq__(self, other)",
        "snippet": "    def __eq__(self, other):\n        if getattr(other, \"is_affine\", False):\n            return np.all(self.get_matrix() == other.get_matrix())\n        return NotImplemented",
        "begin_line": 1709,
        "end_line": 1712,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004434589800443459,
            "pseudo_dstar_susp": 0.00040666937779585197,
            "pseudo_tarantula_susp": 0.0003023888720895071,
            "pseudo_op2_susp": 0.00040666937779585197,
            "pseudo_barinel_susp": 0.0003023888720895071
        }
    },
    {
        "name": "lib.matplotlib.transforms.AffineBase.transform#1714",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.AffineBase",
        "signature": "lib.matplotlib.transforms.AffineBase.transform(self, values)",
        "snippet": "    def transform(self, values):\n        # docstring inherited\n        return self.transform_affine(values)",
        "begin_line": 1714,
        "end_line": 1716,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012165450121654502,
            "pseudo_dstar_susp": 0.0023923444976076554,
            "pseudo_tarantula_susp": 0.00034965034965034965,
            "pseudo_op2_susp": 0.0023923444976076554,
            "pseudo_barinel_susp": 0.00034965034965034965
        }
    },
    {
        "name": "lib.matplotlib.transforms.AffineBase.transform_non_affine#1723",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.AffineBase",
        "signature": "lib.matplotlib.transforms.AffineBase.transform_non_affine(self, points)",
        "snippet": "    def transform_non_affine(self, points):\n        # docstring inherited\n        return points",
        "begin_line": 1723,
        "end_line": 1725,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000281928390188892,
            "pseudo_dstar_susp": 0.0002904443799012489,
            "pseudo_tarantula_susp": 0.0003450655624568668,
            "pseudo_op2_susp": 0.0002904443799012489,
            "pseudo_barinel_susp": 0.00034494653328734045
        }
    },
    {
        "name": "lib.matplotlib.transforms.AffineBase.transform_path#1727",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.AffineBase",
        "signature": "lib.matplotlib.transforms.AffineBase.transform_path(self, path)",
        "snippet": "    def transform_path(self, path):\n        # docstring inherited\n        return self.transform_path_affine(path)",
        "begin_line": 1727,
        "end_line": 1729,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002133560913164071,
            "pseudo_dstar_susp": 0.00021344717182497332,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00021344717182497332,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.transforms.AffineBase.transform_path_affine#1731",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.AffineBase",
        "signature": "lib.matplotlib.transforms.AffineBase.transform_path_affine(self, path)",
        "snippet": "    def transform_path_affine(self, path):\n        # docstring inherited\n        return Path(self.transform_affine(path.vertices),\n                    path.codes, path._interpolation_steps)",
        "begin_line": 1731,
        "end_line": 1734,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005512679162072767,
            "pseudo_dstar_susp": 0.00043782837127845885,
            "pseudo_tarantula_susp": 0.000315059861373661,
            "pseudo_op2_susp": 0.00043782837127845885,
            "pseudo_barinel_susp": 0.000315059861373661
        }
    },
    {
        "name": "lib.matplotlib.transforms.AffineBase.transform_path_non_affine#1736",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.AffineBase",
        "signature": "lib.matplotlib.transforms.AffineBase.transform_path_non_affine(self, path)",
        "snippet": "    def transform_path_non_affine(self, path):\n        # docstring inherited\n        return path",
        "begin_line": 1736,
        "end_line": 1738,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00031191515907673113,
            "pseudo_dstar_susp": 0.00027533039647577095,
            "pseudo_tarantula_susp": 0.0004224757076468103,
            "pseudo_op2_susp": 0.00027533039647577095,
            "pseudo_barinel_susp": 0.0004224757076468103
        }
    },
    {
        "name": "lib.matplotlib.transforms.AffineBase.get_affine#1740",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.AffineBase",
        "signature": "lib.matplotlib.transforms.AffineBase.get_affine(self)",
        "snippet": "    def get_affine(self):\n        # docstring inherited\n        return self",
        "begin_line": 1740,
        "end_line": 1742,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004945598417408506,
            "pseudo_dstar_susp": 0.00042301184433164127,
            "pseudo_tarantula_susp": 0.00031377470975839345,
            "pseudo_op2_susp": 0.00042301184433164127,
            "pseudo_barinel_susp": 0.00031377470975839345
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2DBase.frozen#1764",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2DBase",
        "signature": "lib.matplotlib.transforms.Affine2DBase.frozen(self)",
        "snippet": "    def frozen(self):\n        # docstring inherited\n        return Affine2D(self.get_matrix().copy())",
        "begin_line": 1764,
        "end_line": 1766,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004967709885742673,
            "pseudo_dstar_susp": 0.0004045307443365696,
            "pseudo_tarantula_susp": 0.00031377470975839345,
            "pseudo_op2_susp": 0.0004045307443365696,
            "pseudo_barinel_susp": 0.00031377470975839345
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2DBase.is_separable#1769",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2DBase",
        "signature": "lib.matplotlib.transforms.Affine2DBase.is_separable(self)",
        "snippet": "    def is_separable(self):\n        mtx = self.get_matrix()\n        return mtx[0, 1] == mtx[1, 0] == 0.0",
        "begin_line": 1769,
        "end_line": 1771,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004338394793926247,
            "pseudo_dstar_susp": 0.0005630630630630631,
            "pseudo_tarantula_susp": 0.00015098897780462027,
            "pseudo_op2_susp": 0.0005630630630630631,
            "pseudo_barinel_susp": 0.00015098897780462027
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2DBase.transform_affine#1793",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2DBase",
        "signature": "lib.matplotlib.transforms.Affine2DBase.transform_affine(self, points)",
        "snippet": "    def transform_affine(self, points):\n        mtx = self.get_matrix()\n        if isinstance(points, np.ma.MaskedArray):\n            tpoints = affine_transform(points.data, mtx)\n            return np.ma.MaskedArray(tpoints, mask=np.ma.getmask(points))\n        return affine_transform(points, mtx)",
        "begin_line": 1793,
        "end_line": 1798,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001145475372279496,
            "pseudo_dstar_susp": 0.0024509803921568627,
            "pseudo_tarantula_susp": 0.0003324468085106383,
            "pseudo_op2_susp": 0.0024509803921568627,
            "pseudo_barinel_susp": 0.0003324468085106383
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2DBase.inverted#1814",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2DBase",
        "signature": "lib.matplotlib.transforms.Affine2DBase.inverted(self)",
        "snippet": "    def inverted(self):\n        # docstring inherited\n        if self._inverted is None or self._invalid:\n            mtx = self.get_matrix()\n            shorthand_name = None\n            if self._shorthand_name:\n                shorthand_name = '(%s)-1' % self._shorthand_name\n            self._inverted = Affine2D(inv(mtx), shorthand_name=shorthand_name)\n            self._invalid = 0\n        return self._inverted",
        "begin_line": 1814,
        "end_line": 1823,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003225806451612903,
            "pseudo_dstar_susp": 0.00032393909944930353,
            "pseudo_tarantula_susp": 0.00023364485981308412,
            "pseudo_op2_susp": 0.00032393909944930353,
            "pseudo_barinel_susp": 0.00023364485981308412
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2D.__init__#1831",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2D",
        "signature": "lib.matplotlib.transforms.Affine2D.__init__(self, matrix=None, **kwargs)",
        "snippet": "    def __init__(self, matrix=None, **kwargs):\n        \"\"\"\n        Initialize an Affine transform from a 3x3 numpy float array::\n\n          a c e\n          b d f\n          0 0 1\n\n        If *matrix* is None, initialize with the identity transform.\n        \"\"\"\n        Affine2DBase.__init__(self, **kwargs)\n        if matrix is None:\n            # A bit faster than np.identity(3).\n            matrix = IdentityTransform._mtx.copy()\n        self._mtx = matrix\n        self._invalid = 0",
        "begin_line": 1831,
        "end_line": 1846,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011494252873563218,
            "pseudo_dstar_susp": 0.0016051364365971107,
            "pseudo_tarantula_susp": 0.000390625,
            "pseudo_op2_susp": 0.0016051364365971107,
            "pseudo_barinel_susp": 0.000390625
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2D.__str__#1848",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2D",
        "signature": "lib.matplotlib.transforms.Affine2D.__str__(self)",
        "snippet": "    def __str__(self):\n        return (\"{}(\\n\"\n                    \"{})\"\n                .format(type(self).__name__,\n                        _indent_str(self._mtx)))",
        "begin_line": 1848,
        "end_line": 1852,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2D.from_values#1855",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2D",
        "signature": "lib.matplotlib.transforms.Affine2D.from_values(a, b, c, d, e, f)",
        "snippet": "    def from_values(a, b, c, d, e, f):\n        \"\"\"\n        Create a new Affine2D instance from the given values::\n\n          a c e\n          b d f\n          0 0 1\n\n        .\n        \"\"\"\n        return Affine2D(\n            np.array([a, c, e, b, d, f, 0.0, 0.0, 1.0], float).reshape((3, 3)))",
        "begin_line": 1855,
        "end_line": 1866,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2D.get_matrix#1868",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2D",
        "signature": "lib.matplotlib.transforms.Affine2D.get_matrix(self)",
        "snippet": "    def get_matrix(self):\n        \"\"\"\n        Get the underlying transformation matrix as a 3x3 numpy array::\n\n          a c e\n          b d f\n          0 0 1\n\n        .\n        \"\"\"\n        if self._invalid:\n            self._inverted = None\n            self._invalid = 0\n        return self._mtx",
        "begin_line": 1868,
        "end_line": 1881,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012484394506866417,
            "pseudo_dstar_susp": 0.0024630541871921183,
            "pseudo_tarantula_susp": 0.000376081233546446,
            "pseudo_op2_susp": 0.0024630541871921183,
            "pseudo_barinel_susp": 0.000376081233546446
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2D.clear#1915",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2D",
        "signature": "lib.matplotlib.transforms.Affine2D.clear(self)",
        "snippet": "    def clear(self):\n        \"\"\"\n        Reset the underlying matrix to the identity transform.\n        \"\"\"\n        # A bit faster than np.identity(3).\n        self._mtx = IdentityTransform._mtx.copy()\n        self.invalidate()\n        return self",
        "begin_line": 1915,
        "end_line": 1922,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015384615384615385,
            "pseudo_dstar_susp": 0.0022172949002217295,
            "pseudo_tarantula_susp": 0.00039154267815191856,
            "pseudo_op2_susp": 0.0022172949002217295,
            "pseudo_barinel_susp": 0.00039154267815191856
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2D.rotate#1924",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2D",
        "signature": "lib.matplotlib.transforms.Affine2D.rotate(self, theta)",
        "snippet": "    def rotate(self, theta):\n        \"\"\"\n        Add a rotation (in radians) to this transform in place.\n\n        Returns *self*, so this method can easily be chained with more\n        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`\n        and :meth:`scale`.\n        \"\"\"\n        a = np.cos(theta)\n        b = np.sin(theta)\n        rotate_mtx = np.array([[a, -b, 0.0], [b, a, 0.0], [0.0, 0.0, 1.0]],\n                              float)\n        self._mtx = np.dot(rotate_mtx, self._mtx)\n        self.invalidate()\n        return self",
        "begin_line": 1924,
        "end_line": 1938,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013717421124828531,
            "pseudo_dstar_susp": 0.0031446540880503146,
            "pseudo_tarantula_susp": 0.0004472271914132379,
            "pseudo_op2_susp": 0.0031446540880503146,
            "pseudo_barinel_susp": 0.0004472271914132379
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2D.rotate_deg#1940",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2D",
        "signature": "lib.matplotlib.transforms.Affine2D.rotate_deg(self, degrees)",
        "snippet": "    def rotate_deg(self, degrees):\n        \"\"\"\n        Add a rotation (in degrees) to this transform in place.\n\n        Returns *self*, so this method can easily be chained with more\n        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`\n        and :meth:`scale`.\n        \"\"\"\n        return self.rotate(np.deg2rad(degrees))",
        "begin_line": 1940,
        "end_line": 1948,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014771048744460858,
            "pseudo_dstar_susp": 0.0011806375442739079,
            "pseudo_tarantula_susp": 0.0004610419548178884,
            "pseudo_op2_susp": 0.0011806375442739079,
            "pseudo_barinel_susp": 0.0004610419548178884
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2D.rotate_deg_around#1960",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2D",
        "signature": "lib.matplotlib.transforms.Affine2D.rotate_deg_around(self, x, y, degrees)",
        "snippet": "    def rotate_deg_around(self, x, y, degrees):\n        \"\"\"\n        Add a rotation (in degrees) around the point (x, y) in place.\n\n        Returns *self*, so this method can easily be chained with more\n        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`\n        and :meth:`scale`.\n        \"\"\"\n        # Cast to float to avoid wraparound issues with uint8's\n        x, y = float(x), float(y)\n        return self.translate(-x, -y).rotate_deg(degrees).translate(x, y)",
        "begin_line": 1960,
        "end_line": 1970,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014970059880239522,
            "pseudo_dstar_susp": 0.0011933174224343676,
            "pseudo_tarantula_susp": 0.00046382189239332097,
            "pseudo_op2_susp": 0.0011933174224343676,
            "pseudo_barinel_susp": 0.00046382189239332097
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2D.translate#1972",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2D",
        "signature": "lib.matplotlib.transforms.Affine2D.translate(self, tx, ty)",
        "snippet": "    def translate(self, tx, ty):\n        \"\"\"\n        Adds a translation in place.\n\n        Returns *self*, so this method can easily be chained with more\n        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`\n        and :meth:`scale`.\n        \"\"\"\n        translate_mtx = np.array(\n            [[1.0, 0.0, tx], [0.0, 1.0, ty], [0.0, 0.0, 1.0]], float)\n        self._mtx = np.dot(translate_mtx, self._mtx)\n        self.invalidate()\n        return self",
        "begin_line": 1972,
        "end_line": 1984,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010548523206751054,
            "pseudo_dstar_susp": 0.0036231884057971015,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.0036231884057971015,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2D.scale#1986",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2D",
        "signature": "lib.matplotlib.transforms.Affine2D.scale(self, sx, sy=None)",
        "snippet": "    def scale(self, sx, sy=None):\n        \"\"\"\n        Adds a scale in place.\n\n        If *sy* is None, the same scale is applied in both the *x*- and\n        *y*-directions.\n\n        Returns *self*, so this method can easily be chained with more\n        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`\n        and :meth:`scale`.\n        \"\"\"\n        if sy is None:\n            sy = sx\n        scale_mtx = np.array(\n            [[sx, 0.0, 0.0], [0.0, sy, 0.0], [0.0, 0.0, 1.0]], float)\n        self._mtx = np.dot(scale_mtx, self._mtx)\n        self.invalidate()\n        return self",
        "begin_line": 1986,
        "end_line": 2003,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012135922330097086,
            "pseudo_dstar_susp": 0.0033222591362126247,
            "pseudo_tarantula_susp": 0.0004,
            "pseudo_op2_susp": 0.0033222591362126247,
            "pseudo_barinel_susp": 0.0004
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2D.skew#2005",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2D",
        "signature": "lib.matplotlib.transforms.Affine2D.skew(self, xShear, yShear)",
        "snippet": "    def skew(self, xShear, yShear):\n        \"\"\"\n        Adds a skew in place.\n\n        *xShear* and *yShear* are the shear angles along the *x*- and\n        *y*-axes, respectively, in radians.\n\n        Returns *self*, so this method can easily be chained with more\n        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`\n        and :meth:`scale`.\n        \"\"\"\n        rotX = np.tan(xShear)\n        rotY = np.tan(yShear)\n        skew_mtx = np.array(\n            [[1.0, rotX, 0.0], [rotY, 1.0, 0.0], [0.0, 0.0, 1.0]], float)\n        self._mtx = np.dot(skew_mtx, self._mtx)\n        self.invalidate()\n        return self",
        "begin_line": 2005,
        "end_line": 2022,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.transforms.IdentityTransform.frozen#2045",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.IdentityTransform",
        "signature": "lib.matplotlib.transforms.IdentityTransform.frozen(self)",
        "snippet": "    def frozen(self):\n        # docstring inherited\n        return self",
        "begin_line": 2045,
        "end_line": 2047,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002296211251435132,
            "pseudo_dstar_susp": 0.00023724792408066428,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.00023724792408066428,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.transforms.IdentityTransform.get_matrix#2053",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.IdentityTransform",
        "signature": "lib.matplotlib.transforms.IdentityTransform.get_matrix(self)",
        "snippet": "    def get_matrix(self):\n        # docstring inherited\n        return self._mtx",
        "begin_line": 2053,
        "end_line": 2055,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003487966515521451,
            "pseudo_dstar_susp": 0.0004675081813931744,
            "pseudo_tarantula_susp": 0.0002913752913752914,
            "pseudo_op2_susp": 0.0004675081813931744,
            "pseudo_barinel_susp": 0.0002913752913752914
        }
    },
    {
        "name": "lib.matplotlib.transforms.IdentityTransform.transform#2057",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.IdentityTransform",
        "signature": "lib.matplotlib.transforms.IdentityTransform.transform(self, points)",
        "snippet": "    def transform(self, points):\n        # docstring inherited\n        return np.asanyarray(points)",
        "begin_line": 2057,
        "end_line": 2059,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00027277686852154935,
            "pseudo_dstar_susp": 0.00025144581342720644,
            "pseudo_tarantula_susp": 0.0003020235578375113,
            "pseudo_op2_susp": 0.00025144581342720644,
            "pseudo_barinel_susp": 0.0003020235578375113
        }
    },
    {
        "name": "lib.matplotlib.transforms.IdentityTransform.transform_non_affine#2065",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.IdentityTransform",
        "signature": "lib.matplotlib.transforms.IdentityTransform.transform_non_affine(self, points)",
        "snippet": "    def transform_non_affine(self, points):\n        # docstring inherited\n        return np.asanyarray(points)",
        "begin_line": 2065,
        "end_line": 2067,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001618646811265782,
            "pseudo_dstar_susp": 0.00019015021867275147,
            "pseudo_tarantula_susp": 0.00013672409078479628,
            "pseudo_op2_susp": 0.00019015021867275147,
            "pseudo_barinel_susp": 0.00013672409078479628
        }
    },
    {
        "name": "lib.matplotlib.transforms.IdentityTransform.transform_path#2069",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.IdentityTransform",
        "signature": "lib.matplotlib.transforms.IdentityTransform.transform_path(self, path)",
        "snippet": "    def transform_path(self, path):\n        # docstring inherited\n        return path",
        "begin_line": 2069,
        "end_line": 2071,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.transforms.IdentityTransform.transform_path_affine#2073",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.IdentityTransform",
        "signature": "lib.matplotlib.transforms.IdentityTransform.transform_path_affine(self, path)",
        "snippet": "    def transform_path_affine(self, path):\n        # docstring inherited\n        return path",
        "begin_line": 2073,
        "end_line": 2075,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.transforms.IdentityTransform.transform_path_non_affine#2077",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.IdentityTransform",
        "signature": "lib.matplotlib.transforms.IdentityTransform.transform_path_non_affine(self, path)",
        "snippet": "    def transform_path_non_affine(self, path):\n        # docstring inherited\n        return path",
        "begin_line": 2077,
        "end_line": 2079,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00031725888324873094,
            "pseudo_dstar_susp": 0.0002666666666666667,
            "pseudo_tarantula_susp": 0.0003850596842510589,
            "pseudo_op2_susp": 0.0002666666666666667,
            "pseudo_barinel_susp": 0.00038491147036181676
        }
    },
    {
        "name": "lib.matplotlib.transforms.IdentityTransform.get_affine#2081",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.IdentityTransform",
        "signature": "lib.matplotlib.transforms.IdentityTransform.get_affine(self)",
        "snippet": "    def get_affine(self):\n        # docstring inherited\n        return self",
        "begin_line": 2081,
        "end_line": 2083,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00031446540880503143,
            "pseudo_dstar_susp": 0.00031210986267166043,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00031210986267166043,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.transforms.IdentityTransform.inverted#2085",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.IdentityTransform",
        "signature": "lib.matplotlib.transforms.IdentityTransform.inverted(self)",
        "snippet": "    def inverted(self):\n        # docstring inherited\n        return self",
        "begin_line": 2085,
        "end_line": 2087,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004597701149425287,
            "pseudo_dstar_susp": 0.0003590664272890485,
            "pseudo_tarantula_susp": 0.00037509377344336085,
            "pseudo_op2_susp": 0.0003590664272890485,
            "pseudo_barinel_susp": 0.00037509377344336085
        }
    },
    {
        "name": "lib.matplotlib.transforms._BlendedMixin.__eq__#2093",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms._BlendedMixin",
        "signature": "lib.matplotlib.transforms._BlendedMixin.__eq__(self, other)",
        "snippet": "    def __eq__(self, other):\n        if isinstance(other, (BlendedAffine2D, BlendedGenericTransform)):\n            return (self._x == other._x) and (self._y == other._y)\n        elif self._x == self._y:\n            return self._x == other\n        else:\n            return NotImplemented",
        "begin_line": 2093,
        "end_line": 2099,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003291639236339697,
            "pseudo_dstar_susp": 0.0003562522265764161,
            "pseudo_tarantula_susp": 0.0002829654782116582,
            "pseudo_op2_susp": 0.0003562522265764161,
            "pseudo_barinel_susp": 0.0002829654782116582
        }
    },
    {
        "name": "lib.matplotlib.transforms._BlendedMixin.contains_branch_seperately#2101",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms._BlendedMixin",
        "signature": "lib.matplotlib.transforms._BlendedMixin.contains_branch_seperately(self, transform)",
        "snippet": "    def contains_branch_seperately(self, transform):\n        return (self._x.contains_branch(transform),\n                self._y.contains_branch(transform))",
        "begin_line": 2101,
        "end_line": 2103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000225022502250225,
            "pseudo_dstar_susp": 0.00020060180541624874,
            "pseudo_tarantula_susp": 0.00032393909944930353,
            "pseudo_op2_susp": 0.00020060180541624874,
            "pseudo_barinel_susp": 0.00032393909944930353
        }
    },
    {
        "name": "lib.matplotlib.transforms.BlendedGenericTransform.__init__#2127",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BlendedGenericTransform",
        "signature": "lib.matplotlib.transforms.BlendedGenericTransform.__init__(self, x_transform, y_transform, **kwargs)",
        "snippet": "    def __init__(self, x_transform, y_transform, **kwargs):\n        \"\"\"\n        Create a new \"blended\" transform using *x_transform* to\n        transform the *x*-axis and *y_transform* to transform the\n        *y*-axis.\n\n        You will generally not call this constructor directly but use the\n        `blended_transform_factory` function instead, which can determine\n        automatically which kind of blended transform to create.\n        \"\"\"\n        # Here we ask: \"Does it blend?\"\n\n        Transform.__init__(self, **kwargs)\n        self._x = x_transform\n        self._y = y_transform\n        self.set_children(x_transform, y_transform)\n        self._affine = None",
        "begin_line": 2127,
        "end_line": 2143,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00037257824143070045,
            "pseudo_dstar_susp": 0.0005370569280343716,
            "pseudo_tarantula_susp": 0.0002913752913752914,
            "pseudo_op2_susp": 0.0005370569280343716,
            "pseudo_barinel_susp": 0.0002913752913752914
        }
    },
    {
        "name": "lib.matplotlib.transforms.BlendedGenericTransform.transform_non_affine#2162",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BlendedGenericTransform",
        "signature": "lib.matplotlib.transforms.BlendedGenericTransform.transform_non_affine(self, points)",
        "snippet": "    def transform_non_affine(self, points):\n        # docstring inherited\n        if self._x.is_affine and self._y.is_affine:\n            return points\n        x = self._x\n        y = self._y\n\n        if x == y and x.input_dims == 2:\n            return x.transform_non_affine(points)\n\n        if x.input_dims == 2:\n            x_points = x.transform_non_affine(points)[:, 0:1]\n        else:\n            x_points = x.transform_non_affine(points[:, 0])\n            x_points = x_points.reshape((len(x_points), 1))\n\n        if y.input_dims == 2:\n            y_points = y.transform_non_affine(points)[:, 1:]\n        else:\n            y_points = y.transform_non_affine(points[:, 1])\n            y_points = y_points.reshape((len(y_points), 1))\n\n        if (isinstance(x_points, np.ma.MaskedArray) or\n                isinstance(y_points, np.ma.MaskedArray)):\n            return np.ma.concatenate((x_points, y_points), 1)\n        else:\n            return np.concatenate((x_points, y_points), 1)",
        "begin_line": 2162,
        "end_line": 2188,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001668335001668335,
            "pseudo_dstar_susp": 0.0001979414093428345,
            "pseudo_tarantula_susp": 0.00013798813302056022,
            "pseudo_op2_susp": 0.0001979414093428345,
            "pseudo_barinel_susp": 0.0001379690949227373
        }
    },
    {
        "name": "lib.matplotlib.transforms.BlendedGenericTransform.inverted#2190",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BlendedGenericTransform",
        "signature": "lib.matplotlib.transforms.BlendedGenericTransform.inverted(self)",
        "snippet": "    def inverted(self):\n        # docstring inherited\n        return BlendedGenericTransform(self._x.inverted(), self._y.inverted())",
        "begin_line": 2190,
        "end_line": 2192,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.transforms.BlendedGenericTransform.get_affine#2194",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BlendedGenericTransform",
        "signature": "lib.matplotlib.transforms.BlendedGenericTransform.get_affine(self)",
        "snippet": "    def get_affine(self):\n        # docstring inherited\n        if self._invalid or self._affine is None:\n            if self._x == self._y:\n                self._affine = self._x.get_affine()\n            else:\n                x_mtx = self._x.get_affine().get_matrix()\n                y_mtx = self._y.get_affine().get_matrix()\n                # This works because we already know the transforms are\n                # separable, though normally one would want to set b and\n                # c to zero.\n                mtx = np.vstack((x_mtx[0], y_mtx[1], [0.0, 0.0, 1.0]))\n                self._affine = Affine2D(mtx)\n            self._invalid = 0\n        return self._affine",
        "begin_line": 2194,
        "end_line": 2208,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005254860746190226,
            "pseudo_dstar_susp": 0.0003935458480913026,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.0003935458480913026,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.transforms.BlendedAffine2D.__init__#2221",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BlendedAffine2D",
        "signature": "lib.matplotlib.transforms.BlendedAffine2D.__init__(self, x_transform, y_transform, **kwargs)",
        "snippet": "    def __init__(self, x_transform, y_transform, **kwargs):\n        \"\"\"\n        Create a new \"blended\" transform using *x_transform* to\n        transform the *x*-axis and *y_transform* to transform the\n        *y*-axis.\n\n        Both *x_transform* and *y_transform* must be 2D affine\n        transforms.\n\n        You will generally not call this constructor directly but use the\n        `blended_transform_factory` function instead, which can determine\n        automatically which kind of blended transform to create.\n        \"\"\"\n        is_affine = x_transform.is_affine and y_transform.is_affine\n        is_separable = x_transform.is_separable and y_transform.is_separable\n        is_correct = is_affine and is_separable\n        if not is_correct:\n            raise ValueError(\"Both *x_transform* and *y_transform* must be 2D \"\n                             \"affine transforms\")\n\n        Transform.__init__(self, **kwargs)\n        self._x = x_transform\n        self._y = y_transform\n        self.set_children(x_transform, y_transform)\n\n        Affine2DBase.__init__(self)\n        self._mtx = None",
        "begin_line": 2221,
        "end_line": 2247,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000286286859433152,
            "pseudo_dstar_susp": 0.0002653927813163482,
            "pseudo_tarantula_susp": 0.0002891008962127783,
            "pseudo_op2_susp": 0.0002653927813163482,
            "pseudo_barinel_susp": 0.0002891008962127783
        }
    },
    {
        "name": "lib.matplotlib.transforms.BlendedAffine2D.get_matrix#2249",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BlendedAffine2D",
        "signature": "lib.matplotlib.transforms.BlendedAffine2D.get_matrix(self)",
        "snippet": "    def get_matrix(self):\n        # docstring inherited\n        if self._invalid:\n            if self._x == self._y:\n                self._mtx = self._x.get_matrix()\n            else:\n                x_mtx = self._x.get_matrix()\n                y_mtx = self._y.get_matrix()\n                # This works because we already know the transforms are\n                # separable, though normally one would want to set b and\n                # c to zero.\n                self._mtx = np.vstack((x_mtx[0], y_mtx[1], [0.0, 0.0, 1.0]))\n            self._inverted = None\n            self._invalid = 0\n        return self._mtx",
        "begin_line": 2249,
        "end_line": 2263,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00045599635202918376,
            "pseudo_dstar_susp": 0.00043402777777777775,
            "pseudo_tarantula_susp": 0.00016792611251049538,
            "pseudo_op2_susp": 0.00043402777777777775,
            "pseudo_barinel_susp": 0.00016792611251049538
        }
    },
    {
        "name": "lib.matplotlib.transforms.blended_transform_factory#2266",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms",
        "signature": "lib.matplotlib.transforms.blended_transform_factory(x_transform, y_transform)",
        "snippet": "def blended_transform_factory(x_transform, y_transform):\n    \"\"\"\n    Create a new \"blended\" transform using *x_transform* to transform\n    the *x*-axis and *y_transform* to transform the *y*-axis.\n\n    A faster version of the blended transform is returned for the case\n    where both child transforms are affine.\n    \"\"\"\n    if (isinstance(x_transform, Affine2DBase)\n        and isinstance(y_transform, Affine2DBase)):\n        return BlendedAffine2D(x_transform, y_transform)\n    return BlendedGenericTransform(x_transform, y_transform)",
        "begin_line": 2266,
        "end_line": 2277,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00042716787697565144,
            "pseudo_dstar_susp": 0.0006119951040391676,
            "pseudo_tarantula_susp": 0.00015213753232922562,
            "pseudo_op2_susp": 0.0006119951040391676,
            "pseudo_barinel_susp": 0.00015213753232922562
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeGenericTransform.__init__#2290",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeGenericTransform",
        "signature": "lib.matplotlib.transforms.CompositeGenericTransform.__init__(self, a, b, **kwargs)",
        "snippet": "    def __init__(self, a, b, **kwargs):\n        \"\"\"\n        Create a new composite transform that is the result of\n        applying transform *a* then transform *b*.\n\n        You will generally not call this constructor directly but use the\n        `composite_transform_factory` function instead, which can automatically\n        choose the best kind of composite transform instance to create.\n        \"\"\"\n        if a.output_dims != b.input_dims:\n            raise ValueError(\"The output dimension of 'a' must be equal to \"\n                             \"the input dimensions of 'b'\")\n        self.input_dims = a.input_dims\n        self.output_dims = b.output_dims\n\n        Transform.__init__(self, **kwargs)\n        self._a = a\n        self._b = b\n        self.set_children(a, b)",
        "begin_line": 2290,
        "end_line": 2308,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001182033096926714,
            "pseudo_dstar_susp": 0.003115264797507788,
            "pseudo_tarantula_susp": 0.0003924646781789639,
            "pseudo_op2_susp": 0.003115264797507788,
            "pseudo_barinel_susp": 0.0003924646781789639
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeGenericTransform.frozen#2310",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeGenericTransform",
        "signature": "lib.matplotlib.transforms.CompositeGenericTransform.frozen(self)",
        "snippet": "    def frozen(self):\n        # docstring inherited\n        self._invalid = 0\n        frozen = composite_transform_factory(\n            self._a.frozen(), self._b.frozen())\n        if not isinstance(frozen, CompositeGenericTransform):\n            return frozen.frozen()\n        return frozen",
        "begin_line": 2310,
        "end_line": 2317,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00044822949350067237,
            "pseudo_dstar_susp": 0.0003439972480220158,
            "pseudo_tarantula_susp": 0.00027210884353741496,
            "pseudo_op2_susp": 0.0003439972480220158,
            "pseudo_barinel_susp": 0.0002720348204570185
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeGenericTransform._invalidate_internal#2319",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeGenericTransform",
        "signature": "lib.matplotlib.transforms.CompositeGenericTransform._invalidate_internal(self, value, invalidating_node)",
        "snippet": "    def _invalidate_internal(self, value, invalidating_node):\n        # In some cases for a composite transform, an invalidating call to\n        # AFFINE_ONLY needs to be extended to invalidate the NON_AFFINE part\n        # too. These cases are when the right hand transform is non-affine and\n        # either:\n        # (a) the left hand transform is non affine\n        # (b) it is the left hand node which has triggered the invalidation\n        if value == Transform.INVALID_AFFINE \\\n            and not self._b.is_affine \\\n            and (not self._a.is_affine or invalidating_node is self._a):\n\n            value = Transform.INVALID\n\n        Transform._invalidate_internal(self, value=value,\n                                       invalidating_node=invalidating_node)",
        "begin_line": 2319,
        "end_line": 2333,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040716612377850165,
            "pseudo_dstar_susp": 0.0005390835579514825,
            "pseudo_tarantula_susp": 0.000231000231000231,
            "pseudo_op2_susp": 0.0005390835579514825,
            "pseudo_barinel_susp": 0.000231000231000231
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeGenericTransform.__eq__#2335",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeGenericTransform",
        "signature": "lib.matplotlib.transforms.CompositeGenericTransform.__eq__(self, other)",
        "snippet": "    def __eq__(self, other):\n        if isinstance(other, (CompositeGenericTransform, CompositeAffine2D)):\n            return self is other or (self._a == other._a\n                                     and self._b == other._b)\n        else:\n            return False",
        "begin_line": 2335,
        "end_line": 2340,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005344735435595938,
            "pseudo_dstar_susp": 0.00044742729306487697,
            "pseudo_tarantula_susp": 0.0002878526194588371,
            "pseudo_op2_susp": 0.00044742729306487697,
            "pseudo_barinel_susp": 0.0002878526194588371
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeGenericTransform._iter_break_from_left_to_right#2342",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeGenericTransform",
        "signature": "lib.matplotlib.transforms.CompositeGenericTransform._iter_break_from_left_to_right(self)",
        "snippet": "    def _iter_break_from_left_to_right(self):\n        for left, right in self._a._iter_break_from_left_to_right():\n            yield left, right + self._b\n        for left, right in self._b._iter_break_from_left_to_right():\n            yield self._a + left, right",
        "begin_line": 2342,
        "end_line": 2346,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00033178500331785003,
            "pseudo_dstar_susp": 0.0003679175864606328,
            "pseudo_tarantula_susp": 0.00028368794326241134,
            "pseudo_op2_susp": 0.0003679175864606328,
            "pseudo_barinel_susp": 0.00028368794326241134
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeGenericTransform.__str__#2355",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeGenericTransform",
        "signature": "lib.matplotlib.transforms.CompositeGenericTransform.__str__(self)",
        "snippet": "    def __str__(self):\n        return (\"{}(\\n\"\n                    \"{},\\n\"\n                    \"{})\"\n                .format(type(self).__name__,\n                        _indent_str(self._a),\n                        _indent_str(self._b)))",
        "begin_line": 2355,
        "end_line": 2361,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeGenericTransform.transform_affine#2363",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeGenericTransform",
        "signature": "lib.matplotlib.transforms.CompositeGenericTransform.transform_affine(self, points)",
        "snippet": "    def transform_affine(self, points):\n        # docstring inherited\n        return self.get_affine().transform(points)",
        "begin_line": 2363,
        "end_line": 2365,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004955401387512388,
            "pseudo_dstar_susp": 0.0004257130693912303,
            "pseudo_tarantula_susp": 0.0002781641168289291,
            "pseudo_op2_susp": 0.0004257130693912303,
            "pseudo_barinel_susp": 0.0002781641168289291
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeGenericTransform.transform_non_affine#2367",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeGenericTransform",
        "signature": "lib.matplotlib.transforms.CompositeGenericTransform.transform_non_affine(self, points)",
        "snippet": "    def transform_non_affine(self, points):\n        # docstring inherited\n        if self._a.is_affine and self._b.is_affine:\n            return points\n        elif not self._a.is_affine and self._b.is_affine:\n            return self._a.transform_non_affine(points)\n        else:\n            return self._b.transform_non_affine(\n                                self._a.transform(points))",
        "begin_line": 2367,
        "end_line": 2375,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005221932114882506,
            "pseudo_dstar_susp": 0.000510986203372509,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.000510986203372509,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeGenericTransform.transform_path_non_affine#2377",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeGenericTransform",
        "signature": "lib.matplotlib.transforms.CompositeGenericTransform.transform_path_non_affine(self, path)",
        "snippet": "    def transform_path_non_affine(self, path):\n        # docstring inherited\n        if self._a.is_affine and self._b.is_affine:\n            return path\n        elif not self._a.is_affine and self._b.is_affine:\n            return self._a.transform_path_non_affine(path)\n        else:\n            return self._b.transform_path_non_affine(\n                                    self._a.transform_path(path))",
        "begin_line": 2377,
        "end_line": 2385,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012903225806451613,
            "pseudo_dstar_susp": 0.00228310502283105,
            "pseudo_tarantula_susp": 0.00036603221083455345,
            "pseudo_op2_susp": 0.002277904328018223,
            "pseudo_barinel_susp": 0.00036603221083455345
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeGenericTransform.get_affine#2387",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeGenericTransform",
        "signature": "lib.matplotlib.transforms.CompositeGenericTransform.get_affine(self)",
        "snippet": "    def get_affine(self):\n        # docstring inherited\n        if not self._b.is_affine:\n            return self._b.get_affine()\n        else:\n            return Affine2D(np.dot(self._b.get_affine().get_matrix(),\n                                self._a.get_affine().get_matrix()))",
        "begin_line": 2387,
        "end_line": 2393,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012376237623762376,
            "pseudo_dstar_susp": 0.0022675736961451248,
            "pseudo_tarantula_susp": 0.0003522367030644593,
            "pseudo_op2_susp": 0.0022624434389140274,
            "pseudo_barinel_susp": 0.0003522367030644593
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeGenericTransform.inverted#2395",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeGenericTransform",
        "signature": "lib.matplotlib.transforms.CompositeGenericTransform.inverted(self)",
        "snippet": "    def inverted(self):\n        # docstring inherited\n        return CompositeGenericTransform(\n            self._b.inverted(), self._a.inverted())",
        "begin_line": 2395,
        "end_line": 2398,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023889154323936931,
            "pseudo_dstar_susp": 0.0002738225629791895,
            "pseudo_tarantula_susp": 0.00021621621621621621,
            "pseudo_op2_susp": 0.0002738225629791895,
            "pseudo_barinel_susp": 0.00021598272138228941
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeAffine2D.__init__#2408",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeAffine2D",
        "signature": "lib.matplotlib.transforms.CompositeAffine2D.__init__(self, a, b, **kwargs)",
        "snippet": "    def __init__(self, a, b, **kwargs):\n        \"\"\"\n        Create a new composite transform that is the result of\n        applying transform *a* then transform *b*.\n\n        Both *a* and *b* must be instances of :class:`Affine2DBase`.\n\n        You will generally not call this constructor directly but use the\n        `composite_transform_factory` function instead, which can automatically\n        choose the best kind of composite transform instance to create.\n        \"\"\"\n        if not a.is_affine or not b.is_affine:\n            raise ValueError(\"'a' and 'b' must be affine transforms\")\n        if a.output_dims != b.input_dims:\n            raise ValueError(\"The output dimension of 'a' must be equal to \"\n                             \"the input dimensions of 'b'\")\n        self.input_dims = a.input_dims\n        self.output_dims = b.output_dims\n\n        Affine2DBase.__init__(self, **kwargs)\n        self._a = a\n        self._b = b\n        self.set_children(a, b)\n        self._mtx = None",
        "begin_line": 2408,
        "end_line": 2431,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00048007681228996637,
            "pseudo_dstar_susp": 0.00035523978685612787,
            "pseudo_tarantula_susp": 0.00030175015087507544,
            "pseudo_op2_susp": 0.00035523978685612787,
            "pseudo_barinel_susp": 0.00030175015087507544
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeAffine2D._iter_break_from_left_to_right#2437",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeAffine2D",
        "signature": "lib.matplotlib.transforms.CompositeAffine2D._iter_break_from_left_to_right(self)",
        "snippet": "    def _iter_break_from_left_to_right(self):\n        for left, right in self._a._iter_break_from_left_to_right():\n            yield left, right + self._b\n        for left, right in self._b._iter_break_from_left_to_right():\n            yield self._a + left, right",
        "begin_line": 2437,
        "end_line": 2441,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000209819555182543,
            "pseudo_dstar_susp": 0.0002134016218523261,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0002134016218523261,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeAffine2D.get_matrix#2451",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeAffine2D",
        "signature": "lib.matplotlib.transforms.CompositeAffine2D.get_matrix(self)",
        "snippet": "    def get_matrix(self):\n        # docstring inherited\n        if self._invalid:\n            self._mtx = np.dot(\n                self._b.get_matrix(),\n                self._a.get_matrix())\n            self._inverted = None\n            self._invalid = 0\n        return self._mtx",
        "begin_line": 2451,
        "end_line": 2459,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005305039787798408,
            "pseudo_dstar_susp": 0.000355998576005696,
            "pseudo_tarantula_susp": 0.0002531004808909137,
            "pseudo_op2_susp": 0.000355998576005696,
            "pseudo_barinel_susp": 0.0002531004808909137
        }
    },
    {
        "name": "lib.matplotlib.transforms.composite_transform_factory#2462",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms",
        "signature": "lib.matplotlib.transforms.composite_transform_factory(a, b)",
        "snippet": "def composite_transform_factory(a, b):\n    \"\"\"\n    Create a new composite transform that is the result of applying\n    transform a then transform b.\n\n    Shortcut versions of the blended transform are provided for the\n    case where both child transforms are affine, or one or the other\n    is the identity transform.\n\n    Composite transforms may also be created using the '+' operator,\n    e.g.::\n\n      c = a + b\n    \"\"\"\n    # check to see if any of a or b are IdentityTransforms. We use\n    # isinstance here to guarantee that the transforms will *always*\n    # be IdentityTransforms. Since TransformWrappers are mutable,\n    # use of equality here would be wrong.\n    if isinstance(a, IdentityTransform):\n        return b\n    elif isinstance(b, IdentityTransform):\n        return a\n    elif isinstance(a, Affine2D) and isinstance(b, Affine2D):\n        return CompositeAffine2D(a, b)\n    return CompositeGenericTransform(a, b)",
        "begin_line": 2462,
        "end_line": 2486,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010775862068965517,
            "pseudo_dstar_susp": 0.003076923076923077,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.003076923076923077,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxTransform.__init__#2495",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxTransform",
        "signature": "lib.matplotlib.transforms.BboxTransform.__init__(self, boxin, boxout, **kwargs)",
        "snippet": "    def __init__(self, boxin, boxout, **kwargs):\n        \"\"\"\n        Create a new :class:`BboxTransform` that linearly transforms\n        points from *boxin* to *boxout*.\n        \"\"\"\n        if not boxin.is_bbox or not boxout.is_bbox:\n            raise ValueError(\"'boxin' and 'boxout' must be bbox\")\n\n        Affine2DBase.__init__(self, **kwargs)\n        self._boxin = boxin\n        self._boxout = boxout\n        self.set_children(boxin, boxout)\n        self._mtx = None\n        self._inverted = None",
        "begin_line": 2495,
        "end_line": 2508,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022119000221190003,
            "pseudo_dstar_susp": 0.00020815986677768527,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00020815986677768527,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxTransform.get_matrix#2518",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxTransform",
        "signature": "lib.matplotlib.transforms.BboxTransform.get_matrix(self)",
        "snippet": "    def get_matrix(self):\n        # docstring inherited\n        if self._invalid:\n            inl, inb, inw, inh = self._boxin.bounds\n            outl, outb, outw, outh = self._boxout.bounds\n            x_scale = outw / inw\n            y_scale = outh / inh\n            if DEBUG and (x_scale == 0 or y_scale == 0):\n                raise ValueError(\n                    \"Transforming from or to a singular bounding box\")\n            self._mtx = np.array([[x_scale, 0.0    , (-inl*x_scale+outl)],\n                                  [0.0    , y_scale, (-inb*y_scale+outb)],\n                                  [0.0    , 0.0    , 1.0        ]],\n                                 float)\n            self._inverted = None\n            self._invalid = 0\n        return self._mtx",
        "begin_line": 2518,
        "end_line": 2534,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022119000221190003,
            "pseudo_dstar_susp": 0.00020815986677768527,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00020815986677768527,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxTransformTo.__init__#2544",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxTransformTo",
        "signature": "lib.matplotlib.transforms.BboxTransformTo.__init__(self, boxout, **kwargs)",
        "snippet": "    def __init__(self, boxout, **kwargs):\n        \"\"\"\n        Create a new :class:`BboxTransformTo` that linearly transforms\n        points from the unit bounding box to *boxout*.\n        \"\"\"\n        if not boxout.is_bbox:\n            raise ValueError(\"'boxout' must be bbox\")\n\n        Affine2DBase.__init__(self, **kwargs)\n        self._boxout = boxout\n        self.set_children(boxout)\n        self._mtx = None\n        self._inverted = None",
        "begin_line": 2544,
        "end_line": 2556,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009832841691248771,
            "pseudo_dstar_susp": 0.0031746031746031746,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.0031746031746031746,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxTransformTo.__str__#2558",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxTransformTo",
        "signature": "lib.matplotlib.transforms.BboxTransformTo.__str__(self)",
        "snippet": "    def __str__(self):\n        return (\"{}(\\n\"\n                    \"{})\"\n                .format(type(self).__name__,\n                        _indent_str(self._boxout)))",
        "begin_line": 2558,
        "end_line": 2562,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxTransformTo.get_matrix#2564",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxTransformTo",
        "signature": "lib.matplotlib.transforms.BboxTransformTo.get_matrix(self)",
        "snippet": "    def get_matrix(self):\n        # docstring inherited\n        if self._invalid:\n            outl, outb, outw, outh = self._boxout.bounds\n            if DEBUG and (outw == 0 or outh == 0):\n                raise ValueError(\"Transforming to a singular bounding box.\")\n            self._mtx = np.array([[outw,  0.0, outl],\n                                  [ 0.0, outh, outb],\n                                  [ 0.0,  0.0,  1.0]],\n                                  float)\n            self._inverted = None\n            self._invalid = 0\n        return self._mtx",
        "begin_line": 2564,
        "end_line": 2576,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012062726176115801,
            "pseudo_dstar_susp": 0.0025188916876574307,
            "pseudo_tarantula_susp": 0.00034153005464480874,
            "pseudo_op2_susp": 0.0025188916876574307,
            "pseudo_barinel_susp": 0.00034494653328734045
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxTransformFrom.__init__#2606",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxTransformFrom",
        "signature": "lib.matplotlib.transforms.BboxTransformFrom.__init__(self, boxin, **kwargs)",
        "snippet": "    def __init__(self, boxin, **kwargs):\n        if not boxin.is_bbox:\n            raise ValueError(\"'boxin' must be bbox\")\n\n        Affine2DBase.__init__(self, **kwargs)\n        self._boxin = boxin\n        self.set_children(boxin)\n        self._mtx = None\n        self._inverted = None",
        "begin_line": 2606,
        "end_line": 2614,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00038109756097560977,
            "pseudo_dstar_susp": 0.00048123195380173246,
            "pseudo_tarantula_susp": 0.00028121484814398203,
            "pseudo_op2_susp": 0.00048123195380173246,
            "pseudo_barinel_susp": 0.00028121484814398203
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxTransformFrom.get_matrix#2622",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxTransformFrom",
        "signature": "lib.matplotlib.transforms.BboxTransformFrom.get_matrix(self)",
        "snippet": "    def get_matrix(self):\n        # docstring inherited\n        if self._invalid:\n            inl, inb, inw, inh = self._boxin.bounds\n            if DEBUG and (inw == 0 or inh == 0):\n                raise ValueError(\"Transforming from a singular bounding box.\")\n            x_scale = 1.0 / inw\n            y_scale = 1.0 / inh\n            self._mtx = np.array([[x_scale, 0.0    , (-inl*x_scale)],\n                                  [0.0    , y_scale, (-inb*y_scale)],\n                                  [0.0    , 0.0    , 1.0        ]],\n                                 float)\n            self._inverted = None\n            self._invalid = 0\n        return self._mtx",
        "begin_line": 2622,
        "end_line": 2636,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005178663904712584,
            "pseudo_dstar_susp": 0.0004572473708276177,
            "pseudo_tarantula_susp": 0.00031377470975839345,
            "pseudo_op2_susp": 0.0004572473708276177,
            "pseudo_barinel_susp": 0.00031377470975839345
        }
    },
    {
        "name": "lib.matplotlib.transforms.ScaledTranslation.__init__#2644",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.ScaledTranslation",
        "signature": "lib.matplotlib.transforms.ScaledTranslation.__init__(self, xt, yt, scale_trans, **kwargs)",
        "snippet": "    def __init__(self, xt, yt, scale_trans, **kwargs):\n        Affine2DBase.__init__(self, **kwargs)\n        self._t = (xt, yt)\n        self._scale_trans = scale_trans\n        self.set_children(scale_trans)\n        self._mtx = None\n        self._inverted = None",
        "begin_line": 2644,
        "end_line": 2650,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043878894251864854,
            "pseudo_dstar_susp": 0.0006242197253433209,
            "pseudo_tarantula_susp": 0.0002922267679719462,
            "pseudo_op2_susp": 0.0006242197253433209,
            "pseudo_barinel_susp": 0.0002922267679719462
        }
    },
    {
        "name": "lib.matplotlib.transforms.ScaledTranslation.get_matrix#2658",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.ScaledTranslation",
        "signature": "lib.matplotlib.transforms.ScaledTranslation.get_matrix(self)",
        "snippet": "    def get_matrix(self):\n        # docstring inherited\n        if self._invalid:\n            # A bit faster than np.identity(3).\n            self._mtx = IdentityTransform._mtx.copy()\n            self._mtx[:2, 2] = self._scale_trans.transform(self._t)\n            self._invalid = 0\n            self._inverted = None\n        return self._mtx",
        "begin_line": 2658,
        "end_line": 2666,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005675368898978433,
            "pseudo_dstar_susp": 0.0004870920603994155,
            "pseudo_tarantula_susp": 0.00033178500331785003,
            "pseudo_op2_susp": 0.0004870920603994155,
            "pseudo_barinel_susp": 0.00033178500331785003
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformedPath.__init__#2681",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformedPath",
        "signature": "lib.matplotlib.transforms.TransformedPath.__init__(self, path, transform)",
        "snippet": "    def __init__(self, path, transform):\n        \"\"\"\n        Parameters\n        ----------\n        path : `~.path.Path`\n        transform : `Transform`\n        \"\"\"\n        cbook._check_isinstance(Transform, transform=transform)\n        TransformNode.__init__(self)\n        self._path = path\n        self._transform = transform\n        self.set_children(transform)\n        self._transformed_path = None\n        self._transformed_points = None",
        "begin_line": 2681,
        "end_line": 2694,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005414185165132648,
            "pseudo_dstar_susp": 0.00042069835927639884,
            "pseudo_tarantula_susp": 0.00032393909944930353,
            "pseudo_op2_susp": 0.00042069835927639884,
            "pseudo_barinel_susp": 0.00032393909944930353
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformedPath._revalidate#2696",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformedPath",
        "signature": "lib.matplotlib.transforms.TransformedPath._revalidate(self)",
        "snippet": "    def _revalidate(self):\n        # only recompute if the invalidation includes the non_affine part of\n        # the transform\n        if (self._invalid & self.INVALID_NON_AFFINE == self.INVALID_NON_AFFINE\n            or self._transformed_path is None):\n            self._transformed_path = \\\n                self._transform.transform_path_non_affine(self._path)\n            self._transformed_points = \\\n                Path._fast_from_codes_and_verts(\n                    self._transform.transform_non_affine(self._path.vertices),\n                    None, self._path)\n        self._invalid = 0",
        "begin_line": 2696,
        "end_line": 2707,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005324813631522897,
            "pseudo_dstar_susp": 0.00041684035014589413,
            "pseudo_tarantula_susp": 0.00031969309462915604,
            "pseudo_op2_susp": 0.00041684035014589413,
            "pseudo_barinel_susp": 0.00031969309462915604
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformedPath.get_transformed_points_and_affine#2709",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformedPath",
        "signature": "lib.matplotlib.transforms.TransformedPath.get_transformed_points_and_affine(self)",
        "snippet": "    def get_transformed_points_and_affine(self):\n        \"\"\"\n        Return a copy of the child path, with the non-affine part of\n        the transform already applied, along with the affine part of\n        the path necessary to complete the transformation.  Unlike\n        :meth:`get_transformed_path_and_affine`, no interpolation will\n        be performed.\n        \"\"\"\n        self._revalidate()\n        return self._transformed_points, self.get_affine()",
        "begin_line": 2709,
        "end_line": 2718,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005151983513652757,
            "pseudo_dstar_susp": 0.00039761431411530816,
            "pseudo_tarantula_susp": 0.00033178500331785003,
            "pseudo_op2_susp": 0.00039761431411530816,
            "pseudo_barinel_susp": 0.00033178500331785003
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformedPath.get_transformed_path_and_affine#2720",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformedPath",
        "signature": "lib.matplotlib.transforms.TransformedPath.get_transformed_path_and_affine(self)",
        "snippet": "    def get_transformed_path_and_affine(self):\n        \"\"\"\n        Return a copy of the child path, with the non-affine part of\n        the transform already applied, along with the affine part of\n        the path necessary to complete the transformation.\n        \"\"\"\n        self._revalidate()\n        return self._transformed_path, self.get_affine()",
        "begin_line": 2720,
        "end_line": 2727,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003289473684210526,
            "pseudo_dstar_susp": 0.00033444816053511704,
            "pseudo_tarantula_susp": 0.00029859659599880563,
            "pseudo_op2_susp": 0.00033444816053511704,
            "pseudo_barinel_susp": 0.00029850746268656717
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformedPath.get_fully_transformed_path#2729",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformedPath",
        "signature": "lib.matplotlib.transforms.TransformedPath.get_fully_transformed_path(self)",
        "snippet": "    def get_fully_transformed_path(self):\n        \"\"\"\n        Return a fully-transformed copy of the child path.\n        \"\"\"\n        self._revalidate()\n        return self._transform.transform_path_affine(self._transformed_path)",
        "begin_line": 2729,
        "end_line": 2734,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformedPath.get_affine#2736",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformedPath",
        "signature": "lib.matplotlib.transforms.TransformedPath.get_affine(self)",
        "snippet": "    def get_affine(self):\n        return self._transform.get_affine()",
        "begin_line": 2736,
        "end_line": 2737,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005238344683080147,
            "pseudo_dstar_susp": 0.00039952057530962844,
            "pseudo_tarantula_susp": 0.00032393909944930353,
            "pseudo_op2_susp": 0.00039952057530962844,
            "pseudo_barinel_susp": 0.00032393909944930353
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformedPatchPath.__init__#2746",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformedPatchPath",
        "signature": "lib.matplotlib.transforms.TransformedPatchPath.__init__(self, patch)",
        "snippet": "    def __init__(self, patch):\n        \"\"\"\n        Parameters\n        ----------\n        patch : `~.patches.Patch`\n        \"\"\"\n        TransformNode.__init__(self)\n\n        transform = patch.get_transform()\n        self._patch = patch\n        self._transform = transform\n        self.set_children(transform)\n        self._path = patch.get_path()\n        self._transformed_path = None\n        self._transformed_points = None",
        "begin_line": 2746,
        "end_line": 2760,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002175805047867711,
            "pseudo_dstar_susp": 0.00021626297577854672,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00021626297577854672,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformedPatchPath._revalidate#2762",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformedPatchPath",
        "signature": "lib.matplotlib.transforms.TransformedPatchPath._revalidate(self)",
        "snippet": "    def _revalidate(self):\n        patch_path = self._patch.get_path()\n        # Only recompute if the invalidation includes the non_affine part of\n        # the transform, or the Patch's Path has changed.\n        if (self._transformed_path is None or self._path != patch_path or\n                (self._invalid & self.INVALID_NON_AFFINE ==\n                    self.INVALID_NON_AFFINE)):\n            self._path = patch_path\n            self._transformed_path = \\\n                self._transform.transform_path_non_affine(patch_path)\n            self._transformed_points = \\\n                Path._fast_from_codes_and_verts(\n                    self._transform.transform_non_affine(patch_path.vertices),\n                    None, patch_path)\n        self._invalid = 0",
        "begin_line": 2762,
        "end_line": 2776,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000227842333105491,
            "pseudo_dstar_susp": 0.00021743857360295715,
            "pseudo_tarantula_susp": 0.00027210884353741496,
            "pseudo_op2_susp": 0.00021743857360295715,
            "pseudo_barinel_susp": 0.0002720348204570185
        }
    },
    {
        "name": "lib.matplotlib.transforms.nonsingular#2779",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms",
        "signature": "lib.matplotlib.transforms.nonsingular(vmin, vmax, expander=0.001, tiny=1e-15, increasing=True)",
        "snippet": "def nonsingular(vmin, vmax, expander=0.001, tiny=1e-15, increasing=True):\n    \"\"\"\n    Modify the endpoints of a range as needed to avoid singularities.\n\n    Parameters\n    ----------\n    vmin, vmax : float\n        The initial endpoints.\n    expander : float, optional, default: 0.001\n        Fractional amount by which *vmin* and *vmax* are expanded if\n        the original interval is too small, based on *tiny*.\n    tiny : float, optional, default: 1e-15\n        Threshold for the ratio of the interval to the maximum absolute\n        value of its endpoints.  If the interval is smaller than\n        this, it will be expanded.  This value should be around\n        1e-15 or larger; otherwise the interval will be approaching\n        the double precision resolution limit.\n    increasing : bool, optional, default: True\n        If True, swap *vmin*, *vmax* if *vmin* > *vmax*.\n\n    Returns\n    -------\n    vmin, vmax : float\n        Endpoints, expanded and/or swapped if necessary.\n        If either input is inf or NaN, or if both inputs are 0 or very\n        close to zero, it returns -*expander*, *expander*.\n    \"\"\"\n\n    if (not np.isfinite(vmin)) or (not np.isfinite(vmax)):\n        return -expander, expander\n\n    swapped = False\n    if vmax < vmin:\n        vmin, vmax = vmax, vmin\n        swapped = True\n\n    maxabsvalue = max(abs(vmin), abs(vmax))\n    if maxabsvalue < (1e6 / tiny) * np.finfo(float).tiny:\n        vmin = -expander\n        vmax = expander\n\n    elif vmax - vmin <= maxabsvalue * tiny:\n        if vmax == 0 and vmin == 0:\n            vmin = -expander\n            vmax = expander\n        else:\n            vmin -= expander*abs(vmin)\n            vmax += expander*abs(vmax)\n\n    if swapped and not increasing:\n        vmin, vmax = vmax, vmin\n    return vmin, vmax",
        "begin_line": 2779,
        "end_line": 2830,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003856536829926726,
            "pseudo_dstar_susp": 0.0005793742757821553,
            "pseudo_tarantula_susp": 0.0002860411899313501,
            "pseudo_op2_susp": 0.0005793742757821553,
            "pseudo_barinel_susp": 0.0002860411899313501
        }
    },
    {
        "name": "lib.matplotlib.transforms.interval_contains#2833",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms",
        "signature": "lib.matplotlib.transforms.interval_contains(interval, val)",
        "snippet": "def interval_contains(interval, val):\n    \"\"\"\n    Check, inclusively, whether an interval includes a given value.\n\n    Parameters\n    ----------\n    interval : sequence of scalar\n        A 2-length sequence, endpoints that define the interval.\n    val : scalar\n        Value to check is within interval.\n\n    Returns\n    -------\n    bool\n        Returns *True* if given *val* is within the *interval*.\n    \"\"\"\n    a, b = interval\n    if a > b:\n        a, b = b, a\n    return a <= val <= b",
        "begin_line": 2833,
        "end_line": 2852,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.transforms._interval_contains_close#2855",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms",
        "signature": "lib.matplotlib.transforms._interval_contains_close(interval, val, rtol=1e-10)",
        "snippet": "def _interval_contains_close(interval, val, rtol=1e-10):\n    \"\"\"\n    Check, inclusively, whether an interval includes a given value, with the\n    interval expanded by a small tolerance to admit floating point errors.\n\n    Parameters\n    ----------\n    interval : sequence of scalar\n        A 2-length sequence, endpoints that define the interval.\n    val : scalar\n        Value to check is within interval.\n    rtol : scalar\n        Tolerance slippage allowed outside of this interval.  Default\n        1e-10 * (b - a).\n\n    Returns\n    -------\n    bool\n        Returns *True* if given *val* is within the *interval* (with tolerance)\n    \"\"\"\n    a, b = interval\n    if a > b:\n        a, b = b, a\n    rtol = (b - a) * rtol\n    return a - rtol <= val <= b + rtol",
        "begin_line": 2855,
        "end_line": 2879,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005307855626326964,
            "pseudo_dstar_susp": 0.00040032025620496394,
            "pseudo_tarantula_susp": 0.0004280821917808219,
            "pseudo_op2_susp": 0.00040032025620496394,
            "pseudo_barinel_susp": 0.0004280821917808219
        }
    },
    {
        "name": "lib.matplotlib.transforms.offset_copy#2902",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms",
        "signature": "lib.matplotlib.transforms.offset_copy(trans, fig=None, x=0.0, y=0.0, units='inches')",
        "snippet": "def offset_copy(trans, fig=None, x=0.0, y=0.0, units='inches'):\n    \"\"\"\n    Return a new transform with an added offset.\n\n    Parameters\n    ----------\n    trans : :class:`Transform` instance\n        Any transform, to which offset will be applied.\n    fig : :class:`~matplotlib.figure.Figure`, optional, default: None\n        Current figure. It can be None if *units* are 'dots'.\n    x, y : float, optional, default: 0.0\n        Specifies the offset to apply.\n    units : {'inches', 'points', 'dots'}, optional\n        Units of the offset.\n\n    Returns\n    -------\n    trans : :class:`Transform` instance\n        Transform with applied offset.\n    \"\"\"\n    if units == 'dots':\n        return trans + Affine2D().translate(x, y)\n    if fig is None:\n        raise ValueError('For units of inches or points a fig kwarg is needed')\n    if units == 'points':\n        x /= 72.0\n        y /= 72.0\n    elif units == 'inches':\n        pass\n    else:\n        cbook._check_in_list(['dots', 'points', 'inches'], units=units)\n    return trans + ScaledTranslation(x, y, fig.dpi_scale_trans)",
        "begin_line": 2902,
        "end_line": 2933,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.quiver.QuiverKey.__init__#201",
        "src_path": "lib/matplotlib/quiver.py",
        "class_name": "lib.matplotlib.quiver.QuiverKey",
        "signature": "lib.matplotlib.quiver.QuiverKey.__init__(self, Q, X, Y, U, label, *, angle=0, coordinates='axes', color=None, labelsep=0.1, labelpos='N', labelcolor=None, fontproperties=None, **kw)",
        "snippet": "    def __init__(self, Q, X, Y, U, label,\n                 *, angle=0, coordinates='axes', color=None, labelsep=0.1,\n                 labelpos='N', labelcolor=None, fontproperties=None,\n                 **kw):\n        \"\"\"\n        Add a key to a quiver plot.\n\n        The positioning of the key depends on *X*, *Y*, *coordinates*, and\n        *labelpos*.  If *labelpos* is 'N' or 'S', *X*, *Y* give the position of\n        the middle of the key arrow.  If *labelpos* is 'E', *X*, *Y* positions\n        the head, and if *labelpos* is 'W', *X*, *Y* positions the tail; in\n        either of these two cases, *X*, *Y* is somewhere in the middle of the\n        arrow+label key object.\n\n        Parameters\n        ----------\n        Q : `matplotlib.quiver.Quiver`\n            A `.Quiver` object as returned by a call to `~.Axes.quiver()`.\n        X, Y : float\n            The location of the key.\n        U : float\n            The length of the key.\n        label : str\n            The key label (e.g., length and units of the key).\n        angle : float, default: 0\n            The angle of the key arrow, in degrees anti-clockwise from the\n            x-axis.\n        coordinates : {'axes', 'figure', 'data', 'inches'}, default: 'axes'\n            Coordinate system and units for *X*, *Y*: 'axes' and 'figure' are\n            normalized coordinate systems with (0, 0) in the lower left and\n            (1, 1) in the upper right; 'data' are the axes data coordinates\n            (used for the locations of the vectors in the quiver plot itself);\n            'inches' is position in the figure in inches, with (0, 0) at the\n            lower left corner.\n        color : color\n            Overrides face and edge colors from *Q*.\n        labelpos : {'N', 'S', 'E', 'W'}\n            Position the label above, below, to the right, to the left of the\n            arrow, respectively.\n        labelsep : float, default: 0.1\n            Distance in inches between the arrow and the label.\n        labelcolor : color, default: :rc:`text.color`\n            Label color.\n        fontproperties : dict, optional\n            A dictionary with keyword arguments accepted by the\n            `~matplotlib.font_manager.FontProperties` initializer:\n            *family*, *style*, *variant*, *size*, *weight*.\n        **kwargs\n            Any additional keyword arguments are used to override vector\n            properties taken from *Q*.\n        \"\"\"\n        martist.Artist.__init__(self)\n        self.Q = Q\n        self.X = X\n        self.Y = Y\n        self.U = U\n        self.angle = angle\n        self.coord = coordinates\n        self.color = color\n        self.label = label\n        self._labelsep_inches = labelsep\n        self.labelsep = (self._labelsep_inches * Q.ax.figure.dpi)\n\n        # try to prevent closure over the real self\n        weak_self = weakref.ref(self)\n\n        def on_dpi_change(fig):\n            self_weakref = weak_self()\n            if self_weakref is not None:\n                self_weakref.labelsep = self_weakref._labelsep_inches * fig.dpi\n                # simple brute force update works because _init is called at\n                # the start of draw.\n                self_weakref._initialized = False\n\n        self._cid = Q.ax.figure.callbacks.connect('dpi_changed',\n                                                  on_dpi_change)\n\n        self.labelpos = labelpos\n        self.labelcolor = labelcolor\n        self.fontproperties = fontproperties or dict()\n        self.kw = kw\n        _fp = self.fontproperties\n        # boxprops = dict(facecolor='red')\n        self.text = mtext.Text(\n                        text=label,  # bbox=boxprops,\n                        horizontalalignment=self.halign[self.labelpos],\n                        verticalalignment=self.valign[self.labelpos],\n                        fontproperties=font_manager.FontProperties(**_fp))\n\n        if self.labelcolor is not None:\n            self.text.set_color(self.labelcolor)\n        self._initialized = False\n        self.zorder = Q.zorder + 0.1",
        "begin_line": 201,
        "end_line": 293,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018542555164101615,
            "pseudo_dstar_susp": 0.00017998560115190784,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00017998560115190784,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.quiver.QuiverKey.on_dpi_change#267",
        "src_path": "lib/matplotlib/quiver.py",
        "class_name": "lib.matplotlib.quiver.QuiverKey",
        "signature": "lib.matplotlib.quiver.QuiverKey.on_dpi_change(fig)",
        "snippet": "        def on_dpi_change(fig):\n            self_weakref = weak_self()\n            if self_weakref is not None:\n                self_weakref.labelsep = self_weakref._labelsep_inches * fig.dpi\n                # simple brute force update works because _init is called at\n                # the start of draw.\n                self_weakref._initialized = False",
        "begin_line": 267,
        "end_line": 273,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018053800324968405,
            "pseudo_dstar_susp": 0.0001529987760097919,
            "pseudo_tarantula_susp": 0.0003450655624568668,
            "pseudo_op2_susp": 0.0001529987760097919,
            "pseudo_barinel_susp": 0.00034494653328734045
        }
    },
    {
        "name": "lib.matplotlib.quiver.QuiverKey._init#304",
        "src_path": "lib/matplotlib/quiver.py",
        "class_name": "lib.matplotlib.quiver.QuiverKey",
        "signature": "lib.matplotlib.quiver.QuiverKey._init(self)",
        "snippet": "    def _init(self):\n        if True:  # not self._initialized:\n            if not self.Q._initialized:\n                self.Q._init()\n            self._set_transform()\n            _pivot = self.Q.pivot\n            self.Q.pivot = self.pivot[self.labelpos]\n            # Hack: save and restore the Umask\n            _mask = self.Q.Umask\n            self.Q.Umask = ma.nomask\n            u = self.U * np.cos(np.radians(self.angle))\n            v = self.U * np.sin(np.radians(self.angle))\n            angle = self.Q.angles if isinstance(self.Q.angles, str) else 'uv'\n            self.verts = self.Q._make_verts(\n                np.array([u]), np.array([v]), angle)\n            self.Q.Umask = _mask\n            self.Q.pivot = _pivot\n            kw = self.Q.polykw\n            kw.update(self.kw)\n            self.vector = mcollections.PolyCollection(\n                                        self.verts,\n                                        offsets=[(self.X, self.Y)],\n                                        transOffset=self.get_transform(),\n                                        **kw)\n            if self.color is not None:\n                self.vector.set_color(self.color)\n            self.vector.set_transform(self.Q.get_transform())\n            self.vector.set_figure(self.get_figure())\n            self._initialized = True",
        "begin_line": 304,
        "end_line": 332,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016652789342214822,
            "pseudo_dstar_susp": 0.0001525320317266626,
            "pseudo_tarantula_susp": 0.00027210884353741496,
            "pseudo_op2_susp": 0.0001525320317266626,
            "pseudo_barinel_susp": 0.0002720348204570185
        }
    },
    {
        "name": "lib.matplotlib.quiver._parse_args#393",
        "src_path": "lib/matplotlib/quiver.py",
        "class_name": "lib.matplotlib.quiver",
        "signature": "lib.matplotlib.quiver._parse_args(*args, caller_name='function')",
        "snippet": "def _parse_args(*args, caller_name='function'):\n    \"\"\"\n    Helper function to parse positional parameters for colored vector plots.\n\n    This is currently used for Quiver and Barbs.\n\n    Parameters\n    ----------\n    *args : list\n        list of 2-5 arguments. Depending on their number they are parsed to::\n\n            U, V\n            U, V, C\n            X, Y, U, V\n            X, Y, U, V, C\n\n    caller_name : str\n        Name of the calling method (used in error messages).\n    \"\"\"\n    X = Y = C = None\n\n    len_args = len(args)\n    if len_args == 2:\n        # The use of atleast_1d allows for handling scalar arguments while also\n        # keeping masked arrays\n        U, V = np.atleast_1d(*args)\n    elif len_args == 3:\n        U, V, C = np.atleast_1d(*args)\n    elif len_args == 4:\n        X, Y, U, V = np.atleast_1d(*args)\n    elif len_args == 5:\n        X, Y, U, V, C = np.atleast_1d(*args)\n    else:\n        raise TypeError(f'{caller_name} takes 2-5 positional arguments but '\n                        f'{len_args} were given')\n\n    nr, nc = (1, U.shape[0]) if U.ndim == 1 else U.shape\n\n    if X is not None:\n        X = X.ravel()\n        Y = Y.ravel()\n        if len(X) == nc and len(Y) == nr:\n            X, Y = [a.ravel() for a in np.meshgrid(X, Y)]\n        elif len(X) != len(Y):\n            raise ValueError('X and Y must be the same size, but '\n                             f'X.size is {X.size} and Y.size is {Y.size}.')\n    else:\n        indexgrid = np.meshgrid(np.arange(nc), np.arange(nr))\n        X, Y = [np.ravel(a) for a in indexgrid]\n    # Size validation for U, V, C is left to the set_UVC method.\n    return X, Y, U, V, C",
        "begin_line": 393,
        "end_line": 443,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011559357299734135,
            "pseudo_dstar_susp": 0.00011440338634023568,
            "pseudo_tarantula_susp": 0.00011862396204033214,
            "pseudo_op2_susp": 0.00011440338634023568,
            "pseudo_barinel_susp": 0.00011862396204033214
        }
    },
    {
        "name": "lib.matplotlib.quiver.Quiver.set_UVC#595",
        "src_path": "lib/matplotlib/quiver.py",
        "class_name": "lib.matplotlib.quiver.Quiver",
        "signature": "lib.matplotlib.quiver.Quiver.set_UVC(self, U, V, C=None)",
        "snippet": "    def set_UVC(self, U, V, C=None):\n        # We need to ensure we have a copy, not a reference\n        # to an array that might change before draw().\n        U = ma.masked_invalid(U, copy=True).ravel()\n        V = ma.masked_invalid(V, copy=True).ravel()\n        if C is not None:\n            C = ma.masked_invalid(C, copy=True).ravel()\n        for name, var in zip(('U', 'V', 'C'), (U, V, C)):\n            if var is not None and var.size != self.N:\n                raise ValueError(f'Argument {name} has a size {var.size}'\n                                 f' which does not match {self.N},'\n                                 ' the number of arrow positions')\n\n        mask = ma.mask_or(U.mask, V.mask, copy=False, shrink=True)\n        if C is not None:\n            mask = ma.mask_or(mask, C.mask, copy=False, shrink=True)\n            if mask is ma.nomask:\n                C = C.filled()\n            else:\n                C = ma.array(C, mask=mask, copy=False)\n        self.U = U.filled(1)\n        self.V = V.filled(1)\n        self.Umask = mask\n        if C is not None:\n            self.set_array(C)\n        self._new_UV = True\n        self.stale = True",
        "begin_line": 595,
        "end_line": 621,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001364815067558346,
            "pseudo_dstar_susp": 0.00015030813166992335,
            "pseudo_tarantula_susp": 0.00015276504735716468,
            "pseudo_op2_susp": 0.00015030813166992335,
            "pseudo_barinel_susp": 0.00015446400988569664
        }
    },
    {
        "name": "lib.matplotlib.quiver.Quiver._dots_per_unit#623",
        "src_path": "lib/matplotlib/quiver.py",
        "class_name": "lib.matplotlib.quiver.Quiver",
        "signature": "lib.matplotlib.quiver.Quiver._dots_per_unit(self, units)",
        "snippet": "    def _dots_per_unit(self, units):\n        \"\"\"\n        Return a scale factor for converting from units to pixels\n        \"\"\"\n        ax = self.ax\n        if units in ('x', 'y', 'xy'):\n            if units == 'x':\n                dx0 = ax.viewLim.width\n                dx1 = ax.bbox.width\n            elif units == 'y':\n                dx0 = ax.viewLim.height\n                dx1 = ax.bbox.height\n            else:  # 'xy' is assumed\n                dxx0 = ax.viewLim.width\n                dxx1 = ax.bbox.width\n                dyy0 = ax.viewLim.height\n                dyy1 = ax.bbox.height\n                dx1 = np.hypot(dxx1, dyy1)\n                dx0 = np.hypot(dxx0, dyy0)\n            dx = dx1 / dx0\n        else:\n            if units == 'width':\n                dx = ax.bbox.width\n            elif units == 'height':\n                dx = ax.bbox.height\n            elif units == 'dots':\n                dx = 1.0\n            elif units == 'inches':\n                dx = ax.figure.dpi\n            else:\n                raise ValueError('unrecognized units')\n        return dx",
        "begin_line": 623,
        "end_line": 654,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00015130882130428205,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00015130882130428205,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.quiver.Quiver._h_arrows#734",
        "src_path": "lib/matplotlib/quiver.py",
        "class_name": "lib.matplotlib.quiver.Quiver",
        "signature": "lib.matplotlib.quiver.Quiver._h_arrows(self, length)",
        "snippet": "    def _h_arrows(self, length):\n        \"\"\"Length is in arrow width units.\"\"\"\n        # It might be possible to streamline the code\n        # and speed it up a bit by using complex (x, y)\n        # instead of separate arrays; but any gain would be slight.\n        minsh = self.minshaft * self.headlength\n        N = len(length)\n        length = length.reshape(N, 1)\n        # This number is chosen based on when pixel values overflow in Agg\n        # causing rendering errors\n        # length = np.minimum(length, 2 ** 16)\n        np.clip(length, 0, 2 ** 16, out=length)\n        # x, y: normal horizontal arrow\n        x = np.array([0, -self.headaxislength,\n                      -self.headlength, 0],\n                     np.float64)\n        x = x + np.array([0, 1, 1, 1]) * length\n        y = 0.5 * np.array([1, 1, self.headwidth, 0], np.float64)\n        y = np.repeat(y[np.newaxis, :], N, axis=0)\n        # x0, y0: arrow without shaft, for short vectors\n        x0 = np.array([0, minsh - self.headaxislength,\n                       minsh - self.headlength, minsh], np.float64)\n        y0 = 0.5 * np.array([1, 1, self.headwidth, 0], np.float64)\n        ii = [0, 1, 2, 3, 2, 1, 0, 0]\n        X = x[:, ii]\n        Y = y[:, ii]\n        Y[:, 3:-1] *= -1\n        X0 = x0[ii]\n        Y0 = y0[ii]\n        Y0[3:-1] *= -1\n        shrink = length / minsh if minsh != 0. else 0.\n        X0 = shrink * X0[np.newaxis, :]\n        Y0 = shrink * Y0[np.newaxis, :]\n        short = np.repeat(length < minsh, 8, axis=1)\n        # Now select X0, Y0 if short, otherwise X, Y\n        np.copyto(X, X0, where=short)\n        np.copyto(Y, Y0, where=short)\n        if self.pivot == 'middle':\n            X -= 0.5 * X[:, 3, np.newaxis]\n        elif self.pivot == 'tip':\n            # numpy bug? using -= does not work here unless we multiply by a\n            # float first, as with 'mid'.\n            X = X - X[:, 3, np.newaxis]\n        elif self.pivot != 'tail':\n            cbook._check_in_list([\"middle\", \"tip\", \"tail\"], pivot=self.pivot)\n\n        tooshort = length < self.minlength\n        if tooshort.any():\n            # Use a heptagonal dot:\n            th = np.arange(0, 8, 1, np.float64) * (np.pi / 3.0)\n            x1 = np.cos(th) * self.minlength * 0.5\n            y1 = np.sin(th) * self.minlength * 0.5\n            X1 = np.repeat(x1[np.newaxis, :], N, axis=0)\n            Y1 = np.repeat(y1[np.newaxis, :], N, axis=0)\n            tooshort = np.repeat(tooshort, 8, 1)\n            np.copyto(X, X1, where=tooshort)\n            np.copyto(Y, Y1, where=tooshort)\n        # Mask handling is deferred to the caller, _make_verts.\n        return X, Y",
        "begin_line": 734,
        "end_line": 792,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00015130882130428205,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00015130882130428205,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.quiver.Barbs.__init__#956",
        "src_path": "lib/matplotlib/quiver.py",
        "class_name": "lib.matplotlib.quiver.Barbs",
        "signature": "lib.matplotlib.quiver.Barbs.__init__(self, ax, *args, pivot='tip', length=7, barbcolor=None, flagcolor=None, sizes=None, fill_empty=False, barb_increments=None, rounding=True, flip_barb=False, **kw)",
        "snippet": "    def __init__(self, ax, *args,\n                 pivot='tip', length=7, barbcolor=None, flagcolor=None,\n                 sizes=None, fill_empty=False, barb_increments=None,\n                 rounding=True, flip_barb=False, **kw):\n        \"\"\"\n        The constructor takes one required argument, an Axes\n        instance, followed by the args and kwargs described\n        by the following pyplot interface documentation:\n        %(barbs_doc)s\n        \"\"\"\n        self.sizes = sizes or dict()\n        self.fill_empty = fill_empty\n        self.barb_increments = barb_increments or dict()\n        self.rounding = rounding\n        self.flip = np.atleast_1d(flip_barb)\n        transform = kw.pop('transform', ax.transData)\n        self._pivot = pivot\n        self._length = length\n        barbcolor = barbcolor\n        flagcolor = flagcolor\n\n        # Flagcolor and barbcolor provide convenience parameters for\n        # setting the facecolor and edgecolor, respectively, of the barb\n        # polygon.  We also work here to make the flag the same color as the\n        # rest of the barb by default\n\n        if None in (barbcolor, flagcolor):\n            kw['edgecolors'] = 'face'\n            if flagcolor:\n                kw['facecolors'] = flagcolor\n            elif barbcolor:\n                kw['facecolors'] = barbcolor\n            else:\n                # Set to facecolor passed in or default to black\n                kw.setdefault('facecolors', 'k')\n        else:\n            kw['edgecolors'] = barbcolor\n            kw['facecolors'] = flagcolor\n\n        # Explicitly set a line width if we're not given one, otherwise\n        # polygons are not outlined and we get no barbs\n        if 'linewidth' not in kw and 'lw' not in kw:\n            kw['linewidth'] = 1\n\n        # Parse out the data arrays from the various configurations supported\n        x, y, u, v, c = _parse_args(*args, caller_name='barbs()')\n        self.x = x\n        self.y = y\n        xy = np.column_stack((x, y))\n\n        # Make a collection\n        barb_size = self._length ** 2 / 4  # Empirically determined\n        mcollections.PolyCollection.__init__(self, [], (barb_size,),\n                                             offsets=xy,\n                                             transOffset=transform, **kw)\n        self.set_transform(transforms.IdentityTransform())\n\n        self.set_UVC(u, v, c)",
        "begin_line": 956,
        "end_line": 1013,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.667764583513912e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.quiver.Barbs._find_tails#1015",
        "src_path": "lib/matplotlib/quiver.py",
        "class_name": "lib.matplotlib.quiver.Barbs",
        "signature": "lib.matplotlib.quiver.Barbs._find_tails(self, mag, rounding=True, half=5, full=10, flag=50)",
        "snippet": "    def _find_tails(self, mag, rounding=True, half=5, full=10, flag=50):\n        '''\n        Find how many of each of the tail pieces is necessary.  Flag\n        specifies the increment for a flag, barb for a full barb, and half for\n        half a barb. Mag should be the magnitude of a vector (i.e., >= 0).\n\n        This returns a tuple of:\n\n            (*number of flags*, *number of barbs*, *half_flag*, *empty_flag*)\n\n        *half_flag* is a boolean whether half of a barb is needed,\n        since there should only ever be one half on a given\n        barb. *empty_flag* flag is an array of flags to easily tell if\n        a barb is empty (too low to plot any barbs/flags.\n        '''\n\n        # If rounding, round to the nearest multiple of half, the smallest\n        # increment\n        if rounding:\n            mag = half * (mag / half + 0.5).astype(int)\n\n        num_flags = np.floor(mag / flag).astype(int)\n        mag = mag % flag\n\n        num_barb = np.floor(mag / full).astype(int)\n        mag = mag % full\n\n        half_flag = mag >= half\n        empty_flag = ~(half_flag | (num_flags > 0) | (num_barb > 0))\n\n        return num_flags, num_barb, half_flag, empty_flag",
        "begin_line": 1015,
        "end_line": 1045,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.quiver.Barbs._make_barbs#1047",
        "src_path": "lib/matplotlib/quiver.py",
        "class_name": "lib.matplotlib.quiver.Barbs",
        "signature": "lib.matplotlib.quiver.Barbs._make_barbs(self, u, v, nflags, nbarbs, half_barb, empty_flag, length, pivot, sizes, fill_empty, flip)",
        "snippet": "    def _make_barbs(self, u, v, nflags, nbarbs, half_barb, empty_flag, length,\n                    pivot, sizes, fill_empty, flip):\n        '''\n        This function actually creates the wind barbs.  *u* and *v*\n        are components of the vector in the *x* and *y* directions,\n        respectively.\n\n        *nflags*, *nbarbs*, and *half_barb*, empty_flag* are,\n        *respectively, the number of flags, number of barbs, flag for\n        *half a barb, and flag for empty barb, ostensibly obtained\n        *from :meth:`_find_tails`.\n\n        *length* is the length of the barb staff in points.\n\n        *pivot* specifies the point on the barb around which the\n        entire barb should be rotated.  Right now, valid options are\n        'tip' and 'middle'. Can also be a number, which shifts the start\n        of the barb that many points from the origin.\n\n        *sizes* is a dictionary of coefficients specifying the ratio\n        of a given feature to the length of the barb. These features\n        include:\n\n            - *spacing*: space between features (flags, full/half\n               barbs)\n\n            - *height*: distance from shaft of top of a flag or full\n               barb\n\n            - *width* - width of a flag, twice the width of a full barb\n\n            - *emptybarb* - radius of the circle used for low\n               magnitudes\n\n        *fill_empty* specifies whether the circle representing an\n        empty barb should be filled or not (this changes the drawing\n        of the polygon).\n\n        *flip* is a flag indicating whether the features should be flipped to\n        the other side of the barb (useful for winds in the southern\n        hemisphere).\n\n        This function returns list of arrays of vertices, defining a polygon\n        for each of the wind barbs.  These polygons have been rotated to\n        properly align with the vector direction.\n        '''\n\n        # These control the spacing and size of barb elements relative to the\n        # length of the shaft\n        spacing = length * sizes.get('spacing', 0.125)\n        full_height = length * sizes.get('height', 0.4)\n        full_width = length * sizes.get('width', 0.25)\n        empty_rad = length * sizes.get('emptybarb', 0.15)\n\n        # Controls y point where to pivot the barb.\n        pivot_points = dict(tip=0.0, middle=-length / 2.)\n\n        endx = 0.0\n        try:\n            endy = float(pivot)\n        except ValueError:\n            endy = pivot_points[pivot.lower()]\n\n        # Get the appropriate angle for the vector components.  The offset is\n        # due to the way the barb is initially drawn, going down the y-axis.\n        # This makes sense in a meteorological mode of thinking since there 0\n        # degrees corresponds to north (the y-axis traditionally)\n        angles = -(ma.arctan2(v, u) + np.pi / 2)\n\n        # Used for low magnitude.  We just get the vertices, so if we make it\n        # out here, it can be reused.  The center set here should put the\n        # center of the circle at the location(offset), rather than at the\n        # same point as the barb pivot; this seems more sensible.\n        circ = CirclePolygon((0, 0), radius=empty_rad).get_verts()\n        if fill_empty:\n            empty_barb = circ\n        else:\n            # If we don't want the empty one filled, we make a degenerate\n            # polygon that wraps back over itself\n            empty_barb = np.concatenate((circ, circ[::-1]))\n\n        barb_list = []\n        for index, angle in np.ndenumerate(angles):\n            # If the vector magnitude is too weak to draw anything, plot an\n            # empty circle instead\n            if empty_flag[index]:\n                # We can skip the transform since the circle has no preferred\n                # orientation\n                barb_list.append(empty_barb)\n                continue\n\n            poly_verts = [(endx, endy)]\n            offset = length\n\n            # Handle if this barb should be flipped\n            barb_height = -full_height if flip[index] else full_height\n\n            # Add vertices for each flag\n            for i in range(nflags[index]):\n                # The spacing that works for the barbs is a little to much for\n                # the flags, but this only occurs when we have more than 1\n                # flag.\n                if offset != length:\n                    offset += spacing / 2.\n                poly_verts.extend(\n                    [[endx, endy + offset],\n                     [endx + barb_height, endy - full_width / 2 + offset],\n                     [endx, endy - full_width + offset]])\n\n                offset -= full_width + spacing\n\n            # Add vertices for each barb.  These really are lines, but works\n            # great adding 3 vertices that basically pull the polygon out and\n            # back down the line\n            for i in range(nbarbs[index]):\n                poly_verts.extend(\n                    [(endx, endy + offset),\n                     (endx + barb_height, endy + offset + full_width / 2),\n                     (endx, endy + offset)])\n\n                offset -= spacing\n\n            # Add the vertices for half a barb, if needed\n            if half_barb[index]:\n                # If the half barb is the first on the staff, traditionally it\n                # is offset from the end to make it easy to distinguish from a\n                # barb with a full one\n                if offset == length:\n                    poly_verts.append((endx, endy + offset))\n                    offset -= 1.5 * spacing\n                poly_verts.extend(\n                    [(endx, endy + offset),\n                     (endx + barb_height / 2, endy + offset + full_width / 4),\n                     (endx, endy + offset)])\n\n            # Rotate the barb according the angle. Making the barb first and\n            # then rotating it made the math for drawing the barb really easy.\n            # Also, the transform framework makes doing the rotation simple.\n            poly_verts = transforms.Affine2D().rotate(-angle).transform(\n                poly_verts)\n            barb_list.append(poly_verts)\n\n        return barb_list",
        "begin_line": 1047,
        "end_line": 1189,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.quiver.Barbs.set_UVC#1191",
        "src_path": "lib/matplotlib/quiver.py",
        "class_name": "lib.matplotlib.quiver.Barbs",
        "signature": "lib.matplotlib.quiver.Barbs.set_UVC(self, U, V, C=None)",
        "snippet": "    def set_UVC(self, U, V, C=None):\n        self.u = ma.masked_invalid(U, copy=False).ravel()\n        self.v = ma.masked_invalid(V, copy=False).ravel()\n\n        # Flip needs to have the same number of entries as everything else.\n        # Use broadcast_to to avoid a bloated array of identical values.\n        # (can't rely on actual broadcasting)\n        if len(self.flip) == 1:\n            flip = np.broadcast_to(self.flip, self.u.shape)\n        else:\n            flip = self.flip\n\n        if C is not None:\n            c = ma.masked_invalid(C, copy=False).ravel()\n            x, y, u, v, c, flip = cbook.delete_masked_points(\n                self.x.ravel(), self.y.ravel(), self.u, self.v, c,\n                flip.ravel())\n            _check_consistent_shapes(x, y, u, v, c, flip)\n        else:\n            x, y, u, v, flip = cbook.delete_masked_points(\n                self.x.ravel(), self.y.ravel(), self.u, self.v, flip.ravel())\n            _check_consistent_shapes(x, y, u, v, flip)\n\n        magnitude = np.hypot(u, v)\n        flags, barbs, halves, empty = self._find_tails(magnitude,\n                                                       self.rounding,\n                                                       **self.barb_increments)\n\n        # Get the vertices for each of the barbs\n\n        plot_barbs = self._make_barbs(u, v, flags, barbs, halves, empty,\n                                      self._length, self._pivot, self.sizes,\n                                      self.fill_empty, flip)\n        self.set_verts(plot_barbs)\n\n        # Set the color array\n        if C is not None:\n            self.set_array(c)\n\n        # Update the offsets in case the masked data changed\n        xy = np.column_stack((x, y))\n        self._offsets = xy\n        self.stale = True",
        "begin_line": 1191,
        "end_line": 1233,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._secondary_axes._make_secondary_locator#10",
        "src_path": "lib/matplotlib/axes/_secondary_axes.py",
        "class_name": "lib.matplotlib.axes._secondary_axes",
        "signature": "lib.matplotlib.axes._secondary_axes._make_secondary_locator(rect, parent)",
        "snippet": "def _make_secondary_locator(rect, parent):\n    \"\"\"\n    Helper function to locate the secondary axes.\n\n    A locator gets used in `Axes.set_aspect` to override the default\n    locations...  It is a function that takes an axes object and\n    a renderer and tells `set_aspect` where it is to be placed.\n\n    This locator make the transform be in axes-relative co-coordinates\n    because that is how we specify the \"location\" of the secondary axes.\n\n    Here *rect* is a rectangle [l, b, w, h] that specifies the\n    location for the axes in the transform given by *trans* on the\n    *parent*.\n    \"\"\"\n    _rect = mtransforms.Bbox.from_bounds(*rect)\n    def secondary_locator(ax, renderer):\n        # delay evaluating transform until draw time because the\n        # parent transform may have changed (i.e. if window reesized)\n        bb = mtransforms.TransformedBbox(_rect, parent.transAxes)\n        tr = parent.figure.transFigure.inverted()\n        bb = mtransforms.TransformedBbox(bb, tr)\n        return bb\n\n    return secondary_locator",
        "begin_line": 10,
        "end_line": 34,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012023566189731875,
            "pseudo_dstar_susp": 0.00011741223435481978,
            "pseudo_tarantula_susp": 0.00013345789403443215,
            "pseudo_op2_susp": 0.00011741223435481978,
            "pseudo_barinel_susp": 0.00013338668800853674
        }
    },
    {
        "name": "lib.matplotlib.bezier.get_intersection#17",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier.get_intersection(cx1, cy1, cos_t1, sin_t1, cx2, cy2, cos_t2, sin_t2)",
        "snippet": "def get_intersection(cx1, cy1, cos_t1, sin_t1,\n                     cx2, cy2, cos_t2, sin_t2):\n    \"\"\"\n    Return the intersection between the line through (*cx1*, *cy1*) at angle\n    *t1* and the line through (*cx2*, *cy2*) at angle *t2*.\n    \"\"\"\n\n    # line1 => sin_t1 * (x - cx1) - cos_t1 * (y - cy1) = 0.\n    # line1 => sin_t1 * x + cos_t1 * y = sin_t1*cx1 - cos_t1*cy1\n\n    line1_rhs = sin_t1 * cx1 - cos_t1 * cy1\n    line2_rhs = sin_t2 * cx2 - cos_t2 * cy2\n\n    # rhs matrix\n    a, b = sin_t1, -cos_t1\n    c, d = sin_t2, -cos_t2\n\n    ad_bc = a * d - b * c\n    if np.abs(ad_bc) < 1.0e-12:\n        raise ValueError(\"Given lines do not intersect. Please verify that \"\n                         \"the angles are not equal or differ by 180 degrees.\")\n\n    # rhs_inverse\n    a_, b_ = d, -b\n    c_, d_ = -c, a\n    a_, b_, c_, d_ = [k / ad_bc for k in [a_, b_, c_, d_]]\n\n    x = a_ * line1_rhs + b_ * line2_rhs\n    y = c_ * line1_rhs + d_ * line2_rhs\n\n    return x, y",
        "begin_line": 17,
        "end_line": 47,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018846588767433095,
            "pseudo_dstar_susp": 0.0001541782300339192,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0001541782300339192,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.bezier._de_casteljau1#75",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier._de_casteljau1(beta, t)",
        "snippet": "def _de_casteljau1(beta, t):\n    next_beta = beta[:-1] * (1 - t) + beta[1:] * t\n    return next_beta",
        "begin_line": 75,
        "end_line": 77,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001863238308179616,
            "pseudo_dstar_susp": 0.00019113149847094801,
            "pseudo_tarantula_susp": 0.0002061855670103093,
            "pseudo_op2_susp": 0.00019113149847094801,
            "pseudo_barinel_susp": 0.0002061855670103093
        }
    },
    {
        "name": "lib.matplotlib.bezier.split_de_casteljau#80",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier.split_de_casteljau(beta, t)",
        "snippet": "def split_de_casteljau(beta, t):\n    \"\"\"\n    Split a Bezier segment defined by its control points *beta* into two\n    separate segments divided at *t* and return their control points.\n    \"\"\"\n    beta = np.asarray(beta)\n    beta_list = [beta]\n    while True:\n        beta = _de_casteljau1(beta, t)\n        beta_list.append(beta)\n        if len(beta) == 1:\n            break\n    left_beta = [beta[0] for beta in beta_list]\n    right_beta = [beta[-1] for beta in reversed(beta_list)]\n\n    return left_beta, right_beta",
        "begin_line": 80,
        "end_line": 95,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00027932960893854746,
            "pseudo_dstar_susp": 0.00023798191337458352,
            "pseudo_tarantula_susp": 0.00040584415584415587,
            "pseudo_op2_susp": 0.00023798191337458352,
            "pseudo_barinel_susp": 0.00040584415584415587
        }
    },
    {
        "name": "lib.matplotlib.bezier.split_bezier_intersecting_with_closedpath#203",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier.split_bezier_intersecting_with_closedpath(bezier, inside_closedpath, tolerance=0.01)",
        "snippet": "def split_bezier_intersecting_with_closedpath(\n        bezier, inside_closedpath, tolerance=0.01):\n    \"\"\"\n    Split a Bezier curve into two at the intersection with a closed path.\n\n    Parameters\n    ----------\n    bezier : array-like(N, 2)\n        Control points of the Bezier segment. See `.BezierSegment`.\n    inside_closedpath : callable\n        A function returning True if a given point (x, y) is inside the\n        closed path. See also `.find_bezier_t_intersecting_with_closedpath`.\n    tolerance : float\n        The tolerance for the intersection. See also\n        `.find_bezier_t_intersecting_with_closedpath`.\n\n    Returns\n    -------\n    left, right\n        Lists of control points for the two Bezier segments.\n    \"\"\"\n\n    bz = BezierSegment(bezier)\n    bezier_point_at_t = bz.point_at_t\n\n    t0, t1 = find_bezier_t_intersecting_with_closedpath(\n        bezier_point_at_t, inside_closedpath, tolerance=tolerance)\n\n    _left, _right = split_de_casteljau(bezier, (t0 + t1) / 2.)\n    return _left, _right",
        "begin_line": 203,
        "end_line": 232,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022331397945511388,
            "pseudo_dstar_susp": 0.00023142791020597085,
            "pseudo_tarantula_susp": 0.00021934634788330776,
            "pseudo_op2_susp": 0.00023142791020597085,
            "pseudo_barinel_susp": 0.00021934634788330776
        }
    },
    {
        "name": "lib.matplotlib.bezier.split_path_inout#267",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier.split_path_inout(path, inside, tolerance=0.01, reorder_inout=False)",
        "snippet": "def split_path_inout(path, inside, tolerance=0.01, reorder_inout=False):\n    \"\"\"\n    Divide a path into two segments at the point where ``inside(x, y)`` becomes\n    False.\n    \"\"\"\n    path_iter = path.iter_segments()\n\n    ctl_points, command = next(path_iter)\n    begin_inside = inside(ctl_points[-2:])  # true if begin point is inside\n\n    ctl_points_old = ctl_points\n\n    concat = np.concatenate\n\n    iold = 0\n    i = 1\n\n    for ctl_points, command in path_iter:\n        iold = i\n        i += len(ctl_points) // 2\n        if inside(ctl_points[-2:]) != begin_inside:\n            bezier_path = concat([ctl_points_old[-2:], ctl_points])\n            break\n        ctl_points_old = ctl_points\n    else:\n        raise ValueError(\"The path does not intersect with the patch\")\n\n    bp = bezier_path.reshape((-1, 2))\n    left, right = split_bezier_intersecting_with_closedpath(\n        bp, inside, tolerance)\n    if len(left) == 2:\n        codes_left = [Path.LINETO]\n        codes_right = [Path.MOVETO, Path.LINETO]\n    elif len(left) == 3:\n        codes_left = [Path.CURVE3, Path.CURVE3]\n        codes_right = [Path.MOVETO, Path.CURVE3, Path.CURVE3]\n    elif len(left) == 4:\n        codes_left = [Path.CURVE4, Path.CURVE4, Path.CURVE4]\n        codes_right = [Path.MOVETO, Path.CURVE4, Path.CURVE4, Path.CURVE4]\n    else:\n        raise AssertionError(\"This should never be reached\")\n\n    verts_left = left[1:]\n    verts_right = right[:]\n\n    if path.codes is None:\n        path_in = Path(concat([path.vertices[:i], verts_left]))\n        path_out = Path(concat([verts_right, path.vertices[i:]]))\n\n    else:\n        path_in = Path(concat([path.vertices[:iold], verts_left]),\n                       concat([path.codes[:iold], codes_left]))\n\n        path_out = Path(concat([verts_right, path.vertices[i:]]),\n                        concat([codes_right, path.codes[i:]]))\n\n    if reorder_inout and not begin_inside:\n        path_in, path_out = path_out, path_in\n\n    return path_in, path_out",
        "begin_line": 267,
        "end_line": 326,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011859582542694497,
            "pseudo_dstar_susp": 0.00011637379262190155,
            "pseudo_tarantula_susp": 0.000129315918789603,
            "pseudo_op2_susp": 0.00011637379262190155,
            "pseudo_barinel_susp": 0.000129315918789603
        }
    },
    {
        "name": "lib.matplotlib.bezier.get_cos_sin#348",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier.get_cos_sin(x0, y0, x1, y1)",
        "snippet": "def get_cos_sin(x0, y0, x1, y1):\n    dx, dy = x1 - x0, y1 - y0\n    d = (dx * dx + dy * dy) ** .5\n    # Account for divide by zero\n    if d == 0:\n        return 0.0, 0.0\n    return dx / d, dy / d",
        "begin_line": 348,
        "end_line": 354,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.bezier.get_parallels#388",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier.get_parallels(bezier2, width)",
        "snippet": "def get_parallels(bezier2, width):\n    \"\"\"\n    Given the quadratic Bezier control points *bezier2*, returns\n    control points of quadratic Bezier lines roughly parallel to given\n    one separated by *width*.\n    \"\"\"\n\n    # The parallel Bezier lines are constructed by following ways.\n    #  c1 and c2 are control points representing the begin and end of the\n    #  Bezier line.\n    #  cm is the middle point\n\n    c1x, c1y = bezier2[0]\n    cmx, cmy = bezier2[1]\n    c2x, c2y = bezier2[2]\n\n    parallel_test = check_if_parallel(c1x - cmx, c1y - cmy,\n                                      cmx - c2x, cmy - c2y)\n\n    if parallel_test == -1:\n        cbook._warn_external(\n            \"Lines do not intersect. A straight line is used instead.\")\n        cos_t1, sin_t1 = get_cos_sin(c1x, c1y, c2x, c2y)\n        cos_t2, sin_t2 = cos_t1, sin_t1\n    else:\n        # t1 and t2 is the angle between c1 and cm, cm, c2.  They are\n        # also a angle of the tangential line of the path at c1 and c2\n        cos_t1, sin_t1 = get_cos_sin(c1x, c1y, cmx, cmy)\n        cos_t2, sin_t2 = get_cos_sin(cmx, cmy, c2x, c2y)\n\n    # find c1_left, c1_right which are located along the lines\n    # through c1 and perpendicular to the tangential lines of the\n    # Bezier path at a distance of width. Same thing for c2_left and\n    # c2_right with respect to c2.\n    c1x_left, c1y_left, c1x_right, c1y_right = (\n        get_normal_points(c1x, c1y, cos_t1, sin_t1, width)\n    )\n    c2x_left, c2y_left, c2x_right, c2y_right = (\n        get_normal_points(c2x, c2y, cos_t2, sin_t2, width)\n    )\n\n    # find cm_left which is the intersecting point of a line through\n    # c1_left with angle t1 and a line through c2_left with angle\n    # t2. Same with cm_right.\n    if parallel_test != 0:\n        # a special case for a straight line, i.e., angle between two\n        # lines are smaller than some (arbitrary) value.\n        cmx_left, cmy_left = (\n            0.5 * (c1x_left + c2x_left), 0.5 * (c1y_left + c2y_left)\n        )\n        cmx_right, cmy_right = (\n            0.5 * (c1x_right + c2x_right), 0.5 * (c1y_right + c2y_right)\n        )\n    else:\n        cmx_left, cmy_left = get_intersection(c1x_left, c1y_left, cos_t1,\n                                              sin_t1, c2x_left, c2y_left,\n                                              cos_t2, sin_t2)\n\n        cmx_right, cmy_right = get_intersection(c1x_right, c1y_right, cos_t1,\n                                                sin_t1, c2x_right, c2y_right,\n                                                cos_t2, sin_t2)\n\n    # the parallel Bezier lines are created with control points of\n    # [c1_left, cm_left, c2_left] and [c1_right, cm_right, c2_right]\n    path_left = [(c1x_left, c1y_left),\n                 (cmx_left, cmy_left),\n                 (c2x_left, c2y_left)]\n    path_right = [(c1x_right, c1y_right),\n                  (cmx_right, cmy_right),\n                  (c2x_right, c2y_right)]\n\n    return path_left, path_right",
        "begin_line": 388,
        "end_line": 459,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.228420966016621e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.bezier.make_wedged_bezier2#472",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier.make_wedged_bezier2(bezier2, width, w1=1.0, wm=0.5, w2=0.0)",
        "snippet": "def make_wedged_bezier2(bezier2, width, w1=1., wm=0.5, w2=0.):\n    \"\"\"\n    Being similar to get_parallels, returns control points of two quadratic\n    Bezier lines having a width roughly parallel to given one separated by\n    *width*.\n    \"\"\"\n\n    # c1, cm, c2\n    c1x, c1y = bezier2[0]\n    cmx, cmy = bezier2[1]\n    c3x, c3y = bezier2[2]\n\n    # t1 and t2 is the angle between c1 and cm, cm, c3.\n    # They are also a angle of the tangential line of the path at c1 and c3\n    cos_t1, sin_t1 = get_cos_sin(c1x, c1y, cmx, cmy)\n    cos_t2, sin_t2 = get_cos_sin(cmx, cmy, c3x, c3y)\n\n    # find c1_left, c1_right which are located along the lines\n    # through c1 and perpendicular to the tangential lines of the\n    # Bezier path at a distance of width. Same thing for c3_left and\n    # c3_right with respect to c3.\n    c1x_left, c1y_left, c1x_right, c1y_right = (\n        get_normal_points(c1x, c1y, cos_t1, sin_t1, width * w1)\n    )\n    c3x_left, c3y_left, c3x_right, c3y_right = (\n        get_normal_points(c3x, c3y, cos_t2, sin_t2, width * w2)\n    )\n\n    # find c12, c23 and c123 which are middle points of c1-cm, cm-c3 and\n    # c12-c23\n    c12x, c12y = (c1x + cmx) * .5, (c1y + cmy) * .5\n    c23x, c23y = (cmx + c3x) * .5, (cmy + c3y) * .5\n    c123x, c123y = (c12x + c23x) * .5, (c12y + c23y) * .5\n\n    # tangential angle of c123 (angle between c12 and c23)\n    cos_t123, sin_t123 = get_cos_sin(c12x, c12y, c23x, c23y)\n\n    c123x_left, c123y_left, c123x_right, c123y_right = (\n        get_normal_points(c123x, c123y, cos_t123, sin_t123, width * wm)\n    )\n\n    path_left = find_control_points(c1x_left, c1y_left,\n                                    c123x_left, c123y_left,\n                                    c3x_left, c3y_left)\n    path_right = find_control_points(c1x_right, c1y_right,\n                                     c123x_right, c123y_right,\n                                     c3x_right, c3y_right)\n\n    return path_left, path_right",
        "begin_line": 472,
        "end_line": 520,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.146639511201629e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.figure._stale_figure_callback#45",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure",
        "signature": "lib.matplotlib.figure._stale_figure_callback(self, val)",
        "snippet": "def _stale_figure_callback(self, val):\n    if self.figure:\n        self.figure.stale = val",
        "begin_line": 45,
        "end_line": 47,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.07142857142857142,
            "pseudo_dstar_susp": 0.034482758620689655,
            "pseudo_tarantula_susp": 0.00044822949350067237,
            "pseudo_op2_susp": 0.034482758620689655,
            "pseudo_barinel_susp": 0.00044822949350067237
        }
    },
    {
        "name": "lib.matplotlib.figure._AxesStack.__init__#66",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure._AxesStack",
        "signature": "lib.matplotlib.figure._AxesStack.__init__(self)",
        "snippet": "    def __init__(self):\n        super().__init__()\n        self._ind = 0",
        "begin_line": 66,
        "end_line": 68,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012345679012345678,
            "pseudo_dstar_susp": 0.008,
            "pseudo_tarantula_susp": 0.00043687199650502403,
            "pseudo_op2_susp": 0.008,
            "pseudo_barinel_susp": 0.00043687199650502403
        }
    },
    {
        "name": "lib.matplotlib.figure._AxesStack.as_list#70",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure._AxesStack",
        "signature": "lib.matplotlib.figure._AxesStack.as_list(self)",
        "snippet": "    def as_list(self):\n        \"\"\"\n        Return a list of the Axes instances that have been added to the figure.\n        \"\"\"\n        ia_list = [a for k, a in self._elements]\n        ia_list.sort()\n        return [a for i, a in ia_list]",
        "begin_line": 70,
        "end_line": 76,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000249500998003992,
            "pseudo_dstar_susp": 0.00034626038781163435,
            "pseudo_tarantula_susp": 0.000121921482565228,
            "pseudo_op2_susp": 0.00034626038781163435,
            "pseudo_barinel_susp": 0.000121921482565228
        }
    },
    {
        "name": "lib.matplotlib.figure._AxesStack.get#78",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure._AxesStack",
        "signature": "lib.matplotlib.figure._AxesStack.get(self, key)",
        "snippet": "    def get(self, key):\n        \"\"\"\n        Return the Axes instance that was added with *key*.\n        If it is not present, return *None*.\n        \"\"\"\n        item = dict(self._elements).get(key)\n        if item is None:\n            return None\n        cbook.warn_deprecated(\n            \"2.1\",\n            message=\"Adding an axes using the same arguments as a previous \"\n            \"axes currently reuses the earlier instance.  In a future \"\n            \"version, a new instance will always be created and returned.  \"\n            \"Meanwhile, this warning can be suppressed, and the future \"\n            \"behavior ensured, by passing a unique label to each axes \"\n            \"instance.\")\n        return item[1]",
        "begin_line": 78,
        "end_line": 94,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00048192771084337347,
            "pseudo_dstar_susp": 0.0006613756613756613,
            "pseudo_tarantula_susp": 0.0001404494382022472,
            "pseudo_op2_susp": 0.0006613756613756613,
            "pseudo_barinel_susp": 0.0001404494382022472
        }
    },
    {
        "name": "lib.matplotlib.figure.SubplotParams.update#199",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.SubplotParams",
        "signature": "lib.matplotlib.figure.SubplotParams.update(self, left=None, bottom=None, right=None, top=None, wspace=None, hspace=None)",
        "snippet": "    def update(self, left=None, bottom=None, right=None, top=None,\n               wspace=None, hspace=None):\n        \"\"\"\n        Update the dimensions of the passed parameters. *None* means unchanged.\n        \"\"\"\n        thisleft = getattr(self, 'left', None)\n        thisright = getattr(self, 'right', None)\n        thistop = getattr(self, 'top', None)\n        thisbottom = getattr(self, 'bottom', None)\n        thiswspace = getattr(self, 'wspace', None)\n        thishspace = getattr(self, 'hspace', None)\n\n        self._update_this('left', left)\n        self._update_this('right', right)\n        self._update_this('bottom', bottom)\n        self._update_this('top', top)\n        self._update_this('wspace', wspace)\n        self._update_this('hspace', hspace)\n\n        def reset():\n            self.left = thisleft\n            self.right = thisright\n            self.top = thistop\n            self.bottom = thisbottom\n            self.wspace = thiswspace\n            self.hspace = thishspace\n\n        if self.validate:\n            if self.left >= self.right:\n                reset()\n                raise ValueError('left cannot be >= right')\n\n            if self.bottom >= self.top:\n                reset()\n                raise ValueError('bottom cannot be >= top')",
        "begin_line": 199,
        "end_line": 233,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007042253521126761,
            "pseudo_dstar_susp": 0.007042253521126761,
            "pseudo_tarantula_susp": 0.00042826552462526765,
            "pseudo_op2_susp": 0.007042253521126761,
            "pseudo_barinel_susp": 0.00042826552462526765
        }
    },
    {
        "name": "lib.matplotlib.figure.SubplotParams.reset#218",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.SubplotParams",
        "signature": "lib.matplotlib.figure.SubplotParams.reset()",
        "snippet": "        def reset():\n            self.left = thisleft\n            self.right = thisright\n            self.top = thistop\n            self.bottom = thisbottom\n            self.wspace = thiswspace\n            self.hspace = thishspace",
        "begin_line": 218,
        "end_line": 224,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.736943907156673e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.figure.SubplotParams._update_this#235",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.SubplotParams",
        "signature": "lib.matplotlib.figure.SubplotParams._update_this(self, s, val)",
        "snippet": "    def _update_this(self, s, val):\n        if val is None:\n            val = getattr(self, s, None)\n            if val is None:\n                key = 'figure.subplot.' + s\n                val = rcParams[key]\n\n        setattr(self, s, val)",
        "begin_line": 235,
        "end_line": 242,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00625,
            "pseudo_dstar_susp": 0.007142857142857143,
            "pseudo_tarantula_susp": 0.0003920031360250882,
            "pseudo_op2_susp": 0.007142857142857143,
            "pseudo_barinel_susp": 0.0003920031360250882
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.__init__#275",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.__init__(self, figsize=None, dpi=None, facecolor=None, edgecolor=None, linewidth=0.0, frameon=None, subplotpars=None, tight_layout=None, constrained_layout=None)",
        "snippet": "    def __init__(self,\n                 figsize=None,\n                 dpi=None,\n                 facecolor=None,\n                 edgecolor=None,\n                 linewidth=0.0,\n                 frameon=None,\n                 subplotpars=None,  # default to rc\n                 tight_layout=None,  # default to rc figure.autolayout\n                 constrained_layout=None,  # default to rc\n                                          #figure.constrained_layout.use\n                 ):\n        \"\"\"\n        Parameters\n        ----------\n        figsize : 2-tuple of floats, default: :rc:`figure.figsize`\n            Figure dimension ``(width, height)`` in inches.\n\n        dpi : float, default: :rc:`figure.dpi`\n            Dots per inch.\n\n        facecolor : default: :rc:`figure.facecolor`\n            The figure patch facecolor.\n\n        edgecolor : default: :rc:`figure.edgecolor`\n            The figure patch edge color.\n\n        linewidth : float\n            The linewidth of the frame (i.e. the edge linewidth of the figure\n            patch).\n\n        frameon : bool, default: :rc:`figure.frameon`\n            If ``False``, suppress drawing the figure background patch.\n\n        subplotpars : :class:`SubplotParams`\n            Subplot parameters. If not given, the default subplot\n            parameters :rc:`figure.subplot.*` are used.\n\n        tight_layout : bool or dict, default: :rc:`figure.autolayout`\n            If ``False`` use *subplotpars*. If ``True`` adjust subplot\n            parameters using `.tight_layout` with default padding.\n            When providing a dict containing the keys ``pad``, ``w_pad``,\n            ``h_pad``, and ``rect``, the default `.tight_layout` paddings\n            will be overridden.\n\n        constrained_layout : bool\n            If ``True`` use constrained layout to adjust positioning of plot\n            elements.  Like ``tight_layout``, but designed to be more\n            flexible.  See\n            :doc:`/tutorials/intermediate/constrainedlayout_guide`\n            for examples.  (Note: does not work with :meth:`.subplot` or\n            :meth:`.subplot2grid`.)\n            Defaults to :rc:`figure.constrained_layout.use`.\n        \"\"\"\n        super().__init__()\n        # remove the non-figure artist _axes property\n        # as it makes no sense for a figure to be _in_ an axes\n        # this is used by the property methods in the artist base class\n        # which are over-ridden in this class\n        del self._axes\n        self.callbacks = cbook.CallbackRegistry()\n\n        if figsize is None:\n            figsize = rcParams['figure.figsize']\n        if dpi is None:\n            dpi = rcParams['figure.dpi']\n        if facecolor is None:\n            facecolor = rcParams['figure.facecolor']\n        if edgecolor is None:\n            edgecolor = rcParams['figure.edgecolor']\n        if frameon is None:\n            frameon = rcParams['figure.frameon']\n\n        if not np.isfinite(figsize).all() or (np.array(figsize) <= 0).any():\n            raise ValueError('figure size must be positive finite not '\n                             f'{figsize}')\n        self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)\n\n        self.dpi_scale_trans = Affine2D().scale(dpi)\n        # do not use property as it will trigger\n        self._dpi = dpi\n        self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)\n\n        self.transFigure = BboxTransformTo(self.bbox)\n\n        self.patch = Rectangle(\n            xy=(0, 0), width=1, height=1, visible=frameon,\n            facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,\n            # Don't let the figure patch influence bbox calculation.\n            in_layout=False)\n        self._set_artist_props(self.patch)\n        self.patch.set_antialiased(False)\n\n        FigureCanvasBase(self)  # Set self.canvas.\n        self._suptitle = None\n\n        if subplotpars is None:\n            subplotpars = SubplotParams()\n\n        self.subplotpars = subplotpars\n        # constrained_layout:\n        self._layoutbox = None\n        # set in set_constrained_layout_pads()\n        self.set_constrained_layout(constrained_layout)\n\n        self.set_tight_layout(tight_layout)\n\n        self._axstack = _AxesStack()  # track all figure axes and current axes\n        self.clf()\n        self._cachedRenderer = None\n\n        # groupers to keep track of x and y labels we want to align.\n        # see self.align_xlabels and self.align_ylabels and\n        # axis._get_tick_boxes_siblings\n        self._align_xlabel_grp = cbook.Grouper()\n        self._align_ylabel_grp = cbook.Grouper()\n\n        # list of child gridspecs for this figure\n        self._gridspecs = []",
        "begin_line": 275,
        "end_line": 393,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015174506828528073,
            "pseudo_dstar_susp": 0.00199203187250996,
            "pseudo_tarantula_susp": 0.0004657661853749418,
            "pseudo_op2_susp": 0.00199203187250996,
            "pseudo_barinel_susp": 0.0004657661853749418
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure._get_axes#453",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure._get_axes(self)",
        "snippet": "    def _get_axes(self):\n        return self._axstack.as_list()",
        "begin_line": 453,
        "end_line": 454,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018463810930576072,
            "pseudo_dstar_susp": 0.00016136840406648378,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.00016136840406648378,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure._get_dpi#463",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure._get_dpi(self)",
        "snippet": "    def _get_dpi(self):\n        return self._dpi",
        "begin_line": 463,
        "end_line": 464,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001589825119236884,
            "pseudo_dstar_susp": 0.0012315270935960591,
            "pseudo_tarantula_susp": 0.00047080979284369113,
            "pseudo_op2_susp": 0.0012315270935960591,
            "pseudo_barinel_susp": 0.00047080979284369113
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure._set_dpi#466",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure._set_dpi(self, dpi, forward=True)",
        "snippet": "    def _set_dpi(self, dpi, forward=True):\n        \"\"\"\n        Parameters\n        ----------\n        dpi : float\n\n        forward : bool\n            Passed on to `~.Figure.set_size_inches`\n        \"\"\"\n        self._dpi = dpi\n        self.dpi_scale_trans.clear().scale(dpi)\n        w, h = self.get_size_inches()\n        self.set_size_inches(w, h, forward=forward)\n        self.callbacks.process('dpi_changed', self)",
        "begin_line": 466,
        "end_line": 479,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002347417840375587,
            "pseudo_dstar_susp": 0.0013812154696132596,
            "pseudo_tarantula_susp": 0.0005347593582887701,
            "pseudo_op2_susp": 0.0013812154696132596,
            "pseudo_barinel_susp": 0.0005347593582887701
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.get_tight_layout#483",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.get_tight_layout(self)",
        "snippet": "    def get_tight_layout(self):\n        \"\"\"Return whether `.tight_layout` is called when drawing.\"\"\"\n        return self._tight",
        "begin_line": 483,
        "end_line": 485,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016666666666666668,
            "pseudo_dstar_susp": 0.001272264631043257,
            "pseudo_tarantula_susp": 0.0004775549188156638,
            "pseudo_op2_susp": 0.001272264631043257,
            "pseudo_barinel_susp": 0.0004775549188156638
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.set_tight_layout#487",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.set_tight_layout(self, tight)",
        "snippet": "    def set_tight_layout(self, tight):\n        \"\"\"\n        Set whether and how `.tight_layout` is called when drawing.\n\n        Parameters\n        ----------\n        tight : bool or dict with keys \"pad\", \"w_pad\", \"h_pad\", \"rect\" or None\n            If a bool, sets whether to call `.tight_layout` upon drawing.\n            If ``None``, use the ``figure.autolayout`` rcparam instead.\n            If a dict, pass it as kwargs to `.tight_layout`, overriding the\n            default paddings.\n        \"\"\"\n        if tight is None:\n            tight = rcParams['figure.autolayout']\n        self._tight = bool(tight)\n        self._tight_parameters = tight if isinstance(tight, dict) else {}\n        self.stale = True",
        "begin_line": 487,
        "end_line": 503,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014388489208633094,
            "pseudo_dstar_susp": 0.0011574074074074073,
            "pseudo_tarantula_susp": 0.00045682960255824577,
            "pseudo_op2_susp": 0.0011574074074074073,
            "pseudo_barinel_susp": 0.00045682960255824577
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.set_constrained_layout#513",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.set_constrained_layout(self, constrained)",
        "snippet": "    def set_constrained_layout(self, constrained):\n        \"\"\"\n        Set whether ``constrained_layout`` is used upon drawing. If None,\n        the rcParams['figure.constrained_layout.use'] value will be used.\n\n        When providing a dict containing the keys `w_pad`, `h_pad`\n        the default ``constrained_layout`` paddings will be\n        overridden.  These pads are in inches and default to 3.0/72.0.\n        ``w_pad`` is the width padding and ``h_pad`` is the height padding.\n\n        See :doc:`/tutorials/intermediate/constrainedlayout_guide`.\n\n        Parameters\n        ----------\n        constrained : bool or dict or None\n        \"\"\"\n        self._constrained_layout_pads = dict()\n        self._constrained_layout_pads['w_pad'] = None\n        self._constrained_layout_pads['h_pad'] = None\n        self._constrained_layout_pads['wspace'] = None\n        self._constrained_layout_pads['hspace'] = None\n        if constrained is None:\n            constrained = rcParams['figure.constrained_layout.use']\n        self._constrained = bool(constrained)\n        if isinstance(constrained, dict):\n            self.set_constrained_layout_pads(**constrained)\n        else:\n            self.set_constrained_layout_pads()\n\n        self.stale = True",
        "begin_line": 513,
        "end_line": 542,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014388489208633094,
            "pseudo_dstar_susp": 0.001869158878504673,
            "pseudo_tarantula_susp": 0.00045682960255824577,
            "pseudo_op2_susp": 0.00186219739292365,
            "pseudo_barinel_susp": 0.00045682960255824577
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.set_constrained_layout_pads#544",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.set_constrained_layout_pads(self, **kwargs)",
        "snippet": "    def set_constrained_layout_pads(self, **kwargs):\n        \"\"\"\n        Set padding for ``constrained_layout``.  Note the kwargs can be passed\n        as a dictionary ``fig.set_constrained_layout(**paddict)``.\n\n        See :doc:`/tutorials/intermediate/constrainedlayout_guide`.\n\n        Parameters\n        ----------\n        w_pad : scalar\n            Width padding in inches.  This is the pad around axes\n            and is meant to make sure there is enough room for fonts to\n            look good.  Defaults to 3 pts = 0.04167 inches\n\n        h_pad : scalar\n            Height padding in inches. Defaults to 3 pts.\n\n        wspace : scalar\n            Width padding between subplots, expressed as a fraction of the\n            subplot width.  The total padding ends up being w_pad + wspace.\n\n        hspace : scalar\n            Height padding between subplots, expressed as a fraction of the\n            subplot width. The total padding ends up being h_pad + hspace.\n\n        \"\"\"\n\n        todo = ['w_pad', 'h_pad', 'wspace', 'hspace']\n        for td in todo:\n            if td in kwargs and kwargs[td] is not None:\n                self._constrained_layout_pads[td] = kwargs[td]\n            else:\n                self._constrained_layout_pads[td] = (\n                    rcParams['figure.constrained_layout.' + td])",
        "begin_line": 544,
        "end_line": 577,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001288161793121216,
            "pseudo_dstar_susp": 0.00015576323987538941,
            "pseudo_tarantula_susp": 0.00012080212611741966,
            "pseudo_op2_susp": 0.00015576323987538941,
            "pseudo_barinel_susp": 0.00012080212611741966
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.get_children#651",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.get_children(self)",
        "snippet": "    def get_children(self):\n        \"\"\"Get a list of artists contained in the figure.\"\"\"\n        return [self.patch,\n                *self.artists,\n                *self.axes,\n                *self.lines,\n                *self.patches,\n                *self.texts,\n                *self.images,\n                *self.legends]",
        "begin_line": 651,
        "end_line": 660,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016666666666666668,
            "pseudo_dstar_susp": 0.001272264631043257,
            "pseudo_tarantula_susp": 0.0004775549188156638,
            "pseudo_op2_susp": 0.001272264631043257,
            "pseudo_barinel_susp": 0.0004775549188156638
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.suptitle#682",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.suptitle(self, t, **kwargs)",
        "snippet": "    def suptitle(self, t, **kwargs):\n        \"\"\"\n        Add a centered title to the figure.\n\n        Parameters\n        ----------\n        t : str\n            The title text.\n\n        x : float, default 0.5\n            The x location of the text in figure coordinates.\n\n        y : float, default 0.98\n            The y location of the text in figure coordinates.\n\n        horizontalalignment, ha : {'center', 'left', right'}, default: 'center'\n            The horizontal alignment of the text relative to (*x*, *y*).\n\n        verticalalignment, va : {'top', 'center', 'bottom', 'baseline'}, \\\ndefault: 'top'\n            The vertical alignment of the text relative to (*x*, *y*).\n\n        fontsize, size : default: :rc:`figure.titlesize`\n            The font size of the text. See `.Text.set_size` for possible\n            values.\n\n        fontweight, weight : default: :rc:`figure.titleweight`\n            The font weight of the text. See `.Text.set_weight` for possible\n            values.\n\n\n        Returns\n        -------\n            text\n                The `.Text` instance of the title.\n\n\n        Other Parameters\n        ----------------\n        fontproperties : None or dict, optional\n            A dict of font properties. If *fontproperties* is given the\n            default values for font size and weight are taken from the\n            `FontProperties` defaults. :rc:`figure.titlesize` and\n            :rc:`figure.titleweight` are ignored in this case.\n\n        **kwargs\n            Additional kwargs are :class:`matplotlib.text.Text` properties.\n\n\n        Examples\n        --------\n        >>> fig.suptitle('This is the figure title', fontsize=12)\n        \"\"\"\n        manual_position = ('x' in kwargs or 'y' in kwargs)\n\n        x = kwargs.pop('x', 0.5)\n        y = kwargs.pop('y', 0.98)\n\n        if 'horizontalalignment' not in kwargs and 'ha' not in kwargs:\n            kwargs['horizontalalignment'] = 'center'\n        if 'verticalalignment' not in kwargs and 'va' not in kwargs:\n            kwargs['verticalalignment'] = 'top'\n\n        if 'fontproperties' not in kwargs:\n            if 'fontsize' not in kwargs and 'size' not in kwargs:\n                kwargs['size'] = rcParams['figure.titlesize']\n            if 'fontweight' not in kwargs and 'weight' not in kwargs:\n                kwargs['weight'] = rcParams['figure.titleweight']\n\n        sup = self.text(x, y, t, **kwargs)\n        if self._suptitle is not None:\n            self._suptitle.set_text(t)\n            self._suptitle.set_position((x, y))\n            self._suptitle.update_from(sup)\n            sup.remove()\n        else:\n            self._suptitle = sup\n            self._suptitle._layoutbox = None\n            if self._layoutbox is not None and not manual_position:\n                w_pad, h_pad, wspace, hspace =  \\\n                        self.get_constrained_layout_pads(relative=True)\n                figlb = self._layoutbox\n                self._suptitle._layoutbox = layoutbox.LayoutBox(\n                        parent=figlb, artist=self._suptitle,\n                        name=figlb.name+'.suptitle')\n                # stack the suptitle on top of all the children.\n                # Some day this should be on top of all the children in the\n                # gridspec only.\n                for child in figlb.children:\n                    if child is not self._suptitle._layoutbox:\n                        layoutbox.vstack([self._suptitle._layoutbox,\n                                          child],\n                                         padding=h_pad*2., strength='required')\n        self.stale = True\n        return self._suptitle",
        "begin_line": 682,
        "end_line": 776,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00026624068157614486,
            "pseudo_dstar_susp": 0.000236630383341221,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.000236630383341221,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.set_canvas#778",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.set_canvas(self, canvas)",
        "snippet": "    def set_canvas(self, canvas):\n        \"\"\"\n        Set the canvas that contains the figure\n\n        Parameters\n        ----------\n        canvas : FigureCanvas\n        \"\"\"\n        self.canvas = canvas",
        "begin_line": 778,
        "end_line": 786,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.set_size_inches#874",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.set_size_inches(self, w, h=None, forward=True)",
        "snippet": "    def set_size_inches(self, w, h=None, forward=True):\n        \"\"\"\n        Set the figure size in inches.\n\n        Call signatures::\n\n             fig.set_size_inches(w, h)  # OR\n             fig.set_size_inches((w, h))\n\n        Parameters\n        ----------\n        w : (float, float) or float\n            Width and height in inches (if height not specified as a separate\n            argument) or width.\n        h : float\n            Height in inches.\n        forward : bool, default: True\n            If ``True``, the canvas size is automatically updated, e.g.,\n            you can resize the figure window from the shell.\n\n        See Also\n        --------\n        matplotlib.Figure.get_size_inches\n        \"\"\"\n        if h is None:  # Got called with a single pair as argument.\n            w, h = w\n        size = np.array([w, h])\n        if not np.isfinite(size).all() or (size <= 0).any():\n            raise ValueError(f'figure size must be positive finite not {size}')\n        self.bbox_inches.p1 = size\n        if forward:\n            canvas = getattr(self, 'canvas')\n            if canvas is not None:\n                dpi_ratio = getattr(canvas, '_dpi_ratio', 1)\n                manager = getattr(canvas, 'manager', None)\n                if manager is not None:\n                    manager.resize(*(size * self.dpi / dpi_ratio).astype(int))\n        self.stale = True",
        "begin_line": 874,
        "end_line": 911,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002347417840375587,
            "pseudo_dstar_susp": 0.0013812154696132596,
            "pseudo_tarantula_susp": 0.0005347593582887701,
            "pseudo_op2_susp": 0.0013812154696132596,
            "pseudo_barinel_susp": 0.0005347593582887701
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.get_size_inches#913",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.get_size_inches(self)",
        "snippet": "    def get_size_inches(self):\n        \"\"\"\n        Returns the current size of the figure in inches.\n\n        Returns\n        -------\n        size : ndarray\n           The size (width, height) of the figure in inches.\n\n        See Also\n        --------\n        matplotlib.Figure.set_size_inches\n        \"\"\"\n        return np.array(self.bbox_inches.p1)",
        "begin_line": 913,
        "end_line": 926,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019179133103183735,
            "pseudo_dstar_susp": 0.00016220600162206002,
            "pseudo_tarantula_susp": 0.0003696857670979667,
            "pseudo_op2_susp": 0.00016220600162206002,
            "pseudo_barinel_susp": 0.0003696857670979667
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.get_edgecolor#928",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.get_edgecolor(self)",
        "snippet": "    def get_edgecolor(self):\n        \"\"\"Get the edge color of the Figure rectangle.\"\"\"\n        return self.patch.get_edgecolor()",
        "begin_line": 928,
        "end_line": 930,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019179133103183735,
            "pseudo_dstar_susp": 0.00016220600162206002,
            "pseudo_tarantula_susp": 0.0003696857670979667,
            "pseudo_op2_susp": 0.00016220600162206002,
            "pseudo_barinel_susp": 0.0003696857670979667
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.get_facecolor#932",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.get_facecolor(self)",
        "snippet": "    def get_facecolor(self):\n        \"\"\"Get the face color of the Figure rectangle.\"\"\"\n        return self.patch.get_facecolor()",
        "begin_line": 932,
        "end_line": 934,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002347417840375587,
            "pseudo_dstar_susp": 0.0013812154696132596,
            "pseudo_tarantula_susp": 0.0005347593582887701,
            "pseudo_op2_susp": 0.0013812154696132596,
            "pseudo_barinel_susp": 0.0005347593582887701
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.set_edgecolor#956",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.set_edgecolor(self, color)",
        "snippet": "    def set_edgecolor(self, color):\n        \"\"\"\n        Set the edge color of the Figure rectangle.\n\n        Parameters\n        ----------\n        color : color\n        \"\"\"\n        self.patch.set_edgecolor(color)",
        "begin_line": 956,
        "end_line": 964,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002347417840375587,
            "pseudo_dstar_susp": 0.0013812154696132596,
            "pseudo_tarantula_susp": 0.0005347593582887701,
            "pseudo_op2_susp": 0.0013812154696132596,
            "pseudo_barinel_susp": 0.0005347593582887701
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.set_facecolor#966",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.set_facecolor(self, color)",
        "snippet": "    def set_facecolor(self, color):\n        \"\"\"\n        Set the face color of the Figure rectangle.\n\n        Parameters\n        ----------\n        color : color\n        \"\"\"\n        self.patch.set_facecolor(color)",
        "begin_line": 966,
        "end_line": 974,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002036659877800407,
            "pseudo_dstar_susp": 0.0021551724137931034,
            "pseudo_tarantula_susp": 0.0003961965134706815,
            "pseudo_op2_susp": 0.0021551724137931034,
            "pseudo_barinel_susp": 0.0003961965134706815
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.set_dpi#976",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.set_dpi(self, val)",
        "snippet": "    def set_dpi(self, val):\n        \"\"\"\n        Set the resolution of the figure in dots-per-inch.\n\n        Parameters\n        ----------\n        val : float\n        \"\"\"\n        self.dpi = val\n        self.stale = True",
        "begin_line": 976,
        "end_line": 985,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011584800741427248,
            "pseudo_dstar_susp": 0.00011463945890175398,
            "pseudo_tarantula_susp": 0.00011973180076628352,
            "pseudo_op2_susp": 0.00011463945890175398,
            "pseudo_barinel_susp": 0.00011973180076628352
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.delaxes#1024",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.delaxes(self, ax)",
        "snippet": "    def delaxes(self, ax):\n        \"\"\"\n        Remove the `~matplotlib.axes.Axes` *ax* from the figure and update the\n        current axes.\n        \"\"\"\n        self._axstack.remove(ax)\n        for func in self._axobservers:\n            func(self)\n        self.stale = True",
        "begin_line": 1024,
        "end_line": 1032,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.add_artist#1034",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.add_artist(self, artist, clip=False)",
        "snippet": "    def add_artist(self, artist, clip=False):\n        \"\"\"\n        Add any :class:`~matplotlib.artist.Artist` to the figure.\n\n        Usually artists are added to axes objects using\n        :meth:`matplotlib.axes.Axes.add_artist`, but use this method in the\n        rare cases that adding directly to the figure is necessary.\n\n        Parameters\n        ----------\n        artist : `~matplotlib.artist.Artist`\n            The artist to add to the figure. If the added artist has no\n            transform previously set, its transform will be set to\n            ``figure.transFigure``.\n        clip : bool, optional, default ``False``\n            An optional parameter ``clip`` determines whether the added artist\n            should be clipped by the figure patch. Default is *False*,\n            i.e. no clipping.\n\n        Returns\n        -------\n        artist : The added `~matplotlib.artist.Artist`\n        \"\"\"\n        artist.set_figure(self)\n        self.artists.append(artist)\n        artist._remove_method = self.artists.remove\n\n        if not artist.is_transform_set():\n            artist.set_transform(self.transFigure)\n\n        if clip:\n            artist.set_clip_path(self.patch)\n\n        self.stale = True\n        return artist",
        "begin_line": 1034,
        "end_line": 1068,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.fixitems#1073",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.fixitems(items)",
        "snippet": "        def fixitems(items):\n            # items may have arrays and lists in them, so convert them\n            # to tuples for the key\n            ret = []\n            for k, v in items:\n                # some objects can define __getitem__ without being\n                # iterable and in those cases the conversion to tuples\n                # will fail. So instead of using the np.iterable(v) function\n                # we simply try and convert to a tuple, and proceed if not.\n                try:\n                    v = tuple(v)\n                except Exception:\n                    pass\n                ret.append((k, v))\n            return tuple(ret)",
        "begin_line": 1073,
        "end_line": 1087,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023957834211787255,
            "pseudo_dstar_susp": 0.0003214400514304082,
            "pseudo_tarantula_susp": 0.00012696800406297612,
            "pseudo_op2_susp": 0.0003214400514304082,
            "pseudo_barinel_susp": 0.00012696800406297612
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure._process_projection_requirements#1100",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure._process_projection_requirements(self, *args, polar=False, projection=None, **kwargs)",
        "snippet": "    def _process_projection_requirements(\n            self, *args, polar=False, projection=None, **kwargs):\n        \"\"\"\n        Handle the args/kwargs to add_axes/add_subplot/gca, returning::\n\n            (axes_proj_class, proj_class_kwargs, proj_stack_key)\n\n        which can be used for new axes initialization/identification.\n        \"\"\"\n        if polar:\n            if projection is not None and projection != 'polar':\n                raise ValueError(\n                    \"polar=True, yet projection=%r. \"\n                    \"Only one of these arguments should be supplied.\" %\n                    projection)\n            projection = 'polar'\n\n        if isinstance(projection, str) or projection is None:\n            projection_class = projections.get_projection_class(projection)\n        elif hasattr(projection, '_as_mpl_axes'):\n            projection_class, extra_kwargs = projection._as_mpl_axes()\n            kwargs.update(**extra_kwargs)\n        else:\n            raise TypeError('projection must be a string, None or implement a '\n                            '_as_mpl_axes method. Got %r' % projection)\n\n        # Make the key without projection kwargs, this is used as a unique\n        # lookup for axes instances\n        key = self._make_key(*args, **kwargs)\n\n        return projection_class, kwargs, key",
        "begin_line": 1100,
        "end_line": 1130,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00044072278536800354,
            "pseudo_dstar_susp": 0.0005773672055427252,
            "pseudo_tarantula_susp": 0.00026068821689259646,
            "pseudo_op2_susp": 0.0005773672055427252,
            "pseudo_barinel_susp": 0.0002615746795710175
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.add_axes#1133",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.add_axes(self, *args, **kwargs)",
        "snippet": "    def add_axes(self, *args, **kwargs):\n        \"\"\"\n        Add an axes to the figure.\n\n        Call signatures::\n\n            add_axes(rect, projection=None, polar=False, **kwargs)\n            add_axes(ax)\n\n        Parameters\n        ----------\n        rect : sequence of float\n            The dimensions [left, bottom, width, height] of the new axes. All\n            quantities are in fractions of figure width and height.\n\n        projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n'polar', 'rectilinear', str}, optional\n            The projection type of the `~.axes.Axes`. *str* is the name of\n            a custom projection, see `~matplotlib.projections`. The default\n            None results in a 'rectilinear' projection.\n\n        polar : boolean, optional\n            If True, equivalent to projection='polar'.\n\n        sharex, sharey : `~.axes.Axes`, optional\n            Share the x or y `~matplotlib.axis` with sharex and/or sharey.\n            The axis will have the same limits, ticks, and scale as the axis\n            of the shared axes.\n\n        label : str\n            A label for the returned axes.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            This method also takes the keyword arguments for\n            the returned axes class. The keyword arguments for the\n            rectilinear axes class `~.axes.Axes` can be found in\n            the following table but there might also be other keyword\n            arguments if another projection is used, see the actual axes\n            class.\n\n            %(Axes)s\n\n        Returns\n        -------\n        axes : `~.axes.Axes` (or a subclass of `~.axes.Axes`)\n            The returned axes class depends on the projection used. It is\n            `~.axes.Axes` if rectilinear projection are used and\n            `.projections.polar.PolarAxes` if polar projection\n            are used.\n\n        Notes\n        -----\n        If the figure already has an axes with key (*args*,\n        *kwargs*) then it will simply make that axes current and\n        return it.  This behavior is deprecated. Meanwhile, if you do\n        not want this behavior (i.e., you want to force the creation of a\n        new axes), you must use a unique set of args and kwargs.  The axes\n        *label* attribute has been exposed for this purpose: if you want\n        two axes that are otherwise identical to be added to the figure,\n        make sure you give them unique labels.\n\n        In rare circumstances, `.add_axes` may be called with a single\n        argument, a axes instance already created in the present figure but\n        not in the figure's list of axes.\n\n        See Also\n        --------\n        .Figure.add_subplot\n        .pyplot.subplot\n        .pyplot.axes\n        .Figure.subplots\n        .pyplot.subplots\n\n        Examples\n        --------\n        Some simple examples::\n\n            rect = l, b, w, h\n            fig = plt.figure()\n            fig.add_axes(rect, label=label1)\n            fig.add_axes(rect, label=label2)\n            fig.add_axes(rect, frameon=False, facecolor='g')\n            fig.add_axes(rect, polar=True)\n            ax = fig.add_axes(rect, projection='polar')\n            fig.delaxes(ax)\n            fig.add_axes(ax)\n        \"\"\"\n\n        if not len(args):\n            return\n\n        # shortcut the projection \"key\" modifications later on, if an axes\n        # with the exact args/kwargs exists, return it immediately.\n        key = self._make_key(*args, **kwargs)\n        ax = self._axstack.get(key)\n        if ax is not None:\n            self.sca(ax)\n            return ax\n\n        if isinstance(args[0], Axes):\n            a = args[0]\n            if a.get_figure() is not self:\n                raise ValueError(\n                    \"The Axes must have been created in the present figure\")\n        else:\n            rect = args[0]\n            if not np.isfinite(rect).all():\n                raise ValueError('all entries in rect must be finite '\n                                 'not {}'.format(rect))\n            projection_class, kwargs, key = \\\n                self._process_projection_requirements(*args, **kwargs)\n\n            # check that an axes of this type doesn't already exist, if it\n            # does, set it as active and return it\n            ax = self._axstack.get(key)\n            if isinstance(ax, projection_class):\n                self.sca(ax)\n                return ax\n\n            # create the new axes using the axes class given\n            a = projection_class(self, rect, **kwargs)\n\n        return self._add_axes_internal(key, a)",
        "begin_line": 1133,
        "end_line": 1257,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00025477707006369424,
            "pseudo_dstar_susp": 0.0002420721374969741,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0002420721374969741,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.add_subplot#1260",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.add_subplot(self, *args, **kwargs)",
        "snippet": "    def add_subplot(self, *args, **kwargs):\n        \"\"\"\n        Add an `~.axes.Axes` to the figure as part of a subplot arrangement.\n\n        Call signatures::\n\n           add_subplot(nrows, ncols, index, **kwargs)\n           add_subplot(pos, **kwargs)\n           add_subplot(ax)\n           add_subplot()\n\n        Parameters\n        ----------\n        *args\n            Either a 3-digit integer or three separate integers\n            describing the position of the subplot. If the three\n            integers are *nrows*, *ncols*, and *index* in order, the\n            subplot will take the *index* position on a grid with *nrows*\n            rows and *ncols* columns. *index* starts at 1 in the upper left\n            corner and increases to the right.\n\n            *pos* is a three digit integer, where the first digit is the\n            number of rows, the second the number of columns, and the third\n            the index of the subplot. i.e. fig.add_subplot(235) is the same as\n            fig.add_subplot(2, 3, 5). Note that all integers must be less than\n            10 for this form to work.\n\n            If no positional arguments are passed, defaults to (1, 1, 1).\n\n            In rare circumstances, `.add_subplot` may be called with a single\n            argument, a subplot axes instance already created in the\n            present figure but not in the figure's list of axes.\n\n        projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n'polar', 'rectilinear', str}, optional\n            The projection type of the subplot (`~.axes.Axes`). *str* is the\n            name of a custom projection, see `~matplotlib.projections`. The\n            default None results in a 'rectilinear' projection.\n\n        polar : boolean, optional\n            If True, equivalent to projection='polar'.\n\n        sharex, sharey : `~.axes.Axes`, optional\n            Share the x or y `~matplotlib.axis` with sharex and/or sharey.\n            The axis will have the same limits, ticks, and scale as the axis\n            of the shared axes.\n\n        label : str\n            A label for the returned axes.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            This method also takes the keyword arguments for the returned axes\n            base class; except for the *figure* argument. The keyword arguments\n            for the rectilinear base class `~.axes.Axes` can be found in\n            the following table but there might also be other keyword\n            arguments if another projection is used.\n\n            %(Axes)s\n\n        Returns\n        -------\n        axes : `.axes.SubplotBase`, or another subclass of `~.axes.Axes`\n\n            The axes of the subplot. The returned axes base class depends on\n            the projection used. It is `~.axes.Axes` if rectilinear projection\n            are used and `.projections.polar.PolarAxes` if polar projection\n            are used. The returned axes is then a subplot subclass of the\n            base class.\n\n        Notes\n        -----\n        If the figure already has a subplot with key (*args*,\n        *kwargs*) then it will simply make that subplot current and\n        return it.  This behavior is deprecated. Meanwhile, if you do\n        not want this behavior (i.e., you want to force the creation of a\n        new subplot), you must use a unique set of args and kwargs.  The axes\n        *label* attribute has been exposed for this purpose: if you want\n        two subplots that are otherwise identical to be added to the figure,\n        make sure you give them unique labels.\n\n        See Also\n        --------\n        .Figure.add_axes\n        .pyplot.subplot\n        .pyplot.axes\n        .Figure.subplots\n        .pyplot.subplots\n\n        Examples\n        --------\n        ::\n\n            fig = plt.figure()\n            fig.add_subplot(221)\n\n            # equivalent but more general\n            ax1 = fig.add_subplot(2, 2, 1)\n\n            # add a subplot with no frame\n            ax2 = fig.add_subplot(222, frameon=False)\n\n            # add a polar subplot\n            fig.add_subplot(223, projection='polar')\n\n            # add a red subplot that share the x-axis with ax1\n            fig.add_subplot(224, sharex=ax1, facecolor='red')\n\n            #delete x2 from the figure\n            fig.delaxes(ax2)\n\n            #add x2 to the figure again\n            fig.add_subplot(ax2)\n        \"\"\"\n        if not len(args):\n            args = (1, 1, 1)\n\n        if len(args) == 1 and isinstance(args[0], Integral):\n            if not 100 <= args[0] <= 999:\n                raise ValueError(\"Integer subplot specification must be a \"\n                                 \"three-digit number, not {}\".format(args[0]))\n            args = tuple(map(int, str(args[0])))\n\n        if 'figure' in kwargs:\n            # Axes itself allows for a 'figure' kwarg, but since we want to\n            # bind the created Axes to self, it is not allowed here.\n            raise TypeError(\n                \"add_subplot() got an unexpected keyword argument 'figure'\")\n\n        if isinstance(args[0], SubplotBase):\n\n            a = args[0]\n            if a.get_figure() is not self:\n                raise ValueError(\n                    \"The Subplot must have been created in the present figure\")\n            # make a key for the subplot (which includes the axes object id\n            # in the hash)\n            key = self._make_key(*args, **kwargs)\n        else:\n            projection_class, kwargs, key = \\\n                self._process_projection_requirements(*args, **kwargs)\n\n            # try to find the axes with this key in the stack\n            ax = self._axstack.get(key)\n\n            if ax is not None:\n                if isinstance(ax, projection_class):\n                    # the axes already existed, so set it as active & return\n                    self.sca(ax)\n                    return ax\n                else:\n                    # Undocumented convenience behavior:\n                    # subplot(111); subplot(111, projection='polar')\n                    # will replace the first with the second.\n                    # Without this, add_subplot would be simpler and\n                    # more similar to add_axes.\n                    self._axstack.remove(ax)\n\n            a = subplot_class_factory(projection_class)(self, *args, **kwargs)\n\n        return self._add_axes_internal(key, a)",
        "begin_line": 1260,
        "end_line": 1421,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00039231071008238524,
            "pseudo_dstar_susp": 0.0005534034311012728,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.0005534034311012728,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure._add_axes_internal#1423",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure._add_axes_internal(self, key, ax)",
        "snippet": "    def _add_axes_internal(self, key, ax):\n        \"\"\"Private helper for `add_axes` and `add_subplot`.\"\"\"\n        self._axstack.add(key, ax)\n        self.sca(ax)\n        ax._remove_method = self._remove_ax\n        self.stale = True\n        ax.stale_callback = _stale_figure_callback\n        return ax",
        "begin_line": 1423,
        "end_line": 1430,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043878894251864854,
            "pseudo_dstar_susp": 0.0006242197253433209,
            "pseudo_tarantula_susp": 0.00028121484814398203,
            "pseudo_op2_susp": 0.0006242197253433209,
            "pseudo_barinel_susp": 0.00028121484814398203
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.subplots#1432",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.subplots(self, nrows=1, ncols=1, sharex=False, sharey=False, squeeze=True, subplot_kw=None, gridspec_kw=None)",
        "snippet": "    def subplots(self, nrows=1, ncols=1, sharex=False, sharey=False,\n                 squeeze=True, subplot_kw=None, gridspec_kw=None):\n        \"\"\"\n        Add a set of subplots to this figure.\n\n        This utility wrapper makes it convenient to create common layouts of\n        subplots in a single call.\n\n        Parameters\n        ----------\n        nrows, ncols : int, optional, default: 1\n            Number of rows/columns of the subplot grid.\n\n        sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False\n            Controls sharing of properties among x (`sharex`) or y (`sharey`)\n            axes:\n\n            - True or 'all': x- or y-axis will be shared among all subplots.\n            - False or 'none': each subplot x- or y-axis will be independent.\n            - 'row': each subplot row will share an x- or y-axis.\n            - 'col': each subplot column will share an x- or y-axis.\n\n            When subplots have a shared x-axis along a column, only the x tick\n            labels of the bottom subplot are created. Similarly, when subplots\n            have a shared y-axis along a row, only the y tick labels of the\n            first column subplot are created. To later turn other subplots'\n            ticklabels on, use `~matplotlib.axes.Axes.tick_params`.\n\n        squeeze : bool, optional, default: True\n            - If True, extra dimensions are squeezed out from the returned\n              array of Axes:\n\n              - if only one subplot is constructed (nrows=ncols=1), the\n                resulting single Axes object is returned as a scalar.\n              - for Nx1 or 1xM subplots, the returned object is a 1D numpy\n                object array of Axes objects.\n              - for NxM, subplots with N>1 and M>1 are returned as a 2D array.\n\n            - If False, no squeezing at all is done: the returned Axes object\n              is always a 2D array containing Axes instances, even if it ends\n              up being 1x1.\n\n        subplot_kw : dict, optional\n            Dict with keywords passed to the\n            :meth:`~matplotlib.figure.Figure.add_subplot` call used to create\n            each subplot.\n\n        gridspec_kw : dict, optional\n            Dict with keywords passed to the\n            `~matplotlib.gridspec.GridSpec` constructor used to create\n            the grid the subplots are placed on.\n\n        Returns\n        -------\n        ax : `~.axes.Axes` object or array of Axes objects.\n            *ax* can be either a single `~matplotlib.axes.Axes` object or\n            an array of Axes objects if more than one subplot was created. The\n            dimensions of the resulting array can be controlled with the\n            squeeze keyword, see above.\n\n        Examples\n        --------\n        ::\n\n            # First create some toy data:\n            x = np.linspace(0, 2*np.pi, 400)\n            y = np.sin(x**2)\n\n            # Create a figure\n            plt.figure()\n\n            # Create a subplot\n            ax = fig.subplots()\n            ax.plot(x, y)\n            ax.set_title('Simple plot')\n\n            # Create two subplots and unpack the output array immediately\n            ax1, ax2 = fig.subplots(1, 2, sharey=True)\n            ax1.plot(x, y)\n            ax1.set_title('Sharing Y axis')\n            ax2.scatter(x, y)\n\n            # Create four polar axes and access them through the returned array\n            axes = fig.subplots(2, 2, subplot_kw=dict(polar=True))\n            axes[0, 0].plot(x, y)\n            axes[1, 1].scatter(x, y)\n\n            # Share a X axis with each column of subplots\n            fig.subplots(2, 2, sharex='col')\n\n            # Share a Y axis with each row of subplots\n            fig.subplots(2, 2, sharey='row')\n\n            # Share both X and Y axes with all subplots\n            fig.subplots(2, 2, sharex='all', sharey='all')\n\n            # Note that this is the same as\n            fig.subplots(2, 2, sharex=True, sharey=True)\n\n        See Also\n        --------\n        .pyplot.subplots\n        .Figure.add_subplot\n        .pyplot.subplot\n        \"\"\"\n\n        if isinstance(sharex, bool):\n            sharex = \"all\" if sharex else \"none\"\n        if isinstance(sharey, bool):\n            sharey = \"all\" if sharey else \"none\"\n        # This check was added because it is very easy to type\n        # `subplots(1, 2, 1)` when `subplot(1, 2, 1)` was intended.\n        # In most cases, no error will ever occur, but mysterious behavior\n        # will result because what was intended to be the subplot index is\n        # instead treated as a bool for sharex.\n        if isinstance(sharex, Integral):\n            cbook._warn_external(\n                \"sharex argument to subplots() was an integer.  Did you \"\n                \"intend to use subplot() (without 's')?\")\n        cbook._check_in_list([\"all\", \"row\", \"col\", \"none\"],\n                             sharex=sharex, sharey=sharey)\n        if subplot_kw is None:\n            subplot_kw = {}\n        if gridspec_kw is None:\n            gridspec_kw = {}\n        # don't mutate kwargs passed by user...\n        subplot_kw = subplot_kw.copy()\n        gridspec_kw = gridspec_kw.copy()\n\n        if self.get_constrained_layout():\n            gs = GridSpec(nrows, ncols, figure=self, **gridspec_kw)\n        else:\n            # this should turn constrained_layout off if we don't want it\n            gs = GridSpec(nrows, ncols, figure=None, **gridspec_kw)\n        self._gridspecs.append(gs)\n\n        # Create array to hold all axes.\n        axarr = np.empty((nrows, ncols), dtype=object)\n        for row in range(nrows):\n            for col in range(ncols):\n                shared_with = {\"none\": None, \"all\": axarr[0, 0],\n                               \"row\": axarr[row, 0], \"col\": axarr[0, col]}\n                subplot_kw[\"sharex\"] = shared_with[sharex]\n                subplot_kw[\"sharey\"] = shared_with[sharey]\n                axarr[row, col] = self.add_subplot(gs[row, col], **subplot_kw)\n\n        # turn off redundant tick labeling\n        if sharex in [\"col\", \"all\"]:\n            # turn off all but the bottom row\n            for ax in axarr[:-1, :].flat:\n                ax.xaxis.set_tick_params(which='both',\n                                         labelbottom=False, labeltop=False)\n                ax.xaxis.offsetText.set_visible(False)\n        if sharey in [\"row\", \"all\"]:\n            # turn off all but the first column\n            for ax in axarr[:, 1:].flat:\n                ax.yaxis.set_tick_params(which='both',\n                                         labelleft=False, labelright=False)\n                ax.yaxis.offsetText.set_visible(False)\n\n        if squeeze:\n            # Discarding unneeded dimensions that equal 1.  If we only have one\n            # subplot, just return it instead of a 1-element array.\n            return axarr.item() if axarr.size == 1 else axarr.squeeze()\n        else:\n            # Returned axis array will be always 2-d, even if nrows=ncols=1.\n            return axarr",
        "begin_line": 1432,
        "end_line": 1598,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00025523226135783564,
            "pseudo_dstar_susp": 0.00033523298692591353,
            "pseudo_tarantula_susp": 0.00015482272797646694,
            "pseudo_op2_susp": 0.00033523298692591353,
            "pseudo_barinel_susp": 0.00015446400988569664
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure._remove_ax#1600",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure._remove_ax(self, ax)",
        "snippet": "    def _remove_ax(self, ax):\n        def _reset_locators_and_formatters(axis):\n            # Set the formatters and locators to be associated with axis\n            # (where previously they may have been associated with another\n            # Axis isntance)\n            #\n            # Because set_major_formatter() etc. force isDefault_* to be False,\n            # we have to manually check if the original formatter was a\n            # default and manually set isDefault_* if that was the case.\n            majfmt = axis.get_major_formatter()\n            isDefault = majfmt.axis.isDefault_majfmt\n            axis.set_major_formatter(majfmt)\n            if isDefault:\n                majfmt.axis.isDefault_majfmt = True\n\n            majloc = axis.get_major_locator()\n            isDefault = majloc.axis.isDefault_majloc\n            axis.set_major_locator(majloc)\n            if isDefault:\n                majloc.axis.isDefault_majloc = True\n\n            minfmt = axis.get_minor_formatter()\n            isDefault = majloc.axis.isDefault_minfmt\n            axis.set_minor_formatter(minfmt)\n            if isDefault:\n                minfmt.axis.isDefault_minfmt = True\n\n            minloc = axis.get_minor_locator()\n            isDefault = majloc.axis.isDefault_minloc\n            axis.set_minor_locator(minloc)\n            if isDefault:\n                minloc.axis.isDefault_minloc = True\n\n        def _break_share_link(ax, grouper):\n            siblings = grouper.get_siblings(ax)\n            if len(siblings) > 1:\n                grouper.remove(ax)\n                for last_ax in siblings:\n                    if ax is not last_ax:\n                        return last_ax\n            return None\n\n        self.delaxes(ax)\n        last_ax = _break_share_link(ax, ax._shared_y_axes)\n        if last_ax is not None:\n            _reset_locators_and_formatters(last_ax.yaxis)\n\n        last_ax = _break_share_link(ax, ax._shared_x_axes)\n        if last_ax is not None:\n            _reset_locators_and_formatters(last_ax.xaxis)",
        "begin_line": 1600,
        "end_line": 1649,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure._reset_locators_and_formatters#1601",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure._reset_locators_and_formatters(axis)",
        "snippet": "        def _reset_locators_and_formatters(axis):\n            # Set the formatters and locators to be associated with axis\n            # (where previously they may have been associated with another\n            # Axis isntance)\n            #\n            # Because set_major_formatter() etc. force isDefault_* to be False,\n            # we have to manually check if the original formatter was a\n            # default and manually set isDefault_* if that was the case.\n            majfmt = axis.get_major_formatter()\n            isDefault = majfmt.axis.isDefault_majfmt\n            axis.set_major_formatter(majfmt)\n            if isDefault:\n                majfmt.axis.isDefault_majfmt = True\n\n            majloc = axis.get_major_locator()\n            isDefault = majloc.axis.isDefault_majloc\n            axis.set_major_locator(majloc)\n            if isDefault:\n                majloc.axis.isDefault_majloc = True\n\n            minfmt = axis.get_minor_formatter()\n            isDefault = majloc.axis.isDefault_minfmt\n            axis.set_minor_formatter(minfmt)\n            if isDefault:\n                minfmt.axis.isDefault_minfmt = True\n\n            minloc = axis.get_minor_locator()\n            isDefault = majloc.axis.isDefault_minloc\n            axis.set_minor_locator(minloc)\n            if isDefault:\n                minloc.axis.isDefault_minloc = True",
        "begin_line": 1601,
        "end_line": 1631,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.clf#1651",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.clf(self, keep_observers=False)",
        "snippet": "    def clf(self, keep_observers=False):\n        \"\"\"\n        Clear the figure.\n\n        Set *keep_observers* to True if, for example,\n        a gui widget is tracking the axes in the figure.\n        \"\"\"\n        self.suppressComposite = None\n        self.callbacks = cbook.CallbackRegistry()\n\n        for ax in tuple(self.axes):  # Iterate over the copy.\n            ax.cla()\n            self.delaxes(ax)         # removes ax from self._axstack\n\n        toolbar = getattr(self.canvas, 'toolbar', None)\n        if toolbar is not None:\n            toolbar.update()\n        self._axstack.clear()\n        self.artists = []\n        self.lines = []\n        self.patches = []\n        self.texts = []\n        self.images = []\n        self.legends = []\n        if not keep_observers:\n            self._axobservers = []\n        self._suptitle = None\n        if self.get_constrained_layout():\n            layoutbox.nonetree(self._layoutbox)\n        self.stale = True",
        "begin_line": 1651,
        "end_line": 1680,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014388489208633094,
            "pseudo_dstar_susp": 0.003676470588235294,
            "pseudo_tarantula_susp": 0.00045682960255824577,
            "pseudo_op2_susp": 0.003676470588235294,
            "pseudo_barinel_susp": 0.00045682960255824577
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.draw#1689",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        \"\"\"\n        Render the figure using :class:`matplotlib.backend_bases.RendererBase`\n        instance *renderer*.\n        \"\"\"\n        self._cachedRenderer = renderer\n\n        # draw the figure bounding box, perhaps none for white figure\n        if not self.get_visible():\n            return\n\n        artists = self.get_children()\n        artists.remove(self.patch)\n        artists = sorted(\n            (artist for artist in artists if not artist.get_animated()),\n            key=lambda artist: artist.get_zorder())\n\n        for ax in self.axes:\n            locator = ax.get_axes_locator()\n            if locator:\n                pos = locator(ax, renderer)\n                ax.apply_aspect(pos)\n            else:\n                ax.apply_aspect()\n\n            for child in ax.get_children():\n                if hasattr(child, 'apply_aspect'):\n                    locator = child.get_axes_locator()\n                    if locator:\n                        pos = locator(child, renderer)\n                        child.apply_aspect(pos)\n                    else:\n                        child.apply_aspect()\n\n        try:\n            renderer.open_group('figure', gid=self.get_gid())\n            if self.get_constrained_layout() and self.axes:\n                self.execute_constrained_layout(renderer)\n            if self.get_tight_layout() and self.axes:\n                try:\n                    self.tight_layout(**self._tight_parameters)\n                except ValueError:\n                    pass\n                    # ValueError can occur when resizing a window.\n\n            self.patch.draw(renderer)\n            mimage._draw_list_compositing_images(\n                renderer, self, artists, self.suppressComposite)\n\n            renderer.close_group('figure')\n        finally:\n            self.stale = False\n\n        self.canvas.draw_event(renderer)",
        "begin_line": 1689,
        "end_line": 1742,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016666666666666668,
            "pseudo_dstar_susp": 0.002304147465437788,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.002304147465437788,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.draw_artist#1744",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.draw_artist(self, a)",
        "snippet": "    def draw_artist(self, a):\n        \"\"\"\n        Draw :class:`matplotlib.artist.Artist` instance *a* only.\n        This is available only after the figure is drawn.\n        \"\"\"\n        if self._cachedRenderer is None:\n            raise AttributeError(\"draw_artist can only be used after an \"\n                                 \"initial draw which caches the renderer\")\n        a.draw(self._cachedRenderer)",
        "begin_line": 1744,
        "end_line": 1752,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.get_axes#1754",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.get_axes(self)",
        "snippet": "    def get_axes(self):\n        \"\"\"\n        Return a list of axes in the Figure. You can access and modify the\n        axes in the Figure through this list.\n\n        Do not modify the list itself. Instead, use `~Figure.add_axes`,\n        `~.Figure.subplot` or `~.Figure.delaxes` to add or remove an axes.\n\n        Note: This is equivalent to the property `~.Figure.axes`.\n        \"\"\"\n        return self.axes",
        "begin_line": 1754,
        "end_line": 1764,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002085070892410342,
            "pseudo_dstar_susp": 0.0002133560913164071,
            "pseudo_tarantula_susp": 0.00022187708009762592,
            "pseudo_op2_susp": 0.0002133560913164071,
            "pseudo_barinel_susp": 0.00022187708009762592
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.legend#1771",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.legend(self, *args, **kwargs)",
        "snippet": "    def legend(self, *args, **kwargs):\n        \"\"\"\n        Place a legend on the figure.\n\n        To make a legend from existing artists on every axes::\n\n          legend()\n\n        To make a legend for a list of lines and labels::\n\n          legend(\n              (line1, line2, line3),\n              ('label1', 'label2', 'label3'),\n              loc='upper right')\n\n        These can also be specified by keyword::\n\n          legend(\n              handles=(line1, line2, line3),\n              labels=('label1', 'label2', 'label3'),\n              loc='upper right')\n\n        Parameters\n        ----------\n        handles : list of `.Artist`, optional\n            A list of Artists (lines, patches) to be added to the legend.\n            Use this together with *labels*, if you need full control on what\n            is shown in the legend and the automatic mechanism described above\n            is not sufficient.\n\n            The length of handles and labels should be the same in this\n            case. If they are not, they are truncated to the smaller length.\n\n        labels : list of str, optional\n            A list of labels to show next to the artists.\n            Use this together with *handles*, if you need full control on what\n            is shown in the legend and the automatic mechanism described above\n            is not sufficient.\n\n        Other Parameters\n        ----------------\n        %(_legend_kw_doc)s\n\n        Returns\n        -------\n        :class:`matplotlib.legend.Legend` instance\n\n        Notes\n        -----\n        Not all kinds of artist are supported by the legend command. See\n        :doc:`/tutorials/intermediate/legend_guide` for details.\n        \"\"\"\n\n        handles, labels, extra_args, kwargs = mlegend._parse_legend_args(\n                self.axes,\n                *args,\n                **kwargs)\n        # check for third arg\n        if len(extra_args):\n            # cbook.warn_deprecated(\n            #     \"2.1\",\n            #     message=\"Figure.legend will accept no more than two \"\n            #     \"positional arguments in the future.  Use \"\n            #     \"'fig.legend(handles, labels, loc=location)' \"\n            #     \"instead.\")\n            # kwargs['loc'] = extra_args[0]\n            # extra_args = extra_args[1:]\n            pass\n        l = mlegend.Legend(self, handles, labels, *extra_args, **kwargs)\n        self.legends.append(l)\n        l._remove_method = self.legends.remove\n        self.stale = True\n        return l",
        "begin_line": 1771,
        "end_line": 1843,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.text#1847",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.text(self, x, y, s, fontdict=None, withdash=False, **kwargs)",
        "snippet": "    def text(self, x, y, s, fontdict=None, withdash=False, **kwargs):\n        \"\"\"\n        Add text to figure.\n\n        Parameters\n        ----------\n        x, y : float\n            The position to place the text. By default, this is in figure\n            coordinates, floats in [0, 1]. The coordinate system can be changed\n            using the *transform* keyword.\n\n        s : str\n            The text string.\n\n        fontdict : dictionary, optional, default: None\n            A dictionary to override the default text properties. If fontdict\n            is None, the defaults are determined by your rc parameters. A\n            property in *kwargs* override the same property in fontdict.\n\n        withdash : boolean, optional, default: False\n            Creates a `~matplotlib.text.TextWithDash` instance instead of a\n            `~matplotlib.text.Text` instance.\n\n        Other Parameters\n        ----------------\n        **kwargs : `~matplotlib.text.Text` properties\n            Other miscellaneous text parameters.\n\n            %(Text)s\n\n        Returns\n        -------\n        text : `~.text.Text`\n\n        See Also\n        --------\n        .Axes.text\n        .pyplot.text\n        \"\"\"\n        default = dict(transform=self.transFigure)\n\n        if (withdash\n                and withdash is not cbook.deprecation._deprecated_parameter):\n            text = TextWithDash(x=x, y=y, text=s)\n        else:\n            text = Text(x=x, y=y, text=s)\n\n        text.update(default)\n        if fontdict is not None:\n            text.update(fontdict)\n        text.update(kwargs)\n\n        text.set_figure(self)\n        text.stale_callback = _stale_figure_callback\n\n        self.texts.append(text)\n        text._remove_method = self.texts.remove\n        self.stale = True\n        return text",
        "begin_line": 1847,
        "end_line": 1905,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0025575447570332483,
            "pseudo_dstar_susp": 0.0017452006980802793,
            "pseudo_tarantula_susp": 0.0005120327700972862,
            "pseudo_op2_susp": 0.0017452006980802793,
            "pseudo_barinel_susp": 0.0005120327700972862
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure._set_artist_props#1907",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure._set_artist_props(self, a)",
        "snippet": "    def _set_artist_props(self, a):\n        if a != self:\n            a.set_figure(self)\n        a.stale_callback = _stale_figure_callback\n        a.set_transform(self.transFigure)",
        "begin_line": 1907,
        "end_line": 1911,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012360939431396785,
            "pseudo_dstar_susp": 0.0026041666666666665,
            "pseudo_tarantula_susp": 0.0003944773175542406,
            "pseudo_op2_susp": 0.0026041666666666665,
            "pseudo_barinel_susp": 0.0003944773175542406
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.gca#1914",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.gca(self, **kwargs)",
        "snippet": "    def gca(self, **kwargs):\n        \"\"\"\n        Get the current axes, creating one if necessary.\n\n        The following kwargs are supported for ensuring the returned axes\n        adheres to the given projection etc., and for axes creation if\n        the active axes does not exist:\n\n        %(Axes)s\n\n        \"\"\"\n        ckey, cax = self._axstack.current_key_axes()\n        # if there exists an axes on the stack see if it matches\n        # the desired axes configuration\n        if cax is not None:\n\n            # if no kwargs are given just return the current axes\n            # this is a convenience for gca() on axes such as polar etc.\n            if not kwargs:\n                return cax\n\n            # if the user has specified particular projection detail\n            # then build up a key which can represent this\n            else:\n                projection_class, _, key = \\\n                    self._process_projection_requirements(**kwargs)\n\n                # let the returned axes have any gridspec by removing it from\n                # the key\n                ckey = ckey[1:]\n                key = key[1:]\n\n                # if the cax matches this key then return the axes, otherwise\n                # continue and a new axes will be created\n                if key == ckey and isinstance(cax, projection_class):\n                    return cax\n                else:\n                    cbook._warn_external('Requested projection is different '\n                                         'from current axis projection, '\n                                         'creating new axis with requested '\n                                         'projection.')\n\n        # no axes found, so create one which spans the figure\n        return self.add_subplot(1, 1, 1, **kwargs)",
        "begin_line": 1914,
        "end_line": 1957,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00026295030239284776,
            "pseudo_dstar_susp": 0.00031486146095717883,
            "pseudo_tarantula_susp": 0.00016644474034620507,
            "pseudo_op2_susp": 0.00031486146095717883,
            "pseudo_barinel_susp": 0.00016644474034620507
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.sca#1959",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.sca(self, a)",
        "snippet": "    def sca(self, a):\n        \"\"\"Set the current axes to be a and return a.\"\"\"\n        self._axstack.bubble(a)\n        for func in self._axobservers:\n            func(self)\n        return a",
        "begin_line": 1959,
        "end_line": 1964,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00045454545454545455,
            "pseudo_dstar_susp": 0.0005586592178770949,
            "pseudo_tarantula_susp": 0.00016257519102584944,
            "pseudo_op2_susp": 0.0005586592178770949,
            "pseudo_barinel_susp": 0.00016257519102584944
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.__getstate__#1987",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.__getstate__(self)",
        "snippet": "    def __getstate__(self):\n        state = super().__getstate__()\n\n        # the axobservers cannot currently be pickled.\n        # Additionally, the canvas cannot currently be pickled, but this has\n        # the benefit of meaning that a figure can be detached from one canvas,\n        # and re-attached to another.\n        for attr_to_pop in ('_axobservers', 'show',\n                            'canvas', '_cachedRenderer'):\n            state.pop(attr_to_pop, None)\n\n        # add version information to the state\n        state['__mpl_version__'] = _mpl_version\n\n        # check whether the figure manager (if any) is registered with pyplot\n        from matplotlib import _pylab_helpers\n        if getattr(self.canvas, 'manager', None) \\\n                in _pylab_helpers.Gcf.figs.values():\n            state['_restore_to_pylab'] = True\n\n        # set all the layoutbox information to None.  kiwisolver objects can't\n        # be pickled, so we lose the layout options at this point.\n        state.pop('_layoutbox', None)\n        # suptitle:\n        if self._suptitle is not None:\n            self._suptitle._layoutbox = None\n\n        return state",
        "begin_line": 1987,
        "end_line": 2014,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012023566189731875,
            "pseudo_dstar_susp": 0.00011741223435481978,
            "pseudo_tarantula_susp": 0.00013345789403443215,
            "pseudo_op2_susp": 0.00011741223435481978,
            "pseudo_barinel_susp": 0.00013338668800853674
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.__setstate__#2016",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.__setstate__(self, state)",
        "snippet": "    def __setstate__(self, state):\n        version = state.pop('__mpl_version__')\n        restore_to_pylab = state.pop('_restore_to_pylab', False)\n\n        if version != _mpl_version:\n            cbook._warn_external(\n                f\"This figure was saved with matplotlib version {version} and \"\n                f\"is unlikely to function correctly.\")\n\n        self.__dict__ = state\n\n        # re-initialise some of the unstored state information\n        self._axobservers = []\n        self.canvas = None\n        self._layoutbox = None\n\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n\n            # XXX The following is a copy and paste from pyplot. Consider\n            # factoring to pylab_helpers\n\n            if self.get_label():\n                mgr.set_window_title(self.get_label())\n\n            # make this figure current on button press event\n            def make_active(event):\n                pylab_helpers.Gcf.set_active(mgr)\n\n            mgr._cidgcf = mgr.canvas.mpl_connect('button_press_event',\n                                                 make_active)\n\n            pylab_helpers.Gcf.set_active(mgr)\n            self.number = num\n\n            plt.draw_if_interactive()\n        self.stale = True",
        "begin_line": 2016,
        "end_line": 2057,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.add_axobserver#2059",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.add_axobserver(self, func)",
        "snippet": "    def add_axobserver(self, func):\n        \"\"\"Whenever the axes state change, ``func(self)`` will be called.\"\"\"\n        self._axobservers.append(func)",
        "begin_line": 2059,
        "end_line": 2061,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012391573729863693,
            "pseudo_dstar_susp": 0.0017825311942959,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0017825311942959,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.savefig#2063",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.savefig(self, fname, *, transparent=None, **kwargs)",
        "snippet": "    def savefig(self, fname, *, transparent=None, **kwargs):\n        \"\"\"\n        Save the current figure.\n\n        Call signature::\n\n          savefig(fname, dpi=None, facecolor='w', edgecolor='w',\n                  orientation='portrait', papertype=None, format=None,\n                  transparent=False, bbox_inches=None, pad_inches=0.1,\n                  frameon=None, metadata=None)\n\n        The output formats available depend on the backend being used.\n\n        Parameters\n        ----------\n        fname : str or PathLike or file-like object\n            A path, or a Python file-like object, or\n            possibly some backend-dependent object such as\n            `matplotlib.backends.backend_pdf.PdfPages`.\n\n            If *format* is not set, then the output format is inferred from\n            the extension of *fname*, if any, and from :rc:`savefig.format`\n            otherwise.  If *format* is set, it determines the output format.\n\n            Hence, if *fname* is not a path or has no extension, remember to\n            specify *format* to ensure that the correct backend is used.\n\n        Other Parameters\n        ----------------\n        dpi : [ *None* | scalar > 0 | 'figure' ]\n            The resolution in dots per inch.  If *None*, defaults to\n            :rc:`savefig.dpi`.  If 'figure', uses the figure's dpi value.\n\n        quality : [ *None* | 1 <= scalar <= 100 ]\n            The image quality, on a scale from 1 (worst) to 95 (best).\n            Applicable only if *format* is jpg or jpeg, ignored otherwise.\n            If *None*, defaults to :rc:`savefig.jpeg_quality`.\n            Values above 95 should be avoided; 100 completely disables the\n            JPEG quantization stage.\n\n        optimize : bool\n            If *True*, indicates that the JPEG encoder should make an extra\n            pass over the image in order to select optimal encoder settings.\n            Applicable only if *format* is jpg or jpeg, ignored otherwise.\n            Is *False* by default.\n\n        progressive : bool\n            If *True*, indicates that this image should be stored as a\n            progressive JPEG file. Applicable only if *format* is jpg or\n            jpeg, ignored otherwise. Is *False* by default.\n\n        facecolor : color or None, optional\n            The facecolor of the figure; if *None*, defaults to\n            :rc:`savefig.facecolor`.\n\n        edgecolor : color or None, optional\n            The edgecolor of the figure; if *None*, defaults to\n            :rc:`savefig.edgecolor`\n\n        orientation : {'landscape', 'portrait'}\n            Currently only supported by the postscript backend.\n\n        papertype : str\n            One of 'letter', 'legal', 'executive', 'ledger', 'a0' through\n            'a10', 'b0' through 'b10'. Only supported for postscript\n            output.\n\n        format : str\n            The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when\n            this is unset is documented under *fname*.\n\n        transparent : bool\n            If *True*, the axes patches will all be transparent; the\n            figure patch will also be transparent unless facecolor\n            and/or edgecolor are specified via kwargs.\n            This is useful, for example, for displaying\n            a plot on top of a colored background on a web page.  The\n            transparency of these patches will be restored to their\n            original values upon exit of this function.\n\n        bbox_inches : str or `~matplotlib.transforms.Bbox`, optional\n            Bbox in inches. Only the given portion of the figure is\n            saved. If 'tight', try to figure out the tight bbox of\n            the figure. If None, use savefig.bbox\n\n        pad_inches : scalar, optional\n            Amount of padding around the figure when bbox_inches is\n            'tight'. If None, use savefig.pad_inches\n\n        bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional\n            A list of extra artists that will be considered when the\n            tight bbox is calculated.\n\n        metadata : dict, optional\n            Key/value pairs to store in the image metadata. The supported keys\n            and defaults depend on the image format and backend:\n\n            - 'png' with Agg backend: See the parameter ``metadata`` of\n              `~.FigureCanvasAgg.print_png`.\n            - 'pdf' with pdf backend: See the parameter ``metadata`` of\n              `~.backend_pdf.PdfPages`.\n            - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.\n\n        pil_kwargs : dict, optional\n            Additional keyword arguments that are passed to `PIL.Image.save`\n            when saving the figure.  Only applicable for formats that are saved\n            using Pillow, i.e. JPEG, TIFF, and (if the keyword is set to a\n            non-None value) PNG.\n        \"\"\"\n\n        kwargs.setdefault('dpi', rcParams['savefig.dpi'])\n        if \"frameon\" in kwargs:\n            cbook.warn_deprecated(\"3.1\", name=\"frameon\", obj_type=\"kwarg\",\n                                  alternative=\"facecolor\")\n            frameon = kwargs.pop(\"frameon\")\n            if frameon is None:\n                frameon = dict.__getitem__(rcParams, 'savefig.frameon')\n        else:\n            frameon = False  # Won't pass \"if frameon:\" below.\n        if transparent is None:\n            transparent = rcParams['savefig.transparent']\n\n        if transparent:\n            kwargs.setdefault('facecolor', 'none')\n            kwargs.setdefault('edgecolor', 'none')\n            original_axes_colors = []\n            for ax in self.axes:\n                patch = ax.patch\n                original_axes_colors.append((patch.get_facecolor(),\n                                             patch.get_edgecolor()))\n                patch.set_facecolor('none')\n                patch.set_edgecolor('none')\n        else:\n            kwargs.setdefault('facecolor', rcParams['savefig.facecolor'])\n            kwargs.setdefault('edgecolor', rcParams['savefig.edgecolor'])\n\n        if frameon:\n            original_frameon = self.patch.get_visible()\n            self.patch.set_visible(frameon)\n\n        self.canvas.print_figure(fname, **kwargs)\n\n        if frameon:\n            self.patch.set_visible(original_frameon)\n\n        if transparent:\n            for ax, cc in zip(self.axes, original_axes_colors):\n                ax.patch.set_facecolor(cc[0])\n                ax.patch.set_edgecolor(cc[1])",
        "begin_line": 2063,
        "end_line": 2211,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024096385542168677,
            "pseudo_dstar_susp": 0.002232142857142857,
            "pseudo_tarantula_susp": 0.0005390835579514825,
            "pseudo_op2_susp": 0.002232142857142857,
            "pseudo_barinel_susp": 0.0005390835579514825
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.subplots_adjust#2244",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.subplots_adjust(self, left=None, bottom=None, right=None, top=None, wspace=None, hspace=None)",
        "snippet": "    def subplots_adjust(self, left=None, bottom=None, right=None, top=None,\n                        wspace=None, hspace=None):\n        \"\"\"\n        Update the :class:`SubplotParams` with *kwargs* (defaulting to rc when\n        *None*) and update the subplot locations.\n\n        \"\"\"\n        if self.get_constrained_layout():\n            self.set_constrained_layout(False)\n            cbook._warn_external(\"This figure was using \"\n                                 \"constrained_layout==True, but that is \"\n                                 \"incompatible with subplots_adjust and or \"\n                                 \"tight_layout: setting \"\n                                 \"constrained_layout==False. \")\n        self.subplotpars.update(left, bottom, right, top, wspace, hspace)\n        for ax in self.axes:\n            if not isinstance(ax, SubplotBase):\n                # Check if sharing a subplots axis\n                if isinstance(ax._sharex, SubplotBase):\n                    ax._sharex.update_params()\n                    ax.set_position(ax._sharex.figbox)\n                elif isinstance(ax._sharey, SubplotBase):\n                    ax._sharey.update_params()\n                    ax.set_position(ax._sharey.figbox)\n            else:\n                ax.update_params()\n                ax.set_position(ax.figbox)\n        self.stale = True",
        "begin_line": 2244,
        "end_line": 2271,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00025960539979231567,
            "pseudo_dstar_susp": 0.0002423654871546292,
            "pseudo_tarantula_susp": 0.00029069767441860465,
            "pseudo_op2_susp": 0.0002423654871546292,
            "pseudo_barinel_susp": 0.00029069767441860465
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.get_default_bbox_extra_artists#2346",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.get_default_bbox_extra_artists(self)",
        "snippet": "    def get_default_bbox_extra_artists(self):\n        bbox_artists = [artist for artist in self.get_children()\n                        if (artist.get_visible() and artist.get_in_layout())]\n        for ax in self.axes:\n            if ax.get_visible():\n                bbox_artists.extend(ax.get_default_bbox_extra_artists())\n        return bbox_artists",
        "begin_line": 2346,
        "end_line": 2352,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.get_tightbbox#2354",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.get_tightbbox(self, renderer, bbox_extra_artists=None)",
        "snippet": "    def get_tightbbox(self, renderer, bbox_extra_artists=None):\n        \"\"\"\n        Return a (tight) bounding box of the figure in inches.\n\n        Artists that have ``artist.set_in_layout(False)`` are not included\n        in the bbox.\n\n        Parameters\n        ----------\n        renderer : `.RendererBase` instance\n            renderer that will be used to draw the figures (i.e.\n            ``fig.canvas.get_renderer()``)\n\n        bbox_extra_artists : list of `.Artist` or ``None``\n            List of artists to include in the tight bounding box.  If\n            ``None`` (default), then all artist children of each axes are\n            included in the tight bounding box.\n\n        Returns\n        -------\n        bbox : `.BboxBase`\n            containing the bounding box (in figure inches).\n        \"\"\"\n\n        bb = []\n        if bbox_extra_artists is None:\n            artists = self.get_default_bbox_extra_artists()\n        else:\n            artists = bbox_extra_artists\n\n        for a in artists:\n            bbox = a.get_tightbbox(renderer)\n            if bbox is not None and (bbox.width != 0 or bbox.height != 0):\n                bb.append(bbox)\n\n        for ax in self.axes:\n            if ax.get_visible():\n                # some axes don't take the bbox_extra_artists kwarg so we\n                # need this conditional....\n                try:\n                    bbox = ax.get_tightbbox(renderer,\n                            bbox_extra_artists=bbox_extra_artists)\n                except TypeError:\n                    bbox = ax.get_tightbbox(renderer)\n                bb.append(bbox)\n        bb = [b for b in bb\n              if (np.isfinite(b.width) and np.isfinite(b.height)\n                  and (b.width != 0 or b.height != 0))]\n\n        if len(bb) == 0:\n            return self.bbox_inches\n\n        _bbox = Bbox.union(bb)\n\n        bbox_inches = TransformedBbox(_bbox, Affine2D().scale(1 / self.dpi))\n\n        return bbox_inches",
        "begin_line": 2354,
        "end_line": 2410,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001380071763731714,
            "pseudo_dstar_susp": 0.00013869625520110957,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00013869625520110957,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.init_layoutbox#2412",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.init_layoutbox(self)",
        "snippet": "    def init_layoutbox(self):\n        \"\"\"Initialize the layoutbox for use in constrained_layout.\"\"\"\n        if self._layoutbox is None:\n            self._layoutbox = layoutbox.LayoutBox(parent=None,\n                                     name='figlb',\n                                     artist=self)\n            self._layoutbox.constrain_geometry(0., 0., 1., 1.)",
        "begin_line": 2412,
        "end_line": 2418,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002652519893899204,
            "pseudo_dstar_susp": 0.0002378686964795433,
            "pseudo_tarantula_susp": 0.00033500837520938025,
            "pseudo_op2_susp": 0.0002378686964795433,
            "pseudo_barinel_susp": 0.00033500837520938025
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.execute_constrained_layout#2420",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.execute_constrained_layout(self, renderer=None)",
        "snippet": "    def execute_constrained_layout(self, renderer=None):\n        \"\"\"\n        Use ``layoutbox`` to determine pos positions within axes.\n\n        See also `.set_constrained_layout_pads`.\n        \"\"\"\n\n        from matplotlib._constrained_layout import do_constrained_layout\n\n        _log.debug('Executing constrainedlayout')\n        if self._layoutbox is None:\n            cbook._warn_external(\"Calling figure.constrained_layout, but \"\n                                 \"figure not setup to do constrained layout. \"\n                                 \" You either called GridSpec without the \"\n                                 \"fig keyword, you are using plt.subplot, \"\n                                 \"or you need to call figure or subplots \"\n                                 \"with the constrained_layout=True kwarg.\")\n            return\n        w_pad, h_pad, wspace, hspace = self.get_constrained_layout_pads()\n        # convert to unit-relative lengths\n        fig = self\n        width, height = fig.get_size_inches()\n        w_pad = w_pad / width\n        h_pad = h_pad / height\n        if renderer is None:\n            renderer = layoutbox.get_renderer(fig)\n        do_constrained_layout(fig, renderer, h_pad, w_pad, hspace, wspace)",
        "begin_line": 2420,
        "end_line": 2446,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00026624068157614486,
            "pseudo_dstar_susp": 0.000236630383341221,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.000236630383341221,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.tight_layout#2449",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.tight_layout(self, renderer=None, pad=1.08, h_pad=None, w_pad=None, rect=None)",
        "snippet": "    def tight_layout(self, renderer=None, pad=1.08, h_pad=None, w_pad=None,\n                     rect=None):\n        \"\"\"\n        Automatically adjust subplot parameters to give specified padding.\n\n        To exclude an artist on the axes from the bounding box calculation\n        that determines the subplot parameters (i.e. legend, or annotation),\n        then set `a.set_in_layout(False)` for that artist.\n\n        Parameters\n        ----------\n        renderer : subclass of `~.backend_bases.RendererBase`, optional\n            Defaults to the renderer for the figure.  Deprecated.\n        pad : float, optional\n            Padding between the figure edge and the edges of subplots,\n            as a fraction of the font size.\n        h_pad, w_pad : float, optional\n            Padding (height/width) between edges of adjacent subplots,\n            as a fraction of the font size.  Defaults to *pad*.\n        rect : tuple (left, bottom, right, top), optional\n            A rectangle (left, bottom, right, top) in the normalized\n            figure coordinate that the whole subplots area (including\n            labels) will fit into. Default is (0, 0, 1, 1).\n\n        See Also\n        --------\n        .Figure.set_tight_layout\n        .pyplot.tight_layout\n        \"\"\"\n\n        from .tight_layout import (\n            get_renderer, get_subplotspec_list, get_tight_layout_figure)\n\n        subplotspec_list = get_subplotspec_list(self.axes)\n        if None in subplotspec_list:\n            cbook._warn_external(\"This figure includes Axes that are not \"\n                                 \"compatible with tight_layout, so results \"\n                                 \"might be incorrect.\")\n\n        if renderer is None:\n            renderer = get_renderer(self)\n\n        kwargs = get_tight_layout_figure(\n            self, self.axes, subplotspec_list, renderer,\n            pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)\n        if kwargs:\n            self.subplots_adjust(**kwargs)",
        "begin_line": 2449,
        "end_line": 2495,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021944261575597982,
            "pseudo_dstar_susp": 0.00020777062123415748,
            "pseudo_tarantula_susp": 0.00026322716504343247,
            "pseudo_op2_susp": 0.00020777062123415748,
            "pseudo_barinel_susp": 0.00026322716504343247
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.align_xlabels#2497",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.align_xlabels(self, axs=None)",
        "snippet": "    def align_xlabels(self, axs=None):\n        \"\"\"\n        Align the ylabels of subplots in the same subplot column if label\n        alignment is being done automatically (i.e. the label position is\n        not manually set).\n\n        Alignment persists for draw events after this is called.\n\n        If a label is on the bottom, it is aligned with labels on axes that\n        also have their label on the bottom and that have the same\n        bottom-most subplot row.  If the label is on the top,\n        it is aligned with labels on axes with the same top-most row.\n\n        Parameters\n        ----------\n        axs : list of `~matplotlib.axes.Axes`\n            Optional list of (or ndarray) `~matplotlib.axes.Axes`\n            to align the xlabels.\n            Default is to align all axes on the figure.\n\n        See Also\n        --------\n        matplotlib.figure.Figure.align_ylabels\n\n        matplotlib.figure.Figure.align_labels\n\n        Notes\n        -----\n        This assumes that ``axs`` are from the same `.GridSpec`, so that\n        their `.SubplotSpec` positions correspond to figure positions.\n\n        Examples\n        --------\n        Example with rotated xtick labels::\n\n            fig, axs = plt.subplots(1, 2)\n            for tick in axs[0].get_xticklabels():\n                tick.set_rotation(55)\n            axs[0].set_xlabel('XLabel 0')\n            axs[1].set_xlabel('XLabel 1')\n            fig.align_xlabels()\n\n        \"\"\"\n\n        if axs is None:\n            axs = self.axes\n        axs = np.asarray(axs).ravel()\n        for ax in axs:\n            _log.debug(' Working on: %s', ax.get_xlabel())\n            ss = ax.get_subplotspec()\n            nrows, ncols, row0, row1, col0, col1 = ss.get_rows_columns()\n            labpo = ax.xaxis.get_label_position()  # top or bottom\n\n            # loop through other axes, and search for label positions\n            # that are same as this one, and that share the appropriate\n            # row number.\n            #  Add to a grouper associated with each axes of sibblings.\n            # This list is inspected in `axis.draw` by\n            # `axis._update_label_position`.\n            for axc in axs:\n                if axc.xaxis.get_label_position() == labpo:\n                    ss = axc.get_subplotspec()\n                    nrows, ncols, rowc0, rowc1, colc, col1 = \\\n                            ss.get_rows_columns()\n                    if (labpo == 'bottom' and rowc1 == row1 or\n                        labpo == 'top' and rowc0 == row0):\n                        # grouper for groups of xlabels to align\n                        self._align_xlabel_grp.join(ax, axc)",
        "begin_line": 2497,
        "end_line": 2564,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.align_ylabels#2566",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.align_ylabels(self, axs=None)",
        "snippet": "    def align_ylabels(self, axs=None):\n        \"\"\"\n        Align the ylabels of subplots in the same subplot column if label\n        alignment is being done automatically (i.e. the label position is\n        not manually set).\n\n        Alignment persists for draw events after this is called.\n\n        If a label is on the left, it is aligned with labels on axes that\n        also have their label on the left and that have the same\n        left-most subplot column.  If the label is on the right,\n        it is aligned with labels on axes with the same right-most column.\n\n        Parameters\n        ----------\n        axs : list of `~matplotlib.axes.Axes`\n            Optional list (or ndarray) of `~matplotlib.axes.Axes`\n            to align the ylabels.\n            Default is to align all axes on the figure.\n\n        See Also\n        --------\n        matplotlib.figure.Figure.align_xlabels\n\n        matplotlib.figure.Figure.align_labels\n\n        Notes\n        -----\n        This assumes that ``axs`` are from the same `.GridSpec`, so that\n        their `.SubplotSpec` positions correspond to figure positions.\n\n        Examples\n        --------\n        Example with large yticks labels::\n\n            fig, axs = plt.subplots(2, 1)\n            axs[0].plot(np.arange(0, 1000, 50))\n            axs[0].set_ylabel('YLabel 0')\n            axs[1].set_ylabel('YLabel 1')\n            fig.align_ylabels()\n\n        \"\"\"\n\n        if axs is None:\n            axs = self.axes\n        axs = np.asarray(axs).ravel()\n        for ax in axs:\n            _log.debug(' Working on: %s', ax.get_ylabel())\n            ss = ax.get_subplotspec()\n            nrows, ncols, row0, row1, col0, col1 = ss.get_rows_columns()\n            labpo = ax.yaxis.get_label_position()  # left or right\n            # loop through other axes, and search for label positions\n            # that are same as this one, and that share the appropriate\n            # column number.\n            # Add to a list associated with each axes of sibblings.\n            # This list is inspected in `axis.draw` by\n            # `axis._update_label_position`.\n            for axc in axs:\n                if axc != ax:\n                    if axc.yaxis.get_label_position() == labpo:\n                        ss = axc.get_subplotspec()\n                        nrows, ncols, row0, row1, colc0, colc1 = \\\n                                ss.get_rows_columns()\n                        if (labpo == 'left' and colc0 == col0 or\n                            labpo == 'right' and colc1 == col1):\n                            # grouper for groups of ylabels to align\n                            self._align_ylabel_grp.join(ax, axc)",
        "begin_line": 2566,
        "end_line": 2632,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.align_labels#2634",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.align_labels(self, axs=None)",
        "snippet": "    def align_labels(self, axs=None):\n        \"\"\"\n        Align the xlabels and ylabels of subplots with the same subplots\n        row or column (respectively) if label alignment is being\n        done automatically (i.e. the label position is not manually set).\n\n        Alignment persists for draw events after this is called.\n\n        Parameters\n        ----------\n        axs : list of `~matplotlib.axes.Axes`\n            Optional list (or ndarray) of `~matplotlib.axes.Axes`\n            to align the labels.\n            Default is to align all axes on the figure.\n\n        See Also\n        --------\n        matplotlib.figure.Figure.align_xlabels\n\n        matplotlib.figure.Figure.align_ylabels\n        \"\"\"\n        self.align_xlabels(axs=axs)\n        self.align_ylabels(axs=axs)",
        "begin_line": 2634,
        "end_line": 2656,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.add_gridspec#2658",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.add_gridspec(self, nrows, ncols, **kwargs)",
        "snippet": "    def add_gridspec(self, nrows, ncols, **kwargs):\n        \"\"\"\n        Return a `.GridSpec` that has this figure as a parent.  This allows\n        complex layout of axes in the figure.\n\n        Parameters\n        ----------\n        nrows : int\n            Number of rows in grid.\n\n        ncols : int\n            Number or columns in grid.\n\n        Returns\n        -------\n        gridspec : `.GridSpec`\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Keyword arguments are passed to `.GridSpec`.\n\n        See Also\n        --------\n        matplotlib.pyplot.subplots\n\n        Examples\n        --------\n        Adding a subplot that spans two rows::\n\n            fig = plt.figure()\n            gs = fig.add_gridspec(2, 2)\n            ax1 = fig.add_subplot(gs[0, 0])\n            ax2 = fig.add_subplot(gs[1, 0])\n            # spans two rows:\n            ax3 = fig.add_subplot(gs[:, 1])\n\n        \"\"\"\n\n        _ = kwargs.pop('figure', None)  # pop in case user has added this...\n        gs = GridSpec(nrows=nrows, ncols=ncols, figure=self, **kwargs)\n        self._gridspecs.append(gs)\n        return gs",
        "begin_line": 2658,
        "end_line": 2700,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.figure.figaspect#2703",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure",
        "signature": "lib.matplotlib.figure.figaspect(arg)",
        "snippet": "def figaspect(arg):\n    \"\"\"\n    Calculate the width and height for a figure with a specified aspect ratio.\n\n    While the height is taken from :rc:`figure.figsize`, the width is\n    adjusted to match the desired aspect ratio. Additionally, it is ensured\n    that the width is in the range [4., 16.] and the height is in the range\n    [2., 16.]. If necessary, the default height is adjusted to ensure this.\n\n    Parameters\n    ----------\n    arg : scalar or 2d array\n        If a scalar, this defines the aspect ratio (i.e. the ratio height /\n        width).\n        In case of an array the aspect ratio is number of rows / number of\n        columns, so that the array could be fitted in the figure undistorted.\n\n    Returns\n    -------\n    width, height\n        The figure size in inches.\n\n    Notes\n    -----\n    If you want to create an axes within the figure, that still preserves the\n    aspect ratio, be sure to create it with equal width and height. See\n    examples below.\n\n    Thanks to Fernando Perez for this function.\n\n    Examples\n    --------\n    Make a figure twice as tall as it is wide::\n\n        w, h = figaspect(2.)\n        fig = Figure(figsize=(w, h))\n        ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])\n        ax.imshow(A, **kwargs)\n\n    Make a figure with the proper aspect for an array::\n\n        A = rand(5, 3)\n        w, h = figaspect(A)\n        fig = Figure(figsize=(w, h))\n        ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])\n        ax.imshow(A, **kwargs)\n    \"\"\"\n\n    isarray = hasattr(arg, 'shape') and not np.isscalar(arg)\n\n    # min/max sizes to respect when autoscaling.  If John likes the idea, they\n    # could become rc parameters, for now they're hardwired.\n    figsize_min = np.array((4.0, 2.0))  # min length for width/height\n    figsize_max = np.array((16.0, 16.0))  # max length for width/height\n\n    # Extract the aspect ratio of the array\n    if isarray:\n        nr, nc = arg.shape[:2]\n        arr_ratio = nr / nc\n    else:\n        arr_ratio = arg\n\n    # Height of user figure defaults\n    fig_height = rcParams['figure.figsize'][1]\n\n    # New size for the figure, keeping the aspect ratio of the caller\n    newsize = np.array((fig_height / arr_ratio, fig_height))\n\n    # Sanity checks, don't drop either dimension below figsize_min\n    newsize /= min(1.0, *(newsize / figsize_min))\n\n    # Avoid humongous windows as well\n    newsize /= max(1.0, *(newsize / figsize_max))\n\n    # Finally, if we have a really funky aspect ratio, break it but respect\n    # the min/max dimensions (we don't want figures 10 feet tall!)\n    newsize = np.clip(newsize, figsize_min, figsize_max)\n    return newsize",
        "begin_line": 2703,
        "end_line": 2780,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._subplots.SubplotBase.__init__#18",
        "src_path": "lib/matplotlib/axes/_subplots.py",
        "class_name": "lib.matplotlib.axes._subplots.SubplotBase",
        "signature": "lib.matplotlib.axes._subplots.SubplotBase.__init__(self, fig, *args, **kwargs)",
        "snippet": "    def __init__(self, fig, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        fig : `matplotlib.figure.Figure`\n\n        *args : tuple (*nrows*, *ncols*, *index*) or int\n            The array of subplots in the figure has dimensions ``(nrows,\n            ncols)``, and *index* is the index of the subplot being created.\n            *index* starts at 1 in the upper left corner and increases to the\n            right.\n\n            If *nrows*, *ncols*, and *index* are all single digit numbers, then\n            *args* can be passed as a single 3-digit number (e.g. 234 for\n            (2, 3, 4)).\n        \"\"\"\n\n        self.figure = fig\n\n        if len(args) == 1:\n            if isinstance(args[0], SubplotSpec):\n                self._subplotspec = args[0]\n            else:\n                try:\n                    s = str(int(args[0]))\n                    rows, cols, num = map(int, s)\n                except ValueError:\n                    raise ValueError('Single argument to subplot must be '\n                        'a 3-digit integer')\n                self._subplotspec = GridSpec(rows, cols,\n                                             figure=self.figure)[num - 1]\n                # num - 1 for converting from MATLAB to python indexing\n        elif len(args) == 3:\n            rows, cols, num = args\n            rows = int(rows)\n            cols = int(cols)\n            if rows <= 0:\n                raise ValueError(f'Number of rows must be > 0, not {rows}')\n            if cols <= 0:\n                raise ValueError(f'Number of columns must be > 0, not {cols}')\n            if isinstance(num, tuple) and len(num) == 2:\n                num = [int(n) for n in num]\n                self._subplotspec = GridSpec(\n                        rows, cols,\n                        figure=self.figure)[(num[0] - 1):num[1]]\n            else:\n                if num < 1 or num > rows*cols:\n                    raise ValueError(\n                        f\"num must be 1 <= num <= {rows*cols}, not {num}\")\n                self._subplotspec = GridSpec(\n                        rows, cols, figure=self.figure)[int(num) - 1]\n                # num - 1 for converting from MATLAB to python indexing\n        else:\n            raise ValueError(f'Illegal argument(s) to subplot: {args}')\n\n        self.update_params()\n\n        # _axes_class is set in the subplot_class_factory\n        self._axes_class.__init__(self, fig, self.figbox, **kwargs)\n        # add a layout box to this, for both the full axis, and the poss\n        # of the axis.  We need both because the axes may become smaller\n        # due to parasitic axes and hence no longer fill the subplotspec.\n        if self._subplotspec._layoutbox is None:\n            self._layoutbox = None\n            self._poslayoutbox = None\n        else:\n            name = self._subplotspec._layoutbox.name + '.ax'\n            name = name + layoutbox.seq_id()\n            self._layoutbox = layoutbox.LayoutBox(\n                    parent=self._subplotspec._layoutbox,\n                    name=name,\n                    artist=self)\n            self._poslayoutbox = layoutbox.LayoutBox(\n                    parent=self._layoutbox,\n                    name=self._layoutbox.name+'.pos',\n                    pos=True, subplot=True, artist=self)",
        "begin_line": 18,
        "end_line": 93,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003288391976323578,
            "pseudo_dstar_susp": 0.0003979307600477517,
            "pseudo_tarantula_susp": 0.0001321003963011889,
            "pseudo_op2_susp": 0.0003979307600477517,
            "pseudo_barinel_susp": 0.0001321003963011889
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._ReducedHCT_Element.get_function_derivatives#724",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._ReducedHCT_Element",
        "signature": "lib.matplotlib.tri.triinterpolate._ReducedHCT_Element.get_function_derivatives(self, alpha, J, ecc, dofs)",
        "snippet": "    def get_function_derivatives(self, alpha, J, ecc, dofs):\n        \"\"\"\n        Parameters\n        ----------\n        *alpha* is a (N x 3 x 1) array (array of column-matrices of\n        barycentric coordinates)\n        *J* is a (N x 2 x 2) array of jacobian matrices (jacobian matrix at\n        triangle first apex)\n        *ecc* is a (N x 3 x 1) array (array of column-matrices of triangle\n        eccentricities)\n        *dofs* is a (N x 1 x 9) arrays (arrays of row-matrices) of computed\n        degrees of freedom.\n\n        Returns\n        -------\n        Returns the values of interpolated function derivatives [dz/dx, dz/dy]\n        in global coordinates at locations alpha, as a column-matrices of\n        shape (N x 2 x 1).\n        \"\"\"\n        subtri = np.argmin(alpha, axis=1)[:, 0]\n        ksi = _roll_vectorized(alpha, -subtri, axis=0)\n        E = _roll_vectorized(ecc, -subtri, axis=0)\n        x = ksi[:, 0, 0]\n        y = ksi[:, 1, 0]\n        z = ksi[:, 2, 0]\n        x_sq = x*x\n        y_sq = y*y\n        z_sq = z*z\n        dV = _to_matrix_vectorized([\n            [    -3.*x_sq,     -3.*x_sq],\n            [     3.*y_sq,           0.],\n            [          0.,      3.*z_sq],\n            [     -2.*x*z, -2.*x*z+x_sq],\n            [-2.*x*y+x_sq,      -2.*x*y],\n            [ 2.*x*y-y_sq,        -y_sq],\n            [      2.*y*z,         y_sq],\n            [        z_sq,       2.*y*z],\n            [       -z_sq,  2.*x*z-z_sq],\n            [     x*z-y*z,      x*y-y*z]])\n        # Puts back dV in first apex basis\n        dV = _prod_vectorized(dV, _extract_submatrices(\n            self.rotate_dV, subtri, block_size=2, axis=0))\n\n        prod = _prod_vectorized(self.M, dV)\n        prod += _scalar_vectorized(E[:, 0, 0],\n                                   _prod_vectorized(self.M0, dV))\n        prod += _scalar_vectorized(E[:, 1, 0],\n                                   _prod_vectorized(self.M1, dV))\n        prod += _scalar_vectorized(E[:, 2, 0],\n                                   _prod_vectorized(self.M2, dV))\n        dsdksi = _roll_vectorized(prod, 3*subtri, axis=0)\n        dfdksi = _prod_vectorized(dofs, dsdksi)\n        # In global coordinates:\n        # Here we try to deal with the simplest colinear cases, returning a\n        # null matrix.\n        J_inv = _safe_inv22_vectorized(J)\n        dfdx = _prod_vectorized(J_inv, _transpose_vectorized(dfdksi))\n        return dfdx",
        "begin_line": 724,
        "end_line": 781,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.667764583513912e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._ReducedHCT_Element.get_Hrot_from_J#905",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._ReducedHCT_Element",
        "signature": "lib.matplotlib.tri.triinterpolate._ReducedHCT_Element.get_Hrot_from_J(self, J, return_area=False)",
        "snippet": "    def get_Hrot_from_J(self, J, return_area=False):\n        \"\"\"\n        Parameters\n        ----------\n        *J* is a (N x 2 x 2) array of jacobian matrices (jacobian matrix at\n        triangle first apex)\n\n        Returns\n        -------\n        Returns H_rot used to rotate Hessian from local basis of first apex,\n        to global coordinates.\n        if *return_area* is True, returns also the triangle area (0.5*det(J))\n        \"\"\"\n        # Here we try to deal with the simplest colinear cases; a null\n        # energy and area is imposed.\n        J_inv = _safe_inv22_vectorized(J)\n        Ji00 = J_inv[:, 0, 0]\n        Ji11 = J_inv[:, 1, 1]\n        Ji10 = J_inv[:, 1, 0]\n        Ji01 = J_inv[:, 0, 1]\n        H_rot = _to_matrix_vectorized([\n            [Ji00*Ji00, Ji10*Ji10, Ji00*Ji10],\n            [Ji01*Ji01, Ji11*Ji11, Ji01*Ji11],\n            [2*Ji00*Ji01, 2*Ji11*Ji10, Ji00*Ji11+Ji10*Ji01]])\n        if not return_area:\n            return H_rot\n        else:\n            area = 0.5 * (J[:, 0, 0]*J[:, 1, 1] - J[:, 0, 1]*J[:, 1, 0])\n            return H_rot, area",
        "begin_line": 905,
        "end_line": 933,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.146639511201629e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._ReducedHCT_Element.get_Kff_and_Ff#935",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._ReducedHCT_Element",
        "signature": "lib.matplotlib.tri.triinterpolate._ReducedHCT_Element.get_Kff_and_Ff(self, J, ecc, triangles, Uc)",
        "snippet": "    def get_Kff_and_Ff(self, J, ecc, triangles, Uc):\n        \"\"\"\n        Builds K and F for the following elliptic formulation:\n        minimization of curvature energy with value of function at node\n        imposed and derivatives 'free'.\n        Builds the global Kff matrix in cco format.\n        Builds the full Ff vec Ff = - Kfc x Uc\n\n        Parameters\n        ----------\n        *J* is a (N x 2 x 2) array of jacobian matrices (jacobian matrix at\n        triangle first apex)\n        *ecc* is a (N x 3 x 1) array (array of column-matrices) of triangle\n        eccentricities\n        *triangles* is a (N x 3) array of nodes indexes.\n        *Uc* is (N x 3) array of imposed displacements at nodes\n\n        Returns\n        -------\n        (Kff_rows, Kff_cols, Kff_vals) Kff matrix in coo format - Duplicate\n        (row, col) entries must be summed.\n        Ff: force vector - dim npts * 3\n        \"\"\"\n        ntri = np.size(ecc, 0)\n        vec_range = np.arange(ntri, dtype=np.int32)\n        c_indices = np.full(ntri, -1, dtype=np.int32)  # for unused dofs, -1\n        f_dof = [1, 2, 4, 5, 7, 8]\n        c_dof = [0, 3, 6]\n\n        # vals, rows and cols indices in global dof numbering\n        f_dof_indices = _to_matrix_vectorized([[\n            c_indices, triangles[:, 0]*2, triangles[:, 0]*2+1,\n            c_indices, triangles[:, 1]*2, triangles[:, 1]*2+1,\n            c_indices, triangles[:, 2]*2, triangles[:, 2]*2+1]])\n\n        expand_indices = np.ones([ntri, 9, 1], dtype=np.int32)\n        f_row_indices = _prod_vectorized(_transpose_vectorized(f_dof_indices),\n                                         _transpose_vectorized(expand_indices))\n        f_col_indices = _prod_vectorized(expand_indices, f_dof_indices)\n        K_elem = self.get_bending_matrices(J, ecc)\n\n        # Extracting sub-matrices\n        # Explanation & notations:\n        # * Subscript f denotes 'free' degrees of freedom (i.e. dz/dx, dz/dx)\n        # * Subscript c denotes 'condensated' (imposed) degrees of freedom\n        #    (i.e. z at all nodes)\n        # * F = [Ff, Fc] is the force vector\n        # * U = [Uf, Uc] is the imposed dof vector\n        #        [ Kff Kfc ]\n        # * K =  [         ]  is the laplacian stiffness matrix\n        #        [ Kcf Kff ]\n        # * As F = K x U one gets straightforwardly: Ff = - Kfc x Uc\n\n        # Computing Kff stiffness matrix in sparse coo format\n        Kff_vals = np.ravel(K_elem[np.ix_(vec_range, f_dof, f_dof)])\n        Kff_rows = np.ravel(f_row_indices[np.ix_(vec_range, f_dof, f_dof)])\n        Kff_cols = np.ravel(f_col_indices[np.ix_(vec_range, f_dof, f_dof)])\n\n        # Computing Ff force vector in sparse coo format\n        Kfc_elem = K_elem[np.ix_(vec_range, f_dof, c_dof)]\n        Uc_elem = np.expand_dims(Uc, axis=2)\n        Ff_elem = - _prod_vectorized(Kfc_elem, Uc_elem)[:, :, 0]\n        Ff_indices = f_dof_indices[np.ix_(vec_range, [0], f_dof)][:, 0, :]\n\n        # Extracting Ff force vector in dense format\n        # We have to sum duplicate indices -  using bincount\n        Ff = np.bincount(np.ravel(Ff_indices), weights=np.ravel(Ff_elem))\n        return Kff_rows, Kff_cols, Kff_vals, Ff",
        "begin_line": 935,
        "end_line": 1002,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.146639511201629e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._DOF_estimator.get_dof_vec#1045",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._DOF_estimator",
        "signature": "lib.matplotlib.tri.triinterpolate._DOF_estimator.get_dof_vec(tri_z, tri_dz, J)",
        "snippet": "    def get_dof_vec(tri_z, tri_dz, J):\n        \"\"\"\n        Computes the dof vector of a triangle, knowing the value of f, df and\n        of the local Jacobian at each node.\n\n        *tri_z*: array of shape (3,) of f nodal values\n        *tri_dz*: array of shape (3, 2) of df/dx, df/dy nodal values\n        *J*: Jacobian matrix in local basis of apex 0\n\n        Returns dof array of shape (9,) so that for each apex iapex:\n            dof[iapex*3+0] = f(Ai)\n            dof[iapex*3+1] = df(Ai).(AiAi+)\n            dof[iapex*3+2] = df(Ai).(AiAi-)]\n        \"\"\"\n        npt = tri_z.shape[0]\n        dof = np.zeros([npt, 9], dtype=np.float64)\n        J1 = _prod_vectorized(_ReducedHCT_Element.J0_to_J1, J)\n        J2 = _prod_vectorized(_ReducedHCT_Element.J0_to_J2, J)\n\n        col0 = _prod_vectorized(J, np.expand_dims(tri_dz[:, 0, :], axis=2))\n        col1 = _prod_vectorized(J1, np.expand_dims(tri_dz[:, 1, :], axis=2))\n        col2 = _prod_vectorized(J2, np.expand_dims(tri_dz[:, 2, :], axis=2))\n\n        dfdksi = _to_matrix_vectorized([\n            [col0[:, 0, 0], col1[:, 0, 0], col2[:, 0, 0]],\n            [col0[:, 1, 0], col1[:, 1, 0], col2[:, 1, 0]]])\n        dof[:, 0:7:3] = tri_z\n        dof[:, 1:8:3] = dfdksi[:, 0]\n        dof[:, 2:9:3] = dfdksi[:, 1]\n        return dof",
        "begin_line": 1045,
        "end_line": 1074,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.922674694977024e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._DOF_estimator_geom.compute_dz#1090",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._DOF_estimator_geom",
        "signature": "lib.matplotlib.tri.triinterpolate._DOF_estimator_geom.compute_dz(self)",
        "snippet": "    def compute_dz(self):\n        \"\"\"\n        self.df is computed as weighted average of _triangles sharing a common\n        node. On each triangle itri f is first assumed linear (= ~f), which\n        allows to compute d~f[itri]\n        Then the following approximation of df nodal values is then proposed:\n            f[ipt] = SUM ( w[itri] x d~f[itri] , for itri sharing apex ipt)\n        The weighted coeff. w[itri] are proportional to the angle of the\n        triangle itri at apex ipt\n        \"\"\"\n        el_geom_w = self.compute_geom_weights()\n        el_geom_grad = self.compute_geom_grads()\n\n        # Sum of weights coeffs\n        w_node_sum = np.bincount(np.ravel(self._triangles),\n                                 weights=np.ravel(el_geom_w))\n\n        # Sum of weighted df = (dfx, dfy)\n        dfx_el_w = np.empty_like(el_geom_w)\n        dfy_el_w = np.empty_like(el_geom_w)\n        for iapex in range(3):\n            dfx_el_w[:, iapex] = el_geom_w[:, iapex]*el_geom_grad[:, 0]\n            dfy_el_w[:, iapex] = el_geom_w[:, iapex]*el_geom_grad[:, 1]\n        dfx_node_sum = np.bincount(np.ravel(self._triangles),\n                                   weights=np.ravel(dfx_el_w))\n        dfy_node_sum = np.bincount(np.ravel(self._triangles),\n                                   weights=np.ravel(dfy_el_w))\n\n        # Estimation of df\n        dfx_estim = dfx_node_sum/w_node_sum\n        dfy_estim = dfy_node_sum/w_node_sum\n        return np.vstack([dfx_estim, dfy_estim]).T",
        "begin_line": 1090,
        "end_line": 1121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.03793907242183e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._DOF_estimator_geom.compute_geom_weights#1123",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._DOF_estimator_geom",
        "signature": "lib.matplotlib.tri.triinterpolate._DOF_estimator_geom.compute_geom_weights(self)",
        "snippet": "    def compute_geom_weights(self):\n        \"\"\"\n        Builds the (nelems x 3) weights coeffs of _triangles angles,\n        renormalized so that np.sum(weights, axis=1) == np.ones(nelems)\n        \"\"\"\n        weights = np.zeros([np.size(self._triangles, 0), 3])\n        tris_pts = self._tris_pts\n        for ipt in range(3):\n            p0 = tris_pts[:, (ipt) % 3, :]\n            p1 = tris_pts[:, (ipt+1) % 3, :]\n            p2 = tris_pts[:, (ipt-1) % 3, :]\n            alpha1 = np.arctan2(p1[:, 1]-p0[:, 1], p1[:, 0]-p0[:, 0])\n            alpha2 = np.arctan2(p2[:, 1]-p0[:, 1], p2[:, 0]-p0[:, 0])\n            # In the below formula we could take modulo 2. but\n            # modulo 1. is safer regarding round-off errors (flat triangles).\n            angle = np.abs(((alpha2-alpha1) / np.pi) % 1)\n            # Weight proportional to angle up np.pi/2; null weight for\n            # degenerated cases 0 and np.pi (note that *angle* is normalized\n            # by np.pi).\n            weights[:, ipt] = 0.5 - np.abs(angle-0.5)\n        return weights",
        "begin_line": 1123,
        "end_line": 1143,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.03793907242183e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._DOF_estimator_geom.compute_geom_grads#1145",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._DOF_estimator_geom",
        "signature": "lib.matplotlib.tri.triinterpolate._DOF_estimator_geom.compute_geom_grads(self)",
        "snippet": "    def compute_geom_grads(self):\n        \"\"\"\n        Compute the (global) gradient component of f assumed linear (~f).\n        returns array df of shape (nelems, 2)\n        df[ielem].dM[ielem] = dz[ielem] i.e. df = dz x dM = dM.T^-1 x dz\n        \"\"\"\n        tris_pts = self._tris_pts\n        tris_f = self.z[self._triangles]\n\n        dM1 = tris_pts[:, 1, :] - tris_pts[:, 0, :]\n        dM2 = tris_pts[:, 2, :] - tris_pts[:, 0, :]\n        dM = np.dstack([dM1, dM2])\n        # Here we try to deal with the simplest colinear cases: a null\n        # gradient is assumed in this case.\n        dM_inv = _safe_inv22_vectorized(dM)\n\n        dZ1 = tris_f[:, 1] - tris_f[:, 0]\n        dZ2 = tris_f[:, 2] - tris_f[:, 0]\n        dZ = np.vstack([dZ1, dZ2]).T\n        df = np.empty_like(dZ)\n\n        # With np.einsum :  could be ej,eji -> ej\n        df[:, 0] = dZ[:, 0]*dM_inv[:, 0, 0] + dZ[:, 1]*dM_inv[:, 1, 0]\n        df[:, 1] = dZ[:, 0]*dM_inv[:, 0, 1] + dZ[:, 1]*dM_inv[:, 1, 1]\n        return df",
        "begin_line": 1145,
        "end_line": 1169,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.03793907242183e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._DOF_estimator_min_E.compute_dz#1182",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._DOF_estimator_min_E",
        "signature": "lib.matplotlib.tri.triinterpolate._DOF_estimator_min_E.compute_dz(self)",
        "snippet": "    def compute_dz(self):\n        \"\"\"\n        Elliptic solver for bending energy minimization.\n        Uses a dedicated 'toy' sparse Jacobi PCG solver.\n        \"\"\"\n        # Initial guess for iterative PCG solver.\n        dz_init = _DOF_estimator_geom.compute_dz(self)\n        Uf0 = np.ravel(dz_init)\n\n        reference_element = _ReducedHCT_Element()\n        J = CubicTriInterpolator._get_jacobian(self._tris_pts)\n        eccs = self._eccs\n        triangles = self._triangles\n        Uc = self.z[self._triangles]\n\n        # Building stiffness matrix and force vector in coo format\n        Kff_rows, Kff_cols, Kff_vals, Ff = reference_element.get_Kff_and_Ff(\n            J, eccs, triangles, Uc)\n\n        # Building sparse matrix and solving minimization problem\n        # We could use scipy.sparse direct solver; however to avoid this\n        # external dependency an implementation of a simple PCG solver with\n        # a simple diagonal Jacobi preconditioner is implemented.\n        tol = 1.e-10\n        n_dof = Ff.shape[0]\n        Kff_coo = _Sparse_Matrix_coo(Kff_vals, Kff_rows, Kff_cols,\n                                     shape=(n_dof, n_dof))\n        Kff_coo.compress_csc()\n        Uf, err = _cg(A=Kff_coo, b=Ff, x0=Uf0, tol=tol)\n        # If the PCG did not converge, we return the best guess between Uf0\n        # and Uf.\n        err0 = np.linalg.norm(Kff_coo.dot(Uf0) - Ff)\n        if err0 < err:\n            # Maybe a good occasion to raise a warning here ?\n            cbook._warn_external(\"In TriCubicInterpolator initialization, \"\n                                 \"PCG sparse solver did not converge after \"\n                                 \"1000 iterations. `geom` approximation is \"\n                                 \"used instead of `min_E`\")\n            Uf = Uf0\n\n        # Building dz from Uf\n        dz = np.empty([self._pts.shape[0], 2], dtype=np.float64)\n        dz[:, 0] = Uf[::2]\n        dz[:, 1] = Uf[1::2]\n        return dz",
        "begin_line": 1182,
        "end_line": 1226,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.146639511201629e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo.dot#1246",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo",
        "signature": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo.dot(self, V)",
        "snippet": "    def dot(self, V):\n        \"\"\"\n        Dot product of self by a vector *V* in sparse-dense to dense format\n        *V* dense vector of shape (self.m,)\n        \"\"\"\n        assert V.shape == (self.m,)\n        return np.bincount(self.rows,\n                           weights=self.vals*V[self.cols],\n                           minlength=self.m)",
        "begin_line": 1246,
        "end_line": 1254,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.03793907242183e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo.compress_csc#1256",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo",
        "signature": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo.compress_csc(self)",
        "snippet": "    def compress_csc(self):\n        \"\"\"\n        Compress rows, cols, vals / summing duplicates. Sort for csc format.\n        \"\"\"\n        _, unique, indices = np.unique(\n            self.rows + self.n*self.cols,\n            return_index=True, return_inverse=True)\n        self.rows = self.rows[unique]\n        self.cols = self.cols[unique]\n        self.vals = np.bincount(indices, weights=self.vals)",
        "begin_line": 1256,
        "end_line": 1265,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.03793907242183e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo.to_dense#1278",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo",
        "signature": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo.to_dense(self)",
        "snippet": "    def to_dense(self):\n        \"\"\"\n        Returns a dense matrix representing self.\n        Mainly for debugging purposes.\n        \"\"\"\n        ret = np.zeros([self.n, self.m], dtype=np.float64)\n        nvals = self.vals.size\n        for i in range(nvals):\n            ret[self.rows[i], self.cols[i]] += self.vals[i]\n        return ret",
        "begin_line": 1278,
        "end_line": 1287,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo.diag#1293",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo",
        "signature": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo.diag(self)",
        "snippet": "    def diag(self):\n        \"\"\"\n        Returns the (dense) vector of the diagonal elements.\n        \"\"\"\n        in_diag = (self.rows == self.cols)\n        diag = np.zeros(min(self.n, self.n), dtype=np.float64)  # default 0.\n        diag[self.rows[in_diag]] = self.vals[in_diag]\n        return diag",
        "begin_line": 1293,
        "end_line": 1300,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.03793907242183e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._cg#1303",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate",
        "signature": "lib.matplotlib.tri.triinterpolate._cg(A, b, x0=None, tol=1e-10, maxiter=1000)",
        "snippet": "def _cg(A, b, x0=None, tol=1.e-10, maxiter=1000):\n    \"\"\"\n    Use Preconditioned Conjugate Gradient iteration to solve A x = b\n    A simple Jacobi (diagonal) preconditionner is used.\n\n    Parameters\n    ----------\n    A : _Sparse_Matrix_coo\n        *A* must have been compressed before by compress_csc or\n        compress_csr method.\n\n    b : array\n        Right hand side of the linear system.\n\n    Returns\n    -------\n    x : array\n        The converged solution.\n    err : float\n        The absolute error np.linalg.norm(A.dot(x) - b)\n\n    Other parameters\n    ----------------\n    x0 : array\n        Starting guess for the solution.\n    tol : float\n        Tolerance to achieve. The algorithm terminates when the relative\n        residual is below tol.\n    maxiter : integer\n        Maximum number of iterations. Iteration will stop\n        after maxiter steps even if the specified tolerance has not\n        been achieved.\n    \"\"\"\n    n = b.size\n    assert A.n == n\n    assert A.m == n\n    b_norm = np.linalg.norm(b)\n\n    # Jacobi pre-conditioner\n    kvec = A.diag\n    # For diag elem < 1e-6 we keep 1e-6.\n    kvec = np.maximum(kvec, 1e-6)\n\n    # Initial guess\n    if x0 is None:\n        x = np.zeros(n)\n    else:\n        x = x0\n\n    r = b - A.dot(x)\n    w = r/kvec\n\n    p = np.zeros(n)\n    beta = 0.0\n    rho = np.dot(r, w)\n    k = 0\n\n    # Following C. T. Kelley\n    while (np.sqrt(abs(rho)) > tol*b_norm) and (k < maxiter):\n        p = w + beta*p\n        z = A.dot(p)\n        alpha = rho/np.dot(p, z)\n        r = r - alpha*z\n        w = r/kvec\n        rhoold = rho\n        rho = np.dot(r, w)\n        x = x + alpha*p\n        beta = rho/rhoold\n        #err = np.linalg.norm(A.dot(x) - b) # absolute accuracy - not used\n        k += 1\n    err = np.linalg.norm(A.dot(x) - b)\n    return x, err",
        "begin_line": 1303,
        "end_line": 1374,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.146639511201629e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._safe_inv22_vectorized#1424",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate",
        "signature": "lib.matplotlib.tri.triinterpolate._safe_inv22_vectorized(M)",
        "snippet": "def _safe_inv22_vectorized(M):\n    \"\"\"\n    Inversion of arrays of (2, 2) matrices, returns 0 for rank-deficient\n    matrices.\n\n    *M* : array of (2, 2) matrices to inverse, shape (n, 2, 2)\n    \"\"\"\n    assert M.ndim == 3\n    assert M.shape[-2:] == (2, 2)\n    M_inv = np.empty_like(M)\n    prod1 = M[:, 0, 0]*M[:, 1, 1]\n    delta = prod1 - M[:, 0, 1]*M[:, 1, 0]\n\n    # We set delta_inv to 0. in case of a rank deficient matrix; a\n    # rank-deficient input matrix *M* will lead to a null matrix in output\n    rank2 = (np.abs(delta) > 1e-8*np.abs(prod1))\n    if np.all(rank2):\n        # Normal 'optimized' flow.\n        delta_inv = 1./delta\n    else:\n        # 'Pathologic' flow.\n        delta_inv = np.zeros(M.shape[0])\n        delta_inv[rank2] = 1./delta[rank2]\n\n    M_inv[:, 0, 0] = M[:, 1, 1]*delta_inv\n    M_inv[:, 0, 1] = -M[:, 0, 1]*delta_inv\n    M_inv[:, 1, 0] = -M[:, 1, 0]*delta_inv\n    M_inv[:, 1, 1] = M[:, 0, 0]*delta_inv\n    return M_inv",
        "begin_line": 1424,
        "end_line": 1452,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._pseudo_inv22sym_vectorized#1455",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate",
        "signature": "lib.matplotlib.tri.triinterpolate._pseudo_inv22sym_vectorized(M)",
        "snippet": "def _pseudo_inv22sym_vectorized(M):\n    \"\"\"\n    Inversion of arrays of (2, 2) SYMMETRIC matrices; returns the\n    (Moore-Penrose) pseudo-inverse for rank-deficient matrices.\n\n    In case M is of rank 1, we have M = trace(M) x P where P is the orthogonal\n    projection on Im(M), and we return trace(M)^-1 x P == M / trace(M)**2\n    In case M is of rank 0, we return the null matrix.\n\n    *M* : array of (2, 2) matrices to inverse, shape (n, 2, 2)\n    \"\"\"\n    assert M.ndim == 3\n    assert M.shape[-2:] == (2, 2)\n    M_inv = np.empty_like(M)\n    prod1 = M[:, 0, 0]*M[:, 1, 1]\n    delta = prod1 - M[:, 0, 1]*M[:, 1, 0]\n    rank2 = (np.abs(delta) > 1e-8*np.abs(prod1))\n\n    if np.all(rank2):\n        # Normal 'optimized' flow.\n        M_inv[:, 0, 0] = M[:, 1, 1] / delta\n        M_inv[:, 0, 1] = -M[:, 0, 1] / delta\n        M_inv[:, 1, 0] = -M[:, 1, 0] / delta\n        M_inv[:, 1, 1] = M[:, 0, 0] / delta\n    else:\n        # 'Pathologic' flow.\n        # Here we have to deal with 2 sub-cases\n        # 1) First sub-case: matrices of rank 2:\n        delta = delta[rank2]\n        M_inv[rank2, 0, 0] = M[rank2, 1, 1] / delta\n        M_inv[rank2, 0, 1] = -M[rank2, 0, 1] / delta\n        M_inv[rank2, 1, 0] = -M[rank2, 1, 0] / delta\n        M_inv[rank2, 1, 1] = M[rank2, 0, 0] / delta\n        # 2) Second sub-case: rank-deficient matrices of rank 0 and 1:\n        rank01 = ~rank2\n        tr = M[rank01, 0, 0] + M[rank01, 1, 1]\n        tr_zeros = (np.abs(tr) < 1.e-8)\n        sq_tr_inv = (1.-tr_zeros) / (tr**2+tr_zeros)\n        #sq_tr_inv = 1. / tr**2\n        M_inv[rank01, 0, 0] = M[rank01, 0, 0] * sq_tr_inv\n        M_inv[rank01, 0, 1] = M[rank01, 0, 1] * sq_tr_inv\n        M_inv[rank01, 1, 0] = M[rank01, 1, 0] * sq_tr_inv\n        M_inv[rank01, 1, 1] = M[rank01, 1, 1] * sq_tr_inv\n\n    return M_inv",
        "begin_line": 1455,
        "end_line": 1499,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._prod_vectorized#1502",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate",
        "signature": "lib.matplotlib.tri.triinterpolate._prod_vectorized(M1, M2)",
        "snippet": "def _prod_vectorized(M1, M2):\n    \"\"\"\n    Matrix product between arrays of matrices, or a matrix and an array of\n    matrices (*M1* and *M2*)\n    \"\"\"\n    sh1 = M1.shape\n    sh2 = M2.shape\n    assert len(sh1) >= 2\n    assert len(sh2) >= 2\n    assert sh1[-1] == sh2[-2]\n\n    ndim1 = len(sh1)\n    t1_index = [*range(ndim1-2), ndim1-1, ndim1-2]\n    return np.sum(np.transpose(M1, t1_index)[..., np.newaxis] *\n                  M2[..., np.newaxis, :], -3)",
        "begin_line": 1502,
        "end_line": 1516,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.922674694977024e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._scalar_vectorized#1519",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate",
        "signature": "lib.matplotlib.tri.triinterpolate._scalar_vectorized(scalar, M)",
        "snippet": "def _scalar_vectorized(scalar, M):\n    \"\"\"\n    Scalar product between scalars and matrices.\n    \"\"\"\n    return scalar[:, np.newaxis, np.newaxis]*M",
        "begin_line": 1519,
        "end_line": 1523,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._transpose_vectorized#1526",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate",
        "signature": "lib.matplotlib.tri.triinterpolate._transpose_vectorized(M)",
        "snippet": "def _transpose_vectorized(M):\n    \"\"\"\n    Transposition of an array of matrices *M*.\n    \"\"\"\n    return np.transpose(M, [0, 2, 1])",
        "begin_line": 1526,
        "end_line": 1530,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._roll_vectorized#1533",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate",
        "signature": "lib.matplotlib.tri.triinterpolate._roll_vectorized(M, roll_indices, axis)",
        "snippet": "def _roll_vectorized(M, roll_indices, axis):\n    \"\"\"\n    Rolls an array of matrices along an axis according to an array of indices\n    *roll_indices*\n    *axis* can be either 0 (rolls rows) or 1 (rolls columns).\n    \"\"\"\n    assert axis in [0, 1]\n    ndim = M.ndim\n    assert ndim == 3\n    ndim_roll = roll_indices.ndim\n    assert ndim_roll == 1\n    sh = M.shape\n    r, c = sh[-2:]\n    assert sh[0] == roll_indices.shape[0]\n    vec_indices = np.arange(sh[0], dtype=np.int32)\n\n    # Builds the rolled matrix\n    M_roll = np.empty_like(M)\n    if axis == 0:\n        for ir in range(r):\n            for ic in range(c):\n                M_roll[:, ir, ic] = M[vec_indices, (-roll_indices+ir) % r, ic]\n    elif axis == 1:\n        for ir in range(r):\n            for ic in range(c):\n                M_roll[:, ir, ic] = M[vec_indices, ir, (-roll_indices+ic) % c]\n    return M_roll",
        "begin_line": 1533,
        "end_line": 1559,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._to_matrix_vectorized#1562",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate",
        "signature": "lib.matplotlib.tri.triinterpolate._to_matrix_vectorized(M)",
        "snippet": "def _to_matrix_vectorized(M):\n    \"\"\"\n    Builds an array of matrices from individuals np.arrays of identical\n    shapes.\n    *M*: ncols-list of nrows-lists of shape sh.\n\n    Returns M_res np.array of shape (sh, nrow, ncols) so that:\n        M_res[..., i, j] = M[i][j]\n    \"\"\"\n    assert isinstance(M, (tuple, list))\n    assert all(isinstance(item, (tuple, list)) for item in M)\n    c_vec = np.asarray([len(item) for item in M])\n    assert np.all(c_vec-c_vec[0] == 0)\n    r = len(M)\n    c = c_vec[0]\n    M00 = np.asarray(M[0][0])\n    dt = M00.dtype\n    sh = [M00.shape[0], r, c]\n    M_ret = np.empty(sh, dtype=dt)\n    for irow in range(r):\n        for icol in range(c):\n            M_ret[:, irow, icol] = np.asarray(M[irow][icol])\n    return M_ret",
        "begin_line": 1562,
        "end_line": 1584,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._extract_submatrices#1587",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate",
        "signature": "lib.matplotlib.tri.triinterpolate._extract_submatrices(M, block_indices, block_size, axis)",
        "snippet": "def _extract_submatrices(M, block_indices, block_size, axis):\n    \"\"\"\n    Extracts selected blocks of a matrices *M* depending on parameters\n    *block_indices* and *block_size*.\n\n    Returns the array of extracted matrices *Mres* so that:\n        M_res[...,ir,:] = M[(block_indices*block_size+ir), :]\n    \"\"\"\n    assert block_indices.ndim == 1\n    assert axis in [0, 1]\n\n    r, c = M.shape\n    if axis == 0:\n        sh = [block_indices.shape[0], block_size, c]\n    elif axis == 1:\n        sh = [block_indices.shape[0], r, block_size]\n\n    dt = M.dtype\n    M_res = np.empty(sh, dtype=dt)\n    if axis == 0:\n        for ir in range(block_size):\n            M_res[:, ir, :] = M[(block_indices*block_size+ir), :]\n    elif axis == 1:\n        for ic in range(block_size):\n            M_res[:, :, ic] = M[:, (block_indices*block_size+ic)]\n\n    return M_res",
        "begin_line": 1587,
        "end_line": 1613,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.03793907242183e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.afm._to_float#57",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm",
        "signature": "lib.matplotlib.afm._to_float(x)",
        "snippet": "def _to_float(x):\n    # Some AFM files use \",\" instead of \".\" as decimal separator -- this\n    # shouldn't be ambiguous (unless someone is wicked enough to use \",\" as\n    # thousands separator...).\n    if isinstance(x, bytes):\n        # Encoding doesn't really matter -- if we have codepoints >127 the call\n        # to float() will error anyways.\n        x = x.decode('latin-1')\n    return float(x.replace(',', '.'))",
        "begin_line": 57,
        "end_line": 65,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.228420966016621e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.afm._to_str#68",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm",
        "signature": "lib.matplotlib.afm._to_str(x)",
        "snippet": "def _to_str(x):\n    return x.decode('utf8')",
        "begin_line": 68,
        "end_line": 69,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.08996035919424e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.afm._to_list_of_floats#77",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm",
        "signature": "lib.matplotlib.afm._to_list_of_floats(s)",
        "snippet": "def _to_list_of_floats(s):\n    return [_to_float(val) for val in s.split()]",
        "begin_line": 77,
        "end_line": 78,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.afm._to_bool#81",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm",
        "signature": "lib.matplotlib.afm._to_bool(s)",
        "snippet": "def _to_bool(s):\n    if s.lower().strip() in (b'false', b'0', b'no'):\n        return False\n    else:\n        return True",
        "begin_line": 81,
        "end_line": 85,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.667764583513912e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.afm._parse_header#88",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm",
        "signature": "lib.matplotlib.afm._parse_header(fh)",
        "snippet": "def _parse_header(fh):\n    \"\"\"\n    Reads the font metrics header (up to the char metrics) and returns\n    a dictionary mapping *key* to *val*.  *val* will be converted to the\n    appropriate python type as necessary; e.g.:\n\n        * 'False'->False\n        * '0'->0\n        * '-168 -218 1000 898'-> [-168, -218, 1000, 898]\n\n    Dictionary keys are\n\n      StartFontMetrics, FontName, FullName, FamilyName, Weight,\n      ItalicAngle, IsFixedPitch, FontBBox, UnderlinePosition,\n      UnderlineThickness, Version, Notice, EncodingScheme, CapHeight,\n      XHeight, Ascender, Descender, StartCharMetrics\n\n    \"\"\"\n    header_converters = {\n        b'StartFontMetrics': _to_float,\n        b'FontName': _to_str,\n        b'FullName': _to_str,\n        b'FamilyName': _to_str,\n        b'Weight': _to_str,\n        b'ItalicAngle': _to_float,\n        b'IsFixedPitch': _to_bool,\n        b'FontBBox': _to_list_of_ints,\n        b'UnderlinePosition': _to_float,\n        b'UnderlineThickness': _to_float,\n        b'Version': _to_str,\n        # Some AFM files have non-ASCII characters (which are not allowed by\n        # the spec).  Given that there is actually no public API to even access\n        # this field, just return it as straight bytes.\n        b'Notice': lambda x: x,\n        b'EncodingScheme': _to_str,\n        b'CapHeight': _to_float,  # Is the second version a mistake, or\n        b'Capheight': _to_float,  # do some AFM files contain 'Capheight'? -JKS\n        b'XHeight': _to_float,\n        b'Ascender': _to_float,\n        b'Descender': _to_float,\n        b'StdHW': _to_float,\n        b'StdVW': _to_float,\n        b'StartCharMetrics': _to_int,\n        b'CharacterSet': _to_str,\n        b'Characters': _to_int,\n        }\n\n    d = {}\n    first_line = True\n    for line in fh:\n        line = line.rstrip()\n        if line.startswith(b'Comment'):\n            continue\n        lst = line.split(b' ', 1)\n        key = lst[0]\n        if first_line:\n            # AFM spec, Section 4: The StartFontMetrics keyword\n            # [followed by a version number] must be the first line in\n            # the file, and the EndFontMetrics keyword must be the\n            # last non-empty line in the file.  We just check the\n            # first header entry.\n            if key != b'StartFontMetrics':\n                raise RuntimeError('Not an AFM file')\n            first_line = False\n        if len(lst) == 2:\n            val = lst[1]\n        else:\n            val = b''\n        try:\n            converter = header_converters[key]\n        except KeyError:\n            _log.error('Found an unknown keyword in AFM header (was %r)' % key)\n            continue\n        try:\n            d[key] = converter(val)\n        except ValueError:\n            _log.error('Value error parsing header in AFM: %s, %s', key, val)\n            continue\n        if key == b'StartCharMetrics':\n            break\n    else:\n        raise RuntimeError('Bad parse')\n    return d",
        "begin_line": 88,
        "end_line": 170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.afm._parse_char_metrics#188",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm",
        "signature": "lib.matplotlib.afm._parse_char_metrics(fh)",
        "snippet": "def _parse_char_metrics(fh):\n    \"\"\"\n    Parse the given filehandle for character metrics information and return\n    the information as dicts.\n\n    It is assumed that the file cursor is on the line behind\n    'StartCharMetrics'.\n\n    Returns\n    -------\n    ascii_d : dict\n         A mapping \"ASCII num of the character\" to `.CharMetrics`.\n    name_d : dict\n         A mapping \"character name\" to `.CharMetrics`.\n\n    Notes\n    -----\n    This function is incomplete per the standard, but thus far parses\n    all the sample afm files tried.\n    \"\"\"\n    required_keys = {'C', 'WX', 'N', 'B'}\n\n    ascii_d = {}\n    name_d = {}\n    for line in fh:\n        # We are defensively letting values be utf8. The spec requires\n        # ascii, but there are non-compliant fonts in circulation\n        line = _to_str(line.rstrip())  # Convert from byte-literal\n        if line.startswith('EndCharMetrics'):\n            return ascii_d, name_d\n        # Split the metric line into a dictionary, keyed by metric identifiers\n        vals = dict(s.strip().split(' ', 1) for s in line.split(';') if s)\n        # There may be other metrics present, but only these are needed\n        if not required_keys.issubset(vals):\n            raise RuntimeError('Bad char metrics line: %s' % line)\n        num = _to_int(vals['C'])\n        wx = _to_float(vals['WX'])\n        name = vals['N']\n        bbox = _to_list_of_floats(vals['B'])\n        bbox = list(map(int, bbox))\n        metrics = CharMetrics(wx, name, bbox)\n        # Workaround: If the character name is 'Euro', give it the\n        # corresponding character code, according to WinAnsiEncoding (see PDF\n        # Reference).\n        if name == 'Euro':\n            num = 128\n        elif name == 'minus':\n            num = ord(\"\\N{MINUS SIGN}\")  # 0x2212\n        if num != -1:\n            ascii_d[num] = metrics\n        name_d[name] = metrics\n    raise RuntimeError('Bad parse')",
        "begin_line": 188,
        "end_line": 239,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.afm._parse_optional#328",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm",
        "signature": "lib.matplotlib.afm._parse_optional(fh)",
        "snippet": "def _parse_optional(fh):\n    \"\"\"\n    Parse the optional fields for kern pair data and composites.\n\n    Returns\n    -------\n    kern_data : dict\n        A dict containing kerning information. May be empty.\n        See `._parse_kern_pairs`.\n    composites : dict\n        A dict containing composite information. May be empty.\n        See `._parse_composites`.\n    \"\"\"\n    optional = {\n        b'StartKernData': _parse_kern_pairs,\n        b'StartComposites':  _parse_composites,\n        }\n\n    d = {b'StartKernData': {},\n         b'StartComposites': {}}\n    for line in fh:\n        line = line.rstrip()\n        if not line:\n            continue\n        key = line.split()[0]\n\n        if key in optional:\n            d[key] = optional[key](fh)\n\n    return d[b'StartKernData'], d[b'StartComposites']",
        "begin_line": 328,
        "end_line": 357,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.afm.AFM.__init__#362",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm.AFM",
        "signature": "lib.matplotlib.afm.AFM.__init__(self, fh)",
        "snippet": "    def __init__(self, fh):\n        \"\"\"Parse the AFM file in file object *fh*.\"\"\"\n        self._header = _parse_header(fh)\n        self._metrics, self._metrics_by_name = _parse_char_metrics(fh)\n        self._kern, self._composite = _parse_optional(fh)",
        "begin_line": 362,
        "end_line": 366,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.afm.AFM.get_str_bbox_and_descent#398",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm.AFM",
        "signature": "lib.matplotlib.afm.AFM.get_str_bbox_and_descent(self, s)",
        "snippet": "    def get_str_bbox_and_descent(self, s):\n        \"\"\"Return the string bounding box and the maximal descent.\"\"\"\n        if not len(s):\n            return 0, 0, 0, 0, 0\n        total_width = 0\n        namelast = None\n        miny = 1e9\n        maxy = 0\n        left = 0\n        if not isinstance(s, str):\n            s = _to_str(s)\n        for c in s:\n            if c == '\\n':\n                continue\n            name = uni2type1.get(ord(c), 'question')\n            try:\n                wx, _, bbox = self._metrics_by_name[name]\n            except KeyError:\n                name = 'question'\n                wx, _, bbox = self._metrics_by_name[name]\n            total_width += wx + self._kern.get((namelast, name), 0)\n            l, b, w, h = bbox\n            left = min(left, l)\n            miny = min(miny, b)\n            maxy = max(maxy, b + h)\n\n            namelast = name\n\n        return left, miny, total_width, maxy - miny, -miny",
        "begin_line": 398,
        "end_line": 426,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.afm.AFM.get_fontname#470",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm.AFM",
        "signature": "lib.matplotlib.afm.AFM.get_fontname(self)",
        "snippet": "    def get_fontname(self):\n        \"\"\"Return the font name, e.g., 'Times-Roman'.\"\"\"\n        return self._header[b'FontName']",
        "begin_line": 470,
        "end_line": 472,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.afm.AFM.get_fullname#474",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm.AFM",
        "signature": "lib.matplotlib.afm.AFM.get_fullname(self)",
        "snippet": "    def get_fullname(self):\n        \"\"\"Return the font full name, e.g., 'Times-Roman'.\"\"\"\n        name = self._header.get(b'FullName')\n        if name is None:  # use FontName as a substitute\n            name = self._header[b'FontName']\n        return name",
        "begin_line": 474,
        "end_line": 479,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.afm.AFM.get_familyname#481",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm.AFM",
        "signature": "lib.matplotlib.afm.AFM.get_familyname(self)",
        "snippet": "    def get_familyname(self):\n        \"\"\"Return the font family name, e.g., 'Times'.\"\"\"\n        name = self._header.get(b'FamilyName')\n        if name is not None:\n            return name\n\n        # FamilyName not specified so we'll make a guess\n        name = self.get_fullname()\n        extras = (r'(?i)([ -](regular|plain|italic|oblique|bold|semibold|'\n                  r'light|ultralight|extra|condensed))+$')\n        return re.sub(extras, '', name)",
        "begin_line": 481,
        "end_line": 491,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.afm.AFM.get_weight#498",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm.AFM",
        "signature": "lib.matplotlib.afm.AFM.get_weight(self)",
        "snippet": "    def get_weight(self):\n        \"\"\"Return the font weight, e.g., 'Bold' or 'Roman'.\"\"\"\n        return self._header[b'Weight']",
        "begin_line": 498,
        "end_line": 500,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.afm.AFM.get_angle#502",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm.AFM",
        "signature": "lib.matplotlib.afm.AFM.get_angle(self)",
        "snippet": "    def get_angle(self):\n        \"\"\"Return the fontangle as float.\"\"\"\n        return self._header[b'ItalicAngle']",
        "begin_line": 502,
        "end_line": 504,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.afm.AFM.get_underline_thickness#514",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm.AFM",
        "signature": "lib.matplotlib.afm.AFM.get_underline_thickness(self)",
        "snippet": "    def get_underline_thickness(self):\n        \"\"\"Return the underline thickness as float.\"\"\"\n        return self._header[b'UnderlineThickness']",
        "begin_line": 514,
        "end_line": 516,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.deprecation._generate_deprecation_warning#24",
        "src_path": "lib/matplotlib/cbook/deprecation.py",
        "class_name": "lib.matplotlib.cbook.deprecation",
        "signature": "lib.matplotlib.cbook.deprecation._generate_deprecation_warning(since, message='', name='', alternative='', pending=False, obj_type='', addendum='', *, removal='')",
        "snippet": "def _generate_deprecation_warning(\n        since, message='', name='', alternative='', pending=False, obj_type='',\n        addendum='', *, removal=''):\n    if pending:\n        if removal:\n            raise ValueError(\n                \"A pending deprecation cannot have a scheduled removal\")\n    else:\n        if removal:\n            removal = \"in {}\".format(removal)\n        else:\n            removal = {\"2.2\": \"in 3.1\", \"3.0\": \"in 3.2\", \"3.1\": \"in 3.3\"}.get(\n                since, \"two minor releases later\")\n    if not message:\n        message = (\n            \"\\nThe %(name)s %(obj_type)s\"\n            + (\" will be deprecated in a future version\"\n               if pending else\n               (\" was deprecated in Matplotlib %(since)s\"\n                + (\" and will be removed %(removal)s\"\n                   if removal else\n                   \"\")))\n            + \".\"\n            + (\" Use %(alternative)s instead.\" if alternative else \"\")\n            + (\" %(addendum)s\" if addendum else \"\"))\n    warning_cls = (PendingDeprecationWarning if pending\n                   else MatplotlibDeprecationWarning)\n    return warning_cls(message % dict(\n        func=name, name=name, obj_type=obj_type, since=since, removal=removal,\n        alternative=alternative, addendum=addendum))",
        "begin_line": 24,
        "end_line": 53,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009514747859181732,
            "pseudo_dstar_susp": 0.002044989775051125,
            "pseudo_tarantula_susp": 0.00025484199796126404,
            "pseudo_op2_susp": 0.002044989775051125,
            "pseudo_barinel_susp": 0.00025484199796126404
        }
    },
    {
        "name": "lib.matplotlib.cbook.deprecation.warn_deprecated#56",
        "src_path": "lib/matplotlib/cbook/deprecation.py",
        "class_name": "lib.matplotlib.cbook.deprecation",
        "signature": "lib.matplotlib.cbook.deprecation.warn_deprecated(since, *, message='', name='', alternative='', pending=False, obj_type='', addendum='', removal='')",
        "snippet": "def warn_deprecated(\n        since, *, message='', name='', alternative='', pending=False,\n        obj_type='', addendum='', removal=''):\n    \"\"\"\n    Used to display deprecation in a standard way.\n\n    Parameters\n    ----------\n    since : str\n        The release at which this API became deprecated.\n\n    message : str, optional\n        Override the default deprecation message.  The format\n        specifier `%(name)s` may be used for the name of the function,\n        and `%(alternative)s` may be used in the deprecation message\n        to insert the name of an alternative to the deprecated\n        function.  `%(obj_type)s` may be used to insert a friendly name\n        for the type of object being deprecated.\n\n    name : str, optional\n        The name of the deprecated object.\n\n    alternative : str, optional\n        An alternative API that the user may use in place of the deprecated\n        API.  The deprecation warning will tell the user about this alternative\n        if provided.\n\n    pending : bool, optional\n        If True, uses a PendingDeprecationWarning instead of a\n        DeprecationWarning.  Cannot be used together with *removal*.\n\n    obj_type : str, optional\n        The object type being deprecated.\n\n    addendum : str, optional\n        Additional text appended directly to the final message.\n\n    removal : str, optional\n        The expected removal version.  With the default (an empty string), a\n        removal version is automatically computed from *since*.  Set to other\n        Falsy values to not schedule a removal date.  Cannot be used together\n        with *pending*.\n\n    Examples\n    --------\n    Basic example::\n\n        # To warn of the deprecation of \"matplotlib.name_of_module\"\n        warn_deprecated('1.4.0', name='matplotlib.name_of_module',\n                        obj_type='module')\n    \"\"\"\n    warning = _generate_deprecation_warning(\n        since, message, name, alternative, pending, obj_type, addendum,\n        removal=removal)\n    from . import _warn_external\n    _warn_external(warning)",
        "begin_line": 56,
        "end_line": 111,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011407711613050422,
            "pseudo_dstar_susp": 0.0002092925910422771,
            "pseudo_tarantula_susp": 0.00011405109489051095,
            "pseudo_op2_susp": 0.0002092925910422771,
            "pseudo_barinel_susp": 0.00011405109489051095
        }
    },
    {
        "name": "lib.matplotlib.cbook.deprecation.wrapper#235",
        "src_path": "lib/matplotlib/cbook/deprecation.py",
        "class_name": "lib.matplotlib.cbook.deprecation",
        "signature": "lib.matplotlib.cbook.deprecation.wrapper(*args, **kwargs)",
        "snippet": "        def wrapper(*args, **kwargs):\n            from . import _warn_external\n            _warn_external(warning)\n            return func(*args, **kwargs)",
        "begin_line": 235,
        "end_line": 238,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0058823529411764705,
            "pseudo_dstar_susp": 0.004901960784313725,
            "pseudo_tarantula_susp": 0.00031735956839098697,
            "pseudo_op2_susp": 0.004901960784313725,
            "pseudo_barinel_susp": 0.00031735956839098697
        }
    },
    {
        "name": "lib.matplotlib.cbook.deprecation._rename_parameter#258",
        "src_path": "lib/matplotlib/cbook/deprecation.py",
        "class_name": "lib.matplotlib.cbook.deprecation",
        "signature": "lib.matplotlib.cbook.deprecation._rename_parameter(since, old, new, func=None)",
        "snippet": "def _rename_parameter(since, old, new, func=None):\n    \"\"\"\n    Decorator indicating that parameter *old* of *func* is renamed to *new*.\n\n    The actual implementation of *func* should use *new*, not *old*.  If *old*\n    is passed to *func*, a DeprecationWarning is emitted, and its value is\n    used, even if *new* is also passed by keyword (this is to simplify pyplot\n    wrapper functions, which always pass *new* explicitly to the Axes method).\n    If *new* is also passed but positionally, a TypeError will be raised by the\n    underlying function during argument binding.\n\n    Examples\n    --------\n    ::\n\n        @_rename_parameter(\"3.1\", \"bad_name\", \"good_name\")\n        def func(good_name): ...\n    \"\"\"\n\n    if func is None:\n        return functools.partial(_rename_parameter, since, old, new)\n\n    signature = inspect.signature(func)\n    assert old not in signature.parameters, (\n        f\"Matplotlib internal error: {old!r} cannot be a parameter for \"\n        f\"{func.__name__}()\")\n    assert new in signature.parameters, (\n        f\"Matplotlib internal error: {new!r} must be a parameter for \"\n        f\"{func.__name__}()\")\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        if old in kwargs:\n            warn_deprecated(\n                since, message=f\"The {old!r} parameter of {func.__name__}() \"\n                f\"has been renamed {new!r} since Matplotlib {since}; support \"\n                f\"for the old name will be dropped %(removal)s.\")\n            kwargs[new] = kwargs.pop(old)\n        return func(*args, **kwargs)\n\n    # wrapper() must keep the same documented signature as func(): if we\n    # instead made both *old* and *new* appear in wrapper()'s signature, they\n    # would both show up in the pyplot function for an Axes method as well and\n    # pyplot would explicitly pass both arguments to the Axes method.\n\n    return wrapper",
        "begin_line": 258,
        "end_line": 303,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012301636117603641,
            "pseudo_dstar_susp": 0.0001347164219318335,
            "pseudo_tarantula_susp": 0.00012168410805548795,
            "pseudo_op2_susp": 0.0001347164219318335,
            "pseudo_barinel_susp": 0.00012168410805548795
        }
    },
    {
        "name": "lib.matplotlib.cbook.deprecation.wrapper#289",
        "src_path": "lib/matplotlib/cbook/deprecation.py",
        "class_name": "lib.matplotlib.cbook.deprecation",
        "signature": "lib.matplotlib.cbook.deprecation.wrapper(*args, **kwargs)",
        "snippet": "    def wrapper(*args, **kwargs):\n        if old in kwargs:\n            warn_deprecated(\n                since, message=f\"The {old!r} parameter of {func.__name__}() \"\n                f\"has been renamed {new!r} since Matplotlib {since}; support \"\n                f\"for the old name will be dropped %(removal)s.\")\n            kwargs[new] = kwargs.pop(old)\n        return func(*args, **kwargs)",
        "begin_line": 289,
        "end_line": 296,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0058823529411764705,
            "pseudo_dstar_susp": 0.004901960784313725,
            "pseudo_tarantula_susp": 0.00031735956839098697,
            "pseudo_op2_susp": 0.004901960784313725,
            "pseudo_barinel_susp": 0.00031735956839098697
        }
    },
    {
        "name": "lib.matplotlib.cbook.deprecation._delete_parameter#314",
        "src_path": "lib/matplotlib/cbook/deprecation.py",
        "class_name": "lib.matplotlib.cbook.deprecation",
        "signature": "lib.matplotlib.cbook.deprecation._delete_parameter(since, name, func=None)",
        "snippet": "def _delete_parameter(since, name, func=None):\n    \"\"\"\n    Decorator indicating that parameter *name* of *func* is being deprecated.\n\n    The actual implementation of *func* should keep the *name* parameter in its\n    signature.\n\n    Parameters that come after the deprecated parameter effectively become\n    keyword-only (as they cannot be passed positionally without triggering the\n    DeprecationWarning on the deprecated parameter), and should be marked as\n    such after the deprecation period has passed and the deprecated parameter\n    is removed.\n\n    Examples\n    --------\n    ::\n\n        @_delete_parameter(\"3.1\", \"unused\")\n        def func(used_arg, other_arg, unused, more_args): ...\n    \"\"\"\n\n    if func is None:\n        return functools.partial(_delete_parameter, since, name)\n\n    signature = inspect.signature(func)\n    assert name in signature.parameters, (\n        f\"Matplotlib internal error: {name!r} must be a parameter for \"\n        f\"{func.__name__}()\")\n    func.__signature__ = signature.replace(parameters=[\n        param.replace(default=_deprecated_parameter) if param.name == name\n        else param\n        for param in signature.parameters.values()])\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        arguments = func.__signature__.bind(*args, **kwargs).arguments\n        # We cannot just check `name not in arguments` because the pyplot\n        # wrappers always pass all arguments explicitly.\n        if name in arguments and arguments[name] != _deprecated_parameter:\n            warn_deprecated(\n                since, message=f\"The {name!r} parameter of {func.__name__}() \"\n                f\"is deprecated since Matplotlib {since} and will be removed \"\n                f\"%(removal)s.  If any parameter follows {name!r}, they \"\n                f\"should be pass as keyword, not positionally.\")\n        return func(*args, **kwargs)\n\n    return wrapper",
        "begin_line": 314,
        "end_line": 360,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013964530093562352,
            "pseudo_dstar_susp": 0.00015830299192654741,
            "pseudo_tarantula_susp": 0.00014764506127270044,
            "pseudo_op2_susp": 0.00015830299192654741,
            "pseudo_barinel_susp": 0.00014762326542663124
        }
    },
    {
        "name": "lib.matplotlib.cbook.deprecation.wrapper#348",
        "src_path": "lib/matplotlib/cbook/deprecation.py",
        "class_name": "lib.matplotlib.cbook.deprecation",
        "signature": "lib.matplotlib.cbook.deprecation.wrapper(*args, **kwargs)",
        "snippet": "    def wrapper(*args, **kwargs):\n        arguments = func.__signature__.bind(*args, **kwargs).arguments\n        # We cannot just check `name not in arguments` because the pyplot\n        # wrappers always pass all arguments explicitly.\n        if name in arguments and arguments[name] != _deprecated_parameter:\n            warn_deprecated(\n                since, message=f\"The {name!r} parameter of {func.__name__}() \"\n                f\"is deprecated since Matplotlib {since} and will be removed \"\n                f\"%(removal)s.  If any parameter follows {name!r}, they \"\n                f\"should be pass as keyword, not positionally.\")\n        return func(*args, **kwargs)",
        "begin_line": 348,
        "end_line": 358,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0058823529411764705,
            "pseudo_dstar_susp": 0.004901960784313725,
            "pseudo_tarantula_susp": 0.00031735956839098697,
            "pseudo_op2_susp": 0.004901960784313725,
            "pseudo_barinel_susp": 0.00031735956839098697
        }
    },
    {
        "name": "lib.matplotlib.cbook.deprecation._make_keyword_only#363",
        "src_path": "lib/matplotlib/cbook/deprecation.py",
        "class_name": "lib.matplotlib.cbook.deprecation",
        "signature": "lib.matplotlib.cbook.deprecation._make_keyword_only(since, name, func=None)",
        "snippet": "def _make_keyword_only(since, name, func=None):\n    \"\"\"\n    Decorator indicating that passing parameter *name* (or any of the following\n    ones) positionally to *func* is being deprecated.\n\n    Note that this decorator **cannot** be applied to a function that has a\n    pyplot-level wrapper, as the wrapper always pass all arguments by keyword.\n    If it is used, users will see spurious DeprecationWarnings every time they\n    call the pyplot wrapper.\n    \"\"\"\n\n    if func is None:\n        return functools.partial(_make_keyword_only, since, name)\n\n    signature = inspect.signature(func)\n    POK = inspect.Parameter.POSITIONAL_OR_KEYWORD\n    KWO = inspect.Parameter.KEYWORD_ONLY\n    assert (name in signature.parameters\n            and signature.parameters[name].kind == POK), (\n        f\"Matplotlib internal error: {name!r} must be a positional-or-keyword \"\n        f\"parameter for {func.__name__}()\")\n    names = [*signature.parameters]\n    kwonly = [name for name in names[names.index(name):]\n              if signature.parameters[name].kind == POK]\n    func.__signature__ = signature.replace(parameters=[\n        param.replace(kind=KWO) if param.name in kwonly else param\n        for param in signature.parameters.values()])\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        bound = signature.bind(*args, **kwargs)\n        if name in bound.arguments and name not in kwargs:\n            warn_deprecated(\n                since, message=\"Passing the %(name)s %(obj_type)s \"\n                \"positionally is deprecated since Matplotlib %(since)s; the \"\n                \"parameter will become keyword-only %(removal)s.\",\n                name=name, obj_type=f\"parameter of {func.__name__}()\")\n        return func(*args, **kwargs)\n\n    return wrapper",
        "begin_line": 363,
        "end_line": 402,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.deprecation.wrapper#392",
        "src_path": "lib/matplotlib/cbook/deprecation.py",
        "class_name": "lib.matplotlib.cbook.deprecation",
        "signature": "lib.matplotlib.cbook.deprecation.wrapper(*args, **kwargs)",
        "snippet": "    def wrapper(*args, **kwargs):\n        bound = signature.bind(*args, **kwargs)\n        if name in bound.arguments and name not in kwargs:\n            warn_deprecated(\n                since, message=\"Passing the %(name)s %(obj_type)s \"\n                \"positionally is deprecated since Matplotlib %(since)s; the \"\n                \"parameter will become keyword-only %(removal)s.\",\n                name=name, obj_type=f\"parameter of {func.__name__}()\")\n        return func(*args, **kwargs)",
        "begin_line": 392,
        "end_line": 400,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0058823529411764705,
            "pseudo_dstar_susp": 0.004901960784313725,
            "pseudo_tarantula_susp": 0.00031735956839098697,
            "pseudo_op2_susp": 0.004901960784313725,
            "pseudo_barinel_susp": 0.00031735956839098697
        }
    },
    {
        "name": "lib.matplotlib.cbook.deprecation._suppress_matplotlib_deprecation_warning#406",
        "src_path": "lib/matplotlib/cbook/deprecation.py",
        "class_name": "lib.matplotlib.cbook.deprecation",
        "signature": "lib.matplotlib.cbook.deprecation._suppress_matplotlib_deprecation_warning()",
        "snippet": "def _suppress_matplotlib_deprecation_warning():\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\", MatplotlibDeprecationWarning)\n        yield",
        "begin_line": 406,
        "end_line": 409,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011323745895142112,
            "pseudo_dstar_susp": 0.00017546938059308652,
            "pseudo_tarantula_susp": 0.00011319900384876613,
            "pseudo_op2_susp": 0.00017546938059308652,
            "pseudo_barinel_susp": 0.00011319900384876613
        }
    },
    {
        "name": "lib.matplotlib.colors._sanitize_extrema#113",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors",
        "signature": "lib.matplotlib.colors._sanitize_extrema(ex)",
        "snippet": "def _sanitize_extrema(ex):\n    if ex is None:\n        return ex\n    try:\n        ret = ex.item()\n    except AttributeError:\n        ret = float(ex)\n    return ret",
        "begin_line": 113,
        "end_line": 120,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015586034912718204,
            "pseudo_dstar_susp": 0.00018201674554058973,
            "pseudo_tarantula_susp": 0.0001312163758037003,
            "pseudo_op2_susp": 0.00018201674554058973,
            "pseudo_barinel_susp": 0.0001312163758037003
        }
    },
    {
        "name": "lib.matplotlib.colors.is_color_like#128",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors",
        "signature": "lib.matplotlib.colors.is_color_like(c)",
        "snippet": "def is_color_like(c):\n    \"\"\"Return whether *c* can be interpreted as an RGB(A) color.\"\"\"\n    # Special-case nth color syntax because it cannot be parsed during setup.\n    if _is_nth_color(c):\n        return True\n    try:\n        to_rgba(c)\n    except ValueError:\n        return False\n    else:\n        return True",
        "begin_line": 128,
        "end_line": 138,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011446886446886447,
            "pseudo_dstar_susp": 0.00021829294913774285,
            "pseudo_tarantula_susp": 0.00011420740063956144,
            "pseudo_op2_susp": 0.00021829294913774285,
            "pseudo_barinel_susp": 0.00011420740063956144
        }
    },
    {
        "name": "lib.matplotlib.colors.to_rgba#157",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors",
        "signature": "lib.matplotlib.colors.to_rgba(c, alpha=None)",
        "snippet": "def to_rgba(c, alpha=None):\n    \"\"\"\n    Convert *c* to an RGBA color.\n\n    Parameters\n    ----------\n    c : Matplotlib color or ``np.ma.masked``\n\n    alpha : scalar, optional\n        If *alpha* is not ``None``, it forces the alpha value, except if *c* is\n        ``\"none\"`` (case-insensitive), which always maps to ``(0, 0, 0, 0)``.\n\n    Returns\n    -------\n    tuple\n        Tuple of ``(r, g, b, a)`` scalars.\n    \"\"\"\n    # Special-case nth color syntax because it should not be cached.\n    if _is_nth_color(c):\n        from matplotlib import rcParams\n        prop_cycler = rcParams['axes.prop_cycle']\n        colors = prop_cycler.by_key().get('color', ['k'])\n        c = colors[int(c[1:]) % len(colors)]\n    try:\n        rgba = _colors_full_map.cache[c, alpha]\n    except (KeyError, TypeError):  # Not in cache, or unhashable.\n        rgba = None\n    if rgba is None:  # Suppress exception chaining of cache lookup failure.\n        rgba = _to_rgba_no_colorcycle(c, alpha)\n        try:\n            _colors_full_map.cache[c, alpha] = rgba\n        except TypeError:\n            pass\n    return rgba",
        "begin_line": 157,
        "end_line": 190,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011435105774728416,
            "pseudo_dstar_susp": 0.0002149151085321298,
            "pseudo_tarantula_susp": 0.00011419435879867534,
            "pseudo_op2_susp": 0.0002149151085321298,
            "pseudo_barinel_susp": 0.00011419435879867534
        }
    },
    {
        "name": "lib.matplotlib.colors._to_rgba_no_colorcycle#193",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors",
        "signature": "lib.matplotlib.colors._to_rgba_no_colorcycle(c, alpha=None)",
        "snippet": "def _to_rgba_no_colorcycle(c, alpha=None):\n    \"\"\"Convert *c* to an RGBA color, with no support for color-cycle syntax.\n\n    If *alpha* is not ``None``, it forces the alpha value, except if *c* is\n    ``\"none\"`` (case-insensitive), which always maps to ``(0, 0, 0, 0)``.\n    \"\"\"\n    orig_c = c\n    if c is np.ma.masked:\n        return (0., 0., 0., 0.)\n    if isinstance(c, str):\n        if c.lower() == \"none\":\n            return (0., 0., 0., 0.)\n        # Named color.\n        try:\n            # This may turn c into a non-string, so we check again below.\n            c = _colors_full_map[c]\n        except KeyError:\n            try:\n                c = _colors_full_map[c.lower()]\n            except KeyError:\n                pass\n            else:\n                if len(orig_c) == 1:\n                    cbook.warn_deprecated(\n                        \"3.1\", message=\"Support for uppercase \"\n                        \"single-letter colors is deprecated since Matplotlib \"\n                        \"%(since)s and will be removed %(removal)s; please \"\n                        \"use lowercase instead.\")\n    if isinstance(c, str):\n        # hex color in #rrggbb format.\n        match = re.match(r\"\\A#[a-fA-F0-9]{6}\\Z\", c)\n        if match:\n            return (tuple(int(n, 16) / 255\n                          for n in [c[1:3], c[3:5], c[5:7]])\n                    + (alpha if alpha is not None else 1.,))\n        # hex color in #rgb format, shorthand for #rrggbb.\n        match = re.match(r\"\\A#[a-fA-F0-9]{3}\\Z\", c)\n        if match:\n            return (tuple(int(n, 16) / 255\n                          for n in [c[1]*2, c[2]*2, c[3]*2])\n                    + (alpha if alpha is not None else 1.,))\n        # hex color with alpha in #rrggbbaa format.\n        match = re.match(r\"\\A#[a-fA-F0-9]{8}\\Z\", c)\n        if match:\n            color = [int(n, 16) / 255\n                     for n in [c[1:3], c[3:5], c[5:7], c[7:9]]]\n            if alpha is not None:\n                color[-1] = alpha\n            return tuple(color)\n        # hex color with alpha in #rgba format, shorthand for #rrggbbaa.\n        match = re.match(r\"\\A#[a-fA-F0-9]{4}\\Z\", c)\n        if match:\n            color = [int(n, 16) / 255\n                     for n in [c[1]*2, c[2]*2, c[3]*2, c[4]*2]]\n            if alpha is not None:\n                color[-1] = alpha\n            return tuple(color)\n        # string gray.\n        try:\n            c = float(c)\n        except ValueError:\n            pass\n        else:\n            if not (0 <= c <= 1):\n                raise ValueError(\n                    f\"Invalid string grayscale value {orig_c!r}. \"\n                    f\"Value must be within 0-1 range\")\n            return c, c, c, alpha if alpha is not None else 1.\n        raise ValueError(f\"Invalid RGBA argument: {orig_c!r}\")\n    # tuple color.\n    c = np.array(c)\n    if not np.can_cast(c.dtype, float, \"same_kind\") or c.ndim != 1:\n        # Test the dtype explicitly as `map(float, ...)`, `np.array(...,\n        # float)` and `np.array(...).astype(float)` all convert \"0.5\" to 0.5.\n        # Test dimensionality to reject single floats.\n        raise ValueError(f\"Invalid RGBA argument: {orig_c!r}\")\n    # Return a tuple to prevent the cached value from being modified.\n    c = tuple(c.astype(float))\n    if len(c) not in [3, 4]:\n        raise ValueError(\"RGBA sequence should have length 3 or 4\")\n    if len(c) == 3 and alpha is None:\n        alpha = 1\n    if alpha is not None:\n        c = c[:3] + (alpha,)\n    if any(elem < 0 or elem > 1 for elem in c):\n        raise ValueError(\"RGBA values should be within 0-1 range\")\n    return c",
        "begin_line": 193,
        "end_line": 279,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016315875346712352,
            "pseudo_dstar_susp": 0.00015213753232922562,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00015213753232922562,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.colors.to_rgba_array#282",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors",
        "signature": "lib.matplotlib.colors.to_rgba_array(c, alpha=None)",
        "snippet": "def to_rgba_array(c, alpha=None):\n    \"\"\"Convert *c* to a (n, 4) array of RGBA colors.\n\n    If *alpha* is not ``None``, it forces the alpha value.  If *c* is\n    ``\"none\"`` (case-insensitive) or an empty list, an empty array is returned.\n    If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)\n    row for each masked value or row in *c*.\n    \"\"\"\n    # Special-case inputs that are already arrays, for performance.  (If the\n    # array has the wrong kind or shape, raise the error during one-at-a-time\n    # conversion.)\n    if (isinstance(c, np.ndarray) and c.dtype.kind in \"if\"\n            and c.ndim == 2 and c.shape[1] in [3, 4]):\n        mask = c.mask.any(axis=1) if np.ma.is_masked(c) else None\n        c = np.ma.getdata(c)\n        if c.shape[1] == 3:\n            result = np.column_stack([c, np.zeros(len(c))])\n            result[:, -1] = alpha if alpha is not None else 1.\n        elif c.shape[1] == 4:\n            result = c.copy()\n            if alpha is not None:\n                result[:, -1] = alpha\n        if mask is not None:\n            result[mask] = 0\n        if np.any((result < 0) | (result > 1)):\n            raise ValueError(\"RGBA values should be within 0-1 range\")\n        return result\n    # Handle single values.\n    # Note that this occurs *after* handling inputs that are already arrays, as\n    # `to_rgba(c, alpha)` (below) is expensive for such inputs, due to the need\n    # to format the array in the ValueError message(!).\n    if cbook._str_lower_equal(c, \"none\"):\n        return np.zeros((0, 4), float)\n    try:\n        return np.array([to_rgba(c, alpha)], float)\n    except (ValueError, TypeError):\n        pass\n\n    # Convert one at a time.\n    if isinstance(c, str):\n        # Single string as color sequence.\n        # This is deprecated and will be removed in the future.\n        try:\n            result = np.array([to_rgba(cc, alpha) for cc in c])\n        except ValueError:\n            raise ValueError(\n                \"'%s' is neither a valid single color nor a color sequence \"\n                \"consisting of single character color specifiers such as \"\n                \"'rgb'. Note also that the latter is deprecated.\" % c)\n        else:\n            cbook.warn_deprecated(\"3.2\", message=\"Using a string of single \"\n                                  \"character colors as a color sequence is \"\n                                  \"deprecated. Use an explicit list instead.\")\n            return result\n\n    if len(c) == 0:\n        return np.zeros((0, 4), float)\n    else:\n        return np.array([to_rgba(cc, alpha) for cc in c])",
        "begin_line": 282,
        "end_line": 340,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colors.Colormap.__init__#506",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.Colormap",
        "signature": "lib.matplotlib.colors.Colormap.__init__(self, name, N=256)",
        "snippet": "    def __init__(self, name, N=256):\n        \"\"\"\n        Parameters\n        ----------\n        name : str\n            The name of the colormap.\n        N : int\n            The number of rgb quantization levels.\n\n        \"\"\"\n        self.name = name\n        self.N = int(N)  # ensure that N is always int\n        self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n        self._rgba_under = None\n        self._rgba_over = None\n        self._i_under = self.N\n        self._i_over = self.N + 1\n        self._i_bad = self.N + 2\n        self._isinit = False\n\n        #: When this colormap exists on a scalar mappable and colorbar_extend\n        #: is not False, colorbar creation will pick up ``colorbar_extend`` as\n        #: the default value for the ``extend`` keyword in the\n        #: :class:`matplotlib.colorbar.Colorbar` constructor.\n        self.colorbar_extend = False",
        "begin_line": 506,
        "end_line": 530,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011511453896627144,
            "pseudo_dstar_susp": 0.00014814814814814815,
            "pseudo_tarantula_susp": 0.00011452130096197893,
            "pseudo_op2_susp": 0.00014814814814814815,
            "pseudo_barinel_susp": 0.00011452130096197893
        }
    },
    {
        "name": "lib.matplotlib.colors.Colormap.__call__#532",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.Colormap",
        "signature": "lib.matplotlib.colors.Colormap.__call__(self, X, alpha=None, bytes=False)",
        "snippet": "    def __call__(self, X, alpha=None, bytes=False):\n        \"\"\"\n        Parameters\n        ----------\n        X : scalar, ndarray\n            The data value(s) to convert to RGBA.\n            For floats, X should be in the interval ``[0.0, 1.0]`` to\n            return the RGBA values ``X*100`` percent along the Colormap line.\n            For integers, X should be in the interval ``[0, Colormap.N)`` to\n            return RGBA values *indexed* from the Colormap with index ``X``.\n        alpha : float, None\n            Alpha must be a scalar between 0 and 1, or None.\n        bytes : bool\n            If False (default), the returned RGBA values will be floats in the\n            interval ``[0, 1]`` otherwise they will be uint8s in the interval\n            ``[0, 255]``.\n\n        Returns\n        -------\n        Tuple of RGBA values if X is scalar, otherwise an array of\n        RGBA values with a shape of ``X.shape + (4, )``.\n\n        \"\"\"\n        # See class docstring for arg/kwarg documentation.\n        if not self._isinit:\n            self._init()\n        mask_bad = None\n        if np.ma.is_masked(X):\n            mask_bad = X.mask\n        elif np.any(np.isnan(X)):\n            # mask nan's\n            mask_bad = np.isnan(X)\n\n        xa = np.array(X, copy=True)\n        # Fill bad values to avoid warnings\n        # in the boolean comparisons below.\n        if mask_bad is not None:\n            xa[mask_bad] = 0.\n\n        # Calculations with native byteorder are faster, and avoid a\n        # bug that otherwise can occur with putmask when the last\n        # argument is a numpy scalar.\n        if not xa.dtype.isnative:\n            xa = xa.byteswap().newbyteorder()\n\n        if xa.dtype.kind == \"f\":\n            xa *= self.N\n            # Negative values are out of range, but astype(int) would truncate\n            # them towards zero.\n            xa[xa < 0] = -1\n            # xa == 1 (== N after multiplication) is not out of range.\n            xa[xa == self.N] = self.N - 1\n            # Avoid converting large positive values to negative integers.\n            np.clip(xa, -1, self.N, out=xa)\n            xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        xa[xa > self.N - 1] = self._i_over\n        xa[xa < 0] = self._i_under\n        if mask_bad is not None:\n            xa[mask_bad] = self._i_bad\n\n        if bytes:\n            lut = (self._lut * 255).astype(np.uint8)\n        else:\n            lut = self._lut.copy()  # Don't let alpha modify original _lut.\n\n        if alpha is not None:\n            alpha = np.clip(alpha, 0, 1)\n            if bytes:\n                alpha = int(alpha * 255)\n            if (lut[-1] == 0).all():\n                lut[:-1, -1] = alpha\n                # All zeros is taken as a flag for the default bad\n                # color, which is no color--fully transparent.  We\n                # don't want to override this.\n            else:\n                lut[:, -1] = alpha\n                # If the bad value is set to have a color, then we\n                # override its alpha just as for any other value.\n\n        rgba = lut.take(xa, axis=0, mode='clip')\n        if not np.iterable(X):\n            # Return a tuple if the input was a scalar\n            rgba = tuple(rgba)\n        return rgba",
        "begin_line": 532,
        "end_line": 617,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016350555918901244,
            "pseudo_dstar_susp": 0.00018487705675725643,
            "pseudo_tarantula_susp": 0.00016307893020221786,
            "pseudo_op2_susp": 0.00018487705675725643,
            "pseudo_barinel_susp": 0.00016307893020221786
        }
    },
    {
        "name": "lib.matplotlib.colors.Colormap.__copy__#619",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.Colormap",
        "signature": "lib.matplotlib.colors.Colormap.__copy__(self)",
        "snippet": "    def __copy__(self):\n        \"\"\"Create new object with the same class, update attributes\n        \"\"\"\n        cls = self.__class__\n        cmapobject = cls.__new__(cls)\n        cmapobject.__dict__.update(self.__dict__)\n        if self._isinit:\n            cmapobject._lut = np.copy(self._lut)\n        return cmapobject",
        "begin_line": 619,
        "end_line": 627,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colors.Normalize.__init__#944",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.Normalize",
        "signature": "lib.matplotlib.colors.Normalize.__init__(self, vmin=None, vmax=None, clip=False)",
        "snippet": "    def __init__(self, vmin=None, vmax=None, clip=False):\n        \"\"\"\n        If *vmin* or *vmax* is not given, they are initialized from the\n        minimum and maximum value respectively of the first input\n        processed.  That is, *__call__(A)* calls *autoscale_None(A)*.\n        If *clip* is *True* and the given value falls outside the range,\n        the returned value will be 0 or 1, whichever is closer.\n        Returns 0 if ::\n\n            vmin==vmax\n\n        Works with scalars or arrays, including masked arrays.  If\n        *clip* is *True*, masked values are set to 1; otherwise they\n        remain masked.  Clipping silently defeats the purpose of setting\n        the over, under, and masked colors in the colormap, so it is\n        likely to lead to surprises; therefore the default is\n        *clip* = *False*.\n        \"\"\"\n        self.vmin = _sanitize_extrema(vmin)\n        self.vmax = _sanitize_extrema(vmax)\n        self.clip = clip",
        "begin_line": 944,
        "end_line": 964,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00013477088948787063,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00013477088948787063,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.colors.Normalize.process_value#967",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.Normalize",
        "signature": "lib.matplotlib.colors.Normalize.process_value(value)",
        "snippet": "    def process_value(value):\n        \"\"\"\n        Homogenize the input *value* for easy and efficient normalization.\n\n        *value* can be a scalar or sequence.\n\n        Returns *result*, *is_scalar*, where *result* is a\n        masked array matching *value*.  Float dtypes are preserved;\n        integer types with two bytes or smaller are converted to\n        np.float32, and larger types are converted to np.float64.\n        Preserving float32 when possible, and using in-place operations,\n        can greatly improve speed for large arrays.\n\n        Experimental; we may want to add an option to force the\n        use of float32.\n        \"\"\"\n        is_scalar = not np.iterable(value)\n        if is_scalar:\n            value = [value]\n        dtype = np.min_scalar_type(value)\n        if np.issubdtype(dtype, np.integer) or dtype.type is np.bool_:\n            # bool_/int8/int16 -> float32; int32/int64 -> float64\n            dtype = np.promote_types(dtype, np.float32)\n        # ensure data passed in as an ndarray subclass are interpreted as\n        # an ndarray. See issue #6622.\n        mask = np.ma.getmask(value)\n        data = np.asarray(value)\n        result = np.ma.array(data, mask=mask, dtype=dtype, copy=True)\n        return result, is_scalar",
        "begin_line": 967,
        "end_line": 995,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022232103156958648,
            "pseudo_dstar_susp": 0.0002789400278940028,
            "pseudo_tarantula_susp": 0.00017777777777777779,
            "pseudo_op2_susp": 0.0002789400278940028,
            "pseudo_barinel_susp": 0.00017777777777777779
        }
    },
    {
        "name": "lib.matplotlib.colors.Normalize.__call__#997",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.Normalize",
        "signature": "lib.matplotlib.colors.Normalize.__call__(self, value, clip=None)",
        "snippet": "    def __call__(self, value, clip=None):\n        \"\"\"\n        Normalize *value* data in the ``[vmin, vmax]`` interval into\n        the ``[0.0, 1.0]`` interval and return it.  *clip* defaults\n        to *self.clip* (which defaults to *False*).  If not already\n        initialized, *vmin* and *vmax* are initialized using\n        *autoscale_None(value)*.\n        \"\"\"\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        self.autoscale_None(result)\n        # Convert at least to float, without losing precision.\n        (vmin,), _ = self.process_value(self.vmin)\n        (vmax,), _ = self.process_value(self.vmax)\n        if vmin == vmax:\n            result.fill(0)   # Or should it be all masked?  Or 0.5?\n        elif vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        else:\n            if clip:\n                mask = np.ma.getmask(result)\n                result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                     mask=mask)\n            # ma division is very slow; we can take a shortcut\n            resdat = result.data\n            resdat -= vmin\n            resdat /= (vmax - vmin)\n            result = np.ma.array(resdat, mask=result.mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result",
        "begin_line": 997,
        "end_line": 1030,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.colors.Normalize.inverse#1032",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.Normalize",
        "signature": "lib.matplotlib.colors.Normalize.inverse(self, value)",
        "snippet": "    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        (vmin,), _ = self.process_value(self.vmin)\n        (vmax,), _ = self.process_value(self.vmax)\n\n        if np.iterable(value):\n            val = np.ma.asarray(value)\n            return vmin + val * (vmax - vmin)\n        else:\n            return vmin + value * (vmax - vmin)",
        "begin_line": 1032,
        "end_line": 1042,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018463810930576072,
            "pseudo_dstar_susp": 0.00016136840406648378,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00016136840406648378,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.colors.Normalize.autoscale_None#1050",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.Normalize",
        "signature": "lib.matplotlib.colors.Normalize.autoscale_None(self, A)",
        "snippet": "    def autoscale_None(self, A):\n        \"\"\"Autoscale only None-valued vmin or vmax.\"\"\"\n        A = np.asanyarray(A)\n        if self.vmin is None and A.size:\n            self.vmin = A.min()\n        if self.vmax is None and A.size:\n            self.vmax = A.max()",
        "begin_line": 1050,
        "end_line": 1056,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00013515339910798757,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00013515339910798757,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.colors.Normalize.scaled#1058",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.Normalize",
        "signature": "lib.matplotlib.colors.Normalize.scaled(self)",
        "snippet": "    def scaled(self):\n        \"\"\"Return whether vmin and vmax are set.\"\"\"\n        return self.vmin is not None and self.vmax is not None",
        "begin_line": 1058,
        "end_line": 1060,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.colors.TwoSlopeNorm.__call__#1116",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.TwoSlopeNorm",
        "signature": "lib.matplotlib.colors.TwoSlopeNorm.__call__(self, value, clip=None)",
        "snippet": "    def __call__(self, value, clip=None):\n        \"\"\"\n        Map value to the interval [0, 1]. The clip argument is unused.\n        \"\"\"\n        result, is_scalar = self.process_value(value)\n        self.autoscale_None(result)  # sets self.vmin, self.vmax if None\n\n        if not self.vmin <= self.vcenter <= self.vmax:\n            raise ValueError(\"vmin, vcenter, vmax must increase monotonically\")\n        result = np.ma.masked_array(\n            np.interp(result, [self.vmin, self.vcenter, self.vmax],\n                      [0, 0.5, 1.]), mask=np.ma.getmask(result))\n        if is_scalar:\n            result = np.atleast_1d(result)[0]\n        return result",
        "begin_line": 1116,
        "end_line": 1130,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.667764583513912e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colors.LogNorm._check_vmin_vmax#1141",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LogNorm",
        "signature": "lib.matplotlib.colors.LogNorm._check_vmin_vmax(self)",
        "snippet": "    def _check_vmin_vmax(self):\n        if self.vmin > self.vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif self.vmin <= 0:\n            raise ValueError(\"minvalue must be positive\")",
        "begin_line": 1141,
        "end_line": 1145,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.922674694977024e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colors.LogNorm.__call__#1147",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LogNorm",
        "signature": "lib.matplotlib.colors.LogNorm.__call__(self, value, clip=None)",
        "snippet": "    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        result = np.ma.masked_less_equal(result, 0, copy=False)\n\n        self.autoscale_None(result)\n        self._check_vmin_vmax()\n        vmin, vmax = self.vmin, self.vmax\n        if vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = np.ma.getmask(result)\n                result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                     mask=mask)\n            # in-place equivalent of above can be much faster\n            resdat = result.data\n            mask = result.mask\n            if mask is np.ma.nomask:\n                mask = (resdat <= 0)\n            else:\n                mask |= resdat <= 0\n            np.copyto(resdat, 1, where=mask)\n            np.log(resdat, resdat)\n            resdat -= np.log(vmin)\n            resdat /= (np.log(vmax) - np.log(vmin))\n            result = np.ma.array(resdat, mask=mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result",
        "begin_line": 1147,
        "end_line": 1179,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colors.LogNorm.inverse#1181",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LogNorm",
        "signature": "lib.matplotlib.colors.LogNorm.inverse(self, value)",
        "snippet": "    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        self._check_vmin_vmax()\n        vmin, vmax = self.vmin, self.vmax\n\n        if np.iterable(value):\n            val = np.ma.asarray(value)\n            return vmin * np.ma.power((vmax / vmin), val)\n        else:\n            return vmin * pow((vmax / vmin), value)",
        "begin_line": 1181,
        "end_line": 1191,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colors.SymLogNorm.__init__#1212",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.SymLogNorm",
        "signature": "lib.matplotlib.colors.SymLogNorm.__init__(self, linthresh, linscale=1.0, vmin=None, vmax=None, clip=False)",
        "snippet": "    def __init__(self,  linthresh, linscale=1.0,\n                 vmin=None, vmax=None, clip=False):\n        \"\"\"\n        *linthresh*:\n        The range within which the plot is linear (to\n        avoid having the plot go to infinity around zero).\n\n        *linscale*:\n        This allows the linear range (-*linthresh* to *linthresh*)\n        to be stretched relative to the logarithmic range.  Its\n        value is the number of decades to use for each half of the\n        linear range.  For example, when *linscale* == 1.0 (the\n        default), the space used for the positive and negative\n        halves of the linear range will be equal to one decade in\n        the logarithmic range. Defaults to 1.\n        \"\"\"\n        Normalize.__init__(self, vmin, vmax, clip)\n        self.linthresh = float(linthresh)\n        self._linscale_adj = (linscale / (1.0 - np.e ** -1))\n        if vmin is not None and vmax is not None:\n            self._transform_vmin_vmax()",
        "begin_line": 1212,
        "end_line": 1232,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.34306691139663e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colors.SymLogNorm.__call__#1234",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.SymLogNorm",
        "signature": "lib.matplotlib.colors.SymLogNorm.__call__(self, value, clip=None)",
        "snippet": "    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = np.ma.getmask(result)\n                result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                     mask=mask)\n            # in-place equivalent of above can be much faster\n            resdat = self._transform(result.data)\n            resdat -= self._lower\n            resdat /= (self._upper - self._lower)\n\n        if is_scalar:\n            result = result[0]\n        return result",
        "begin_line": 1234,
        "end_line": 1258,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colors.SymLogNorm._transform#1260",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.SymLogNorm",
        "signature": "lib.matplotlib.colors.SymLogNorm._transform(self, a)",
        "snippet": "    def _transform(self, a):\n        \"\"\"Inplace transformation.\"\"\"\n        with np.errstate(invalid=\"ignore\"):\n            masked = np.abs(a) > self.linthresh\n        sign = np.sign(a[masked])\n        log = (self._linscale_adj + np.log(np.abs(a[masked]) / self.linthresh))\n        log *= sign * self.linthresh\n        a[masked] = log\n        a[~masked] *= self._linscale_adj\n        return a",
        "begin_line": 1260,
        "end_line": 1269,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.34306691139663e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colors.SymLogNorm._inv_transform#1271",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.SymLogNorm",
        "signature": "lib.matplotlib.colors.SymLogNorm._inv_transform(self, a)",
        "snippet": "    def _inv_transform(self, a):\n        \"\"\"Inverse inplace Transformation.\"\"\"\n        masked = np.abs(a) > (self.linthresh * self._linscale_adj)\n        sign = np.sign(a[masked])\n        exp = np.exp(sign * a[masked] / self.linthresh - self._linscale_adj)\n        exp *= sign * self.linthresh\n        a[masked] = exp\n        a[~masked] /= self._linscale_adj\n        return a",
        "begin_line": 1271,
        "end_line": 1279,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.498342823149486e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colors.SymLogNorm.inverse#1287",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.SymLogNorm",
        "signature": "lib.matplotlib.colors.SymLogNorm.inverse(self, value)",
        "snippet": "    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        val = np.ma.asarray(value)\n        val = val * (self._upper - self._lower) + self._lower\n        return self._inv_transform(val)",
        "begin_line": 1287,
        "end_line": 1292,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.498342823149486e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colors.SymLogNorm.autoscale_None#1299",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.SymLogNorm",
        "signature": "lib.matplotlib.colors.SymLogNorm.autoscale_None(self, A)",
        "snippet": "    def autoscale_None(self, A):\n        # docstring inherited.\n        super().autoscale_None(A)\n        self._transform_vmin_vmax()",
        "begin_line": 1299,
        "end_line": 1302,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colors.PowerNorm.__init__#1310",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.PowerNorm",
        "signature": "lib.matplotlib.colors.PowerNorm.__init__(self, gamma, vmin=None, vmax=None, clip=False)",
        "snippet": "    def __init__(self, gamma, vmin=None, vmax=None, clip=False):\n        Normalize.__init__(self, vmin, vmax, clip)\n        self.gamma = gamma",
        "begin_line": 1310,
        "end_line": 1312,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.498342823149486e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colors.PowerNorm.__call__#1314",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.PowerNorm",
        "signature": "lib.matplotlib.colors.PowerNorm.__call__(self, value, clip=None)",
        "snippet": "    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        self.autoscale_None(result)\n        gamma = self.gamma\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = np.ma.getmask(result)\n                result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                     mask=mask)\n            resdat = result.data\n            resdat -= vmin\n            resdat[resdat < 0] = 0\n            np.power(resdat, gamma, resdat)\n            resdat /= (vmax - vmin) ** gamma\n\n            result = np.ma.array(resdat, mask=result.mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result",
        "begin_line": 1314,
        "end_line": 1341,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colors.BoundaryNorm.__init__#1367",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.BoundaryNorm",
        "signature": "lib.matplotlib.colors.BoundaryNorm.__init__(self, boundaries, ncolors, clip=False)",
        "snippet": "    def __init__(self, boundaries, ncolors, clip=False):\n        \"\"\"\n        Parameters\n        ----------\n        boundaries : array-like\n            Monotonically increasing sequence of boundaries\n        ncolors : int\n            Number of colors in the colormap to be used\n        clip : bool, optional\n            If clip is ``True``, out of range values are mapped to 0 if they\n            are below ``boundaries[0]`` or mapped to ncolors - 1 if they are\n            above ``boundaries[-1]``.\n\n            If clip is ``False``, out of range values are mapped to -1 if\n            they are below ``boundaries[0]`` or mapped to ncolors if they are\n            above ``boundaries[-1]``. These are then converted to valid indices\n            by :meth:`Colormap.__call__`.\n\n        Notes\n        -----\n        *boundaries* defines the edges of bins, and data falling within a bin\n        is mapped to the color with the same index.\n\n        If the number of bins doesn't equal *ncolors*, the color is chosen\n        by linear interpolation of the bin number onto color numbers.\n        \"\"\"\n        self.clip = clip\n        self.vmin = boundaries[0]\n        self.vmax = boundaries[-1]\n        self.boundaries = np.asarray(boundaries)\n        self.N = len(self.boundaries)\n        self.Ncmap = ncolors\n        if self.N - 1 == self.Ncmap:\n            self._interp = False\n        else:\n            self._interp = True",
        "begin_line": 1367,
        "end_line": 1402,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.colors.BoundaryNorm.__call__#1404",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.BoundaryNorm",
        "signature": "lib.matplotlib.colors.BoundaryNorm.__call__(self, value, clip=None)",
        "snippet": "    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        xx, is_scalar = self.process_value(value)\n        mask = np.ma.getmaskarray(xx)\n        xx = np.atleast_1d(xx.filled(self.vmax + 1))\n        if clip:\n            np.clip(xx, self.vmin, self.vmax, out=xx)\n            max_col = self.Ncmap - 1\n        else:\n            max_col = self.Ncmap\n        iret = np.zeros(xx.shape, dtype=np.int16)\n        for i, b in enumerate(self.boundaries):\n            iret[xx >= b] = i\n        if self._interp:\n            scalefac = (self.Ncmap - 1) / (self.N - 2)\n            iret = (iret * scalefac).astype(np.int16)\n        iret[xx < self.vmin] = -1\n        iret[xx >= self.vmax] = max_col\n        ret = np.ma.array(iret, mask=mask)\n        if is_scalar:\n            ret = int(ret[0])  # assume python scalar\n        return ret",
        "begin_line": 1404,
        "end_line": 1427,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.colors.NoNorm.__call__#1445",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.NoNorm",
        "signature": "lib.matplotlib.colors.NoNorm.__call__(self, value, clip=None)",
        "snippet": "    def __call__(self, value, clip=None):\n        return value",
        "begin_line": 1445,
        "end_line": 1446,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018463810930576072,
            "pseudo_dstar_susp": 0.00016136840406648378,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00016136840406648378,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.colors.NoNorm.inverse#1448",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.NoNorm",
        "signature": "lib.matplotlib.colors.NoNorm.inverse(self, value)",
        "snippet": "    def inverse(self, value):\n        return value",
        "begin_line": 1448,
        "end_line": 1449,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.colors.rgb_to_hsv#1452",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors",
        "signature": "lib.matplotlib.colors.rgb_to_hsv(arr)",
        "snippet": "def rgb_to_hsv(arr):\n    \"\"\"\n    Convert float rgb values (in the range [0, 1]), in a numpy array to hsv\n    values.\n\n    Parameters\n    ----------\n    arr : (..., 3) array-like\n       All values must be in the range [0, 1]\n\n    Returns\n    -------\n    hsv : (..., 3) ndarray\n       Colors converted to hsv values in range [0, 1]\n    \"\"\"\n    arr = np.asarray(arr)\n\n    # check length of the last dimension, should be _some_ sort of rgb\n    if arr.shape[-1] != 3:\n        raise ValueError(\"Last dimension of input array must be 3; \"\n                         \"shape {} was found.\".format(arr.shape))\n\n    in_shape = arr.shape\n    arr = np.array(\n        arr, copy=False,\n        dtype=np.promote_types(arr.dtype, np.float32),  # Don't work on ints.\n        ndmin=2,  # In case input was 1D.\n    )\n    out = np.zeros_like(arr)\n    arr_max = arr.max(-1)\n    ipos = arr_max > 0\n    delta = arr.ptp(-1)\n    s = np.zeros_like(delta)\n    s[ipos] = delta[ipos] / arr_max[ipos]\n    ipos = delta > 0\n    # red is max\n    idx = (arr[..., 0] == arr_max) & ipos\n    out[idx, 0] = (arr[idx, 1] - arr[idx, 2]) / delta[idx]\n    # green is max\n    idx = (arr[..., 1] == arr_max) & ipos\n    out[idx, 0] = 2. + (arr[idx, 2] - arr[idx, 0]) / delta[idx]\n    # blue is max\n    idx = (arr[..., 2] == arr_max) & ipos\n    out[idx, 0] = 4. + (arr[idx, 0] - arr[idx, 1]) / delta[idx]\n\n    out[..., 0] = (out[..., 0] / 6.0) % 1.0\n    out[..., 1] = s\n    out[..., 2] = arr_max\n\n    return out.reshape(in_shape)",
        "begin_line": 1452,
        "end_line": 1501,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colors.hsv_to_rgb#1504",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors",
        "signature": "lib.matplotlib.colors.hsv_to_rgb(hsv)",
        "snippet": "def hsv_to_rgb(hsv):\n    \"\"\"\n    Convert hsv values to rgb.\n\n    Parameters\n    ----------\n    hsv : (..., 3) array-like\n       All values assumed to be in range [0, 1]\n\n    Returns\n    -------\n    rgb : (..., 3) ndarray\n       Colors converted to RGB values in range [0, 1]\n    \"\"\"\n    hsv = np.asarray(hsv)\n\n    # check length of the last dimension, should be _some_ sort of rgb\n    if hsv.shape[-1] != 3:\n        raise ValueError(\"Last dimension of input array must be 3; \"\n                         \"shape {shp} was found.\".format(shp=hsv.shape))\n\n    in_shape = hsv.shape\n    hsv = np.array(\n        hsv, copy=False,\n        dtype=np.promote_types(hsv.dtype, np.float32),  # Don't work on ints.\n        ndmin=2,  # In case input was 1D.\n    )\n\n    h = hsv[..., 0]\n    s = hsv[..., 1]\n    v = hsv[..., 2]\n\n    r = np.empty_like(h)\n    g = np.empty_like(h)\n    b = np.empty_like(h)\n\n    i = (h * 6.0).astype(int)\n    f = (h * 6.0) - i\n    p = v * (1.0 - s)\n    q = v * (1.0 - s * f)\n    t = v * (1.0 - s * (1.0 - f))\n\n    idx = i % 6 == 0\n    r[idx] = v[idx]\n    g[idx] = t[idx]\n    b[idx] = p[idx]\n\n    idx = i == 1\n    r[idx] = q[idx]\n    g[idx] = v[idx]\n    b[idx] = p[idx]\n\n    idx = i == 2\n    r[idx] = p[idx]\n    g[idx] = v[idx]\n    b[idx] = t[idx]\n\n    idx = i == 3\n    r[idx] = p[idx]\n    g[idx] = q[idx]\n    b[idx] = v[idx]\n\n    idx = i == 4\n    r[idx] = t[idx]\n    g[idx] = p[idx]\n    b[idx] = v[idx]\n\n    idx = i == 5\n    r[idx] = v[idx]\n    g[idx] = p[idx]\n    b[idx] = q[idx]\n\n    idx = s == 0\n    r[idx] = v[idx]\n    g[idx] = v[idx]\n    b[idx] = v[idx]\n\n    rgb = np.stack([r, g, b], axis=-1)\n\n    return rgb.reshape(in_shape)",
        "begin_line": 1504,
        "end_line": 1583,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colors._vector_magnitude#1586",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors",
        "signature": "lib.matplotlib.colors._vector_magnitude(arr)",
        "snippet": "def _vector_magnitude(arr):\n    # things that don't work here:\n    #  * np.linalg.norm\n    #    - doesn't broadcast in numpy 1.7\n    #    - drops the mask from ma.array\n    #  * using keepdims - broken on ma.array until 1.11.2\n    #  * using sum - discards mask on ma.array unless entire vector is masked\n\n    sum_sq = 0\n    for i in range(arr.shape[-1]):\n        sum_sq += np.square(arr[..., i, np.newaxis])\n    return np.sqrt(sum_sq)",
        "begin_line": 1586,
        "end_line": 1597,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colors.LightSource.__init__#1611",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LightSource",
        "signature": "lib.matplotlib.colors.LightSource.__init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1, hsv_max_sat=0)",
        "snippet": "    def __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1,\n                 hsv_min_sat=1, hsv_max_sat=0):\n        \"\"\"\n        Specify the azimuth (measured clockwise from south) and altitude\n        (measured up from the plane of the surface) of the light source\n        in degrees.\n\n        Parameters\n        ----------\n        azdeg : number, optional\n            The azimuth (0-360, degrees clockwise from North) of the light\n            source. Defaults to 315 degrees (from the northwest).\n        altdeg : number, optional\n            The altitude (0-90, degrees up from horizontal) of the light\n            source.  Defaults to 45 degrees from horizontal.\n\n        Notes\n        -----\n        For backwards compatibility, the parameters *hsv_min_val*,\n        *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at\n        initialization as well.  However, these parameters will only be used if\n        \"blend_mode='hsv'\" is passed into :meth:`shade` or :meth:`shade_rgb`.\n        See the documentation for :meth:`blend_hsv` for more details.\n        \"\"\"\n        self.azdeg = azdeg\n        self.altdeg = altdeg\n        self.hsv_min_val = hsv_min_val\n        self.hsv_max_val = hsv_max_val\n        self.hsv_min_sat = hsv_min_sat\n        self.hsv_max_sat = hsv_max_sat",
        "begin_line": 1611,
        "end_line": 1640,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.498342823149486e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colors.LightSource.direction#1643",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LightSource",
        "signature": "lib.matplotlib.colors.LightSource.direction(self)",
        "snippet": "    def direction(self):\n        \"\"\"The unit vector direction towards the light source.\"\"\"\n        # Azimuth is in degrees clockwise from North. Convert to radians\n        # counterclockwise from East (mathematical notation).\n        az = np.radians(90 - self.azdeg)\n        alt = np.radians(self.altdeg)\n        return np.array([\n            np.cos(az) * np.cos(alt),\n            np.sin(az) * np.cos(alt),\n            np.sin(alt)\n        ])",
        "begin_line": 1643,
        "end_line": 1653,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.498342823149486e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colors.LightSource.shade_normals#1709",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LightSource",
        "signature": "lib.matplotlib.colors.LightSource.shade_normals(self, normals, fraction=1.0)",
        "snippet": "    def shade_normals(self, normals, fraction=1.):\n        \"\"\"\n        Calculates the illumination intensity for the normal vectors of a\n        surface using the defined azimuth and elevation for the light source.\n\n        Imagine an artificial sun placed at infinity in some azimuth and\n        elevation position illuminating our surface. The parts of the surface\n        that slope toward the sun should brighten while those sides facing away\n        should become darker.\n\n        Parameters\n        ----------\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n\n        Returns\n        -------\n        intensity : ndarray\n            A 2d array of illumination values between 0-1, where 0 is\n            completely in shadow and 1 is completely illuminated.\n        \"\"\"\n\n        intensity = normals.dot(self.direction)\n\n        # Apply contrast stretch\n        imin, imax = intensity.min(), intensity.max()\n        intensity *= fraction\n\n        # Rescale to 0-1, keeping range before contrast stretch\n        # If constant slope, keep relative scaling (i.e. flat should be 0.5,\n        # fully occluded 0, etc.)\n        if (imax - imin) > 1e-6:\n            # Strictly speaking, this is incorrect. Negative values should be\n            # clipped to 0 because they're fully occluded. However, rescaling\n            # in this manner is consistent with the previous implementation and\n            # visually appears better than a \"hard\" clip.\n            intensity -= imin\n            intensity /= (imax - imin)\n        intensity = np.clip(intensity, 0, 1)\n\n        return intensity",
        "begin_line": 1709,
        "end_line": 1753,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.667764583513912e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colors.LightSource.shade#1755",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LightSource",
        "signature": "lib.matplotlib.colors.LightSource.shade(self, data, cmap, norm=None, blend_mode='overlay', vmin=None, vmax=None, vert_exag=1, dx=1, dy=1, fraction=1, **kwargs)",
        "snippet": "    def shade(self, data, cmap, norm=None, blend_mode='overlay', vmin=None,\n              vmax=None, vert_exag=1, dx=1, dy=1, fraction=1, **kwargs):\n        \"\"\"\n        Combine colormapped data values with an illumination intensity map\n        (a.k.a.  \"hillshade\") of the values.\n\n        Parameters\n        ----------\n        data : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        cmap : `~matplotlib.colors.Colormap` instance\n            The colormap used to color the *data* array. Note that this must be\n            a `~matplotlib.colors.Colormap` instance.  For example, rather than\n            passing in `cmap='gist_earth'`, use\n            `cmap=plt.get_cmap('gist_earth')` instead.\n        norm : `~matplotlib.colors.Normalize` instance, optional\n            The normalization used to scale values before colormapping. If\n            None, the input will be linearly scaled between its min and max.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data\n            values with the illumination intensity.  Default is\n            \"overlay\".  Note that for most topographic surfaces,\n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to\n            combine an MxNx3 RGB array of floats (ranging 0 to 1) with\n            an MxNx1 hillshade array (also 0 to 1).  (Call signature\n            `func(rgb, illum, **kwargs)`) Additional kwargs supplied\n            to this function will be passed on to the *blend_mode*\n            function.\n        vmin : scalar or None, optional\n            The minimum value used in colormapping *data*. If *None* the\n            minimum value in *data* is used. If *norm* is specified, then this\n            argument will be ignored.\n        vmax : scalar or None, optional\n            The maximum value used in colormapping *data*. If *None* the\n            maximum value in *data* is used. If *norm* is specified, then this\n            argument will be ignored.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs. meters) or to\n            exaggerate or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        Additional kwargs are passed on to the *blend_mode* function.\n\n        Returns\n        -------\n        rgba : ndarray\n            An MxNx4 array of floats ranging between 0-1.\n        \"\"\"\n        if vmin is None:\n            vmin = data.min()\n        if vmax is None:\n            vmax = data.max()\n        if norm is None:\n            norm = Normalize(vmin=vmin, vmax=vmax)\n\n        rgb0 = cmap(norm(data))\n        rgb1 = self.shade_rgb(rgb0, elevation=data, blend_mode=blend_mode,\n                              vert_exag=vert_exag, dx=dx, dy=dy,\n                              fraction=fraction, **kwargs)\n        # Don't overwrite the alpha channel, if present.\n        rgb0[..., :3] = rgb1[..., :3]\n        return rgb0",
        "begin_line": 1755,
        "end_line": 1829,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colors.LightSource.shade_rgb#1831",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LightSource",
        "signature": "lib.matplotlib.colors.LightSource.shade_rgb(self, rgb, elevation, fraction=1.0, blend_mode='hsv', vert_exag=1, dx=1, dy=1, **kwargs)",
        "snippet": "    def shade_rgb(self, rgb, elevation, fraction=1., blend_mode='hsv',\n                  vert_exag=1, dx=1, dy=1, **kwargs):\n        \"\"\"\n        Use this light source to adjust the colors of the *rgb* input array to\n        give the impression of a shaded relief map with the given `elevation`.\n\n        Parameters\n        ----------\n        rgb : array-like\n            An (M, N, 3) RGB array, assumed to be in the range of 0 to 1.\n        elevation : array-like\n            An (M, N) array of the height values used to generate a shaded map.\n        fraction : number\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data values\n            with the illumination intensity.  For backwards compatibility, this\n            defaults to \"hsv\". Note that for most topographic surfaces,\n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to combine an\n            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade\n            array (also 0 to 1).  (Call signature `func(rgb, illum, **kwargs)`)\n            Additional kwargs supplied to this function will be passed on to\n            the *blend_mode* function.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs. meters) or to\n            exaggerate or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        Additional kwargs are passed on to the *blend_mode* function.\n\n        Returns\n        -------\n        shaded_rgb : ndarray\n            An (m, n, 3) array of floats ranging between 0-1.\n        \"\"\"\n        # Calculate the \"hillshade\" intensity.\n        intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)\n        intensity = intensity[..., np.newaxis]\n\n        # Blend the hillshade and rgb data using the specified mode\n        lookup = {\n                'hsv': self.blend_hsv,\n                'soft': self.blend_soft_light,\n                'overlay': self.blend_overlay,\n                }\n        if blend_mode in lookup:\n            blend = lookup[blend_mode](rgb, intensity, **kwargs)\n        else:\n            try:\n                blend = blend_mode(rgb, intensity, **kwargs)\n            except TypeError:\n                raise ValueError('\"blend_mode\" must be callable or one of {}'\n                                 .format(lookup.keys))\n\n        # Only apply result where hillshade intensity isn't masked\n        if hasattr(intensity, 'mask'):\n            mask = intensity.mask[..., 0]\n            for i in range(3):\n                blend[..., i][mask] = rgb[..., i][mask]\n\n        return blend",
        "begin_line": 1831,
        "end_line": 1901,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colors.LightSource.blend_hsv#1903",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LightSource",
        "signature": "lib.matplotlib.colors.LightSource.blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None, hsv_min_val=None, hsv_min_sat=None)",
        "snippet": "    def blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None,\n                  hsv_min_val=None, hsv_min_sat=None):\n        \"\"\"\n        Take the input data array, convert to HSV values in the given colormap,\n        then adjust those color values to give the impression of a shaded\n        relief map with a specified light source.  RGBA values are returned,\n        which can then be used to plot the shaded image with imshow.\n\n        The color of the resulting image will be darkened by moving the (s, v)\n        values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the\n        shaded regions, or lightened by sliding (s, v) toward (hsv_max_sat,\n        hsv_max_val) in regions that are illuminated.  The default extremes are\n        chose so that completely shaded points are nearly black (s = 1, v = 0)\n        and completely illuminated points are nearly white (s = 0, v = 1).\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n        hsv_max_sat : number, optional\n            The maximum saturation value that the *intensity* map can shift the\n            output image to. Defaults to 1.\n        hsv_min_sat : number, optional\n            The minimum saturation value that the *intensity* map can shift the\n            output image to. Defaults to 0.\n        hsv_max_val : number, optional\n            The maximum value (\"v\" in \"hsv\") that the *intensity* map can shift\n            the output image to. Defaults to 1.\n        hsv_min_val : number, optional\n            The minimum value (\"v\" in \"hsv\") that the *intensity* map can shift\n            the output image to. Defaults to 0.\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        \"\"\"\n        # Backward compatibility...\n        if hsv_max_sat is None:\n            hsv_max_sat = self.hsv_max_sat\n        if hsv_max_val is None:\n            hsv_max_val = self.hsv_max_val\n        if hsv_min_sat is None:\n            hsv_min_sat = self.hsv_min_sat\n        if hsv_min_val is None:\n            hsv_min_val = self.hsv_min_val\n\n        # Expects a 2D intensity array scaled between -1 to 1...\n        intensity = intensity[..., 0]\n        intensity = 2 * intensity - 1\n\n        # Convert to rgb, then rgb to hsv\n        hsv = rgb_to_hsv(rgb[:, :, 0:3])\n        hue, sat, val = np.moveaxis(hsv, -1, 0)\n\n        # Modify hsv values (in place) to simulate illumination.\n        # putmask(A, mask, B) <=> A[mask] = B[mask]\n        np.putmask(sat, (np.abs(sat) > 1.e-10) & (intensity > 0),\n                   (1 - intensity) * sat + intensity * hsv_max_sat)\n        np.putmask(sat, (np.abs(sat) > 1.e-10) & (intensity < 0),\n                   (1 + intensity) * sat - intensity * hsv_min_sat)\n        np.putmask(val, intensity > 0,\n                   (1 - intensity) * val + intensity * hsv_max_val)\n        np.putmask(val, intensity < 0,\n                   (1 + intensity) * val - intensity * hsv_min_val)\n        np.clip(hsv[:, :, 1:], 0, 1, out=hsv[:, :, 1:])\n\n        # Convert modified hsv back to rgb.\n        return hsv_to_rgb(hsv)",
        "begin_line": 1903,
        "end_line": 1973,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.colors.from_levels_and_colors#2015",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors",
        "signature": "lib.matplotlib.colors.from_levels_and_colors(levels, colors, extend='neither')",
        "snippet": "def from_levels_and_colors(levels, colors, extend='neither'):\n    \"\"\"\n    A helper routine to generate a cmap and a norm instance which\n    behave similar to contourf's levels and colors arguments.\n\n    Parameters\n    ----------\n    levels : sequence of numbers\n        The quantization levels used to construct the :class:`BoundaryNorm`.\n        Value ``v`` is quantized to level ``i`` if ``lev[i] <= v < lev[i+1]``.\n    colors : sequence of colors\n        The fill color to use for each level. If `extend` is \"neither\" there\n        must be ``n_level - 1`` colors. For an `extend` of \"min\" or \"max\" add\n        one extra color, and for an `extend` of \"both\" add two colors.\n    extend : {'neither', 'min', 'max', 'both'}, optional\n        The behaviour when a value falls out of range of the given levels.\n        See :func:`~matplotlib.pyplot.contourf` for details.\n\n    Returns\n    -------\n    cmap : `~matplotlib.colors.Normalize`\n    norm : `~matplotlib.colors.Colormap`\n    \"\"\"\n    slice_map = {\n        'both': slice(1, -1),\n        'min': slice(1, None),\n        'max': slice(0, -1),\n        'neither': slice(0, None),\n    }\n    cbook._check_in_list(slice_map, extend=extend)\n    color_slice = slice_map[extend]\n\n    n_data_colors = len(levels) - 1\n    n_expected = n_data_colors + color_slice.start - (color_slice.stop or 0)\n    if len(colors) != n_expected:\n        raise ValueError(\n            f'With extend == {extend!r} and {len(levels)} levels, '\n            f'expected {n_expected} colors, but got {len(colors)}')\n\n    cmap = ListedColormap(colors[color_slice], N=n_data_colors)\n\n    if extend in ['min', 'both']:\n        cmap.set_under(colors[0])\n    else:\n        cmap.set_under('none')\n\n    if extend in ['max', 'both']:\n        cmap.set_over(colors[-1])\n    else:\n        cmap.set_over('none')\n\n    cmap.colorbar_extend = extend\n\n    norm = BoundaryNorm(levels, ncolors=n_data_colors)\n    return cmap, norm",
        "begin_line": 2015,
        "end_line": 2069,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.widgets.CheckButtons.__init__#526",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.CheckButtons",
        "signature": "lib.matplotlib.widgets.CheckButtons.__init__(self, ax, labels, actives=None)",
        "snippet": "    def __init__(self, ax, labels, actives=None):\n        \"\"\"\n        Add check buttons to `matplotlib.axes.Axes` instance *ax*\n\n        Parameters\n        ----------\n        ax : `~matplotlib.axes.Axes`\n            The parent axes for the widget.\n\n        labels : list of str\n            The labels of the check buttons.\n\n        actives : list of bool, optional\n            The initial check states of the buttons. The list must have the\n            same length as *labels*. If not given, all buttons are unchecked.\n        \"\"\"\n        AxesWidget.__init__(self, ax)\n\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.set_navigate(False)\n\n        if actives is None:\n            actives = [False] * len(labels)\n\n        if len(labels) > 1:\n            dy = 1. / (len(labels) + 1)\n            ys = np.linspace(1 - dy, dy, len(labels))\n        else:\n            dy = 0.25\n            ys = [0.5]\n\n        axcolor = ax.get_facecolor()\n\n        self.labels = []\n        self.lines = []\n        self.rectangles = []\n\n        lineparams = {'color': 'k', 'linewidth': 1.25,\n                      'transform': ax.transAxes, 'solid_capstyle': 'butt'}\n        for y, label, active in zip(ys, labels, actives):\n            t = ax.text(0.25, y, label, transform=ax.transAxes,\n                        horizontalalignment='left',\n                        verticalalignment='center')\n\n            w, h = dy / 2, dy / 2\n            x, y = 0.05, y - h / 2\n\n            p = Rectangle(xy=(x, y), width=w, height=h, edgecolor='black',\n                          facecolor=axcolor, transform=ax.transAxes)\n\n            l1 = Line2D([x, x + w], [y + h, y], **lineparams)\n            l2 = Line2D([x, x + w], [y, y + h], **lineparams)\n\n            l1.set_visible(active)\n            l2.set_visible(active)\n            self.labels.append(t)\n            self.rectangles.append(p)\n            self.lines.append((l1, l2))\n            ax.add_patch(p)\n            ax.add_line(l1)\n            ax.add_line(l2)\n\n        self.connect_event('button_press_event', self._clicked)\n\n        self.cnt = 0\n        self.observers = {}",
        "begin_line": 526,
        "end_line": 592,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.widgets.RadioButtons.__init__#982",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RadioButtons",
        "signature": "lib.matplotlib.widgets.RadioButtons.__init__(self, ax, labels, active=0, activecolor='blue')",
        "snippet": "    def __init__(self, ax, labels, active=0, activecolor='blue'):\n        \"\"\"\n        Add radio buttons to an `~.axes.Axes`.\n\n        Parameters\n        ----------\n        ax : `~matplotlib.axes.Axes`\n            The axes to add the buttons to.\n        labels : list of str\n            The button labels.\n        active : int\n            The index of the initially selected button.\n        activecolor : color\n            The color of the selected button.\n        \"\"\"\n        AxesWidget.__init__(self, ax)\n        self.activecolor = activecolor\n        self.value_selected = None\n\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.set_navigate(False)\n        dy = 1. / (len(labels) + 1)\n        ys = np.linspace(1 - dy, dy, len(labels))\n        cnt = 0\n        axcolor = ax.get_facecolor()\n\n        # scale the radius of the circle with the spacing between each one\n        circle_radius = dy / 2 - 0.01\n        # default to hard-coded value if the radius becomes too large\n        circle_radius = min(circle_radius, 0.05)\n\n        self.labels = []\n        self.circles = []\n        for y, label in zip(ys, labels):\n            t = ax.text(0.25, y, label, transform=ax.transAxes,\n                        horizontalalignment='left',\n                        verticalalignment='center')\n\n            if cnt == active:\n                self.value_selected = label\n                facecolor = activecolor\n            else:\n                facecolor = axcolor\n\n            p = Circle(xy=(0.15, y), radius=circle_radius, edgecolor='black',\n                       facecolor=facecolor, transform=ax.transAxes)\n\n            self.labels.append(t)\n            self.circles.append(p)\n            ax.add_patch(p)\n            cnt += 1\n\n        self.connect_event('button_press_event', self._clicked)\n\n        self.cnt = 0\n        self.observers = {}",
        "begin_line": 982,
        "end_line": 1038,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget.__init__#1437",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget.__init__(self, ax, onselect, useblit=False, button=None, state_modifier_keys=None)",
        "snippet": "    def __init__(self, ax, onselect, useblit=False, button=None,\n                 state_modifier_keys=None):\n        AxesWidget.__init__(self, ax)\n\n        self.visible = True\n        self.onselect = onselect\n        self.useblit = useblit and self.canvas.supports_blit\n        self.connect_default_events()\n\n        self.state_modifier_keys = dict(move=' ', clear='escape',\n                                        square='shift', center='control')\n        self.state_modifier_keys.update(state_modifier_keys or {})\n\n        self.background = None\n        self.artists = []\n\n        if isinstance(button, Integral):\n            self.validButtons = [button]\n        else:\n            self.validButtons = button\n\n        # will save the data (position at mouseclick)\n        self.eventpress = None\n        # will save the data (pos. at mouserelease)\n        self.eventrelease = None\n        self._prev_event = None\n        self.state = set()",
        "begin_line": 1437,
        "end_line": 1463,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.34306691139663e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget.update_background#1470",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget.update_background(self, event)",
        "snippet": "    def update_background(self, event):\n        \"\"\"force an update of the background\"\"\"\n        # If you add a call to `ignore` here, you'll want to check edge case:\n        # `release` can call a draw event even when `ignore` is True.\n        if self.useblit:\n            self.background = self.canvas.copy_from_bbox(self.ax.bbox)",
        "begin_line": 1470,
        "end_line": 1475,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget.connect_default_events#1477",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget.connect_default_events(self)",
        "snippet": "    def connect_default_events(self):\n        \"\"\"Connect the major canvas events to methods.\"\"\"\n        self.connect_event('motion_notify_event', self.onmove)\n        self.connect_event('button_press_event', self.press)\n        self.connect_event('button_release_event', self.release)\n        self.connect_event('draw_event', self.update_background)\n        self.connect_event('key_press_event', self.on_key_press)\n        self.connect_event('key_release_event', self.on_key_release)\n        self.connect_event('scroll_event', self.on_scroll)",
        "begin_line": 1477,
        "end_line": 1485,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget.ignore#1487",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget.ignore(self, event)",
        "snippet": "    def ignore(self, event):\n        # docstring inherited\n        if not self.active or not self.ax.get_visible():\n            return True\n        # If canvas was locked\n        if not self.canvas.widgetlock.available(self):\n            return True\n        if not hasattr(event, 'button'):\n            event.button = None\n        # Only do rectangle selection if event was triggered\n        # with a desired button\n        if (self.validButtons is not None\n                and event.button not in self.validButtons):\n            return True\n        # If no button was pressed yet ignore the event if it was out\n        # of the axes\n        if self.eventpress is None:\n            return event.inaxes != self.ax\n        # If a button was pressed, check if the release-button is the same.\n        if event.button == self.eventpress.button:\n            return False\n        # If a button was pressed, check if the release-button is the same.\n        return (event.inaxes != self.ax or\n                event.button != self.eventpress.button)",
        "begin_line": 1487,
        "end_line": 1510,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget.update#1512",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget.update(self)",
        "snippet": "    def update(self):\n        \"\"\"\n        Draw using blit() or draw_idle() depending on ``self.useblit``.\n        \"\"\"\n        if not self.ax.get_visible():\n            return False\n        if self.useblit:\n            if self.background is not None:\n                self.canvas.restore_region(self.background)\n            for artist in self.artists:\n                self.ax.draw_artist(artist)\n            self.canvas.blit(self.ax.bbox)\n        else:\n            self.canvas.draw_idle()\n        return False",
        "begin_line": 1512,
        "end_line": 1526,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget._get_data#1528",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget._get_data(self, event)",
        "snippet": "    def _get_data(self, event):\n        \"\"\"Get the xdata and ydata for event, with limits\"\"\"\n        if event.xdata is None:\n            return None, None\n        x0, x1 = self.ax.get_xbound()\n        y0, y1 = self.ax.get_ybound()\n        xdata = max(x0, event.xdata)\n        xdata = min(x1, xdata)\n        ydata = max(y0, event.ydata)\n        ydata = min(y1, ydata)\n        return xdata, ydata",
        "begin_line": 1528,
        "end_line": 1538,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget._clean_event#1540",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget._clean_event(self, event)",
        "snippet": "    def _clean_event(self, event):\n        \"\"\"Clean up an event\n\n        Use prev event if there is no xdata\n        Limit the xdata and ydata to the axes limits\n        Set the prev event\n        \"\"\"\n        if event.xdata is None:\n            event = self._prev_event\n        else:\n            event = copy.copy(event)\n        event.xdata, event.ydata = self._get_data(event)\n\n        self._prev_event = event\n        return event",
        "begin_line": 1540,
        "end_line": 1554,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.34306691139663e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget.press#1556",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget.press(self, event)",
        "snippet": "    def press(self, event):\n        \"\"\"Button press handler and validator\"\"\"\n        if not self.ignore(event):\n            event = self._clean_event(event)\n            self.eventpress = event\n            self._prev_event = event\n            key = event.key or ''\n            key = key.replace('ctrl', 'control')\n            # move state is locked in on a button press\n            if key == self.state_modifier_keys['move']:\n                self.state.add('move')\n            self._press(event)\n            return True\n        return False",
        "begin_line": 1556,
        "end_line": 1569,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.34306691139663e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget.release#1574",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget.release(self, event)",
        "snippet": "    def release(self, event):\n        \"\"\"Button release event handler and validator\"\"\"\n        if not self.ignore(event) and self.eventpress:\n            event = self._clean_event(event)\n            self.eventrelease = event\n            self._release(event)\n            self.eventpress = None\n            self.eventrelease = None\n            self.state.discard('move')\n            return True\n        return False",
        "begin_line": 1574,
        "end_line": 1584,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.34306691139663e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget.onmove#1589",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget.onmove(self, event)",
        "snippet": "    def onmove(self, event):\n        \"\"\"Cursor move event handler and validator\"\"\"\n        if not self.ignore(event) and self.eventpress:\n            event = self._clean_event(event)\n            self._onmove(event)\n            return True\n        return False",
        "begin_line": 1589,
        "end_line": 1595,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget.on_key_press#1608",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget.on_key_press(self, event)",
        "snippet": "    def on_key_press(self, event):\n        \"\"\"Key press event handler and validator for all selection widgets\"\"\"\n        if self.active:\n            key = event.key or ''\n            key = key.replace('ctrl', 'control')\n            if key == self.state_modifier_keys['clear']:\n                for artist in self.artists:\n                    artist.set_visible(False)\n                self.update()\n                return\n            for (state, modifier) in self.state_modifier_keys.items():\n                if modifier in key:\n                    self.state.add(state)\n            self._on_key_press(event)",
        "begin_line": 1608,
        "end_line": 1621,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget.on_key_release#1627",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget.on_key_release(self, event)",
        "snippet": "    def on_key_release(self, event):\n        \"\"\"Key release event handler and validator.\"\"\"\n        if self.active:\n            key = event.key or ''\n            for (state, modifier) in self.state_modifier_keys.items():\n                if modifier in key:\n                    self.state.discard(state)\n            self._on_key_release(event)",
        "begin_line": 1627,
        "end_line": 1634,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget.set_visible#1639",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget.set_visible(self, visible)",
        "snippet": "    def set_visible(self, visible):\n        \"\"\"Set the visibility of our artists.\"\"\"\n        self.visible = visible\n        for artist in self.artists:\n            artist.set_visible(visible)",
        "begin_line": 1639,
        "end_line": 1643,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.667764583513912e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.SpanSelector.__init__#1700",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.SpanSelector",
        "signature": "lib.matplotlib.widgets.SpanSelector.__init__(self, ax, onselect, direction, minspan=None, useblit=False, rectprops=None, onmove_callback=None, span_stays=False, button=None)",
        "snippet": "    def __init__(self, ax, onselect, direction, minspan=None, useblit=False,\n                 rectprops=None, onmove_callback=None, span_stays=False,\n                 button=None):\n\n        _SelectorWidget.__init__(self, ax, onselect, useblit=useblit,\n                                 button=button)\n\n        if rectprops is None:\n            rectprops = dict(facecolor='red', alpha=0.5)\n\n        rectprops['animated'] = self.useblit\n\n        cbook._check_in_list(['horizontal', 'vertical'], direction=direction)\n        self.direction = direction\n\n        self.rect = None\n        self.pressv = None\n\n        self.rectprops = rectprops\n        self.onmove_callback = onmove_callback\n        self.minspan = minspan\n        self.span_stays = span_stays\n\n        # Needed when dragging out of axes\n        self.prev = (0, 0)\n\n        # Reset canvas so that `new_axes` connects events.\n        self.canvas = None\n        self.new_axes(ax)",
        "begin_line": 1700,
        "end_line": 1728,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.SpanSelector.new_axes#1730",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.SpanSelector",
        "signature": "lib.matplotlib.widgets.SpanSelector.new_axes(self, ax)",
        "snippet": "    def new_axes(self, ax):\n        \"\"\"Set SpanSelector to operate on a new Axes.\"\"\"\n        self.ax = ax\n        if self.canvas is not ax.figure.canvas:\n            if self.canvas is not None:\n                self.disconnect_events()\n\n            self.canvas = ax.figure.canvas\n            self.connect_default_events()\n\n        if self.direction == 'horizontal':\n            trans = blended_transform_factory(self.ax.transData,\n                                              self.ax.transAxes)\n            w, h = 0, 1\n        else:\n            trans = blended_transform_factory(self.ax.transAxes,\n                                              self.ax.transData)\n            w, h = 1, 0\n        self.rect = Rectangle((0, 0), w, h,\n                              transform=trans,\n                              visible=False,\n                              **self.rectprops)\n        if self.span_stays:\n            self.stay_rect = Rectangle((0, 0), w, h,\n                                       transform=trans,\n                                       visible=False,\n                                       **self.rectprops)\n            self.stay_rect.set_animated(False)\n            self.ax.add_patch(self.stay_rect)\n\n        self.ax.add_patch(self.rect)\n        self.artists = [self.rect]",
        "begin_line": 1730,
        "end_line": 1761,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.SpanSelector.ignore#1763",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.SpanSelector",
        "signature": "lib.matplotlib.widgets.SpanSelector.ignore(self, event)",
        "snippet": "    def ignore(self, event):\n        # docstring inherited\n        return _SelectorWidget.ignore(self, event) or not self.visible",
        "begin_line": 1763,
        "end_line": 1765,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.SpanSelector._press#1767",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.SpanSelector",
        "signature": "lib.matplotlib.widgets.SpanSelector._press(self, event)",
        "snippet": "    def _press(self, event):\n        \"\"\"on button press event\"\"\"\n        self.rect.set_visible(self.visible)\n        if self.span_stays:\n            self.stay_rect.set_visible(False)\n            # really force a draw so that the stay rect is not in\n            # the blit background\n            if self.useblit:\n                self.canvas.draw()\n        xdata, ydata = self._get_data(event)\n        if self.direction == 'horizontal':\n            self.pressv = xdata\n        else:\n            self.pressv = ydata\n\n        self._set_span_xy(event)\n        return False",
        "begin_line": 1767,
        "end_line": 1783,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.SpanSelector._release#1785",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.SpanSelector",
        "signature": "lib.matplotlib.widgets.SpanSelector._release(self, event)",
        "snippet": "    def _release(self, event):\n        \"\"\"on button release event\"\"\"\n        if self.pressv is None:\n            return\n\n        self.rect.set_visible(False)\n\n        if self.span_stays:\n            self.stay_rect.set_x(self.rect.get_x())\n            self.stay_rect.set_y(self.rect.get_y())\n            self.stay_rect.set_width(self.rect.get_width())\n            self.stay_rect.set_height(self.rect.get_height())\n            self.stay_rect.set_visible(True)\n\n        self.canvas.draw_idle()\n        vmin = self.pressv\n        xdata, ydata = self._get_data(event)\n        if self.direction == 'horizontal':\n            vmax = xdata or self.prev[0]\n        else:\n            vmax = ydata or self.prev[1]\n\n        if vmin > vmax:\n            vmin, vmax = vmax, vmin\n        span = vmax - vmin\n        if self.minspan is not None and span < self.minspan:\n            return\n        self.onselect(vmin, vmax)\n        self.pressv = None\n        return False",
        "begin_line": 1785,
        "end_line": 1814,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.SpanSelector._onmove#1821",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.SpanSelector",
        "signature": "lib.matplotlib.widgets.SpanSelector._onmove(self, event)",
        "snippet": "    def _onmove(self, event):\n        \"\"\"on motion notify event\"\"\"\n        if self.pressv is None:\n            return\n\n        self._set_span_xy(event)\n\n        if self.onmove_callback is not None:\n            vmin = self.pressv\n            xdata, ydata = self._get_data(event)\n            if self.direction == 'horizontal':\n                vmax = xdata or self.prev[0]\n            else:\n                vmax = ydata or self.prev[1]\n\n            if vmin > vmax:\n                vmin, vmax = vmax, vmin\n            self.onmove_callback(vmin, vmax)\n\n        self.update()\n        return False",
        "begin_line": 1821,
        "end_line": 1841,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.ToolHandles.__init__#1882",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.ToolHandles",
        "signature": "lib.matplotlib.widgets.ToolHandles.__init__(self, ax, x, y, marker='o', marker_props=None, useblit=True)",
        "snippet": "    def __init__(self, ax, x, y, marker='o', marker_props=None, useblit=True):\n        self.ax = ax\n        props = dict(marker=marker, markersize=7, mfc='w', ls='none',\n                     alpha=0.5, visible=False, label='_nolegend_')\n        props.update(marker_props if marker_props is not None else {})\n        self._markers = Line2D(x, y, animated=useblit, **props)\n        self.ax.add_line(self._markers)\n        self.artist = self._markers",
        "begin_line": 1882,
        "end_line": 1889,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.ToolHandles.closest#1912",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.ToolHandles",
        "signature": "lib.matplotlib.widgets.ToolHandles.closest(self, x, y)",
        "snippet": "    def closest(self, x, y):\n        \"\"\"Return index and pixel distance to closest index.\"\"\"\n        pts = np.column_stack([self.x, self.y])\n        # Transform data coordinates to pixel coordinates.\n        pts = self.ax.transData.transform(pts)\n        diff = pts - [x, y]\n        dist = np.hypot(*diff.T)\n        min_index = np.argmin(dist)\n        return min_index, dist[min_index]",
        "begin_line": 1912,
        "end_line": 1920,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.RectangleSelector.__init__#1962",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RectangleSelector",
        "signature": "lib.matplotlib.widgets.RectangleSelector.__init__(self, ax, onselect, drawtype='box', minspanx=None, minspany=None, useblit=False, lineprops=None, rectprops=None, spancoords='data', button=None, maxdist=10, marker_props=None, interactive=False, state_modifier_keys=None)",
        "snippet": "    def __init__(self, ax, onselect, drawtype='box',\n                 minspanx=None, minspany=None, useblit=False,\n                 lineprops=None, rectprops=None, spancoords='data',\n                 button=None, maxdist=10, marker_props=None,\n                 interactive=False, state_modifier_keys=None):\n        \"\"\"\n        Create a selector in *ax*.  When a selection is made, clear\n        the span and call onselect with::\n\n          onselect(pos_1, pos_2)\n\n        and clear the drawn box/line. The ``pos_1`` and ``pos_2`` are\n        arrays of length 2 containing the x- and y-coordinate.\n\n        If *minspanx* is not *None* then events smaller than *minspanx*\n        in x direction are ignored (it's the same for y).\n\n        The rectangle is drawn with *rectprops*; default::\n\n          rectprops = dict(facecolor='red', edgecolor = 'black',\n                           alpha=0.2, fill=True)\n\n        The line is drawn with *lineprops*; default::\n\n          lineprops = dict(color='black', linestyle='-',\n                           linewidth = 2, alpha=0.5)\n\n        Use *drawtype* if you want the mouse to draw a line,\n        a box or nothing between click and actual position by setting\n\n        ``drawtype = 'line'``, ``drawtype='box'`` or ``drawtype = 'none'``.\n        Drawing a line would result in a line from vertex A to vertex C in\n        a rectangle ABCD.\n\n        *spancoords* is one of 'data' or 'pixels'.  If 'data', *minspanx*\n        and *minspanx* will be interpreted in the same coordinates as\n        the x and y axis. If 'pixels', they are in pixels.\n\n        *button* is a list of integers indicating which mouse buttons should\n        be used for rectangle selection.  You can also specify a single\n        integer if only a single button is desired.  Default is *None*,\n        which does not limit which button can be used.\n\n        Note, typically:\n         1 = left mouse button\n         2 = center mouse button (scroll wheel)\n         3 = right mouse button\n\n        *interactive* will draw a set of handles and allow you interact\n        with the widget after it is drawn.\n\n        *state_modifier_keys* are keyboard modifiers that affect the behavior\n        of the widget.\n\n        The defaults are:\n        dict(move=' ', clear='escape', square='shift', center='ctrl')\n\n        Keyboard modifiers, which:\n        'move': Move the existing shape.\n        'clear': Clear the current shape.\n        'square': Makes the shape square.\n        'center': Make the initial point the center of the shape.\n        'square' and 'center' can be combined.\n        \"\"\"\n        _SelectorWidget.__init__(self, ax, onselect, useblit=useblit,\n                                 button=button,\n                                 state_modifier_keys=state_modifier_keys)\n\n        self.to_draw = None\n        self.visible = True\n        self.interactive = interactive\n\n        if drawtype == 'none':  # draw a line but make it invisible\n            drawtype = 'line'\n            self.visible = False\n\n        if drawtype == 'box':\n            if rectprops is None:\n                rectprops = dict(facecolor='red', edgecolor='black',\n                                 alpha=0.2, fill=True)\n            rectprops['animated'] = self.useblit\n            self.rectprops = rectprops\n            self.to_draw = self._shape_klass((0, 0), 0, 1, visible=False,\n                                             **self.rectprops)\n            self.ax.add_patch(self.to_draw)\n        if drawtype == 'line':\n            if lineprops is None:\n                lineprops = dict(color='black', linestyle='-',\n                                 linewidth=2, alpha=0.5)\n            lineprops['animated'] = self.useblit\n            self.lineprops = lineprops\n            self.to_draw = Line2D([0, 0], [0, 0], visible=False,\n                                  **self.lineprops)\n            self.ax.add_line(self.to_draw)\n\n        self.minspanx = minspanx\n        self.minspany = minspany\n\n        cbook._check_in_list(['data', 'pixels'], spancoords=spancoords)\n        self.spancoords = spancoords\n        self.drawtype = drawtype\n\n        self.maxdist = maxdist\n\n        if rectprops is None:\n            props = dict(mec='r')\n        else:\n            props = dict(mec=rectprops.get('edgecolor', 'r'))\n        self._corner_order = ['NW', 'NE', 'SE', 'SW']\n        xc, yc = self.corners\n        self._corner_handles = ToolHandles(self.ax, xc, yc, marker_props=props,\n                                           useblit=self.useblit)\n\n        self._edge_order = ['W', 'N', 'E', 'S']\n        xe, ye = self.edge_centers\n        self._edge_handles = ToolHandles(self.ax, xe, ye, marker='s',\n                                         marker_props=props,\n                                         useblit=self.useblit)\n\n        xc, yc = self.center\n        self._center_handle = ToolHandles(self.ax, [xc], [yc], marker='s',\n                                          marker_props=props,\n                                          useblit=self.useblit)\n\n        self.active_handle = None\n\n        self.artists = [self.to_draw, self._center_handle.artist,\n                        self._corner_handles.artist,\n                        self._edge_handles.artist]\n\n        if not self.interactive:\n            self.artists = [self.to_draw]\n\n        self._extents_on_press = None",
        "begin_line": 1962,
        "end_line": 2095,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.RectangleSelector._press#2097",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RectangleSelector",
        "signature": "lib.matplotlib.widgets.RectangleSelector._press(self, event)",
        "snippet": "    def _press(self, event):\n        \"\"\"on button press event\"\"\"\n        # make the drawed box/line visible get the click-coordinates,\n        # button, ...\n        if self.interactive and self.to_draw.get_visible():\n            self._set_active_handle(event)\n        else:\n            self.active_handle = None\n\n        if self.active_handle is None or not self.interactive:\n            # Clear previous rectangle before drawing new rectangle.\n            self.update()\n\n        if not self.interactive:\n            x = event.xdata\n            y = event.ydata\n            self.extents = x, x, y, y\n\n        self.set_visible(self.visible)",
        "begin_line": 2097,
        "end_line": 2115,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.RectangleSelector._release#2117",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RectangleSelector",
        "signature": "lib.matplotlib.widgets.RectangleSelector._release(self, event)",
        "snippet": "    def _release(self, event):\n        \"\"\"on button release event\"\"\"\n        if not self.interactive:\n            self.to_draw.set_visible(False)\n\n        # update the eventpress and eventrelease with the resulting extents\n        x1, x2, y1, y2 = self.extents\n        self.eventpress.xdata = x1\n        self.eventpress.ydata = y1\n        xy1 = self.ax.transData.transform([x1, y1])\n        self.eventpress.x, self.eventpress.y = xy1\n\n        self.eventrelease.xdata = x2\n        self.eventrelease.ydata = y2\n        xy2 = self.ax.transData.transform([x2, y2])\n        self.eventrelease.x, self.eventrelease.y = xy2\n\n        if self.spancoords == 'data':\n            xmin, ymin = self.eventpress.xdata, self.eventpress.ydata\n            xmax, ymax = self.eventrelease.xdata, self.eventrelease.ydata\n            # calculate dimensions of box or line get values in the right order\n        elif self.spancoords == 'pixels':\n            xmin, ymin = self.eventpress.x, self.eventpress.y\n            xmax, ymax = self.eventrelease.x, self.eventrelease.y\n        else:\n            cbook._check_in_list(['data', 'pixels'],\n                                 spancoords=self.spancoords)\n\n        if xmin > xmax:\n            xmin, xmax = xmax, xmin\n        if ymin > ymax:\n            ymin, ymax = ymax, ymin\n\n        spanx = xmax - xmin\n        spany = ymax - ymin\n        xproblems = self.minspanx is not None and spanx < self.minspanx\n        yproblems = self.minspany is not None and spany < self.minspany\n\n        # check if drawn distance (if it exists) is not too small in\n        # either x or y-direction\n        if self.drawtype != 'none' and (xproblems or yproblems):\n            for artist in self.artists:\n                artist.set_visible(False)\n            self.update()\n            return\n\n        # call desired function\n        self.onselect(self.eventpress, self.eventrelease)\n        self.update()\n\n        return False",
        "begin_line": 2117,
        "end_line": 2167,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.RectangleSelector._onmove#2169",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RectangleSelector",
        "signature": "lib.matplotlib.widgets.RectangleSelector._onmove(self, event)",
        "snippet": "    def _onmove(self, event):\n        \"\"\"on motion notify event if box/line is wanted\"\"\"\n        # resize an existing shape\n        if self.active_handle and self.active_handle != 'C':\n            x1, x2, y1, y2 = self._extents_on_press\n            if self.active_handle in ['E', 'W'] + self._corner_order:\n                x2 = event.xdata\n            if self.active_handle in ['N', 'S'] + self._corner_order:\n                y2 = event.ydata\n\n        # move existing shape\n        elif (('move' in self.state or self.active_handle == 'C')\n              and self._extents_on_press is not None):\n            x1, x2, y1, y2 = self._extents_on_press\n            dx = event.xdata - self.eventpress.xdata\n            dy = event.ydata - self.eventpress.ydata\n            x1 += dx\n            x2 += dx\n            y1 += dy\n            y2 += dy\n\n        # new shape\n        else:\n            center = [self.eventpress.xdata, self.eventpress.ydata]\n            center_pix = [self.eventpress.x, self.eventpress.y]\n            dx = (event.xdata - center[0]) / 2.\n            dy = (event.ydata - center[1]) / 2.\n\n            # square shape\n            if 'square' in self.state:\n                dx_pix = abs(event.x - center_pix[0])\n                dy_pix = abs(event.y - center_pix[1])\n                if not dx_pix:\n                    return\n                maxd = max(abs(dx_pix), abs(dy_pix))\n                if abs(dx_pix) < maxd:\n                    dx *= maxd / (abs(dx_pix) + 1e-6)\n                if abs(dy_pix) < maxd:\n                    dy *= maxd / (abs(dy_pix) + 1e-6)\n\n            # from center\n            if 'center' in self.state:\n                dx *= 2\n                dy *= 2\n\n            # from corner\n            else:\n                center[0] += dx\n                center[1] += dy\n\n            x1, x2, y1, y2 = (center[0] - dx, center[0] + dx,\n                              center[1] - dy, center[1] + dy)\n\n        self.extents = x1, x2, y1, y2",
        "begin_line": 2169,
        "end_line": 2222,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.RectangleSelector._rect_bbox#2225",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RectangleSelector",
        "signature": "lib.matplotlib.widgets.RectangleSelector._rect_bbox(self)",
        "snippet": "    def _rect_bbox(self):\n        if self.drawtype == 'box':\n            x0 = self.to_draw.get_x()\n            y0 = self.to_draw.get_y()\n            width = self.to_draw.get_width()\n            height = self.to_draw.get_height()\n            return x0, y0, width, height\n        else:\n            x, y = self.to_draw.get_data()\n            x0, x1 = min(x), max(x)\n            y0, y1 = min(y), max(y)\n            return x0, y0, x1 - x0, y1 - y0",
        "begin_line": 2225,
        "end_line": 2236,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.RectangleSelector.extents#2263",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RectangleSelector",
        "signature": "lib.matplotlib.widgets.RectangleSelector.extents(self)",
        "snippet": "    def extents(self):\n        \"\"\"Return (xmin, xmax, ymin, ymax).\"\"\"\n        x0, y0, width, height = self._rect_bbox\n        xmin, xmax = sorted([x0, x0 + width])\n        ymin, ymax = sorted([y0, y0 + height])\n        return xmin, xmax, ymin, ymax",
        "begin_line": 2263,
        "end_line": 2268,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.RectangleSelector.extents#2271",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RectangleSelector",
        "signature": "lib.matplotlib.widgets.RectangleSelector.extents(self, extents)",
        "snippet": "    def extents(self, extents):\n        # Update displayed shape\n        self.draw_shape(extents)\n        # Update displayed handles\n        self._corner_handles.set_data(*self.corners)\n        self._edge_handles.set_data(*self.edge_centers)\n        self._center_handle.set_data(*self.center)\n        self.set_visible(self.visible)\n        self.update()",
        "begin_line": 2271,
        "end_line": 2279,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.RectangleSelector.draw_shape#2281",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RectangleSelector",
        "signature": "lib.matplotlib.widgets.RectangleSelector.draw_shape(self, extents)",
        "snippet": "    def draw_shape(self, extents):\n        x0, x1, y0, y1 = extents\n        xmin, xmax = sorted([x0, x1])\n        ymin, ymax = sorted([y0, y1])\n        xlim = sorted(self.ax.get_xlim())\n        ylim = sorted(self.ax.get_ylim())\n\n        xmin = max(xlim[0], xmin)\n        ymin = max(ylim[0], ymin)\n        xmax = min(xmax, xlim[1])\n        ymax = min(ymax, ylim[1])\n\n        if self.drawtype == 'box':\n            self.to_draw.set_x(xmin)\n            self.to_draw.set_y(ymin)\n            self.to_draw.set_width(xmax - xmin)\n            self.to_draw.set_height(ymax - ymin)\n\n        elif self.drawtype == 'line':\n            self.to_draw.set_data([xmin, xmax], [ymin, ymax])",
        "begin_line": 2281,
        "end_line": 2300,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.RectangleSelector._set_active_handle#2302",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RectangleSelector",
        "signature": "lib.matplotlib.widgets.RectangleSelector._set_active_handle(self, event)",
        "snippet": "    def _set_active_handle(self, event):\n        \"\"\"Set active handle based on the location of the mouse event\"\"\"\n        # Note: event.xdata/ydata in data coordinates, event.x/y in pixels\n        c_idx, c_dist = self._corner_handles.closest(event.x, event.y)\n        e_idx, e_dist = self._edge_handles.closest(event.x, event.y)\n        m_idx, m_dist = self._center_handle.closest(event.x, event.y)\n\n        if 'move' in self.state:\n            self.active_handle = 'C'\n            self._extents_on_press = self.extents\n\n        # Set active handle as closest handle, if mouse click is close enough.\n        elif m_dist < self.maxdist * 2:\n            self.active_handle = 'C'\n        elif c_dist > self.maxdist and e_dist > self.maxdist:\n            self.active_handle = None\n            return\n        elif c_dist < e_dist:\n            self.active_handle = self._corner_order[c_idx]\n        else:\n            self.active_handle = self._edge_order[e_idx]\n\n        # Save coordinates of rectangle at the start of handle movement.\n        x1, x2, y1, y2 = self.extents\n        # Switch variables so that only x2 and/or y2 are updated on move.\n        if self.active_handle in ['W', 'SW', 'NW']:\n            x1, x2 = x2, event.xdata\n        if self.active_handle in ['N', 'NW', 'NE']:\n            y1, y2 = y2, event.ydata\n        self._extents_on_press = x1, x2, y1, y2",
        "begin_line": 2302,
        "end_line": 2331,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.EllipseSelector.draw_shape#2388",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.EllipseSelector",
        "signature": "lib.matplotlib.widgets.EllipseSelector.draw_shape(self, extents)",
        "snippet": "    def draw_shape(self, extents):\n        x1, x2, y1, y2 = extents\n        xmin, xmax = sorted([x1, x2])\n        ymin, ymax = sorted([y1, y2])\n        center = [x1 + (x2 - x1) / 2., y1 + (y2 - y1) / 2.]\n        a = (xmax - xmin) / 2.\n        b = (ymax - ymin) / 2.\n\n        if self.drawtype == 'box':\n            self.to_draw.center = center\n            self.to_draw.width = 2 * a\n            self.to_draw.height = 2 * b\n        else:\n            rad = np.deg2rad(np.arange(31) * 12)\n            x = a * np.cos(rad) + center[0]\n            y = b * np.sin(rad) + center[1]\n            self.to_draw.set_data(x, y)",
        "begin_line": 2388,
        "end_line": 2404,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.EllipseSelector._rect_bbox#2407",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.EllipseSelector",
        "signature": "lib.matplotlib.widgets.EllipseSelector._rect_bbox(self)",
        "snippet": "    def _rect_bbox(self):\n        if self.drawtype == 'box':\n            x, y = self.to_draw.center\n            width = self.to_draw.width\n            height = self.to_draw.height\n            return x - width / 2., y - height / 2., width, height\n        else:\n            x, y = self.to_draw.get_data()\n            x0, x1 = min(x), max(x)\n            y0, y1 = min(y), max(y)\n            return x0, y0, x1 - x0, y1 - y0",
        "begin_line": 2407,
        "end_line": 2417,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.LassoSelector.__init__#2454",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.LassoSelector",
        "signature": "lib.matplotlib.widgets.LassoSelector.__init__(self, ax, onselect=None, useblit=True, lineprops=None, button=None)",
        "snippet": "    def __init__(self, ax, onselect=None, useblit=True, lineprops=None,\n                 button=None):\n        _SelectorWidget.__init__(self, ax, onselect, useblit=useblit,\n                                 button=button)\n        self.verts = None\n        if lineprops is None:\n            lineprops = dict()\n        # self.useblit may be != useblit, if the canvas doesn't support blit.\n        lineprops.update(animated=self.useblit, visible=False)\n        self.line = Line2D([], [], **lineprops)\n        self.ax.add_line(self.line)\n        self.artists = [self.line]",
        "begin_line": 2454,
        "end_line": 2465,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.LassoSelector._press#2470",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.LassoSelector",
        "signature": "lib.matplotlib.widgets.LassoSelector._press(self, event)",
        "snippet": "    def _press(self, event):\n        self.verts = [self._get_data(event)]\n        self.line.set_visible(True)",
        "begin_line": 2470,
        "end_line": 2472,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.LassoSelector._release#2477",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.LassoSelector",
        "signature": "lib.matplotlib.widgets.LassoSelector._release(self, event)",
        "snippet": "    def _release(self, event):\n        if self.verts is not None:\n            self.verts.append(self._get_data(event))\n            self.onselect(self.verts)\n        self.line.set_data([[], []])\n        self.line.set_visible(False)\n        self.verts = None",
        "begin_line": 2477,
        "end_line": 2483,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.PolygonSelector.__init__#2536",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.PolygonSelector",
        "signature": "lib.matplotlib.widgets.PolygonSelector.__init__(self, ax, onselect, useblit=False, lineprops=None, markerprops=None, vertex_select_radius=15)",
        "snippet": "    def __init__(self, ax, onselect, useblit=False,\n                 lineprops=None, markerprops=None, vertex_select_radius=15):\n        # The state modifiers 'move', 'square', and 'center' are expected by\n        # _SelectorWidget but are not supported by PolygonSelector\n        # Note: could not use the existing 'move' state modifier in-place of\n        # 'move_all' because _SelectorWidget automatically discards 'move'\n        # from the state on button release.\n        state_modifier_keys = dict(clear='escape', move_vertex='control',\n                                   move_all='shift', move='not-applicable',\n                                   square='not-applicable',\n                                   center='not-applicable')\n        _SelectorWidget.__init__(self, ax, onselect, useblit=useblit,\n                                 state_modifier_keys=state_modifier_keys)\n\n        self._xs, self._ys = [0], [0]\n        self._polygon_completed = False\n\n        if lineprops is None:\n            lineprops = dict(color='k', linestyle='-', linewidth=2, alpha=0.5)\n        lineprops['animated'] = self.useblit\n        self.line = Line2D(self._xs, self._ys, **lineprops)\n        self.ax.add_line(self.line)\n\n        if markerprops is None:\n            markerprops = dict(mec='k', mfc=lineprops.get('color', 'k'))\n        self._polygon_handles = ToolHandles(self.ax, self._xs, self._ys,\n                                            useblit=self.useblit,\n                                            marker_props=markerprops)\n\n        self._active_handle_idx = -1\n        self.vertex_select_radius = vertex_select_radius\n\n        self.artists = [self.line, self._polygon_handles.artist]\n        self.set_visible(True)",
        "begin_line": 2536,
        "end_line": 2569,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.PolygonSelector._press#2571",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.PolygonSelector",
        "signature": "lib.matplotlib.widgets.PolygonSelector._press(self, event)",
        "snippet": "    def _press(self, event):\n        \"\"\"Button press event handler\"\"\"\n        # Check for selection of a tool handle.\n        if ((self._polygon_completed or 'move_vertex' in self.state)\n                and len(self._xs) > 0):\n            h_idx, h_dist = self._polygon_handles.closest(event.x, event.y)\n            if h_dist < self.vertex_select_radius:\n                self._active_handle_idx = h_idx\n        # Save the vertex positions at the time of the press event (needed to\n        # support the 'move_all' state modifier).\n        self._xs_at_press, self._ys_at_press = self._xs[:], self._ys[:]",
        "begin_line": 2571,
        "end_line": 2581,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.PolygonSelector._release#2583",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.PolygonSelector",
        "signature": "lib.matplotlib.widgets.PolygonSelector._release(self, event)",
        "snippet": "    def _release(self, event):\n        \"\"\"Button release event handler\"\"\"\n        # Release active tool handle.\n        if self._active_handle_idx >= 0:\n            self._active_handle_idx = -1\n\n        # Complete the polygon.\n        elif (len(self._xs) > 3\n              and self._xs[-1] == self._xs[0]\n              and self._ys[-1] == self._ys[0]):\n            self._polygon_completed = True\n\n        # Place new vertex.\n        elif (not self._polygon_completed\n              and 'move_all' not in self.state\n              and 'move_vertex' not in self.state):\n            self._xs.insert(-1, event.xdata)\n            self._ys.insert(-1, event.ydata)\n\n        if self._polygon_completed:\n            self.onselect(self.verts)",
        "begin_line": 2583,
        "end_line": 2603,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.PolygonSelector.onmove#2605",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.PolygonSelector",
        "signature": "lib.matplotlib.widgets.PolygonSelector.onmove(self, event)",
        "snippet": "    def onmove(self, event):\n        \"\"\"Cursor move event handler and validator\"\"\"\n        # Method overrides _SelectorWidget.onmove because the polygon selector\n        # needs to process the move callback even if there is no button press.\n        # _SelectorWidget.onmove include logic to ignore move event if\n        # eventpress is None.\n        if not self.ignore(event):\n            event = self._clean_event(event)\n            self._onmove(event)\n            return True\n        return False",
        "begin_line": 2605,
        "end_line": 2615,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.PolygonSelector._onmove#2617",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.PolygonSelector",
        "signature": "lib.matplotlib.widgets.PolygonSelector._onmove(self, event)",
        "snippet": "    def _onmove(self, event):\n        \"\"\"Cursor move event handler\"\"\"\n        # Move the active vertex (ToolHandle).\n        if self._active_handle_idx >= 0:\n            idx = self._active_handle_idx\n            self._xs[idx], self._ys[idx] = event.xdata, event.ydata\n            # Also update the end of the polygon line if the first vertex is\n            # the active handle and the polygon is completed.\n            if idx == 0 and self._polygon_completed:\n                self._xs[-1], self._ys[-1] = event.xdata, event.ydata\n\n        # Move all vertices.\n        elif 'move_all' in self.state and self.eventpress:\n            dx = event.xdata - self.eventpress.xdata\n            dy = event.ydata - self.eventpress.ydata\n            for k in range(len(self._xs)):\n                self._xs[k] = self._xs_at_press[k] + dx\n                self._ys[k] = self._ys_at_press[k] + dy\n\n        # Do nothing if completed or waiting for a move.\n        elif (self._polygon_completed\n              or 'move_vertex' in self.state or 'move_all' in self.state):\n            return\n\n        # Position pending vertex.\n        else:\n            # Calculate distance to the start vertex.\n            x0, y0 = self.line.get_transform().transform((self._xs[0],\n                                                          self._ys[0]))\n            v0_dist = np.hypot(x0 - event.x, y0 - event.y)\n            # Lock on to the start vertex if near it and ready to complete.\n            if len(self._xs) > 3 and v0_dist < self.vertex_select_radius:\n                self._xs[-1], self._ys[-1] = self._xs[0], self._ys[0]\n            else:\n                self._xs[-1], self._ys[-1] = event.xdata, event.ydata\n\n        self._draw_polygon()",
        "begin_line": 2617,
        "end_line": 2653,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.PolygonSelector._on_key_press#2655",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.PolygonSelector",
        "signature": "lib.matplotlib.widgets.PolygonSelector._on_key_press(self, event)",
        "snippet": "    def _on_key_press(self, event):\n        \"\"\"Key press event handler\"\"\"\n        # Remove the pending vertex if entering the 'move_vertex' or\n        # 'move_all' mode\n        if (not self._polygon_completed\n                and ('move_vertex' in self.state or 'move_all' in self.state)):\n            self._xs, self._ys = self._xs[:-1], self._ys[:-1]\n            self._draw_polygon()",
        "begin_line": 2655,
        "end_line": 2662,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.PolygonSelector._on_key_release#2664",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.PolygonSelector",
        "signature": "lib.matplotlib.widgets.PolygonSelector._on_key_release(self, event)",
        "snippet": "    def _on_key_release(self, event):\n        \"\"\"Key release event handler\"\"\"\n        # Add back the pending vertex if leaving the 'move_vertex' or\n        # 'move_all' mode (by checking the released key)\n        if (not self._polygon_completed\n                and\n                (event.key == self.state_modifier_keys.get('move_vertex')\n                 or event.key == self.state_modifier_keys.get('move_all'))):\n            self._xs.append(event.xdata)\n            self._ys.append(event.ydata)\n            self._draw_polygon()\n        # Reset the polygon if the released key is the 'clear' key.\n        elif event.key == self.state_modifier_keys.get('clear'):\n            event = self._clean_event(event)\n            self._xs, self._ys = [event.xdata], [event.ydata]\n            self._polygon_completed = False\n            self.set_visible(True)",
        "begin_line": 2664,
        "end_line": 2680,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.widgets.PolygonSelector._draw_polygon#2682",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.PolygonSelector",
        "signature": "lib.matplotlib.widgets.PolygonSelector._draw_polygon(self)",
        "snippet": "    def _draw_polygon(self):\n        \"\"\"Redraw the polygon based on the new vertex positions.\"\"\"\n        self.line.set_data(self._xs, self._ys)\n        # Only show one tool handle at the start and end vertex of the polygon\n        # if the polygon is completed or the user is locked on to the start\n        # vertex.\n        if (self._polygon_completed\n                or (len(self._xs) > 3\n                    and self._xs[-1] == self._xs[0]\n                    and self._ys[-1] == self._ys[0])):\n            self._polygon_handles.set_data(self._xs[:-1], self._ys[:-1])\n        else:\n            self._polygon_handles.set_data(self._xs, self._ys)\n        self.update()",
        "begin_line": 2682,
        "end_line": 2695,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.testing.jpl_units.UnitDblFormatter.UnitDblFormatter.__call__#15",
        "src_path": "lib/matplotlib/testing/jpl_units/UnitDblFormatter.py",
        "class_name": "lib.matplotlib.testing.jpl_units.UnitDblFormatter.UnitDblFormatter",
        "signature": "lib.matplotlib.testing.jpl_units.UnitDblFormatter.UnitDblFormatter.__call__(self, x, pos=None)",
        "snippet": "    def __call__(self, x, pos=None):\n        # docstring inherited\n        if len(self.locs) == 0:\n            return ''\n        else:\n            return '{:.12}'.format(x)",
        "begin_line": 15,
        "end_line": 20,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001426533523537803,
            "pseudo_dstar_susp": 0.00021003990758244065,
            "pseudo_tarantula_susp": 0.00013345789403443215,
            "pseudo_op2_susp": 0.00021003990758244065,
            "pseudo_barinel_susp": 0.00013338668800853674
        }
    },
    {
        "name": "lib.matplotlib.__init__.wrapper#272",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__.wrapper()",
        "snippet": "    def wrapper():\n        nonlocal called, ret\n        if not called:\n            ret = func()\n            called = True\n            _log.debug(fmt, ret)\n        return ret",
        "begin_line": 272,
        "end_line": 278,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.__init__.RcParams.__init__#757",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.RcParams",
        "signature": "lib.matplotlib.__init__.RcParams.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        self.update(*args, **kwargs)",
        "begin_line": 757,
        "end_line": 758,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.__init__.RcParams.__setitem__#760",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.RcParams",
        "signature": "lib.matplotlib.__init__.RcParams.__setitem__(self, key, val)",
        "snippet": "    def __setitem__(self, key, val):\n        try:\n            if key in _deprecated_map:\n                version, alt_key, alt_val, inverse_alt = _deprecated_map[key]\n                cbook.warn_deprecated(\n                    version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n                key = alt_key\n                val = alt_val(val)\n            elif key in _deprecated_remain_as_none and val is not None:\n                version, = _deprecated_remain_as_none[key]\n                cbook.warn_deprecated(\n                    version, name=key, obj_type=\"rcparam\")\n            elif key in _deprecated_ignore_map:\n                version, alt_key = _deprecated_ignore_map[key]\n                cbook.warn_deprecated(\n                    version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n                return\n            elif key == 'backend':\n                if val is rcsetup._auto_backend_sentinel:\n                    if 'backend' in self:\n                        return\n            try:\n                cval = self.validate[key](val)\n            except ValueError as ve:\n                raise ValueError(\"Key %s: %s\" % (key, str(ve)))\n            dict.__setitem__(self, key, cval)\n        except KeyError:\n            raise KeyError(\n                f\"{key} is not a valid rc parameter (see rcParams.keys() for \"\n                f\"a list of valid parameters)\")",
        "begin_line": 760,
        "end_line": 789,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011261261261261261,
            "pseudo_dstar_susp": 0.006097560975609756,
            "pseudo_tarantula_susp": 0.0002563445270443476,
            "pseudo_op2_susp": 0.006097560975609756,
            "pseudo_barinel_susp": 0.0002563445270443476
        }
    },
    {
        "name": "lib.matplotlib.__init__.RcParams.__getitem__#791",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.RcParams",
        "signature": "lib.matplotlib.__init__.RcParams.__getitem__(self, key)",
        "snippet": "    def __getitem__(self, key):\n        if key in _deprecated_map:\n            version, alt_key, alt_val, inverse_alt = _deprecated_map[key]\n            cbook.warn_deprecated(\n                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n            return inverse_alt(dict.__getitem__(self, alt_key))\n\n        elif key in _deprecated_ignore_map:\n            version, alt_key = _deprecated_ignore_map[key]\n            cbook.warn_deprecated(\n                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n            return dict.__getitem__(self, alt_key) if alt_key else None\n\n        elif key == \"backend\":\n            val = dict.__getitem__(self, key)\n            if val is rcsetup._auto_backend_sentinel:\n                from matplotlib import pyplot as plt\n                plt.switch_backend(rcsetup._auto_backend_sentinel)\n\n        return dict.__getitem__(self, key)",
        "begin_line": 791,
        "end_line": 810,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010649627263045794,
            "pseudo_dstar_susp": 0.00625,
            "pseudo_tarantula_susp": 0.00019073049780659929,
            "pseudo_op2_susp": 0.00625,
            "pseudo_barinel_susp": 0.00019073049780659929
        }
    },
    {
        "name": "lib.matplotlib.__init__.RcParams.__repr__#812",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.RcParams",
        "signature": "lib.matplotlib.__init__.RcParams.__repr__(self)",
        "snippet": "    def __repr__(self):\n        class_name = self.__class__.__name__\n        indent = len(class_name) + 1\n        with cbook._suppress_matplotlib_deprecation_warning():\n            repr_split = pprint.pformat(dict(self), indent=1,\n                                        width=80 - indent).split('\\n')\n        repr_indented = ('\\n' + ' ' * indent).join(repr_split)\n        return '{}({})'.format(class_name, repr_indented)",
        "begin_line": 812,
        "end_line": 819,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.__init__.RcParams.__str__#821",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.RcParams",
        "signature": "lib.matplotlib.__init__.RcParams.__str__(self)",
        "snippet": "    def __str__(self):\n        return '\\n'.join(map('{0[0]}: {0[1]}'.format, sorted(self.items())))",
        "begin_line": 821,
        "end_line": 822,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.__init__.RcParams.__iter__#824",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.RcParams",
        "signature": "lib.matplotlib.__init__.RcParams.__iter__(self)",
        "snippet": "    def __iter__(self):\n        \"\"\"Yield sorted list of keys.\"\"\"\n        with cbook._suppress_matplotlib_deprecation_warning():\n            yield from sorted(dict.__iter__(self))",
        "begin_line": 824,
        "end_line": 827,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002446183953033268,
            "pseudo_dstar_susp": 0.0006325110689437065,
            "pseudo_tarantula_susp": 0.00017009695526450075,
            "pseudo_op2_susp": 0.0006325110689437065,
            "pseudo_barinel_susp": 0.00017009695526450075
        }
    },
    {
        "name": "lib.matplotlib.__init__.RcParams.__len__#829",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.RcParams",
        "signature": "lib.matplotlib.__init__.RcParams.__len__(self)",
        "snippet": "    def __len__(self):\n        return dict.__len__(self)",
        "begin_line": 829,
        "end_line": 830,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.__init__.RcParams.find_all#832",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.RcParams",
        "signature": "lib.matplotlib.__init__.RcParams.find_all(self, pattern)",
        "snippet": "    def find_all(self, pattern):\n        \"\"\"\n        Return the subset of this RcParams dictionary whose keys match,\n        using :func:`re.search`, the given ``pattern``.\n\n        .. note::\n\n            Changes to the returned dictionary are *not* propagated to\n            the parent RcParams dictionary.\n\n        \"\"\"\n        pattern_re = re.compile(pattern)\n        return RcParams((key, value)\n                        for key, value in self.items()\n                        if pattern_re.search(key))",
        "begin_line": 832,
        "end_line": 846,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.__init__.RcParams.copy#848",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.RcParams",
        "signature": "lib.matplotlib.__init__.RcParams.copy(self)",
        "snippet": "    def copy(self):\n        return {k: dict.__getitem__(self, k) for k in self}",
        "begin_line": 848,
        "end_line": 849,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002941176470588235,
            "pseudo_dstar_susp": 0.00028011204481792715,
            "pseudo_tarantula_susp": 0.0002563445270443476,
            "pseudo_op2_susp": 0.00028011204481792715,
            "pseudo_barinel_susp": 0.0002563445270443476
        }
    },
    {
        "name": "lib.matplotlib.__init__._open_file_or_url#866",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__._open_file_or_url(fname)",
        "snippet": "def _open_file_or_url(fname):\n    if not isinstance(fname, Path) and is_url(fname):\n        import urllib.request\n        with urllib.request.urlopen(fname) as f:\n            yield (line.decode('utf-8') for line in f)\n    else:\n        fname = os.path.expanduser(fname)\n        encoding = locale.getpreferredencoding(do_setlocale=False)\n        if encoding is None:\n            encoding = \"utf-8\"\n        with open(fname, encoding=encoding) as f:\n            yield f",
        "begin_line": 866,
        "end_line": 877,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.__init__._rc_params_in_file#880",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__._rc_params_in_file(fname, fail_on_error=False)",
        "snippet": "def _rc_params_in_file(fname, fail_on_error=False):\n    \"\"\"\n    Construct a `RcParams` instance from file *fname*.\n\n    Unlike `rc_params_from_file`, the configuration class only contains the\n    parameters specified in the file (i.e. default values are not filled in).\n    \"\"\"\n    _error_details_fmt = 'line #%d\\n\\t\"%s\"\\n\\tin file \"%s\"'\n\n    rc_temp = {}\n    with _open_file_or_url(fname) as fd:\n        try:\n            for line_no, line in enumerate(fd, 1):\n                strippedline = line.split('#', 1)[0].strip()\n                if not strippedline:\n                    continue\n                tup = strippedline.split(':', 1)\n                if len(tup) != 2:\n                    error_details = _error_details_fmt % (line_no, line, fname)\n                    _log.warning('Illegal %s', error_details)\n                    continue\n                key, val = tup\n                key = key.strip()\n                val = val.strip()\n                if key in rc_temp:\n                    _log.warning('Duplicate key in file %r line #%d.',\n                                 fname, line_no)\n                rc_temp[key] = (val, line, line_no)\n        except UnicodeDecodeError:\n            _log.warning('Cannot decode configuration file %s with encoding '\n                         '%s, check LANG and LC_* variables.',\n                         fname,\n                         locale.getpreferredencoding(do_setlocale=False)\n                         or 'utf-8 (default)')\n            raise\n\n    config = RcParams()\n\n    for key, (val, line, line_no) in rc_temp.items():\n        if key in defaultParams:\n            if fail_on_error:\n                config[key] = val  # try to convert to proper type or raise\n            else:\n                try:\n                    config[key] = val  # try to convert to proper type or skip\n                except Exception as msg:\n                    error_details = _error_details_fmt % (line_no, line, fname)\n                    _log.warning('Bad val %r on %s\\n\\t%s',\n                                 val, error_details, msg)\n        elif key in _deprecated_ignore_map:\n            version, alt_key = _deprecated_ignore_map[key]\n            cbook.warn_deprecated(\n                version, name=key, alternative=alt_key,\n                addendum=\"Please update your matplotlibrc.\")\n        else:\n            version = 'master' if '.post' in __version__ else f'v{__version__}'\n            print(f\"\"\"\nBad key \"{key}\" on line {line_no} in\n{fname}.\nYou probably need to get an updated matplotlibrc file from\nhttps://github.com/matplotlib/matplotlib/blob/{version}/matplotlibrc.template\nor from the matplotlib source distribution\"\"\", file=sys.stderr)\n    return config",
        "begin_line": 880,
        "end_line": 942,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.__init__.rc_params_from_file#945",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__.rc_params_from_file(fname, fail_on_error=False, use_default_template=True)",
        "snippet": "def rc_params_from_file(fname, fail_on_error=False, use_default_template=True):\n    \"\"\"\n    Construct a `RcParams` from file *fname*.\n\n    Parameters\n    ----------\n    fname : str or path-like\n        Name of file parsed for Matplotlib settings.\n    fail_on_error : bool\n        If True, raise an error when the parser fails to convert a parameter.\n    use_default_template : bool\n        If True, initialize with default parameters before updating with those\n        in the given file. If False, the configuration class only contains the\n        parameters specified in the file. (Useful for updating dicts.)\n    \"\"\"\n    config_from_file = _rc_params_in_file(fname, fail_on_error)\n\n    if not use_default_template:\n        return config_from_file\n\n    iter_params = defaultParams.items()\n    with cbook._suppress_matplotlib_deprecation_warning():\n        config = RcParams([(key, default) for key, (default, _) in iter_params\n                           if key not in _all_deprecated])\n    config.update(config_from_file)\n\n    if config['datapath'] is None:\n        config['datapath'] = get_data_path()\n\n    if \"\".join(config['text.latex.preamble']):\n        _log.info(\"\"\"\n*****************************************************************\nYou have the following UNSUPPORTED LaTeX preamble customizations:\n%s\nPlease do not ask for support with these customizations active.\n*****************************************************************\n\"\"\", '\\n'.join(config['text.latex.preamble']))\n    _log.debug('loaded rc file %s', fname)\n\n    return config",
        "begin_line": 945,
        "end_line": 984,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.__init__.rc#1001",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__.rc(group, **kwargs)",
        "snippet": "def rc(group, **kwargs):\n    \"\"\"\n    Set the current rc params.  *group* is the grouping for the rc, e.g.,\n    for ``lines.linewidth`` the group is ``lines``, for\n    ``axes.facecolor``, the group is ``axes``, and so on.  Group may\n    also be a list or tuple of group names, e.g., (*xtick*, *ytick*).\n    *kwargs* is a dictionary attribute name/value pairs, e.g.,::\n\n      rc('lines', linewidth=2, color='r')\n\n    sets the current rc params and is equivalent to::\n\n      rcParams['lines.linewidth'] = 2\n      rcParams['lines.color'] = 'r'\n\n    The following aliases are available to save typing for interactive users:\n\n    =====   =================\n    Alias   Property\n    =====   =================\n    'lw'    'linewidth'\n    'ls'    'linestyle'\n    'c'     'color'\n    'fc'    'facecolor'\n    'ec'    'edgecolor'\n    'mew'   'markeredgewidth'\n    'aa'    'antialiased'\n    =====   =================\n\n    Thus you could abbreviate the above rc command as::\n\n          rc('lines', lw=2, c='r')\n\n    Note you can use python's kwargs dictionary facility to store\n    dictionaries of default parameters.  e.g., you can customize the\n    font rc as follows::\n\n      font = {'family' : 'monospace',\n              'weight' : 'bold',\n              'size'   : 'larger'}\n      rc('font', **font)  # pass in the font dict as kwargs\n\n    This enables you to easily switch between several configurations.  Use\n    ``matplotlib.style.use('default')`` or :func:`~matplotlib.rcdefaults` to\n    restore the default rc params after changes.\n\n    Notes\n    -----\n    Similar functionality is available by using the normal dict interface, i.e.\n    ``rcParams.update({\"lines.linewidth\": 2, ...})`` (but ``rcParams.update``\n    does not support abbreviations or grouping).\n    \"\"\"\n\n    aliases = {\n        'lw':  'linewidth',\n        'ls':  'linestyle',\n        'c':   'color',\n        'fc':  'facecolor',\n        'ec':  'edgecolor',\n        'mew': 'markeredgewidth',\n        'aa':  'antialiased',\n        }\n\n    if isinstance(group, str):\n        group = (group,)\n    for g in group:\n        for k, v in kwargs.items():\n            name = aliases.get(k) or k\n            key = '%s.%s' % (g, name)\n            try:\n                rcParams[key] = v\n            except KeyError:\n                raise KeyError(('Unrecognized key \"%s\" for group \"%s\" and '\n                                'name \"%s\"') % (key, g, name))",
        "begin_line": 1001,
        "end_line": 1074,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.__init__.rcdefaults#1077",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__.rcdefaults()",
        "snippet": "def rcdefaults():\n    \"\"\"\n    Restore the rc params from Matplotlib's internal default style.\n\n    Style-blacklisted rc params (defined in\n    `matplotlib.style.core.STYLE_BLACKLIST`) are not updated.\n\n    See Also\n    --------\n    rc_file_defaults\n        Restore the rc params from the rc file originally loaded by Matplotlib.\n    matplotlib.style.use :\n        Use a specific style file.  Call ``style.use('default')`` to restore\n        the default style.\n    \"\"\"\n    # Deprecation warnings were already handled when creating rcParamsDefault,\n    # no need to reemit them here.\n    with cbook._suppress_matplotlib_deprecation_warning():\n        from .style.core import STYLE_BLACKLIST\n        rcParams.clear()\n        rcParams.update({k: v for k, v in rcParamsDefault.items()\n                         if k not in STYLE_BLACKLIST})",
        "begin_line": 1077,
        "end_line": 1098,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008077544426494346,
            "pseudo_dstar_susp": 0.004016064257028112,
            "pseudo_tarantula_susp": 0.0002577984016499098,
            "pseudo_op2_susp": 0.004,
            "pseudo_barinel_susp": 0.0002577984016499098
        }
    },
    {
        "name": "lib.matplotlib.__init__.rc_file#1116",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__.rc_file(fname, *, use_default_template=True)",
        "snippet": "def rc_file(fname, *, use_default_template=True):\n    \"\"\"\n    Update rc params from file.\n\n    Style-blacklisted rc params (defined in\n    `matplotlib.style.core.STYLE_BLACKLIST`) are not updated.\n\n    Parameters\n    ----------\n    fname : str\n        Name of file parsed for matplotlib settings.\n\n    use_default_template : bool\n        If True, initialize with default parameters before updating with those\n        in the given file. If False, the current configuration persists\n        and only the parameters specified in the file are updated.\n    \"\"\"\n    # Deprecation warnings were already handled in rc_params_from_file, no need\n    # to reemit them here.\n    with cbook._suppress_matplotlib_deprecation_warning():\n        from .style.core import STYLE_BLACKLIST\n        rc_from_file = rc_params_from_file(\n            fname, use_default_template=use_default_template)\n        rcParams.update({k: rc_from_file[k] for k in rc_from_file\n                         if k not in STYLE_BLACKLIST})",
        "begin_line": 1116,
        "end_line": 1140,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.__init__.rc_context.__init__#1178",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.rc_context",
        "signature": "lib.matplotlib.__init__.rc_context.__init__(self, rc=None, fname=None)",
        "snippet": "    def __init__(self, rc=None, fname=None):\n        self._orig = rcParams.copy()\n        try:\n            if fname:\n                rc_file(fname)\n            if rc:\n                rcParams.update(rc)\n        except Exception:\n            self.__fallback()\n            raise",
        "begin_line": 1178,
        "end_line": 1187,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007936507936507937,
            "pseudo_dstar_susp": 0.004219409282700422,
            "pseudo_tarantula_susp": 0.0002563445270443476,
            "pseudo_op2_susp": 0.004219409282700422,
            "pseudo_barinel_susp": 0.0002563445270443476
        }
    },
    {
        "name": "lib.matplotlib.__init__.rc_context.__fallback#1189",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.rc_context",
        "signature": "lib.matplotlib.__init__.rc_context.__fallback(self)",
        "snippet": "    def __fallback(self):\n        # If anything goes wrong, revert to the original rcs.\n        updated_backend = self._orig['backend']\n        dict.update(rcParams, self._orig)\n        # except for the backend.  If the context block triggered resolving\n        # the auto backend resolution keep that value around\n        if self._orig['backend'] is rcsetup._auto_backend_sentinel:\n            rcParams['backend'] = updated_backend",
        "begin_line": 1189,
        "end_line": 1196,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007961783439490446,
            "pseudo_dstar_susp": 0.004291845493562232,
            "pseudo_tarantula_susp": 0.0002577984016499098,
            "pseudo_op2_susp": 0.004291845493562232,
            "pseudo_barinel_susp": 0.0002577984016499098
        }
    },
    {
        "name": "lib.matplotlib.__init__.rc_context.__enter__#1198",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.rc_context",
        "signature": "lib.matplotlib.__init__.rc_context.__enter__(self)",
        "snippet": "    def __enter__(self):\n        return self",
        "begin_line": 1198,
        "end_line": 1199,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007974481658692185,
            "pseudo_dstar_susp": 0.004329004329004329,
            "pseudo_tarantula_susp": 0.0002563445270443476,
            "pseudo_op2_susp": 0.004329004329004329,
            "pseudo_barinel_susp": 0.0002563445270443476
        }
    },
    {
        "name": "lib.matplotlib.__init__.rc_context.__exit__#1201",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.rc_context",
        "signature": "lib.matplotlib.__init__.rc_context.__exit__(self, exc_type, exc_value, exc_tb)",
        "snippet": "    def __exit__(self, exc_type, exc_value, exc_tb):\n        self.__fallback()",
        "begin_line": 1201,
        "end_line": 1202,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007961783439490446,
            "pseudo_dstar_susp": 0.004291845493562232,
            "pseudo_tarantula_susp": 0.0002563445270443476,
            "pseudo_op2_susp": 0.004291845493562232,
            "pseudo_barinel_susp": 0.0002563445270443476
        }
    },
    {
        "name": "lib.matplotlib.__init__.use#1207",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__.use(backend, warn=False, force=True)",
        "snippet": "def use(backend, warn=False, force=True):\n    \"\"\"\n    Select the backend used for rendering and GUI integration.\n\n    Parameters\n    ----------\n    backend : str\n        The backend to switch to.  This can either be one of the standard\n        backend names, which are case-insensitive:\n\n        - interactive backends:\n          GTK3Agg, GTK3Cairo, MacOSX, nbAgg,\n          Qt4Agg, Qt4Cairo, Qt5Agg, Qt5Cairo,\n          TkAgg, TkCairo, WebAgg, WX, WXAgg, WXCairo\n\n        - non-interactive backends:\n          agg, cairo, pdf, pgf, ps, svg, template\n\n        or a string of the form: ``module://my.module.name``.\n\n    warn : bool, optional, default: False\n        If True and not *force*, emit a warning if a failure-to-switch\n        `ImportError` has been suppressed.  This parameter is deprecated.\n\n    force : bool, optional, default: True\n        If True (the default), raise an `ImportError` if the backend cannot be\n        set up (either because it fails to import, or because an incompatible\n        GUI interactive framework is already running); if False, ignore the\n        failure.\n\n    See Also\n    --------\n    :ref:`backends`\n    matplotlib.get_backend\n    \"\"\"\n    name = validate_backend(backend)\n    if dict.__getitem__(rcParams, 'backend') == name:\n        # Nothing to do if the requested backend is already set\n        pass\n    else:\n        # Update both rcParams and rcDefaults so restoring the defaults later\n        # with rcdefaults won't change the backend.  This is a bit of overkill\n        # as 'backend' is already in style.core.STYLE_BLACKLIST, but better to\n        # be safe.\n        rcParams['backend'] = rcParamsDefault['backend'] = name\n        try:\n            from matplotlib import pyplot as plt\n            plt.switch_backend(name)\n        except ImportError as exc:\n            if force:\n                raise\n            if warn:\n                cbook._warn_external(\n                    f\"Failed to switch backend to {backend}: {exc}\")",
        "begin_line": 1207,
        "end_line": 1260,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008051529790660225,
            "pseudo_dstar_susp": 0.003968253968253968,
            "pseudo_tarantula_susp": 0.00016663889351774705,
            "pseudo_op2_susp": 0.003952569169960474,
            "pseudo_barinel_susp": 0.00016663889351774705
        }
    },
    {
        "name": "lib.matplotlib.__init__.get_backend#1267",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__.get_backend()",
        "snippet": "def get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    return rcParams['backend']",
        "begin_line": 1267,
        "end_line": 1275,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010416666666666667,
            "pseudo_dstar_susp": 0.0036496350364963502,
            "pseudo_tarantula_susp": 0.0003132832080200501,
            "pseudo_op2_susp": 0.0036496350364963502,
            "pseudo_barinel_susp": 0.0003132832080200501
        }
    },
    {
        "name": "lib.matplotlib.__init__.is_interactive#1285",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__.is_interactive()",
        "snippet": "def is_interactive():\n    \"\"\"Return whether to redraw after every plotting command.\"\"\"\n    return rcParams['interactive']",
        "begin_line": 1285,
        "end_line": 1287,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009832841691248771,
            "pseudo_dstar_susp": 0.0031746031746031746,
            "pseudo_tarantula_susp": 0.00030303030303030303,
            "pseudo_op2_susp": 0.0031746031746031746,
            "pseudo_barinel_susp": 0.00030303030303030303
        }
    },
    {
        "name": "lib.matplotlib.__init__._replacer#1387",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__._replacer(data, value)",
        "snippet": "def _replacer(data, value):\n    \"\"\"\n    Either returns ``data[value]`` or passes ``data`` back, converts either to\n    a sequence.\n    \"\"\"\n    try:\n        # if key isn't a string don't bother\n        if isinstance(value, str):\n            # try to use __getitem__\n            value = data[value]\n    except Exception:\n        # key does not exist, silently fall back to key\n        pass\n    return sanitize_sequence(value)",
        "begin_line": 1387,
        "end_line": 1400,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.__init__._label_from_arg#1403",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__._label_from_arg(y, default_name)",
        "snippet": "def _label_from_arg(y, default_name):\n    try:\n        return y.name\n    except AttributeError:\n        if isinstance(default_name, str):\n            return default_name\n    return None",
        "begin_line": 1403,
        "end_line": 1409,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001290822253775655,
            "pseudo_dstar_susp": 0.0001359249694168819,
            "pseudo_tarantula_susp": 0.00015482272797646694,
            "pseudo_op2_susp": 0.0001359249694168819,
            "pseudo_barinel_susp": 0.00015446400988569664
        }
    },
    {
        "name": "lib.matplotlib.__init__._add_data_doc#1432",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__._add_data_doc(docstring, replace_names)",
        "snippet": "def _add_data_doc(docstring, replace_names):\n    \"\"\"Add documentation for a *data* field to the given docstring.\n\n    Parameters\n    ----------\n    docstring : str\n        The input docstring.\n    replace_names : list of str or None\n        The list of parameter names which arguments should be replaced by\n        ``data[name]`` (if ``data[name]`` does not throw an exception).  If\n        None, replacement is attempted for all arguments.\n\n    Returns\n    -------\n        The augmented docstring.\n    \"\"\"\n    docstring = inspect.cleandoc(docstring) if docstring is not None else \"\"\n    repl = (\"* All positional and all keyword arguments.\"\n            if replace_names is None else\n            \"\"\n            if len(replace_names) == 0 else\n            \"* All arguments with the following names: {}.\".format(\n                \", \".join(map(repr, sorted(replace_names)))))\n    addendum = _DATA_DOC_APPENDIX.format(replaced=repl)\n    if _DATA_DOC_TITLE not in docstring:\n        addendum = _DATA_DOC_TITLE + addendum\n    return docstring + addendum",
        "begin_line": 1432,
        "end_line": 1458,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.__init__._preprocess_data#1461",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__._preprocess_data(func=None, *, replace_names=None, label_namer=None)",
        "snippet": "def _preprocess_data(func=None, *, replace_names=None, label_namer=None):\n    \"\"\"\n    A decorator to add a 'data' kwarg to a function.\n\n    When applied::\n\n        @_preprocess_data()\n        def func(ax, *args, **kwargs): ...\n\n    the signature is modified to ``decorated(ax, *args, data=None, **kwargs)``\n    with the following behavior:\n\n    - if called with ``data=None``, forward the other arguments to ``func``;\n    - otherwise, *data* must be a mapping; for any argument passed in as a\n      string ``name``, replace the argument by ``data[name]`` (if this does not\n      throw an exception), then forward the arguments to ``func``.\n\n    In either case, any argument that is a `MappingView` is also converted to a\n    list.\n\n    Parameters\n    ----------\n    replace_names : list of str or None, optional, default: None\n        The list of parameter names for which lookup into *data* should be\n        attempted. If None, replacement is attempted for all arguments.\n    label_namer : str, optional, default: None\n        If set e.g. to \"namer\" (which must be a kwarg in the function's\n        signature -- not as ``**kwargs``), if the *namer* argument passed in is\n        a (string) key of *data* and no *label* kwarg is passed, then use the\n        (string) value of the *namer* as *label*. ::\n\n            @_preprocess_data(label_namer=\"foo\")\n            def func(foo, label=None): ...\n\n            func(\"key\", data={\"key\": value})\n            # is equivalent to\n            func.__wrapped__(value, label=\"key\")\n    \"\"\"\n\n    if func is None:  # Return the actual decorator.\n        return functools.partial(\n            _preprocess_data,\n            replace_names=replace_names, label_namer=label_namer)\n\n    sig = inspect.signature(func)\n    varargs_name = None\n    varkwargs_name = None\n    arg_names = []\n    params = list(sig.parameters.values())\n    for p in params:\n        if p.kind is Parameter.VAR_POSITIONAL:\n            varargs_name = p.name\n        elif p.kind is Parameter.VAR_KEYWORD:\n            varkwargs_name = p.name\n        else:\n            arg_names.append(p.name)\n    data_param = Parameter(\"data\", Parameter.KEYWORD_ONLY, default=None)\n    if varkwargs_name:\n        params.insert(-1, data_param)\n    else:\n        params.append(data_param)\n    new_sig = sig.replace(parameters=params)\n    arg_names = arg_names[1:]  # remove the first \"ax\" / self arg\n\n    if replace_names is not None:\n        replace_names = set(replace_names)\n\n    assert (replace_names or set()) <= set(arg_names) or varkwargs_name, (\n        \"Matplotlib internal error: invalid replace_names ({!r}) for {!r}\"\n        .format(replace_names, func.__name__))\n    assert label_namer is None or label_namer in arg_names, (\n        \"Matplotlib internal error: invalid label_namer ({!r}) for {!r}\"\n            .format(label_namer, func.__name__))\n\n    @functools.wraps(func)\n    def inner(ax, *args, data=None, **kwargs):\n        if data is None:\n            return func(ax, *map(sanitize_sequence, args), **kwargs)\n\n        bound = new_sig.bind(ax, *args, **kwargs)\n        needs_label = (label_namer\n                       and \"label\" not in bound.arguments\n                       and \"label\" not in bound.kwargs)\n        auto_label = (bound.arguments.get(label_namer)\n                      or bound.kwargs.get(label_namer))\n\n        for k, v in bound.arguments.items():\n            if k == varkwargs_name:\n                for k1, v1 in v.items():\n                    if replace_names is None or k1 in replace_names:\n                        v[k1] = _replacer(data, v1)\n            elif k == varargs_name:\n                if replace_names is None:\n                    bound.arguments[k] = tuple(_replacer(data, v1) for v1 in v)\n            else:\n                if replace_names is None or k in replace_names:\n                    bound.arguments[k] = _replacer(data, v)\n\n        bound.apply_defaults()\n        del bound.arguments[\"data\"]\n\n        if needs_label:\n            all_kwargs = {**bound.arguments, **bound.kwargs}\n            # label_namer will be in all_kwargs as we asserted above that\n            # `label_namer is None or label_namer in arg_names`.\n            label = _label_from_arg(all_kwargs[label_namer], auto_label)\n            if \"label\" in arg_names:\n                bound.arguments[\"label\"] = label\n                try:\n                    bound.arguments.move_to_end(varkwargs_name)\n                except KeyError:\n                    pass\n            else:\n                bound.arguments.setdefault(varkwargs_name, {})[\"label\"] = label\n\n        return func(*bound.args, **bound.kwargs)\n\n    inner.__doc__ = _add_data_doc(inner.__doc__, replace_names)\n    inner.__signature__ = new_sig\n    return inner",
        "begin_line": 1461,
        "end_line": 1580,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022993791676247414,
            "pseudo_dstar_susp": 0.0002261420171867933,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.0002261420171867933,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.__init__.inner#1536",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__.inner(ax, *args, data=None, **kwargs)",
        "snippet": "    def inner(ax, *args, data=None, **kwargs):\n        if data is None:\n            return func(ax, *map(sanitize_sequence, args), **kwargs)\n\n        bound = new_sig.bind(ax, *args, **kwargs)\n        needs_label = (label_namer\n                       and \"label\" not in bound.arguments\n                       and \"label\" not in bound.kwargs)\n        auto_label = (bound.arguments.get(label_namer)\n                      or bound.kwargs.get(label_namer))\n\n        for k, v in bound.arguments.items():\n            if k == varkwargs_name:\n                for k1, v1 in v.items():\n                    if replace_names is None or k1 in replace_names:\n                        v[k1] = _replacer(data, v1)\n            elif k == varargs_name:\n                if replace_names is None:\n                    bound.arguments[k] = tuple(_replacer(data, v1) for v1 in v)\n            else:\n                if replace_names is None or k in replace_names:\n                    bound.arguments[k] = _replacer(data, v)\n\n        bound.apply_defaults()\n        del bound.arguments[\"data\"]\n\n        if needs_label:\n            all_kwargs = {**bound.arguments, **bound.kwargs}\n            # label_namer will be in all_kwargs as we asserted above that\n            # `label_namer is None or label_namer in arg_names`.\n            label = _label_from_arg(all_kwargs[label_namer], auto_label)\n            if \"label\" in arg_names:\n                bound.arguments[\"label\"] = label\n                try:\n                    bound.arguments.move_to_end(varkwargs_name)\n                except KeyError:\n                    pass\n            else:\n                bound.arguments.setdefault(varkwargs_name, {})[\"label\"] = label\n\n        return func(*bound.args, **bound.kwargs)",
        "begin_line": 1536,
        "end_line": 1576,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002858776443682104,
            "pseudo_dstar_susp": 0.0003443526170798898,
            "pseudo_tarantula_susp": 0.00014168319637291018,
            "pseudo_op2_susp": 0.0003443526170798898,
            "pseudo_barinel_susp": 0.00014168319637291018
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.__init__#74",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.__init__(self)",
        "snippet": "    def __init__(self):\n        self._stale = True\n        self.stale_callback = None\n        self._axes = None\n        self.figure = None\n\n        self._transform = None\n        self._transformSet = False\n        self._visible = True\n        self._animated = False\n        self._alpha = None\n        self.clipbox = None\n        self._clippath = None\n        self._clipon = True\n        self._label = ''\n        self._picker = None\n        self._contains = None\n        self._rasterized = None\n        self._agg_filter = None\n        self._mouseover = False\n        self.eventson = False  # fire events only if eventson\n        self._oid = 0  # an observer id\n        self._propobservers = {}  # a dict from oids to funcs\n        try:\n            self.axes = None\n        except AttributeError:\n            # Handle self.axes as a read-only property, as in Figure.\n            pass\n        self._remove_method = None\n        self._url = None\n        self._gid = None\n        self._snap = None\n        self._sketch = rcParams['path.sketch']\n        self._path_effects = rcParams['path.effects']\n        self._sticky_edges = _XYPair([], [])\n        self._in_layout = True",
        "begin_line": 74,
        "end_line": 109,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013736263736263737,
            "pseudo_dstar_susp": 0.001838235294117647,
            "pseudo_tarantula_susp": 0.0004434589800443459,
            "pseudo_op2_susp": 0.001834862385321101,
            "pseudo_barinel_susp": 0.0004434589800443459
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.convert_xunits#168",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.convert_xunits(self, x)",
        "snippet": "    def convert_xunits(self, x):\n        \"\"\"\n        Convert *x* using the unit type of the xaxis.\n\n        If the artist is not in contained in an Axes or if the xaxis does not\n        have units, *x* itself is returned.\n        \"\"\"\n        ax = getattr(self, 'axes', None)\n        if ax is None or ax.xaxis is None:\n            return x\n        return ax.xaxis.convert_units(x)",
        "begin_line": 168,
        "end_line": 178,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.754342431761787e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.stale#218",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.stale(self, val)",
        "snippet": "    def stale(self, val):\n        self._stale = val\n\n        # if the artist is animated it does not take normal part in the\n        # draw stack and is not expected to be drawn as part of the normal\n        # draw loop (when not saving) so do not propagate this change\n        if self.get_animated():\n            return\n\n        if val and self.stale_callback is not None:\n            self.stale_callback(self, val)",
        "begin_line": 218,
        "end_line": 228,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012658227848101266,
            "pseudo_dstar_susp": 0.0017482517482517483,
            "pseudo_tarantula_susp": 0.0004068348250610252,
            "pseudo_op2_susp": 0.0017482517482517483,
            "pseudo_barinel_susp": 0.0004068348250610252
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.pchanged#336",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.pchanged(self)",
        "snippet": "    def pchanged(self):\n        \"\"\"\n        Call all of the registered callbacks.\n\n        This function is triggered internally when a property is changed.\n\n        See Also\n        --------\n        add_callback\n        remove_callback\n        \"\"\"\n        for oid, func in self._propobservers.items():\n            func(self)",
        "begin_line": 336,
        "end_line": 348,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.859781498074354e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.is_transform_set#350",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.is_transform_set(self)",
        "snippet": "    def is_transform_set(self):\n        \"\"\"\n        Return whether the Artist has an explicitly set transform.\n\n        This is *True* after `.set_transform` has been called.\n        \"\"\"\n        return self._transformSet",
        "begin_line": 350,
        "end_line": 356,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001830831197363603,
            "pseudo_dstar_susp": 0.00017076502732240437,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00017076502732240437,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.set_transform#358",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.set_transform(self, t)",
        "snippet": "    def set_transform(self, t):\n        \"\"\"\n        Set the artist transform.\n\n        Parameters\n        ----------\n        t : `.Transform`\n        \"\"\"\n        self._transform = t\n        self._transformSet = True\n        self.pchanged()\n        self.stale = True",
        "begin_line": 358,
        "end_line": 369,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014084507042253522,
            "pseudo_dstar_susp": 0.0011376564277588168,
            "pseudo_tarantula_susp": 0.00045351473922902497,
            "pseudo_op2_susp": 0.0011376564277588168,
            "pseudo_barinel_susp": 0.00045351473922902497
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_transform#371",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_transform(self)",
        "snippet": "    def get_transform(self):\n        \"\"\"Return the `.Transform` instance used by this artist.\"\"\"\n        if self._transform is None:\n            self._transform = IdentityTransform()\n        elif (not isinstance(self._transform, Transform)\n              and hasattr(self._transform, '_as_mpl_transform')):\n            self._transform = self._transform._as_mpl_transform(self.axes)\n        return self._transform",
        "begin_line": 371,
        "end_line": 378,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015772870662460567,
            "pseudo_dstar_susp": 0.0012285012285012285,
            "pseudo_tarantula_susp": 0.00046948356807511736,
            "pseudo_op2_susp": 0.0012285012285012285,
            "pseudo_barinel_susp": 0.00046948356807511736
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_gid#580",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_gid(self)",
        "snippet": "    def get_gid(self):\n        \"\"\"Return the group id.\"\"\"\n        return self._gid",
        "begin_line": 580,
        "end_line": 582,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015992323684631377,
            "pseudo_dstar_susp": 0.0001405086412814388,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.0001405086412814388,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_snap#594",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_snap(self)",
        "snippet": "    def get_snap(self):\n        \"\"\"\n        Returns the snap setting.\n\n        See `.set_snap` for details.\n        \"\"\"\n        if rcParams['path.snap']:\n            return self._snap\n        else:\n            return False",
        "begin_line": 594,
        "end_line": 603,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016666666666666668,
            "pseudo_dstar_susp": 0.001272264631043257,
            "pseudo_tarantula_susp": 0.0004775549188156638,
            "pseudo_op2_susp": 0.001272264631043257,
            "pseudo_barinel_susp": 0.0004775549188156638
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.set_snap#605",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.set_snap(self, snap)",
        "snippet": "    def set_snap(self, snap):\n        \"\"\"\n        Set the snapping behavior.\n\n        Snapping aligns positions with the pixel grid, which results in\n        clearer images. For example, if a black line of 1px width was\n        defined at a position in between two pixels, the resulting image\n        would contain the interpolated value of that line in the pixel grid,\n        which would be a grey value on both adjacent pixel positions. In\n        contrast, snapping will move the line to the nearest integer pixel\n        value, so that the resulting image will really contain a 1px wide\n        black line.\n\n        Snapping is currently only supported by the Agg and MacOSX backends.\n\n        Parameters\n        ----------\n        snap : bool or None\n            Possible values:\n\n            - *True*: Snap vertices to the nearest pixel center.\n            - *False*: Do not modify vertex positions.\n            - *None*: (auto) If the path contains only rectilinear line\n              segments, round to the nearest pixel center.\n        \"\"\"\n        self._snap = snap\n        self.stale = True",
        "begin_line": 605,
        "end_line": 631,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_sketch_params#633",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_sketch_params(self)",
        "snippet": "    def get_sketch_params(self):\n        \"\"\"\n        Returns the sketch parameters for the artist.\n\n        Returns\n        -------\n        sketch_params : tuple or None\n\n            A 3-tuple with the following elements:\n\n            - *scale*: The amplitude of the wiggle perpendicular to the\n              source line.\n            - *length*: The length of the wiggle along the line.\n            - *randomness*: The scale factor by which the length is\n              shrunken or expanded.\n\n            Returns *None* if no sketch parameters were set.\n        \"\"\"\n        return self._sketch",
        "begin_line": 633,
        "end_line": 651,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_path_effects#688",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_path_effects(self)",
        "snippet": "    def get_path_effects(self):\n        return self._path_effects",
        "begin_line": 688,
        "end_line": 689,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00025940337224383917,
            "pseudo_dstar_susp": 0.0002795638803466592,
            "pseudo_tarantula_susp": 0.0003696857670979667,
            "pseudo_op2_susp": 0.0002795638803466592,
            "pseudo_barinel_susp": 0.0003696857670979667
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_figure#691",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_figure(self)",
        "snippet": "    def get_figure(self):\n        \"\"\"Return the `.Figure` instance the artist belongs to.\"\"\"\n        return self.figure",
        "begin_line": 691,
        "end_line": 693,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.set_figure#695",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.set_figure(self, fig)",
        "snippet": "    def set_figure(self, fig):\n        \"\"\"\n        Set the `.Figure` instance the artist belongs to.\n\n        Parameters\n        ----------\n        fig : `.Figure`\n        \"\"\"\n        # if this is a no-op just return\n        if self.figure is fig:\n            return\n        # if we currently have a figure (the case of both `self.figure`\n        # and *fig* being none is taken care of above) we then user is\n        # trying to change the figure an artist is associated with which\n        # is not allowed for the same reason as adding the same instance\n        # to more than one Axes\n        if self.figure is not None:\n            raise RuntimeError(\"Can not put single artist in \"\n                               \"more than one figure\")\n        self.figure = fig\n        if self.figure and self.figure is not self:\n            self.pchanged()\n        self.stale = True",
        "begin_line": 695,
        "end_line": 717,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.set_clip_path#731",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.set_clip_path(self, path, transform=None)",
        "snippet": "    def set_clip_path(self, path, transform=None):\n        \"\"\"\n        Set the artist's clip path.\n\n        Parameters\n        ----------\n        path : `.Patch` or `.Path` or `.TransformedPath` or None\n            The clip path. If given a `.Path`, *transform* must be provided as\n            well. If *None*, a previously set clip path is removed.\n        transform : `~matplotlib.transforms.Transform`, optional\n            Only used if *path* is a `.Path`, in which case the given `.Path`\n            is converted to a `.TransformedPath` using *transform*.\n\n        Notes\n        -----\n        For efficiency, if *path* is a `.Rectangle` this method will set the\n        clipping box to the corresponding rectangle and set the clipping path\n        to ``None``.\n\n        For technical reasons (support of ``setp``), a tuple\n        (*path*, *transform*) is also accepted as a single positional\n        parameter.\n\n        .. ACCEPTS: Patch or (Path, Transform) or None\n        \"\"\"\n        from matplotlib.patches import Patch, Rectangle\n\n        success = False\n        if transform is None:\n            if isinstance(path, Rectangle):\n                self.clipbox = TransformedBbox(Bbox.unit(),\n                                               path.get_transform())\n                self._clippath = None\n                success = True\n            elif isinstance(path, Patch):\n                self._clippath = TransformedPatchPath(path)\n                success = True\n            elif isinstance(path, tuple):\n                path, transform = path\n\n        if path is None:\n            self._clippath = None\n            success = True\n        elif isinstance(path, Path):\n            self._clippath = TransformedPath(path, transform)\n            success = True\n        elif isinstance(path, TransformedPatchPath):\n            self._clippath = path\n            success = True\n        elif isinstance(path, TransformedPath):\n            self._clippath = path\n            success = True\n\n        if not success:\n            raise TypeError(\n                \"Invalid arguments to set_clip_path, of type {} and {}\"\n                .format(type(path).__name__, type(transform).__name__))\n        # This may result in the callbacks being hit twice, but guarantees they\n        # will be hit at least once.\n        self.pchanged()\n        self.stale = True",
        "begin_line": 731,
        "end_line": 791,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021353833013025838,
            "pseudo_dstar_susp": 0.00030248033877797946,
            "pseudo_tarantula_susp": 0.00012169891687963977,
            "pseudo_op2_susp": 0.00030248033877797946,
            "pseudo_barinel_susp": 0.00012169891687963977
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_alpha#793",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_alpha(self)",
        "snippet": "    def get_alpha(self):\n        \"\"\"\n        Return the alpha value used for blending - not supported on all\n        backends\n        \"\"\"\n        return self._alpha",
        "begin_line": 793,
        "end_line": 798,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00024838549428713363,
            "pseudo_dstar_susp": 0.00021800741225201656,
            "pseudo_tarantula_susp": 0.0004046944556859571,
            "pseudo_op2_susp": 0.00021800741225201656,
            "pseudo_barinel_susp": 0.0004046944556859571
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_visible#800",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_visible(self)",
        "snippet": "    def get_visible(self):\n        \"\"\"Return the visibility.\"\"\"\n        return self._visible",
        "begin_line": 800,
        "end_line": 802,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015527950310559005,
            "pseudo_dstar_susp": 0.001221001221001221,
            "pseudo_tarantula_susp": 0.00046816479400749064,
            "pseudo_op2_susp": 0.001221001221001221,
            "pseudo_barinel_susp": 0.00046816479400749064
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.set_clip_on#841",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.set_clip_on(self, b)",
        "snippet": "    def set_clip_on(self, b):\n        \"\"\"\n        Set whether the artist uses clipping.\n\n        When False artists will be visible out side of the axes which\n        can lead to unexpected results.\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        self._clipon = b\n        # This may result in the callbacks being hit twice, but ensures they\n        # are hit at least once\n        self.pchanged()\n        self.stale = True",
        "begin_line": 841,
        "end_line": 856,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist._set_gc_clip#858",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist._set_gc_clip(self, gc)",
        "snippet": "    def _set_gc_clip(self, gc):\n        'Set the clip properly for the gc'\n        if self._clipon:\n            if self.clipbox is not None:\n                gc.set_clip_rectangle(self.clipbox)\n            gc.set_clip_path(self._clippath)\n        else:\n            gc.set_clip_rectangle(None)\n            gc.set_clip_path(None)",
        "begin_line": 858,
        "end_line": 866,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002004008016032064,
            "pseudo_dstar_susp": 0.0012953367875647669,
            "pseudo_tarantula_susp": 0.0004899559039686428,
            "pseudo_op2_susp": 0.0012953367875647669,
            "pseudo_barinel_susp": 0.0004899559039686428
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_rasterized#868",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_rasterized(self)",
        "snippet": "    def get_rasterized(self):\n        \"\"\"Return whether the artist is to be rasterized.\"\"\"\n        return self._rasterized",
        "begin_line": 868,
        "end_line": 870,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019179133103183735,
            "pseudo_dstar_susp": 0.00016220600162206002,
            "pseudo_tarantula_susp": 0.0003696857670979667,
            "pseudo_op2_susp": 0.00016220600162206002,
            "pseudo_barinel_susp": 0.0003696857670979667
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_agg_filter#888",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_agg_filter(self)",
        "snippet": "    def get_agg_filter(self):\n        \"\"\"Return filter function to be used for agg filter.\"\"\"\n        return self._agg_filter",
        "begin_line": 888,
        "end_line": 890,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013698630136986301,
            "pseudo_dstar_susp": 0.002012072434607646,
            "pseudo_tarantula_susp": 0.00041946308724832214,
            "pseudo_op2_susp": 0.002012072434607646,
            "pseudo_barinel_susp": 0.00041946308724832214
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.set_alpha#923",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.set_alpha(self, alpha)",
        "snippet": "    def set_alpha(self, alpha):\n        \"\"\"\n        Set the alpha value used for blending - not supported on all backends.\n\n        Parameters\n        ----------\n        alpha : float or None\n        \"\"\"\n        if alpha is not None and not isinstance(alpha, Number):\n            raise TypeError('alpha must be a float or None')\n        self._alpha = alpha\n        self.pchanged()\n        self.stale = True",
        "begin_line": 923,
        "end_line": 935,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002654632333421821,
            "pseudo_dstar_susp": 0.0002512562814070352,
            "pseudo_tarantula_susp": 0.00026917900403768504,
            "pseudo_op2_susp": 0.0002512562814070352,
            "pseudo_barinel_susp": 0.00026917900403768504
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.set_visible#937",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.set_visible(self, b)",
        "snippet": "    def set_visible(self, b):\n        \"\"\"\n        Set the artist's visibility.\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        self._visible = b\n        self.pchanged()\n        self.stale = True",
        "begin_line": 937,
        "end_line": 947,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018463810930576072,
            "pseudo_dstar_susp": 0.00016136840406648378,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.00016136840406648378,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.set_in_layout#961",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.set_in_layout(self, in_layout)",
        "snippet": "    def set_in_layout(self, in_layout):\n        \"\"\"\n        Set if artist is to be included in layout calculations,\n        E.g. :doc:`/tutorials/intermediate/constrainedlayout_guide`,\n        `.Figure.tight_layout()`, and\n        ``fig.savefig(fname, bbox_inches='tight')``.\n\n        Parameters\n        ----------\n        in_layout : bool\n        \"\"\"\n        self._in_layout = in_layout",
        "begin_line": 961,
        "end_line": 972,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018463810930576072,
            "pseudo_dstar_susp": 0.00016136840406648378,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.00016136840406648378,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.update#974",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.update(self, props)",
        "snippet": "    def update(self, props):\n        \"\"\"\n        Update this artist's properties from the dictionary *props*.\n        \"\"\"\n        def _update_property(self, k, v):\n            \"\"\"Sorting out how to update property (setter or setattr).\n\n            Parameters\n            ----------\n            k : str\n                The name of property to update\n            v : obj\n                The value to assign to the property\n\n            Returns\n            -------\n            ret : obj or None\n                If using a `set_*` method return it's return, else None.\n            \"\"\"\n            k = k.lower()\n            # white list attributes we want to be able to update through\n            # art.update, art.set, setp\n            if k in {'axes'}:\n                return setattr(self, k, v)\n            else:\n                func = getattr(self, 'set_' + k, None)\n                if not callable(func):\n                    raise AttributeError('{!r} object has no property {!r}'\n                                         .format(type(self).__name__, k))\n                return func(v)\n\n        with cbook._setattr_cm(self, eventson=False):\n            ret = [_update_property(self, k, v) for k, v in props.items()]\n\n        if len(ret):\n            self.pchanged()\n            self.stale = True\n        return ret",
        "begin_line": 974,
        "end_line": 1011,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001402524544179523,
            "pseudo_dstar_susp": 0.0011337868480725624,
            "pseudo_tarantula_susp": 0.00045248868778280545,
            "pseudo_op2_susp": 0.0011337868480725624,
            "pseudo_barinel_susp": 0.00045248868778280545
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist._update_property#978",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist._update_property(self, k, v)",
        "snippet": "        def _update_property(self, k, v):\n            \"\"\"Sorting out how to update property (setter or setattr).\n\n            Parameters\n            ----------\n            k : str\n                The name of property to update\n            v : obj\n                The value to assign to the property\n\n            Returns\n            -------\n            ret : obj or None\n                If using a `set_*` method return it's return, else None.\n            \"\"\"\n            k = k.lower()\n            # white list attributes we want to be able to update through\n            # art.update, art.set, setp\n            if k in {'axes'}:\n                return setattr(self, k, v)\n            else:\n                func = getattr(self, 'set_' + k, None)\n                if not callable(func):\n                    raise AttributeError('{!r} object has no property {!r}'\n                                         .format(type(self).__name__, k))\n                return func(v)",
        "begin_line": 978,
        "end_line": 1003,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001402524544179523,
            "pseudo_dstar_susp": 0.0019801980198019802,
            "pseudo_tarantula_susp": 0.00045248868778280545,
            "pseudo_op2_susp": 0.0019723865877712033,
            "pseudo_barinel_susp": 0.00045248868778280545
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_label#1013",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_label(self)",
        "snippet": "    def get_label(self):\n        \"\"\"Return the label used for this artist in the legend.\"\"\"\n        return self._label",
        "begin_line": 1013,
        "end_line": 1015,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.701193685021179e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_zorder#1033",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_zorder(self)",
        "snippet": "    def get_zorder(self):\n        \"\"\"Return the artist's zorder.\"\"\"\n        return self.zorder",
        "begin_line": 1033,
        "end_line": 1035,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002004008016032064,
            "pseudo_dstar_susp": 0.0012953367875647669,
            "pseudo_tarantula_susp": 0.0004899559039686428,
            "pseudo_op2_susp": 0.0012953367875647669,
            "pseudo_barinel_susp": 0.0004899559039686428
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.update_from#1074",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.update_from(self, other)",
        "snippet": "    def update_from(self, other):\n        'Copy properties from *other* to *self*.'\n        self._transform = other._transform\n        self._transformSet = other._transformSet\n        self._visible = other._visible\n        self._alpha = other._alpha\n        self.clipbox = other.clipbox\n        self._clipon = other._clipon\n        self._clippath = other._clippath\n        self._label = other._label\n        self._sketch = other._sketch\n        self._path_effects = other._path_effects\n        self.sticky_edges.x[:] = other.sticky_edges.x[:]\n        self.sticky_edges.y[:] = other.sticky_edges.y[:]\n        self.pchanged()\n        self.stale = True",
        "begin_line": 1074,
        "end_line": 1089,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005120327700972862,
            "pseudo_dstar_susp": 0.00042936882782310007,
            "pseudo_tarantula_susp": 0.00021034917963819942,
            "pseudo_op2_susp": 0.00042936882782310007,
            "pseudo_barinel_susp": 0.00021034917963819942
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.set#1095",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.set(self, **kwargs)",
        "snippet": "    def set(self, **kwargs):\n        \"\"\"A property batch setter.  Pass *kwargs* to set properties.\"\"\"\n        kwargs = cbook.normalize_kwargs(kwargs, self)\n        props = OrderedDict(\n            sorted(kwargs.items(), reverse=True,\n                   key=lambda x: (self._prop_order.get(x[0], 0), x[0])))\n        return self.update(props)",
        "begin_line": 1095,
        "end_line": 1101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002748007694421544,
            "pseudo_dstar_susp": 0.00034518467380048324,
            "pseudo_tarantula_susp": 0.00013236267372600927,
            "pseudo_op2_susp": 0.00034518467380048324,
            "pseudo_barinel_susp": 0.00013236267372600927
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.findobj#1103",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.findobj(self, match=None, include_self=True)",
        "snippet": "    def findobj(self, match=None, include_self=True):\n        \"\"\"\n        Find artist objects.\n\n        Recursively find all `.Artist` instances contained in the artist.\n\n        Parameters\n        ----------\n        match\n            A filter criterion for the matches. This can be\n\n            - *None*: Return all objects contained in artist.\n            - A function with signature ``def match(artist: Artist) -> bool``.\n              The result will only contain artists for which the function\n              returns *True*.\n            - A class instance: e.g., `.Line2D`. The result will only contain\n              artists of this class or its subclasses (``isinstance`` check).\n\n        include_self : bool\n            Include *self* in the list to be checked for a match.\n\n        Returns\n        -------\n        artists : list of `.Artist`\n\n        \"\"\"\n        if match is None:  # always return True\n            def matchfunc(x):\n                return True\n        elif isinstance(match, type) and issubclass(match, Artist):\n            def matchfunc(x):\n                return isinstance(x, match)\n        elif callable(match):\n            matchfunc = match\n        else:\n            raise ValueError('match must be None, a matplotlib.artist.Artist '\n                             'subclass, or a callable')\n\n        artists = sum([c.findobj(matchfunc) for c in self.get_children()], [])\n        if include_self and matchfunc(self):\n            artists.append(self)\n        return artists",
        "begin_line": 1103,
        "end_line": 1144,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.format_cursor_data#1177",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.format_cursor_data(self, data)",
        "snippet": "    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets.\n\n        See Also\n        --------\n        get_cursor_data\n        \"\"\"\n        try:\n            data[0]\n        except (TypeError, IndexError):\n            data = [data]\n        data_str = ', '.join('{:0.3g}'.format(item) for item in data\n                             if isinstance(item, Number))\n        return \"[\" + data_str + \"]\"",
        "begin_line": 1177,
        "end_line": 1199,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.mouseover#1202",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.mouseover(self)",
        "snippet": "    def mouseover(self):\n        \"\"\"\n        If this property is set to *True*, the artist will be queried for\n        custom context information when the mouse cursor moves over it.\n\n        See also :meth:`get_cursor_data`, :class:`.ToolCursorPosition` and\n        :class:`.NavigationToolbar2`.\n        \"\"\"\n        return self._mouseover",
        "begin_line": 1202,
        "end_line": 1210,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00025673940949935817,
            "pseudo_dstar_susp": 0.00033534540576794097,
            "pseudo_tarantula_susp": 0.00013078733978550875,
            "pseudo_op2_susp": 0.00033534540576794097,
            "pseudo_barinel_susp": 0.00013078733978550875
        }
    },
    {
        "name": "lib.matplotlib.artist.ArtistInspector.__init__#1230",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.ArtistInspector",
        "signature": "lib.matplotlib.artist.ArtistInspector.__init__(self, o)",
        "snippet": "    def __init__(self, o):\n        r\"\"\"\n        Initialize the artist inspector with an `Artist` or an iterable of\n        `Artist`\\s.  If an iterable is used, we assume it is a homogeneous\n        sequence (all `Artists` are of the same type) and it is your\n        responsibility to make sure this is so.\n        \"\"\"\n        if not isinstance(o, Artist):\n            if np.iterable(o):\n                o = list(o)\n                if len(o):\n                    o = o[0]\n\n        self.oorig = o\n        if not isinstance(o, type):\n            o = type(o)\n        self.o = o\n\n        self.aliasd = self.get_aliases()",
        "begin_line": 1230,
        "end_line": 1248,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012195121951219512,
            "pseudo_dstar_susp": 0.00011855364552459988,
            "pseudo_tarantula_susp": 0.00015482272797646694,
            "pseudo_op2_susp": 0.00011855364552459988,
            "pseudo_barinel_susp": 0.00015446400988569664
        }
    },
    {
        "name": "lib.matplotlib.artist.ArtistInspector.get_aliases#1250",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.ArtistInspector",
        "signature": "lib.matplotlib.artist.ArtistInspector.get_aliases(self)",
        "snippet": "    def get_aliases(self):\n        \"\"\"\n        Get a dict mapping property fullnames to sets of aliases for each alias\n        in the :class:`~matplotlib.artist.ArtistInspector`.\n\n        e.g., for lines::\n\n          {'markerfacecolor': {'mfc'},\n           'linewidth'      : {'lw'},\n          }\n        \"\"\"\n        names = [name for name in dir(self.o)\n                 if name.startswith(('set_', 'get_'))\n                    and callable(getattr(self.o, name))]\n        aliases = {}\n        for name in names:\n            func = getattr(self.o, name)\n            if not self.is_alias(func):\n                continue\n            propname = re.search(\"`({}.*)`\".format(name[:4]),  # get_.*/set_.*\n                                 inspect.getdoc(func)).group(1)\n            aliases.setdefault(propname[4:], set()).add(name[4:])\n        return aliases",
        "begin_line": 1250,
        "end_line": 1272,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.0001398014818957081,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.0001398014818957081,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.artist.ArtistInspector.get_valid_values#1278",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.ArtistInspector",
        "signature": "lib.matplotlib.artist.ArtistInspector.get_valid_values(self, attr)",
        "snippet": "    def get_valid_values(self, attr):\n        \"\"\"\n        Get the legal arguments for the setter associated with *attr*.\n\n        This is done by querying the docstring of the setter for a line that\n        begins with \"ACCEPTS:\" or \".. ACCEPTS:\", and then by looking for a\n        numpydoc-style documentation for the setter's first argument.\n        \"\"\"\n\n        name = 'set_%s' % attr\n        if not hasattr(self.o, name):\n            raise AttributeError('%s has no function %s' % (self.o, name))\n        func = getattr(self.o, name)\n\n        docstring = inspect.getdoc(func)\n        if docstring is None:\n            return 'unknown'\n\n        if docstring.startswith('Alias for '):\n            return None\n\n        match = self._get_valid_values_regex.search(docstring)\n        if match is not None:\n            return re.sub(\"\\n *\", \" \", match.group(1))\n\n        # Much faster than list(inspect.signature(func).parameters)[1],\n        # although barely relevant wrt. matplotlib's total import time.\n        param_name = func.__code__.co_varnames[1]\n        # We could set the presence * based on whether the parameter is a\n        # varargs (it can't be a varkwargs) but it's not really worth the it.\n        match = re.search(r\"(?m)^ *\\*?{} : (.+)\".format(param_name), docstring)\n        if match:\n            return match.group(1)\n\n        return 'unknown'",
        "begin_line": 1278,
        "end_line": 1312,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.artist.ArtistInspector._get_setters_and_targets#1314",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.ArtistInspector",
        "signature": "lib.matplotlib.artist.ArtistInspector._get_setters_and_targets(self)",
        "snippet": "    def _get_setters_and_targets(self):\n        \"\"\"\n        Get the attribute strings and a full path to where the setter\n        is defined for all setters in an object.\n        \"\"\"\n        setters = []\n        for name in dir(self.o):\n            if not name.startswith('set_'):\n                continue\n            func = getattr(self.o, name)\n            if (not callable(func)\n                    or len(inspect.signature(func).parameters) < 2\n                    or self.is_alias(func)):\n                continue\n            setters.append(\n                (name[4:], f\"{func.__module__}.{func.__qualname__}\"))\n        return setters",
        "begin_line": 1314,
        "end_line": 1330,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.artist.ArtistInspector.is_alias#1350",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.ArtistInspector",
        "signature": "lib.matplotlib.artist.ArtistInspector.is_alias(self, o)",
        "snippet": "    def is_alias(self, o):\n        \"\"\"Return whether method object *o* is an alias for another method.\"\"\"\n        ds = inspect.getdoc(o)\n        if ds is None:\n            return False\n        return ds.startswith('Alias for ')",
        "begin_line": 1350,
        "end_line": 1355,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.970032677133976e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.artist.ArtistInspector.aliased_name#1357",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.ArtistInspector",
        "signature": "lib.matplotlib.artist.ArtistInspector.aliased_name(self, s)",
        "snippet": "    def aliased_name(self, s):\n        \"\"\"\n        Return 'PROPNAME or alias' if *s* has an alias, else return 'PROPNAME'.\n\n        e.g., for the line markerfacecolor property, which has an\n        alias, return 'markerfacecolor or mfc' and for the transform\n        property, which does not, return 'transform'.\n        \"\"\"\n        aliases = ''.join(' or %s' % x for x in sorted(self.aliasd.get(s, [])))\n        return s + aliases",
        "begin_line": 1357,
        "end_line": 1366,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.artist.ArtistInspector.pprint_setters#1380",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.ArtistInspector",
        "signature": "lib.matplotlib.artist.ArtistInspector.pprint_setters(self, prop=None, leadingspace=2)",
        "snippet": "    def pprint_setters(self, prop=None, leadingspace=2):\n        \"\"\"\n        If *prop* is *None*, return a list of strings of all settable\n        properties and their valid values.\n\n        If *prop* is not *None*, it is a valid property name and that\n        property will be returned as a string of property : valid\n        values.\n        \"\"\"\n        if leadingspace:\n            pad = ' ' * leadingspace\n        else:\n            pad = ''\n        if prop is not None:\n            accepts = self.get_valid_values(prop)\n            return '%s%s: %s' % (pad, prop, accepts)\n\n        attrs = self._get_setters_and_targets()\n        attrs.sort()\n        lines = []\n\n        for prop, path in attrs:\n            accepts = self.get_valid_values(prop)\n            name = self.aliased_name(prop)\n\n            lines.append('%s%s: %s' % (pad, name, accepts))\n        return lines",
        "begin_line": 1380,
        "end_line": 1406,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.artist.ArtistInspector.properties#1452",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.ArtistInspector",
        "signature": "lib.matplotlib.artist.ArtistInspector.properties(self)",
        "snippet": "    def properties(self):\n        \"\"\"Return a dictionary mapping property name -> value.\"\"\"\n        o = self.oorig\n        getters = [name for name in dir(o)\n                   if name.startswith('get_') and callable(getattr(o, name))]\n        getters.sort()\n        d = {}\n        for name in getters:\n            func = getattr(o, name)\n            if self.is_alias(func):\n                continue\n            try:\n                with warnings.catch_warnings():\n                    warnings.simplefilter('ignore')\n                    val = func()\n            except Exception:\n                continue\n            else:\n                d[name[4:]] = val\n        return d",
        "begin_line": 1452,
        "end_line": 1471,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.artist.setp#1530",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist",
        "signature": "lib.matplotlib.artist.setp(obj, *args, **kwargs)",
        "snippet": "def setp(obj, *args, **kwargs):\n    \"\"\"\n    Set a property on an artist object.\n\n    matplotlib supports the use of :func:`setp` (\"set property\") and\n    :func:`getp` to set and get object properties, as well as to do\n    introspection on the object.  For example, to set the linestyle of a\n    line to be dashed, you can do::\n\n      >>> line, = plot([1, 2, 3])\n      >>> setp(line, linestyle='--')\n\n    If you want to know the valid types of arguments, you can provide\n    the name of the property you want to set without a value::\n\n      >>> setp(line, 'linestyle')\n          linestyle: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}\n\n    If you want to see all the properties that can be set, and their\n    possible values, you can do::\n\n      >>> setp(line)\n          ... long output listing omitted\n\n    You may specify another output file to `setp` if `sys.stdout` is not\n    acceptable for some reason using the *file* keyword-only argument::\n\n      >>> with fopen('output.log') as f:\n      >>>     setp(line, file=f)\n\n    :func:`setp` operates on a single instance or a iterable of\n    instances. If you are in query mode introspecting the possible\n    values, only the first instance in the sequence is used. When\n    actually setting values, all the instances will be set.  e.g.,\n    suppose you have a list of two lines, the following will make both\n    lines thicker and red::\n\n      >>> x = arange(0, 1, 0.01)\n      >>> y1 = sin(2*pi*x)\n      >>> y2 = sin(4*pi*x)\n      >>> lines = plot(x, y1, x, y2)\n      >>> setp(lines, linewidth=2, color='r')\n\n    :func:`setp` works with the MATLAB style string/value pairs or\n    with python kwargs.  For example, the following are equivalent::\n\n      >>> setp(lines, 'linewidth', 2, 'color', 'r')  # MATLAB style\n      >>> setp(lines, linewidth=2, color='r')        # python style\n    \"\"\"\n\n    if isinstance(obj, Artist):\n        objs = [obj]\n    else:\n        objs = list(cbook.flatten(obj))\n\n    if not objs:\n        return\n\n    insp = ArtistInspector(objs[0])\n\n    # file has to be popped before checking if kwargs is empty\n    printArgs = {}\n    if 'file' in kwargs:\n        printArgs['file'] = kwargs.pop('file')\n\n    if not kwargs and len(args) < 2:\n        if args:\n            print(insp.pprint_setters(prop=args[0]), **printArgs)\n        else:\n            print('\\n'.join(insp.pprint_setters()), **printArgs)\n        return\n\n    if len(args) % 2:\n        raise ValueError('The set args must be string, value pairs')\n\n    # put args into ordereddict to maintain order\n    funcvals = OrderedDict((k, v) for k, v in zip(args[::2], args[1::2]))\n    ret = [o.update(funcvals) for o in objs] + [o.set(**kwargs) for o in objs]\n    return list(cbook.flatten(ret))",
        "begin_line": 1530,
        "end_line": 1608,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patheffects.AbstractPathEffect.__init__#21",
        "src_path": "lib/matplotlib/patheffects.py",
        "class_name": "lib.matplotlib.patheffects.AbstractPathEffect",
        "signature": "lib.matplotlib.patheffects.AbstractPathEffect.__init__(self, offset=(0.0, 0.0))",
        "snippet": "    def __init__(self, offset=(0., 0.)):\n        \"\"\"\n        Parameters\n        ----------\n        offset : pair of floats\n            The offset to apply to the path, measured in points.\n        \"\"\"\n        self._offset = offset",
        "begin_line": 21,
        "end_line": 28,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00030156815440289503,
            "pseudo_dstar_susp": 0.0002549069589599796,
            "pseudo_tarantula_susp": 0.0003763643206624012,
            "pseudo_op2_susp": 0.0002549069589599796,
            "pseudo_barinel_susp": 0.0003763643206624012
        }
    },
    {
        "name": "lib.matplotlib.patheffects.AbstractPathEffect._offset_transform#30",
        "src_path": "lib/matplotlib/patheffects.py",
        "class_name": "lib.matplotlib.patheffects.AbstractPathEffect",
        "signature": "lib.matplotlib.patheffects.AbstractPathEffect._offset_transform(self, renderer)",
        "snippet": "    def _offset_transform(self, renderer):\n        \"\"\"Apply the offset to the given transform.\"\"\"\n        return mtransforms.Affine2D().translate(\n            *map(renderer.points_to_pixels, self._offset))",
        "begin_line": 30,
        "end_line": 33,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00033400133600534405,
            "pseudo_dstar_susp": 0.0002986857825567503,
            "pseudo_tarantula_susp": 0.00043878894251864854,
            "pseudo_op2_susp": 0.0002986857825567503,
            "pseudo_barinel_susp": 0.00043878894251864854
        }
    },
    {
        "name": "lib.matplotlib.patheffects.AbstractPathEffect._update_gc#35",
        "src_path": "lib/matplotlib/patheffects.py",
        "class_name": "lib.matplotlib.patheffects.AbstractPathEffect",
        "signature": "lib.matplotlib.patheffects.AbstractPathEffect._update_gc(self, gc, new_gc_dict)",
        "snippet": "    def _update_gc(self, gc, new_gc_dict):\n        \"\"\"\n        Update the given GraphicsCollection with the given\n        dictionary of properties. The keys in the dictionary are used to\n        identify the appropriate set_ method on the gc.\n\n        \"\"\"\n        new_gc_dict = new_gc_dict.copy()\n\n        dashes = new_gc_dict.pop(\"dashes\", None)\n        if dashes:\n            gc.set_dashes(**dashes)\n\n        for k, v in new_gc_dict.items():\n            set_method = getattr(gc, 'set_' + k, None)\n            if not callable(set_method):\n                raise AttributeError('Unknown property {0}'.format(k))\n            set_method(v)\n        return gc",
        "begin_line": 35,
        "end_line": 53,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043649061545176777,
            "pseudo_dstar_susp": 0.0003096934035305048,
            "pseudo_tarantula_susp": 0.00040666937779585197,
            "pseudo_op2_susp": 0.0003096934035305048,
            "pseudo_barinel_susp": 0.00040666937779585197
        }
    },
    {
        "name": "lib.matplotlib.patheffects.AbstractPathEffect.draw_path#55",
        "src_path": "lib/matplotlib/patheffects.py",
        "class_name": "lib.matplotlib.patheffects.AbstractPathEffect",
        "signature": "lib.matplotlib.patheffects.AbstractPathEffect.draw_path(self, renderer, gc, tpath, affine, rgbFace=None)",
        "snippet": "    def draw_path(self, renderer, gc, tpath, affine, rgbFace=None):\n        \"\"\"\n        Derived should override this method. The arguments are the same\n        as :meth:`matplotlib.backend_bases.RendererBase.draw_path`\n        except the first argument is a renderer.\n\n        \"\"\"\n        # Get the real renderer, not a PathEffectRenderer.\n        if isinstance(renderer, PathEffectRenderer):\n            renderer = renderer._renderer\n        return renderer.draw_path(gc, tpath, affine, rgbFace)",
        "begin_line": 55,
        "end_line": 65,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00031279324366593683,
            "pseudo_dstar_susp": 0.00026041666666666666,
            "pseudo_tarantula_susp": 0.00039108330074305825,
            "pseudo_op2_susp": 0.00026041666666666666,
            "pseudo_barinel_susp": 0.00039108330074305825
        }
    },
    {
        "name": "lib.matplotlib.patheffects.PathEffectRenderer.__init__#81",
        "src_path": "lib/matplotlib/patheffects.py",
        "class_name": "lib.matplotlib.patheffects.PathEffectRenderer",
        "signature": "lib.matplotlib.patheffects.PathEffectRenderer.__init__(self, path_effects, renderer)",
        "snippet": "    def __init__(self, path_effects, renderer):\n        \"\"\"\n        Parameters\n        ----------\n        path_effects : iterable of :class:`AbstractPathEffect`\n            The path effects which this renderer represents.\n        renderer : :class:`matplotlib.backend_bases.RendererBase` instance\n\n        \"\"\"\n        self._path_effects = path_effects\n        self._renderer = renderer",
        "begin_line": 81,
        "end_line": 91,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00032862306933946765,
            "pseudo_dstar_susp": 0.00027862914460852607,
            "pseudo_tarantula_susp": 0.0004170141784820684,
            "pseudo_op2_susp": 0.00027862914460852607,
            "pseudo_barinel_susp": 0.0004170141784820684
        }
    },
    {
        "name": "lib.matplotlib.patheffects.PathEffectRenderer.draw_path#96",
        "src_path": "lib/matplotlib/patheffects.py",
        "class_name": "lib.matplotlib.patheffects.PathEffectRenderer",
        "signature": "lib.matplotlib.patheffects.PathEffectRenderer.draw_path(self, gc, tpath, affine, rgbFace=None)",
        "snippet": "    def draw_path(self, gc, tpath, affine, rgbFace=None):\n        for path_effect in self._path_effects:\n            path_effect.draw_path(self._renderer, gc, tpath, affine,\n                                  rgbFace)",
        "begin_line": 96,
        "end_line": 99,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003372681281618887,
            "pseudo_dstar_susp": 0.0002990430622009569,
            "pseudo_tarantula_susp": 0.00043956043956043956,
            "pseudo_op2_susp": 0.0002990430622009569,
            "pseudo_barinel_susp": 0.00043956043956043956
        }
    },
    {
        "name": "lib.matplotlib.patheffects.PathEffectRenderer._draw_text_as_path#139",
        "src_path": "lib/matplotlib/patheffects.py",
        "class_name": "lib.matplotlib.patheffects.PathEffectRenderer",
        "signature": "lib.matplotlib.patheffects.PathEffectRenderer._draw_text_as_path(self, gc, x, y, s, prop, angle, ismath)",
        "snippet": "    def _draw_text_as_path(self, gc, x, y, s, prop, angle, ismath):\n        # Implements the naive text drawing as is found in RendererBase.\n        path, transform = self._get_text_path_transform(x, y, s, prop,\n                                                        angle, ismath)\n        color = gc.get_rgb()\n        gc.set_linewidth(0.0)\n        self.draw_path(gc, path, transform, rgbFace=color)",
        "begin_line": 139,
        "end_line": 145,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000328515111695138,
            "pseudo_dstar_susp": 0.0002775464890369137,
            "pseudo_tarantula_susp": 0.00044365572315882877,
            "pseudo_op2_susp": 0.0002775464890369137,
            "pseudo_barinel_susp": 0.00044365572315882877
        }
    },
    {
        "name": "lib.matplotlib.patheffects.PathEffectRenderer.__getattribute__#147",
        "src_path": "lib/matplotlib/patheffects.py",
        "class_name": "lib.matplotlib.patheffects.PathEffectRenderer",
        "signature": "lib.matplotlib.patheffects.PathEffectRenderer.__getattribute__(self, name)",
        "snippet": "    def __getattribute__(self, name):\n        if name in ['flipy', 'get_canvas_width_height', 'new_gc',\n                    'points_to_pixels', '_text2path', 'height', 'width']:\n            return getattr(self._renderer, name)\n        else:\n            return object.__getattribute__(self, name)",
        "begin_line": 147,
        "end_line": 152,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004,
            "pseudo_dstar_susp": 0.0003056234718826406,
            "pseudo_tarantula_susp": 0.00043821209465381246,
            "pseudo_op2_susp": 0.0003056234718826406,
            "pseudo_barinel_susp": 0.00043821209465381246
        }
    },
    {
        "name": "lib.matplotlib.patheffects.Stroke.__init__#167",
        "src_path": "lib/matplotlib/patheffects.py",
        "class_name": "lib.matplotlib.patheffects.Stroke",
        "signature": "lib.matplotlib.patheffects.Stroke.__init__(self, offset=(0, 0), **kwargs)",
        "snippet": "    def __init__(self, offset=(0, 0), **kwargs):\n        \"\"\"\n        The path will be stroked with its gc updated with the given\n        keyword arguments, i.e., the keyword arguments should be valid\n        gc parameter values.\n        \"\"\"\n        super().__init__(offset)\n        self._gc = kwargs",
        "begin_line": 167,
        "end_line": 174,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000380517503805175,
            "pseudo_dstar_susp": 0.00030156815440289503,
            "pseudo_tarantula_susp": 0.000493339911198816,
            "pseudo_op2_susp": 0.00030156815440289503,
            "pseudo_barinel_susp": 0.000493339911198816
        }
    },
    {
        "name": "lib.matplotlib.patheffects.Stroke.draw_path#176",
        "src_path": "lib/matplotlib/patheffects.py",
        "class_name": "lib.matplotlib.patheffects.Stroke",
        "signature": "lib.matplotlib.patheffects.Stroke.draw_path(self, renderer, gc, tpath, affine, rgbFace)",
        "snippet": "    def draw_path(self, renderer, gc, tpath, affine, rgbFace):\n        \"\"\"\n        Draw the path with updated gc.\n        \"\"\"\n        gc0 = renderer.new_gc()  # Don't modify gc, but a copy!\n        gc0.copy_properties(gc)\n        gc0 = self._update_gc(gc0, self._gc)\n        renderer.draw_path(\n            gc0, tpath, affine + self._offset_transform(renderer), rgbFace)\n        gc0.restore()",
        "begin_line": 176,
        "end_line": 185,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00035676061362825543,
            "pseudo_dstar_susp": 0.0002991325157044571,
            "pseudo_tarantula_susp": 0.00048496605237633366,
            "pseudo_op2_susp": 0.0002991325157044571,
            "pseudo_barinel_susp": 0.00048496605237633366
        }
    },
    {
        "name": "lib.matplotlib.patheffects.withStroke.draw_path#194",
        "src_path": "lib/matplotlib/patheffects.py",
        "class_name": "lib.matplotlib.patheffects.withStroke",
        "signature": "lib.matplotlib.patheffects.withStroke.draw_path(self, renderer, gc, tpath, affine, rgbFace)",
        "snippet": "    def draw_path(self, renderer, gc, tpath, affine, rgbFace):\n        Stroke.draw_path(self, renderer, gc, tpath, affine, rgbFace)\n        renderer.draw_path(gc, tpath, affine, rgbFace)",
        "begin_line": 194,
        "end_line": 196,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003368137420006736,
            "pseudo_dstar_susp": 0.0002942907592701589,
            "pseudo_tarantula_susp": 0.0004342162396873643,
            "pseudo_op2_susp": 0.0002942907592701589,
            "pseudo_barinel_susp": 0.0004342162396873643
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.get_registered_canvas_class#116",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases",
        "signature": "lib.matplotlib.backend_bases.get_registered_canvas_class(format)",
        "snippet": "def get_registered_canvas_class(format):\n    \"\"\"\n    Return the registered default canvas for given file format.\n    Handles deferred import of required backend.\n    \"\"\"\n    if format not in _default_backends:\n        return None\n    backend_class = _default_backends[format]\n    if isinstance(backend_class, str):\n        backend_class = importlib.import_module(backend_class).FigureCanvas\n        _default_backends[format] = backend_class\n    return backend_class",
        "begin_line": 116,
        "end_line": 127,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.87959971633441e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.RendererBase.open_group#154",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.RendererBase",
        "signature": "lib.matplotlib.backend_bases.RendererBase.open_group(self, s, gid=None)",
        "snippet": "    def open_group(self, s, gid=None):\n        \"\"\"\n        Open a grouping element with label *s* and *gid* (if set) as id.\n\n        Only used by the SVG renderer.\n        \"\"\"",
        "begin_line": 154,
        "end_line": 159,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007194244604316547,
            "pseudo_dstar_susp": 0.005405405405405406,
            "pseudo_tarantula_susp": 0.000429000429000429,
            "pseudo_op2_susp": 0.005405405405405406,
            "pseudo_barinel_susp": 0.000429000429000429
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.RendererBase.close_group#161",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.RendererBase",
        "signature": "lib.matplotlib.backend_bases.RendererBase.close_group(self, s)",
        "snippet": "    def close_group(self, s):\n        \"\"\"\n        Close a grouping element with label *s*.\n\n        Only used by the SVG renderer.\n        \"\"\"",
        "begin_line": 161,
        "end_line": 166,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00033068783068783067,
            "pseudo_dstar_susp": 0.0003916960438699569,
            "pseudo_tarantula_susp": 0.00013548299688389108,
            "pseudo_op2_susp": 0.0003916960438699569,
            "pseudo_barinel_susp": 0.00013548299688389108
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.RendererBase._iter_collection_raw_paths#304",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.RendererBase",
        "signature": "lib.matplotlib.backend_bases.RendererBase._iter_collection_raw_paths(self, master_transform, paths, all_transforms)",
        "snippet": "    def _iter_collection_raw_paths(self, master_transform, paths,\n                                   all_transforms):\n        \"\"\"\n        This is a helper method (along with :meth:`_iter_collection`) to make\n        it easier to write a space-efficient :meth:`draw_path_collection`\n        implementation in a backend.\n\n        This method yields all of the base path/transform\n        combinations, given a master transform, a list of paths and\n        list of transforms.\n\n        The arguments should be exactly what is passed in to\n        :meth:`draw_path_collection`.\n\n        The backend should take each yielded path and transform and\n        create an object that can be referenced (reused) later.\n        \"\"\"\n        Npaths = len(paths)\n        Ntransforms = len(all_transforms)\n        N = max(Npaths, Ntransforms)\n\n        if Npaths == 0:\n            return\n\n        transform = transforms.IdentityTransform()\n        for i in range(N):\n            path = paths[i % Npaths]\n            if Ntransforms:\n                transform = Affine2D(all_transforms[i % Ntransforms])\n            yield path, transform + master_transform",
        "begin_line": 304,
        "end_line": 333,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.RendererBase._iter_collection_uses_per_path#335",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.RendererBase",
        "signature": "lib.matplotlib.backend_bases.RendererBase._iter_collection_uses_per_path(self, paths, all_transforms, offsets, facecolors, edgecolors)",
        "snippet": "    def _iter_collection_uses_per_path(self, paths, all_transforms,\n                                       offsets, facecolors, edgecolors):\n        \"\"\"\n        Compute how many times each raw path object returned by\n        _iter_collection_raw_paths would be used when calling\n        _iter_collection. This is intended for the backend to decide\n        on the tradeoff between using the paths in-line and storing\n        them once and reusing. Rounds up in case the number of uses\n        is not the same for every path.\n        \"\"\"\n        Npaths = len(paths)\n        if Npaths == 0 or len(facecolors) == len(edgecolors) == 0:\n            return 0\n        Npath_ids = max(Npaths, len(all_transforms))\n        N = max(Npath_ids, len(offsets))\n        return (N + Npath_ids - 1) // Npath_ids",
        "begin_line": 335,
        "end_line": 350,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.RendererBase._iter_collection#352",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.RendererBase",
        "signature": "lib.matplotlib.backend_bases.RendererBase._iter_collection(self, gc, master_transform, all_transforms, path_ids, offsets, offsetTrans, facecolors, edgecolors, linewidths, linestyles, antialiaseds, urls, offset_position)",
        "snippet": "    def _iter_collection(self, gc, master_transform, all_transforms,\n                         path_ids, offsets, offsetTrans, facecolors,\n                         edgecolors, linewidths, linestyles,\n                         antialiaseds, urls, offset_position):\n        \"\"\"\n        This is a helper method (along with\n        :meth:`_iter_collection_raw_paths`) to make it easier to write\n        a space-efficient :meth:`draw_path_collection` implementation in a\n        backend.\n\n        This method yields all of the path, offset and graphics\n        context combinations to draw the path collection.  The caller\n        should already have looped over the results of\n        :meth:`_iter_collection_raw_paths` to draw this collection.\n\n        The arguments should be the same as that passed into\n        :meth:`draw_path_collection`, with the exception of\n        *path_ids*, which is a list of arbitrary objects that the\n        backend will use to reference one of the paths created in the\n        :meth:`_iter_collection_raw_paths` stage.\n\n        Each yielded result is of the form::\n\n           xo, yo, path_id, gc, rgbFace\n\n        where *xo*, *yo* is an offset; *path_id* is one of the elements of\n        *path_ids*; *gc* is a graphics context and *rgbFace* is a color to\n        use for filling the path.\n        \"\"\"\n        Ntransforms = len(all_transforms)\n        Npaths = len(path_ids)\n        Noffsets = len(offsets)\n        N = max(Npaths, Noffsets)\n        Nfacecolors = len(facecolors)\n        Nedgecolors = len(edgecolors)\n        Nlinewidths = len(linewidths)\n        Nlinestyles = len(linestyles)\n        Naa = len(antialiaseds)\n        Nurls = len(urls)\n\n        if (Nfacecolors == 0 and Nedgecolors == 0) or Npaths == 0:\n            return\n        if Noffsets:\n            toffsets = offsetTrans.transform(offsets)\n\n        gc0 = self.new_gc()\n        gc0.copy_properties(gc)\n\n        if Nfacecolors == 0:\n            rgbFace = None\n\n        if Nedgecolors == 0:\n            gc0.set_linewidth(0.0)\n\n        xo, yo = 0, 0\n        for i in range(N):\n            path_id = path_ids[i % Npaths]\n            if Noffsets:\n                xo, yo = toffsets[i % Noffsets]\n                if offset_position == 'data':\n                    if Ntransforms:\n                        transform = (\n                            Affine2D(all_transforms[i % Ntransforms]) +\n                            master_transform)\n                    else:\n                        transform = master_transform\n                    (xo, yo), (xp, yp) = transform.transform(\n                        [(xo, yo), (0, 0)])\n                    xo = -(xp - xo)\n                    yo = -(yp - yo)\n            if not (np.isfinite(xo) and np.isfinite(yo)):\n                continue\n            if Nfacecolors:\n                rgbFace = facecolors[i % Nfacecolors]\n            if Nedgecolors:\n                if Nlinewidths:\n                    gc0.set_linewidth(linewidths[i % Nlinewidths])\n                if Nlinestyles:\n                    gc0.set_dashes(*linestyles[i % Nlinestyles])\n                fg = edgecolors[i % Nedgecolors]\n                if len(fg) == 4:\n                    if fg[3] == 0.0:\n                        gc0.set_linewidth(0)\n                    else:\n                        gc0.set_foreground(fg)\n                else:\n                    gc0.set_foreground(fg)\n            if rgbFace is not None and len(rgbFace) == 4:\n                if rgbFace[3] == 0:\n                    rgbFace = None\n            gc0.set_antialiased(antialiaseds[i % Naa])\n            if Nurls:\n                gc0.set_url(urls[i % Nurls])\n\n            yield xo, yo, path_id, gc0, rgbFace\n        gc0.restore()",
        "begin_line": 352,
        "end_line": 447,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.RendererBase._get_text_path_transform#549",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.RendererBase",
        "signature": "lib.matplotlib.backend_bases.RendererBase._get_text_path_transform(self, x, y, s, prop, angle, ismath)",
        "snippet": "    def _get_text_path_transform(self, x, y, s, prop, angle, ismath):\n        \"\"\"\n        Return the text path and transform.\n\n        Parameters\n        ----------\n        prop : `matplotlib.font_manager.FontProperties`\n            The font property.\n        s : str\n            The text to be converted.\n        ismath : bool or \"TeX\"\n            If True, use mathtext parser. If \"TeX\", use *usetex* mode.\n        \"\"\"\n\n        text2path = self._text2path\n        fontsize = self.points_to_pixels(prop.get_size_in_points())\n        verts, codes = text2path.get_text_path(prop, s, ismath=ismath)\n\n        path = Path(verts, codes)\n        angle = np.deg2rad(angle)\n        if self.flipy():\n            width, height = self.get_canvas_width_height()\n            transform = (Affine2D()\n                         .scale(fontsize / text2path.FONT_SCALE)\n                         .rotate(angle)\n                         .translate(x, height - y))\n        else:\n            transform = (Affine2D()\n                         .scale(fontsize / text2path.FONT_SCALE)\n                         .rotate(angle)\n                         .translate(x, y))\n\n        return path, transform",
        "begin_line": 549,
        "end_line": 581,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020222446916076846,
            "pseudo_dstar_susp": 0.00017319016279875303,
            "pseudo_tarantula_susp": 0.0003850596842510589,
            "pseudo_op2_susp": 0.00017319016279875303,
            "pseudo_barinel_susp": 0.00038491147036181676
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.__init__#719",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.__init__(self)",
        "snippet": "    def __init__(self):\n        self._alpha = 1.0\n        self._forced_alpha = False  # if True, _alpha overrides A from RGBA\n        self._antialiased = 1  # use 0, 1 not True, False for extension code\n        self._capstyle = 'butt'\n        self._cliprect = None\n        self._clippath = None\n        self._dashes = None, None\n        self._joinstyle = 'round'\n        self._linestyle = 'solid'\n        self._linewidth = 1\n        self._rgb = (0.0, 0.0, 0.0, 1.0)\n        self._hatch = None\n        self._hatch_color = colors.to_rgba(rcParams['hatch.color'])\n        self._hatch_linewidth = rcParams['hatch.linewidth']\n        self._url = None\n        self._gid = None\n        self._snap = None\n        self._sketch = None",
        "begin_line": 719,
        "end_line": 737,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002066115702479339,
            "pseudo_dstar_susp": 0.0019193857965451055,
            "pseudo_tarantula_susp": 0.0005122950819672131,
            "pseudo_op2_susp": 0.0019193857965451055,
            "pseudo_barinel_susp": 0.0005122950819672131
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.copy_properties#739",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.copy_properties(self, gc)",
        "snippet": "    def copy_properties(self, gc):\n        'Copy properties from gc to self'\n        self._alpha = gc._alpha\n        self._forced_alpha = gc._forced_alpha\n        self._antialiased = gc._antialiased\n        self._capstyle = gc._capstyle\n        self._cliprect = gc._cliprect\n        self._clippath = gc._clippath\n        self._dashes = gc._dashes\n        self._joinstyle = gc._joinstyle\n        self._linestyle = gc._linestyle\n        self._linewidth = gc._linewidth\n        self._rgb = gc._rgb\n        self._hatch = gc._hatch\n        self._hatch_color = gc._hatch_color\n        self._hatch_linewidth = gc._hatch_linewidth\n        self._url = gc._url\n        self._gid = gc._gid\n        self._snap = gc._snap\n        self._sketch = gc._sketch",
        "begin_line": 739,
        "end_line": 758,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001830831197363603,
            "pseudo_dstar_susp": 0.00017076502732240437,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00017076502732240437,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_clip_path#789",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_clip_path(self)",
        "snippet": "    def get_clip_path(self):\n        \"\"\"\n        Return the clip path in the form (path, transform), where path\n        is a :class:`~matplotlib.path.Path` instance, and transform is\n        an affine transform to apply to the path before clipping.\n        \"\"\"\n        if self._clippath is not None:\n            return self._clippath.get_transformed_path_and_affine()\n        return None, None",
        "begin_line": 789,
        "end_line": 797,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013392259274139549,
            "pseudo_dstar_susp": 0.00015728216420257942,
            "pseudo_tarantula_susp": 0.00012594458438287153,
            "pseudo_op2_susp": 0.00015728216420257942,
            "pseudo_barinel_susp": 0.00012594458438287153
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_dashes#799",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_dashes(self)",
        "snippet": "    def get_dashes(self):\n        \"\"\"\n        Return the dash style as an (offset, dash-list) pair.\n\n        The dash list is a even-length list that gives the ink on, ink off in\n        points.  See p. 107 of to PostScript `blue book`_ for more info.\n\n        Default value is (None, None).\n\n        .. _blue book: https://www-cdf.fnal.gov/offline/PostScript/BLUEBOOK.PDF\n        \"\"\"\n        return self._dashes",
        "begin_line": 799,
        "end_line": 810,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002151462994836489,
            "pseudo_dstar_susp": 0.00019630938358853554,
            "pseudo_tarantula_susp": 0.0002973535533749628,
            "pseudo_op2_susp": 0.00019630938358853554,
            "pseudo_barinel_susp": 0.0002973535533749628
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_snap#839",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_snap(self)",
        "snippet": "    def get_snap(self):\n        \"\"\"\n        Returns the snap setting, which can be:\n\n        * True: snap vertices to the nearest pixel center\n        * False: leave vertices as-is\n        * None: (auto) If the path contains only rectilinear line segments,\n          round to the nearest pixel center\n        \"\"\"\n        return self._snap",
        "begin_line": 839,
        "end_line": 848,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_alpha#850",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_alpha(self, alpha)",
        "snippet": "    def set_alpha(self, alpha):\n        \"\"\"\n        Set the alpha value used for blending - not supported on all backends.\n\n        If ``alpha=None`` (the default), the alpha components of the\n        foreground and fill colors will be used to set their respective\n        transparencies (where applicable); otherwise, ``alpha`` will override\n        them.\n        \"\"\"\n        if alpha is not None:\n            self._alpha = alpha\n            self._forced_alpha = True\n        else:\n            self._alpha = 1.0\n            self._forced_alpha = False\n        self.set_foreground(self._rgb, isRGBA=True)",
        "begin_line": 850,
        "end_line": 865,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002004008016032064,
            "pseudo_dstar_susp": 0.002008032128514056,
            "pseudo_tarantula_susp": 0.0004899559039686428,
            "pseudo_op2_susp": 0.002008032128514056,
            "pseudo_barinel_susp": 0.0004899559039686428
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_antialiased#867",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_antialiased(self, b)",
        "snippet": "    def set_antialiased(self, b):\n        \"\"\"Set whether object should be drawn with antialiased rendering.\"\"\"\n        # Use ints to make life easier on extension code trying to read the gc.\n        self._antialiased = int(bool(b))",
        "begin_line": 867,
        "end_line": 870,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001610305958132045,
            "pseudo_dstar_susp": 0.0012437810945273632,
            "pseudo_tarantula_susp": 0.00047281323877068556,
            "pseudo_op2_susp": 0.0012437810945273632,
            "pseudo_barinel_susp": 0.00047281323877068556
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_capstyle#872",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_capstyle(self, cs)",
        "snippet": "    def set_capstyle(self, cs):\n        \"\"\"Set the capstyle to be one of ('butt', 'round', 'projecting').\"\"\"\n        cbook._check_in_list(['butt', 'round', 'projecting'], cs=cs)\n        self._capstyle = cs",
        "begin_line": 872,
        "end_line": 875,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016666666666666668,
            "pseudo_dstar_susp": 0.001272264631043257,
            "pseudo_tarantula_susp": 0.0004775549188156638,
            "pseudo_op2_susp": 0.001272264631043257,
            "pseudo_barinel_susp": 0.0004775549188156638
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_clip_path#883",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_clip_path(self, path)",
        "snippet": "    def set_clip_path(self, path):\n        \"\"\"\n        Set the clip path and transformation.\n\n        Parameters\n        ----------\n        path : `~matplotlib.transforms.TransformedPath` or None\n        \"\"\"\n        cbook._check_isinstance((transforms.TransformedPath, None), path=path)\n        self._clippath = path",
        "begin_line": 883,
        "end_line": 892,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016666666666666668,
            "pseudo_dstar_susp": 0.001272264631043257,
            "pseudo_tarantula_susp": 0.0004775549188156638,
            "pseudo_op2_susp": 0.001272264631043257,
            "pseudo_barinel_susp": 0.0004775549188156638
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_dashes#894",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_dashes(self, dash_offset, dash_list)",
        "snippet": "    def set_dashes(self, dash_offset, dash_list):\n        \"\"\"\n        Set the dash style for the gc.\n\n        Parameters\n        ----------\n        dash_offset : float or None\n            The offset (usually 0).\n        dash_list : array-like or None\n            The on-off sequence as points.\n\n        Notes\n        -----\n        ``(None, None)`` specifies a solid line.\n\n        See p. 107 of to PostScript `blue book`_ for more info.\n\n        .. _blue book: https://www-cdf.fnal.gov/offline/PostScript/BLUEBOOK.PDF\n        \"\"\"\n        if dash_list is not None:\n            dl = np.asarray(dash_list)\n            if np.any(dl < 0.0):\n                raise ValueError(\n                    \"All values in the dash list must be positive\")\n        self._dashes = dash_offset, dash_list",
        "begin_line": 894,
        "end_line": 918,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013089005235602095,
            "pseudo_dstar_susp": 0.001937984496124031,
            "pseudo_tarantula_susp": 0.00040551500405515005,
            "pseudo_op2_susp": 0.0019305019305019305,
            "pseudo_barinel_susp": 0.00040551500405515005
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_foreground#920",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_foreground(self, fg, isRGBA=False)",
        "snippet": "    def set_foreground(self, fg, isRGBA=False):\n        \"\"\"\n        Set the foreground color.\n\n        Parameters\n        ----------\n        fg : color\n        isRGBA : bool\n            If *fg* is known to be an ``(r, g, b, a)`` tuple, *isRGBA* can be\n            set to True to improve performance.\n        \"\"\"\n        if self._forced_alpha and isRGBA:\n            self._rgb = fg[:3] + (self._alpha,)\n        elif self._forced_alpha:\n            self._rgb = colors.to_rgba(fg, self._alpha)\n        elif isRGBA:\n            self._rgb = fg\n        else:\n            self._rgb = colors.to_rgba(fg)",
        "begin_line": 920,
        "end_line": 938,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002183406113537118,
            "pseudo_dstar_susp": 0.001326259946949602,
            "pseudo_tarantula_susp": 0.0005235602094240838,
            "pseudo_op2_susp": 0.001326259946949602,
            "pseudo_barinel_susp": 0.0005235602094240838
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_joinstyle#940",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_joinstyle(self, js)",
        "snippet": "    def set_joinstyle(self, js):\n        \"\"\"Set the join style to be one of ('miter', 'round', 'bevel').\"\"\"\n        cbook._check_in_list(['miter', 'round', 'bevel'], js=js)\n        self._joinstyle = js",
        "begin_line": 940,
        "end_line": 943,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016666666666666668,
            "pseudo_dstar_susp": 0.001272264631043257,
            "pseudo_tarantula_susp": 0.0004775549188156638,
            "pseudo_op2_susp": 0.001272264631043257,
            "pseudo_barinel_susp": 0.0004775549188156638
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_linewidth#945",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_linewidth(self, w)",
        "snippet": "    def set_linewidth(self, w):\n        \"\"\"Set the linewidth in points.\"\"\"\n        self._linewidth = float(w)",
        "begin_line": 945,
        "end_line": 947,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001610305958132045,
            "pseudo_dstar_susp": 0.0012437810945273632,
            "pseudo_tarantula_susp": 0.00047281323877068556,
            "pseudo_op2_susp": 0.0012437810945273632,
            "pseudo_barinel_susp": 0.00047281323877068556
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_url#949",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_url(self, url)",
        "snippet": "    def set_url(self, url):\n        \"\"\"Set the url for links in compatible backends.\"\"\"\n        self._url = url",
        "begin_line": 949,
        "end_line": 951,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016666666666666668,
            "pseudo_dstar_susp": 0.001272264631043257,
            "pseudo_tarantula_susp": 0.0004775549188156638,
            "pseudo_op2_susp": 0.001272264631043257,
            "pseudo_barinel_susp": 0.0004775549188156638
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_snap#957",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_snap(self, snap)",
        "snippet": "    def set_snap(self, snap):\n        \"\"\"\n        Set the snap setting which may be:\n\n        * True: snap vertices to the nearest pixel center\n        * False: leave vertices as-is\n        * None: (auto) If the path contains only rectilinear line segments,\n          round to the nearest pixel center\n        \"\"\"\n        self._snap = snap",
        "begin_line": 957,
        "end_line": 966,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019179133103183735,
            "pseudo_dstar_susp": 0.00016220600162206002,
            "pseudo_tarantula_susp": 0.0003696857670979667,
            "pseudo_op2_susp": 0.00016220600162206002,
            "pseudo_barinel_susp": 0.0003696857670979667
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_hatch#972",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_hatch(self)",
        "snippet": "    def get_hatch(self):\n        \"\"\"Get the current hatch style.\"\"\"\n        return self._hatch",
        "begin_line": 972,
        "end_line": 974,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00031486146095717883,
            "pseudo_dstar_susp": 0.0002707092582566324,
            "pseudo_tarantula_susp": 0.00035435861091424523,
            "pseudo_op2_susp": 0.0002707092582566324,
            "pseudo_barinel_susp": 0.00035435861091424523
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_hatch_path#976",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_hatch_path(self, density=6.0)",
        "snippet": "    def get_hatch_path(self, density=6.0):\n        \"\"\"Return a `Path` for the current hatch.\"\"\"\n        hatch = self.get_hatch()\n        if hatch is None:\n            return None\n        return Path.hatch(hatch, density)",
        "begin_line": 976,
        "end_line": 981,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000552791597567717,
            "pseudo_dstar_susp": 0.0004177109440267335,
            "pseudo_tarantula_susp": 0.0002121790791427965,
            "pseudo_op2_susp": 0.0004177109440267335,
            "pseudo_barinel_susp": 0.0002121790791427965
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_hatch_color#983",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_hatch_color(self)",
        "snippet": "    def get_hatch_color(self):\n        \"\"\"Get the hatch color.\"\"\"\n        return self._hatch_color",
        "begin_line": 983,
        "end_line": 985,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005691519635742744,
            "pseudo_dstar_susp": 0.000423908435777872,
            "pseudo_tarantula_susp": 0.00036536353671903543,
            "pseudo_op2_susp": 0.000423908435777872,
            "pseudo_barinel_susp": 0.00036536353671903543
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_hatch_color#987",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_hatch_color(self, hatch_color)",
        "snippet": "    def set_hatch_color(self, hatch_color):\n        \"\"\"Set the hatch color.\"\"\"\n        self._hatch_color = hatch_color",
        "begin_line": 987,
        "end_line": 989,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019179133103183735,
            "pseudo_dstar_susp": 0.00016220600162206002,
            "pseudo_tarantula_susp": 0.0003696857670979667,
            "pseudo_op2_susp": 0.00016220600162206002,
            "pseudo_barinel_susp": 0.0003696857670979667
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_hatch_linewidth#991",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_hatch_linewidth(self)",
        "snippet": "    def get_hatch_linewidth(self):\n        \"\"\"Get the hatch linewidth.\"\"\"\n        return self._hatch_linewidth",
        "begin_line": 991,
        "end_line": 993,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00130718954248366,
            "pseudo_dstar_susp": 0.0022471910112359553,
            "pseudo_tarantula_susp": 0.00037425149700598805,
            "pseudo_op2_susp": 0.0022471910112359553,
            "pseudo_barinel_susp": 0.00037425149700598805
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_sketch_params#995",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_sketch_params(self)",
        "snippet": "    def get_sketch_params(self):\n        \"\"\"\n        Return the sketch parameters for the artist.\n\n        Returns\n        -------\n        sketch_params : tuple or `None`\n\n            A 3-tuple with the following elements:\n\n            * ``scale``: The amplitude of the wiggle perpendicular to the\n              source line.\n            * ``length``: The length of the wiggle along the line.\n            * ``randomness``: The scale factor by which the length is\n              shrunken or expanded.\n\n            May return `None` if no sketch parameters were set.\n        \"\"\"\n        return self._sketch",
        "begin_line": 995,
        "end_line": 1013,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016666666666666668,
            "pseudo_dstar_susp": 0.001272264631043257,
            "pseudo_tarantula_susp": 0.0004775549188156638,
            "pseudo_op2_susp": 0.001272264631043257,
            "pseudo_barinel_susp": 0.0004775549188156638
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_sketch_params#1015",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_sketch_params(self, scale=None, length=None, randomness=None)",
        "snippet": "    def set_sketch_params(self, scale=None, length=None, randomness=None):\n        \"\"\"\n        Set the sketch parameters.\n\n        Parameters\n        ----------\n        scale : float, optional\n            The amplitude of the wiggle perpendicular to the source line, in\n            pixels.  If scale is `None`, or not provided, no sketch filter will\n            be provided.\n        length : float, default: 128\n             The length of the wiggle along the line, in pixels.\n        randomness : float, default: 16\n            The scale factor by which the length is shrunken or expanded.\n        \"\"\"\n        self._sketch = (\n            None if scale is None\n            else (scale, length or 128., randomness or 16.))",
        "begin_line": 1015,
        "end_line": 1032,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.TimerBase.__init__#1074",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.TimerBase",
        "signature": "lib.matplotlib.backend_bases.TimerBase.__init__(self, interval=None, callbacks=None)",
        "snippet": "    def __init__(self, interval=None, callbacks=None):\n        #Initialize empty callbacks list and setup default settings if necssary\n        if callbacks is None:\n            self.callbacks = []\n        else:\n            self.callbacks = callbacks[:]  # Create a copy\n\n        if interval is None:\n            self._interval = 1000\n        else:\n            self._interval = interval\n\n        self._single = False\n\n        # Default attribute for holding the GUI-specific timer object\n        self._timer = None",
        "begin_line": 1074,
        "end_line": 1089,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.970032677133976e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.TimerBase.interval#1124",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.TimerBase",
        "signature": "lib.matplotlib.backend_bases.TimerBase.interval(self, interval)",
        "snippet": "    def interval(self, interval):\n        # Force to int since none of the backends actually support fractional\n        # milliseconds, and some error or give warnings.\n        interval = int(interval)\n        self._interval = interval\n        self._timer_set_interval()",
        "begin_line": 1124,
        "end_line": 1129,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.970032677133976e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.Event.__init__#1218",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.Event",
        "signature": "lib.matplotlib.backend_bases.Event.__init__(self, name, canvas, guiEvent=None)",
        "snippet": "    def __init__(self, name, canvas, guiEvent=None):\n        self.name = name\n        self.canvas = canvas\n        self.guiEvent = guiEvent",
        "begin_line": 1218,
        "end_line": 1221,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015625,
            "pseudo_dstar_susp": 0.0022727272727272726,
            "pseudo_tarantula_susp": 0.00046882325363338024,
            "pseudo_op2_susp": 0.0022675736961451248,
            "pseudo_barinel_susp": 0.00046882325363338024
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.DrawEvent.__init__#1247",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.DrawEvent",
        "signature": "lib.matplotlib.backend_bases.DrawEvent.__init__(self, name, canvas, renderer)",
        "snippet": "    def __init__(self, name, canvas, renderer):\n        Event.__init__(self, name, canvas)\n        self.renderer = renderer",
        "begin_line": 1247,
        "end_line": 1249,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020920502092050207,
            "pseudo_dstar_susp": 0.002207505518763797,
            "pseudo_tarantula_susp": 0.0005165289256198347,
            "pseudo_op2_susp": 0.002207505518763797,
            "pseudo_barinel_susp": 0.0005149330587023687
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.LocationEvent.__init__#1301",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.LocationEvent",
        "signature": "lib.matplotlib.backend_bases.LocationEvent.__init__(self, name, canvas, x, y, guiEvent=None)",
        "snippet": "    def __init__(self, name, canvas, x, y, guiEvent=None):\n        \"\"\"\n        (*x*, *y*) in figure coords ((0, 0) = bottom left).\n        \"\"\"\n        Event.__init__(self, name, canvas, guiEvent=guiEvent)\n        # x position - pixels from left of canvas\n        self.x = int(x) if x is not None else x\n        # y position - pixels from right of canvas\n        self.y = int(y) if y is not None else y\n        self.inaxes = None  # the Axes instance if mouse us over axes\n        self.xdata = None   # x coord of mouse in data coords\n        self.ydata = None   # y coord of mouse in data coords\n\n        if x is None or y is None:\n            # cannot check if event was in axes if no (x, y) info\n            self._update_enter_leave()\n            return\n\n        if self.canvas.mouse_grabber is None:\n            self.inaxes = self.canvas.inaxes((x, y))\n        else:\n            self.inaxes = self.canvas.mouse_grabber\n\n        if self.inaxes is not None:\n            try:\n                trans = self.inaxes.transData.inverted()\n                xdata, ydata = trans.transform((x, y))\n            except ValueError:\n                pass\n            else:\n                self.xdata = xdata\n                self.ydata = ydata\n\n        self._update_enter_leave()",
        "begin_line": 1301,
        "end_line": 1334,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012717792191275595,
            "pseudo_dstar_susp": 0.0001210800339024095,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.0001210800339024095,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.LocationEvent._update_enter_leave#1336",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.LocationEvent",
        "signature": "lib.matplotlib.backend_bases.LocationEvent._update_enter_leave(self)",
        "snippet": "    def _update_enter_leave(self):\n        'process the figure/axes enter leave events'\n        if LocationEvent.lastevent is not None:\n            last = LocationEvent.lastevent\n            if last.inaxes != self.inaxes:\n                # process axes enter/leave events\n                try:\n                    if last.inaxes is not None:\n                        last.canvas.callbacks.process('axes_leave_event', last)\n                except Exception:\n                    pass\n                    # See ticket 2901582.\n                    # I think this is a valid exception to the rule\n                    # against catching all exceptions; if anything goes\n                    # wrong, we simply want to move on and process the\n                    # current event.\n                if self.inaxes is not None:\n                    self.canvas.callbacks.process('axes_enter_event', self)\n\n        else:\n            # process a figure enter event\n            if self.inaxes is not None:\n                self.canvas.callbacks.process('axes_enter_event', self)\n\n        LocationEvent.lastevent = self",
        "begin_line": 1336,
        "end_line": 1360,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011690437222352116,
            "pseudo_dstar_susp": 0.00011547344110854503,
            "pseudo_tarantula_susp": 0.00012465719272001995,
            "pseudo_op2_susp": 0.00011547344110854503,
            "pseudo_barinel_susp": 0.0001246416552411816
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.MouseEvent.__init__#1417",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.MouseEvent",
        "signature": "lib.matplotlib.backend_bases.MouseEvent.__init__(self, name, canvas, x, y, button=None, key=None, step=0, dblclick=False, guiEvent=None)",
        "snippet": "    def __init__(self, name, canvas, x, y, button=None, key=None,\n                 step=0, dblclick=False, guiEvent=None):\n        \"\"\"\n        (*x*, *y*) in figure coords ((0, 0) = bottom left)\n        button pressed None, 1, 2, 3, 'up', 'down'\n        \"\"\"\n        LocationEvent.__init__(self, name, canvas, x, y, guiEvent=guiEvent)\n        if button in MouseButton.__members__.values():\n            button = MouseButton(button)\n        self.button = button\n        self.key = key\n        self.step = step\n        self.dblclick = dblclick",
        "begin_line": 1417,
        "end_line": 1429,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backend_bases._get_renderer#1519",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases",
        "signature": "lib.matplotlib.backend_bases._get_renderer(figure, print_method)",
        "snippet": "def _get_renderer(figure, print_method):\n    \"\"\"\n    Get the renderer that would be used to save a `~.Figure`, and cache it on\n    the figure.\n    \"\"\"\n    # This is implemented by triggering a draw, then immediately jumping out of\n    # Figure.draw() by raising an exception.\n\n    class Done(Exception):\n        pass\n\n    def _draw(renderer): raise Done(renderer)\n\n    with cbook._setattr_cm(figure, draw=_draw):\n        try:\n            print_method(io.BytesIO())\n        except Done as exc:\n            figure._cachedRenderer, = exc.args\n            return figure._cachedRenderer",
        "begin_line": 1519,
        "end_line": 1537,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00013869625520110957,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00013869625520110957,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.Done._get_renderer#1519",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.Done",
        "signature": "lib.matplotlib.backend_bases.Done._get_renderer(figure, print_method)",
        "snippet": "def _get_renderer(figure, print_method):\n    \"\"\"\n    Get the renderer that would be used to save a `~.Figure`, and cache it on\n    the figure.\n    \"\"\"\n    # This is implemented by triggering a draw, then immediately jumping out of\n    # Figure.draw() by raising an exception.\n\n    class Done(Exception):\n        pass\n\n    def _draw(renderer): raise Done(renderer)\n\n    with cbook._setattr_cm(figure, draw=_draw):\n        try:\n            print_method(io.BytesIO())\n        except Done as exc:\n            figure._cachedRenderer, = exc.args\n            return figure._cachedRenderer",
        "begin_line": 1519,
        "end_line": 1537,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00013869625520110957,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00013869625520110957,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.supports_blit#1604",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.supports_blit(cls)",
        "snippet": "    def supports_blit(cls):\n        return (hasattr(cls, \"copy_from_bbox\")\n                and hasattr(cls, \"restore_region\"))",
        "begin_line": 1604,
        "end_line": 1606,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.__init__#1608",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.__init__(self, figure)",
        "snippet": "    def __init__(self, figure):\n        self._fix_ipython_backend2gui()\n        self._is_idle_drawing = True\n        self._is_saving = False\n        figure.set_canvas(self)\n        self.figure = figure\n        # a dictionary from event name to a dictionary that maps cid->func\n        self.callbacks = cbook.CallbackRegistry()\n        self.widgetlock = widgets.LockDraw()\n        self._button = None  # the button pressed\n        self._key = None  # the key pressed\n        self._lastx, self._lasty = None, None\n        self.button_pick_id = self.mpl_connect('button_press_event', self.pick)\n        self.scroll_pick_id = self.mpl_connect('scroll_event', self.pick)\n        self.mouse_grabber = None  # the axes currently grabbing mouse\n        self.toolbar = None  # NavigationToolbar2 will set me\n        self._is_idle_drawing = False",
        "begin_line": 1608,
        "end_line": 1624,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001072961373390558,
            "pseudo_dstar_susp": 0.0036101083032490976,
            "pseudo_tarantula_susp": 0.00030111412225233364,
            "pseudo_op2_susp": 0.0036101083032490976,
            "pseudo_barinel_susp": 0.00030111412225233364
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase._fix_ipython_backend2gui#1628",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase._fix_ipython_backend2gui(cls)",
        "snippet": "    def _fix_ipython_backend2gui(cls):\n        # Fix hard-coded module -> toolkit mapping in IPython (used for\n        # `ipython --auto`).  This cannot be done at import time due to\n        # ordering issues, so we do it when creating a canvas, and should only\n        # be done once per class (hence the `lru_cache(1)`).\n        if \"IPython\" not in sys.modules:\n            return\n        import IPython\n        ip = IPython.get_ipython()\n        if not ip:\n            return\n        from IPython.core import pylabtools as pt\n        if (not hasattr(pt, \"backend2gui\")\n                or not hasattr(ip, \"enable_matplotlib\")):\n            # In case we ever move the patch to IPython and remove these APIs,\n            # don't break on our side.\n            return\n        rif = getattr(cls, \"required_interactive_framework\", None)\n        backend2gui_rif = {\"qt5\": \"qt\", \"qt4\": \"qt\", \"gtk3\": \"gtk3\",\n                           \"wx\": \"wx\", \"macosx\": \"osx\"}.get(rif)\n        if backend2gui_rif:\n            if _is_non_interactive_terminal_ipython(ip):\n                ip.enable_gui(backend2gui_rif)",
        "begin_line": 1628,
        "end_line": 1650,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase._idle_draw_cntx#1653",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase._idle_draw_cntx(self)",
        "snippet": "    def _idle_draw_cntx(self):\n        self._is_idle_drawing = True\n        yield\n        self._is_idle_drawing = False",
        "begin_line": 1653,
        "end_line": 1656,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.736943907156673e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.draw_event#1675",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.draw_event(self, renderer)",
        "snippet": "    def draw_event(self, renderer):\n        \"\"\"Pass a `DrawEvent` to all functions connected to ``draw_event``.\"\"\"\n        s = 'draw_event'\n        event = DrawEvent(s, self, renderer)\n        self.callbacks.process(s, event)",
        "begin_line": 1675,
        "end_line": 1679,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004899559039686428,
            "pseudo_dstar_susp": 0.00038580246913580245,
            "pseudo_tarantula_susp": 0.00020044097013429546,
            "pseudo_op2_susp": 0.00038580246913580245,
            "pseudo_barinel_susp": 0.00020044097013429546
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.inaxes#1854",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.inaxes(self, xy)",
        "snippet": "    def inaxes(self, xy):\n        \"\"\"\n        Check if a point is in an axes.\n\n        Parameters\n        ----------\n        xy : tuple or list\n            (x, y) coordinates.\n            x position - pixels from left of canvas.\n            y position - pixels from bottom of canvas.\n\n        Returns\n        -------\n        axes: topmost axes containing the point, or None if no axes.\n\n        \"\"\"\n        axes_list = [a for a in self.figure.get_axes()\n                     if a.patch.contains_point(xy)]\n\n        if axes_list:\n            axes = cbook._topmost_artist(axes_list)\n        else:\n            axes = None\n\n        return axes",
        "begin_line": 1854,
        "end_line": 1878,
        "comment": "",
        "is_bug": true,
        "susp": {
            "pseudo_ochiai_susp": 0.0001165365342034728,
            "pseudo_dstar_susp": 0.00011516756881262236,
            "pseudo_tarantula_susp": 0.00012236906510034264,
            "pseudo_op2_susp": 0.00011516756881262236,
            "pseudo_barinel_susp": 0.00012232415902140674
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.draw#1901",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.draw(self, *args, **kwargs)",
        "snippet": "    def draw(self, *args, **kwargs):\n        \"\"\"Render the :class:`~matplotlib.figure.Figure`.\"\"\"",
        "begin_line": 1901,
        "end_line": 1902,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00047058823529411766,
            "pseudo_dstar_susp": 0.0003675119441381845,
            "pseudo_tarantula_susp": 0.0003696857670979667,
            "pseudo_op2_susp": 0.0003675119441381845,
            "pseudo_barinel_susp": 0.0003696857670979667
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.draw_idle#1904",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.draw_idle(self, *args, **kwargs)",
        "snippet": "    def draw_idle(self, *args, **kwargs):\n        \"\"\"\n        Request a widget redraw once control returns to the GUI event loop.\n\n        Even if multiple calls to `draw_idle` occur before control returns\n        to the GUI event loop, the figure will only be rendered once.\n\n        Notes\n        -----\n        Backends may choose to override the method and implement their own\n        strategy to prevent multiple renderings.\n\n        \"\"\"\n        if not self._is_idle_drawing:\n            with self._idle_draw_cntx():\n                self.draw(*args, **kwargs)",
        "begin_line": 1904,
        "end_line": 1919,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.667764583513912e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase._get_output_canvas#1954",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase._get_output_canvas(self, fmt)",
        "snippet": "    def _get_output_canvas(self, fmt):\n        \"\"\"\n        Return a canvas suitable for saving figures to a specified file format.\n\n        If necessary, this function will switch to a registered backend that\n        supports the format.\n        \"\"\"\n        # Return the current canvas if it supports the requested format.\n        if hasattr(self, 'print_{}'.format(fmt)):\n            return self\n        # Return a default canvas for the requested format, if it exists.\n        canvas_class = get_registered_canvas_class(fmt)\n        if canvas_class:\n            return self.switch_backends(canvas_class)\n        # Else report error for unsupported format.\n        raise ValueError(\n            \"Format {!r} is not supported (supported formats: {})\"\n            .format(fmt, \", \".join(sorted(self.get_supported_filetypes()))))",
        "begin_line": 1954,
        "end_line": 1971,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0025188916876574307,
            "pseudo_dstar_susp": 0.00141643059490085,
            "pseudo_tarantula_susp": 0.0005425935973955507,
            "pseudo_op2_susp": 0.00141643059490085,
            "pseudo_barinel_susp": 0.0005425935973955507
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.print_figure#1973",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.print_figure(self, filename, dpi=None, facecolor=None, edgecolor=None, orientation='portrait', format=None, *, bbox_inches=None, **kwargs)",
        "snippet": "    def print_figure(self, filename, dpi=None, facecolor=None, edgecolor=None,\n                     orientation='portrait', format=None,\n                     *, bbox_inches=None, **kwargs):\n        \"\"\"\n        Render the figure to hardcopy. Set the figure patch face and edge\n        colors.  This is useful because some of the GUIs have a gray figure\n        face color background and you'll probably want to override this on\n        hardcopy.\n\n        Parameters\n        ----------\n        filename\n            can also be a file object on image backends\n\n        orientation : {'landscape', 'portrait'}, default: 'portrait'\n            only currently applies to PostScript printing.\n\n        dpi : scalar, optional\n            the dots per inch to save the figure in; if None, use savefig.dpi\n\n        facecolor : color, default: :rc:`savefig.facecolor`\n            The facecolor of the figure.\n\n        edgecolor : color, default: :rc:`savefig.edgecolor`\n            The edgecolor of the figure.\n\n        format : str, optional\n            Force a specific file format. If not given, the format is inferred\n            from the *filename* extension, and if that fails from\n            :rc:`savefig.format`.\n\n        bbox_inches : 'tight' or `~matplotlib.transforms.Bbox`, \\\ndefault: :rc:`savefig.bbox`\n            Bbox in inches. Only the given portion of the figure is\n            saved. If 'tight', try to figure out the tight bbox of\n            the figure.\n\n        pad_inches : float, default: :rc:`savefig.pad_inches`\n            Amount of padding around the figure when *bbox_inches* is 'tight'.\n\n        bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional\n            A list of extra artists that will be considered when the\n            tight bbox is calculated.\n\n        \"\"\"\n        if format is None:\n            # get format from filename, or from backend's default filetype\n            if isinstance(filename, os.PathLike):\n                filename = os.fspath(filename)\n            if isinstance(filename, str):\n                format = os.path.splitext(filename)[1][1:]\n            if format is None or format == '':\n                format = self.get_default_filetype()\n                if isinstance(filename, str):\n                    filename = filename.rstrip('.') + '.' + format\n        format = format.lower()\n\n        # get canvas object and print method for format\n        canvas = self._get_output_canvas(format)\n        print_method = getattr(canvas, 'print_%s' % format)\n\n        if dpi is None:\n            dpi = rcParams['savefig.dpi']\n        if dpi == 'figure':\n            dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n\n        # Remove the figure manager, if any, to avoid resizing the GUI widget.\n        # Some code (e.g. Figure.show) differentiates between having *no*\n        # manager and a *None* manager, which should be fixed at some point,\n        # but this should be fine.\n        with cbook._setattr_cm(self, _is_saving=True, manager=None), \\\n                cbook._setattr_cm(self.figure, dpi=dpi):\n\n            if facecolor is None:\n                facecolor = rcParams['savefig.facecolor']\n            if edgecolor is None:\n                edgecolor = rcParams['savefig.edgecolor']\n\n            origfacecolor = self.figure.get_facecolor()\n            origedgecolor = self.figure.get_edgecolor()\n\n            self.figure.set_facecolor(facecolor)\n            self.figure.set_edgecolor(edgecolor)\n\n            if bbox_inches is None:\n                bbox_inches = rcParams['savefig.bbox']\n\n            if bbox_inches:\n                if bbox_inches == \"tight\":\n                    renderer = _get_renderer(\n                        self.figure,\n                        functools.partial(\n                            print_method, dpi=dpi, orientation=orientation))\n                    self.figure.draw(renderer)\n                    bbox_artists = kwargs.pop(\"bbox_extra_artists\", None)\n                    bbox_inches = self.figure.get_tightbbox(renderer,\n                            bbox_extra_artists=bbox_artists)\n                    pad = kwargs.pop(\"pad_inches\", None)\n                    if pad is None:\n                        pad = rcParams['savefig.pad_inches']\n\n                    bbox_inches = bbox_inches.padded(pad)\n\n                # call adjust_bbox to save only the given area\n                restore_bbox = tight_bbox.adjust_bbox(self.figure, bbox_inches,\n                                                      canvas.fixed_dpi)\n\n                _bbox_inches_restore = (bbox_inches, restore_bbox)\n            else:\n                _bbox_inches_restore = None\n\n            try:\n                result = print_method(\n                    filename,\n                    dpi=dpi,\n                    facecolor=facecolor,\n                    edgecolor=edgecolor,\n                    orientation=orientation,\n                    bbox_inches_restore=_bbox_inches_restore,\n                    **kwargs)\n            finally:\n                if bbox_inches and restore_bbox:\n                    restore_bbox()\n\n                self.figure.set_facecolor(origfacecolor)\n                self.figure.set_edgecolor(origedgecolor)\n                self.figure.set_canvas(self)\n            return result",
        "begin_line": 1973,
        "end_line": 2100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005376344086021506,
            "pseudo_dstar_susp": 0.002242152466367713,
            "pseudo_tarantula_susp": 0.0005720823798627002,
            "pseudo_op2_susp": 0.002242152466367713,
            "pseudo_barinel_susp": 0.0005720823798627002
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.get_default_filetype#2103",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.get_default_filetype(cls)",
        "snippet": "    def get_default_filetype(cls):\n        \"\"\"\n        Get the default savefig file format as specified in rcParam\n        ``savefig.format``. Returned string excludes period. Overridden\n        in backends that only support a single file type.\n        \"\"\"\n        return rcParams['savefig.format']",
        "begin_line": 2103,
        "end_line": 2109,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.667764583513912e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.get_window_title#2111",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.get_window_title(self)",
        "snippet": "    def get_window_title(self):\n        \"\"\"\n        Get the title text of the window containing the figure.\n        Return None if there is no window (e.g., a PS backend).\n        \"\"\"\n        if hasattr(self, \"manager\"):\n            return self.manager.get_window_title()",
        "begin_line": 2111,
        "end_line": 2117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.get_default_filename#2127",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.get_default_filename(self)",
        "snippet": "    def get_default_filename(self):\n        \"\"\"\n        Return a string, which includes extension, suitable for use as\n        a default filename.\n        \"\"\"\n        default_basename = self.get_window_title() or 'image'\n        default_basename = default_basename.replace(' ', '_')\n        default_filetype = self.get_default_filetype()\n        default_filename = default_basename + '.' + default_filetype\n        return default_filename",
        "begin_line": 2127,
        "end_line": 2136,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.switch_backends#2138",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.switch_backends(self, FigureCanvasClass)",
        "snippet": "    def switch_backends(self, FigureCanvasClass):\n        \"\"\"\n        Instantiate an instance of FigureCanvasClass\n\n        This is used for backend switching, e.g., to instantiate a\n        FigureCanvasPS from a FigureCanvasGTK.  Note, deep copying is\n        not done, so any changes to one of the instances (e.g., setting\n        figure size or line props), will be reflected in the other\n        \"\"\"\n        newCanvas = FigureCanvasClass(self.figure)\n        newCanvas._is_saving = self._is_saving\n        return newCanvas",
        "begin_line": 2138,
        "end_line": 2149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012195121951219512,
            "pseudo_dstar_susp": 0.00011855364552459988,
            "pseudo_tarantula_susp": 0.00015482272797646694,
            "pseudo_op2_susp": 0.00011855364552459988,
            "pseudo_barinel_susp": 0.00015446400988569664
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.mpl_connect#2151",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.mpl_connect(self, s, func)",
        "snippet": "    def mpl_connect(self, s, func):\n        \"\"\"\n        Bind function *func* to event *s*.\n\n        Parameters\n        ----------\n        s : str\n            One of the following events ids:\n\n            - 'button_press_event'\n            - 'button_release_event'\n            - 'draw_event'\n            - 'key_press_event'\n            - 'key_release_event'\n            - 'motion_notify_event'\n            - 'pick_event'\n            - 'resize_event'\n            - 'scroll_event'\n            - 'figure_enter_event',\n            - 'figure_leave_event',\n            - 'axes_enter_event',\n            - 'axes_leave_event'\n            - 'close_event'.\n\n        func : callable\n            The callback function to be executed, which must have the\n            signature::\n\n                def func(event: Event) -> Any\n\n            For the location events (button and key press/release), if the\n            mouse is over the axes, the ``inaxes`` attribute of the event will\n            be set to the `~matplotlib.axes.Axes` the event occurs is over, and\n            additionally, the variables ``xdata`` and ``ydata`` attributes will\n            be set to the mouse location in data coordinates.  See `.KeyEvent`\n            and `.MouseEvent` for more info.\n\n        Returns\n        -------\n        cid\n            A connection id that can be used with\n            `.FigureCanvasBase.mpl_disconnect`.\n\n        Examples\n        --------\n        ::\n\n            def on_press(event):\n                print('you pressed', event.button, event.xdata, event.ydata)\n\n            cid = canvas.mpl_connect('button_press_event', on_press)\n        \"\"\"\n\n        return self.callbacks.connect(s, func)",
        "begin_line": 2151,
        "end_line": 2204,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010799136069114472,
            "pseudo_dstar_susp": 0.002053388090349076,
            "pseudo_tarantula_susp": 0.0003155569580309246,
            "pseudo_op2_susp": 0.002053388090349076,
            "pseudo_barinel_susp": 0.0003155569580309246
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.mpl_disconnect#2206",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.mpl_disconnect(self, cid)",
        "snippet": "    def mpl_disconnect(self, cid):\n        \"\"\"\n        Disconnect the callback with id *cid*.\n\n        Examples\n        --------\n        ::\n\n            cid = canvas.mpl_connect('button_press_event', on_press)\n            # ... later\n            canvas.mpl_disconnect(cid)\n        \"\"\"\n        return self.callbacks.disconnect(cid)",
        "begin_line": 2206,
        "end_line": 2218,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010460251046025104,
            "pseudo_dstar_susp": 0.002770083102493075,
            "pseudo_tarantula_susp": 0.0002874389192296637,
            "pseudo_op2_susp": 0.002770083102493075,
            "pseudo_barinel_susp": 0.0002874389192296637
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.new_timer#2220",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.new_timer(self, *args, **kwargs)",
        "snippet": "    def new_timer(self, *args, **kwargs):\n        \"\"\"\n        Create a new backend-specific subclass of `.Timer`.\n\n        This is useful for getting periodic events through the backend's native\n        event loop.  Implemented only for backends with GUIs.\n\n        Other Parameters\n        ----------------\n        interval : scalar\n            Timer interval in milliseconds\n\n        callbacks : List[Tuple[callable, Tuple, Dict]]\n            Sequence of (func, args, kwargs) where ``func(*args, **kwargs)``\n            will be executed by the timer every *interval*.\n\n            Callbacks which return ``False`` or ``0`` will be removed from the\n            timer.\n\n        Examples\n        --------\n        >>> timer = fig.canvas.new_timer(callbacks=[(f1, (1, ), {'a': 3}),])\n        \"\"\"\n        return TimerBase(*args, **kwargs)",
        "begin_line": 2220,
        "end_line": 2243,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureManagerBase.__init__#2530",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureManagerBase",
        "signature": "lib.matplotlib.backend_bases.FigureManagerBase.__init__(self, canvas, num)",
        "snippet": "    def __init__(self, canvas, num):\n        self.canvas = canvas\n        canvas.manager = self  # store a pointer to parent\n        self.num = num\n\n        self.key_press_handler_id = None\n        self.button_press_handler_id = None\n        if rcParams['toolbar'] != 'toolmanager':\n            self.key_press_handler_id = self.canvas.mpl_connect(\n                'key_press_event',\n                self.key_press)\n            self.button_press_handler_id = self.canvas.mpl_connect(\n                'button_press_event',\n                self.button_press)\n\n        self.toolmanager = None\n        self.toolbar = None\n\n        @self.canvas.figure.add_axobserver\n        def notify_axes_change(fig):\n            # Called whenever the current axes is changed.\n            if self.toolmanager is None and self.toolbar is not None:\n                self.toolbar.update()",
        "begin_line": 2530,
        "end_line": 2552,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0021231422505307855,
            "pseudo_dstar_susp": 0.0036496350364963502,
            "pseudo_tarantula_susp": 0.00048756704046806434,
            "pseudo_op2_susp": 0.0036496350364963502,
            "pseudo_barinel_susp": 0.00048756704046806434
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureManagerBase.notify_axes_change#2549",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureManagerBase",
        "signature": "lib.matplotlib.backend_bases.FigureManagerBase.notify_axes_change(fig)",
        "snippet": "        def notify_axes_change(fig):\n            # Called whenever the current axes is changed.\n            if self.toolmanager is None and self.toolbar is not None:\n                self.toolbar.update()",
        "begin_line": 2549,
        "end_line": 2552,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.647598654022637e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureManagerBase.show#2554",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureManagerBase",
        "signature": "lib.matplotlib.backend_bases.FigureManagerBase.show(self)",
        "snippet": "    def show(self):\n        \"\"\"\n        For GUI backends, show the figure window and redraw.\n        For non-GUI backends, raise an exception to be caught\n        by :meth:`~matplotlib.figure.Figure.show`, for an\n        optional warning.\n        \"\"\"\n        raise NonGuiException()",
        "begin_line": 2554,
        "end_line": 2561,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureManagerBase.destroy#2563",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureManagerBase",
        "signature": "lib.matplotlib.backend_bases.FigureManagerBase.destroy(self)",
        "snippet": "    def destroy(self):\n        pass",
        "begin_line": 2563,
        "end_line": 2564,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00029994001199760045,
            "pseudo_dstar_susp": 0.00027210884353741496,
            "pseudo_tarantula_susp": 0.0003013863773357444,
            "pseudo_op2_susp": 0.00027210884353741496,
            "pseudo_barinel_susp": 0.0003013863773357444
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureManagerBase.set_window_title#2593",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureManagerBase",
        "signature": "lib.matplotlib.backend_bases.FigureManagerBase.set_window_title(self, title)",
        "snippet": "    def set_window_title(self, title):\n        \"\"\"\n        Set the title text of the window containing the figure.\n\n        This has no effect for non-GUI (e.g., PS) backends.\n        \"\"\"",
        "begin_line": 2593,
        "end_line": 2598,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011584800741427248,
            "pseudo_dstar_susp": 0.0001326259946949602,
            "pseudo_tarantula_susp": 0.0001152073732718894,
            "pseudo_op2_susp": 0.0001326259946949602,
            "pseudo_barinel_susp": 0.0001152073732718894
        }
    },
    {
        "name": "lib.matplotlib.backend_bases._Backend.new_figure_manager#3318",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases._Backend",
        "signature": "lib.matplotlib.backend_bases._Backend.new_figure_manager(cls, num, *args, **kwargs)",
        "snippet": "    def new_figure_manager(cls, num, *args, **kwargs):\n        \"\"\"Create a new figure manager instance.\"\"\"\n        # This import needs to happen here due to circular imports.\n        from matplotlib.figure import Figure\n        fig_cls = kwargs.pop('FigureClass', Figure)\n        fig = fig_cls(*args, **kwargs)\n        return cls.new_figure_manager_given_figure(num, fig)",
        "begin_line": 3318,
        "end_line": 3324,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010570824524312897,
            "pseudo_dstar_susp": 0.002881844380403458,
            "pseudo_tarantula_susp": 0.0002901073397156948,
            "pseudo_op2_susp": 0.002881844380403458,
            "pseudo_barinel_susp": 0.0002901073397156948
        }
    },
    {
        "name": "lib.matplotlib.backend_bases._Backend.new_figure_manager_given_figure#3327",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases._Backend",
        "signature": "lib.matplotlib.backend_bases._Backend.new_figure_manager_given_figure(cls, num, figure)",
        "snippet": "    def new_figure_manager_given_figure(cls, num, figure):\n        \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n        canvas = cls.FigureCanvas(figure)\n        manager = cls.FigureManager(canvas, num)\n        return manager",
        "begin_line": 3327,
        "end_line": 3331,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010416666666666667,
            "pseudo_dstar_susp": 0.0036496350364963502,
            "pseudo_tarantula_susp": 0.00028506271379703536,
            "pseudo_op2_susp": 0.0036496350364963502,
            "pseudo_barinel_susp": 0.00028506271379703536
        }
    },
    {
        "name": "lib.matplotlib.backend_bases._Backend.show#3342",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases._Backend",
        "signature": "lib.matplotlib.backend_bases._Backend.show(cls, block=None)",
        "snippet": "    def show(cls, block=None):\n        \"\"\"\n        Show all figures.\n\n        `show` blocks by calling `mainloop` if *block* is ``True``, or if it\n        is ``None`` and we are neither in IPython's ``%pylab`` mode, nor in\n        `interactive` mode.\n        \"\"\"\n        managers = Gcf.get_all_fig_managers()\n        if not managers:\n            return\n        for manager in managers:\n            # Emits a warning if the backend is non-interactive.\n            manager.canvas.figure.show()\n        if cls.mainloop is None:\n            return\n        if block is None:\n            # Hack: Are we in IPython's pylab mode?\n            from matplotlib import pyplot\n            try:\n                # IPython versions >= 0.10 tack the _needmain attribute onto\n                # pyplot.show, and always set it to False, when in %pylab mode.\n                ipython_pylab = not pyplot.show._needmain\n            except AttributeError:\n                ipython_pylab = False\n            block = not ipython_pylab and not is_interactive()\n            # TODO: The above is a hack to get the WebAgg backend working with\n            # ipython's `%pylab` mode until proper integration is implemented.\n            if get_backend() == \"WebAgg\":\n                block = True\n        if block:\n            cls.mainloop()",
        "begin_line": 3342,
        "end_line": 3373,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backend_bases._Backend.export#3378",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases._Backend",
        "signature": "lib.matplotlib.backend_bases._Backend.export(cls)",
        "snippet": "    def export(cls):\n        for name in [\n                \"backend_version\",\n                \"FigureCanvas\",\n                \"FigureManager\",\n                \"new_figure_manager\",\n                \"new_figure_manager_given_figure\",\n                \"draw_if_interactive\",\n                \"show\",\n        ]:\n            setattr(sys.modules[cls.__module__], name, getattr(cls, name))\n\n        # For back-compatibility, generate a shim `Show` class.\n\n        class Show(ShowBase):\n            def mainloop(self):\n                return cls.mainloop()\n\n        setattr(sys.modules[cls.__module__], \"Show\", Show)\n        return cls",
        "begin_line": 3378,
        "end_line": 3397,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.Show.export#3378",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.Show",
        "signature": "lib.matplotlib.backend_bases.Show.export(cls)",
        "snippet": "    def export(cls):\n        for name in [\n                \"backend_version\",\n                \"FigureCanvas\",\n                \"FigureManager\",\n                \"new_figure_manager\",\n                \"new_figure_manager_given_figure\",\n                \"draw_if_interactive\",\n                \"show\",\n        ]:\n            setattr(sys.modules[cls.__module__], name, getattr(cls, name))\n\n        # For back-compatibility, generate a shim `Show` class.\n\n        class Show(ShowBase):\n            def mainloop(self):\n                return cls.mainloop()\n\n        setattr(sys.modules[cls.__module__], \"Show\", Show)\n        return cls",
        "begin_line": 3378,
        "end_line": 3397,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.Show.mainloop#3393",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.Show",
        "signature": "lib.matplotlib.backend_bases.Show.mainloop(self)",
        "snippet": "            def mainloop(self):\n                return cls.mainloop()",
        "begin_line": 3393,
        "end_line": 3394,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser.parse#122",
        "src_path": "lib/matplotlib/fontconfig_pattern.py",
        "class_name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser",
        "signature": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser.parse(self, pattern)",
        "snippet": "    def parse(self, pattern):\n        \"\"\"\n        Parse the given fontconfig *pattern* and return a dictionary\n        of key/value pairs useful for initializing a\n        :class:`font_manager.FontProperties` object.\n        \"\"\"\n        props = self._properties = {}\n        try:\n            self._parser.parseString(pattern)\n        except self.ParseException as e:\n            raise ValueError(\n                \"Could not parse font string: '%s'\\n%s\" % (pattern, e))\n\n        self._properties = None\n\n        self._parser.resetCache()\n\n        return props",
        "begin_line": 122,
        "end_line": 139,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021468441391155003,
            "pseudo_dstar_susp": 0.00022941041523285156,
            "pseudo_tarantula_susp": 0.00019175455417066154,
            "pseudo_op2_susp": 0.00022941041523285156,
            "pseudo_barinel_susp": 0.00019175455417066154
        }
    },
    {
        "name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser._family#141",
        "src_path": "lib/matplotlib/fontconfig_pattern.py",
        "class_name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser",
        "signature": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser._family(self, s, loc, tokens)",
        "snippet": "    def _family(self, s, loc, tokens):\n        return [family_unescape(r'\\1', str(tokens[0]))]",
        "begin_line": 141,
        "end_line": 142,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser._name#147",
        "src_path": "lib/matplotlib/fontconfig_pattern.py",
        "class_name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser",
        "signature": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser._name(self, s, loc, tokens)",
        "snippet": "    def _name(self, s, loc, tokens):\n        return [str(tokens[0])]",
        "begin_line": 147,
        "end_line": 148,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser._value#150",
        "src_path": "lib/matplotlib/fontconfig_pattern.py",
        "class_name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser",
        "signature": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser._value(self, s, loc, tokens)",
        "snippet": "    def _value(self, s, loc, tokens):\n        return [value_unescape(r'\\1', str(tokens[0]))]",
        "begin_line": 150,
        "end_line": 151,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser._families#153",
        "src_path": "lib/matplotlib/fontconfig_pattern.py",
        "class_name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser",
        "signature": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser._families(self, s, loc, tokens)",
        "snippet": "    def _families(self, s, loc, tokens):\n        self._properties['family'] = [str(x) for x in tokens]\n        return []",
        "begin_line": 153,
        "end_line": 155,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser._property#161",
        "src_path": "lib/matplotlib/fontconfig_pattern.py",
        "class_name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser",
        "signature": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser._property(self, s, loc, tokens)",
        "snippet": "    def _property(self, s, loc, tokens):\n        if len(tokens) == 1:\n            if tokens[0] in self._constants:\n                key, val = self._constants[tokens[0]]\n                self._properties.setdefault(key, []).append(val)\n        else:\n            key = tokens[0]\n            val = tokens[1:]\n            self._properties.setdefault(key, []).extend(val)\n        return []",
        "begin_line": 161,
        "end_line": 170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.fontconfig_pattern._escape_val#180",
        "src_path": "lib/matplotlib/fontconfig_pattern.py",
        "class_name": "lib.matplotlib.fontconfig_pattern",
        "signature": "lib.matplotlib.fontconfig_pattern._escape_val(val, escape_func)",
        "snippet": "def _escape_val(val, escape_func):\n    \"\"\"\n    Given a string value or a list of string values, run each value through\n    the input escape function to make the values into legal font config\n    strings.  The result is returned as a string.\n    \"\"\"\n    if not np.iterable(val) or isinstance(val, str):\n        val = [val]\n\n    return ','.join(escape_func(r'\\\\\\1', str(x)) for x in val\n                    if x is not None)",
        "begin_line": 180,
        "end_line": 190,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.fontconfig_pattern.generate_fontconfig_pattern#193",
        "src_path": "lib/matplotlib/fontconfig_pattern.py",
        "class_name": "lib.matplotlib.fontconfig_pattern",
        "signature": "lib.matplotlib.fontconfig_pattern.generate_fontconfig_pattern(d)",
        "snippet": "def generate_fontconfig_pattern(d):\n    \"\"\"\n    Given a dictionary of key/value pairs, generates a fontconfig\n    pattern string.\n    \"\"\"\n    props = []\n\n    # Family is added first w/o a keyword\n    family = d.get_family()\n    if family is not None and family != []:\n        props.append(_escape_val(family, family_escape))\n\n    # The other keys are added as key=value\n    for key in ['style', 'variant', 'weight', 'stretch', 'file', 'size']:\n        val = getattr(d, 'get_' + key)()\n        # Don't use 'if not val' because 0 is a valid input.\n        if val is not None and val != []:\n            props.append(\":%s=%s\" % (key, _escape_val(val, value_escape)))\n\n    return ''.join(props)",
        "begin_line": 193,
        "end_line": 212,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.container.Container.__new__#17",
        "src_path": "lib/matplotlib/container.py",
        "class_name": "lib.matplotlib.container.Container",
        "signature": "lib.matplotlib.container.Container.__new__(cls, *args, **kwargs)",
        "snippet": "    def __new__(cls, *args, **kwargs):\n        return tuple.__new__(cls, args[0])",
        "begin_line": 17,
        "end_line": 18,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019735543714229328,
            "pseudo_dstar_susp": 0.0002155636990730761,
            "pseudo_tarantula_susp": 0.00018532246108228317,
            "pseudo_op2_susp": 0.0002155636990730761,
            "pseudo_barinel_susp": 0.00018532246108228317
        }
    },
    {
        "name": "lib.matplotlib.container.Container.__init__#20",
        "src_path": "lib/matplotlib/container.py",
        "class_name": "lib.matplotlib.container.Container",
        "signature": "lib.matplotlib.container.Container.__init__(self, kl, label=None)",
        "snippet": "    def __init__(self, kl, label=None):\n        self.eventson = False  # fire events only if eventson\n        self._oid = 0  # an observer id\n        self._propobservers = {}  # a dict from oids to funcs\n        self._remove_method = None\n        self.set_label(label)",
        "begin_line": 20,
        "end_line": 25,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019409937888198756,
            "pseudo_dstar_susp": 0.0002577319587628866,
            "pseudo_tarantula_susp": 0.00021934634788330776,
            "pseudo_op2_susp": 0.0002577319587628866,
            "pseudo_barinel_susp": 0.00021934634788330776
        }
    },
    {
        "name": "lib.matplotlib.container.Container.remove#27",
        "src_path": "lib/matplotlib/container.py",
        "class_name": "lib.matplotlib.container.Container",
        "signature": "lib.matplotlib.container.Container.remove(self)",
        "snippet": "    def remove(self):\n        for c in cbook.flatten(\n                self, scalarp=lambda x: isinstance(x, Artist)):\n            if c is not None:\n                c.remove()\n\n        if self._remove_method:\n            self._remove_method(self)",
        "begin_line": 27,
        "end_line": 34,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.667764583513912e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.container.Container.get_children#36",
        "src_path": "lib/matplotlib/container.py",
        "class_name": "lib.matplotlib.container.Container",
        "signature": "lib.matplotlib.container.Container.get_children(self)",
        "snippet": "    def get_children(self):\n        return [child for child in cbook.flatten(self) if child is not None]",
        "begin_line": 36,
        "end_line": 37,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022331397945511388,
            "pseudo_dstar_susp": 0.00023142791020597085,
            "pseudo_tarantula_susp": 0.0002519526329050139,
            "pseudo_op2_susp": 0.00023142791020597085,
            "pseudo_barinel_susp": 0.00025201612903225806
        }
    },
    {
        "name": "lib.matplotlib.container.BarContainer.__init__#65",
        "src_path": "lib/matplotlib/container.py",
        "class_name": "lib.matplotlib.container.BarContainer",
        "signature": "lib.matplotlib.container.BarContainer.__init__(self, patches, errorbar=None, **kwargs)",
        "snippet": "    def __init__(self, patches, errorbar=None, **kwargs):\n        self.patches = patches\n        self.errorbar = errorbar\n        Container.__init__(self, patches, **kwargs)",
        "begin_line": 65,
        "end_line": 68,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021542438604049978,
            "pseudo_dstar_susp": 0.00025233409033560434,
            "pseudo_tarantula_susp": 0.00016909029421711193,
            "pseudo_op2_susp": 0.00025233409033560434,
            "pseudo_barinel_susp": 0.00016909029421711193
        }
    },
    {
        "name": "lib.matplotlib.container.ErrorbarContainer.__init__#96",
        "src_path": "lib/matplotlib/container.py",
        "class_name": "lib.matplotlib.container.ErrorbarContainer",
        "signature": "lib.matplotlib.container.ErrorbarContainer.__init__(self, lines, has_xerr=False, has_yerr=False, **kwargs)",
        "snippet": "    def __init__(self, lines, has_xerr=False, has_yerr=False, **kwargs):\n        self.lines = lines\n        self.has_xerr = has_xerr\n        self.has_yerr = has_yerr\n        Container.__init__(self, lines, **kwargs)",
        "begin_line": 96,
        "end_line": 100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018656716417910448,
            "pseudo_dstar_susp": 0.00021281123643328368,
            "pseudo_tarantula_susp": 0.00017711654268508679,
            "pseudo_op2_susp": 0.00021281123643328368,
            "pseudo_barinel_susp": 0.00017711654268508679
        }
    },
    {
        "name": "lib.matplotlib.container.StemContainer.__init__#121",
        "src_path": "lib/matplotlib/container.py",
        "class_name": "lib.matplotlib.container.StemContainer",
        "signature": "lib.matplotlib.container.StemContainer.__init__(self, markerline_stemlines_baseline, **kwargs)",
        "snippet": "    def __init__(self, markerline_stemlines_baseline, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        markerline_stemlines_baseline : tuple\n            Tuple of ``(markerline, stemlines, baseline)``.\n            ``markerline`` contains the `LineCollection` of the markers,\n            ``stemlines`` is a `LineCollection` of the main lines,\n            ``baseline`` is the `Line2D` of the baseline.\n        \"\"\"\n        markerline, stemlines, baseline = markerline_stemlines_baseline\n        self.markerline = markerline\n        self.stemlines = stemlines\n        self.baseline = baseline\n        Container.__init__(self, markerline_stemlines_baseline, **kwargs)",
        "begin_line": 121,
        "end_line": 135,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.228420966016621e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mathtext.get_unicode_index#48",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext",
        "signature": "lib.matplotlib.mathtext.get_unicode_index(symbol, math=True)",
        "snippet": "def get_unicode_index(symbol, math=True):\n    r\"\"\"\n    Return the integer index (from the Unicode table) of *symbol*.\n\n    Parameters\n    ----------\n    symbol : str\n        A single unicode character, a TeX command (e.g. r'\\pi') or a Type1\n        symbol name (e.g. 'phi').\n    math : bool, default is True\n        If False, always treat as a single unicode character.\n    \"\"\"\n    # for a non-math symbol, simply return its unicode index\n    if not math:\n        return ord(symbol)\n    # From UTF #25: U+2212 minus sign is the preferred\n    # representation of the unary and binary minus sign rather than\n    # the ASCII-derived U+002D hyphen-minus, because minus sign is\n    # unambiguous and because it is rendered with a more desirable\n    # length, usually longer than a hyphen.\n    if symbol == '-':\n        return 0x2212\n    try:  # This will succeed if symbol is a single unicode char\n        return ord(symbol)\n    except TypeError:\n        pass\n    try:  # Is symbol a TeX symbol (i.e. \\alpha)\n        return tex2uni[symbol.strip(\"\\\\\")]\n    except KeyError:\n        raise ValueError(\n            \"'{}' is not a valid Unicode character or TeX/Type1 symbol\"\n            .format(symbol))",
        "begin_line": 48,
        "end_line": 79,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 1.0,
            "pseudo_dstar_susp": 1.0,
            "pseudo_tarantula_susp": 0.0005091649694501018,
            "pseudo_op2_susp": 1.0,
            "pseudo_barinel_susp": 0.0005091649694501018
        }
    },
    {
        "name": "lib.matplotlib.mathtext.MathtextBackend.__init__#98",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.MathtextBackend",
        "signature": "lib.matplotlib.mathtext.MathtextBackend.__init__(self)",
        "snippet": "    def __init__(self):\n        self.width = 0\n        self.height = 0\n        self.depth = 0",
        "begin_line": 98,
        "end_line": 101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.1111111111111111,
            "pseudo_dstar_susp": 0.0625,
            "pseudo_tarantula_susp": 0.0005099439061703213,
            "pseudo_op2_susp": 0.0625,
            "pseudo_barinel_susp": 0.0005099439061703213
        }
    },
    {
        "name": "lib.matplotlib.mathtext.MathtextBackend.set_canvas_size#103",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.MathtextBackend",
        "signature": "lib.matplotlib.mathtext.MathtextBackend.set_canvas_size(self, w, h, d)",
        "snippet": "    def set_canvas_size(self, w, h, d):\n        'Dimension the drawing canvas'\n        self.width  = w\n        self.height = h\n        self.depth  = d",
        "begin_line": 103,
        "end_line": 107,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.023809523809523808,
            "pseudo_dstar_susp": 0.015384615384615385,
            "pseudo_tarantula_susp": 0.0004478280340349306,
            "pseudo_op2_susp": 0.015384615384615385,
            "pseudo_barinel_susp": 0.0004478280340349306
        }
    },
    {
        "name": "lib.matplotlib.mathtext.MathtextBackendAgg.__init__#142",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.MathtextBackendAgg",
        "signature": "lib.matplotlib.mathtext.MathtextBackendAgg.__init__(self)",
        "snippet": "    def __init__(self):\n        self.ox = 0\n        self.oy = 0\n        self.image = None\n        self.mode = 'bbox'\n        self.bbox = [0, 0, 0, 0]\n        MathtextBackend.__init__(self)",
        "begin_line": 142,
        "end_line": 148,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.014084507042253521,
            "pseudo_dstar_susp": 0.008928571428571428,
            "pseudo_tarantula_susp": 0.0004597701149425287,
            "pseudo_op2_susp": 0.008928571428571428,
            "pseudo_barinel_susp": 0.0004597701149425287
        }
    },
    {
        "name": "lib.matplotlib.mathtext.MathtextBackendAgg._update_bbox#150",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.MathtextBackendAgg",
        "signature": "lib.matplotlib.mathtext.MathtextBackendAgg._update_bbox(self, x1, y1, x2, y2)",
        "snippet": "    def _update_bbox(self, x1, y1, x2, y2):\n        self.bbox = [min(self.bbox[0], x1),\n                     min(self.bbox[1], y1),\n                     max(self.bbox[2], x2),\n                     max(self.bbox[3], y2)]",
        "begin_line": 150,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.125,
            "pseudo_dstar_susp": 0.05555555555555555,
            "pseudo_tarantula_susp": 0.00044014084507042255,
            "pseudo_op2_susp": 0.05555555555555555,
            "pseudo_barinel_susp": 0.00044014084507042255
        }
    },
    {
        "name": "lib.matplotlib.mathtext.MathtextBackendAgg.set_canvas_size#156",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.MathtextBackendAgg",
        "signature": "lib.matplotlib.mathtext.MathtextBackendAgg.set_canvas_size(self, w, h, d)",
        "snippet": "    def set_canvas_size(self, w, h, d):\n        MathtextBackend.set_canvas_size(self, w, h, d)\n        if self.mode != 'bbox':\n            self.image = FT2Image(np.ceil(w), np.ceil(h + max(d, 0)))",
        "begin_line": 156,
        "end_line": 159,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.1,
            "pseudo_dstar_susp": 0.058823529411764705,
            "pseudo_tarantula_susp": 0.00044802867383512545,
            "pseudo_op2_susp": 0.058823529411764705,
            "pseudo_barinel_susp": 0.00044802867383512545
        }
    },
    {
        "name": "lib.matplotlib.mathtext.MathtextBackendAgg.render_glyph#161",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.MathtextBackendAgg",
        "signature": "lib.matplotlib.mathtext.MathtextBackendAgg.render_glyph(self, ox, oy, info)",
        "snippet": "    def render_glyph(self, ox, oy, info):\n        if self.mode == 'bbox':\n            self._update_bbox(ox + info.metrics.xmin,\n                              oy - info.metrics.ymax,\n                              ox + info.metrics.xmax,\n                              oy - info.metrics.ymin)\n        else:\n            info.font.draw_glyph_to_bitmap(\n                self.image, ox, oy - info.metrics.iceberg, info.glyph,\n                antialiased=rcParams['text.antialiased'])",
        "begin_line": 161,
        "end_line": 170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.3333333333333333,
            "pseudo_dstar_susp": 0.14285714285714285,
            "pseudo_tarantula_susp": 0.0005125576627370579,
            "pseudo_op2_susp": 0.14285714285714285,
            "pseudo_barinel_susp": 0.0005125576627370579
        }
    },
    {
        "name": "lib.matplotlib.mathtext.MathtextBackendAgg.render_rect_filled#172",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.MathtextBackendAgg",
        "signature": "lib.matplotlib.mathtext.MathtextBackendAgg.render_rect_filled(self, x1, y1, x2, y2)",
        "snippet": "    def render_rect_filled(self, x1, y1, x2, y2):\n        if self.mode == 'bbox':\n            self._update_bbox(x1, y1, x2, y2)\n        else:\n            height = max(int(y2 - y1) - 1, 0)\n            if height == 0:\n                center = (y2 + y1) / 2.0\n                y = int(center - (height + 1) / 2.0)\n            else:\n                y = int(y1)\n            self.image.draw_rect_filled(int(x1), y, np.ceil(x2), y + height)",
        "begin_line": 172,
        "end_line": 182,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006531678641410843,
            "pseudo_dstar_susp": 0.0005614823133071309,
            "pseudo_tarantula_susp": 0.00037778617302606723,
            "pseudo_op2_susp": 0.0005614823133071309,
            "pseudo_barinel_susp": 0.00037778617302606723
        }
    },
    {
        "name": "lib.matplotlib.mathtext.MathtextBackendAgg.get_results#184",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.MathtextBackendAgg",
        "signature": "lib.matplotlib.mathtext.MathtextBackendAgg.get_results(self, box, used_characters)",
        "snippet": "    def get_results(self, box, used_characters):\n        self.mode = 'bbox'\n        orig_height = box.height\n        orig_depth  = box.depth\n        ship(0, 0, box)\n        bbox = self.bbox\n        bbox = [bbox[0] - 1, bbox[1] - 1, bbox[2] + 1, bbox[3] + 1]\n        self.mode = 'render'\n        self.set_canvas_size(\n            bbox[2] - bbox[0],\n            (bbox[3] - bbox[1]) - orig_depth,\n            (bbox[3] - bbox[1]) - orig_height)\n        ship(-bbox[0], -bbox[1], box)\n        result = (self.ox,\n                  self.oy,\n                  self.width,\n                  self.height + self.depth,\n                  self.depth,\n                  self.image,\n                  used_characters)\n        self.image = None\n        return result",
        "begin_line": 184,
        "end_line": 205,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.25,
            "pseudo_dstar_susp": 0.1,
            "pseudo_tarantula_susp": 0.0005414185165132648,
            "pseudo_op2_susp": 0.09090909090909091,
            "pseudo_barinel_susp": 0.0005414185165132648
        }
    },
    {
        "name": "lib.matplotlib.mathtext.MathtextBackendAgg.get_hinting_type#207",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.MathtextBackendAgg",
        "signature": "lib.matplotlib.mathtext.MathtextBackendAgg.get_hinting_type(self)",
        "snippet": "    def get_hinting_type(self):\n        from matplotlib.backends import backend_agg\n        return backend_agg.get_hinting_flag()",
        "begin_line": 207,
        "end_line": 209,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.03333333333333333,
            "pseudo_dstar_susp": 0.014084507042253521,
            "pseudo_tarantula_susp": 0.0005115089514066496,
            "pseudo_op2_susp": 0.014084507042253521,
            "pseudo_barinel_susp": 0.0005115089514066496
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Fonts.__init__#388",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Fonts",
        "signature": "lib.matplotlib.mathtext.Fonts.__init__(self, default_font_prop, mathtext_backend)",
        "snippet": "    def __init__(self, default_font_prop, mathtext_backend):\n        \"\"\"\n        *default_font_prop*: A\n        :class:`~matplotlib.font_manager.FontProperties` object to use\n        for the default non-math font, or the base font for Unicode\n        (generic) font rendering.\n\n        *mathtext_backend*: A subclass of :class:`MathTextBackend`\n        used to delegate the actual rendering.\n        \"\"\"\n        self.default_font_prop = default_font_prop\n        self.mathtext_backend = mathtext_backend\n        self.used_characters = {}",
        "begin_line": 388,
        "end_line": 400,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018796992481203006,
            "pseudo_dstar_susp": 0.0009057971014492754,
            "pseudo_tarantula_susp": 0.0005027652086475615,
            "pseudo_op2_susp": 0.0009057971014492754,
            "pseudo_barinel_susp": 0.0005027652086475615
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Fonts.destroy#402",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Fonts",
        "signature": "lib.matplotlib.mathtext.Fonts.destroy(self)",
        "snippet": "    def destroy(self):\n        \"\"\"\n        Fix any cyclical references before the object is about\n        to be destroyed.\n        \"\"\"\n        self.used_characters = None",
        "begin_line": 402,
        "end_line": 407,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0036900369003690036,
            "pseudo_dstar_susp": 0.0009881422924901185,
            "pseudo_tarantula_susp": 0.0006097560975609756,
            "pseudo_op2_susp": 0.0009881422924901185,
            "pseudo_barinel_susp": 0.0006097560975609756
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Fonts.get_metrics#428",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Fonts",
        "signature": "lib.matplotlib.mathtext.Fonts.get_metrics(self, font, font_class, sym, fontsize, dpi, math=True)",
        "snippet": "    def get_metrics(self, font, font_class, sym, fontsize, dpi, math=True):\n        r\"\"\"\n        *font*: one of the TeX font names::\n\n          tt, it, rm, cal, sf, bf or default/regular (non-math)\n\n        *font_class*: TODO\n\n        *sym*:  a symbol in raw TeX form. e.g., '1', 'x' or '\\sigma'\n\n        *fontsize*: font size in points\n\n        *dpi*: current dots-per-inch\n\n        *math*: whether sym is a math character\n\n        Returns an object with the following attributes:\n\n          - *advance*: The advance distance (in points) of the glyph.\n\n          - *height*: The height of the glyph in points.\n\n          - *width*: The width of the glyph in points.\n\n          - *xmin*, *xmax*, *ymin*, *ymax* - the ink rectangle of the glyph\n\n          - *iceberg* - the distance from the baseline to the top of\n            the glyph.  This corresponds to TeX's definition of\n            \"height\".\n        \"\"\"\n        info = self._get_info(font, font_class, sym, fontsize, dpi, math)\n        return info.metrics",
        "begin_line": 428,
        "end_line": 459,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0036900369003690036,
            "pseudo_dstar_susp": 0.0009881422924901185,
            "pseudo_tarantula_susp": 0.0006097560975609756,
            "pseudo_op2_susp": 0.0009881422924901185,
            "pseudo_barinel_susp": 0.0006097560975609756
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Fonts.set_canvas_size#461",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Fonts",
        "signature": "lib.matplotlib.mathtext.Fonts.set_canvas_size(self, w, h, d)",
        "snippet": "    def set_canvas_size(self, w, h, d):\n        \"\"\"\n        Set the size of the buffer used to render the math expression.\n        Only really necessary for the bitmap backends.\n        \"\"\"\n        self.width, self.height, self.depth = np.ceil([w, h, d])\n        self.mathtext_backend.set_canvas_size(\n            self.width, self.height, self.depth)",
        "begin_line": 461,
        "end_line": 468,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0036900369003690036,
            "pseudo_dstar_susp": 0.0009881422924901185,
            "pseudo_tarantula_susp": 0.0006097560975609756,
            "pseudo_op2_susp": 0.0009881422924901185,
            "pseudo_barinel_susp": 0.0006097560975609756
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Fonts.render_glyph#470",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Fonts",
        "signature": "lib.matplotlib.mathtext.Fonts.render_glyph(self, ox, oy, facename, font_class, sym, fontsize, dpi)",
        "snippet": "    def render_glyph(self, ox, oy, facename, font_class, sym, fontsize, dpi):\n        \"\"\"\n        Draw a glyph at\n\n          - *ox*, *oy*: position\n\n          - *facename*: One of the TeX face names\n\n          - *font_class*:\n\n          - *sym*: TeX symbol name or single character\n\n          - *fontsize*: fontsize in points\n\n          - *dpi*: The dpi to draw at.\n        \"\"\"\n        info = self._get_info(facename, font_class, sym, fontsize, dpi)\n        realpath, stat_key = get_realpath_and_stat(info.font.fname)\n        used_characters = self.used_characters.setdefault(\n            stat_key, (realpath, set()))\n        used_characters[1].add(info.num)\n        self.mathtext_backend.render_glyph(ox, oy, info)",
        "begin_line": 470,
        "end_line": 491,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0036900369003690036,
            "pseudo_dstar_susp": 0.0009881422924901185,
            "pseudo_tarantula_susp": 0.0006097560975609756,
            "pseudo_op2_susp": 0.0009881422924901185,
            "pseudo_barinel_susp": 0.0006097560975609756
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Fonts.render_rect_filled#493",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Fonts",
        "signature": "lib.matplotlib.mathtext.Fonts.render_rect_filled(self, x1, y1, x2, y2)",
        "snippet": "    def render_rect_filled(self, x1, y1, x2, y2):\n        \"\"\"\n        Draw a filled rectangle from (*x1*, *y1*) to (*x2*, *y2*).\n        \"\"\"\n        self.mathtext_backend.render_rect_filled(x1, y1, x2, y2)",
        "begin_line": 493,
        "end_line": 497,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Fonts.get_used_characters#512",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Fonts",
        "signature": "lib.matplotlib.mathtext.Fonts.get_used_characters(self)",
        "snippet": "    def get_used_characters(self):\n        \"\"\"\n        Get the set of characters that were used in the math\n        expression.  Used by backends that need to subset fonts so\n        they know which glyphs to include.\n        \"\"\"\n        return self.used_characters",
        "begin_line": 512,
        "end_line": 518,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0036900369003690036,
            "pseudo_dstar_susp": 0.0009881422924901185,
            "pseudo_tarantula_susp": 0.0006097560975609756,
            "pseudo_op2_susp": 0.0009881422924901185,
            "pseudo_barinel_susp": 0.0006097560975609756
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Fonts.get_results#520",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Fonts",
        "signature": "lib.matplotlib.mathtext.Fonts.get_results(self, box)",
        "snippet": "    def get_results(self, box):\n        \"\"\"\n        Get the data needed by the backend to render the math\n        expression.  The return value is backend-specific.\n        \"\"\"\n        result = self.mathtext_backend.get_results(\n            box, self.get_used_characters())\n        self.destroy()\n        return result",
        "begin_line": 520,
        "end_line": 528,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0036900369003690036,
            "pseudo_dstar_susp": 0.0009881422924901185,
            "pseudo_tarantula_susp": 0.0006097560975609756,
            "pseudo_op2_susp": 0.0009881422924901185,
            "pseudo_barinel_susp": 0.0006097560975609756
        }
    },
    {
        "name": "lib.matplotlib.mathtext.TruetypeFonts.__init__#545",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.TruetypeFonts",
        "signature": "lib.matplotlib.mathtext.TruetypeFonts.__init__(self, default_font_prop, mathtext_backend)",
        "snippet": "    def __init__(self, default_font_prop, mathtext_backend):\n        Fonts.__init__(self, default_font_prop, mathtext_backend)\n        self.glyphd = {}\n        self._fonts = {}\n\n        filename = findfont(default_font_prop)\n        default_font = get_font(filename)\n        self._fonts['default'] = default_font\n        self._fonts['regular'] = default_font",
        "begin_line": 545,
        "end_line": 553,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018796992481203006,
            "pseudo_dstar_susp": 0.0009057971014492754,
            "pseudo_tarantula_susp": 0.0005027652086475615,
            "pseudo_op2_susp": 0.0009057971014492754,
            "pseudo_barinel_susp": 0.0005027652086475615
        }
    },
    {
        "name": "lib.matplotlib.mathtext.TruetypeFonts.destroy#555",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.TruetypeFonts",
        "signature": "lib.matplotlib.mathtext.TruetypeFonts.destroy(self)",
        "snippet": "    def destroy(self):\n        self.glyphd = None\n        Fonts.destroy(self)",
        "begin_line": 555,
        "end_line": 557,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0036900369003690036,
            "pseudo_dstar_susp": 0.0009881422924901185,
            "pseudo_tarantula_susp": 0.0006097560975609756,
            "pseudo_op2_susp": 0.0009881422924901185,
            "pseudo_barinel_susp": 0.0006097560975609756
        }
    },
    {
        "name": "lib.matplotlib.mathtext.TruetypeFonts._get_font#559",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.TruetypeFonts",
        "signature": "lib.matplotlib.mathtext.TruetypeFonts._get_font(self, font)",
        "snippet": "    def _get_font(self, font):\n        if font in self.fontmap:\n            basename = self.fontmap[font]\n        else:\n            basename = font\n        cached_font = self._fonts.get(basename)\n        if cached_font is None and os.path.exists(basename):\n            cached_font = get_font(basename)\n            self._fonts[basename] = cached_font\n            self._fonts[cached_font.postscript_name] = cached_font\n            self._fonts[cached_font.postscript_name.lower()] = cached_font\n        return cached_font",
        "begin_line": 559,
        "end_line": 570,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0049261083743842365,
            "pseudo_dstar_susp": 0.0010449320794148381,
            "pseudo_tarantula_susp": 0.0006591957811470006,
            "pseudo_op2_susp": 0.0010449320794148381,
            "pseudo_barinel_susp": 0.0006591957811470006
        }
    },
    {
        "name": "lib.matplotlib.mathtext.TruetypeFonts._get_offset#572",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.TruetypeFonts",
        "signature": "lib.matplotlib.mathtext.TruetypeFonts._get_offset(self, font, glyph, fontsize, dpi)",
        "snippet": "    def _get_offset(self, font, glyph, fontsize, dpi):\n        if font.postscript_name == 'Cmex10':\n            return ((glyph.height/64.0/2.0) + (fontsize/3.0 * dpi/72.0))\n        return 0.",
        "begin_line": 572,
        "end_line": 575,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0036900369003690036,
            "pseudo_dstar_susp": 0.0009881422924901185,
            "pseudo_tarantula_susp": 0.0006097560975609756,
            "pseudo_op2_susp": 0.0009881422924901185,
            "pseudo_barinel_susp": 0.0006097560975609756
        }
    },
    {
        "name": "lib.matplotlib.mathtext.TruetypeFonts._get_info#577",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.TruetypeFonts",
        "signature": "lib.matplotlib.mathtext.TruetypeFonts._get_info(self, fontname, font_class, sym, fontsize, dpi, math=True)",
        "snippet": "    def _get_info(self, fontname, font_class, sym, fontsize, dpi, math=True):\n        key = fontname, font_class, sym, fontsize, dpi\n        bunch = self.glyphd.get(key)\n        if bunch is not None:\n            return bunch\n\n        font, num, symbol_name, fontsize, slanted = \\\n            self._get_glyph(fontname, font_class, sym, fontsize, math)\n\n        font.set_size(fontsize, dpi)\n        glyph = font.load_char(\n            num,\n            flags=self.mathtext_backend.get_hinting_type())\n\n        xmin, ymin, xmax, ymax = [val/64.0 for val in glyph.bbox]\n        offset = self._get_offset(font, glyph, fontsize, dpi)\n        metrics = types.SimpleNamespace(\n            advance = glyph.linearHoriAdvance/65536.0,\n            height  = glyph.height/64.0,\n            width   = glyph.width/64.0,\n            xmin    = xmin,\n            xmax    = xmax,\n            ymin    = ymin+offset,\n            ymax    = ymax+offset,\n            # iceberg is the equivalent of TeX's \"height\"\n            iceberg = glyph.horiBearingY/64.0 + offset,\n            slanted = slanted\n            )\n\n        result = self.glyphd[key] = types.SimpleNamespace(\n            font            = font,\n            fontsize        = fontsize,\n            postscript_name = font.postscript_name,\n            metrics         = metrics,\n            symbol_name     = symbol_name,\n            num             = num,\n            glyph           = glyph,\n            offset          = offset\n            )\n        return result",
        "begin_line": 577,
        "end_line": 616,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0036900369003690036,
            "pseudo_dstar_susp": 0.0009881422924901185,
            "pseudo_tarantula_susp": 0.0006097560975609756,
            "pseudo_op2_susp": 0.0009881422924901185,
            "pseudo_barinel_susp": 0.0006097560975609756
        }
    },
    {
        "name": "lib.matplotlib.mathtext.TruetypeFonts.get_xheight#618",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.TruetypeFonts",
        "signature": "lib.matplotlib.mathtext.TruetypeFonts.get_xheight(self, fontname, fontsize, dpi)",
        "snippet": "    def get_xheight(self, fontname, fontsize, dpi):\n        font = self._get_font(fontname)\n        font.set_size(fontsize, dpi)\n        pclt = font.get_sfnt_table('pclt')\n        if pclt is None:\n            # Some fonts don't store the xHeight, so we do a poor man's xHeight\n            metrics = self.get_metrics(\n                fontname, rcParams['mathtext.default'], 'x', fontsize, dpi)\n            return metrics.iceberg\n        xHeight = (pclt['xHeight'] / 64.0) * (fontsize / 12.0) * (dpi / 100.0)\n        return xHeight",
        "begin_line": 618,
        "end_line": 628,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009033423667570009,
            "pseudo_dstar_susp": 0.0007524454477050414,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0007524454477050414,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.TruetypeFonts.get_underline_thickness#630",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.TruetypeFonts",
        "signature": "lib.matplotlib.mathtext.TruetypeFonts.get_underline_thickness(self, font, fontsize, dpi)",
        "snippet": "    def get_underline_thickness(self, font, fontsize, dpi):\n        # This function used to grab underline thickness from the font\n        # metrics, but that information is just too un-reliable, so it\n        # is now hardcoded.\n        return ((0.75 / 12.0) * fontsize * dpi) / 72.0",
        "begin_line": 630,
        "end_line": 634,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009337068160597573,
            "pseudo_dstar_susp": 0.000778816199376947,
            "pseudo_tarantula_susp": 0.0005903187721369539,
            "pseudo_op2_susp": 0.000778816199376947,
            "pseudo_barinel_susp": 0.0005903187721369539
        }
    },
    {
        "name": "lib.matplotlib.mathtext.TruetypeFonts.get_kern#636",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.TruetypeFonts",
        "signature": "lib.matplotlib.mathtext.TruetypeFonts.get_kern(self, font1, fontclass1, sym1, fontsize1, font2, fontclass2, sym2, fontsize2, dpi)",
        "snippet": "    def get_kern(self, font1, fontclass1, sym1, fontsize1,\n                 font2, fontclass2, sym2, fontsize2, dpi):\n        if font1 == font2 and fontsize1 == fontsize2:\n            info1 = self._get_info(font1, fontclass1, sym1, fontsize1, dpi)\n            info2 = self._get_info(font2, fontclass2, sym2, fontsize2, dpi)\n            font = info1.font\n            return font.get_kerning(info1.num, info2.num, KERNING_DEFAULT) / 64\n        return Fonts.get_kern(self, font1, fontclass1, sym1, fontsize1,\n                              font2, fontclass2, sym2, fontsize2, dpi)",
        "begin_line": 636,
        "end_line": 644,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009587727708533077,
            "pseudo_dstar_susp": 0.0008326394671107411,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0008326394671107411,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.BakomaFonts.__init__#664",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.BakomaFonts",
        "signature": "lib.matplotlib.mathtext.BakomaFonts.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        self._stix_fallback = StixFonts(*args, **kwargs)\n\n        TruetypeFonts.__init__(self, *args, **kwargs)\n        self.fontmap = {}\n        for key, val in self._fontmap.items():\n            fullpath = findfont(val)\n            self.fontmap[key] = fullpath\n            self.fontmap[val] = fullpath",
        "begin_line": 664,
        "end_line": 672,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009487666034155598,
            "pseudo_dstar_susp": 0.0008156606851549756,
            "pseudo_tarantula_susp": 0.0004492362982929021,
            "pseudo_op2_susp": 0.0008156606851549756,
            "pseudo_barinel_susp": 0.0004492362982929021
        }
    },
    {
        "name": "lib.matplotlib.mathtext.BakomaFonts._get_glyph#676",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.BakomaFonts",
        "signature": "lib.matplotlib.mathtext.BakomaFonts._get_glyph(self, fontname, font_class, sym, fontsize, math=True)",
        "snippet": "    def _get_glyph(self, fontname, font_class, sym, fontsize, math=True):\n        symbol_name = None\n        font = None\n        if fontname in self.fontmap and sym in latex_to_bakoma:\n            basename, num = latex_to_bakoma[sym]\n            slanted = (basename == \"cmmi10\") or sym in self._slanted_symbols\n            font = self._get_font(basename)\n        elif len(sym) == 1:\n            slanted = (fontname == \"it\")\n            font = self._get_font(fontname)\n            if font is not None:\n                num = ord(sym)\n\n        if font is not None:\n            gid = font.get_char_index(num)\n            if gid != 0:\n                symbol_name = font.get_glyph_name(gid)\n\n        if symbol_name is None:\n            return self._stix_fallback._get_glyph(\n                fontname, font_class, sym, fontsize, math)\n\n        return font, num, symbol_name, fontsize, slanted",
        "begin_line": 676,
        "end_line": 698,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000724112961622013,
            "pseudo_dstar_susp": 0.0006565988181221273,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0006565988181221273,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.UnicodeFonts._map_virtual_font#791",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.UnicodeFonts",
        "signature": "lib.matplotlib.mathtext.UnicodeFonts._map_virtual_font(self, fontname, font_class, uniindex)",
        "snippet": "    def _map_virtual_font(self, fontname, font_class, uniindex):\n        return fontname, uniindex",
        "begin_line": 791,
        "end_line": 792,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.UnicodeFonts._get_glyph#794",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.UnicodeFonts",
        "signature": "lib.matplotlib.mathtext.UnicodeFonts._get_glyph(self, fontname, font_class, sym, fontsize, math=True)",
        "snippet": "    def _get_glyph(self, fontname, font_class, sym, fontsize, math=True):\n        found_symbol = False\n\n        if self.use_cmex:\n            uniindex = latex_to_cmex.get(sym)\n            if uniindex is not None:\n                fontname = 'ex'\n                found_symbol = True\n\n        if not found_symbol:\n            try:\n                uniindex = get_unicode_index(sym, math)\n                found_symbol = True\n            except ValueError:\n                uniindex = ord('?')\n                _log.warning(\n                    \"No TeX to unicode mapping for {!a}.\".format(sym))\n\n        fontname, uniindex = self._map_virtual_font(\n            fontname, font_class, uniindex)\n\n        new_fontname = fontname\n\n        # Only characters in the \"Letter\" class should be italicized in 'it'\n        # mode.  Greek capital letters should be Roman.\n        if found_symbol:\n            if fontname == 'it' and uniindex < 0x10000:\n                char = chr(uniindex)\n                if (unicodedata.category(char)[0] != \"L\"\n                        or unicodedata.name(char).startswith(\"GREEK CAPITAL\")):\n                    new_fontname = 'rm'\n\n            slanted = (new_fontname == 'it') or sym in self._slanted_symbols\n            found_symbol = False\n            font = self._get_font(new_fontname)\n            if font is not None:\n                glyphindex = font.get_char_index(uniindex)\n                if glyphindex != 0:\n                    found_symbol = True\n\n        if not found_symbol:\n            if self.cm_fallback:\n                if isinstance(self.cm_fallback, BakomaFonts):\n                    _log.warning(\n                        \"Substituting with a symbol from Computer Modern.\")\n                if (fontname in ('it', 'regular') and\n                        isinstance(self.cm_fallback, StixFonts)):\n                    return self.cm_fallback._get_glyph(\n                            'rm', font_class, sym, fontsize)\n                else:\n                    return self.cm_fallback._get_glyph(\n                        fontname, font_class, sym, fontsize)\n            else:\n                if (fontname in ('it', 'regular')\n                        and isinstance(self, StixFonts)):\n                    return self._get_glyph('rm', font_class, sym, fontsize)\n                _log.warning(\"Font {!r} does not have a glyph for {!a} \"\n                             \"[U+{:x}], substituting with a dummy \"\n                             \"symbol.\".format(new_fontname, sym, uniindex))\n                fontname = 'rm'\n                font = self._get_font(fontname)\n                uniindex = 0xA4  # currency char, for lack of anything better\n                glyphindex = font.get_char_index(uniindex)\n                slanted = False\n\n        symbol_name = font.get_glyph_name(glyphindex)\n        return font, uniindex, symbol_name, fontsize, slanted",
        "begin_line": 794,
        "end_line": 860,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011655011655011655,
            "pseudo_dstar_susp": 0.0008561643835616438,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0008561643835616438,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.DejaVuFonts.__init__#872",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.DejaVuFonts",
        "signature": "lib.matplotlib.mathtext.DejaVuFonts.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        # This must come first so the backend's owner is set correctly\n        if isinstance(self, DejaVuSerifFonts):\n            self.cm_fallback = StixFonts(*args, **kwargs)\n        else:\n            self.cm_fallback = StixSansFonts(*args, **kwargs)\n        self.bakoma = BakomaFonts(*args, **kwargs)\n        TruetypeFonts.__init__(self, *args, **kwargs)\n        self.fontmap = {}\n        # Include Stix sized alternatives for glyphs\n        self._fontmap.update({\n            1: 'STIXSizeOneSym',\n            2: 'STIXSizeTwoSym',\n            3: 'STIXSizeThreeSym',\n            4: 'STIXSizeFourSym',\n            5: 'STIXSizeFiveSym',\n        })\n        for key, name in self._fontmap.items():\n            fullpath = findfont(name)\n            self.fontmap[key] = fullpath\n            self.fontmap[name] = fullpath",
        "begin_line": 872,
        "end_line": 892,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009285051067780873,
            "pseudo_dstar_susp": 0.0007727975270479134,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0007727975270479134,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.DejaVuFonts._get_glyph#894",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.DejaVuFonts",
        "signature": "lib.matplotlib.mathtext.DejaVuFonts._get_glyph(self, fontname, font_class, sym, fontsize, math=True)",
        "snippet": "    def _get_glyph(self, fontname, font_class, sym, fontsize, math=True):\n        # Override prime symbol to use Bakoma.\n        if sym == r'\\prime':\n            return self.bakoma._get_glyph(\n                fontname, font_class, sym, fontsize, math)\n        else:\n            # check whether the glyph is available in the display font\n            uniindex = get_unicode_index(sym)\n            font = self._get_font('ex')\n            if font is not None:\n                glyphindex = font.get_char_index(uniindex)\n                if glyphindex != 0:\n                    return super()._get_glyph(\n                        'ex', font_class, sym, fontsize, math)\n            # otherwise return regular glyph\n            return super()._get_glyph(\n                fontname, font_class, sym, fontsize, math)",
        "begin_line": 894,
        "end_line": 910,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009285051067780873,
            "pseudo_dstar_susp": 0.0007727975270479134,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0007727975270479134,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.StixFonts.__init__#977",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.StixFonts",
        "signature": "lib.matplotlib.mathtext.StixFonts.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        TruetypeFonts.__init__(self, *args, **kwargs)\n        self.fontmap = {}\n        for key, name in self._fontmap.items():\n            fullpath = findfont(name)\n            self.fontmap[key] = fullpath\n            self.fontmap[name] = fullpath",
        "begin_line": 977,
        "end_line": 983,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018796992481203006,
            "pseudo_dstar_susp": 0.0009057971014492754,
            "pseudo_tarantula_susp": 0.0005027652086475615,
            "pseudo_op2_susp": 0.0009057971014492754,
            "pseudo_barinel_susp": 0.0005027652086475615
        }
    },
    {
        "name": "lib.matplotlib.mathtext.StixFonts._map_virtual_font#985",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.StixFonts",
        "signature": "lib.matplotlib.mathtext.StixFonts._map_virtual_font(self, fontname, font_class, uniindex)",
        "snippet": "    def _map_virtual_font(self, fontname, font_class, uniindex):\n        # Handle these \"fonts\" that are actually embedded in\n        # other fonts.\n        mapping = stix_virtual_fonts.get(fontname)\n        if (self._sans and mapping is None\n                and fontname not in ('regular', 'default')):\n            mapping = stix_virtual_fonts['sf']\n            doing_sans_conversion = True\n        else:\n            doing_sans_conversion = False\n\n        if mapping is not None:\n            if isinstance(mapping, dict):\n                try:\n                    mapping = mapping[font_class]\n                except KeyError:\n                    mapping = mapping['rm']\n\n            # Binary search for the source glyph\n            lo = 0\n            hi = len(mapping)\n            while lo < hi:\n                mid = (lo+hi)//2\n                range = mapping[mid]\n                if uniindex < range[0]:\n                    hi = mid\n                elif uniindex <= range[1]:\n                    break\n                else:\n                    lo = mid + 1\n\n            if range[0] <= uniindex <= range[1]:\n                uniindex = uniindex - range[0] + range[3]\n                fontname = range[2]\n            elif not doing_sans_conversion:\n                # This will generate a dummy character\n                uniindex = 0x1\n                fontname = rcParams['mathtext.default']\n\n        # Handle private use area glyphs\n        if fontname in ('it', 'rm', 'bf') and 0xe000 <= uniindex <= 0xf8ff:\n            fontname = 'nonuni' + fontname\n\n        return fontname, uniindex",
        "begin_line": 985,
        "end_line": 1028,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009433962264150943,
            "pseudo_dstar_susp": 0.0008051529790660225,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0008051529790660225,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.StixFonts.get_sized_alternatives_for_symbol#1031",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.StixFonts",
        "signature": "lib.matplotlib.mathtext.StixFonts.get_sized_alternatives_for_symbol(self, fontname, sym)",
        "snippet": "    def get_sized_alternatives_for_symbol(self, fontname, sym):\n        fixes = {\n            '\\\\{': '{', '\\\\}': '}', '\\\\[': '[', '\\\\]': ']',\n            '<': '\\N{MATHEMATICAL LEFT ANGLE BRACKET}',\n            '>': '\\N{MATHEMATICAL RIGHT ANGLE BRACKET}',\n        }\n        sym = fixes.get(sym, sym)\n        try:\n            uniindex = get_unicode_index(sym)\n        except ValueError:\n            return [(fontname, sym)]\n        alternatives = [(i, chr(uniindex)) for i in range(6)\n                        if self._get_font(i).get_char_index(uniindex) != 0]\n        # The largest size of the radical symbol in STIX has incorrect\n        # metrics that cause it to be disconnected from the stem.\n        if sym == r'\\__sqrt__':\n            alternatives = alternatives[:-1]\n        return alternatives",
        "begin_line": 1031,
        "end_line": 1048,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006215040397762585,
            "pseudo_dstar_susp": 0.00035714285714285714,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00035714285714285714,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.StandardPsFonts._get_info#1112",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.StandardPsFonts",
        "signature": "lib.matplotlib.mathtext.StandardPsFonts._get_info(self, fontname, font_class, sym, fontsize, dpi, math=True)",
        "snippet": "    def _get_info(self, fontname, font_class, sym, fontsize, dpi, math=True):\n        'load the cmfont, metrics and glyph with caching'\n        key = fontname, sym, fontsize, dpi\n        tup = self.glyphd.get(key)\n\n        if tup is not None:\n            return tup\n\n        # Only characters in the \"Letter\" class should really be italicized.\n        # This class includes greek letters, so we're ok\n        if (fontname == 'it' and\n                (len(sym) > 1\n                 or not unicodedata.category(sym).startswith(\"L\"))):\n            fontname = 'rm'\n\n        found_symbol = False\n\n        if sym in latex_to_standard:\n            fontname, num = latex_to_standard[sym]\n            glyph = chr(num)\n            found_symbol = True\n        elif len(sym) == 1:\n            glyph = sym\n            num = ord(glyph)\n            found_symbol = True\n        else:\n            _log.warning(\n                \"No TeX to built-in Postscript mapping for {!r}\".format(sym))\n\n        slanted = (fontname == 'it')\n        font = self._get_font(fontname)\n\n        if found_symbol:\n            try:\n                symbol_name = font.get_name_char(glyph)\n            except KeyError:\n                _log.warning(\n                    \"No glyph in standard Postscript font {!r} for {!r}\"\n                    .format(font.get_fontname(), sym))\n                found_symbol = False\n\n        if not found_symbol:\n            glyph = '?'\n            num = ord(glyph)\n            symbol_name = font.get_name_char(glyph)\n\n        offset = 0\n\n        scale = 0.001 * fontsize\n\n        xmin, ymin, xmax, ymax = [val * scale\n                                  for val in font.get_bbox_char(glyph)]\n        metrics = types.SimpleNamespace(\n            advance  = font.get_width_char(glyph) * scale,\n            width    = font.get_width_char(glyph) * scale,\n            height   = font.get_height_char(glyph) * scale,\n            xmin = xmin,\n            xmax = xmax,\n            ymin = ymin+offset,\n            ymax = ymax+offset,\n            # iceberg is the equivalent of TeX's \"height\"\n            iceberg = ymax + offset,\n            slanted = slanted\n            )\n\n        self.glyphd[key] = types.SimpleNamespace(\n            font            = font,\n            fontsize        = fontsize,\n            postscript_name = font.get_fontname(),\n            metrics         = metrics,\n            symbol_name     = symbol_name,\n            num             = num,\n            glyph           = glyph,\n            offset          = offset\n            )\n\n        return self.glyphd[key]",
        "begin_line": 1112,
        "end_line": 1188,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mathtext.StandardPsFonts.get_underline_thickness#1205",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.StandardPsFonts",
        "signature": "lib.matplotlib.mathtext.StandardPsFonts.get_underline_thickness(self, font, fontsize, dpi)",
        "snippet": "    def get_underline_thickness(self, font, fontsize, dpi):\n        font = self._get_font(font)\n        return font.get_underline_thickness() * 0.001 * fontsize",
        "begin_line": 1205,
        "end_line": 1207,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mathtext._get_font_constant_set#1339",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext",
        "signature": "lib.matplotlib.mathtext._get_font_constant_set(state)",
        "snippet": "def _get_font_constant_set(state):\n    constants = _font_constant_mapping.get(\n        state.font_output._get_font(state.font).family_name,\n        FontConstantsBase)\n    # STIX sans isn't really its own fonts, just different code points\n    # in the STIX fonts, so we have to detect this one separately.\n    if (constants is STIXFontConstants and\n            isinstance(state.font_output, StixSansFonts)):\n        return STIXSansFontConstants\n    return constants",
        "begin_line": 1339,
        "end_line": 1348,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008396305625524769,
            "pseudo_dstar_susp": 0.0007037297677691766,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0007037297677691766,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Node.__init__#1359",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Node",
        "signature": "lib.matplotlib.mathtext.Node.__init__(self)",
        "snippet": "    def __init__(self):\n        self.size = 0",
        "begin_line": 1359,
        "end_line": 1360,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016286644951140066,
            "pseudo_dstar_susp": 0.0008818342151675485,
            "pseudo_tarantula_susp": 0.0004914004914004914,
            "pseudo_op2_susp": 0.0008818342151675485,
            "pseudo_barinel_susp": 0.0004914004914004914
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Node.get_kerning#1365",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Node",
        "signature": "lib.matplotlib.mathtext.Node.get_kerning(self, next)",
        "snippet": "    def get_kerning(self, next):\n        return 0.0",
        "begin_line": 1365,
        "end_line": 1366,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0036900369003690036,
            "pseudo_dstar_susp": 0.0009881422924901185,
            "pseudo_tarantula_susp": 0.0006097560975609756,
            "pseudo_op2_susp": 0.0009881422924901185,
            "pseudo_barinel_susp": 0.0006097560975609756
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Node.shrink#1368",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Node",
        "signature": "lib.matplotlib.mathtext.Node.shrink(self)",
        "snippet": "    def shrink(self):\n        \"\"\"\n        Shrinks one level smaller.  There are only three levels of\n        sizes, after which things will no longer get smaller.\n        \"\"\"\n        self.size += 1",
        "begin_line": 1368,
        "end_line": 1373,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009157509157509158,
            "pseudo_dstar_susp": 0.00076103500761035,
            "pseudo_tarantula_susp": 0.0005889281507656066,
            "pseudo_op2_susp": 0.00076103500761035,
            "pseudo_barinel_susp": 0.0005889281507656066
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Box.__init__#1390",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Box",
        "signature": "lib.matplotlib.mathtext.Box.__init__(self, width, height, depth)",
        "snippet": "    def __init__(self, width, height, depth):\n        Node.__init__(self)\n        self.width  = width\n        self.height = height\n        self.depth  = depth",
        "begin_line": 1390,
        "end_line": 1394,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017985611510791368,
            "pseudo_dstar_susp": 0.0015037593984962407,
            "pseudo_tarantula_susp": 0.0004918839153959665,
            "pseudo_op2_susp": 0.0015037593984962407,
            "pseudo_barinel_susp": 0.0004918839153959665
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Box.shrink#1396",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Box",
        "signature": "lib.matplotlib.mathtext.Box.shrink(self)",
        "snippet": "    def shrink(self):\n        Node.shrink(self)\n        if self.size < NUM_SIZE_LEVELS:\n            self.width  *= SHRINK_FACTOR\n            self.height *= SHRINK_FACTOR\n            self.depth  *= SHRINK_FACTOR",
        "begin_line": 1396,
        "end_line": 1401,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009107468123861566,
            "pseudo_dstar_susp": 0.0007593014426727411,
            "pseudo_tarantula_susp": 0.0005871990604815032,
            "pseudo_op2_susp": 0.0007593014426727411,
            "pseudo_barinel_susp": 0.0005871990604815032
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Box.render#1409",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Box",
        "signature": "lib.matplotlib.mathtext.Box.render(self, x1, y1, x2, y2)",
        "snippet": "    def render(self, x1, y1, x2, y2):\n        pass",
        "begin_line": 1409,
        "end_line": 1410,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006920415224913495,
            "pseudo_dstar_susp": 0.0006333122229259025,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0006333122229259025,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Vbox.__init__#1417",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Vbox",
        "signature": "lib.matplotlib.mathtext.Vbox.__init__(self, height, depth)",
        "snippet": "    def __init__(self, height, depth):\n        Box.__init__(self, 0., height, depth)",
        "begin_line": 1417,
        "end_line": 1418,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000691085003455425,
            "pseudo_dstar_susp": 0.0006329113924050633,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0006329113924050633,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Hbox.__init__#1425",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Hbox",
        "signature": "lib.matplotlib.mathtext.Hbox.__init__(self, width)",
        "snippet": "    def __init__(self, width):\n        Box.__init__(self, width, 0., 0.)",
        "begin_line": 1425,
        "end_line": 1426,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000727802037845706,
            "pseudo_dstar_susp": 0.0006587615283267457,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0006587615283267457,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Char.__init__#1440",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Char",
        "signature": "lib.matplotlib.mathtext.Char.__init__(self, c, state, math=True)",
        "snippet": "    def __init__(self, c, state, math=True):\n        Node.__init__(self)\n        self.c = c\n        self.font_output = state.font_output\n        self.font = state.font\n        self.font_class = state.font_class\n        self.fontsize = state.fontsize\n        self.dpi = state.dpi\n        self.math = math\n        # The real width, height and depth will be set during the\n        # pack phase, after we know the real fontsize\n        self._update_metrics()",
        "begin_line": 1440,
        "end_line": 1451,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0047169811320754715,
            "pseudo_dstar_susp": 0.001589825119236884,
            "pseudo_tarantula_susp": 0.0006097560975609756,
            "pseudo_op2_susp": 0.001589825119236884,
            "pseudo_barinel_susp": 0.0006097560975609756
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Char._update_metrics#1456",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Char",
        "signature": "lib.matplotlib.mathtext.Char._update_metrics(self)",
        "snippet": "    def _update_metrics(self):\n        metrics = self._metrics = self.font_output.get_metrics(\n            self.font, self.font_class, self.c, self.fontsize, self.dpi,\n            self.math)\n        if self.c == ' ':\n            self.width = metrics.advance\n        else:\n            self.width = metrics.width\n        self.height = metrics.iceberg\n        self.depth = -(metrics.iceberg - metrics.height)",
        "begin_line": 1456,
        "end_line": 1465,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0048543689320388345,
            "pseudo_dstar_susp": 0.0016025641025641025,
            "pseudo_tarantula_susp": 0.0006720430107526882,
            "pseudo_op2_susp": 0.0016025641025641025,
            "pseudo_barinel_susp": 0.0006720430107526882
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Char.is_slanted#1467",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Char",
        "signature": "lib.matplotlib.mathtext.Char.is_slanted(self)",
        "snippet": "    def is_slanted(self):\n        return self._metrics.slanted",
        "begin_line": 1467,
        "end_line": 1468,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008291873963515755,
            "pseudo_dstar_susp": 0.0006949270326615705,
            "pseudo_tarantula_susp": 0.0005446623093681918,
            "pseudo_op2_susp": 0.0006949270326615705,
            "pseudo_barinel_susp": 0.0005446623093681918
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Char.get_kerning#1470",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Char",
        "signature": "lib.matplotlib.mathtext.Char.get_kerning(self, next)",
        "snippet": "    def get_kerning(self, next):\n        \"\"\"\n        Return the amount of kerning between this and the given\n        character.  Called when characters are strung together into\n        :class:`Hlist` to create :class:`Kern` nodes.\n        \"\"\"\n        advance = self._metrics.advance - self.width\n        kern = 0.\n        if isinstance(next, Char):\n            kern = self.font_output.get_kern(\n                self.font, self.font_class, self.c, self.fontsize,\n                next.font, next.font_class, next.c, next.fontsize,\n                self.dpi)\n        return advance + kern",
        "begin_line": 1470,
        "end_line": 1483,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004608294930875576,
            "pseudo_dstar_susp": 0.0015772870662460567,
            "pseudo_tarantula_susp": 0.000671591672263264,
            "pseudo_op2_susp": 0.0015772870662460567,
            "pseudo_barinel_susp": 0.000671591672263264
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Char.render#1485",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Char",
        "signature": "lib.matplotlib.mathtext.Char.render(self, x, y)",
        "snippet": "    def render(self, x, y):\n        \"\"\"\n        Render the character to the canvas\n        \"\"\"\n        self.font_output.render_glyph(\n            x, y,\n            self.font, self.font_class, self.c, self.fontsize, self.dpi)",
        "begin_line": 1485,
        "end_line": 1491,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0047169811320754715,
            "pseudo_dstar_susp": 0.001589825119236884,
            "pseudo_tarantula_susp": 0.0005820721769499418,
            "pseudo_op2_susp": 0.001589825119236884,
            "pseudo_barinel_susp": 0.0005820721769499418
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Char.shrink#1493",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Char",
        "signature": "lib.matplotlib.mathtext.Char.shrink(self)",
        "snippet": "    def shrink(self):\n        Node.shrink(self)\n        if self.size < NUM_SIZE_LEVELS:\n            self.fontsize *= SHRINK_FACTOR\n            self.width    *= SHRINK_FACTOR\n            self.height   *= SHRINK_FACTOR\n            self.depth    *= SHRINK_FACTOR",
        "begin_line": 1493,
        "end_line": 1499,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009208103130755065,
            "pseudo_dstar_susp": 0.0007680491551459293,
            "pseudo_tarantula_susp": 0.0005889281507656066,
            "pseudo_op2_susp": 0.0007680491551459293,
            "pseudo_barinel_susp": 0.0005889281507656066
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Accent._update_metrics#1515",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Accent",
        "signature": "lib.matplotlib.mathtext.Accent._update_metrics(self)",
        "snippet": "    def _update_metrics(self):\n        metrics = self._metrics = self.font_output.get_metrics(\n            self.font, self.font_class, self.c, self.fontsize, self.dpi)\n        self.width = metrics.xmax - metrics.xmin\n        self.height = metrics.ymax - metrics.ymin\n        self.depth = 0",
        "begin_line": 1515,
        "end_line": 1520,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003522367030644593,
            "pseudo_dstar_susp": 0.00029231218941829873,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00029231218941829873,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Accent.shrink#1522",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Accent",
        "signature": "lib.matplotlib.mathtext.Accent.shrink(self)",
        "snippet": "    def shrink(self):\n        Char.shrink(self)\n        self._update_metrics()",
        "begin_line": 1522,
        "end_line": 1524,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00024172105390379503,
            "pseudo_dstar_susp": 0.0002034587995930824,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0002034587995930824,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Accent.render#1530",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Accent",
        "signature": "lib.matplotlib.mathtext.Accent.render(self, x, y)",
        "snippet": "    def render(self, x, y):\n        \"\"\"\n        Render the character to the canvas.\n        \"\"\"\n        self.font_output.render_glyph(\n            x - self._metrics.xmin, y + self._metrics.ymin,\n            self.font, self.font_class, self.c, self.fontsize, self.dpi)",
        "begin_line": 1530,
        "end_line": 1536,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003522367030644593,
            "pseudo_dstar_susp": 0.00029231218941829873,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00029231218941829873,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.List.__init__#1543",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.List",
        "signature": "lib.matplotlib.mathtext.List.__init__(self, elements)",
        "snippet": "    def __init__(self, elements):\n        Box.__init__(self, 0., 0., 0.)\n        self.shift_amount = 0.   # An arbitrary offset\n        self.children     = elements  # The child nodes of this list\n        # The following parameters are set in the vpack and hpack functions\n        self.glue_set     = 0.   # The glue setting of this list\n        self.glue_sign    = 0    # 0: normal, -1: shrinking, 1: stretching\n        self.glue_order   = 0    # The order of infinity (0 - 3) for the glue",
        "begin_line": 1543,
        "end_line": 1550,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001976284584980237,
            "pseudo_dstar_susp": 0.0015128593040847202,
            "pseudo_tarantula_susp": 0.0004911591355599214,
            "pseudo_op2_susp": 0.0015128593040847202,
            "pseudo_barinel_susp": 0.0004911591355599214
        }
    },
    {
        "name": "lib.matplotlib.mathtext.List._determine_order#1560",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.List",
        "signature": "lib.matplotlib.mathtext.List._determine_order(totals)",
        "snippet": "    def _determine_order(totals):\n        \"\"\"\n        Determine the highest order of glue used by the members of this list.\n\n        Helper function used by vpack and hpack.\n        \"\"\"\n        for i in range(len(totals))[::-1]:\n            if totals[i] != 0:\n                return i\n        return 0",
        "begin_line": 1560,
        "end_line": 1569,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007412898443291327,
            "pseudo_dstar_susp": 0.0006697923643670462,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0006697923643670462,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.List._set_glue#1571",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.List",
        "signature": "lib.matplotlib.mathtext.List._set_glue(self, x, sign, totals, error_type)",
        "snippet": "    def _set_glue(self, x, sign, totals, error_type):\n        o = self._determine_order(totals)\n        self.glue_order = o\n        self.glue_sign = sign\n        if totals[o] != 0.:\n            self.glue_set = x / totals[o]\n        else:\n            self.glue_sign = 0\n            self.glue_ratio = 0.\n        if o == 0:\n            if len(self.children):\n                _log.warning(\"%s %s: %r\",\n                             error_type, self.__class__.__name__, self)",
        "begin_line": 1571,
        "end_line": 1583,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007412898443291327,
            "pseudo_dstar_susp": 0.0006697923643670462,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0006697923643670462,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.List.shrink#1585",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.List",
        "signature": "lib.matplotlib.mathtext.List.shrink(self)",
        "snippet": "    def shrink(self):\n        for child in self.children:\n            child.shrink()\n        Box.shrink(self)\n        if self.size < NUM_SIZE_LEVELS:\n            self.shift_amount *= SHRINK_FACTOR\n            self.glue_set     *= SHRINK_FACTOR",
        "begin_line": 1585,
        "end_line": 1591,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009199632014719411,
            "pseudo_dstar_susp": 0.0007662835249042146,
            "pseudo_tarantula_susp": 0.0005871990604815032,
            "pseudo_op2_susp": 0.0007662835249042146,
            "pseudo_barinel_susp": 0.0005871990604815032
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Hlist.__init__#1605",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Hlist",
        "signature": "lib.matplotlib.mathtext.Hlist.__init__(self, elements, w=0.0, m='additional', do_kern=True)",
        "snippet": "    def __init__(self, elements, w=0., m='additional', do_kern=True):\n        List.__init__(self, elements)\n        if do_kern:\n            self.kern()\n        self.hpack()",
        "begin_line": 1605,
        "end_line": 1609,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018796992481203006,
            "pseudo_dstar_susp": 0.0009057971014492754,
            "pseudo_tarantula_susp": 0.0005027652086475615,
            "pseudo_op2_susp": 0.0009057971014492754,
            "pseudo_barinel_susp": 0.0005027652086475615
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Hlist.kern#1611",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Hlist",
        "signature": "lib.matplotlib.mathtext.Hlist.kern(self)",
        "snippet": "    def kern(self):\n        \"\"\"\n        Insert :class:`Kern` nodes between :class:`Char` nodes to set\n        kerning.  The :class:`Char` nodes themselves determine the\n        amount of kerning they need (in :meth:`~Char.get_kerning`),\n        and this function just creates the linked list in the correct\n        way.\n        \"\"\"\n        new_children = []\n        num_children = len(self.children)\n        if num_children:\n            for i in range(num_children):\n                elem = self.children[i]\n                if i < num_children - 1:\n                    next = self.children[i + 1]\n                else:\n                    next = None\n\n                new_children.append(elem)\n                kerning_distance = elem.get_kerning(next)\n                if kerning_distance != 0.:\n                    kern = Kern(kerning_distance)\n                    new_children.append(kern)\n            self.children = new_children",
        "begin_line": 1611,
        "end_line": 1634,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0036900369003690036,
            "pseudo_dstar_susp": 0.0015723270440251573,
            "pseudo_tarantula_susp": 0.0006097560975609756,
            "pseudo_op2_susp": 0.0015723270440251573,
            "pseudo_barinel_susp": 0.0006097560975609756
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Hlist.hpack#1650",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Hlist",
        "signature": "lib.matplotlib.mathtext.Hlist.hpack(self, w=0.0, m='additional')",
        "snippet": "    def hpack(self, w=0., m='additional'):\n        r\"\"\"\n        The main duty of :meth:`hpack` is to compute the dimensions of\n        the resulting boxes, and to adjust the glue if one of those\n        dimensions is pre-specified.  The computed sizes normally\n        enclose all of the material inside the new box; but some items\n        may stick out if negative glue is used, if the box is\n        overfull, or if a ``\\vbox`` includes other boxes that have\n        been shifted left.\n\n          - *w*: specifies a width\n\n          - *m*: is either 'exactly' or 'additional'.\n\n        Thus, ``hpack(w, 'exactly')`` produces a box whose width is\n        exactly *w*, while ``hpack(w, 'additional')`` yields a box\n        whose width is the natural width plus *w*.  The default values\n        produce a box with the natural width.\n        \"\"\"\n        # I don't know why these get reset in TeX.  Shift_amount is pretty\n        # much useless if we do.\n        # self.shift_amount = 0.\n        h = 0.\n        d = 0.\n        x = 0.\n        total_stretch = [0.] * 4\n        total_shrink = [0.] * 4\n        for p in self.children:\n            if isinstance(p, Char):\n                x += p.width\n                h = max(h, p.height)\n                d = max(d, p.depth)\n            elif isinstance(p, Box):\n                x += p.width\n                if not np.isinf(p.height) and not np.isinf(p.depth):\n                    s = getattr(p, 'shift_amount', 0.)\n                    h = max(h, p.height - s)\n                    d = max(d, p.depth + s)\n            elif isinstance(p, Glue):\n                glue_spec = p.glue_spec\n                x += glue_spec.width\n                total_stretch[glue_spec.stretch_order] += glue_spec.stretch\n                total_shrink[glue_spec.shrink_order] += glue_spec.shrink\n            elif isinstance(p, Kern):\n                x += p.width\n        self.height = h\n        self.depth = d\n\n        if m == 'additional':\n            w += x\n        self.width = w\n        x = w - x\n\n        if x == 0.:\n            self.glue_sign = 0\n            self.glue_order = 0\n            self.glue_ratio = 0.\n            return\n        if x > 0.:\n            self._set_glue(x, 1, total_stretch, \"Overfull\")\n        else:\n            self._set_glue(x, -1, total_shrink, \"Underfull\")",
        "begin_line": 1650,
        "end_line": 1711,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0048543689320388345,
            "pseudo_dstar_susp": 0.0016025641025641025,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0016025641025641025,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Vlist.__init__#1718",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Vlist",
        "signature": "lib.matplotlib.mathtext.Vlist.__init__(self, elements, h=0.0, m='additional')",
        "snippet": "    def __init__(self, elements, h=0., m='additional'):\n        List.__init__(self, elements)\n        self.vpack()",
        "begin_line": 1718,
        "end_line": 1720,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008865248226950354,
            "pseudo_dstar_susp": 0.0007326007326007326,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0007326007326007326,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Vlist.vpack#1722",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Vlist",
        "signature": "lib.matplotlib.mathtext.Vlist.vpack(self, h=0.0, m='additional', l=np.inf)",
        "snippet": "    def vpack(self, h=0., m='additional', l=np.inf):\n        \"\"\"\n        The main duty of :meth:`vpack` is to compute the dimensions of\n        the resulting boxes, and to adjust the glue if one of those\n        dimensions is pre-specified.\n\n          - *h*: specifies a height\n          - *m*: is either 'exactly' or 'additional'.\n          - *l*: a maximum height\n\n        Thus, ``vpack(h, 'exactly')`` produces a box whose height is\n        exactly *h*, while ``vpack(h, 'additional')`` yields a box\n        whose height is the natural height plus *h*.  The default\n        values produce a box with the natural width.\n        \"\"\"\n        # I don't know why these get reset in TeX.  Shift_amount is pretty\n        # much useless if we do.\n        # self.shift_amount = 0.\n        w = 0.\n        d = 0.\n        x = 0.\n        total_stretch = [0.] * 4\n        total_shrink = [0.] * 4\n        for p in self.children:\n            if isinstance(p, Box):\n                x += d + p.height\n                d = p.depth\n                if not np.isinf(p.width):\n                    s = getattr(p, 'shift_amount', 0.)\n                    w = max(w, p.width + s)\n            elif isinstance(p, Glue):\n                x += d\n                d = 0.\n                glue_spec = p.glue_spec\n                x += glue_spec.width\n                total_stretch[glue_spec.stretch_order] += glue_spec.stretch\n                total_shrink[glue_spec.shrink_order] += glue_spec.shrink\n            elif isinstance(p, Kern):\n                x += d + p.width\n                d = 0.\n            elif isinstance(p, Char):\n                raise RuntimeError(\n                    \"Internal mathtext error: Char node found in Vlist\")\n\n        self.width = w\n        if d > l:\n            x += d - l\n            self.depth = l\n        else:\n            self.depth = d\n\n        if m == 'additional':\n            h += x\n        self.height = h\n        x = h - x\n\n        if x == 0:\n            self.glue_sign = 0\n            self.glue_order = 0\n            self.glue_ratio = 0.\n            return\n\n        if x > 0.:\n            self._set_glue(x, 1, total_stretch, \"Overfull\")\n        else:\n            self._set_glue(x, -1, total_shrink, \"Underfull\")",
        "begin_line": 1722,
        "end_line": 1787,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008865248226950354,
            "pseudo_dstar_susp": 0.0007326007326007326,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0007326007326007326,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Rule.__init__#1800",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Rule",
        "signature": "lib.matplotlib.mathtext.Rule.__init__(self, width, height, depth, state)",
        "snippet": "    def __init__(self, width, height, depth, state):\n        Box.__init__(self, width, height, depth)\n        self.font_output = state.font_output",
        "begin_line": 1800,
        "end_line": 1802,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006863417982155113,
            "pseudo_dstar_susp": 0.0006293266205160479,
            "pseudo_tarantula_susp": 0.0006464124111182935,
            "pseudo_op2_susp": 0.0006293266205160479,
            "pseudo_barinel_susp": 0.0006464124111182935
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Rule.render#1804",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Rule",
        "signature": "lib.matplotlib.mathtext.Rule.render(self, x, y, w, h)",
        "snippet": "    def render(self, x, y, w, h):\n        self.font_output.render_rect_filled(x, y, x + w, y + h)",
        "begin_line": 1804,
        "end_line": 1805,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00066711140760507,
            "pseudo_dstar_susp": 0.000445632798573975,
            "pseudo_tarantula_susp": 0.0006309148264984228,
            "pseudo_op2_susp": 0.000445632798573975,
            "pseudo_barinel_susp": 0.0006309148264984228
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Hrule.__init__#1812",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Hrule",
        "signature": "lib.matplotlib.mathtext.Hrule.__init__(self, state, thickness=None)",
        "snippet": "    def __init__(self, state, thickness=None):\n        if thickness is None:\n            thickness = state.font_output.get_underline_thickness(\n                state.font, state.fontsize, state.dpi)\n        height = depth = thickness * 0.5\n        Rule.__init__(self, np.inf, height, depth, state)",
        "begin_line": 1812,
        "end_line": 1817,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006882312456985547,
            "pseudo_dstar_susp": 0.0006309148264984228,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0006309148264984228,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Glue.__init__#1837",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Glue",
        "signature": "lib.matplotlib.mathtext.Glue.__init__(self, glue_type, copy=False)",
        "snippet": "    def __init__(self, glue_type, copy=False):\n        Node.__init__(self)\n        self.glue_subtype   = 'normal'\n        if isinstance(glue_type, str):\n            glue_spec = GlueSpec.factory(glue_type)\n        elif isinstance(glue_type, GlueSpec):\n            glue_spec = glue_type\n        else:\n            raise ValueError(\"glue_type must be a glue spec name or instance\")\n        if copy:\n            glue_spec = glue_spec.copy()\n        self.glue_spec      = glue_spec",
        "begin_line": 1837,
        "end_line": 1848,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007412898443291327,
            "pseudo_dstar_susp": 0.0006697923643670462,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0006697923643670462,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Glue.shrink#1850",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Glue",
        "signature": "lib.matplotlib.mathtext.Glue.shrink(self)",
        "snippet": "    def shrink(self):\n        Node.shrink(self)\n        if self.size < NUM_SIZE_LEVELS:\n            if self.glue_spec.width != 0.:\n                self.glue_spec = self.glue_spec.copy()\n                self.glue_spec.width *= SHRINK_FACTOR",
        "begin_line": 1850,
        "end_line": 1855,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005899705014749262,
            "pseudo_dstar_susp": 0.00033818058843422386,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00033818058843422386,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.GlueSpec.factory#1885",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.GlueSpec",
        "signature": "lib.matplotlib.mathtext.GlueSpec.factory(cls, glue_type)",
        "snippet": "    def factory(cls, glue_type):\n        return cls._types[glue_type]",
        "begin_line": 1885,
        "end_line": 1886,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007363770250368188,
            "pseudo_dstar_susp": 0.0006657789613848203,
            "pseudo_tarantula_susp": 0.000657030223390276,
            "pseudo_op2_susp": 0.0006657789613848203,
            "pseudo_barinel_susp": 0.000657030223390276
        }
    },
    {
        "name": "lib.matplotlib.mathtext.SsGlue.__init__#1935",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.SsGlue",
        "signature": "lib.matplotlib.mathtext.SsGlue.__init__(self)",
        "snippet": "    def __init__(self):\n        Glue.__init__(self, 'ss')",
        "begin_line": 1935,
        "end_line": 1936,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007183908045977011,
            "pseudo_dstar_susp": 0.0006514657980456026,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0006514657980456026,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.HCentered.__init__#1944",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.HCentered",
        "signature": "lib.matplotlib.mathtext.HCentered.__init__(self, elements)",
        "snippet": "    def __init__(self, elements):\n        Hlist.__init__(self, [SsGlue()] + elements + [SsGlue()],\n                       do_kern=False)",
        "begin_line": 1944,
        "end_line": 1946,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007183908045977011,
            "pseudo_dstar_susp": 0.0006514657980456026,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0006514657980456026,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Kern.__init__#1971",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Kern",
        "signature": "lib.matplotlib.mathtext.Kern.__init__(self, width)",
        "snippet": "    def __init__(self, width):\n        Node.__init__(self)\n        self.width = width",
        "begin_line": 1971,
        "end_line": 1973,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0036900369003690036,
            "pseudo_dstar_susp": 0.0009881422924901185,
            "pseudo_tarantula_susp": 0.0006097560975609756,
            "pseudo_op2_susp": 0.0009881422924901185,
            "pseudo_barinel_susp": 0.0006097560975609756
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Kern.shrink#1978",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Kern",
        "signature": "lib.matplotlib.mathtext.Kern.shrink(self)",
        "snippet": "    def shrink(self):\n        Node.shrink(self)\n        if self.size < NUM_SIZE_LEVELS:\n            self.width *= SHRINK_FACTOR",
        "begin_line": 1978,
        "end_line": 1981,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009132420091324201,
            "pseudo_dstar_susp": 0.0007656967840735069,
            "pseudo_tarantula_susp": 0.0005376344086021505,
            "pseudo_op2_susp": 0.0007656967840735069,
            "pseudo_barinel_susp": 0.0005376344086021505
        }
    },
    {
        "name": "lib.matplotlib.mathtext.AutoHeightChar.__init__#2011",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.AutoHeightChar",
        "signature": "lib.matplotlib.mathtext.AutoHeightChar.__init__(self, c, height, depth, state, always=False, factor=None)",
        "snippet": "    def __init__(self, c, height, depth, state, always=False, factor=None):\n        alternatives = state.font_output.get_sized_alternatives_for_symbol(\n            state.font, c)\n\n        xHeight = state.font_output.get_xheight(\n            state.font, state.fontsize, state.dpi)\n\n        state = state.copy()\n        target_total = height + depth\n        for fontname, sym in alternatives:\n            state.font = fontname\n            char = Char(sym, state)\n            # Ensure that size 0 is chosen when the text is regular sized but\n            # with descender glyphs by subtracting 0.2 * xHeight\n            if char.height + char.depth >= target_total - 0.2 * xHeight:\n                break\n\n        shift = 0\n        if state.font != 0:\n            if factor is None:\n                factor = (target_total) / (char.height + char.depth)\n            state.fontsize *= factor\n            char = Char(sym, state)\n\n            shift = (depth - char.depth)\n\n        Hlist.__init__(self, [char])\n        self.shift_amount = shift",
        "begin_line": 2011,
        "end_line": 2038,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006329113924050633,
            "pseudo_dstar_susp": 0.0003705075954057058,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0003705075954057058,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.AutoWidthChar.__init__#2049",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.AutoWidthChar",
        "signature": "lib.matplotlib.mathtext.AutoWidthChar.__init__(self, c, width, state, always=False, char_class=Char)",
        "snippet": "    def __init__(self, c, width, state, always=False, char_class=Char):\n        alternatives = state.font_output.get_sized_alternatives_for_symbol(\n            state.font, c)\n\n        state = state.copy()\n        for fontname, sym in alternatives:\n            state.font = fontname\n            char = char_class(sym, state)\n            if char.width >= width:\n                break\n\n        factor = width / char.width\n        state.fontsize *= factor\n        char = char_class(sym, state)\n\n        Hlist.__init__(self, [char])\n        self.width = char.width",
        "begin_line": 2049,
        "end_line": 2065,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00024172105390379503,
            "pseudo_dstar_susp": 0.0002034587995930824,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0002034587995930824,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Ship.__call__#2078",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Ship",
        "signature": "lib.matplotlib.mathtext.Ship.__call__(self, ox, oy, box)",
        "snippet": "    def __call__(self, ox, oy, box):\n        self.max_push    = 0  # Deepest nesting of push commands so far\n        self.cur_s       = 0\n        self.cur_v       = 0.\n        self.cur_h       = 0.\n        self.off_h       = ox\n        self.off_v       = oy + box.height\n        self.hlist_out(box)",
        "begin_line": 2078,
        "end_line": 2085,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0036900369003690036,
            "pseudo_dstar_susp": 0.0015455950540958269,
            "pseudo_tarantula_susp": 0.0006097560975609756,
            "pseudo_op2_susp": 0.0015455950540958269,
            "pseudo_barinel_susp": 0.0006097560975609756
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Ship.clamp#2088",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Ship",
        "signature": "lib.matplotlib.mathtext.Ship.clamp(value)",
        "snippet": "    def clamp(value):\n        if value < -1000000000.:\n            return -1000000000.\n        if value > 1000000000.:\n            return 1000000000.\n        return value",
        "begin_line": 2088,
        "end_line": 2093,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007412898443291327,
            "pseudo_dstar_susp": 0.0006697923643670462,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0006697923643670462,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Ship.hlist_out#2095",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Ship",
        "signature": "lib.matplotlib.mathtext.Ship.hlist_out(self, box)",
        "snippet": "    def hlist_out(self, box):\n        cur_g         = 0\n        cur_glue      = 0.\n        glue_order    = box.glue_order\n        glue_sign     = box.glue_sign\n        base_line     = self.cur_v\n        left_edge     = self.cur_h\n        self.cur_s    += 1\n        self.max_push = max(self.cur_s, self.max_push)\n        clamp         = self.clamp\n\n        for p in box.children:\n            if isinstance(p, Char):\n                p.render(self.cur_h + self.off_h, self.cur_v + self.off_v)\n                self.cur_h += p.width\n            elif isinstance(p, Kern):\n                self.cur_h += p.width\n            elif isinstance(p, List):\n                # node623\n                if len(p.children) == 0:\n                    self.cur_h += p.width\n                else:\n                    edge = self.cur_h\n                    self.cur_v = base_line + p.shift_amount\n                    if isinstance(p, Hlist):\n                        self.hlist_out(p)\n                    else:\n                        # p.vpack(box.height + box.depth, 'exactly')\n                        self.vlist_out(p)\n                    self.cur_h = edge + p.width\n                    self.cur_v = base_line\n            elif isinstance(p, Box):\n                # node624\n                rule_height = p.height\n                rule_depth  = p.depth\n                rule_width  = p.width\n                if np.isinf(rule_height):\n                    rule_height = box.height\n                if np.isinf(rule_depth):\n                    rule_depth = box.depth\n                if rule_height > 0 and rule_width > 0:\n                    self.cur_v = base_line + rule_depth\n                    p.render(self.cur_h + self.off_h,\n                             self.cur_v + self.off_v,\n                             rule_width, rule_height)\n                    self.cur_v = base_line\n                self.cur_h += rule_width\n            elif isinstance(p, Glue):\n                # node625\n                glue_spec = p.glue_spec\n                rule_width = glue_spec.width - cur_g\n                if glue_sign != 0:  # normal\n                    if glue_sign == 1:  # stretching\n                        if glue_spec.stretch_order == glue_order:\n                            cur_glue += glue_spec.stretch\n                            cur_g = round(clamp(box.glue_set * cur_glue))\n                    elif glue_spec.shrink_order == glue_order:\n                        cur_glue += glue_spec.shrink\n                        cur_g = round(clamp(box.glue_set * cur_glue))\n                rule_width += cur_g\n                self.cur_h += rule_width\n        self.cur_s -= 1",
        "begin_line": 2095,
        "end_line": 2156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0036900369003690036,
            "pseudo_dstar_susp": 0.0015455950540958269,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0015455950540958269,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Ship.vlist_out#2158",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Ship",
        "signature": "lib.matplotlib.mathtext.Ship.vlist_out(self, box)",
        "snippet": "    def vlist_out(self, box):\n        cur_g         = 0\n        cur_glue      = 0.\n        glue_order    = box.glue_order\n        glue_sign     = box.glue_sign\n        self.cur_s    += 1\n        self.max_push = max(self.max_push, self.cur_s)\n        left_edge     = self.cur_h\n        self.cur_v    -= box.height\n        top_edge      = self.cur_v\n        clamp         = self.clamp\n\n        for p in box.children:\n            if isinstance(p, Kern):\n                self.cur_v += p.width\n            elif isinstance(p, List):\n                if len(p.children) == 0:\n                    self.cur_v += p.height + p.depth\n                else:\n                    self.cur_v += p.height\n                    self.cur_h = left_edge + p.shift_amount\n                    save_v = self.cur_v\n                    p.width = box.width\n                    if isinstance(p, Hlist):\n                        self.hlist_out(p)\n                    else:\n                        self.vlist_out(p)\n                    self.cur_v = save_v + p.depth\n                    self.cur_h = left_edge\n            elif isinstance(p, Box):\n                rule_height = p.height\n                rule_depth = p.depth\n                rule_width = p.width\n                if np.isinf(rule_width):\n                    rule_width = box.width\n                rule_height += rule_depth\n                if rule_height > 0 and rule_depth > 0:\n                    self.cur_v += rule_height\n                    p.render(self.cur_h + self.off_h,\n                             self.cur_v + self.off_v,\n                             rule_width, rule_height)\n            elif isinstance(p, Glue):\n                glue_spec = p.glue_spec\n                rule_height = glue_spec.width - cur_g\n                if glue_sign != 0:  # normal\n                    if glue_sign == 1:  # stretching\n                        if glue_spec.stretch_order == glue_order:\n                            cur_glue += glue_spec.stretch\n                            cur_g = round(clamp(box.glue_set * cur_glue))\n                    elif glue_spec.shrink_order == glue_order:  # shrinking\n                        cur_glue += glue_spec.shrink\n                        cur_g = round(clamp(box.glue_set * cur_glue))\n                rule_height += cur_g\n                self.cur_v += rule_height\n            elif isinstance(p, Char):\n                raise RuntimeError(\n                    \"Internal mathtext error: Char node found in vlist\")\n        self.cur_s -= 1",
        "begin_line": 2158,
        "end_line": 2215,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008865248226950354,
            "pseudo_dstar_susp": 0.0007326007326007326,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0007326007326007326,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.__init__#2321",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.__init__(self)",
        "snippet": "    def __init__(self):\n        p = types.SimpleNamespace()\n        # All forward declarations are here\n        p.accent           = Forward()\n        p.ambi_delim       = Forward()\n        p.apostrophe       = Forward()\n        p.auto_delim       = Forward()\n        p.binom            = Forward()\n        p.bslash           = Forward()\n        p.c_over_c         = Forward()\n        p.customspace      = Forward()\n        p.end_group        = Forward()\n        p.float_literal    = Forward()\n        p.font             = Forward()\n        p.frac             = Forward()\n        p.dfrac            = Forward()\n        p.function         = Forward()\n        p.genfrac          = Forward()\n        p.group            = Forward()\n        p.int_literal      = Forward()\n        p.latexfont        = Forward()\n        p.lbracket         = Forward()\n        p.left_delim       = Forward()\n        p.lbrace           = Forward()\n        p.main             = Forward()\n        p.math             = Forward()\n        p.math_string      = Forward()\n        p.non_math         = Forward()\n        p.operatorname     = Forward()\n        p.overline         = Forward()\n        p.placeable        = Forward()\n        p.rbrace           = Forward()\n        p.rbracket         = Forward()\n        p.required_group   = Forward()\n        p.right_delim      = Forward()\n        p.right_delim_safe = Forward()\n        p.simple           = Forward()\n        p.simple_group     = Forward()\n        p.single_symbol    = Forward()\n        p.snowflake        = Forward()\n        p.space            = Forward()\n        p.sqrt             = Forward()\n        p.stackrel         = Forward()\n        p.start_group      = Forward()\n        p.subsuper         = Forward()\n        p.subsuperop       = Forward()\n        p.symbol           = Forward()\n        p.symbol_name      = Forward()\n        p.token            = Forward()\n        p.unknown_symbol   = Forward()\n\n        # Set names on everything -- very useful for debugging\n        for key, val in vars(p).items():\n            if not key.startswith('_'):\n                val.setName(key)\n\n        p.float_literal <<= Regex(r\"[-+]?([0-9]+\\.?[0-9]*|\\.[0-9]+)\")\n        p.int_literal   <<= Regex(\"[-+]?[0-9]+\")\n\n        p.lbrace        <<= Literal('{').suppress()\n        p.rbrace        <<= Literal('}').suppress()\n        p.lbracket      <<= Literal('[').suppress()\n        p.rbracket      <<= Literal(']').suppress()\n        p.bslash        <<= Literal('\\\\')\n\n        p.space         <<= oneOf(list(self._space_widths))\n        p.customspace   <<= (\n            Suppress(Literal(r'\\hspace'))\n            - ((p.lbrace + p.float_literal + p.rbrace)\n               | Error(r\"Expected \\hspace{n}\"))\n        )\n\n        unicode_range = \"\\U00000080-\\U0001ffff\"\n        p.single_symbol <<= Regex(\n            r\"([a-zA-Z0-9 +\\-*/<>=:,.;!\\?&'@()\\[\\]|%s])|(\\\\[%%${}\\[\\]_|])\" %\n            unicode_range)\n        p.snowflake     <<= Suppress(p.bslash) + oneOf(self._snowflake)\n        p.symbol_name   <<= (\n            Combine(p.bslash + oneOf(list(tex2uni)))\n            + FollowedBy(Regex(\"[^A-Za-z]\").leaveWhitespace() | StringEnd())\n        )\n        p.symbol        <<= (p.single_symbol | p.symbol_name).leaveWhitespace()\n\n        p.apostrophe    <<= Regex(\"'+\")\n\n        p.c_over_c      <<= (\n            Suppress(p.bslash)\n            + oneOf(list(self._char_over_chars))\n        )\n\n        p.accent        <<= Group(\n            Suppress(p.bslash)\n            + oneOf([*self._accent_map, *self._wide_accents])\n            - p.placeable\n        )\n\n        p.function      <<= (\n            Suppress(p.bslash)\n            + oneOf(list(self._function_names))\n        )\n\n        p.start_group    <<= Optional(p.latexfont) + p.lbrace\n        p.end_group      <<= p.rbrace.copy()\n        p.simple_group   <<= Group(p.lbrace + ZeroOrMore(p.token) + p.rbrace)\n        p.required_group <<= Group(p.lbrace + OneOrMore(p.token) + p.rbrace)\n        p.group          <<= Group(\n            p.start_group + ZeroOrMore(p.token) + p.end_group\n        )\n\n        p.font          <<= Suppress(p.bslash) + oneOf(list(self._fontnames))\n        p.latexfont     <<= (\n            Suppress(p.bslash)\n            + oneOf(['math' + x for x in self._fontnames])\n        )\n\n        p.frac          <<= Group(\n            Suppress(Literal(r\"\\frac\"))\n            - ((p.required_group + p.required_group)\n               | Error(r\"Expected \\frac{num}{den}\"))\n        )\n\n        p.dfrac         <<= Group(\n            Suppress(Literal(r\"\\dfrac\"))\n            - ((p.required_group + p.required_group)\n               | Error(r\"Expected \\dfrac{num}{den}\"))\n        )\n\n        p.stackrel      <<= Group(\n            Suppress(Literal(r\"\\stackrel\"))\n            - ((p.required_group + p.required_group)\n               | Error(r\"Expected \\stackrel{num}{den}\"))\n        )\n\n        p.binom         <<= Group(\n            Suppress(Literal(r\"\\binom\"))\n            - ((p.required_group + p.required_group)\n               | Error(r\"Expected \\binom{num}{den}\"))\n        )\n\n        p.ambi_delim    <<= oneOf(list(self._ambi_delim))\n        p.left_delim    <<= oneOf(list(self._left_delim))\n        p.right_delim   <<= oneOf(list(self._right_delim))\n        p.right_delim_safe <<= oneOf([*(self._right_delim - {'}'}), r'\\}'])\n\n        p.genfrac <<= Group(\n            Suppress(Literal(r\"\\genfrac\"))\n            - (((p.lbrace\n                 + Optional(p.ambi_delim | p.left_delim, default='')\n                 + p.rbrace)\n                + (p.lbrace\n                   + Optional(p.ambi_delim | p.right_delim_safe, default='')\n                   + p.rbrace)\n                + (p.lbrace + p.float_literal + p.rbrace)\n                + p.simple_group + p.required_group + p.required_group)\n               | Error(\"Expected \"\n                       r\"\\genfrac{ldelim}{rdelim}{rulesize}{style}{num}{den}\"))\n        )\n\n        p.sqrt <<= Group(\n            Suppress(Literal(r\"\\sqrt\"))\n            - ((Optional(p.lbracket + p.int_literal + p.rbracket, default=None)\n                + p.required_group)\n               | Error(\"Expected \\\\sqrt{value}\"))\n        )\n\n        p.overline <<= Group(\n            Suppress(Literal(r\"\\overline\"))\n            - (p.required_group | Error(\"Expected \\\\overline{value}\"))\n        )\n\n        p.unknown_symbol <<= Combine(p.bslash + Regex(\"[A-Za-z]*\"))\n\n        p.operatorname <<= Group(\n            Suppress(Literal(r\"\\operatorname\"))\n            - ((p.lbrace + ZeroOrMore(p.simple | p.unknown_symbol) + p.rbrace)\n               | Error(\"Expected \\\\operatorname{value}\"))\n        )\n\n        p.placeable     <<= (\n            p.snowflake  # Must be before accent so named symbols that are\n                         # prefixed with an accent name work\n            | p.accent   # Must be before symbol as all accents are symbols\n            | p.symbol   # Must be third to catch all named symbols and single\n                         # chars not in a group\n            | p.c_over_c\n            | p.function\n            | p.group\n            | p.frac\n            | p.dfrac\n            | p.stackrel\n            | p.binom\n            | p.genfrac\n            | p.sqrt\n            | p.overline\n            | p.operatorname\n        )\n\n        p.simple        <<= (\n            p.space\n            | p.customspace\n            | p.font\n            | p.subsuper\n        )\n\n        p.subsuperop    <<= oneOf([\"_\", \"^\"])\n\n        p.subsuper      <<= Group(\n            (Optional(p.placeable)\n             + OneOrMore(p.subsuperop - p.placeable)\n             + Optional(p.apostrophe))\n            | (p.placeable + Optional(p.apostrophe))\n            | p.apostrophe\n        )\n\n        p.token         <<= (\n            p.simple\n            | p.auto_delim\n            | p.unknown_symbol  # Must be last\n        )\n\n        p.auto_delim    <<= (\n            Suppress(Literal(r\"\\left\"))\n            - ((p.left_delim | p.ambi_delim)\n               | Error(\"Expected a delimiter\"))\n            + Group(ZeroOrMore(p.simple | p.auto_delim))\n            + Suppress(Literal(r\"\\right\"))\n            - ((p.right_delim | p.ambi_delim)\n               | Error(\"Expected a delimiter\"))\n        )\n\n        p.math          <<= OneOrMore(p.token)\n\n        p.math_string   <<= QuotedString('$', '\\\\', unquoteResults=False)\n\n        p.non_math      <<= Regex(r\"(?:(?:\\\\[$])|[^$])*\").leaveWhitespace()\n\n        p.main          <<= (\n            p.non_math + ZeroOrMore(p.math_string + p.non_math) + StringEnd()\n        )\n\n        # Set actions\n        for key, val in vars(p).items():\n            if not key.startswith('_'):\n                if hasattr(self, key):\n                    val.setParseAction(getattr(self, key))\n\n        self._expression = p.main\n        self._math_expression = p.math",
        "begin_line": 2321,
        "end_line": 2568,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.parse#2570",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.parse(self, s, fonts_object, fontsize, dpi)",
        "snippet": "    def parse(self, s, fonts_object, fontsize, dpi):\n        \"\"\"\n        Parse expression *s* using the given *fonts_object* for\n        output, at the given *fontsize* and *dpi*.\n\n        Returns the parse tree of :class:`Node` instances.\n        \"\"\"\n        self._state_stack = [\n            self.State(fonts_object, 'default', 'rm', fontsize, dpi)]\n        self._em_width_cache = {}\n        try:\n            result = self._expression.parseString(s)\n        except ParseBaseException as err:\n            raise ValueError(\"\\n\".join([\"\",\n                                        err.line,\n                                        \" \" * (err.column - 1) + \"^\",\n                                        str(err)]))\n        self._state_stack = None\n        self._em_width_cache = {}\n        self._expression.resetCache()\n        return result[0]",
        "begin_line": 2570,
        "end_line": 2590,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00303951367781155,
            "pseudo_dstar_susp": 0.0015455950540958269,
            "pseudo_tarantula_susp": 0.0005820721769499418,
            "pseudo_op2_susp": 0.0015455950540958269,
            "pseudo_barinel_susp": 0.0005820721769499418
        }
    },
    {
        "name": "lib.matplotlib.mathtext.State.__init__#2603",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.State",
        "signature": "lib.matplotlib.mathtext.State.__init__(self, font_output, font, font_class, fontsize, dpi)",
        "snippet": "        def __init__(self, font_output, font, font_class, fontsize, dpi):\n            self.font_output = font_output\n            self._font = font\n            self.font_class = font_class\n            self.fontsize = fontsize\n            self.dpi = dpi",
        "begin_line": 2603,
        "end_line": 2608,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018796992481203006,
            "pseudo_dstar_susp": 0.0014792899408284023,
            "pseudo_tarantula_susp": 0.0005027652086475615,
            "pseudo_op2_susp": 0.0014792899408284023,
            "pseudo_barinel_susp": 0.0005027652086475615
        }
    },
    {
        "name": "lib.matplotlib.mathtext.State.copy#2610",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.State",
        "signature": "lib.matplotlib.mathtext.State.copy(self)",
        "snippet": "        def copy(self):\n            return Parser.State(\n                self.font_output,\n                self.font,\n                self.font_class,\n                self.fontsize,\n                self.dpi)",
        "begin_line": 2610,
        "end_line": 2616,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018796992481203006,
            "pseudo_dstar_susp": 0.0014792899408284023,
            "pseudo_tarantula_susp": 0.0005027652086475615,
            "pseudo_op2_susp": 0.0014792899408284023,
            "pseudo_barinel_susp": 0.0005027652086475615
        }
    },
    {
        "name": "lib.matplotlib.mathtext.State.font#2619",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.State",
        "signature": "lib.matplotlib.mathtext.State.font(self)",
        "snippet": "        def font(self):\n            return self._font",
        "begin_line": 2619,
        "end_line": 2620,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017331022530329288,
            "pseudo_dstar_susp": 0.0014792899408284023,
            "pseudo_tarantula_susp": 0.00048262548262548264,
            "pseudo_op2_susp": 0.0014792899408284023,
            "pseudo_barinel_susp": 0.00048262548262548264
        }
    },
    {
        "name": "lib.matplotlib.mathtext.State.font#2623",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.State",
        "signature": "lib.matplotlib.mathtext.State.font(self, name)",
        "snippet": "        def font(self, name):\n            if name == \"circled\":\n                cbook.warn_deprecated(\n                    \"3.1\", name=\"\\\\mathcircled\", obj_type=\"mathtext command\",\n                    alternative=\"unicode characters (e.g. '\\\\N{CIRCLED LATIN \"\n                    \"CAPITAL LETTER A}' or '\\\\u24b6')\")\n            if name in ('rm', 'it', 'bf'):\n                self.font_class = name\n            self._font = name",
        "begin_line": 2623,
        "end_line": 2631,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017761989342806395,
            "pseudo_dstar_susp": 0.0008857395925597874,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0008857395925597874,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.get_state#2633",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.get_state(self)",
        "snippet": "    def get_state(self):\n        \"\"\"\n        Get the current :class:`State` of the parser.\n        \"\"\"\n        return self._state_stack[-1]",
        "begin_line": 2633,
        "end_line": 2637,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017331022530329288,
            "pseudo_dstar_susp": 0.0014792899408284023,
            "pseudo_tarantula_susp": 0.00048262548262548264,
            "pseudo_op2_susp": 0.0014792899408284023,
            "pseudo_barinel_susp": 0.00048262548262548264
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.pop_state#2639",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.pop_state(self)",
        "snippet": "    def pop_state(self):\n        \"\"\"\n        Pop a :class:`State` off of the stack.\n        \"\"\"\n        self._state_stack.pop()",
        "begin_line": 2639,
        "end_line": 2643,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004608294930875576,
            "pseudo_dstar_susp": 0.0015772870662460567,
            "pseudo_tarantula_susp": 0.0005611672278338945,
            "pseudo_op2_susp": 0.0015772870662460567,
            "pseudo_barinel_susp": 0.0005611672278338945
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.push_state#2645",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.push_state(self)",
        "snippet": "    def push_state(self):\n        \"\"\"\n        Push a new :class:`State` onto the stack which is just a copy\n        of the current state.\n        \"\"\"\n        self._state_stack.append(self.get_state().copy())",
        "begin_line": 2645,
        "end_line": 2650,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018796992481203006,
            "pseudo_dstar_susp": 0.0009057971014492754,
            "pseudo_tarantula_susp": 0.0005027652086475615,
            "pseudo_op2_susp": 0.0009057971014492754,
            "pseudo_barinel_susp": 0.0005027652086475615
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.main#2652",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.main(self, s, loc, toks)",
        "snippet": "    def main(self, s, loc, toks):\n        return [Hlist(toks)]",
        "begin_line": 2652,
        "end_line": 2653,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002898550724637681,
            "pseudo_dstar_susp": 0.0015455950540958269,
            "pseudo_tarantula_susp": 0.000555247084952804,
            "pseudo_op2_susp": 0.0015455950540958269,
            "pseudo_barinel_susp": 0.000555247084952804
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.math_string#2655",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.math_string(self, s, loc, toks)",
        "snippet": "    def math_string(self, s, loc, toks):\n        return self._math_expression.parseString(toks[0][1:-1])",
        "begin_line": 2655,
        "end_line": 2656,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017331022530329288,
            "pseudo_dstar_susp": 0.0014792899408284023,
            "pseudo_tarantula_susp": 0.00048262548262548264,
            "pseudo_op2_susp": 0.0014792899408284023,
            "pseudo_barinel_susp": 0.00048262548262548264
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.math#2658",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.math(self, s, loc, toks)",
        "snippet": "    def math(self, s, loc, toks):\n        hlist = Hlist(toks)\n        self.pop_state()\n        return [hlist]",
        "begin_line": 2658,
        "end_line": 2661,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00303951367781155,
            "pseudo_dstar_susp": 0.0015455950540958269,
            "pseudo_tarantula_susp": 0.0005820721769499418,
            "pseudo_op2_susp": 0.0015455950540958269,
            "pseudo_barinel_susp": 0.0005820721769499418
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.non_math#2663",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.non_math(self, s, loc, toks)",
        "snippet": "    def non_math(self, s, loc, toks):\n        s = toks[0].replace(r'\\$', '$')\n        symbols = [Char(c, self.get_state(), math=False) for c in s]\n        hlist = Hlist(symbols)\n        # We're going into math now, so set font to 'it'\n        self.push_state()\n        self.get_state().font = rcParams['mathtext.default']\n        return [hlist]",
        "begin_line": 2663,
        "end_line": 2670,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017761989342806395,
            "pseudo_dstar_susp": 0.0014792899408284023,
            "pseudo_tarantula_susp": 0.0004965243296921549,
            "pseudo_op2_susp": 0.0014792899408284023,
            "pseudo_barinel_susp": 0.0004965243296921549
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser._make_space#2672",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser._make_space(self, percentage)",
        "snippet": "    def _make_space(self, percentage):\n        # All spaces are relative to em width\n        state = self.get_state()\n        key = (state.font, state.fontsize, state.dpi)\n        width = self._em_width_cache.get(key)\n        if width is None:\n            metrics = state.font_output.get_metrics(\n                state.font, rcParams['mathtext.default'], 'm', state.fontsize,\n                state.dpi)\n            width = metrics.advance\n            self._em_width_cache[key] = width\n        return Kern(width * percentage)",
        "begin_line": 2672,
        "end_line": 2683,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007704160246533128,
            "pseudo_dstar_susp": 0.0006882312456985547,
            "pseudo_tarantula_susp": 0.0005837711617046118,
            "pseudo_op2_susp": 0.0006882312456985547,
            "pseudo_barinel_susp": 0.0005837711617046118
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.space#2700",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.space(self, s, loc, toks)",
        "snippet": "    def space(self, s, loc, toks):\n        assert len(toks) == 1\n        num = self._space_widths[toks[0]]\n        box = self._make_space(num)\n        return [box]",
        "begin_line": 2700,
        "end_line": 2704,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005361930294906167,
            "pseudo_dstar_susp": 0.00031959092361776926,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00031959092361776926,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.customspace#2706",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.customspace(self, s, loc, toks)",
        "snippet": "    def customspace(self, s, loc, toks):\n        return [self._make_space(float(toks[0]))]",
        "begin_line": 2706,
        "end_line": 2707,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00024172105390379503,
            "pseudo_dstar_susp": 0.0002034587995930824,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0002034587995930824,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.symbol#2709",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.symbol(self, s, loc, toks)",
        "snippet": "    def symbol(self, s, loc, toks):\n        c = toks[0]\n        try:\n            char = Char(c, self.get_state())\n        except ValueError:\n            raise ParseFatalException(s, loc, \"Unknown symbol: %s\" % c)\n\n        if c in self._spaced_symbols:\n            # iterate until we find previous character, needed for cases\n            # such as ${ -2}$, $ -2$, or $   -2$.\n            prev_char = next((c for c in s[:loc][::-1] if c != ' '), '')\n            # Binary operators at start of string should not be spaced\n            if (c in self._binary_operators and\n                    (len(s[:loc].split()) == 0 or prev_char == '{' or\n                     prev_char in self._left_delim)):\n                return [char]\n            else:\n                return [Hlist([self._make_space(0.2),\n                               char,\n                               self._make_space(0.2)],\n                               do_kern = True)]\n        elif c in self._punctuation_symbols:\n\n            # Do not space commas between brackets\n            if c == ',':\n                prev_char = next((c for c in s[:loc][::-1] if c != ' '), '')\n                next_char = next((c for c in s[loc + 1:] if c != ' '), '')\n                if prev_char == '{' and next_char == '}':\n                    return [char]\n\n            # Do not space dots as decimal separators\n            if c == '.' and s[loc - 1].isdigit() and s[loc + 1].isdigit():\n                return [char]\n            else:\n                return [Hlist([char,\n                               self._make_space(0.2)],\n                               do_kern = True)]\n        return [char]",
        "begin_line": 2709,
        "end_line": 2746,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0047169811320754715,
            "pseudo_dstar_susp": 0.001589825119236884,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.001589825119236884,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.unknown_symbol#2750",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.unknown_symbol(self, s, loc, toks)",
        "snippet": "    def unknown_symbol(self, s, loc, toks):\n        c = toks[0]\n        raise ParseFatalException(s, loc, \"Unknown symbol: %s\" % c)",
        "begin_line": 2750,
        "end_line": 2752,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.accent#2826",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.accent(self, s, loc, toks)",
        "snippet": "    def accent(self, s, loc, toks):\n        assert len(toks) == 1\n        state = self.get_state()\n        thickness = state.font_output.get_underline_thickness(\n            state.font, state.fontsize, state.dpi)\n        if len(toks[0]) != 2:\n            raise ParseFatalException(\"Error parsing accent\")\n        accent, sym = toks[0]\n        if accent in self._wide_accents:\n            accent_box = AutoWidthChar(\n                '\\\\' + accent, sym.width, state, char_class=Accent)\n        else:\n            accent_box = Accent(self._accent_map[accent], state)\n        if accent == 'mathring':\n            accent_box.shrink()\n            accent_box.shrink()\n        centered = HCentered([Hbox(sym.width / 4.0), accent_box])\n        centered.hpack(sym.width, 'exactly')\n        return Vlist([\n                centered,\n                Vbox(0., thickness * 2.0),\n                Hlist([sym])\n                ])",
        "begin_line": 2826,
        "end_line": 2848,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003522367030644593,
            "pseudo_dstar_susp": 0.00029231218941829873,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00029231218941829873,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.function#2850",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.function(self, s, loc, toks)",
        "snippet": "    def function(self, s, loc, toks):\n        self.push_state()\n        state = self.get_state()\n        state.font = 'rm'\n        hlist = Hlist([Char(c, state) for c in toks[0]])\n        self.pop_state()\n        hlist.function_name = toks[0]\n        return hlist",
        "begin_line": 2850,
        "end_line": 2857,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003522367030644593,
            "pseudo_dstar_susp": 0.00029231218941829873,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00029231218941829873,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.operatorname#2859",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.operatorname(self, s, loc, toks)",
        "snippet": "    def operatorname(self, s, loc, toks):\n        self.push_state()\n        state = self.get_state()\n        state.font = 'rm'\n        # Change the font of Chars, but leave Kerns alone\n        for c in toks[0]:\n            if isinstance(c, Char):\n                c.font = 'rm'\n                c._update_metrics()\n        self.pop_state()\n        return Hlist(toks[0])",
        "begin_line": 2859,
        "end_line": 2869,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00024172105390379503,
            "pseudo_dstar_susp": 0.0002034587995930824,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0002034587995930824,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.start_group#2871",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.start_group(self, s, loc, toks)",
        "snippet": "    def start_group(self, s, loc, toks):\n        self.push_state()\n        # Deal with LaTeX-style font tokens\n        if len(toks):\n            self.get_state().font = toks[0][4:]\n        return []",
        "begin_line": 2871,
        "end_line": 2876,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009551098376313276,
            "pseudo_dstar_susp": 0.0008291873963515755,
            "pseudo_tarantula_susp": 0.0006578947368421052,
            "pseudo_op2_susp": 0.0008291873963515755,
            "pseudo_barinel_susp": 0.0006578947368421052
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.group#2878",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.group(self, s, loc, toks)",
        "snippet": "    def group(self, s, loc, toks):\n        grp = Hlist(toks[0])\n        return [grp]",
        "begin_line": 2878,
        "end_line": 2880,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010976948408342481,
            "pseudo_dstar_susp": 0.0008424599831508003,
            "pseudo_tarantula_susp": 0.0006600660066006601,
            "pseudo_op2_susp": 0.0008424599831508003,
            "pseudo_barinel_susp": 0.0006600660066006601
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.end_group#2883",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.end_group(self, s, loc, toks)",
        "snippet": "    def end_group(self, s, loc, toks):\n        self.pop_state()\n        return []",
        "begin_line": 2883,
        "end_line": 2885,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009569377990430622,
            "pseudo_dstar_susp": 0.0008305647840531562,
            "pseudo_tarantula_susp": 0.0005595970900951316,
            "pseudo_op2_susp": 0.0008305647840531562,
            "pseudo_barinel_susp": 0.0005595970900951316
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.font#2887",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.font(self, s, loc, toks)",
        "snippet": "    def font(self, s, loc, toks):\n        assert len(toks) == 1\n        name = toks[0]\n        self.get_state().font = name\n        return []",
        "begin_line": 2887,
        "end_line": 2891,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003522367030644593,
            "pseudo_dstar_susp": 0.00029231218941829873,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00029231218941829873,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.is_overunder#2893",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.is_overunder(self, nucleus)",
        "snippet": "    def is_overunder(self, nucleus):\n        if isinstance(nucleus, Char):\n            return nucleus.c in self._overunder_symbols\n        elif isinstance(nucleus, Hlist) and hasattr(nucleus, 'function_name'):\n            return nucleus.function_name in self._overunder_functions\n        return False",
        "begin_line": 2893,
        "end_line": 2898,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008968609865470852,
            "pseudo_dstar_susp": 0.000744047619047619,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.000744047619047619,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.is_dropsub#2900",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.is_dropsub(self, nucleus)",
        "snippet": "    def is_dropsub(self, nucleus):\n        if isinstance(nucleus, Char):\n            return nucleus.c in self._dropsub_symbols\n        return False",
        "begin_line": 2900,
        "end_line": 2903,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008460236886632825,
            "pseudo_dstar_susp": 0.0007092198581560284,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0007092198581560284,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.is_slanted#2905",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.is_slanted(self, nucleus)",
        "snippet": "    def is_slanted(self, nucleus):\n        if isinstance(nucleus, Char):\n            return nucleus.is_slanted()\n        return False",
        "begin_line": 2905,
        "end_line": 2908,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008460236886632825,
            "pseudo_dstar_susp": 0.0007092198581560284,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0007092198581560284,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.subsuper#2913",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.subsuper(self, s, loc, toks)",
        "snippet": "    def subsuper(self, s, loc, toks):\n        assert len(toks) == 1\n\n        nucleus = None\n        sub = None\n        super = None\n\n        # Pick all of the apostrophes out, including first apostrophes that\n        # have been parsed as characters\n        napostrophes = 0\n        new_toks = []\n        for tok in toks[0]:\n            if isinstance(tok, str) and tok not in ('^', '_'):\n                napostrophes += len(tok)\n            elif isinstance(tok, Char) and tok.c == \"'\":\n                napostrophes += 1\n            else:\n                new_toks.append(tok)\n        toks = new_toks\n\n        if len(toks) == 0:\n            assert napostrophes\n            nucleus = Hbox(0.0)\n        elif len(toks) == 1:\n            if not napostrophes:\n                return toks[0]  # .asList()\n            else:\n                nucleus = toks[0]\n        elif len(toks) in (2, 3):\n            # single subscript or superscript\n            nucleus = toks[0] if len(toks) == 3 else Hbox(0.0)\n            op, next = toks[-2:]\n            if op == '_':\n                sub = next\n            else:\n                super = next\n        elif len(toks) in (4, 5):\n            # subscript and superscript\n            nucleus = toks[0] if len(toks) == 5 else Hbox(0.0)\n            op1, next1, op2, next2 = toks[-4:]\n            if op1 == op2:\n                if op1 == '_':\n                    raise ParseFatalException(\"Double subscript\")\n                else:\n                    raise ParseFatalException(\"Double superscript\")\n            if op1 == '_':\n                sub = next1\n                super = next2\n            else:\n                super = next1\n                sub = next2\n        else:\n            raise ParseFatalException(\n                \"Subscript/superscript sequence is too long. \"\n                \"Use braces { } to remove ambiguity.\")\n\n        state = self.get_state()\n        rule_thickness = state.font_output.get_underline_thickness(\n            state.font, state.fontsize, state.dpi)\n        xHeight = state.font_output.get_xheight(\n            state.font, state.fontsize, state.dpi)\n\n        if napostrophes:\n            if super is None:\n                super = Hlist([])\n            for i in range(napostrophes):\n                super.children.extend(self.symbol(s, loc, ['\\\\prime']))\n            # kern() and hpack() needed to get the metrics right after\n            # extending\n            super.kern()\n            super.hpack()\n\n        # Handle over/under symbols, such as sum or integral\n        if self.is_overunder(nucleus):\n            vlist = []\n            shift = 0.\n            width = nucleus.width\n            if super is not None:\n                super.shrink()\n                width = max(width, super.width)\n            if sub is not None:\n                sub.shrink()\n                width = max(width, sub.width)\n\n            if super is not None:\n                hlist = HCentered([super])\n                hlist.hpack(width, 'exactly')\n                vlist.extend([hlist, Kern(rule_thickness * 3.0)])\n            hlist = HCentered([nucleus])\n            hlist.hpack(width, 'exactly')\n            vlist.append(hlist)\n            if sub is not None:\n                hlist = HCentered([sub])\n                hlist.hpack(width, 'exactly')\n                vlist.extend([Kern(rule_thickness * 3.0), hlist])\n                shift = hlist.height\n            vlist = Vlist(vlist)\n            vlist.shift_amount = shift + nucleus.depth\n            result = Hlist([vlist])\n            return [result]\n\n        # We remove kerning on the last character for consistency (otherwise\n        # it will compute kerning based on non-shrunk characters and may put\n        # them too close together when superscripted)\n        # We change the width of the last character to match the advance to\n        # consider some fonts with weird metrics: e.g. stix's f has a width of\n        # 7.75 and a kerning of -4.0 for an advance of 3.72, and we want to put\n        # the superscript at the advance\n        last_char = nucleus\n        if isinstance(nucleus, Hlist):\n            new_children = nucleus.children\n            if len(new_children):\n                # remove last kern\n                if (isinstance(new_children[-1], Kern) and\n                        hasattr(new_children[-2], '_metrics')):\n                    new_children = new_children[:-1]\n                last_char = new_children[-1]\n                if hasattr(last_char, '_metrics'):\n                    last_char.width = last_char._metrics.advance\n            # create new Hlist without kerning\n            nucleus = Hlist(new_children, do_kern=False)\n        else:\n            if isinstance(nucleus, Char):\n                last_char.width = last_char._metrics.advance\n            nucleus = Hlist([nucleus])\n\n        # Handle regular sub/superscripts\n        constants = _get_font_constant_set(state)\n        lc_height   = last_char.height\n        lc_baseline = 0\n        if self.is_dropsub(last_char):\n            lc_baseline = last_char.depth\n\n        # Compute kerning for sub and super\n        superkern = constants.delta * xHeight\n        subkern = constants.delta * xHeight\n        if self.is_slanted(last_char):\n            superkern += constants.delta * xHeight\n            superkern += (constants.delta_slanted *\n                          (lc_height - xHeight * 2. / 3.))\n            if self.is_dropsub(last_char):\n                subkern = (3 * constants.delta -\n                           constants.delta_integral) * lc_height\n                superkern = (3 * constants.delta +\n                             constants.delta_integral) * lc_height\n            else:\n                subkern = 0\n\n        if super is None:\n            # node757\n            x = Hlist([Kern(subkern), sub])\n            x.shrink()\n            if self.is_dropsub(last_char):\n                shift_down = lc_baseline + constants.subdrop * xHeight\n            else:\n                shift_down = constants.sub1 * xHeight\n            x.shift_amount = shift_down\n        else:\n            x = Hlist([Kern(superkern), super])\n            x.shrink()\n            if self.is_dropsub(last_char):\n                shift_up = lc_height - constants.subdrop * xHeight\n            else:\n                shift_up = constants.sup1 * xHeight\n            if sub is None:\n                x.shift_amount = -shift_up\n            else:  # Both sub and superscript\n                y = Hlist([Kern(subkern), sub])\n                y.shrink()\n                if self.is_dropsub(last_char):\n                    shift_down = lc_baseline + constants.subdrop * xHeight\n                else:\n                    shift_down = constants.sub2 * xHeight\n                # If sub and superscript collide, move super up\n                clr = (2.0 * rule_thickness -\n                       ((shift_up - x.depth) - (y.height - shift_down)))\n                if clr > 0.:\n                    shift_up += clr\n                x = Vlist([\n                    x,\n                    Kern((shift_up - x.depth) - (y.height - shift_down)),\n                    y])\n                x.shift_amount = shift_down\n\n        if not self.is_dropsub(last_char):\n            x.width += constants.script_space * xHeight\n        result = Hlist([nucleus, x])\n\n        return [result]",
        "begin_line": 2913,
        "end_line": 3101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0047169811320754715,
            "pseudo_dstar_susp": 0.001589825119236884,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.001589825119236884,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser._genfrac#3103",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser._genfrac(self, ldelim, rdelim, rule, style, num, den)",
        "snippet": "    def _genfrac(self, ldelim, rdelim, rule, style, num, den):\n        state = self.get_state()\n        thickness = state.font_output.get_underline_thickness(\n            state.font, state.fontsize, state.dpi)\n\n        rule = float(rule)\n\n        # If style != displaystyle == 0, shrink the num and den\n        if style != self._math_style_dict['displaystyle']:\n            num.shrink()\n            den.shrink()\n        cnum = HCentered([num])\n        cden = HCentered([den])\n        width = max(num.width, den.width)\n        cnum.hpack(width, 'exactly')\n        cden.hpack(width, 'exactly')\n        vlist = Vlist([cnum,                      # numerator\n                       Vbox(0, thickness * 2.0),  # space\n                       Hrule(state, rule),        # rule\n                       Vbox(0, thickness * 2.0),  # space\n                       cden                       # denominator\n                       ])\n\n        # Shift so the fraction line sits in the middle of the\n        # equals sign\n        metrics = state.font_output.get_metrics(\n            state.font, rcParams['mathtext.default'],\n            '=', state.fontsize, state.dpi)\n        shift = (cden.height -\n                 ((metrics.ymax + metrics.ymin) / 2 -\n                  thickness * 3.0))\n        vlist.shift_amount = shift\n\n        result = [Hlist([vlist, Hbox(thickness * 2.)])]\n        if ldelim or rdelim:\n            if ldelim == '':\n                ldelim = '.'\n            if rdelim == '':\n                rdelim = '.'\n            return self._auto_sized_delimiter(ldelim, result, rdelim)\n        return result",
        "begin_line": 3103,
        "end_line": 3143,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006743088334457181,
            "pseudo_dstar_susp": 0.0005296610169491525,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0005296610169491525,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.genfrac#3145",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.genfrac(self, s, loc, toks)",
        "snippet": "    def genfrac(self, s, loc, toks):\n        assert len(toks) == 1\n        assert len(toks[0]) == 6\n\n        return self._genfrac(*tuple(toks[0]))",
        "begin_line": 3145,
        "end_line": 3149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00024172105390379503,
            "pseudo_dstar_susp": 0.0002034587995930824,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0002034587995930824,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.frac#3151",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.frac(self, s, loc, toks)",
        "snippet": "    def frac(self, s, loc, toks):\n        assert len(toks) == 1\n        assert len(toks[0]) == 2\n        state = self.get_state()\n\n        thickness = state.font_output.get_underline_thickness(\n            state.font, state.fontsize, state.dpi)\n        num, den = toks[0]\n\n        return self._genfrac('', '', thickness,\n                             self._math_style_dict['textstyle'], num, den)",
        "begin_line": 3151,
        "end_line": 3161,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006493506493506494,
            "pseudo_dstar_susp": 0.00037979491074819596,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00037979491074819596,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.dfrac#3163",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.dfrac(self, s, loc, toks)",
        "snippet": "    def dfrac(self, s, loc, toks):\n        assert len(toks) == 1\n        assert len(toks[0]) == 2\n        state = self.get_state()\n\n        thickness = state.font_output.get_underline_thickness(\n            state.font, state.fontsize, state.dpi)\n        num, den = toks[0]\n\n        return self._genfrac('', '', thickness,\n                             self._math_style_dict['displaystyle'], num, den)",
        "begin_line": 3163,
        "end_line": 3173,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00024172105390379503,
            "pseudo_dstar_susp": 0.0002034587995930824,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0002034587995930824,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.stackrel#3177",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.stackrel(self, s, loc, toks)",
        "snippet": "    def stackrel(self, s, loc, toks):\n        assert len(toks) == 1\n        assert len(toks[0]) == 2\n        num, den = toks[0]\n\n        return self._genfrac('', '', 0.0,\n                             self._math_style_dict['textstyle'], num, den)",
        "begin_line": 3177,
        "end_line": 3183,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00024172105390379503,
            "pseudo_dstar_susp": 0.0002034587995930824,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0002034587995930824,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.binom#3185",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.binom(self, s, loc, toks)",
        "snippet": "    def binom(self, s, loc, toks):\n        assert len(toks) == 1\n        assert len(toks[0]) == 2\n        num, den = toks[0]\n\n        return self._genfrac('(', ')', 0.0,\n                             self._math_style_dict['textstyle'], num, den)",
        "begin_line": 3185,
        "end_line": 3191,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002962962962962963,
            "pseudo_dstar_susp": 0.00023849272597185786,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00023849272597185786,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.sqrt#3193",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.sqrt(self, s, loc, toks)",
        "snippet": "    def sqrt(self, s, loc, toks):\n        root, body = toks[0]\n        state = self.get_state()\n        thickness = state.font_output.get_underline_thickness(\n            state.font, state.fontsize, state.dpi)\n\n        # Determine the height of the body, and add a little extra to\n        # the height so it doesn't seem cramped\n        height = body.height - body.shift_amount + thickness * 5.0\n        depth = body.depth + body.shift_amount\n        check = AutoHeightChar(r'\\__sqrt__', height, depth, state, always=True)\n        height = check.height - check.shift_amount\n        depth = check.depth + check.shift_amount\n\n        # Put a little extra space to the left and right of the body\n        padded_body = Hlist([Hbox(thickness * 2.0),\n                             body,\n                             Hbox(thickness * 2.0)])\n        rightside = Vlist([Hrule(state),\n                           Fill(),\n                           padded_body])\n        # Stretch the glue between the hrule and the body\n        rightside.vpack(height + (state.fontsize * state.dpi) / (100.0 * 12.0),\n                        'exactly', depth)\n\n        # Add the root and shift it upward so it is above the tick.\n        # The value of 0.6 is a hard-coded hack ;)\n        if root is None:\n            root = Box(check.width * 0.5, 0., 0.)\n        else:\n            root = Hlist([Char(x, state) for x in root])\n            root.shrink()\n            root.shrink()\n\n        root_vlist = Vlist([Hlist([root])])\n        root_vlist.shift_amount = -height * 0.6\n\n        hlist = Hlist([root_vlist,               # Root\n                       # Negative kerning to put root over tick\n                       Kern(-check.width * 0.5),\n                       check,                    # Check\n                       rightside])               # Body\n        return [hlist]",
        "begin_line": 3193,
        "end_line": 3235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003663003663003663,
            "pseudo_dstar_susp": 0.00029568302779420464,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00029568302779420464,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.overline#3237",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.overline(self, s, loc, toks)",
        "snippet": "    def overline(self, s, loc, toks):\n        assert len(toks) == 1\n        assert len(toks[0]) == 1\n\n        body = toks[0][0]\n\n        state = self.get_state()\n        thickness = state.font_output.get_underline_thickness(\n            state.font, state.fontsize, state.dpi)\n\n        height = body.height - body.shift_amount + thickness * 3.0\n        depth = body.depth + body.shift_amount\n\n        # Place overline above body\n        rightside = Vlist([Hrule(state),\n                           Fill(),\n                           Hlist([body])])\n\n        # Stretch the glue between the hrule and the body\n        rightside.vpack(height + (state.fontsize * state.dpi) / (100.0 * 12.0),\n                        'exactly', depth)\n\n        hlist = Hlist([rightside])\n        return [hlist]",
        "begin_line": 3237,
        "end_line": 3260,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00024172105390379503,
            "pseudo_dstar_susp": 0.0002034587995930824,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0002034587995930824,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser._auto_sized_delimiter#3262",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser._auto_sized_delimiter(self, front, middle, back)",
        "snippet": "    def _auto_sized_delimiter(self, front, middle, back):\n        state = self.get_state()\n        if len(middle):\n            height = max(x.height for x in middle)\n            depth = max(x.depth for x in middle)\n            factor = None\n        else:\n            height = 0\n            depth = 0\n            factor = 1.0\n        parts = []\n        # \\left. and \\right. aren't supposed to produce any symbols\n        if front != '.':\n            parts.append(\n                AutoHeightChar(front, height, depth, state, factor=factor))\n        parts.extend(middle)\n        if back != '.':\n            parts.append(\n                AutoHeightChar(back, height, depth, state, factor=factor))\n        hlist = Hlist(parts)\n        return hlist",
        "begin_line": 3262,
        "end_line": 3282,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006108735491753207,
            "pseudo_dstar_susp": 0.00035124692658939234,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00035124692658939234,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.auto_delim#3284",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.auto_delim(self, s, loc, toks)",
        "snippet": "    def auto_delim(self, s, loc, toks):\n        front, middle, back = toks\n\n        return self._auto_sized_delimiter(front, middle.asList(), back)",
        "begin_line": 3284,
        "end_line": 3287,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005952380952380953,
            "pseudo_dstar_susp": 0.0003447087211306446,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0003447087211306446,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.mathtext.MathTextParser.__init__#3316",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.MathTextParser",
        "signature": "lib.matplotlib.mathtext.MathTextParser.__init__(self, output)",
        "snippet": "    def __init__(self, output):\n        \"\"\"\n        Create a MathTextParser for the given backend *output*.\n        \"\"\"\n        self._output = output.lower()",
        "begin_line": 3316,
        "end_line": 3320,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012547051442910915,
            "pseudo_dstar_susp": 0.0023148148148148147,
            "pseudo_tarantula_susp": 0.00035373187124159886,
            "pseudo_op2_susp": 0.0023148148148148147,
            "pseudo_barinel_susp": 0.00035373187124159886
        }
    },
    {
        "name": "lib.matplotlib.mathtext.MathTextParser.parse#3323",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.MathTextParser",
        "signature": "lib.matplotlib.mathtext.MathTextParser.parse(self, s, dpi=72, prop=None)",
        "snippet": "    def parse(self, s, dpi = 72, prop = None):\n        \"\"\"\n        Parse the given math expression *s* at the given *dpi*.  If\n        *prop* is provided, it is a\n        :class:`~matplotlib.font_manager.FontProperties` object\n        specifying the \"default\" font to use in the math expression,\n        used for all non-math text.\n\n        The results are cached, so multiple calls to :meth:`parse`\n        with the same expression should be fast.\n        \"\"\"\n\n        if prop is None:\n            prop = FontProperties()\n\n        if self._output == 'ps' and rcParams['ps.useafm']:\n            font_output = StandardPsFonts(prop)\n        else:\n            backend = self._backend_mapping[self._output]()\n            fontset = rcParams['mathtext.fontset'].lower()\n            fontset_class = cbook._check_getitem(\n                self._font_type_mapping, fontset=fontset)\n            font_output = fontset_class(prop, backend)\n\n        fontsize = prop.get_size_in_points()\n\n        # This is a class variable so we don't rebuild the parser\n        # with each request.\n        if self._parser is None:\n            self.__class__._parser = Parser()\n\n        box = self._parser.parse(s, font_output, fontsize, dpi)\n        font_output.set_canvas_size(box.width, box.height, box.depth)\n        return font_output.get_results(box)",
        "begin_line": 3323,
        "end_line": 3356,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002898550724637681,
            "pseudo_dstar_susp": 0.0015455950540958269,
            "pseudo_tarantula_susp": 0.000555247084952804,
            "pseudo_op2_susp": 0.0015455950540958269,
            "pseudo_barinel_susp": 0.000555247084952804
        }
    },
    {
        "name": "lib.matplotlib.lines._get_dash_pattern#31",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines",
        "signature": "lib.matplotlib.lines._get_dash_pattern(style)",
        "snippet": "def _get_dash_pattern(style):\n    \"\"\"Convert linestyle -> dash pattern\n    \"\"\"\n    # go from short hand -> full strings\n    if isinstance(style, str):\n        style = ls_mapper.get(style, style)\n    # un-dashed styles\n    if style in ['solid', 'None']:\n        offset, dashes = None, None\n    # dashed styles\n    elif style in ['dashed', 'dashdot', 'dotted']:\n        offset = 0\n        dashes = tuple(rcParams['lines.{}_pattern'.format(style)])\n    #\n    elif isinstance(style, tuple):\n        offset, dashes = style\n    else:\n        raise ValueError('Unrecognized linestyle: %s' % str(style))\n\n    # normalize offset to be positive and shorter than the dash cycle\n    if dashes is not None and offset is not None:\n        dsum = sum(dashes)\n        if dsum:\n            offset %= dsum\n\n    return offset, dashes",
        "begin_line": 31,
        "end_line": 56,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.037037037037037035,
            "pseudo_dstar_susp": 0.25,
            "pseudo_tarantula_susp": 0.000434593654932638,
            "pseudo_op2_susp": 0.25,
            "pseudo_barinel_susp": 0.000434593654932638
        }
    },
    {
        "name": "lib.matplotlib.lines._scale_dashes#59",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines",
        "signature": "lib.matplotlib.lines._scale_dashes(offset, dashes, lw)",
        "snippet": "def _scale_dashes(offset, dashes, lw):\n    if not rcParams['lines.scale_dashes']:\n        return offset, dashes\n\n    scaled_offset = scaled_dashes = None\n    if offset is not None:\n        scaled_offset = offset * lw\n    if dashes is not None:\n        scaled_dashes = [x * lw if x is not None else None\n                         for x in dashes]\n\n    return scaled_offset, scaled_dashes",
        "begin_line": 59,
        "end_line": 70,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.038461538461538464,
            "pseudo_dstar_susp": 0.2,
            "pseudo_tarantula_susp": 0.0002771618625277162,
            "pseudo_op2_susp": 0.2,
            "pseudo_barinel_susp": 0.0002771618625277162
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.__init__#269",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.__init__(self, xdata, ydata, linewidth=None, linestyle=None, color=None, marker=None, markersize=None, markeredgewidth=None, markeredgecolor=None, markerfacecolor=None, markerfacecoloralt='none', fillstyle=None, antialiased=None, dash_capstyle=None, solid_capstyle=None, dash_joinstyle=None, solid_joinstyle=None, pickradius=5, drawstyle=None, markevery=None, **kwargs)",
        "snippet": "    def __init__(self, xdata, ydata,\n                 linewidth=None,  # all Nones default to rc\n                 linestyle=None,\n                 color=None,\n                 marker=None,\n                 markersize=None,\n                 markeredgewidth=None,\n                 markeredgecolor=None,\n                 markerfacecolor=None,\n                 markerfacecoloralt='none',\n                 fillstyle=None,\n                 antialiased=None,\n                 dash_capstyle=None,\n                 solid_capstyle=None,\n                 dash_joinstyle=None,\n                 solid_joinstyle=None,\n                 pickradius=5,\n                 drawstyle=None,\n                 markevery=None,\n                 **kwargs\n                 ):\n        \"\"\"\n        Create a `.Line2D` instance with *x* and *y* data in sequences of\n        *xdata*, *ydata*.\n\n        Additional keyword arguments are `.Line2D` properties:\n\n        %(_Line2D_docstr)s\n\n        See :meth:`set_linestyle` for a description of the line styles,\n        :meth:`set_marker` for a description of the markers, and\n        :meth:`set_drawstyle` for a description of the draw styles.\n\n        \"\"\"\n        Artist.__init__(self)\n\n        #convert sequences to numpy arrays\n        if not np.iterable(xdata):\n            raise RuntimeError('xdata must be a sequence')\n        if not np.iterable(ydata):\n            raise RuntimeError('ydata must be a sequence')\n\n        if linewidth is None:\n            linewidth = rcParams['lines.linewidth']\n\n        if linestyle is None:\n            linestyle = rcParams['lines.linestyle']\n        if marker is None:\n            marker = rcParams['lines.marker']\n        if markerfacecolor is None:\n            markerfacecolor = rcParams['lines.markerfacecolor']\n        if markeredgecolor is None:\n            markeredgecolor = rcParams['lines.markeredgecolor']\n        if color is None:\n            color = rcParams['lines.color']\n\n        if markersize is None:\n            markersize = rcParams['lines.markersize']\n        if antialiased is None:\n            antialiased = rcParams['lines.antialiased']\n        if dash_capstyle is None:\n            dash_capstyle = rcParams['lines.dash_capstyle']\n        if dash_joinstyle is None:\n            dash_joinstyle = rcParams['lines.dash_joinstyle']\n        if solid_capstyle is None:\n            solid_capstyle = rcParams['lines.solid_capstyle']\n        if solid_joinstyle is None:\n            solid_joinstyle = rcParams['lines.solid_joinstyle']\n\n        if isinstance(linestyle, str):\n            ds, ls = self._split_drawstyle_linestyle(linestyle)\n            if ds is not None and drawstyle is not None and ds != drawstyle:\n                raise ValueError(\"Inconsistent drawstyle ({!r}) and linestyle \"\n                                 \"({!r})\".format(drawstyle, linestyle))\n            linestyle = ls\n\n            if ds is not None:\n                drawstyle = ds\n\n        if drawstyle is None:\n            drawstyle = 'default'\n\n        self._dashcapstyle = None\n        self._dashjoinstyle = None\n        self._solidjoinstyle = None\n        self._solidcapstyle = None\n        self.set_dash_capstyle(dash_capstyle)\n        self.set_dash_joinstyle(dash_joinstyle)\n        self.set_solid_capstyle(solid_capstyle)\n        self.set_solid_joinstyle(solid_joinstyle)\n\n        self._linestyles = None\n        self._drawstyle = None\n        self._linewidth = linewidth\n\n        # scaled dash + offset\n        self._dashSeq = None\n        self._dashOffset = 0\n        # unscaled dash + offset\n        # this is needed scaling the dash pattern by linewidth\n        self._us_dashSeq = None\n        self._us_dashOffset = 0\n\n        self.set_linewidth(linewidth)\n        self.set_linestyle(linestyle)\n        self.set_drawstyle(drawstyle)\n\n        self._color = None\n        self.set_color(color)\n        self._marker = MarkerStyle(marker, fillstyle)\n\n        self._markevery = None\n        self._markersize = None\n        self._antialiased = None\n\n        self.set_markevery(markevery)\n        self.set_antialiased(antialiased)\n        self.set_markersize(markersize)\n\n        self._markeredgecolor = None\n        self._markeredgewidth = None\n        self._markerfacecolor = None\n        self._markerfacecoloralt = None\n\n        self.set_markerfacecolor(markerfacecolor)\n        self.set_markerfacecoloralt(markerfacecoloralt)\n        self.set_markeredgecolor(markeredgecolor)\n        self.set_markeredgewidth(markeredgewidth)\n\n        # update kwargs before updating data to give the caller a\n        # chance to init axes (and hence unit support)\n        self.update(kwargs)\n        self.pickradius = pickradius\n        self.ind_offset = 0\n        if isinstance(self._picker, Number):\n            self.pickradius = self._picker\n\n        self._xorig = np.asarray([])\n        self._yorig = np.asarray([])\n        self._invalidx = True\n        self._invalidy = True\n        self._x = None\n        self._y = None\n        self._xy = None\n        self._path = None\n        self._transformed_path = None\n        self._subslice = False\n        self._x_filled = None  # used in subslicing; only x is needed\n\n        self.set_data(xdata, ydata)",
        "begin_line": 269,
        "end_line": 418,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004570383912248629,
            "pseudo_dstar_susp": 0.0006035003017501509,
            "pseudo_tarantula_susp": 0.00033178500331785003,
            "pseudo_op2_susp": 0.0006035003017501509,
            "pseudo_barinel_susp": 0.00033178500331785003
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_fillstyle#518",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_fillstyle(self)",
        "snippet": "    def get_fillstyle(self):\n        \"\"\"\n        Return the marker fill style.\n\n        See also `~.Line2D.set_fillstyle`.\n        \"\"\"\n        return self._marker.get_fillstyle()",
        "begin_line": 518,
        "end_line": 524,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000513347022587269,
            "pseudo_dstar_susp": 0.00038095238095238096,
            "pseudo_tarantula_susp": 0.000333889816360601,
            "pseudo_op2_susp": 0.00038095238095238096,
            "pseudo_barinel_susp": 0.000333889816360601
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_markevery#547",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_markevery(self, every)",
        "snippet": "    def set_markevery(self, every):\n        \"\"\"Set the markevery property to subsample the plot when using markers.\n\n        e.g., if `every=5`, every 5-th marker will be plotted.\n\n        Parameters\n        ----------\n        every : None or int or (int, int) or slice or List[int] or float or \\\n(float, float)\n            Which markers to plot.\n\n            - every=None, every point will be plotted.\n            - every=N, every N-th marker will be plotted starting with\n              marker 0.\n            - every=(start, N), every N-th marker, starting at point\n              start, will be plotted.\n            - every=slice(start, end, N), every N-th marker, starting at\n              point start, up to but not including point end, will be plotted.\n            - every=[i, j, m, n], only markers at points i, j, m, and n\n              will be plotted.\n            - every=0.1, (i.e. a float) then markers will be spaced at\n              approximately equal distances along the line; the distance\n              along the line between markers is determined by multiplying the\n              display-coordinate distance of the axes bounding-box diagonal\n              by the value of every.\n            - every=(0.5, 0.1) (i.e. a length-2 tuple of float), the same\n              functionality as every=0.1 is exhibited but the first marker will\n              be 0.5 multiplied by the display-coordinate-diagonal-distance\n              along the line.\n\n            For examples see\n            :doc:`/gallery/lines_bars_and_markers/markevery_demo`.\n\n        Notes\n        -----\n        Setting the markevery property will only show markers at actual data\n        points.  When using float arguments to set the markevery property\n        on irregularly spaced data, the markers will likely not appear evenly\n        spaced because the actual data points do not coincide with the\n        theoretical spacing between markers.\n\n        When using a start offset to specify the first marker, the offset will\n        be from the first data point which may be different from the first\n        the visible data point if the plot is zoomed in.\n\n        If zooming in on a plot when using float arguments then the actual\n        data points that have markers will change because the distance between\n        markers is always determined from the display-coordinates\n        axes-bounding-box-diagonal regardless of the actual axes data limits.\n\n        \"\"\"\n        if self._markevery != every:\n            self.stale = True\n        self._markevery = every",
        "begin_line": 547,
        "end_line": 600,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00024515812699190976,
            "pseudo_dstar_susp": 0.00023228803716608595,
            "pseudo_tarantula_susp": 0.0002637826431020839,
            "pseudo_op2_susp": 0.00023228803716608595,
            "pseudo_barinel_susp": 0.0002637826431020839
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_markevery#602",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_markevery(self)",
        "snippet": "    def get_markevery(self):\n        \"\"\"\n        Return the markevery setting for marker subsampling.\n\n        See also `~.Line2D.set_markevery`.\n        \"\"\"\n        return self._markevery",
        "begin_line": 602,
        "end_line": 608,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005216484089723526,
            "pseudo_dstar_susp": 0.0003762227238525207,
            "pseudo_tarantula_susp": 0.0002153316106804479,
            "pseudo_op2_susp": 0.0003762227238525207,
            "pseudo_barinel_susp": 0.0002153316106804479
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.axes#636",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.axes(self, ax)",
        "snippet": "    def axes(self, ax):\n        # call the set method from the base-class property\n        Artist.axes.fset(self, ax)\n        if ax is not None:\n            # connect unit-related callbacks\n            if ax.xaxis is not None:\n                self._xcid = ax.xaxis.callbacks.connect('units',\n                                                        self.recache_always)\n            if ax.yaxis is not None:\n                self._ycid = ax.yaxis.callbacks.connect('units',\n                                                        self.recache_always)",
        "begin_line": 636,
        "end_line": 646,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003713330857779428,
            "pseudo_dstar_susp": 0.0005157297576070139,
            "pseudo_tarantula_susp": 0.00015708451146716933,
            "pseudo_op2_susp": 0.0005157297576070139,
            "pseudo_barinel_susp": 0.00015708451146716933
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_data#648",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_data(self, *args)",
        "snippet": "    def set_data(self, *args):\n        \"\"\"\n        Set the x and y data.\n\n        Parameters\n        ----------\n        *args : (2, N) array or two 1D arrays\n        \"\"\"\n        if len(args) == 1:\n            (x, y), = args\n        else:\n            x, y = args\n\n        self.set_xdata(x)\n        self.set_ydata(y)",
        "begin_line": 648,
        "end_line": 662,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041322314049586776,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0003184713375796178,
            "pseudo_op2_susp": 0.0005711022272986865,
            "pseudo_barinel_susp": 0.0003184713375796178
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.recache#667",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.recache(self, always=False)",
        "snippet": "    def recache(self, always=False):\n        if always or self._invalidx:\n            xconv = self.convert_xunits(self._xorig)\n            x = _to_unmasked_float_array(xconv).ravel()\n        else:\n            x = self._x\n        if always or self._invalidy:\n            yconv = self.convert_yunits(self._yorig)\n            y = _to_unmasked_float_array(yconv).ravel()\n        else:\n            y = self._y\n\n        self._xy = np.column_stack(np.broadcast_arrays(x, y)).astype(float)\n        self._x, self._y = self._xy.T  # views\n\n        self._subslice = False\n        if (self.axes and len(x) > 1000 and self._is_sorted(x) and\n                self.axes.name == 'rectilinear' and\n                self.axes.get_xscale() == 'linear' and\n                self._markevery is None and\n                self.get_clip_on()):\n            self._subslice = True\n            nanmask = np.isnan(x)\n            if nanmask.any():\n                self._x_filled = self._x.copy()\n                indices = np.arange(len(x))\n                self._x_filled[nanmask] = np.interp(indices[nanmask],\n                        indices[~nanmask], self._x[~nanmask])\n            else:\n                self._x_filled = self._x\n\n        if self._path is not None:\n            interpolation_steps = self._path._interpolation_steps\n        else:\n            interpolation_steps = 1\n        xy = STEP_LOOKUP_MAP[self._drawstyle](*self._xy.T)\n        self._path = Path(np.asarray(xy).T,\n                          _interpolation_steps=interpolation_steps)\n        self._transformed_path = None\n        self._invalidx = False\n        self._invalidy = False",
        "begin_line": 667,
        "end_line": 707,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00045641259698767686,
            "pseudo_dstar_susp": 0.0005078720162519045,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0005078720162519045,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D._transform_path#709",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D._transform_path(self, subslice=None)",
        "snippet": "    def _transform_path(self, subslice=None):\n        \"\"\"\n        Puts a TransformedPath instance at self._transformed_path;\n        all invalidation of the transform is then handled by the\n        TransformedPath instance.\n        \"\"\"\n        # Masked arrays are now handled by the Path class itself\n        if subslice is not None:\n            xy = STEP_LOOKUP_MAP[self._drawstyle](*self._xy[subslice, :].T)\n            _path = Path(np.asarray(xy).T,\n                         _interpolation_steps=self._path._interpolation_steps)\n        else:\n            _path = self._path\n        self._transformed_path = TransformedPath(_path, self.get_transform())",
        "begin_line": 709,
        "end_line": 722,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005330490405117271,
            "pseudo_dstar_susp": 0.0003943217665615142,
            "pseudo_tarantula_susp": 0.00035587188612099647,
            "pseudo_op2_susp": 0.0003943217665615142,
            "pseudo_barinel_susp": 0.00035587188612099647
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D._get_transformed_path#724",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D._get_transformed_path(self)",
        "snippet": "    def _get_transformed_path(self):\n        \"\"\"\n        Return the :class:`~matplotlib.transforms.TransformedPath` instance\n        of this line.\n        \"\"\"\n        if self._transformed_path is None:\n            self._transform_path()\n        return self._transformed_path",
        "begin_line": 724,
        "end_line": 731,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003262642740619902,
            "pseudo_dstar_susp": 0.0003254149040026033,
            "pseudo_tarantula_susp": 0.00031938677738741617,
            "pseudo_op2_susp": 0.0003254149040026033,
            "pseudo_barinel_susp": 0.00031938677738741617
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_transform#733",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_transform(self, t)",
        "snippet": "    def set_transform(self, t):\n        \"\"\"\n        Set the Transformation instance used by this artist.\n\n        Parameters\n        ----------\n        t : `matplotlib.transforms.Transform`\n        \"\"\"\n        Artist.set_transform(self, t)\n        self._invalidx = True\n        self._invalidy = True\n        self.stale = True",
        "begin_line": 733,
        "end_line": 744,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00038654812524159255,
            "pseudo_dstar_susp": 0.00046860356138706655,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.00046860356138706655,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D._is_sorted#746",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D._is_sorted(self, x)",
        "snippet": "    def _is_sorted(self, x):\n        \"\"\"Return whether x is sorted in ascending order.\"\"\"\n        # We don't handle the monotonically decreasing case.\n        return _path.is_sorted(x)",
        "begin_line": 746,
        "end_line": 749,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012195121951219512,
            "pseudo_dstar_susp": 0.00011855364552459988,
            "pseudo_tarantula_susp": 0.00015482272797646694,
            "pseudo_op2_susp": 0.00011855364552459988,
            "pseudo_barinel_susp": 0.00015446400988569664
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.draw#752",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        # docstring inherited from Artist.draw.\n\n        if not self.get_visible():\n            return\n\n        if self._invalidy or self._invalidx:\n            self.recache()\n        self.ind_offset = 0  # Needed for contains() method.\n        if self._subslice and self.axes:\n            x0, x1 = self.axes.get_xbound()\n            i0 = self._x_filled.searchsorted(x0, 'left')\n            i1 = self._x_filled.searchsorted(x1, 'right')\n            subslice = slice(max(i0 - 1, 0), i1 + 1)\n            self.ind_offset = subslice.start\n            self._transform_path(subslice)\n        else:\n            subslice = None\n\n        if self.get_path_effects():\n            from matplotlib.patheffects import PathEffectRenderer\n            renderer = PathEffectRenderer(self.get_path_effects(), renderer)\n\n        renderer.open_group('line2d', self.get_gid())\n        if self._lineStyles[self._linestyle] != '_draw_nothing':\n            tpath, affine = (self._get_transformed_path()\n                             .get_transformed_path_and_affine())\n            if len(tpath.vertices):\n                gc = renderer.new_gc()\n                self._set_gc_clip(gc)\n\n                lc_rgba = mcolors.to_rgba(self._color, self._alpha)\n                gc.set_foreground(lc_rgba, isRGBA=True)\n\n                gc.set_antialiased(self._antialiased)\n                gc.set_linewidth(self._linewidth)\n\n                if self.is_dashed():\n                    cap = self._dashcapstyle\n                    join = self._dashjoinstyle\n                else:\n                    cap = self._solidcapstyle\n                    join = self._solidjoinstyle\n                gc.set_joinstyle(join)\n                gc.set_capstyle(cap)\n                gc.set_snap(self.get_snap())\n                if self.get_sketch_params() is not None:\n                    gc.set_sketch_params(*self.get_sketch_params())\n\n                gc.set_dashes(self._dashOffset, self._dashSeq)\n                renderer.draw_path(gc, tpath, affine.frozen())\n                gc.restore()\n\n        if self._marker and self._markersize > 0:\n            gc = renderer.new_gc()\n            self._set_gc_clip(gc)\n            gc.set_linewidth(self._markeredgewidth)\n            gc.set_antialiased(self._antialiased)\n\n            ec_rgba = mcolors.to_rgba(\n                self.get_markeredgecolor(), self._alpha)\n            fc_rgba = mcolors.to_rgba(\n                self._get_markerfacecolor(), self._alpha)\n            fcalt_rgba = mcolors.to_rgba(\n                self._get_markerfacecolor(alt=True), self._alpha)\n            # If the edgecolor is \"auto\", it is set according to the *line*\n            # color but inherits the alpha value of the *face* color, if any.\n            if (cbook._str_equal(self._markeredgecolor, \"auto\")\n                    and not cbook._str_lower_equal(\n                        self.get_markerfacecolor(), \"none\")):\n                ec_rgba = ec_rgba[:3] + (fc_rgba[3],)\n            gc.set_foreground(ec_rgba, isRGBA=True)\n            if self.get_sketch_params() is not None:\n                scale, length, randomness = self.get_sketch_params()\n                gc.set_sketch_params(scale/2, length/2, 2*randomness)\n\n            marker = self._marker\n\n            # Markers *must* be drawn ignoring the drawstyle (but don't pay the\n            # recaching if drawstyle is already \"default\").\n            if self.get_drawstyle() != \"default\":\n                with cbook._setattr_cm(\n                        self, _drawstyle=\"default\", _transformed_path=None):\n                    self.recache()\n                    self._transform_path(subslice)\n                    tpath, affine = (self._get_transformed_path()\n                                    .get_transformed_points_and_affine())\n            else:\n                tpath, affine = (self._get_transformed_path()\n                                 .get_transformed_points_and_affine())\n\n            if len(tpath.vertices):\n                # subsample the markers if markevery is not None\n                markevery = self.get_markevery()\n                if markevery is not None:\n                    subsampled = _mark_every_path(markevery, tpath,\n                                                  affine, self.axes.transAxes)\n                else:\n                    subsampled = tpath\n\n                snap = marker.get_snap_threshold()\n                if isinstance(snap, Real):\n                    snap = renderer.points_to_pixels(self._markersize) >= snap\n                gc.set_snap(snap)\n                gc.set_joinstyle(marker.get_joinstyle())\n                gc.set_capstyle(marker.get_capstyle())\n                marker_path = marker.get_path()\n                marker_trans = marker.get_transform()\n                w = renderer.points_to_pixels(self._markersize)\n\n                if cbook._str_equal(marker.get_marker(), \",\"):\n                    gc.set_linewidth(0)\n                else:\n                    # Don't scale for pixels, and don't stroke them\n                    marker_trans = marker_trans.scale(w)\n                renderer.draw_markers(gc, marker_path, marker_trans,\n                                      subsampled, affine.frozen(),\n                                      fc_rgba)\n\n                alt_marker_path = marker.get_alt_path()\n                if alt_marker_path:\n                    alt_marker_trans = marker.get_alt_transform()\n                    alt_marker_trans = alt_marker_trans.scale(w)\n                    renderer.draw_markers(\n                            gc, alt_marker_path, alt_marker_trans, subsampled,\n                            affine.frozen(), fcalt_rgba)\n\n            gc.restore()\n\n        renderer.close_group('line2d')\n        self.stale = False",
        "begin_line": 752,
        "end_line": 882,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005396654074473826,
            "pseudo_dstar_susp": 0.00039761431411530816,
            "pseudo_tarantula_susp": 0.00021565667457407807,
            "pseudo_op2_susp": 0.00039761431411530816,
            "pseudo_barinel_susp": 0.00021565667457407807
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_drawstyle#896",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_drawstyle(self)",
        "snippet": "    def get_drawstyle(self):\n        \"\"\"\n        Return the drawstyle.\n\n        See also `~.Line2D.set_drawstyle`.\n        \"\"\"\n        return self._drawstyle",
        "begin_line": 896,
        "end_line": 902,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004940711462450593,
            "pseudo_dstar_susp": 0.000380517503805175,
            "pseudo_tarantula_susp": 0.00033422459893048126,
            "pseudo_op2_susp": 0.000380517503805175,
            "pseudo_barinel_susp": 0.00033422459893048126
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_marker#920",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_marker(self)",
        "snippet": "    def get_marker(self):\n        \"\"\"\n        Return the line marker.\n\n        See also `~.Line2D.set_marker`.\n        \"\"\"\n        return self._marker.get_marker()",
        "begin_line": 920,
        "end_line": 926,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_markeredgecolor#928",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_markeredgecolor(self)",
        "snippet": "    def get_markeredgecolor(self):\n        \"\"\"\n        Return the marker edge color.\n\n        See also `~.Line2D.set_markeredgecolor`.\n        \"\"\"\n        mec = self._markeredgecolor\n        if cbook._str_equal(mec, 'auto'):\n            if rcParams['_internal.classic_mode']:\n                if self._marker.get_marker() in ('.', ','):\n                    return self._color\n                if self._marker.is_filled() and self.get_fillstyle() != 'none':\n                    return 'k'  # Bad hard-wired default...\n            return self._color\n        else:\n            return mec",
        "begin_line": 928,
        "end_line": 943,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005279831045406547,
            "pseudo_dstar_susp": 0.00038284839203675346,
            "pseudo_tarantula_susp": 0.00037425149700598805,
            "pseudo_op2_susp": 0.00038284839203675346,
            "pseudo_barinel_susp": 0.00037425149700598805
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D._get_markerfacecolor#953",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D._get_markerfacecolor(self, alt=False)",
        "snippet": "    def _get_markerfacecolor(self, alt=False):\n        fc = self._markerfacecoloralt if alt else self._markerfacecolor\n        if cbook._str_lower_equal(fc, 'auto'):\n            if self.get_fillstyle() == 'none':\n                return 'none'\n            else:\n                return self._color\n        else:\n            return fc",
        "begin_line": 953,
        "end_line": 961,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005194805194805195,
            "pseudo_dstar_susp": 0.0003971405877680699,
            "pseudo_tarantula_susp": 0.00032393909944930353,
            "pseudo_op2_susp": 0.0003971405877680699,
            "pseudo_barinel_susp": 0.00032393909944930353
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_markerfacecolor#963",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_markerfacecolor(self)",
        "snippet": "    def get_markerfacecolor(self):\n        \"\"\"\n        Return the marker face color.\n\n        See also `~.Line2D.set_markerfacecolor`.\n        \"\"\"\n        return self._get_markerfacecolor(alt=False)",
        "begin_line": 963,
        "end_line": 969,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004985044865403788,
            "pseudo_dstar_susp": 0.0003863987635239567,
            "pseudo_tarantula_susp": 0.0003178639542275906,
            "pseudo_op2_susp": 0.0003863987635239567,
            "pseudo_barinel_susp": 0.0003178639542275906
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_data#987",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_data(self, orig=True)",
        "snippet": "    def get_data(self, orig=True):\n        \"\"\"\n        Return the xdata, ydata.\n\n        If *orig* is *True*, return the original data.\n        \"\"\"\n        return self.get_xdata(orig=orig), self.get_ydata(orig=orig)",
        "begin_line": 987,
        "end_line": 993,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_xdata#995",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_xdata(self, orig=True)",
        "snippet": "    def get_xdata(self, orig=True):\n        \"\"\"\n        Return the xdata.\n\n        If *orig* is *True*, return the original data, else the\n        processed data.\n        \"\"\"\n        if orig:\n            return self._xorig\n        if self._invalidx:\n            self.recache()\n        return self._x",
        "begin_line": 995,
        "end_line": 1006,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_ydata#1008",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_ydata(self, orig=True)",
        "snippet": "    def get_ydata(self, orig=True):\n        \"\"\"\n        Return the ydata.\n\n        If *orig* is *True*, return the original data, else the\n        processed data.\n        \"\"\"\n        if orig:\n            return self._yorig\n        if self._invalidy:\n            self.recache()\n        return self._y",
        "begin_line": 1008,
        "end_line": 1019,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_path#1021",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_path(self)",
        "snippet": "    def get_path(self):\n        \"\"\"\n        Return the :class:`~matplotlib.path.Path` object associated\n        with this line.\n        \"\"\"\n        if self._invalidy or self._invalidx:\n            self.recache()\n        return self._path",
        "begin_line": 1021,
        "end_line": 1028,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00037243947858472997,
            "pseudo_dstar_susp": 0.0005367686527106817,
            "pseudo_tarantula_susp": 0.0002860411899313501,
            "pseudo_op2_susp": 0.0005367686527106817,
            "pseudo_barinel_susp": 0.0002860411899313501
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_antialiased#1038",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_antialiased(self, b)",
        "snippet": "    def set_antialiased(self, b):\n        \"\"\"\n        Set whether to use antialiased rendering.\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        if self._antialiased != b:\n            self.stale = True\n        self._antialiased = b",
        "begin_line": 1038,
        "end_line": 1048,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003633720930232558,
            "pseudo_dstar_susp": 0.0005452562704471102,
            "pseudo_tarantula_susp": 0.0002946375957572186,
            "pseudo_op2_susp": 0.0005452562704471102,
            "pseudo_barinel_susp": 0.0002945508100147275
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_color#1050",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_color(self, color)",
        "snippet": "    def set_color(self, color):\n        \"\"\"\n        Set the color of the line.\n\n        Parameters\n        ----------\n        color : color\n        \"\"\"\n        self._color = color\n        self.stale = True",
        "begin_line": 1050,
        "end_line": 1059,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004192872117400419,
            "pseudo_dstar_susp": 0.0006042296072507553,
            "pseudo_tarantula_susp": 0.0002796420581655481,
            "pseudo_op2_susp": 0.0006042296072507553,
            "pseudo_barinel_susp": 0.0002796420581655481
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_drawstyle#1061",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_drawstyle(self, drawstyle)",
        "snippet": "    def set_drawstyle(self, drawstyle):\n        \"\"\"\n        Set the drawstyle of the plot.\n\n        The drawstyle determines how the points are connected.\n\n        Parameters\n        ----------\n        drawstyle : {'default', 'steps', 'steps-pre', 'steps-mid', \\\n'steps-post'}, default: 'default'\n            For 'default', the points are connected with straight lines.\n\n            The steps variants connect the points with step-like lines,\n            i.e. horizontal lines with vertical steps. They differ in the\n            location of the step:\n\n            - 'steps-pre': The step is at the beginning of the line segment,\n              i.e. the line will be at the y-value of point to the right.\n            - 'steps-mid': The step is halfway between the points.\n            - 'steps-post: The step is at the end of the line segment,\n              i.e. the line will be at the y-value of the point to the left.\n            - 'steps' is equal to 'steps-pre' and is maintained for\n              backward-compatibility.\n\n            For examples see :doc:`/gallery/lines_bars_and_markers/step_demo`.\n        \"\"\"\n        if drawstyle is None:\n            drawstyle = 'default'\n        cbook._check_in_list(self.drawStyles, drawstyle=drawstyle)\n        if self._drawstyle != drawstyle:\n            self.stale = True\n            # invalidate to trigger a recache of the path\n            self._invalidx = True\n        self._drawstyle = drawstyle",
        "begin_line": 1061,
        "end_line": 1094,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040225261464199515,
            "pseudo_dstar_susp": 0.0005592841163310962,
            "pseudo_tarantula_susp": 0.0002969121140142518,
            "pseudo_op2_susp": 0.0005592841163310962,
            "pseudo_barinel_susp": 0.0002969121140142518
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_linewidth#1096",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_linewidth(self, w)",
        "snippet": "    def set_linewidth(self, w):\n        \"\"\"\n        Set the line width in points.\n\n        Parameters\n        ----------\n        w : float\n            Line width, in points.\n        \"\"\"\n        w = float(w)\n\n        if self._linewidth != w:\n            self.stale = True\n        self._linewidth = w\n        # rescale the dashes + offset\n        self._dashOffset, self._dashSeq = _scale_dashes(\n            self._us_dashOffset, self._us_dashSeq, self._linewidth)",
        "begin_line": 1096,
        "end_line": 1112,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041999160016799666,
            "pseudo_dstar_susp": 0.0006053268765133172,
            "pseudo_tarantula_susp": 0.00014425851125216387,
            "pseudo_op2_susp": 0.0006053268765133172,
            "pseudo_barinel_susp": 0.00014425851125216387
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D._split_drawstyle_linestyle#1114",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D._split_drawstyle_linestyle(self, ls)",
        "snippet": "    def _split_drawstyle_linestyle(self, ls):\n        \"\"\"\n        Split drawstyle from linestyle string.\n\n        If *ls* is only a drawstyle default to returning a linestyle\n        of '-'.\n\n        Parameters\n        ----------\n        ls : str\n            The linestyle to be processed\n\n        Returns\n        -------\n        ret_ds : str or None\n            If the linestyle string does not contain a drawstyle prefix\n            return None, otherwise return it.\n\n        ls : str\n            The linestyle with the drawstyle (if any) stripped.\n        \"\"\"\n        for ds in self.drawStyleKeys:  # long names are first in the list\n            if ls.startswith(ds):\n                cbook.warn_deprecated(\n                    \"3.1\", message=\"Passing the drawstyle with the linestyle \"\n                    \"as a single string is deprecated since Matplotlib \"\n                    \"%(since)s and support will be removed %(removal)s; \"\n                    \"please pass the drawstyle separately using the drawstyle \"\n                    \"keyword argument to Line2D or set_drawstyle() method (or \"\n                    \"ds/set_ds()).\")\n                return ds, ls[len(ds):] or '-'\n        return None, ls",
        "begin_line": 1114,
        "end_line": 1145,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004224757076468103,
            "pseudo_dstar_susp": 0.0006064281382656155,
            "pseudo_tarantula_susp": 0.00028735632183908046,
            "pseudo_op2_susp": 0.0006064281382656155,
            "pseudo_barinel_susp": 0.00028735632183908046
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_linestyle#1147",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_linestyle(self, ls)",
        "snippet": "    def set_linestyle(self, ls):\n        \"\"\"\n        Set the linestyle of the line.\n\n        Parameters\n        ----------\n        ls : {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}\n            Possible values:\n\n            - A string:\n\n              ===============================   =================\n              Linestyle                         Description\n              ===============================   =================\n              ``'-'`` or ``'solid'``            solid line\n              ``'--'`` or  ``'dashed'``         dashed line\n              ``'-.'`` or  ``'dashdot'``        dash-dotted line\n              ``':'`` or ``'dotted'``           dotted line\n              ``'None'`` or ``' '`` or ``''``   draw nothing\n              ===============================   =================\n\n              Optionally, the string may be preceded by a drawstyle, e.g.\n              ``'steps--'``. See :meth:`set_drawstyle` for details.\n\n            - Alternatively a dash tuple of the following form can be\n              provided::\n\n                  (offset, onoffseq)\n\n              where ``onoffseq`` is an even length tuple of on and off ink\n              in points. See also :meth:`set_dashes`.\n\n            For examples see :doc:`/gallery/lines_bars_and_markers/linestyles`.\n        \"\"\"\n        if isinstance(ls, str):\n            ds, ls = self._split_drawstyle_linestyle(ls)\n            if ds is not None:\n                self.set_drawstyle(ds)\n\n            if ls in [' ', '', 'none']:\n                ls = 'None'\n\n            cbook._check_in_list([*self._lineStyles, *ls_mapper_r], ls=ls)\n            if ls not in self._lineStyles:\n                ls = ls_mapper_r[ls]\n            self._linestyle = ls\n        else:\n            self._linestyle = '--'\n\n        # get the unscaled dashes\n        self._us_dashOffset, self._us_dashSeq = _get_dash_pattern(ls)\n        # compute the linewidth scaled dashes\n        self._dashOffset, self._dashSeq = _scale_dashes(\n            self._us_dashOffset, self._us_dashSeq, self._linewidth)",
        "begin_line": 1147,
        "end_line": 1200,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004192872117400419,
            "pseudo_dstar_susp": 0.0006042296072507553,
            "pseudo_tarantula_susp": 0.0002913752913752914,
            "pseudo_op2_susp": 0.0006042296072507553,
            "pseudo_barinel_susp": 0.0002913752913752914
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_marker#1203",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_marker(self, marker)",
        "snippet": "    def set_marker(self, marker):\n        \"\"\"\n        Set the line marker.\n\n        Parameters\n        ----------\n        marker : marker style\n            See `~matplotlib.markers` for full description of possible\n            arguments.\n        \"\"\"\n        self._marker.set_marker(marker)\n        self.stale = True",
        "begin_line": 1203,
        "end_line": 1214,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00024906600249066,
            "pseudo_dstar_susp": 0.00024826216484607745,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00024826216484607745,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_markeredgecolor#1216",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_markeredgecolor(self, ec)",
        "snippet": "    def set_markeredgecolor(self, ec):\n        \"\"\"\n        Set the marker edge color.\n\n        Parameters\n        ----------\n        ec : color\n        \"\"\"\n        if ec is None:\n            ec = 'auto'\n        if (self._markeredgecolor is None\n                or np.any(self._markeredgecolor != ec)):\n            self.stale = True\n        self._markeredgecolor = ec",
        "begin_line": 1216,
        "end_line": 1229,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004106776180698152,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0002860411899313501,
            "pseudo_op2_susp": 0.0005906674542232723,
            "pseudo_barinel_susp": 0.0002860411899313501
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_markeredgewidth#1231",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_markeredgewidth(self, ew)",
        "snippet": "    def set_markeredgewidth(self, ew):\n        \"\"\"\n        Set the marker edge width in points.\n\n        Parameters\n        ----------\n        ew : float\n             Marker edge width, in points.\n        \"\"\"\n        if ew is None:\n            ew = rcParams['lines.markeredgewidth']\n        if self._markeredgewidth != ew:\n            self.stale = True\n        self._markeredgewidth = ew",
        "begin_line": 1231,
        "end_line": 1244,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004106776180698152,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0002767783005812344,
            "pseudo_op2_susp": 0.0005906674542232723,
            "pseudo_barinel_susp": 0.0002767783005812344
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_markerfacecolor#1246",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_markerfacecolor(self, fc)",
        "snippet": "    def set_markerfacecolor(self, fc):\n        \"\"\"\n        Set the marker face color.\n\n        Parameters\n        ----------\n        fc : color\n        \"\"\"\n        if fc is None:\n            fc = 'auto'\n        if np.any(self._markerfacecolor != fc):\n            self.stale = True\n        self._markerfacecolor = fc",
        "begin_line": 1246,
        "end_line": 1258,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002598752598752599,
            "pseudo_dstar_susp": 0.0003307972213033411,
            "pseudo_tarantula_susp": 0.0002767783005812344,
            "pseudo_op2_susp": 0.0003307972213033411,
            "pseudo_barinel_susp": 0.0002767783005812344
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_markerfacecoloralt#1260",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_markerfacecoloralt(self, fc)",
        "snippet": "    def set_markerfacecoloralt(self, fc):\n        \"\"\"\n        Set the alternate marker face color.\n\n        Parameters\n        ----------\n        fc : color\n        \"\"\"\n        if fc is None:\n            fc = 'auto'\n        if np.any(self._markerfacecoloralt != fc):\n            self.stale = True\n        self._markerfacecoloralt = fc",
        "begin_line": 1260,
        "end_line": 1272,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000362844702467344,
            "pseudo_dstar_susp": 0.0005443658138268917,
            "pseudo_tarantula_susp": 0.0002767783005812344,
            "pseudo_op2_susp": 0.0005443658138268917,
            "pseudo_barinel_susp": 0.0002767783005812344
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_markersize#1274",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_markersize(self, sz)",
        "snippet": "    def set_markersize(self, sz):\n        \"\"\"\n        Set the marker size in points.\n\n        Parameters\n        ----------\n        sz : float\n             Marker size, in points.\n        \"\"\"\n        sz = float(sz)\n        if self._markersize != sz:\n            self.stale = True\n        self._markersize = sz",
        "begin_line": 1274,
        "end_line": 1286,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004106776180698152,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0002860411899313501,
            "pseudo_op2_susp": 0.0005906674542232723,
            "pseudo_barinel_susp": 0.0002860411899313501
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_xdata#1288",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_xdata(self, x)",
        "snippet": "    def set_xdata(self, x):\n        \"\"\"\n        Set the data array for x.\n\n        Parameters\n        ----------\n        x : 1D array\n        \"\"\"\n        self._xorig = x\n        self._invalidx = True\n        self.stale = True",
        "begin_line": 1288,
        "end_line": 1298,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004106776180698152,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0002860411899313501,
            "pseudo_op2_susp": 0.0005906674542232723,
            "pseudo_barinel_susp": 0.0002860411899313501
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_ydata#1300",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_ydata(self, y)",
        "snippet": "    def set_ydata(self, y):\n        \"\"\"\n        Set the data array for y.\n\n        Parameters\n        ----------\n        y : 1D array\n        \"\"\"\n        self._yorig = y\n        self._invalidy = True\n        self.stale = True",
        "begin_line": 1300,
        "end_line": 1310,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00042158516020236085,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0002860411899313501,
            "pseudo_op2_susp": 0.0005906674542232723,
            "pseudo_barinel_susp": 0.0002860411899313501
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.update_from#1333",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.update_from(self, other)",
        "snippet": "    def update_from(self, other):\n        \"\"\"Copy properties from *other* to self.\"\"\"\n        Artist.update_from(self, other)\n        self._linestyle = other._linestyle\n        self._linewidth = other._linewidth\n        self._color = other._color\n        self._markersize = other._markersize\n        self._markerfacecolor = other._markerfacecolor\n        self._markerfacecoloralt = other._markerfacecoloralt\n        self._markeredgecolor = other._markeredgecolor\n        self._markeredgewidth = other._markeredgewidth\n        self._dashSeq = other._dashSeq\n        self._us_dashSeq = other._us_dashSeq\n        self._dashOffset = other._dashOffset\n        self._us_dashOffset = other._us_dashOffset\n        self._dashcapstyle = other._dashcapstyle\n        self._dashjoinstyle = other._dashjoinstyle\n        self._solidcapstyle = other._solidcapstyle\n        self._solidjoinstyle = other._solidjoinstyle\n\n        self._linestyle = other._linestyle\n        self._marker = MarkerStyle(other._marker.get_marker(),\n                                   other._marker.get_fillstyle())\n        self._drawstyle = other._drawstyle",
        "begin_line": 1333,
        "end_line": 1356,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004885197850512946,
            "pseudo_dstar_susp": 0.0004154549231408392,
            "pseudo_tarantula_susp": 0.00031625553447185326,
            "pseudo_op2_susp": 0.0004154549231408392,
            "pseudo_barinel_susp": 0.00031625553447185326
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_dash_joinstyle#1358",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_dash_joinstyle(self, s)",
        "snippet": "    def set_dash_joinstyle(self, s):\n        \"\"\"\n        Set the join style for dashed lines.\n\n        Parameters\n        ----------\n        s : {'miter', 'round', 'bevel'}\n            For examples see :doc:`/gallery/lines_bars_and_markers/joinstyle`.\n        \"\"\"\n        s = s.lower()\n        cbook._check_in_list(self.validJoin, s=s)\n        if self._dashjoinstyle != s:\n            self.stale = True\n        self._dashjoinstyle = s",
        "begin_line": 1358,
        "end_line": 1371,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004106776180698152,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.00026917900403768504,
            "pseudo_op2_susp": 0.0005906674542232723,
            "pseudo_barinel_susp": 0.00026917900403768504
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_solid_joinstyle#1373",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_solid_joinstyle(self, s)",
        "snippet": "    def set_solid_joinstyle(self, s):\n        \"\"\"\n        Set the join style for solid lines.\n\n        Parameters\n        ----------\n        s : {'miter', 'round', 'bevel'}\n            For examples see :doc:`/gallery/lines_bars_and_markers/joinstyle`.\n        \"\"\"\n        s = s.lower()\n        cbook._check_in_list(self.validJoin, s=s)\n        if self._solidjoinstyle != s:\n            self.stale = True\n        self._solidjoinstyle = s",
        "begin_line": 1373,
        "end_line": 1386,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004106776180698152,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.00028121484814398203,
            "pseudo_op2_susp": 0.0005906674542232723,
            "pseudo_barinel_susp": 0.00028121484814398203
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_dash_capstyle#1404",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_dash_capstyle(self, s)",
        "snippet": "    def set_dash_capstyle(self, s):\n        \"\"\"\n        Set the cap style for dashed lines.\n\n        Parameters\n        ----------\n        s : {'butt', 'round', 'projecting'}\n            For examples see :doc:`/gallery/lines_bars_and_markers/joinstyle`.\n        \"\"\"\n        s = s.lower()\n        cbook._check_in_list(self.validCap, s=s)\n        if self._dashcapstyle != s:\n            self.stale = True\n        self._dashcapstyle = s",
        "begin_line": 1404,
        "end_line": 1417,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004106776180698152,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0002860411899313501,
            "pseudo_op2_susp": 0.0005906674542232723,
            "pseudo_barinel_susp": 0.0002860411899313501
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_solid_capstyle#1419",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_solid_capstyle(self, s)",
        "snippet": "    def set_solid_capstyle(self, s):\n        \"\"\"\n        Set the cap style for solid lines.\n\n        Parameters\n        ----------\n        s : {'butt', 'round', 'projecting'}\n            For examples see :doc:`/gallery/lines_bars_and_markers/joinstyle`.\n        \"\"\"\n        s = s.lower()\n        cbook._check_in_list(self.validCap, s=s)\n        if self._solidcapstyle != s:\n            self.stale = True\n        self._solidcapstyle = s",
        "begin_line": 1419,
        "end_line": 1432,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041999160016799666,
            "pseudo_dstar_susp": 0.0006053268765133172,
            "pseudo_tarantula_susp": 0.0002860411899313501,
            "pseudo_op2_susp": 0.0006053268765133172,
            "pseudo_barinel_susp": 0.0002860411899313501
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_dash_capstyle#1434",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_dash_capstyle(self)",
        "snippet": "    def get_dash_capstyle(self):\n        \"\"\"\n        Return the cap style for dashed lines.\n\n        See also `~.Line2D.set_dash_capstyle`.\n        \"\"\"\n        return self._dashcapstyle",
        "begin_line": 1434,
        "end_line": 1440,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_solid_capstyle#1442",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_solid_capstyle(self)",
        "snippet": "    def get_solid_capstyle(self):\n        \"\"\"\n        Return the cap style for solid lines.\n\n        See also `~.Line2D.set_solid_capstyle`.\n        \"\"\"\n        return self._solidcapstyle",
        "begin_line": 1442,
        "end_line": 1448,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.is_dashed#1450",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.is_dashed(self)",
        "snippet": "    def is_dashed(self):\n        \"\"\"\n        Return whether line has a dashed linestyle.\n\n        See also `~.Line2D.set_linestyle`.\n        \"\"\"\n        return self._linestyle in ('--', '-.', ':')",
        "begin_line": 1450,
        "end_line": 1456,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00031665611146295124,
            "pseudo_dstar_susp": 0.00032102728731942215,
            "pseudo_tarantula_susp": 0.00028368794326241134,
            "pseudo_op2_susp": 0.00032102728731942215,
            "pseudo_barinel_susp": 0.00028368794326241134
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.ValidateInStrings.__init__#50",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup.ValidateInStrings",
        "signature": "lib.matplotlib.rcsetup.ValidateInStrings.__init__(self, key, valid, ignorecase=False)",
        "snippet": "    def __init__(self, key, valid, ignorecase=False):\n        'valid is a list of legal strings'\n        self.key = key\n        self.ignorecase = ignorecase\n\n        def func(s):\n            if ignorecase:\n                return s.lower()\n            else:\n                return s\n        self.valid = {func(k): k for k in valid}",
        "begin_line": 50,
        "end_line": 60,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0056179775280898875,
            "pseudo_dstar_susp": 0.019230769230769232,
            "pseudo_tarantula_susp": 0.000170590242238144,
            "pseudo_op2_susp": 0.019230769230769232,
            "pseudo_barinel_susp": 0.000170590242238144
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.ValidateInStrings.func#55",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup.ValidateInStrings",
        "signature": "lib.matplotlib.rcsetup.ValidateInStrings.func(s)",
        "snippet": "        def func(s):\n            if ignorecase:\n                return s.lower()\n            else:\n                return s",
        "begin_line": 55,
        "end_line": 59,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011403808872163302,
            "pseudo_dstar_susp": 0.00022311468094600624,
            "pseudo_tarantula_susp": 0.00011397310234784591,
            "pseudo_op2_susp": 0.00022311468094600624,
            "pseudo_barinel_susp": 0.00011397310234784591
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.ValidateInStrings.__call__#62",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup.ValidateInStrings",
        "signature": "lib.matplotlib.rcsetup.ValidateInStrings.__call__(self, s)",
        "snippet": "    def __call__(self, s):\n        if self.ignorecase:\n            s = s.lower()\n        if s in self.valid:\n            return self.valid[s]\n        raise ValueError('Unrecognized %s string %r: valid strings are %s'\n                         % (self.key, s, list(self.valid.values())))",
        "begin_line": 62,
        "end_line": 68,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006756756756756757,
            "pseudo_dstar_susp": 0.01639344262295082,
            "pseudo_tarantula_susp": 0.0002244668911335578,
            "pseudo_op2_susp": 0.01639344262295082,
            "pseudo_barinel_susp": 0.0002244668911335578
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.f#72",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.f(s)",
        "snippet": "    def f(s):\n        if isinstance(s, str):\n            try:\n                return [scalar_validator(v.strip()) for v in s.split(',')\n                        if v.strip()]\n            except Exception:\n                if allow_stringlist:\n                    # Sometimes, a list of colors might be a single string\n                    # of single-letter colornames. So give that a shot.\n                    return [scalar_validator(v.strip())\n                            for v in s if v.strip()]\n                else:\n                    raise\n        # We should allow any generic sequence type, including generators,\n        # Numpy ndarrays, and pandas data structures.  However, unordered\n        # sequences, such as sets, should be allowed but discouraged unless the\n        # user desires pseudorandom behavior.\n        elif isinstance(s, Iterable) and not isinstance(s, Mapping):\n            # The condition on this list comprehension will preserve the\n            # behavior of filtering out any empty strings (behavior was\n            # from the original validate_stringlist()), while allowing\n            # any non-string/text scalar values such as numbers and arrays.\n            return [scalar_validator(v) for v in s\n                    if not isinstance(v, str) or v]\n        else:\n            raise ValueError(\"{!r} must be of type: str or non-dictionary \"\n                             \"iterable\".format(s))",
        "begin_line": 72,
        "end_line": 98,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006169031462060457,
            "pseudo_dstar_susp": 0.0038461538461538464,
            "pseudo_tarantula_susp": 0.00011890606420927467,
            "pseudo_op2_susp": 0.004166666666666667,
            "pseudo_barinel_susp": 0.00011890606420927467
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_any#107",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_any(s)",
        "snippet": "def validate_any(s):\n    return s",
        "begin_line": 107,
        "end_line": 108,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006027727546714888,
            "pseudo_dstar_susp": 0.0008688097306689834,
            "pseudo_tarantula_susp": 0.00011983223487118035,
            "pseudo_op2_susp": 0.0008688097306689834,
            "pseudo_barinel_susp": 0.00011983223487118035
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_bool#123",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_bool(b)",
        "snippet": "def validate_bool(b):\n    \"\"\"Convert b to a boolean or raise\"\"\"\n    if isinstance(b, str):\n        b = b.lower()\n    if b in ('t', 'y', 'yes', 'on', 'true', '1', 1, True):\n        return True\n    elif b in ('f', 'n', 'no', 'off', 'false', '0', 0, False):\n        return False\n    else:\n        raise ValueError('Could not convert \"%s\" to boolean' % b)",
        "begin_line": 123,
        "end_line": 132,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00847457627118644,
            "pseudo_dstar_susp": 0.02702702702702703,
            "pseudo_tarantula_susp": 0.00022568269013766644,
            "pseudo_op2_susp": 0.030303030303030304,
            "pseudo_barinel_susp": 0.00022568269013766644
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_bool_maybe_none#135",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_bool_maybe_none(b)",
        "snippet": "def validate_bool_maybe_none(b):\n    \"\"\"Convert b to a boolean or raise.\"\"\"\n    if isinstance(b, str):\n        b = b.lower()\n    if b is None or b == 'none':\n        return None\n    if b in ('t', 'y', 'yes', 'on', 'true', '1', 1, True):\n        return True\n    elif b in ('f', 'n', 'no', 'off', 'false', '0', 0, False):\n        return False\n    else:\n        raise ValueError('Could not convert \"%s\" to boolean' % b)",
        "begin_line": 135,
        "end_line": 146,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.146639511201629e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.rcsetup._validate_tex_preamble#149",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup._validate_tex_preamble(s)",
        "snippet": "def _validate_tex_preamble(s):\n    if s is None or s == 'None':\n        return \"\"\n    try:\n        if isinstance(s, str):\n            return s\n        elif isinstance(s, Iterable):\n            return '\\n'.join(s)\n        else:\n            raise TypeError\n    except TypeError:\n        raise ValueError('Could not convert \"%s\" to string' % s)",
        "begin_line": 149,
        "end_line": 160,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00102880658436214,
            "pseudo_dstar_susp": 0.0055248618784530384,
            "pseudo_tarantula_susp": 0.0002063557573256294,
            "pseudo_op2_susp": 0.0055248618784530384,
            "pseudo_barinel_susp": 0.0002063557573256294
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_axisbelow#163",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_axisbelow(s)",
        "snippet": "def validate_axisbelow(s):\n    try:\n        return validate_bool(s)\n    except ValueError:\n        if isinstance(s, str):\n            s = s.lower()\n            if s.startswith('line'):\n                return 'line'\n    raise ValueError('%s cannot be interpreted as'\n                     ' True, False, or \"line\"' % s)",
        "begin_line": 163,
        "end_line": 172,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0007621951219512195,
            "pseudo_tarantula_susp": 0.00011848341232227489,
            "pseudo_op2_susp": 0.0007621951219512195,
            "pseudo_barinel_susp": 0.00011848341232227489
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_dpi#175",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_dpi(s)",
        "snippet": "def validate_dpi(s):\n    \"\"\"Confirm s is string 'figure' or convert s to float or raise.\"\"\"\n    if s == 'figure':\n        return s\n    try:\n        return float(s)\n    except ValueError:\n        raise ValueError('\"%s\" is not string \"figure\" or'\n            ' could not convert \"%s\" to float' % (s, s))",
        "begin_line": 175,
        "end_line": 183,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02631578947368421,
            "pseudo_dstar_susp": 0.16666666666666666,
            "pseudo_tarantula_susp": 0.0002575328354365182,
            "pseudo_op2_susp": 0.16666666666666666,
            "pseudo_barinel_susp": 0.0002575328354365182
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validator#192",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validator(s)",
        "snippet": "    def validator(s):\n        if (allow_none and\n                (s is None or isinstance(s, str) and s.lower() == \"none\")):\n            return None\n        try:\n            return cls(s)\n        except ValueError:\n            raise ValueError(f'Could not convert {s!r} to {cls.__name__}')",
        "begin_line": 192,
        "end_line": 199,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008123476848090983,
            "pseudo_dstar_susp": 0.0026666666666666666,
            "pseudo_tarantula_susp": 0.0002570694087403599,
            "pseudo_op2_susp": 0.002688172043010753,
            "pseudo_barinel_susp": 0.0002570694087403599
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_fonttype#216",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_fonttype(s)",
        "snippet": "def validate_fonttype(s):\n    \"\"\"\n    Confirm that this is a Postscript or PDF font type that we know how to\n    convert to.\n    \"\"\"\n    fonttypes = {'type3':    3,\n                 'truetype': 42}\n    try:\n        fonttype = validate_int(s)\n    except ValueError:\n        try:\n            return fonttypes[s.lower()]\n        except KeyError:\n            raise ValueError(\n                'Supported Postscript/PDF font types are %s' % list(fonttypes))\n    else:\n        if fonttype not in fonttypes.values():\n            raise ValueError(\n                'Supported Postscript/PDF font types are %s' %\n                list(fonttypes.values()))\n        return fonttype",
        "begin_line": 216,
        "end_line": 236,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009861932938856016,
            "pseudo_dstar_susp": 0.005555555555555556,
            "pseudo_tarantula_susp": 0.00020403999183840033,
            "pseudo_op2_susp": 0.005555555555555556,
            "pseudo_barinel_susp": 0.00020403999183840033
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_backend#244",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_backend(s)",
        "snippet": "def validate_backend(s):\n    backend = (\n        s if s is _auto_backend_sentinel or s.startswith(\"module://\")\n        else _validate_standard_backends(s))\n    return backend",
        "begin_line": 244,
        "end_line": 248,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008503401360544217,
            "pseudo_dstar_susp": 0.0045871559633027525,
            "pseudo_tarantula_susp": 0.00016983695652173913,
            "pseudo_op2_susp": 0.0045871559633027525,
            "pseudo_barinel_susp": 0.00016983695652173913
        }
    },
    {
        "name": "lib.matplotlib.rcsetup._make_nseq_validator#269",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup._make_nseq_validator(cls, n=None, allow_none=False)",
        "snippet": "def _make_nseq_validator(cls, n=None, allow_none=False):\n\n    def validator(s):\n        \"\"\"Convert *n* objects using ``cls``, or raise.\"\"\"\n        if isinstance(s, str):\n            s = [x.strip() for x in s.split(',')]\n            if n is not None and len(s) != n:\n                raise ValueError(\n                    f'Expected exactly {n} comma-separated values, '\n                    f'but got {len(s)} comma-separated values: {s}')\n        else:\n            if n is not None and len(s) != n:\n                raise ValueError(\n                    f'Expected exactly {n} values, '\n                    f'but got {len(s)} values: {s}')\n        try:\n            return [cls(val) if not allow_none or val is not None else val\n                    for val in s]\n        except ValueError:\n            raise ValueError(\n                f'Could not convert all entries to {cls.__name__}s')\n\n    return validator",
        "begin_line": 269,
        "end_line": 291,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007818608287724785,
            "pseudo_dstar_susp": 0.0016129032258064516,
            "pseudo_tarantula_susp": 0.00018573551263001485,
            "pseudo_op2_susp": 0.0016129032258064516,
            "pseudo_barinel_susp": 0.00018573551263001485
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validator#271",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validator(s)",
        "snippet": "    def validator(s):\n        \"\"\"Convert *n* objects using ``cls``, or raise.\"\"\"\n        if isinstance(s, str):\n            s = [x.strip() for x in s.split(',')]\n            if n is not None and len(s) != n:\n                raise ValueError(\n                    f'Expected exactly {n} comma-separated values, '\n                    f'but got {len(s)} comma-separated values: {s}')\n        else:\n            if n is not None and len(s) != n:\n                raise ValueError(\n                    f'Expected exactly {n} values, '\n                    f'but got {len(s)} values: {s}')\n        try:\n            return [cls(val) if not allow_none or val is not None else val\n                    for val in s]\n        except ValueError:\n            raise ValueError(\n                f'Could not convert all entries to {cls.__name__}s')",
        "begin_line": 271,
        "end_line": 289,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008123476848090983,
            "pseudo_dstar_susp": 0.0026666666666666666,
            "pseudo_tarantula_susp": 0.0002570694087403599,
            "pseudo_op2_susp": 0.002688172043010753,
            "pseudo_barinel_susp": 0.0002570694087403599
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_color_or_inherit#298",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_color_or_inherit(s)",
        "snippet": "def validate_color_or_inherit(s):\n    \"\"\"Return a valid color arg.\"\"\"\n    if s == 'inherit':\n        return s\n    return validate_color(s)",
        "begin_line": 298,
        "end_line": 302,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007874015748031496,
            "pseudo_dstar_susp": 0.0019723865877712033,
            "pseudo_tarantula_susp": 0.00018914318138831096,
            "pseudo_op2_susp": 0.001984126984126984,
            "pseudo_barinel_susp": 0.00018914318138831096
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_color_or_auto#305",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_color_or_auto(s)",
        "snippet": "def validate_color_or_auto(s):\n    if s == 'auto':\n        return s\n    return validate_color(s)",
        "begin_line": 305,
        "end_line": 308,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008136696501220504,
            "pseudo_dstar_susp": 0.002564102564102564,
            "pseudo_tarantula_susp": 0.00022999080036798528,
            "pseudo_op2_susp": 0.002564102564102564,
            "pseudo_barinel_susp": 0.00022999080036798528
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_color_for_prop_cycle#311",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_color_for_prop_cycle(s)",
        "snippet": "def validate_color_for_prop_cycle(s):\n    # Special-case the N-th color cycle syntax, this obviously can not\n    # go in the color cycle.\n    if isinstance(s, bytes):\n        match = re.match(b'^C[0-9]$', s)\n        if match is not None:\n            raise ValueError('Can not put cycle reference ({cn!r}) in '\n                             'prop_cycler'.format(cn=s))\n    elif isinstance(s, str):\n        match = re.match('^C[0-9]$', s)\n        if match is not None:\n            raise ValueError('Can not put cycle reference ({cn!r}) in '\n                             'prop_cycler'.format(cn=s))\n    return validate_color(s)",
        "begin_line": 311,
        "end_line": 324,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007987220447284345,
            "pseudo_dstar_susp": 0.0037313432835820895,
            "pseudo_tarantula_susp": 0.00018573551263001485,
            "pseudo_op2_susp": 0.0037313432835820895,
            "pseudo_barinel_susp": 0.00018573551263001485
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_color#327",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_color(s)",
        "snippet": "def validate_color(s):\n    \"\"\"Return a valid color arg.\"\"\"\n    try:\n        if s.lower() == 'none':\n            return 'none'\n    except AttributeError:\n        pass\n\n    if isinstance(s, str):\n        if len(s) == 6 or len(s) == 8:\n            stmp = '#' + s\n            if is_color_like(stmp):\n                return stmp\n\n    if is_color_like(s):\n        return s\n\n    # If it is still valid, it must be a tuple.\n    colorarg = s\n    msg = ''\n    if s.find(',') >= 0:\n        # get rid of grouping symbols\n        stmp = ''.join([c for c in s if c.isdigit() or c == '.' or c == ','])\n        vals = stmp.split(',')\n        if len(vals) not in [3, 4]:\n            msg = '\\nColor tuples must be of length 3 or 4'\n        else:\n            try:\n                colorarg = [float(val) for val in vals]\n            except ValueError:\n                msg = '\\nCould not convert all entries to floats'\n\n    if not msg and is_color_like(colorarg):\n        return colorarg\n\n    raise ValueError('%s does not look like a color arg%s' % (s, msg))",
        "begin_line": 327,
        "end_line": 362,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008103727714748784,
            "pseudo_dstar_susp": 0.0027397260273972603,
            "pseudo_tarantula_susp": 0.00018573551263001485,
            "pseudo_op2_susp": 0.0027624309392265192,
            "pseudo_barinel_susp": 0.00018573551263001485
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_aspect#371",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_aspect(s)",
        "snippet": "def validate_aspect(s):\n    if s in ('auto', 'equal'):\n        return s\n    try:\n        return float(s)\n    except ValueError:\n        raise ValueError('not a valid aspect specification')",
        "begin_line": 371,
        "end_line": 377,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000784313725490196,
            "pseudo_dstar_susp": 0.0016611295681063123,
            "pseudo_tarantula_susp": 0.00025316455696202533,
            "pseudo_op2_susp": 0.0016611295681063123,
            "pseudo_barinel_susp": 0.00025316455696202533
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_fontsize_None#380",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_fontsize_None(s)",
        "snippet": "def validate_fontsize_None(s):\n    if s is None or s == 'None':\n        return None\n    else:\n        return validate_fontsize(s)",
        "begin_line": 380,
        "end_line": 384,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007874015748031496,
            "pseudo_dstar_susp": 0.0016750418760469012,
            "pseudo_tarantula_susp": 0.00018573551263001485,
            "pseudo_op2_susp": 0.0016750418760469012,
            "pseudo_barinel_susp": 0.00018573551263001485
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_fontsize#387",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_fontsize(s)",
        "snippet": "def validate_fontsize(s):\n    fontsizes = ['xx-small', 'x-small', 'small', 'medium', 'large',\n                 'x-large', 'xx-large', 'smaller', 'larger']\n    if isinstance(s, str):\n        s = s.lower()\n    if s in fontsizes:\n        return s\n    try:\n        return float(s)\n    except ValueError:\n        raise ValueError(\"%s is not a valid font size. Valid font sizes \"\n                         \"are %s.\" % (s, \", \".join(fontsizes)))",
        "begin_line": 387,
        "end_line": 398,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000784313725490196,
            "pseudo_dstar_susp": 0.0016611295681063123,
            "pseudo_tarantula_susp": 0.0002563445270443476,
            "pseudo_op2_susp": 0.0016611295681063123,
            "pseudo_barinel_susp": 0.0002563445270443476
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_fontweight#404",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_fontweight(s)",
        "snippet": "def validate_fontweight(s):\n    weights = [\n        'ultralight', 'light', 'normal', 'regular', 'book', 'medium', 'roman',\n        'semibold', 'demibold', 'demi', 'bold', 'heavy', 'extra bold', 'black']\n    # Note: Historically, weights have been case-sensitive in Matplotlib\n    if s in weights:\n        return s\n    try:\n        return int(s)\n    except (ValueError, TypeError):\n        raise ValueError(f'{s} is not a valid font weight.')",
        "begin_line": 404,
        "end_line": 414,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00078064012490242,
            "pseudo_dstar_susp": 0.0016501650165016502,
            "pseudo_tarantula_susp": 0.00017238407171177384,
            "pseudo_op2_susp": 0.0016501650165016502,
            "pseudo_barinel_susp": 0.00017238407171177384
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_font_properties#417",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_font_properties(s)",
        "snippet": "def validate_font_properties(s):\n    parse_fontconfig_pattern(s)\n    return s",
        "begin_line": 417,
        "end_line": 419,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008149959250203749,
            "pseudo_dstar_susp": 0.002577319587628866,
            "pseudo_tarantula_susp": 0.00025113008538422905,
            "pseudo_op2_susp": 0.002577319587628866,
            "pseudo_barinel_susp": 0.00025113008538422905
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_mathtext_default#427",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_mathtext_default(s)",
        "snippet": "def validate_mathtext_default(s):\n    if s == \"circled\":\n        cbook.warn_deprecated(\n            \"3.1\", message=\"Support for setting the mathtext.default rcParam \"\n            \"to 'circled' is deprecated since %(since)s and will be removed \"\n            \"%(removal)s.\")\n    return ValidateInStrings(\n        'default',\n        \"rm cal it tt sf bf default bb frak circled scr regular\".split())(s)",
        "begin_line": 427,
        "end_line": 435,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008149959250203749,
            "pseudo_dstar_susp": 0.002577319587628866,
            "pseudo_tarantula_susp": 0.0002563445270443476,
            "pseudo_op2_susp": 0.002577319587628866,
            "pseudo_barinel_susp": 0.0002563445270443476
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_whiskers#454",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_whiskers(s)",
        "snippet": "def validate_whiskers(s):\n    if s == 'range':\n        cbook.warn_deprecated(\n            \"3.2\", message=\"Support for setting the boxplot.whiskers rcParam \"\n            \"to 'range' is deprecated since %(since)s and will be removed \"\n            \"%(removal)s; set it to 0, 100 instead.\")\n        return 'range'\n    else:\n        try:\n            v = validate_nseq_float(2)(s)\n            return v\n        except (TypeError, ValueError):\n            try:\n                v = float(s)\n                return v\n            except ValueError:\n                raise ValueError(\"Not a valid whisker value ['range', float, \"\n                                 \"(float, float)]\")",
        "begin_line": 454,
        "end_line": 471,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008285004142502071,
            "pseudo_dstar_susp": 0.003875968992248062,
            "pseudo_tarantula_susp": 0.00016897600540723216,
            "pseudo_op2_susp": 0.003861003861003861,
            "pseudo_barinel_susp": 0.00016897600540723216
        }
    },
    {
        "name": "lib.matplotlib.rcsetup._update_savefig_format#489",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup._update_savefig_format(value)",
        "snippet": "def _update_savefig_format(value):\n    # The old savefig.extension could also have a value of \"auto\", but\n    # the new savefig.format does not.  We need to fix this here.\n    value = validate_string(value)\n    if value == 'auto':\n        cbook.warn_deprecated(\n            \"3.2\", message=\"Support for setting the 'savefig.format' rcParam \"\n            \"to 'auto' is deprecated since %(since)s and will be removed \"\n            \"%(removal)s; set it to 'png' instead.\")\n        value = 'png'\n    return value",
        "begin_line": 489,
        "end_line": 499,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008019246190858059,
            "pseudo_dstar_susp": 0.0038910505836575876,
            "pseudo_tarantula_susp": 0.00025113008538422905,
            "pseudo_op2_susp": 0.003875968992248062,
            "pseudo_barinel_susp": 0.00025113008538422905
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_ps_distiller#510",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_ps_distiller(s)",
        "snippet": "def validate_ps_distiller(s):\n    if isinstance(s, str):\n        s = s.lower()\n    if s in ('none', None, 'false', False):\n        return None\n    elif s in ('ghostscript', 'xpdf'):\n        try:\n            mpl._get_executable_info(\"gs\")\n        except mpl.ExecutableNotFoundError:\n            _log.warning(\"Setting rcParams['ps.usedistiller'] requires \"\n                         \"ghostscript.\")\n            return None\n        if s == \"xpdf\":\n            try:\n                mpl._get_executable_info(\"pdftops\")\n            except mpl.ExecutableNotFoundError:\n                _log.warning(\"Setting rcParams['ps.usedistiller'] to 'xpdf' \"\n                             \"requires xpdf.\")\n                return None\n        return s\n    else:\n        raise ValueError('matplotlibrc ps.usedistiller must either be none, '\n                         'ghostscript or xpdf')",
        "begin_line": 510,
        "end_line": 532,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007598784194528875,
            "pseudo_dstar_susp": 0.0018726591760299626,
            "pseudo_tarantula_susp": 0.00016837851490149856,
            "pseudo_op2_susp": 0.0018726591760299626,
            "pseudo_barinel_susp": 0.00016837851490149856
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_hinting#607",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_hinting(s)",
        "snippet": "def validate_hinting(s):\n    if s in (True, False):\n        cbook.warn_deprecated(\n            \"3.2\", message=\"Support for setting the text.hinting rcParam to \"\n            \"True or False is deprecated since %(since)s and will be removed \"\n            \"%(removal)s; set it to its synonyms 'auto' or 'none' instead.\")\n        return s\n    if s.lower() in ('auto', 'native', 'either', 'none'):\n        return s.lower()\n    raise ValueError(\"hinting should be 'auto', 'native', 'either' or 'none'\")",
        "begin_line": 607,
        "end_line": 616,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011363636363636363,
            "pseudo_dstar_susp": 0.005847953216374269,
            "pseudo_tarantula_susp": 0.00025131942699170643,
            "pseudo_op2_susp": 0.005847953216374269,
            "pseudo_barinel_susp": 0.00025131942699170643
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_bbox#637",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_bbox(s)",
        "snippet": "def validate_bbox(s):\n    if isinstance(s, str):\n        s = s.lower()\n        if s == 'tight':\n            return s\n        if s == 'standard':\n            return None\n        raise ValueError(\"bbox should be 'tight' or 'standard'\")\n    elif s is not None:\n        # Backwards compatibility. None is equivalent to 'standard'.\n        raise ValueError(\"bbox should be 'tight' or 'standard'\")\n    return s",
        "begin_line": 637,
        "end_line": 648,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007898894154818325,
            "pseudo_dstar_susp": 0.0018214936247723133,
            "pseudo_tarantula_susp": 0.00017277125086385625,
            "pseudo_op2_susp": 0.0018214936247723133,
            "pseudo_barinel_susp": 0.00017277125086385625
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_sketch#651",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_sketch(s)",
        "snippet": "def validate_sketch(s):\n    if isinstance(s, str):\n        s = s.lower()\n    if s == 'none' or s is None:\n        return None\n    if isinstance(s, str):\n        result = tuple([float(v.strip()) for v in s.split(',')])\n    elif isinstance(s, (list, tuple)):\n        result = tuple([float(v) for v in s])\n    if len(result) != 3:\n        raise ValueError(\"path.sketch must be a tuple (scale, length, randomness)\")\n    return result",
        "begin_line": 651,
        "end_line": 662,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002955082742316785,
            "pseudo_dstar_susp": 0.00028074115665356543,
            "pseudo_tarantula_susp": 0.0002577984016499098,
            "pseudo_op2_susp": 0.00028074115665356543,
            "pseudo_barinel_susp": 0.0002577984016499098
        }
    },
    {
        "name": "lib.matplotlib.rcsetup._validate_greaterequal0_lessthan1#698",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup._validate_greaterequal0_lessthan1(s)",
        "snippet": "def _validate_greaterequal0_lessthan1(s):\n    s = validate_float(s)\n    if 0 <= s < 1:\n        return s\n    else:\n        raise RuntimeError(f'Value must be >=0 and <1; got {s}')",
        "begin_line": 698,
        "end_line": 703,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000784313725490196,
            "pseudo_dstar_susp": 0.0019305019305019305,
            "pseudo_tarantula_susp": 0.0001725327812284334,
            "pseudo_op2_susp": 0.0019342359767891683,
            "pseudo_barinel_susp": 0.0001725327812284334
        }
    },
    {
        "name": "lib.matplotlib.rcsetup._validate_greaterequal0_lessequal1#706",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup._validate_greaterequal0_lessequal1(s)",
        "snippet": "def _validate_greaterequal0_lessequal1(s):\n    s = validate_float(s)\n    if 0 <= s <= 1:\n        return s\n    else:\n        raise RuntimeError(f'Value must be >=0 and <=1; got {s}')",
        "begin_line": 706,
        "end_line": 711,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007905138339920949,
            "pseudo_dstar_susp": 0.0022522522522522522,
            "pseudo_tarantula_susp": 0.00018573551263001485,
            "pseudo_op2_susp": 0.0022935779816513763,
            "pseudo_barinel_susp": 0.00018573551263001485
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_hatch#723",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_hatch(s)",
        "snippet": "def validate_hatch(s):\n    r\"\"\"\n    Validate a hatch pattern.\n    A hatch pattern string can have any sequence of the following\n    characters: ``\\ / | - + * . x o O``.\n    \"\"\"\n    if not isinstance(s, str):\n        raise ValueError(\"Hatch pattern must be a string\")\n    cbook._check_isinstance(str, hatch_pattern=s)\n    unknown = set(s) - {'\\\\', '/', '|', '-', '+', '*', '.', 'x', 'o', 'O'}\n    if unknown:\n        raise ValueError(\"Unknown hatch symbol(s): %s\" % list(unknown))\n    return s",
        "begin_line": 723,
        "end_line": 735,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.cycler#775",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.cycler(*args, **kwargs)",
        "snippet": "def cycler(*args, **kwargs):\n    \"\"\"\n    Creates a `~cycler.Cycler` object much like :func:`cycler.cycler`,\n    but includes input validation.\n\n    Call signatures::\n\n      cycler(cycler)\n      cycler(label=values[, label2=values2[, ...]])\n      cycler(label, values)\n\n    Form 1 copies a given `~cycler.Cycler` object.\n\n    Form 2 creates a `~cycler.Cycler` which cycles over one or more\n    properties simultaneously. If multiple properties are given, their\n    value lists must have the same length.\n\n    Form 3 creates a `~cycler.Cycler` for a single property. This form\n    exists for compatibility with the original cycler. Its use is\n    discouraged in favor of the kwarg form, i.e. ``cycler(label=values)``.\n\n    Parameters\n    ----------\n    cycler : Cycler\n        Copy constructor for Cycler.\n\n    label : str\n        The property key. Must be a valid `.Artist` property.\n        For example, 'color' or 'linestyle'. Aliases are allowed,\n        such as 'c' for 'color' and 'lw' for 'linewidth'.\n\n    values : iterable\n        Finite-length iterable of the property values. These values\n        are validated and will raise a ValueError if invalid.\n\n    Returns\n    -------\n    cycler : Cycler\n        A new :class:`~cycler.Cycler` for the given properties.\n\n    Examples\n    --------\n    Creating a cycler for a single property:\n\n    >>> c = cycler(color=['red', 'green', 'blue'])\n\n    Creating a cycler for simultaneously cycling over multiple properties\n    (e.g. red circle, green plus, blue cross):\n\n    >>> c = cycler(color=['red', 'green', 'blue'],\n    ...            marker=['o', '+', 'x'])\n\n    \"\"\"\n    if args and kwargs:\n        raise TypeError(\"cycler() can only accept positional OR keyword \"\n                        \"arguments -- not both.\")\n    elif not args and not kwargs:\n        raise TypeError(\"cycler() must have positional OR keyword arguments\")\n\n    if len(args) == 1:\n        if not isinstance(args[0], Cycler):\n            raise TypeError(\"If only one positional argument given, it must \"\n                            \" be a Cycler instance.\")\n        return validate_cycler(args[0])\n    elif len(args) == 2:\n        pairs = [(args[0], args[1])]\n    elif len(args) > 2:\n        raise TypeError(\"No more than 2 positional arguments allowed\")\n    else:\n        pairs = kwargs.items()\n\n    validated = []\n    for prop, vals in pairs:\n        norm_prop = _prop_aliases.get(prop, prop)\n        validator = _prop_validators.get(norm_prop, None)\n        if validator is None:\n            raise TypeError(\"Unknown artist property: %s\" % prop)\n        vals = validator(vals)\n        # We will normalize the property names as well to reduce\n        # the amount of alias handling code elsewhere.\n        validated.append((norm_prop, vals))\n\n    return reduce(operator.add, (ccycler(k, v) for k, v in validated))",
        "begin_line": 775,
        "end_line": 857,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001830831197363603,
            "pseudo_dstar_susp": 0.00017076502732240437,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00017076502732240437,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_cycler#860",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_cycler(s)",
        "snippet": "def validate_cycler(s):\n    \"\"\"Return a Cycler object from a string repr or the object itself.\"\"\"\n    if isinstance(s, str):\n        try:\n            # TODO: We might want to rethink this...\n            # While I think I have it quite locked down,\n            # it is execution of arbitrary code without\n            # sanitation.\n            # Combine this with the possibility that rcparams\n            # might come from the internet (future plans), this\n            # could be downright dangerous.\n            # I locked it down by only having the 'cycler()' function\n            # available.\n            # UPDATE: Partly plugging a security hole.\n            # I really should have read this:\n            # http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html\n            # We should replace this eval with a combo of PyParsing and\n            # ast.literal_eval()\n            if '.__' in s.replace(' ', ''):\n                raise ValueError(\"'%s' seems to have dunder methods. Raising\"\n                                 \" an exception for your safety\")\n            s = eval(s, {'cycler': cycler, '__builtins__': {}})\n        except BaseException as e:\n            raise ValueError(\"'%s' is not a valid cycler construction: %s\" %\n                             (s, e))\n    # Should make sure what comes from the above eval()\n    # is a Cycler object.\n    if isinstance(s, Cycler):\n        cycler_inst = s\n    else:\n        raise ValueError(\"object was not a string or Cycler instance: %s\" % s)\n\n    unknowns = cycler_inst.keys - (set(_prop_validators) | set(_prop_aliases))\n    if unknowns:\n        raise ValueError(\"Unknown artist properties: %s\" % unknowns)\n\n    # Not a full validation, but it'll at least normalize property names\n    # A fuller validation would require v0.10 of cycler.\n    checker = set()\n    for prop in cycler_inst.keys:\n        norm_prop = _prop_aliases.get(prop, prop)\n        if norm_prop != prop and norm_prop in cycler_inst.keys:\n            raise ValueError(\"Cannot specify both '{0}' and alias '{1}'\"\n                             \" in the same prop_cycle\".format(norm_prop, prop))\n        if norm_prop in checker:\n            raise ValueError(\"Another property was already aliased to '{0}'.\"\n                             \" Collision normalizing '{1}'.\".format(norm_prop,\n                                                                    prop))\n        checker.update([norm_prop])\n\n    # This is just an extra-careful check, just in case there is some\n    # edge-case I haven't thought of.\n    assert len(checker) == len(cycler_inst.keys)\n\n    # Now, it should be safe to mutate this cycler\n    for prop in cycler_inst.keys:\n        norm_prop = _prop_aliases.get(prop, prop)\n        cycler_inst.change_key(prop, norm_prop)\n\n    for key, vals in cycler_inst.by_key().items():\n        _prop_validators[key](vals)\n\n    return cycler_inst",
        "begin_line": 860,
        "end_line": 922,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008333333333333334,
            "pseudo_dstar_susp": 0.0044444444444444444,
            "pseudo_tarantula_susp": 0.0001721763085399449,
            "pseudo_op2_susp": 0.0044444444444444444,
            "pseudo_barinel_susp": 0.0001721763085399449
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_hist_bins#925",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_hist_bins(s)",
        "snippet": "def validate_hist_bins(s):\n    valid_strs = [\"auto\", \"sturges\", \"fd\", \"doane\", \"scott\", \"rice\", \"sqrt\"]\n    if isinstance(s, str) and s in valid_strs:\n        return s\n    try:\n        return int(s)\n    except (TypeError, ValueError):\n        pass\n    try:\n        return validate_floatlist(s)\n    except ValueError:\n        pass\n    raise ValueError(\"'hist.bins' must be one of {}, an int or\"\n                     \" a sequence of floats\".format(valid_strs))",
        "begin_line": 925,
        "end_line": 938,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008084074373484236,
            "pseudo_dstar_susp": 0.004032258064516129,
            "pseudo_tarantula_susp": 0.0002563445270443476,
            "pseudo_op2_susp": 0.004016064257028112,
            "pseudo_barinel_susp": 0.0002563445270443476
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_webagg_address#957",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_webagg_address(s)",
        "snippet": "def validate_webagg_address(s):\n    if s is not None:\n        import socket\n        try:\n            socket.inet_aton(s)\n        except socket.error:\n            raise ValueError(\"'webagg.address' is not a valid IP address\")\n        return s\n    raise ValueError(\"'webagg.address' is not a valid IP address\")",
        "begin_line": 957,
        "end_line": 965,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.rcsetup._validate_linestyle#976",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup._validate_linestyle(ls)",
        "snippet": "def _validate_linestyle(ls):\n    \"\"\"\n    A validator for all possible line styles, the named ones *and*\n    the on-off ink sequences.\n    \"\"\"\n    # Look first for a valid named line style, like '--' or 'solid' Also\n    # includes bytes(-arrays) here (they all fail _validate_named_linestyle);\n    # otherwise, if *ls* is of even-length, it will be passed to the instance\n    # of validate_nseq_float, which will return an absurd on-off ink\n    # sequence...\n    if isinstance(ls, (str, bytes, bytearray)):\n        return _validate_named_linestyle(ls)\n\n    # Look for an on-off ink sequence (in points) *of even length*.\n    # Offset is set to None.\n    try:\n        if len(ls) % 2 != 0:\n            raise ValueError(\"the linestyle sequence {!r} is not of even \"\n                             \"length.\".format(ls))\n\n        return (None, validate_nseq_float()(ls))\n\n    except (ValueError, TypeError):\n        # TypeError can be raised inside the instance of validate_nseq_float,\n        # by wrong types passed to float(), like NoneType.\n        raise ValueError(\"linestyle {!r} is not a valid on-off ink \"\n                         \"sequence.\".format(ls))",
        "begin_line": 976,
        "end_line": 1002,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008169934640522876,
            "pseudo_dstar_susp": 0.002702702702702703,
            "pseudo_tarantula_susp": 0.0002577984016499098,
            "pseudo_op2_susp": 0.00273224043715847,
            "pseudo_barinel_susp": 0.0002577984016499098
        }
    },
    {
        "name": "lib.matplotlib.tri.tripcolor.tripcolor#9",
        "src_path": "lib/matplotlib/tri/tripcolor.py",
        "class_name": "lib.matplotlib.tri.tripcolor",
        "signature": "lib.matplotlib.tri.tripcolor.tripcolor(ax, *args, alpha=1.0, norm=None, cmap=None, vmin=None, vmax=None, shading='flat', facecolors=None, **kwargs)",
        "snippet": "def tripcolor(ax, *args, alpha=1.0, norm=None, cmap=None, vmin=None,\n              vmax=None, shading='flat', facecolors=None, **kwargs):\n    \"\"\"\n    Create a pseudocolor plot of an unstructured triangular grid.\n\n    The triangulation can be specified in one of two ways; either::\n\n      tripcolor(triangulation, ...)\n\n    where triangulation is a :class:`matplotlib.tri.Triangulation`\n    object, or\n\n    ::\n\n      tripcolor(x, y, ...)\n      tripcolor(x, y, triangles, ...)\n      tripcolor(x, y, triangles=triangles, ...)\n      tripcolor(x, y, mask=mask, ...)\n      tripcolor(x, y, triangles, mask=mask, ...)\n\n    in which case a Triangulation object will be created.  See\n    :class:`~matplotlib.tri.Triangulation` for a explanation of these\n    possibilities.\n\n    The next argument must be *C*, the array of color values, either\n    one per point in the triangulation if color values are defined at\n    points, or one per triangle in the triangulation if color values\n    are defined at triangles. If there are the same number of points\n    and triangles in the triangulation it is assumed that color\n    values are defined at points; to force the use of color values at\n    triangles use the kwarg ``facecolors=C`` instead of just ``C``.\n\n    *shading* may be 'flat' (the default) or 'gouraud'. If *shading*\n    is 'flat' and C values are defined at points, the color values\n    used for each triangle are from the mean C of the triangle's\n    three points. If *shading* is 'gouraud' then color values must be\n    defined at points.\n\n    The remaining kwargs are the same as for\n    :meth:`~matplotlib.axes.Axes.pcolor`.\n    \"\"\"\n    cbook._check_in_list(['flat', 'gouraud'], shading=shading)\n\n    tri, args, kwargs = Triangulation.get_from_args_and_kwargs(*args, **kwargs)\n\n    # C is the colors array defined at either points or faces (i.e. triangles).\n    # If facecolors is None, C are defined at points.\n    # If facecolors is not None, C are defined at faces.\n    if facecolors is not None:\n        C = facecolors\n    else:\n        C = np.asarray(args[0])\n\n    # If there are a different number of points and triangles in the\n    # triangulation, can omit facecolors kwarg as it is obvious from\n    # length of C whether it refers to points or faces.\n    # Do not do this for gouraud shading.\n    if (facecolors is None and len(C) == len(tri.triangles) and\n            len(C) != len(tri.x) and shading != 'gouraud'):\n        facecolors = C\n\n    # Check length of C is OK.\n    if ((facecolors is None and len(C) != len(tri.x)) or\n            (facecolors is not None and len(C) != len(tri.triangles))):\n        raise ValueError('Length of color values array must be the same '\n                         'as either the number of triangulation points '\n                         'or triangles')\n\n    # Handling of linewidths, shading, edgecolors and antialiased as\n    # in Axes.pcolor\n    linewidths = (0.25,)\n    if 'linewidth' in kwargs:\n        kwargs['linewidths'] = kwargs.pop('linewidth')\n    kwargs.setdefault('linewidths', linewidths)\n\n    edgecolors = 'none'\n    if 'edgecolor' in kwargs:\n        kwargs['edgecolors'] = kwargs.pop('edgecolor')\n    ec = kwargs.setdefault('edgecolors', edgecolors)\n\n    if 'antialiased' in kwargs:\n        kwargs['antialiaseds'] = kwargs.pop('antialiased')\n    if 'antialiaseds' not in kwargs and ec.lower() == \"none\":\n        kwargs['antialiaseds'] = False\n\n    if shading == 'gouraud':\n        if facecolors is not None:\n            raise ValueError('Gouraud shading does not support the use '\n                             'of facecolors kwarg')\n        if len(C) != len(tri.x):\n            raise ValueError('For gouraud shading, the length of color '\n                             'values array must be the same as the '\n                             'number of triangulation points')\n        collection = TriMesh(tri, **kwargs)\n    else:\n        # Vertices of triangles.\n        maskedTris = tri.get_masked_triangles()\n        verts = np.stack((tri.x[maskedTris], tri.y[maskedTris]), axis=-1)\n\n        # Color values.\n        if facecolors is None:\n            # One color per triangle, the mean of the 3 vertex color values.\n            C = C[maskedTris].mean(axis=1)\n        elif tri.mask is not None:\n            # Remove color values of masked triangles.\n            C = C[~tri.mask]\n\n        collection = PolyCollection(verts, **kwargs)\n\n    collection.set_alpha(alpha)\n    collection.set_array(C)\n    cbook._check_isinstance((Normalize, None), norm=norm)\n    collection.set_cmap(cmap)\n    collection.set_norm(norm)\n    if vmin is not None or vmax is not None:\n        collection.set_clim(vmin, vmax)\n    else:\n        collection.autoscale_None()\n    ax.grid(False)\n\n    minx = tri.x.min()\n    maxx = tri.x.max()\n    miny = tri.y.min()\n    maxy = tri.y.max()\n    corners = (minx, miny), (maxx, maxy)\n    ax.update_datalim(corners)\n    ax.autoscale_view()\n    ax.add_collection(collection)\n    return collection",
        "begin_line": 9,
        "end_line": 137,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.sankey.Sankey.__init__#42",
        "src_path": "lib/matplotlib/sankey.py",
        "class_name": "lib.matplotlib.sankey.Sankey",
        "signature": "lib.matplotlib.sankey.Sankey.__init__(self, ax=None, scale=1.0, unit='', format='%G', gap=0.25, radius=0.1, shoulder=0.03, offset=0.15, head_angle=100, margin=0.4, tolerance=1e-06, **kwargs)",
        "snippet": "    def __init__(self, ax=None, scale=1.0, unit='', format='%G', gap=0.25,\n                 radius=0.1, shoulder=0.03, offset=0.15, head_angle=100,\n                 margin=0.4, tolerance=1e-6, **kwargs):\n        \"\"\"\n        Create a new Sankey instance.\n\n        Optional keyword arguments:\n\n          ===============   ===================================================\n          Field             Description\n          ===============   ===================================================\n          *ax*              axes onto which the data should be plotted\n                            If *ax* isn't provided, new axes will be created.\n          *scale*           scaling factor for the flows\n                            *scale* sizes the width of the paths in order to\n                            maintain proper layout.  The same scale is applied\n                            to all subdiagrams.  The value should be chosen\n                            such that the product of the scale and the sum of\n                            the inputs is approximately 1.0 (and the product of\n                            the scale and the sum of the outputs is\n                            approximately -1.0).\n          *unit*            string representing the physical unit associated\n                            with the flow quantities\n                            If *unit* is None, then none of the quantities are\n                            labeled.\n          *format*          a Python number formatting string to be used in\n                            labeling the flow as a quantity (i.e., a number\n                            times a unit, where the unit is given)\n          *gap*             space between paths that break in/break away\n                            to/from the top or bottom\n          *radius*          inner radius of the vertical paths\n          *shoulder*        size of the shoulders of output arrowS\n          *offset*          text offset (from the dip or tip of the arrow)\n          *head_angle*      angle of the arrow heads (and negative of the angle\n                            of the tails) [deg]\n          *margin*          minimum space between Sankey outlines and the edge\n                            of the plot area\n          *tolerance*       acceptable maximum of the magnitude of the sum of\n                            flows\n                            The magnitude of the sum of connected flows cannot\n                            be greater than *tolerance*.\n          ===============   ===================================================\n\n        The optional arguments listed above are applied to all subdiagrams so\n        that there is consistent alignment and formatting.\n\n        If :class:`Sankey` is instantiated with any keyword arguments other\n        than those explicitly listed above (``**kwargs``), they will be passed\n        to :meth:`add`, which will create the first subdiagram.\n\n        In order to draw a complex Sankey diagram, create an instance of\n        :class:`Sankey` by calling it without any kwargs::\n\n            sankey = Sankey()\n\n        Then add simple Sankey sub-diagrams::\n\n            sankey.add() # 1\n            sankey.add() # 2\n            #...\n            sankey.add() # n\n\n        Finally, create the full diagram::\n\n            sankey.finish()\n\n        Or, instead, simply daisy-chain those calls::\n\n            Sankey().add().add...  .add().finish()\n\n        See Also\n        --------\n        Sankey.add\n        Sankey.finish\n\n        Examples\n        --------\n        .. plot:: gallery/specialty_plots/sankey_basics.py\n        \"\"\"\n        # Check the arguments.\n        if gap < 0:\n            raise ValueError(\n                \"'gap' is negative, which is not allowed because it would \"\n                \"cause the paths to overlap\")\n        if radius > gap:\n            raise ValueError(\n                \"'radius' is greater than 'gap', which is not allowed because \"\n                \"it would cause the paths to overlap\")\n        if head_angle < 0:\n            raise ValueError(\n                \"'head_angle' is negative, which is not allowed because it \"\n                \"would cause inputs to look like outputs and vice versa\")\n        if tolerance < 0:\n            raise ValueError(\n                \"'tolerance' is negative, but it must be a magnitude\")\n\n        # Create axes if necessary.\n        if ax is None:\n            import matplotlib.pyplot as plt\n            fig = plt.figure()\n            ax = fig.add_subplot(1, 1, 1, xticks=[], yticks=[])\n\n        self.diagrams = []\n\n        # Store the inputs.\n        self.ax = ax\n        self.unit = unit\n        self.format = format\n        self.scale = scale\n        self.gap = gap\n        self.radius = radius\n        self.shoulder = shoulder\n        self.offset = offset\n        self.margin = margin\n        self.pitch = np.tan(np.pi * (1 - head_angle / 180.0) / 2.0)\n        self.tolerance = tolerance\n\n        # Initialize the vertices of tight box around the diagram(s).\n        self.extent = np.array((np.inf, -np.inf, np.inf, -np.inf))\n\n        # If there are any kwargs, create the first subdiagram.\n        if len(kwargs):\n            self.add(**kwargs)",
        "begin_line": 42,
        "end_line": 164,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.667764583513912e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.sankey.Sankey._add_input#221",
        "src_path": "lib/matplotlib/sankey.py",
        "class_name": "lib.matplotlib.sankey.Sankey",
        "signature": "lib.matplotlib.sankey.Sankey._add_input(self, path, angle, flow, length)",
        "snippet": "    def _add_input(self, path, angle, flow, length):\n        \"\"\"\n        Add an input to a path and return its tip and label locations.\n        \"\"\"\n        if angle is None:\n            return [0, 0], [0, 0]\n        else:\n            x, y = path[-1][1]  # Use the last point as a reference.\n            dipdepth = (flow / 2) * self.pitch\n            if angle == RIGHT:\n                x -= length\n                dip = [x + dipdepth, y + flow / 2.0]\n                path.extend([(Path.LINETO, [x, y]),\n                             (Path.LINETO, dip),\n                             (Path.LINETO, [x, y + flow]),\n                             (Path.LINETO, [x + self.gap, y + flow])])\n                label_location = [dip[0] - self.offset, dip[1]]\n            else:  # Vertical\n                x -= self.gap\n                if angle == UP:\n                    sign = 1\n                else:\n                    sign = -1\n\n                dip = [x - flow / 2, y - sign * (length - dipdepth)]\n                if angle == DOWN:\n                    quadrant = 2\n                else:\n                    quadrant = 1\n\n                # Inner arc isn't needed if inner radius is zero\n                if self.radius:\n                    path.extend(self._arc(quadrant=quadrant,\n                                          cw=angle == UP,\n                                          radius=self.radius,\n                                          center=(x + self.radius,\n                                                  y - sign * self.radius)))\n                else:\n                    path.append((Path.LINETO, [x, y]))\n                path.extend([(Path.LINETO, [x, y - sign * length]),\n                             (Path.LINETO, dip),\n                             (Path.LINETO, [x - flow, y - sign * length])])\n                path.extend(self._arc(quadrant=quadrant,\n                                      cw=angle == DOWN,\n                                      radius=flow + self.radius,\n                                      center=(x + self.radius,\n                                              y - sign * self.radius)))\n                path.append((Path.LINETO, [x - flow, y + sign * flow]))\n                label_location = [dip[0], dip[1] - sign * self.offset]\n\n            return dip, label_location",
        "begin_line": 221,
        "end_line": 271,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.sankey.Sankey._add_output#273",
        "src_path": "lib/matplotlib/sankey.py",
        "class_name": "lib.matplotlib.sankey.Sankey",
        "signature": "lib.matplotlib.sankey.Sankey._add_output(self, path, angle, flow, length)",
        "snippet": "    def _add_output(self, path, angle, flow, length):\n        \"\"\"\n        Append an output to a path and return its tip and label locations.\n\n        .. note:: *flow* is negative for an output.\n        \"\"\"\n        if angle is None:\n            return [0, 0], [0, 0]\n        else:\n            x, y = path[-1][1]  # Use the last point as a reference.\n            tipheight = (self.shoulder - flow / 2) * self.pitch\n            if angle == RIGHT:\n                x += length\n                tip = [x + tipheight, y + flow / 2.0]\n                path.extend([(Path.LINETO, [x, y]),\n                             (Path.LINETO, [x, y + self.shoulder]),\n                             (Path.LINETO, tip),\n                             (Path.LINETO, [x, y - self.shoulder + flow]),\n                             (Path.LINETO, [x, y + flow]),\n                             (Path.LINETO, [x - self.gap, y + flow])])\n                label_location = [tip[0] + self.offset, tip[1]]\n            else:  # Vertical\n                x += self.gap\n                if angle == UP:\n                    sign = 1\n                else:\n                    sign = -1\n\n                tip = [x - flow / 2.0, y + sign * (length + tipheight)]\n                if angle == UP:\n                    quadrant = 3\n                else:\n                    quadrant = 0\n                # Inner arc isn't needed if inner radius is zero\n                if self.radius:\n                    path.extend(self._arc(quadrant=quadrant,\n                                          cw=angle == UP,\n                                          radius=self.radius,\n                                          center=(x - self.radius,\n                                                  y + sign * self.radius)))\n                else:\n                    path.append((Path.LINETO, [x, y]))\n                path.extend([(Path.LINETO, [x, y + sign * length]),\n                             (Path.LINETO, [x - self.shoulder,\n                                            y + sign * length]),\n                             (Path.LINETO, tip),\n                             (Path.LINETO, [x + self.shoulder - flow,\n                                            y + sign * length]),\n                             (Path.LINETO, [x - flow, y + sign * length])])\n                path.extend(self._arc(quadrant=quadrant,\n                                      cw=angle == DOWN,\n                                      radius=self.radius - flow,\n                                      center=(x - self.radius,\n                                              y + sign * self.radius)))\n                path.append((Path.LINETO, [x - flow, y + sign * flow]))\n                label_location = [tip[0], tip[1] + sign * self.offset]\n            return tip, label_location",
        "begin_line": 273,
        "end_line": 329,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.sankey.Sankey._revert#331",
        "src_path": "lib/matplotlib/sankey.py",
        "class_name": "lib.matplotlib.sankey.Sankey",
        "signature": "lib.matplotlib.sankey.Sankey._revert(self, path, first_action=Path.LINETO)",
        "snippet": "    def _revert(self, path, first_action=Path.LINETO):\n        \"\"\"\n        A path is not simply reversible by path[::-1] since the code\n        specifies an action to take from the **previous** point.\n        \"\"\"\n        reverse_path = []\n        next_code = first_action\n        for code, position in path[::-1]:\n            reverse_path.append((next_code, position))\n            next_code = code\n        return reverse_path",
        "begin_line": 331,
        "end_line": 341,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.sankey.Sankey.add#350",
        "src_path": "lib/matplotlib/sankey.py",
        "class_name": "lib.matplotlib.sankey.Sankey",
        "signature": "lib.matplotlib.sankey.Sankey.add(self, patchlabel='', flows=None, orientations=None, labels='', trunklength=1.0, pathlengths=0.25, prior=None, connect=(0, 0), rotation=0, **kwargs)",
        "snippet": "    def add(self, patchlabel='', flows=None, orientations=None, labels='',\n            trunklength=1.0, pathlengths=0.25, prior=None, connect=(0, 0),\n            rotation=0, **kwargs):\n        \"\"\"\n        Add a simple Sankey diagram with flows at the same hierarchical level.\n\n        Parameters\n        ----------\n        patchlabel : str\n            Label to be placed at the center of the diagram.\n            Note that *label* (not *patchlabel*) can be passed as keyword\n            argument to create an entry in the legend.\n\n        flows : list of float\n            Array of flow values.  By convention, inputs are positive and\n            outputs are negative.\n\n            Flows are placed along the top of the diagram from the inside out\n            in order of their index within *flows*.  They are placed along the\n            sides of the diagram from the top down and along the bottom from\n            the outside in.\n\n            If the sum of the inputs and outputs is\n            nonzero, the discrepancy will appear as a cubic Bezier curve along\n            the top and bottom edges of the trunk.\n\n        orientations : list of {-1, 0, 1}\n            List of orientations of the flows (or a single orientation to be\n            used for all flows).  Valid values are 0 (inputs from\n            the left, outputs to the right), 1 (from and to the top) or -1\n            (from and to the bottom).\n\n        labels : list of (str or None)\n            List of labels for the flows (or a single label to be used for all\n            flows).  Each label may be *None* (no label), or a labeling string.\n            If an entry is a (possibly empty) string, then the quantity for the\n            corresponding flow will be shown below the string.  However, if\n            the *unit* of the main diagram is None, then quantities are never\n            shown, regardless of the value of this argument.\n\n        trunklength : float\n            Length between the bases of the input and output groups (in\n            data-space units).\n\n        pathlengths : list of float\n            List of lengths of the vertical arrows before break-in or after\n            break-away.  If a single value is given, then it will be applied to\n            the first (inside) paths on the top and bottom, and the length of\n            all other arrows will be justified accordingly.  The *pathlengths*\n            are not applied to the horizontal inputs and outputs.\n\n        prior : int\n            Index of the prior diagram to which this diagram should be\n            connected.\n\n        connect : (int, int)\n            A (prior, this) tuple indexing the flow of the prior diagram and\n            the flow of this diagram which should be connected.  If this is the\n            first diagram or *prior* is *None*, *connect* will be ignored.\n\n        rotation : float\n            Angle of rotation of the diagram in degrees.  The interpretation of\n            the *orientations* argument will be rotated accordingly (e.g., if\n            *rotation* == 90, an *orientations* entry of 1 means to/from the\n            left).  *rotation* is ignored if this diagram is connected to an\n            existing one (using *prior* and *connect*).\n\n        Returns\n        -------\n        Sankey\n            The current `.Sankey` instance.\n\n        Other Parameters\n        ----------------\n        **kwargs\n           Additional keyword arguments set `matplotlib.patches.PathPatch`\n           properties, listed below.  For example, one may want to use\n           ``fill=False`` or ``label=\"A legend entry\"``.\n\n        %(Patch)s\n\n        See Also\n        --------\n        Sankey.finish\n        \"\"\"\n        # Check and preprocess the arguments.\n        if flows is None:\n            flows = np.array([1.0, -1.0])\n        else:\n            flows = np.array(flows)\n        n = flows.shape[0]  # Number of flows\n        if rotation is None:\n            rotation = 0\n        else:\n            # In the code below, angles are expressed in deg/90.\n            rotation /= 90.0\n        if orientations is None:\n            orientations = 0\n        try:\n            orientations = np.broadcast_to(orientations, n)\n        except ValueError:\n            raise ValueError(\n                f\"The shapes of 'flows' {np.shape(flows)} and 'orientations' \"\n                f\"{np.shape(orientations)} are incompatible\"\n            ) from None\n        try:\n            labels = np.broadcast_to(labels, n)\n        except ValueError:\n            raise ValueError(\n                f\"The shapes of 'flows' {np.shape(flows)} and 'labels' \"\n                f\"{np.shape(labels)} are incompatible\"\n            ) from None\n        if trunklength < 0:\n            raise ValueError(\n                \"'trunklength' is negative, which is not allowed because it \"\n                \"would cause poor layout\")\n        if np.abs(np.sum(flows)) > self.tolerance:\n            _log.info(\"The sum of the flows is nonzero (%f; patchlabel=%r); \"\n                      \"is the system not at steady state?\",\n                      np.sum(flows), patchlabel)\n        scaled_flows = self.scale * flows\n        gain = sum(max(flow, 0) for flow in scaled_flows)\n        loss = sum(min(flow, 0) for flow in scaled_flows)\n        if prior is not None:\n            if prior < 0:\n                raise ValueError(\"The index of the prior diagram is negative\")\n            if min(connect) < 0:\n                raise ValueError(\n                    \"At least one of the connection indices is negative\")\n            if prior >= len(self.diagrams):\n                raise ValueError(\n                    f\"The index of the prior diagram is {prior}, but there \"\n                    f\"are only {len(self.diagrams)} other diagrams\")\n            if connect[0] >= len(self.diagrams[prior].flows):\n                raise ValueError(\n                    \"The connection index to the source diagram is {}, but \"\n                    \"that diagram has only {} flows\".format(\n                        connect[0], len(self.diagrams[prior].flows)))\n            if connect[1] >= n:\n                raise ValueError(\n                    f\"The connection index to this diagram is {connect[1]}, \"\n                    f\"but this diagram has only {n} flows\")\n            if self.diagrams[prior].angles[connect[0]] is None:\n                raise ValueError(\n                    f\"The connection cannot be made, which may occur if the \"\n                    f\"magnitude of flow {connect[0]} of diagram {prior} is \"\n                    f\"less than the specified tolerance\")\n            flow_error = (self.diagrams[prior].flows[connect[0]] +\n                          flows[connect[1]])\n            if abs(flow_error) >= self.tolerance:\n                raise ValueError(\n                    f\"The scaled sum of the connected flows is {flow_error}, \"\n                    f\"which is not within the tolerance ({self.tolerance})\")\n\n        # Determine if the flows are inputs.\n        are_inputs = [None] * n\n        for i, flow in enumerate(flows):\n            if flow >= self.tolerance:\n                are_inputs[i] = True\n            elif flow <= -self.tolerance:\n                are_inputs[i] = False\n            else:\n                _log.info(\n                    \"The magnitude of flow %d (%f) is below the tolerance \"\n                    \"(%f).\\nIt will not be shown, and it cannot be used in a \"\n                    \"connection.\", i, flow, self.tolerance)\n\n        # Determine the angles of the arrows (before rotation).\n        angles = [None] * n\n        for i, (orient, is_input) in enumerate(zip(orientations, are_inputs)):\n            if orient == 1:\n                if is_input:\n                    angles[i] = DOWN\n                elif not is_input:\n                    # Be specific since is_input can be None.\n                    angles[i] = UP\n            elif orient == 0:\n                if is_input is not None:\n                    angles[i] = RIGHT\n            else:\n                if orient != -1:\n                    raise ValueError(\n                        f\"The value of orientations[{i}] is {orient}, \"\n                        f\"but it must be -1, 0, or 1\")\n                if is_input:\n                    angles[i] = UP\n                elif not is_input:\n                    angles[i] = DOWN\n\n        # Justify the lengths of the paths.\n        if np.iterable(pathlengths):\n            if len(pathlengths) != n:\n                raise ValueError(\n                    f\"The lengths of 'flows' ({n}) and 'pathlengths' \"\n                    f\"({len(pathlengths)}) are incompatible\")\n        else:  # Make pathlengths into a list.\n            urlength = pathlengths\n            ullength = pathlengths\n            lrlength = pathlengths\n            lllength = pathlengths\n            d = dict(RIGHT=pathlengths)\n            pathlengths = [d.get(angle, 0) for angle in angles]\n            # Determine the lengths of the top-side arrows\n            # from the middle outwards.\n            for i, (angle, is_input, flow) in enumerate(zip(angles, are_inputs,\n                                                            scaled_flows)):\n                if angle == DOWN and is_input:\n                    pathlengths[i] = ullength\n                    ullength += flow\n                elif angle == UP and not is_input:\n                    pathlengths[i] = urlength\n                    urlength -= flow  # Flow is negative for outputs.\n            # Determine the lengths of the bottom-side arrows\n            # from the middle outwards.\n            for i, (angle, is_input, flow) in enumerate(reversed(list(zip(\n                  angles, are_inputs, scaled_flows)))):\n                if angle == UP and is_input:\n                    pathlengths[n - i - 1] = lllength\n                    lllength += flow\n                elif angle == DOWN and not is_input:\n                    pathlengths[n - i - 1] = lrlength\n                    lrlength -= flow\n            # Determine the lengths of the left-side arrows\n            # from the bottom upwards.\n            has_left_input = False\n            for i, (angle, is_input, spec) in enumerate(reversed(list(zip(\n                  angles, are_inputs, zip(scaled_flows, pathlengths))))):\n                if angle == RIGHT:\n                    if is_input:\n                        if has_left_input:\n                            pathlengths[n - i - 1] = 0\n                        else:\n                            has_left_input = True\n            # Determine the lengths of the right-side arrows\n            # from the top downwards.\n            has_right_output = False\n            for i, (angle, is_input, spec) in enumerate(zip(\n                  angles, are_inputs, list(zip(scaled_flows, pathlengths)))):\n                if angle == RIGHT:\n                    if not is_input:\n                        if has_right_output:\n                            pathlengths[i] = 0\n                        else:\n                            has_right_output = True\n\n        # Begin the subpaths, and smooth the transition if the sum of the flows\n        # is nonzero.\n        urpath = [(Path.MOVETO, [(self.gap - trunklength / 2.0),  # Upper right\n                                 gain / 2.0]),\n                  (Path.LINETO, [(self.gap - trunklength / 2.0) / 2.0,\n                                 gain / 2.0]),\n                  (Path.CURVE4, [(self.gap - trunklength / 2.0) / 8.0,\n                                 gain / 2.0]),\n                  (Path.CURVE4, [(trunklength / 2.0 - self.gap) / 8.0,\n                                 -loss / 2.0]),\n                  (Path.LINETO, [(trunklength / 2.0 - self.gap) / 2.0,\n                                 -loss / 2.0]),\n                  (Path.LINETO, [(trunklength / 2.0 - self.gap),\n                                 -loss / 2.0])]\n        llpath = [(Path.LINETO, [(trunklength / 2.0 - self.gap),  # Lower left\n                                 loss / 2.0]),\n                  (Path.LINETO, [(trunklength / 2.0 - self.gap) / 2.0,\n                                 loss / 2.0]),\n                  (Path.CURVE4, [(trunklength / 2.0 - self.gap) / 8.0,\n                                 loss / 2.0]),\n                  (Path.CURVE4, [(self.gap - trunklength / 2.0) / 8.0,\n                                 -gain / 2.0]),\n                  (Path.LINETO, [(self.gap - trunklength / 2.0) / 2.0,\n                                 -gain / 2.0]),\n                  (Path.LINETO, [(self.gap - trunklength / 2.0),\n                                 -gain / 2.0])]\n        lrpath = [(Path.LINETO, [(trunklength / 2.0 - self.gap),  # Lower right\n                                 loss / 2.0])]\n        ulpath = [(Path.LINETO, [self.gap - trunklength / 2.0,  # Upper left\n                                 gain / 2.0])]\n\n        # Add the subpaths and assign the locations of the tips and labels.\n        tips = np.zeros((n, 2))\n        label_locations = np.zeros((n, 2))\n        # Add the top-side inputs and outputs from the middle outwards.\n        for i, (angle, is_input, spec) in enumerate(zip(\n              angles, are_inputs, list(zip(scaled_flows, pathlengths)))):\n            if angle == DOWN and is_input:\n                tips[i, :], label_locations[i, :] = self._add_input(\n                    ulpath, angle, *spec)\n            elif angle == UP and not is_input:\n                tips[i, :], label_locations[i, :] = self._add_output(\n                    urpath, angle, *spec)\n        # Add the bottom-side inputs and outputs from the middle outwards.\n        for i, (angle, is_input, spec) in enumerate(reversed(list(zip(\n              angles, are_inputs, list(zip(scaled_flows, pathlengths)))))):\n            if angle == UP and is_input:\n                tip, label_location = self._add_input(llpath, angle, *spec)\n                tips[n - i - 1, :] = tip\n                label_locations[n - i - 1, :] = label_location\n            elif angle == DOWN and not is_input:\n                tip, label_location = self._add_output(lrpath, angle, *spec)\n                tips[n - i - 1, :] = tip\n                label_locations[n - i - 1, :] = label_location\n        # Add the left-side inputs from the bottom upwards.\n        has_left_input = False\n        for i, (angle, is_input, spec) in enumerate(reversed(list(zip(\n              angles, are_inputs, list(zip(scaled_flows, pathlengths)))))):\n            if angle == RIGHT and is_input:\n                if not has_left_input:\n                    # Make sure the lower path extends\n                    # at least as far as the upper one.\n                    if llpath[-1][1][0] > ulpath[-1][1][0]:\n                        llpath.append((Path.LINETO, [ulpath[-1][1][0],\n                                                     llpath[-1][1][1]]))\n                    has_left_input = True\n                tip, label_location = self._add_input(llpath, angle, *spec)\n                tips[n - i - 1, :] = tip\n                label_locations[n - i - 1, :] = label_location\n        # Add the right-side outputs from the top downwards.\n        has_right_output = False\n        for i, (angle, is_input, spec) in enumerate(zip(\n              angles, are_inputs, list(zip(scaled_flows, pathlengths)))):\n            if angle == RIGHT and not is_input:\n                if not has_right_output:\n                    # Make sure the upper path extends\n                    # at least as far as the lower one.\n                    if urpath[-1][1][0] < lrpath[-1][1][0]:\n                        urpath.append((Path.LINETO, [lrpath[-1][1][0],\n                                                     urpath[-1][1][1]]))\n                    has_right_output = True\n                tips[i, :], label_locations[i, :] = self._add_output(\n                    urpath, angle, *spec)\n        # Trim any hanging vertices.\n        if not has_left_input:\n            ulpath.pop()\n            llpath.pop()\n        if not has_right_output:\n            lrpath.pop()\n            urpath.pop()\n\n        # Concatenate the subpaths in the correct order (clockwise from top).\n        path = (urpath + self._revert(lrpath) + llpath + self._revert(ulpath) +\n                [(Path.CLOSEPOLY, urpath[0][1])])\n\n        # Create a patch with the Sankey outline.\n        codes, vertices = zip(*path)\n        vertices = np.array(vertices)\n\n        def _get_angle(a, r):\n            if a is None:\n                return None\n            else:\n                return a + r\n\n        if prior is None:\n            if rotation != 0:  # By default, none of this is needed.\n                angles = [_get_angle(angle, rotation) for angle in angles]\n                rotate = Affine2D().rotate_deg(rotation * 90).transform_affine\n                tips = rotate(tips)\n                label_locations = rotate(label_locations)\n                vertices = rotate(vertices)\n            text = self.ax.text(0, 0, s=patchlabel, ha='center', va='center')\n        else:\n            rotation = (self.diagrams[prior].angles[connect[0]] -\n                        angles[connect[1]])\n            angles = [_get_angle(angle, rotation) for angle in angles]\n            rotate = Affine2D().rotate_deg(rotation * 90).transform_affine\n            tips = rotate(tips)\n            offset = self.diagrams[prior].tips[connect[0]] - tips[connect[1]]\n            translate = Affine2D().translate(*offset).transform_affine\n            tips = translate(tips)\n            label_locations = translate(rotate(label_locations))\n            vertices = translate(rotate(vertices))\n            kwds = dict(s=patchlabel, ha='center', va='center')\n            text = self.ax.text(*offset, **kwds)\n        if rcParams['_internal.classic_mode']:\n            fc = kwargs.pop('fc', kwargs.pop('facecolor', '#bfd1d4'))\n            lw = kwargs.pop('lw', kwargs.pop('linewidth', 0.5))\n        else:\n            fc = kwargs.pop('fc', kwargs.pop('facecolor', None))\n            lw = kwargs.pop('lw', kwargs.pop('linewidth', None))\n        if fc is None:\n            fc = next(self.ax._get_patches_for_fill.prop_cycler)['color']\n        patch = PathPatch(Path(vertices, codes), fc=fc, lw=lw, **kwargs)\n        self.ax.add_patch(patch)\n\n        # Add the path labels.\n        texts = []\n        for number, angle, label, location in zip(flows, angles, labels,\n                                                  label_locations):\n            if label is None or angle is None:\n                label = ''\n            elif self.unit is not None:\n                quantity = self.format % abs(number) + self.unit\n                if label != '':\n                    label += \"\\n\"\n                label += quantity\n            texts.append(self.ax.text(x=location[0], y=location[1],\n                                      s=label,\n                                      ha='center', va='center'))\n        # Text objects are placed even they are empty (as long as the magnitude\n        # of the corresponding flow is larger than the tolerance) in case the\n        # user wants to provide labels later.\n\n        # Expand the size of the diagram if necessary.\n        self.extent = (min(np.min(vertices[:, 0]),\n                           np.min(label_locations[:, 0]),\n                           self.extent[0]),\n                       max(np.max(vertices[:, 0]),\n                           np.max(label_locations[:, 0]),\n                           self.extent[1]),\n                       min(np.min(vertices[:, 1]),\n                           np.min(label_locations[:, 1]),\n                           self.extent[2]),\n                       max(np.max(vertices[:, 1]),\n                           np.max(label_locations[:, 1]),\n                           self.extent[3]))\n        # Include both vertices _and_ label locations in the extents; there are\n        # where either could determine the margins (e.g., arrow shoulders).\n\n        # Add this diagram as a subdiagram.\n        self.diagrams.append(\n            SimpleNamespace(patch=patch, flows=flows, angles=angles, tips=tips,\n                            text=text, texts=texts))\n\n        # Allow a daisy-chained call structure (see docstring for the class).\n        return self",
        "begin_line": 350,
        "end_line": 772,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.sankey.Sankey._get_angle#694",
        "src_path": "lib/matplotlib/sankey.py",
        "class_name": "lib.matplotlib.sankey.Sankey",
        "signature": "lib.matplotlib.sankey.Sankey._get_angle(a, r)",
        "snippet": "        def _get_angle(a, r):\n            if a is None:\n                return None\n            else:\n                return a + r",
        "begin_line": 694,
        "end_line": 698,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.testing.jpl_units.Duration.Duration.__init__#13",
        "src_path": "lib/matplotlib/testing/jpl_units/Duration.py",
        "class_name": "lib.matplotlib.testing.jpl_units.Duration.Duration",
        "signature": "lib.matplotlib.testing.jpl_units.Duration.Duration.__init__(self, frame, seconds)",
        "snippet": "    def __init__(self, frame, seconds):\n        \"\"\"Create a new Duration object.\n\n        = ERROR CONDITIONS\n        - If the input frame is not in the allowed list, an error is thrown.\n\n        = INPUT VARIABLES\n        - frame     The frame of the duration.  Must be 'ET' or 'UTC'\n        - seconds  The number of seconds in the Duration.\n        \"\"\"\n        cbook._check_in_list(self.allowed, frame=frame)\n        self._frame = frame\n        self._seconds = seconds",
        "begin_line": 13,
        "end_line": 25,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019527436047646945,
            "pseudo_dstar_susp": 0.00017214666896195557,
            "pseudo_tarantula_susp": 0.00032393909944930353,
            "pseudo_op2_susp": 0.00017214666896195557,
            "pseudo_barinel_susp": 0.00032393909944930353
        }
    },
    {
        "name": "lib.matplotlib.tri.triplot.triplot#5",
        "src_path": "lib/matplotlib/tri/triplot.py",
        "class_name": "lib.matplotlib.tri.triplot",
        "signature": "lib.matplotlib.tri.triplot.triplot(ax, *args, **kwargs)",
        "snippet": "def triplot(ax, *args, **kwargs):\n    \"\"\"\n    Draw a unstructured triangular grid as lines and/or markers.\n\n    The triangulation to plot can be specified in one of two ways;\n    either::\n\n      triplot(triangulation, ...)\n\n    where triangulation is a :class:`matplotlib.tri.Triangulation`\n    object, or\n\n    ::\n\n      triplot(x, y, ...)\n      triplot(x, y, triangles, ...)\n      triplot(x, y, triangles=triangles, ...)\n      triplot(x, y, mask=mask, ...)\n      triplot(x, y, triangles, mask=mask, ...)\n\n    in which case a Triangulation object will be created.  See\n    :class:`~matplotlib.tri.Triangulation` for a explanation of these\n    possibilities.\n\n    The remaining args and kwargs are the same as for\n    :meth:`~matplotlib.axes.Axes.plot`.\n\n    Return a list of 2 :class:`~matplotlib.lines.Line2D` containing\n    respectively:\n\n        - the lines plotted for triangles edges\n        - the markers plotted for triangles nodes\n    \"\"\"\n    import matplotlib.axes\n\n    tri, args, kwargs = Triangulation.get_from_args_and_kwargs(*args, **kwargs)\n    x, y, edges = (tri.x, tri.y, tri.edges)\n\n    # Decode plot format string, e.g., 'ro-'\n    fmt = args[0] if args else \"\"\n    linestyle, marker, color = matplotlib.axes._base._process_plot_format(fmt)\n\n    # Insert plot format string into a copy of kwargs (kwargs values prevail).\n    kw = kwargs.copy()\n    for key, val in zip(('linestyle', 'marker', 'color'),\n                        (linestyle, marker, color)):\n        if val is not None:\n            kw[key] = kwargs.get(key, val)\n\n    # Draw lines without markers.\n    # Note 1: If we drew markers here, most markers would be drawn more than\n    #         once as they belong to several edges.\n    # Note 2: We insert nan values in the flattened edges arrays rather than\n    #         plotting directly (triang.x[edges].T, triang.y[edges].T)\n    #         as it considerably speeds-up code execution.\n    linestyle = kw['linestyle']\n    kw_lines = {\n        **kw,\n        'marker': 'None',  # No marker to draw.\n        'zorder': kw.get('zorder', 1),  # Path default zorder is used.\n    }\n    if linestyle not in [None, 'None', '', ' ']:\n        tri_lines_x = np.insert(x[edges], 2, np.nan, axis=1)\n        tri_lines_y = np.insert(y[edges], 2, np.nan, axis=1)\n        tri_lines = ax.plot(tri_lines_x.ravel(), tri_lines_y.ravel(),\n                            **kw_lines)\n    else:\n        tri_lines = ax.plot([], [], **kw_lines)\n\n    # Draw markers separately.\n    marker = kw['marker']\n    kw_markers = {\n        **kw,\n        'linestyle': 'None',  # No line to draw.\n    }\n    if marker not in [None, 'None', '', ' ']:\n        tri_markers = ax.plot(x, y, **kw_markers)\n    else:\n        tri_markers = ax.plot([], [], **kw_markers)\n\n    return tri_lines + tri_markers",
        "begin_line": 5,
        "end_line": 85,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.ThetaTick._get_text2#275",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.ThetaTick",
        "signature": "lib.matplotlib.projections.polar.ThetaTick._get_text2(self)",
        "snippet": "    def _get_text2(self):\n        t = super()._get_text2()\n        t.set_rotation_mode('anchor')\n        t.set_transform(t.get_transform() + self._text2_translate)\n        return t",
        "begin_line": 275,
        "end_line": 279,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.RadialAxis.cla#680",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.RadialAxis",
        "signature": "lib.matplotlib.projections.polar.RadialAxis.cla(self)",
        "snippet": "    def cla(self):\n        super().cla()\n        self.set_ticks_position('none')\n        self._wrap_locator_formatter()",
        "begin_line": 680,
        "end_line": 683,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002190580503833516,
            "pseudo_dstar_susp": 0.00021367521367521368,
            "pseudo_tarantula_susp": 0.0002519526329050139,
            "pseudo_op2_susp": 0.00021367521367521368,
            "pseudo_barinel_susp": 0.00025201612903225806
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes._init_axis#816",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes._init_axis(self)",
        "snippet": "    def _init_axis(self):\n        \"move this out of __init__ because non-separable axes don't use it\"\n        self.xaxis = ThetaAxis(self)\n        self.yaxis = RadialAxis(self)\n        # Calling polar_axes.xaxis.cla() or polar_axes.xaxis.cla()\n        # results in weird artifacts. Therefore we disable this for\n        # now.\n        # self.spines['polar'].register_axis(self.yaxis)\n        self._update_transScale()",
        "begin_line": 816,
        "end_line": 824,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021299254526091586,
            "pseudo_dstar_susp": 0.00020738282870178348,
            "pseudo_tarantula_susp": 0.000231000231000231,
            "pseudo_op2_susp": 0.00020738282870178348,
            "pseudo_barinel_susp": 0.000231000231000231
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes.get_yaxis_transform#920",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes.get_yaxis_transform(self, which='grid')",
        "snippet": "    def get_yaxis_transform(self, which='grid'):\n        if which in ('tick1', 'tick2'):\n            return self._yaxis_text_transform\n        elif which == 'grid':\n            return self._yaxis_transform\n        else:\n            cbook._check_in_list(['tick1', 'tick2', 'grid'], which=which)",
        "begin_line": 920,
        "end_line": 926,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021381227282446012,
            "pseudo_dstar_susp": 0.0002074688796680498,
            "pseudo_tarantula_susp": 0.0002333177788147457,
            "pseudo_op2_susp": 0.0002074688796680498,
            "pseudo_barinel_susp": 0.0002333177788147457
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes._gen_axes_spines#997",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes._gen_axes_spines(self)",
        "snippet": "    def _gen_axes_spines(self):\n        spines = OrderedDict([\n            ('polar', mspines.Spine.arc_spine(self, 'top',\n                                              (0.5, 0.5), 0.5, 0.0, 360.0)),\n            ('start', mspines.Spine.linear_spine(self, 'left')),\n            ('end', mspines.Spine.linear_spine(self, 'right')),\n            ('inner', mspines.Spine.arc_spine(self, 'bottom',\n                                              (0.5, 0.5), 0.0, 0.0, 360.0))\n        ])\n        spines['polar'].set_transform(self.transWedge + self.transAxes)\n        spines['inner'].set_transform(self.transWedge + self.transAxes)\n        spines['start'].set_transform(self._yaxis_transform)\n        spines['end'].set_transform(self._yaxis_transform)\n        return spines",
        "begin_line": 997,
        "end_line": 1010,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021734405564007825,
            "pseudo_dstar_susp": 0.00021353833013025838,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00021353833013025838,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes.set_theta_offset#1041",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes.set_theta_offset(self, offset)",
        "snippet": "    def set_theta_offset(self, offset):\n        \"\"\"\n        Set the offset for the location of 0 in radians.\n        \"\"\"\n        mtx = self._theta_offset.get_matrix()\n        mtx[0, 2] = offset\n        self._theta_offset.invalidate()",
        "begin_line": 1041,
        "end_line": 1047,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012454851164528583,
            "pseudo_dstar_susp": 0.00011988970147464332,
            "pseudo_tarantula_susp": 0.00017415534656913968,
            "pseudo_op2_susp": 0.00011988970147464332,
            "pseudo_barinel_susp": 0.0001742767514813524
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes.set_rorigin#1150",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes.set_rorigin(self, rorigin)",
        "snippet": "    def set_rorigin(self, rorigin):\n        \"\"\"\n        Update the radial origin.\n\n        Parameters\n        ----------\n        rorigin : float\n        \"\"\"\n        self._originViewLim.locked_y0 = rorigin",
        "begin_line": 1150,
        "end_line": 1158,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes.set_ylim#1190",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes.set_ylim(self, bottom=None, top=None, emit=True, auto=False, *, ymin=None, ymax=None)",
        "snippet": "    def set_ylim(self, bottom=None, top=None, emit=True, auto=False,\n                 *, ymin=None, ymax=None):\n        \"\"\"\n        Set the data limits for the radial axis.\n\n        Parameters\n        ----------\n        bottom : scalar, optional\n            The bottom limit (default: None, which leaves the bottom\n            limit unchanged).\n            The bottom and top ylims may be passed as the tuple\n            (*bottom*, *top*) as the first positional argument (or as\n            the *bottom* keyword argument).\n\n        top : scalar, optional\n            The top limit (default: None, which leaves the top limit\n            unchanged).\n\n        emit : bool, optional\n            Whether to notify observers of limit change (default: True).\n\n        auto : bool or None, optional\n            Whether to turn on autoscaling of the y-axis. True turns on,\n            False turns off (default action), None leaves unchanged.\n\n        ymin, ymax : scalar, optional\n            These arguments are deprecated and will be removed in a future\n            version.  They are equivalent to *bottom* and *top* respectively,\n            and it is an error to pass both *ymin* and *bottom* or\n            *ymax* and *top*.\n\n        Returns\n        -------\n        bottom, top : (float, float)\n            The new y-axis limits in data coordinates.\n        \"\"\"\n        if ymin is not None:\n            if bottom is not None:\n                raise ValueError('Cannot supply both positional \"bottom\" '\n                                 'argument and kwarg \"ymin\"')\n            else:\n                bottom = ymin\n        if ymax is not None:\n            if top is not None:\n                raise ValueError('Cannot supply both positional \"top\" '\n                                 'argument and kwarg \"ymax\"')\n            else:\n                top = ymax\n        if top is None and np.iterable(bottom):\n            bottom, top = bottom[0], bottom[1]\n        return super().set_ylim(bottom=bottom, top=top, emit=emit, auto=auto)",
        "begin_line": 1190,
        "end_line": 1240,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes.set_rlabel_position#1251",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes.set_rlabel_position(self, value)",
        "snippet": "    def set_rlabel_position(self, value):\n        \"\"\"Updates the theta position of the radius labels.\n\n        Parameters\n        ----------\n        value : number\n            The angular position of the radius labels in degrees.\n        \"\"\"\n        self._r_label_position.clear().translate(np.deg2rad(value), 0.0)",
        "begin_line": 1251,
        "end_line": 1259,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes.set_thetagrids#1272",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes.set_thetagrids(self, angles, labels=None, fmt=None, **kwargs)",
        "snippet": "    def set_thetagrids(self, angles, labels=None, fmt=None, **kwargs):\n        \"\"\"\n        Set the theta gridlines in a polar plot.\n\n        Parameters\n        ----------\n        angles : tuple with floats, degrees\n            The angles of the theta gridlines.\n\n        labels : tuple with strings or None\n            The labels to use at each theta gridline. The\n            `.projections.polar.ThetaFormatter` will be used if None.\n\n        fmt : str or None\n            Format string used in `matplotlib.ticker.FormatStrFormatter`.\n            For example '%f'. Note that the angle that is used is in\n            radians.\n\n        Returns\n        -------\n        lines, labels : list of `.lines.Line2D`, list of `.text.Text`\n            *lines* are the theta gridlines and *labels* are the tick labels.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            *kwargs* are optional `~.Text` properties for the labels.\n\n        See Also\n        --------\n        .PolarAxes.set_rgrids\n        .Axis.get_gridlines\n        .Axis.get_ticklabels\n        \"\"\"\n\n        # Make sure we take into account unitized data\n        angles = self.convert_yunits(angles)\n        angles = np.deg2rad(angles)\n        self.set_xticks(angles)\n        if labels is not None:\n            self.set_xticklabels(labels)\n        elif fmt is not None:\n            self.xaxis.set_major_formatter(mticker.FormatStrFormatter(fmt))\n        for t in self.xaxis.get_ticklabels():\n            t.update(kwargs)\n        return self.xaxis.get_ticklines(), self.xaxis.get_ticklabels()",
        "begin_line": 1272,
        "end_line": 1317,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes.get_data_ratio#1388",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes.get_data_ratio(self)",
        "snippet": "    def get_data_ratio(self):\n        '''\n        Return the aspect ratio of the data itself.  For a polar plot,\n        this should always be 1.0\n        '''\n        return 1.0",
        "begin_line": 1388,
        "end_line": 1393,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002271178741766977,
            "pseudo_dstar_susp": 0.00021427040925648167,
            "pseudo_tarantula_susp": 0.00029197080291970805,
            "pseudo_op2_susp": 0.00021427040925648167,
            "pseudo_barinel_susp": 0.00029197080291970805
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.set_title#148",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.set_title(self, label, fontdict=None, loc=None, pad=None, **kwargs)",
        "snippet": "    def set_title(self, label, fontdict=None, loc=None, pad=None,\n                    **kwargs):\n        \"\"\"\n        Set a title for the axes.\n\n        Set one of the three available axes titles. The available titles\n        are positioned above the axes in the center, flush with the left\n        edge, and flush with the right edge.\n\n        Parameters\n        ----------\n        label : str\n            Text to use for the title\n\n        fontdict : dict\n            A dictionary controlling the appearance of the title text,\n            the default *fontdict* is::\n\n               {'fontsize': rcParams['axes.titlesize'],\n                'fontweight' : rcParams['axes.titleweight'],\n                'color' : rcParams['axes.titlecolor'],\n                'verticalalignment': 'baseline',\n                'horizontalalignment': loc}\n\n        loc : {'center', 'left', 'right'}, str, optional\n            Which title to set.\n            If *None*, defaults to :rc:`axes.titlelocation`.\n\n        pad : float\n            The offset of the title from the top of the axes, in points.\n            If *None*, defaults to :rc:`axes.titlepad`.\n\n        Returns\n        -------\n        text : :class:`~matplotlib.text.Text`\n            The matplotlib text instance representing the title\n\n        Other Parameters\n        ----------------\n        **kwargs : `~matplotlib.text.Text` properties\n            Other keyword arguments are text properties, see\n            :class:`~matplotlib.text.Text` for a list of valid text\n            properties.\n        \"\"\"\n        if loc is None:\n            loc = rcParams['axes.titlelocation']\n\n        titles = {'left': self._left_title,\n                  'center': self.title,\n                  'right': self._right_title}\n        title = cbook._check_getitem(titles, loc=loc.lower())\n        default = {\n            'fontsize': rcParams['axes.titlesize'],\n            'fontweight': rcParams['axes.titleweight'],\n            'verticalalignment': 'baseline',\n            'horizontalalignment': loc.lower()}\n        titlecolor = rcParams['axes.titlecolor']\n        if not cbook._str_lower_equal(titlecolor, 'auto'):\n            default[\"color\"] = titlecolor\n        if pad is None:\n            pad = rcParams['axes.titlepad']\n        self._set_title_offset_trans(float(pad))\n        title.set_text(label)\n        title.update(default)\n        if fontdict is not None:\n            title.update(fontdict)\n        title.update(kwargs)\n        return title",
        "begin_line": 148,
        "end_line": 215,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006242197253433209,
            "pseudo_dstar_susp": 0.0006821282401091405,
            "pseudo_tarantula_susp": 0.0002306805074971165,
            "pseudo_op2_susp": 0.0006821282401091405,
            "pseudo_barinel_susp": 0.0002306805074971165
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.get_ylabel#250",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.get_ylabel(self)",
        "snippet": "    def get_ylabel(self):\n        \"\"\"\n        Get the ylabel text string.\n        \"\"\"\n        label = self.yaxis.get_label()\n        return label.get_text()",
        "begin_line": 250,
        "end_line": 255,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020842017507294707,
            "pseudo_dstar_susp": 0.0001986491855383393,
            "pseudo_tarantula_susp": 0.00023304591004427873,
            "pseudo_op2_susp": 0.0001986491855383393,
            "pseudo_barinel_susp": 0.00023304591004427873
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.set_ylabel#257",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.set_ylabel(self, ylabel, fontdict=None, labelpad=None, **kwargs)",
        "snippet": "    def set_ylabel(self, ylabel, fontdict=None, labelpad=None, **kwargs):\n        \"\"\"\n        Set the label for the y-axis.\n\n        Parameters\n        ----------\n        ylabel : str\n            The label text.\n\n        labelpad : scalar, optional, default: None\n            Spacing in points from the axes bounding box including ticks\n            and tick labels.\n\n        Other Parameters\n        ----------------\n        **kwargs : `.Text` properties\n            `.Text` properties control the appearance of the label.\n\n        See also\n        --------\n        text : for information on how override and the optional args work\n\n        \"\"\"\n        if labelpad is not None:\n            self.yaxis.labelpad = labelpad\n        return self.yaxis.set_label_text(ylabel, fontdict, **kwargs)",
        "begin_line": 257,
        "end_line": 282,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002501876407305479,
            "pseudo_dstar_susp": 0.00025316455696202533,
            "pseudo_tarantula_susp": 0.00023078698361412417,
            "pseudo_op2_susp": 0.00025316455696202533,
            "pseudo_barinel_susp": 0.00023078698361412417
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.legend#301",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.legend(self, *args, **kwargs)",
        "snippet": "    def legend(self, *args, **kwargs):\n        \"\"\"\n        Place a legend on the axes.\n\n        Call signatures::\n\n            legend()\n            legend(labels)\n            legend(handles, labels)\n\n        The call signatures correspond to three different ways how to use\n        this method.\n\n        **1. Automatic detection of elements to be shown in the legend**\n\n        The elements to be added to the legend are automatically determined,\n        when you do not pass in any extra arguments.\n\n        In this case, the labels are taken from the artist. You can specify\n        them either at artist creation or by calling the\n        :meth:`~.Artist.set_label` method on the artist::\n\n            line, = ax.plot([1, 2, 3], label='Inline label')\n            ax.legend()\n\n        or::\n\n            line, = ax.plot([1, 2, 3])\n            line.set_label('Label via method')\n            ax.legend()\n\n        Specific lines can be excluded from the automatic legend element\n        selection by defining a label starting with an underscore.\n        This is default for all artists, so calling `Axes.legend` without\n        any arguments and without setting the labels manually will result in\n        no legend being drawn.\n\n\n        **2. Labeling existing plot elements**\n\n        To make a legend for lines which already exist on the axes\n        (via plot for instance), simply call this function with an iterable\n        of strings, one for each legend item. For example::\n\n            ax.plot([1, 2, 3])\n            ax.legend(['A simple line'])\n\n        Note: This way of using is discouraged, because the relation between\n        plot elements and labels is only implicit by their order and can\n        easily be mixed up.\n\n\n        **3. Explicitly defining the elements in the legend**\n\n        For full control of which artists have a legend entry, it is possible\n        to pass an iterable of legend artists followed by an iterable of\n        legend labels respectively::\n\n            legend((line1, line2, line3), ('label1', 'label2', 'label3'))\n\n        Parameters\n        ----------\n        handles : sequence of `.Artist`, optional\n            A list of Artists (lines, patches) to be added to the legend.\n            Use this together with *labels*, if you need full control on what\n            is shown in the legend and the automatic mechanism described above\n            is not sufficient.\n\n            The length of handles and labels should be the same in this\n            case. If they are not, they are truncated to the smaller length.\n\n        labels : list of str, optional\n            A list of labels to show next to the artists.\n            Use this together with *handles*, if you need full control on what\n            is shown in the legend and the automatic mechanism described above\n            is not sufficient.\n\n        Other Parameters\n        ----------------\n        %(_legend_kw_doc)s\n\n        Returns\n        -------\n        legend : `~matplotlib.legend.Legend`\n\n        Notes\n        -----\n        Not all kinds of artist are supported by the legend command. See\n        :doc:`/tutorials/intermediate/legend_guide` for details.\n\n        Examples\n        --------\n        .. plot:: gallery/text_labels_and_annotations/legend.py\n        \"\"\"\n        handles, labels, extra_args, kwargs = mlegend._parse_legend_args(\n                [self],\n                *args,\n                **kwargs)\n        if len(extra_args):\n            raise TypeError('legend only accepts two non-keyword arguments')\n        self.legend_ = mlegend.Legend(self, handles, labels, **kwargs)\n        self.legend_._remove_method = self._remove_legend\n        return self.legend_",
        "begin_line": 301,
        "end_line": 403,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002443195699975568,
            "pseudo_dstar_susp": 0.00025075225677031093,
            "pseudo_tarantula_susp": 0.00022426553038797938,
            "pseudo_op2_susp": 0.00025075225677031093,
            "pseudo_barinel_susp": 0.00022426553038797938
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.text#689",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.text(self, x, y, s, fontdict=None, withdash=False, **kwargs)",
        "snippet": "    def text(self, x, y, s, fontdict=None, withdash=False, **kwargs):\n        \"\"\"\n        Add text to the axes.\n\n        Add the text *s* to the axes at location *x*, *y* in data coordinates.\n\n        Parameters\n        ----------\n        x, y : scalars\n            The position to place the text. By default, this is in data\n            coordinates. The coordinate system can be changed using the\n            *transform* parameter.\n\n        s : str\n            The text.\n\n        fontdict : dictionary, optional, default: None\n            A dictionary to override the default text properties. If fontdict\n            is None, the defaults are determined by your rc parameters.\n\n        withdash : boolean, optional, default: False\n            Creates a `~matplotlib.text.TextWithDash` instance instead of a\n            `~matplotlib.text.Text` instance.\n\n        Returns\n        -------\n        text : `.Text`\n            The created `.Text` instance.\n\n        Other Parameters\n        ----------------\n        **kwargs : `~matplotlib.text.Text` properties.\n            Other miscellaneous text parameters.\n\n        Examples\n        --------\n        Individual keyword arguments can be used to override any given\n        parameter::\n\n            >>> text(x, y, s, fontsize=12)\n\n        The default transform specifies that text is in data coords,\n        alternatively, you can specify text in axis coords ((0, 0) is\n        lower-left and (1, 1) is upper-right).  The example below places\n        text in the center of the axes::\n\n            >>> text(0.5, 0.5, 'matplotlib', horizontalalignment='center',\n            ...      verticalalignment='center', transform=ax.transAxes)\n\n        You can put a rectangular box around the text instance (e.g., to\n        set a background color) by using the keyword *bbox*.  *bbox* is\n        a dictionary of `~matplotlib.patches.Rectangle`\n        properties.  For example::\n\n            >>> text(x, y, s, bbox=dict(facecolor='red', alpha=0.5))\n        \"\"\"\n        if fontdict is None:\n            fontdict = {}\n\n        effective_kwargs = {\n            'verticalalignment': 'baseline',\n            'horizontalalignment': 'left',\n            'transform': self.transData,\n            'clip_on': False,\n            **fontdict,\n            **kwargs,\n        }\n\n        # At some point if we feel confident that TextWithDash\n        # is robust as a drop-in replacement for Text and that\n        # the performance impact of the heavier-weight class\n        # isn't too significant, it may make sense to eliminate\n        # the withdash kwarg and simply delegate whether there's\n        # a dash to TextWithDash and dashlength.\n\n        if (withdash\n                and withdash is not cbook.deprecation._deprecated_parameter):\n            t = mtext.TextWithDash(x, y, text=s)\n        else:\n            t = mtext.Text(x, y, text=s)\n        t.update(effective_kwargs)\n\n        t.set_clip_path(self.patch)\n        self._add_text(t)\n        return t",
        "begin_line": 689,
        "end_line": 773,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018053800324968405,
            "pseudo_dstar_susp": 0.0001952362358453729,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0001952362358453729,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.annotate#776",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.annotate(self, s, xy, *args, **kwargs)",
        "snippet": "    def annotate(self, s, xy, *args, **kwargs):\n        a = mtext.Annotation(s, xy, *args, **kwargs)\n        a.set_transform(mtransforms.IdentityTransform())\n        if 'clip_on' in kwargs:\n            a.set_clip_path(self.patch)\n        self._add_text(a)\n        return a",
        "begin_line": 776,
        "end_line": 782,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015659254619480113,
            "pseudo_dstar_susp": 0.00015158405335758679,
            "pseudo_tarantula_susp": 0.0002158894645941278,
            "pseudo_op2_susp": 0.00015158405335758679,
            "pseudo_barinel_susp": 0.00021598272138228941
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.axhline#787",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.axhline(self, y=0, xmin=0, xmax=1, **kwargs)",
        "snippet": "    def axhline(self, y=0, xmin=0, xmax=1, **kwargs):\n        \"\"\"\n        Add a horizontal line across the axis.\n\n        Parameters\n        ----------\n        y : scalar, optional, default: 0\n            y position in data coordinates of the horizontal line.\n\n        xmin : scalar, optional, default: 0\n            Should be between 0 and 1, 0 being the far left of the plot, 1 the\n            far right of the plot.\n\n        xmax : scalar, optional, default: 1\n            Should be between 0 and 1, 0 being the far left of the plot, 1 the\n            far right of the plot.\n\n        Returns\n        -------\n        line : `~matplotlib.lines.Line2D`\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Valid keyword arguments are `.Line2D` properties, with the\n            exception of 'transform':\n\n            %(_Line2D_docstr)s\n\n        See also\n        --------\n        hlines : Add horizontal lines in data coordinates.\n        axhspan : Add a horizontal span (rectangle) across the axis.\n\n        Examples\n        --------\n        * draw a thick red hline at 'y' = 0 that spans the xrange::\n\n            >>> axhline(linewidth=4, color='r')\n\n        * draw a default hline at 'y' = 1 that spans the xrange::\n\n            >>> axhline(y=1)\n\n        * draw a default hline at 'y' = .5 that spans the middle half of\n          the xrange::\n\n            >>> axhline(y=.5, xmin=0.25, xmax=0.75)\n        \"\"\"\n        if \"transform\" in kwargs:\n            raise ValueError(\n                \"'transform' is not allowed as a kwarg;\"\n                + \"axhline generates its own transform.\")\n        ymin, ymax = self.get_ybound()\n\n        # We need to strip away the units for comparison with\n        # non-unitized bounds\n        self._process_unit_info(ydata=y, kwargs=kwargs)\n        yy = self.convert_yunits(y)\n        scaley = (yy < ymin) or (yy > ymax)\n\n        trans = self.get_yaxis_transform(which='grid')\n        l = mlines.Line2D([xmin, xmax], [y, y], transform=trans, **kwargs)\n        self.add_line(l)\n        self._request_autoscale_view(scalex=False, scaley=scaley)\n        return l",
        "begin_line": 787,
        "end_line": 852,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018053800324968405,
            "pseudo_dstar_susp": 0.0001529987760097919,
            "pseudo_tarantula_susp": 0.0003450655624568668,
            "pseudo_op2_susp": 0.0001529987760097919,
            "pseudo_barinel_susp": 0.00034494653328734045
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.axvline#855",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.axvline(self, x=0, ymin=0, ymax=1, **kwargs)",
        "snippet": "    def axvline(self, x=0, ymin=0, ymax=1, **kwargs):\n        \"\"\"\n        Add a vertical line across the axes.\n\n        Parameters\n        ----------\n        x : scalar, optional, default: 0\n            x position in data coordinates of the vertical line.\n\n        ymin : scalar, optional, default: 0\n            Should be between 0 and 1, 0 being the bottom of the plot, 1 the\n            top of the plot.\n\n        ymax : scalar, optional, default: 1\n            Should be between 0 and 1, 0 being the bottom of the plot, 1 the\n            top of the plot.\n\n        Returns\n        -------\n        line : `~matplotlib.lines.Line2D`\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Valid keyword arguments are `.Line2D` properties, with the\n            exception of 'transform':\n\n            %(_Line2D_docstr)s\n\n        Examples\n        --------\n        * draw a thick red vline at *x* = 0 that spans the yrange::\n\n            >>> axvline(linewidth=4, color='r')\n\n        * draw a default vline at *x* = 1 that spans the yrange::\n\n            >>> axvline(x=1)\n\n        * draw a default vline at *x* = .5 that spans the middle half of\n          the yrange::\n\n            >>> axvline(x=.5, ymin=0.25, ymax=0.75)\n\n        See also\n        --------\n        vlines : Add vertical lines in data coordinates.\n        axvspan : Add a vertical span (rectangle) across the axis.\n        \"\"\"\n\n        if \"transform\" in kwargs:\n            raise ValueError(\n                \"'transform' is not allowed as a kwarg;\"\n                + \"axvline generates its own transform.\")\n        xmin, xmax = self.get_xbound()\n\n        # We need to strip away the units for comparison with\n        # non-unitized bounds\n        self._process_unit_info(xdata=x, kwargs=kwargs)\n        xx = self.convert_xunits(x)\n        scalex = (xx < xmin) or (xx > xmax)\n\n        trans = self.get_xaxis_transform(which='grid')\n        l = mlines.Line2D([x, x], [ymin, ymax], transform=trans, **kwargs)\n        self.add_line(l)\n        self._request_autoscale_view(scalex=scalex, scaley=False)\n        return l",
        "begin_line": 855,
        "end_line": 921,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001356300013563,
            "pseudo_dstar_susp": 0.00013766519823788548,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00013766519823788548,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.axhspan#924",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.axhspan(self, ymin, ymax, xmin=0, xmax=1, **kwargs)",
        "snippet": "    def axhspan(self, ymin, ymax, xmin=0, xmax=1, **kwargs):\n        \"\"\"\n        Add a horizontal span (rectangle) across the axis.\n\n        Draw a horizontal span (rectangle) from *ymin* to *ymax*.\n        With the default values of *xmin* = 0 and *xmax* = 1, this\n        always spans the xrange, regardless of the xlim settings, even\n        if you change them, e.g., with the :meth:`set_xlim` command.\n        That is, the horizontal extent is in axes coords: 0=left,\n        0.5=middle, 1.0=right but the *y* location is in data\n        coordinates.\n\n        Parameters\n        ----------\n        ymin : float\n               Lower limit of the horizontal span in data units.\n        ymax : float\n               Upper limit of the horizontal span in data units.\n        xmin : float, optional, default: 0\n               Lower limit of the vertical span in axes (relative\n               0-1) units.\n        xmax : float, optional, default: 1\n               Upper limit of the vertical span in axes (relative\n               0-1) units.\n\n        Returns\n        -------\n        Polygon : `~matplotlib.patches.Polygon`\n\n        Other Parameters\n        ----------------\n        **kwargs : `~matplotlib.patches.Polygon` properties.\n\n        %(Polygon)s\n\n        See Also\n        --------\n        axvspan : Add a vertical span across the axes.\n        \"\"\"\n        trans = self.get_yaxis_transform(which='grid')\n\n        # process the unit information\n        self._process_unit_info([xmin, xmax], [ymin, ymax], kwargs=kwargs)\n\n        # first we need to strip away the units\n        xmin, xmax = self.convert_xunits([xmin, xmax])\n        ymin, ymax = self.convert_yunits([ymin, ymax])\n\n        verts = (xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)\n        p = mpatches.Polygon(verts, **kwargs)\n        p.set_transform(trans)\n        self.add_patch(p)\n        self._request_autoscale_view(scalex=False)\n        return p",
        "begin_line": 924,
        "end_line": 977,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.hlines#1045",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.hlines(self, y, xmin, xmax, colors='k', linestyles='solid', label='', **kwargs)",
        "snippet": "    def hlines(self, y, xmin, xmax, colors='k', linestyles='solid',\n               label='', **kwargs):\n        \"\"\"\n        Plot horizontal lines at each *y* from *xmin* to *xmax*.\n\n        Parameters\n        ----------\n        y : scalar or sequence of scalar\n            y-indexes where to plot the lines.\n\n        xmin, xmax : scalar or 1D array-like\n            Respective beginning and end of each line. If scalars are\n            provided, all lines will have same length.\n\n        colors : array-like of colors, optional, default: 'k'\n\n        linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, optional\n\n        label : str, optional, default: ''\n\n        Returns\n        -------\n        lines : `~matplotlib.collections.LineCollection`\n\n        Other Parameters\n        ----------------\n        **kwargs :  `~matplotlib.collections.LineCollection` properties.\n\n        See also\n        --------\n        vlines : vertical lines\n        axhline: horizontal line across the axes\n        \"\"\"\n\n        # We do the conversion first since not all unitized data is uniform\n        # process the unit information\n        self._process_unit_info([xmin, xmax], y, kwargs=kwargs)\n        y = self.convert_yunits(y)\n        xmin = self.convert_xunits(xmin)\n        xmax = self.convert_xunits(xmax)\n\n        if not np.iterable(y):\n            y = [y]\n        if not np.iterable(xmin):\n            xmin = [xmin]\n        if not np.iterable(xmax):\n            xmax = [xmax]\n\n        y, xmin, xmax = cbook.delete_masked_points(y, xmin, xmax)\n\n        y = np.ravel(y)\n        xmin = np.resize(xmin, y.shape)\n        xmax = np.resize(xmax, y.shape)\n\n        verts = [((thisxmin, thisy), (thisxmax, thisy))\n                 for thisxmin, thisxmax, thisy in zip(xmin, xmax, y)]\n        lines = mcoll.LineCollection(verts, colors=colors,\n                                     linestyles=linestyles, label=label)\n        self.add_collection(lines, autolim=False)\n        lines.update(kwargs)\n\n        if len(y) > 0:\n            minx = min(xmin.min(), xmax.min())\n            maxx = max(xmin.max(), xmax.max())\n            miny = y.min()\n            maxy = y.max()\n\n            corners = (minx, miny), (maxx, maxy)\n\n            self.update_datalim(corners)\n            self._request_autoscale_view()\n\n        return lines",
        "begin_line": 1045,
        "end_line": 1117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.vlines#1121",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.vlines(self, x, ymin, ymax, colors='k', linestyles='solid', label='', **kwargs)",
        "snippet": "    def vlines(self, x, ymin, ymax, colors='k', linestyles='solid',\n               label='', **kwargs):\n        \"\"\"\n        Plot vertical lines.\n\n        Plot vertical lines at each *x* from *ymin* to *ymax*.\n\n        Parameters\n        ----------\n        x : scalar or 1D array-like\n            x-indexes where to plot the lines.\n\n        ymin, ymax : scalar or 1D array-like\n            Respective beginning and end of each line. If scalars are\n            provided, all lines will have same length.\n\n        colors : array-like of colors, optional, default: 'k'\n\n        linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, optional\n\n        label : str, optional, default: ''\n\n        Returns\n        -------\n        lines : `~matplotlib.collections.LineCollection`\n\n        Other Parameters\n        ----------------\n        **kwargs : `~matplotlib.collections.LineCollection` properties.\n\n        See also\n        --------\n        hlines : horizontal lines\n        axvline: vertical line across the axes\n        \"\"\"\n\n        self._process_unit_info(xdata=x, ydata=[ymin, ymax], kwargs=kwargs)\n\n        # We do the conversion first since not all unitized data is uniform\n        x = self.convert_xunits(x)\n        ymin = self.convert_yunits(ymin)\n        ymax = self.convert_yunits(ymax)\n\n        if not np.iterable(x):\n            x = [x]\n        if not np.iterable(ymin):\n            ymin = [ymin]\n        if not np.iterable(ymax):\n            ymax = [ymax]\n\n        x, ymin, ymax = cbook.delete_masked_points(x, ymin, ymax)\n\n        x = np.ravel(x)\n        ymin = np.resize(ymin, x.shape)\n        ymax = np.resize(ymax, x.shape)\n\n        verts = [((thisx, thisymin), (thisx, thisymax))\n                 for thisx, thisymin, thisymax in zip(x, ymin, ymax)]\n        lines = mcoll.LineCollection(verts, colors=colors,\n                                     linestyles=linestyles, label=label)\n        self.add_collection(lines, autolim=False)\n        lines.update(kwargs)\n\n        if len(x) > 0:\n            minx = x.min()\n            maxx = x.max()\n            miny = min(ymin.min(), ymax.min())\n            maxy = max(ymin.max(), ymax.max())\n\n            corners = (minx, miny), (maxx, maxy)\n            self.update_datalim(corners)\n            self._request_autoscale_view()\n\n        return lines",
        "begin_line": 1121,
        "end_line": 1194,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016725204883759825,
            "pseudo_dstar_susp": 0.0002153316106804479,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.0002153316106804479,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.plot#1414",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.plot(self, *args, scalex=True, scaley=True, data=None, **kwargs)",
        "snippet": "    def plot(self, *args, scalex=True, scaley=True, data=None, **kwargs):\n        \"\"\"\n        Plot y versus x as lines and/or markers.\n\n        Call signatures::\n\n            plot([x], y, [fmt], *, data=None, **kwargs)\n            plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)\n\n        The coordinates of the points or line nodes are given by *x*, *y*.\n\n        The optional parameter *fmt* is a convenient way for defining basic\n        formatting like color, marker and linestyle. It's a shortcut string\n        notation described in the *Notes* section below.\n\n        >>> plot(x, y)        # plot x and y using default line style and color\n        >>> plot(x, y, 'bo')  # plot x and y using blue circle markers\n        >>> plot(y)           # plot y using x as index array 0..N-1\n        >>> plot(y, 'r+')     # ditto, but with red plusses\n\n        You can use `.Line2D` properties as keyword arguments for more\n        control on the appearance. Line properties and *fmt* can be mixed.\n        The following two calls yield identical results:\n\n        >>> plot(x, y, 'go--', linewidth=2, markersize=12)\n        >>> plot(x, y, color='green', marker='o', linestyle='dashed',\n        ...      linewidth=2, markersize=12)\n\n        When conflicting with *fmt*, keyword arguments take precedence.\n\n\n        **Plotting labelled data**\n\n        There's a convenient way for plotting objects with labelled data (i.e.\n        data that can be accessed by index ``obj['y']``). Instead of giving\n        the data in *x* and *y*, you can provide the object in the *data*\n        parameter and just give the labels for *x* and *y*::\n\n        >>> plot('xlabel', 'ylabel', data=obj)\n\n        All indexable objects are supported. This could e.g. be a `dict`, a\n        `pandas.DataFame` or a structured numpy array.\n\n\n        **Plotting multiple sets of data**\n\n        There are various ways to plot multiple sets of data.\n\n        - The most straight forward way is just to call `plot` multiple times.\n          Example:\n\n          >>> plot(x1, y1, 'bo')\n          >>> plot(x2, y2, 'go')\n\n        - Alternatively, if your data is already a 2d array, you can pass it\n          directly to *x*, *y*. A separate data set will be drawn for every\n          column.\n\n          Example: an array ``a`` where the first column represents the *x*\n          values and the other columns are the *y* columns::\n\n          >>> plot(a[0], a[1:])\n\n        - The third way is to specify multiple sets of *[x]*, *y*, *[fmt]*\n          groups::\n\n          >>> plot(x1, y1, 'g^', x2, y2, 'g-')\n\n          In this case, any additional keyword argument applies to all\n          datasets. Also this syntax cannot be combined with the *data*\n          parameter.\n\n        By default, each line is assigned a different style specified by a\n        'style cycle'. The *fmt* and line property parameters are only\n        necessary if you want explicit deviations from these defaults.\n        Alternatively, you can also change the style cycle using\n        :rc:`axes.prop_cycle`.\n\n\n        Parameters\n        ----------\n        x, y : array-like or scalar\n            The horizontal / vertical coordinates of the data points.\n            *x* values are optional and default to `range(len(y))`.\n\n            Commonly, these parameters are 1D arrays.\n\n            They can also be scalars, or two-dimensional (in that case, the\n            columns represent separate data sets).\n\n            These arguments cannot be passed as keywords.\n\n        fmt : str, optional\n            A format string, e.g. 'ro' for red circles. See the *Notes*\n            section for a full description of the format strings.\n\n            Format strings are just an abbreviation for quickly setting\n            basic line properties. All of these and more can also be\n            controlled by keyword arguments.\n\n            This argument cannot be passed as keyword.\n\n        data : indexable object, optional\n            An object with labelled data. If given, provide the label names to\n            plot in *x* and *y*.\n\n            .. note::\n                Technically there's a slight ambiguity in calls where the\n                second label is a valid *fmt*. `plot('n', 'o', data=obj)`\n                could be `plt(x, y)` or `plt(y, fmt)`. In such cases,\n                the former interpretation is chosen, but a warning is issued.\n                You may suppress the warning by adding an empty format string\n                `plot('n', 'o', '', data=obj)`.\n\n        Other Parameters\n        ----------------\n        scalex, scaley : bool, optional, default: True\n            These parameters determined if the view limits are adapted to\n            the data limits. The values are passed on to `autoscale_view`.\n\n        **kwargs : `.Line2D` properties, optional\n            *kwargs* are used to specify properties like a line label (for\n            auto legends), linewidth, antialiasing, marker face color.\n            Example::\n\n            >>> plot([1, 2, 3], [1, 2, 3], 'go-', label='line 1', linewidth=2)\n            >>> plot([1, 2, 3], [1, 4, 9], 'rs', label='line 2')\n\n            If you make multiple lines with one plot command, the kwargs\n            apply to all those lines.\n\n            Here is a list of available `.Line2D` properties:\n\n            %(_Line2D_docstr)s\n\n        Returns\n        -------\n        lines\n            A list of `.Line2D` objects representing the plotted data.\n\n        See Also\n        --------\n        scatter : XY scatter plot with markers of varying size and/or color (\n            sometimes also called bubble chart).\n\n        Notes\n        -----\n        **Format Strings**\n\n        A format string consists of a part for color, marker and line::\n\n            fmt = '[marker][line][color]'\n\n        Each of them is optional. If not provided, the value from the style\n        cycle is used. Exception: If ``line`` is given, but no ``marker``,\n        the data will be a line without markers.\n\n        Other combinations such as ``[color][marker][line]`` are also\n        supported, but note that their parsing may be ambiguous.\n\n        **Markers**\n\n        =============    ===============================\n        character        description\n        =============    ===============================\n        ``'.'``          point marker\n        ``','``          pixel marker\n        ``'o'``          circle marker\n        ``'v'``          triangle_down marker\n        ``'^'``          triangle_up marker\n        ``'<'``          triangle_left marker\n        ``'>'``          triangle_right marker\n        ``'1'``          tri_down marker\n        ``'2'``          tri_up marker\n        ``'3'``          tri_left marker\n        ``'4'``          tri_right marker\n        ``'s'``          square marker\n        ``'p'``          pentagon marker\n        ``'*'``          star marker\n        ``'h'``          hexagon1 marker\n        ``'H'``          hexagon2 marker\n        ``'+'``          plus marker\n        ``'x'``          x marker\n        ``'D'``          diamond marker\n        ``'d'``          thin_diamond marker\n        ``'|'``          vline marker\n        ``'_'``          hline marker\n        =============    ===============================\n\n        **Line Styles**\n\n        =============    ===============================\n        character        description\n        =============    ===============================\n        ``'-'``          solid line style\n        ``'--'``         dashed line style\n        ``'-.'``         dash-dot line style\n        ``':'``          dotted line style\n        =============    ===============================\n\n        Example format strings::\n\n            'b'    # blue markers with default shape\n            'or'   # red circles\n            '-g'   # green solid line\n            '--'   # dashed line with default color\n            '^k:'  # black triangle_up markers connected by a dotted line\n\n        **Colors**\n\n        The supported color abbreviations are the single letter codes\n\n        =============    ===============================\n        character        color\n        =============    ===============================\n        ``'b'``          blue\n        ``'g'``          green\n        ``'r'``          red\n        ``'c'``          cyan\n        ``'m'``          magenta\n        ``'y'``          yellow\n        ``'k'``          black\n        ``'w'``          white\n        =============    ===============================\n\n        and the ``'CN'`` colors that index into the default property cycle.\n\n        If the color is the only part of the format string, you can\n        additionally use any  `matplotlib.colors` spec, e.g. full names\n        (``'green'``) or hex strings (``'#008000'``).\n        \"\"\"\n        kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)\n        lines = [*self._get_lines(*args, data=data, **kwargs)]\n        for line in lines:\n            self.add_line(line)\n        self._request_autoscale_view(scalex=scalex, scaley=scaley)\n        return lines",
        "begin_line": 1414,
        "end_line": 1650,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00031026993484331366,
            "pseudo_dstar_susp": 0.00033277870216306157,
            "pseudo_tarantula_susp": 0.00017927572606669058,
            "pseudo_op2_susp": 0.00033277870216306157,
            "pseudo_barinel_susp": 0.00017927572606669058
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.plot_date#1654",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.plot_date(self, x, y, fmt='o', tz=None, xdate=True, ydate=False, **kwargs)",
        "snippet": "    def plot_date(self, x, y, fmt='o', tz=None, xdate=True, ydate=False,\n                  **kwargs):\n        \"\"\"\n        Plot data that contains dates.\n\n        Similar to `.plot`, this plots *y* vs. *x* as lines or markers.\n        However, the axis labels are formatted as dates depending on *xdate*\n        and *ydate*.\n\n        Parameters\n        ----------\n        x, y : array-like\n            The coordinates of the data points. If *xdate* or *ydate* is\n            *True*, the respective values *x* or *y* are interpreted as\n            :ref:`Matplotlib dates <date-format>`.\n\n        fmt : str, optional\n            The plot format string. For details, see the corresponding\n            parameter in `.plot`.\n\n        tz : timezone string or `tzinfo` or None\n            The time zone to use in labeling dates. If *None*, defaults to\n            :rc:`timezone`.\n\n        xdate : bool, optional, default: True\n            If *True*, the *x*-axis will be interpreted as Matplotlib dates.\n\n        ydate : bool, optional, default: False\n            If *True*, the *y*-axis will be interpreted as Matplotlib dates.\n\n\n        Returns\n        -------\n        lines\n            A list of `.Line2D` objects representing the plotted data.\n\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Keyword arguments control the `.Line2D` properties:\n\n            %(_Line2D_docstr)s\n\n        See Also\n        --------\n        matplotlib.dates : Helper functions on dates.\n        matplotlib.dates.date2num : Convert dates to num.\n        matplotlib.dates.num2date : Convert num to dates.\n        matplotlib.dates.drange : Create an equally spaced sequence of dates.\n\n        Notes\n        -----\n        If you are using custom date tickers and formatters, it may be\n        necessary to set the formatters/locators after the call to\n        `.plot_date`. `.plot_date` will set the default tick locator to\n        `.AutoDateLocator` (if the tick locator is not already set to a\n        `.DateLocator` instance) and the default tick formatter to\n        `.AutoDateFormatter` (if the tick formatter is not already set to a\n        `.DateFormatter` instance).\n        \"\"\"\n        if xdate:\n            self.xaxis_date(tz)\n        if ydate:\n            self.yaxis_date(tz)\n\n        ret = self.plot(x, y, fmt, **kwargs)\n\n        self._request_autoscale_view()\n\n        return ret",
        "begin_line": 1654,
        "end_line": 1724,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019916351324437363,
            "pseudo_dstar_susp": 0.00016353229762878168,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00016353229762878168,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.loglog#1728",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.loglog(self, *args, **kwargs)",
        "snippet": "    def loglog(self, *args, **kwargs):\n        \"\"\"\n        Make a plot with log scaling on both the x and y axis.\n\n        Call signatures::\n\n            loglog([x], y, [fmt], data=None, **kwargs)\n            loglog([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)\n\n        This is just a thin wrapper around `.plot` which additionally changes\n        both the x-axis and the y-axis to log scaling. All of the concepts and\n        parameters of plot can be used here as well.\n\n        The additional parameters *basex/y*, *subsx/y* and *nonposx/y* control\n        the x/y-axis properties. They are just forwarded to `.Axes.set_xscale`\n        and `.Axes.set_yscale`.\n\n        Parameters\n        ----------\n        basex, basey : scalar, optional, default 10\n            Base of the x/y logarithm.\n\n        subsx, subsy : sequence, optional\n            The location of the minor x/y ticks. If *None*, reasonable\n            locations are automatically chosen depending on the number of\n            decades in the plot.\n            See `.Axes.set_xscale` / `.Axes.set_yscale` for details.\n\n        nonposx, nonposy : {'mask', 'clip'}, optional, default 'mask'\n            Non-positive values in x or y can be masked as invalid, or clipped\n            to a very small positive number.\n\n        Returns\n        -------\n        lines\n            A list of `.Line2D` objects representing the plotted data.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            All parameters supported by `.plot`.\n        \"\"\"\n        dx = {k: kwargs.pop(k) for k in ['basex', 'subsx', 'nonposx']\n              if k in kwargs}\n        dy = {k: kwargs.pop(k) for k in ['basey', 'subsy', 'nonposy']\n              if k in kwargs}\n\n        self.set_xscale('log', **dx)\n        self.set_yscale('log', **dy)\n\n        l = self.plot(*args, **kwargs)\n        return l",
        "begin_line": 1728,
        "end_line": 1779,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012454851164528583,
            "pseudo_dstar_susp": 0.00011988970147464332,
            "pseudo_tarantula_susp": 0.00017415534656913968,
            "pseudo_op2_susp": 0.00011988970147464332,
            "pseudo_barinel_susp": 0.0001742767514813524
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.semilogx#1783",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.semilogx(self, *args, **kwargs)",
        "snippet": "    def semilogx(self, *args, **kwargs):\n        \"\"\"\n        Make a plot with log scaling on the x axis.\n\n        Call signatures::\n\n            semilogx([x], y, [fmt], data=None, **kwargs)\n            semilogx([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)\n\n        This is just a thin wrapper around `.plot` which additionally changes\n        the x-axis to log scaling. All of the concepts and parameters of plot\n        can be used here as well.\n\n        The additional parameters *basex*, *subsx* and *nonposx* control the\n        x-axis properties. They are just forwarded to `.Axes.set_xscale`.\n\n        Parameters\n        ----------\n        basex : scalar, optional, default 10\n            Base of the x logarithm.\n\n        subsx : array-like, optional\n            The location of the minor xticks. If *None*, reasonable locations\n            are automatically chosen depending on the number of decades in the\n            plot. See `.Axes.set_xscale` for details.\n\n        nonposx : {'mask', 'clip'}, optional, default 'mask'\n            Non-positive values in x can be masked as invalid, or clipped to a\n            very small positive number.\n\n        Returns\n        -------\n        lines\n            A list of `.Line2D` objects representing the plotted data.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            All parameters supported by `.plot`.\n        \"\"\"\n        d = {k: kwargs.pop(k) for k in ['basex', 'subsx', 'nonposx']\n             if k in kwargs}\n\n        self.set_xscale('log', **d)\n        l = self.plot(*args, **kwargs)\n        return l",
        "begin_line": 1783,
        "end_line": 1828,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.semilogy#1832",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.semilogy(self, *args, **kwargs)",
        "snippet": "    def semilogy(self, *args, **kwargs):\n        \"\"\"\n        Make a plot with log scaling on the y axis.\n\n        Call signatures::\n\n            semilogy([x], y, [fmt], data=None, **kwargs)\n            semilogy([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)\n\n        This is just a thin wrapper around `.plot` which additionally changes\n        the y-axis to log scaling. All of the concepts and parameters of plot\n        can be used here as well.\n\n        The additional parameters *basey*, *subsy* and *nonposy* control the\n        y-axis properties. They are just forwarded to `.Axes.set_yscale`.\n\n        Parameters\n        ----------\n        basey : scalar, optional, default 10\n            Base of the y logarithm.\n\n        subsy : array-like, optional\n            The location of the minor yticks. If *None*, reasonable locations\n            are automatically chosen depending on the number of decades in the\n            plot. See `.Axes.set_yscale` for details.\n\n        nonposy : {'mask', 'clip'}, optional, default 'mask'\n            Non-positive values in y can be masked as invalid, or clipped to a\n            very small positive number.\n\n        Returns\n        -------\n        lines\n            A list of `.Line2D` objects representing the plotted data.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            All parameters supported by `.plot`.\n        \"\"\"\n        d = {k: kwargs.pop(k) for k in ['basey', 'subsy', 'nonposy']\n             if k in kwargs}\n        self.set_yscale('log', **d)\n        l = self.plot(*args, **kwargs)\n\n        return l",
        "begin_line": 1832,
        "end_line": 1877,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.acorr#1880",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.acorr(self, x, **kwargs)",
        "snippet": "    def acorr(self, x, **kwargs):\n        \"\"\"\n        Plot the autocorrelation of *x*.\n\n        Parameters\n        ----------\n        x : array-like\n\n        detrend : callable, optional, default: `mlab.detrend_none`\n            *x* is detrended by the *detrend* callable. This must be a\n            function ``x = detrend(x)`` accepting and returning an\n            `numpy.array`. Default is no normalization.\n\n        normed : bool, optional, default: True\n            If ``True``, input vectors are normalised to unit length.\n\n        usevlines : bool, optional, default: True\n            Determines the plot style.\n\n            If ``True``, vertical lines are plotted from 0 to the acorr value\n            using `Axes.vlines`. Additionally, a horizontal line is plotted\n            at y=0 using `Axes.axhline`.\n\n            If ``False``, markers are plotted at the acorr values using\n            `Axes.plot`.\n\n        maxlags : int, optional, default: 10\n            Number of lags to show. If ``None``, will return all\n            ``2 * len(x) - 1`` lags.\n\n        Returns\n        -------\n        lags : array (length ``2*maxlags+1``)\n            The lag vector.\n        c : array  (length ``2*maxlags+1``)\n            The auto correlation vector.\n        line : `.LineCollection` or `.Line2D`\n            `.Artist` added to the axes of the correlation:\n\n            - `.LineCollection` if *usevlines* is True.\n            - `.Line2D` if *usevlines* is False.\n        b : `.Line2D` or None\n            Horizontal line at 0 if *usevlines* is True\n            None *usevlines* is False.\n\n        Other Parameters\n        ----------------\n        linestyle : `.Line2D` property, optional\n            The linestyle for plotting the data points.\n            Only used if *usevlines* is ``False``.\n\n        marker : str, optional, default: 'o'\n            The marker for plotting the data points.\n            Only used if *usevlines* is ``False``.\n\n        Notes\n        -----\n        The cross correlation is performed with :func:`numpy.correlate` with\n        ``mode = \"full\"``.\n        \"\"\"\n        return self.xcorr(x, x, **kwargs)",
        "begin_line": 1880,
        "end_line": 1940,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.xcorr#1943",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.xcorr(self, x, y, normed=True, detrend=mlab.detrend_none, usevlines=True, maxlags=10, **kwargs)",
        "snippet": "    def xcorr(self, x, y, normed=True, detrend=mlab.detrend_none,\n              usevlines=True, maxlags=10, **kwargs):\n        r\"\"\"\n        Plot the cross correlation between *x* and *y*.\n\n        The correlation with lag k is defined as\n        :math:`\\sum_n x[n+k] \\cdot y^*[n]`, where :math:`y^*` is the complex\n        conjugate of :math:`y`.\n\n        Parameters\n        ----------\n        x : array-like of length n\n\n        y : array-like of length n\n\n        detrend : callable, optional, default: `mlab.detrend_none`\n            *x* and *y* are detrended by the *detrend* callable. This must be a\n            function ``x = detrend(x)`` accepting and returning an\n            `numpy.array`. Default is no normalization.\n\n        normed : bool, optional, default: True\n            If ``True``, input vectors are normalised to unit length.\n\n        usevlines : bool, optional, default: True\n            Determines the plot style.\n\n            If ``True``, vertical lines are plotted from 0 to the xcorr value\n            using `Axes.vlines`. Additionally, a horizontal line is plotted\n            at y=0 using `Axes.axhline`.\n\n            If ``False``, markers are plotted at the xcorr values using\n            `Axes.plot`.\n\n        maxlags : int, optional, default: 10\n            Number of lags to show. If None, will return all ``2 * len(x) - 1``\n            lags.\n\n        Returns\n        -------\n        lags : array (length ``2*maxlags+1``)\n            The lag vector.\n        c : array  (length ``2*maxlags+1``)\n            The auto correlation vector.\n        line : `.LineCollection` or `.Line2D`\n            `.Artist` added to the axes of the correlation:\n\n            - `.LineCollection` if *usevlines* is True.\n            - `.Line2D` if *usevlines* is False.\n        b : `.Line2D` or None\n            Horizontal line at 0 if *usevlines* is True\n            None *usevlines* is False.\n\n        Other Parameters\n        ----------------\n        linestyle : `.Line2D` property, optional\n            The linestyle for plotting the data points.\n            Only used if *usevlines* is ``False``.\n\n        marker : str, optional, default: 'o'\n            The marker for plotting the data points.\n            Only used if *usevlines* is ``False``.\n\n        Notes\n        -----\n        The cross correlation is performed with :func:`numpy.correlate` with\n        ``mode = \"full\"``.\n        \"\"\"\n        Nx = len(x)\n        if Nx != len(y):\n            raise ValueError('x and y must be equal length')\n\n        x = detrend(np.asarray(x))\n        y = detrend(np.asarray(y))\n\n        correls = np.correlate(x, y, mode=\"full\")\n\n        if normed:\n            correls /= np.sqrt(np.dot(x, x) * np.dot(y, y))\n\n        if maxlags is None:\n            maxlags = Nx - 1\n\n        if maxlags >= Nx or maxlags < 1:\n            raise ValueError('maxlags must be None or strictly '\n                             'positive < %d' % Nx)\n\n        lags = np.arange(-maxlags, maxlags + 1)\n        correls = correls[Nx - 1 - maxlags:Nx + maxlags]\n\n        if usevlines:\n            a = self.vlines(lags, [0], correls, **kwargs)\n            # Make label empty so only vertical lines get a legend entry\n            kwargs.pop('label', '')\n            b = self.axhline(**kwargs)\n        else:\n            kwargs.setdefault('marker', 'o')\n            kwargs.setdefault('linestyle', 'None')\n            a, = self.plot(lags, correls, **kwargs)\n            b = None\n        return lags, correls, a, b",
        "begin_line": 1943,
        "end_line": 2042,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.step#2047",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.step(self, x, y, *args, where='pre', data=None, **kwargs)",
        "snippet": "    def step(self, x, y, *args, where='pre', data=None, **kwargs):\n        \"\"\"\n        Make a step plot.\n\n        Call signatures::\n\n            step(x, y, [fmt], *, data=None, where='pre', **kwargs)\n            step(x, y, [fmt], x2, y2, [fmt2], ..., *, where='pre', **kwargs)\n\n        This is just a thin wrapper around `.plot` which changes some\n        formatting options. Most of the concepts and parameters of plot can be\n        used here as well.\n\n        Parameters\n        ----------\n        x : array-like\n            1-D sequence of x positions. It is assumed, but not checked, that\n            it is uniformly increasing.\n\n        y : array-like\n            1-D sequence of y levels.\n\n        fmt : str, optional\n            A format string, e.g. 'g' for a green line. See `.plot` for a more\n            detailed description.\n\n            Note: While full format strings are accepted, it is recommended to\n            only specify the color. Line styles are currently ignored (use\n            the keyword argument *linestyle* instead). Markers are accepted\n            and plotted on the given positions, however, this is a rarely\n            needed feature for step plots.\n\n        data : indexable object, optional\n            An object with labelled data. If given, provide the label names to\n            plot in *x* and *y*.\n\n        where : {'pre', 'post', 'mid'}, optional, default 'pre'\n            Define where the steps should be placed:\n\n            - 'pre': The y value is continued constantly to the left from\n              every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the\n              value ``y[i]``.\n            - 'post': The y value is continued constantly to the right from\n              every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the\n              value ``y[i]``.\n            - 'mid': Steps occur half-way between the *x* positions.\n\n        Returns\n        -------\n        lines\n            A list of `.Line2D` objects representing the plotted data.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Additional parameters are the same as those for `.plot`.\n\n        Notes\n        -----\n        .. [notes section required to get data note injection right]\n        \"\"\"\n        cbook._check_in_list(('pre', 'post', 'mid'), where=where)\n        kwargs['drawstyle'] = 'steps-' + where\n        return self.plot(x, y, *args, data=data, **kwargs)",
        "begin_line": 2047,
        "end_line": 2110,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes._convert_dx#2113",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes._convert_dx(dx, x0, xconv, convert)",
        "snippet": "    def _convert_dx(dx, x0, xconv, convert):\n        \"\"\"\n        Small helper to do logic of width conversion flexibly.\n\n        *dx* and *x0* have units, but *xconv* has already been converted\n        to unitless (and is an ndarray).  This allows the *dx* to have units\n        that are different from *x0*, but are still accepted by the\n        ``__add__`` operator of *x0*.\n        \"\"\"\n\n        # x should be an array...\n        assert type(xconv) is np.ndarray\n\n        if xconv.size == 0:\n            # xconv has already been converted, but maybe empty...\n            return convert(dx)\n\n        try:\n            # attempt to add the width to x0; this works for\n            # datetime+timedelta, for instance\n\n            # only use the first element of x and x0.  This saves\n            # having to be sure addition works across the whole\n            # vector.  This is particularly an issue if\n            # x0 and dx are lists so x0 + dx just concatenates the lists.\n            # We can't just cast x0 and dx to numpy arrays because that\n            # removes the units from unit packages like `pint` that\n            # wrap numpy arrays.\n            try:\n                x0 = cbook.safe_first_element(x0)\n            except (TypeError, IndexError, KeyError):\n                x0 = x0\n\n            try:\n                x = cbook.safe_first_element(xconv)\n            except (TypeError, IndexError, KeyError):\n                x = xconv\n\n            delist = False\n            if not np.iterable(dx):\n                dx = [dx]\n                delist = True\n            dx = [convert(x0 + ddx) - x for ddx in dx]\n            if delist:\n                dx = dx[0]\n        except (ValueError, TypeError, AttributeError):\n            # if the above fails (for any reason) just fallback to what\n            # we do by default and convert dx by itself.\n            dx = convert(dx)\n        return dx",
        "begin_line": 2113,
        "end_line": 2162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018846588767433095,
            "pseudo_dstar_susp": 0.00021963540522732265,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00021963540522732265,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.bar#2166",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.bar(self, x, height, width=0.8, bottom=None, *, align='center', **kwargs)",
        "snippet": "    def bar(self, x, height, width=0.8, bottom=None, *, align=\"center\",\n            **kwargs):\n        r\"\"\"\n        Make a bar plot.\n\n        The bars are positioned at *x* with the given *align*\\ment. Their\n        dimensions are given by *width* and *height*. The vertical baseline\n        is *bottom* (default 0).\n\n        Each of *x*, *height*, *width*, and *bottom* may either be a scalar\n        applying to all bars, or it may be a sequence of length N providing a\n        separate value for each bar.\n\n        Parameters\n        ----------\n        x : sequence of scalars\n            The x coordinates of the bars. See also *align* for the\n            alignment of the bars to the coordinates.\n\n        height : scalar or sequence of scalars\n            The height(s) of the bars.\n\n        width : scalar or array-like, optional\n            The width(s) of the bars (default: 0.8).\n\n        bottom : scalar or array-like, optional\n            The y coordinate(s) of the bars bases (default: 0).\n\n        align : {'center', 'edge'}, optional, default: 'center'\n            Alignment of the bars to the *x* coordinates:\n\n            - 'center': Center the base on the *x* positions.\n            - 'edge': Align the left edges of the bars with the *x* positions.\n\n            To align the bars on the right edge pass a negative *width* and\n            ``align='edge'``.\n\n        Returns\n        -------\n        container : `.BarContainer`\n            Container with all the bars and optionally errorbars.\n\n        Other Parameters\n        ----------------\n        color : scalar or array-like, optional\n            The colors of the bar faces.\n\n        edgecolor : scalar or array-like, optional\n            The colors of the bar edges.\n\n        linewidth : scalar or array-like, optional\n            Width of the bar edge(s). If 0, don't draw edges.\n\n        tick_label : str or array-like, optional\n            The tick labels of the bars.\n            Default: None (Use default numeric labels.)\n\n        xerr, yerr : scalar or array-like of shape(N,) or shape(2, N), optional\n            If not *None*, add horizontal / vertical errorbars to the bar tips.\n            The values are +/- sizes relative to the data:\n\n            - scalar: symmetric +/- values for all bars\n            - shape(N,): symmetric +/- values for each bar\n            - shape(2, N): Separate - and + values for each bar. First row\n              contains the lower errors, the second row contains the upper\n              errors.\n            - *None*: No errorbar. (Default)\n\n            See :doc:`/gallery/statistics/errorbar_features`\n            for an example on the usage of ``xerr`` and ``yerr``.\n\n        ecolor : scalar or array-like, optional, default: 'black'\n            The line color of the errorbars.\n\n        capsize : scalar, optional\n           The length of the error bar caps in points.\n           Default: None, which will take the value from\n           :rc:`errorbar.capsize`.\n\n        error_kw : dict, optional\n            Dictionary of kwargs to be passed to the `~.Axes.errorbar`\n            method. Values of *ecolor* or *capsize* defined here take\n            precedence over the independent kwargs.\n\n        log : bool, optional, default: False\n            If *True*, set the y-axis to be log scale.\n\n        orientation : {'vertical',  'horizontal'}, optional\n            *This is for internal use only.* Please use `barh` for\n            horizontal bar plots. Default: 'vertical'.\n\n        See also\n        --------\n        barh: Plot a horizontal bar plot.\n\n        Notes\n        -----\n        The optional arguments *color*, *edgecolor*, *linewidth*,\n        *xerr*, and *yerr* can be either scalars or sequences of\n        length equal to the number of bars.  This enables you to use\n        bar as the basis for stacked bar charts, or candlestick plots.\n        Detail: *xerr* and *yerr* are passed directly to\n        :meth:`errorbar`, so they can also have shape 2xN for\n        independent specification of lower and upper errors.\n\n        Other optional kwargs:\n\n        %(Rectangle)s\n        \"\"\"\n        kwargs = cbook.normalize_kwargs(kwargs, mpatches.Patch)\n        color = kwargs.pop('color', None)\n        if color is None:\n            color = self._get_patches_for_fill.get_next_color()\n        edgecolor = kwargs.pop('edgecolor', None)\n        linewidth = kwargs.pop('linewidth', None)\n\n        # Because xerr and yerr will be passed to errorbar, most dimension\n        # checking and processing will be left to the errorbar method.\n        xerr = kwargs.pop('xerr', None)\n        yerr = kwargs.pop('yerr', None)\n        error_kw = kwargs.pop('error_kw', {})\n        ezorder = error_kw.pop('zorder', None)\n        if ezorder is None:\n            ezorder = kwargs.get('zorder', None)\n            if ezorder is not None:\n                # If using the bar zorder, increment slightly to make sure\n                # errorbars are drawn on top of bars\n                ezorder += 0.01\n        error_kw.setdefault('zorder', ezorder)\n        ecolor = kwargs.pop('ecolor', 'k')\n        capsize = kwargs.pop('capsize', rcParams[\"errorbar.capsize\"])\n        error_kw.setdefault('ecolor', ecolor)\n        error_kw.setdefault('capsize', capsize)\n\n        orientation = kwargs.pop('orientation', 'vertical')\n        cbook._check_in_list(['vertical', 'horizontal'],\n                             orientation=orientation)\n        log = kwargs.pop('log', False)\n        label = kwargs.pop('label', '')\n        tick_labels = kwargs.pop('tick_label', None)\n\n        y = bottom  # Matches barh call signature.\n        if orientation == 'vertical':\n            if y is None:\n                y = 0\n        elif orientation == 'horizontal':\n            if x is None:\n                x = 0\n\n        if orientation == 'vertical':\n            self._process_unit_info(xdata=x, ydata=height, kwargs=kwargs)\n            if log:\n                self.set_yscale('log', nonposy='clip')\n        elif orientation == 'horizontal':\n            self._process_unit_info(xdata=width, ydata=y, kwargs=kwargs)\n            if log:\n                self.set_xscale('log', nonposx='clip')\n\n        # lets do some conversions now since some types cannot be\n        # subtracted uniformly\n        if self.xaxis is not None:\n            x0 = x\n            x = np.asarray(self.convert_xunits(x))\n            width = self._convert_dx(width, x0, x, self.convert_xunits)\n            if xerr is not None:\n                xerr = self._convert_dx(xerr, x0, x, self.convert_xunits)\n        if self.yaxis is not None:\n            y0 = y\n            y = np.asarray(self.convert_yunits(y))\n            height = self._convert_dx(height, y0, y, self.convert_yunits)\n            if yerr is not None:\n                yerr = self._convert_dx(yerr, y0, y, self.convert_yunits)\n\n        x, height, width, y, linewidth = np.broadcast_arrays(\n            # Make args iterable too.\n            np.atleast_1d(x), height, width, y, linewidth)\n\n        # Now that units have been converted, set the tick locations.\n        if orientation == 'vertical':\n            tick_label_axis = self.xaxis\n            tick_label_position = x\n        elif orientation == 'horizontal':\n            tick_label_axis = self.yaxis\n            tick_label_position = y\n\n        linewidth = itertools.cycle(np.atleast_1d(linewidth))\n        color = itertools.chain(itertools.cycle(mcolors.to_rgba_array(color)),\n                                # Fallback if color == \"none\".\n                                itertools.repeat('none'))\n        if edgecolor is None:\n            edgecolor = itertools.repeat(None)\n        else:\n            edgecolor = itertools.chain(\n                itertools.cycle(mcolors.to_rgba_array(edgecolor)),\n                # Fallback if edgecolor == \"none\".\n                itertools.repeat('none'))\n\n        # We will now resolve the alignment and really have\n        # left, bottom, width, height vectors\n        cbook._check_in_list(['center', 'edge'], align=align)\n        if align == 'center':\n            if orientation == 'vertical':\n                try:\n                    left = x - width / 2\n                except TypeError as e:\n                    raise TypeError(f'the dtypes of parameters x ({x.dtype}) '\n                                    f'and width ({width.dtype}) '\n                                    f'are incompatible') from e\n                bottom = y\n            elif orientation == 'horizontal':\n                try:\n                    bottom = y - height / 2\n                except TypeError as e:\n                    raise TypeError(f'the dtypes of parameters y ({y.dtype}) '\n                                    f'and height ({height.dtype}) '\n                                    f'are incompatible') from e\n                left = x\n        elif align == 'edge':\n            left = x\n            bottom = y\n\n        patches = []\n        args = zip(left, bottom, width, height, color, edgecolor, linewidth)\n        for l, b, w, h, c, e, lw in args:\n            r = mpatches.Rectangle(\n                xy=(l, b), width=w, height=h,\n                facecolor=c,\n                edgecolor=e,\n                linewidth=lw,\n                label='_nolegend_',\n                )\n            r.update(kwargs)\n            r.get_path()._interpolation_steps = 100\n            if orientation == 'vertical':\n                r.sticky_edges.y.append(b)\n            elif orientation == 'horizontal':\n                r.sticky_edges.x.append(l)\n            self.add_patch(r)\n            patches.append(r)\n\n        if xerr is not None or yerr is not None:\n            if orientation == 'vertical':\n                # using list comps rather than arrays to preserve unit info\n                ex = [l + 0.5 * w for l, w in zip(left, width)]\n                ey = [b + h for b, h in zip(bottom, height)]\n\n            elif orientation == 'horizontal':\n                # using list comps rather than arrays to preserve unit info\n                ex = [l + w for l, w in zip(left, width)]\n                ey = [b + 0.5 * h for b, h in zip(bottom, height)]\n\n            error_kw.setdefault(\"label\", '_nolegend_')\n\n            errorbar = self.errorbar(ex, ey,\n                                     yerr=yerr, xerr=xerr,\n                                     fmt='none', **error_kw)\n        else:\n            errorbar = None\n\n        self._request_autoscale_view()\n\n        bar_container = BarContainer(patches, errorbar, label=label)\n        self.add_container(bar_container)\n\n        if tick_labels is not None:\n            tick_labels = np.broadcast_to(tick_labels, len(patches))\n            tick_label_axis.set_ticks(tick_label_position)\n            tick_label_axis.set_ticklabels(tick_labels)\n\n        return bar_container",
        "begin_line": 2166,
        "end_line": 2435,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018846588767433095,
            "pseudo_dstar_susp": 0.00021973192704900023,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00021973192704900023,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.broken_barh#2551",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.broken_barh(self, xranges, yrange, **kwargs)",
        "snippet": "    def broken_barh(self, xranges, yrange, **kwargs):\n        \"\"\"\n        Plot a horizontal sequence of rectangles.\n\n        A rectangle is drawn for each element of *xranges*. All rectangles\n        have the same vertical position and size defined by *yrange*.\n\n        This is a convenience function for instantiating a\n        `.BrokenBarHCollection`, adding it to the axes and autoscaling the\n        view.\n\n        Parameters\n        ----------\n        xranges : sequence of tuples (*xmin*, *xwidth*)\n            The x-positions and extends of the rectangles. For each tuple\n            (*xmin*, *xwidth*) a rectangle is drawn from *xmin* to *xmin* +\n            *xwidth*.\n        yrange : (*ymin*, *yheight*)\n            The y-position and extend for all the rectangles.\n\n        Other Parameters\n        ----------------\n        **kwargs : :class:`.BrokenBarHCollection` properties\n\n            Each *kwarg* can be either a single argument applying to all\n            rectangles, e.g.::\n\n                facecolors='black'\n\n            or a sequence of arguments over which is cycled, e.g.::\n\n                facecolors=('black', 'blue')\n\n            would create interleaving black and blue rectangles.\n\n            Supported keywords:\n\n            %(BrokenBarHCollection)s\n\n        Returns\n        -------\n        collection : A :class:`~.collections.BrokenBarHCollection`\n        \"\"\"\n        # process the unit information\n        if len(xranges):\n            xdata = cbook.safe_first_element(xranges)\n        else:\n            xdata = None\n        if len(yrange):\n            ydata = cbook.safe_first_element(yrange)\n        else:\n            ydata = None\n        self._process_unit_info(xdata=xdata,\n                                ydata=ydata,\n                                kwargs=kwargs)\n        xranges_conv = []\n        for xr in xranges:\n            if len(xr) != 2:\n                raise ValueError('each range in xrange must be a sequence '\n                                 'with two elements (i.e. an Nx2 array)')\n            # convert the absolute values, not the x and dx...\n            x_conv = np.asarray(self.convert_xunits(xr[0]))\n            x1 = self._convert_dx(xr[1], xr[0], x_conv, self.convert_xunits)\n            xranges_conv.append((x_conv, x1))\n\n        yrange_conv = self.convert_yunits(yrange)\n\n        col = mcoll.BrokenBarHCollection(xranges_conv, yrange_conv, **kwargs)\n        self.add_collection(col, autolim=True)\n        self._request_autoscale_view()\n\n        return col",
        "begin_line": 2551,
        "end_line": 2622,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.stem#2625",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.stem(self, *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0, label=None, use_line_collection=False)",
        "snippet": "    def stem(self, *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0,\n             label=None, use_line_collection=False):\n        \"\"\"\n        Create a stem plot.\n\n        A stem plot plots vertical lines at each *x* location from the baseline\n        to *y*, and places a marker there.\n\n        Call signature::\n\n          stem([x,] y, linefmt=None, markerfmt=None, basefmt=None)\n\n        The x-positions are optional. The formats may be provided either as\n        positional or as keyword-arguments.\n\n        Parameters\n        ----------\n        x : array-like, optional\n            The x-positions of the stems. Default: (0, 1, ..., len(y) - 1).\n\n        y : array-like\n            The y-values of the stem heads.\n\n        linefmt : str, optional\n            A string defining the properties of the vertical lines. Usually,\n            this will be a color or a color and a linestyle:\n\n            =========  =============\n            Character  Line Style\n            =========  =============\n            ``'-'``    solid line\n            ``'--'``   dashed line\n            ``'-.'``   dash-dot line\n            ``':'``    dotted line\n            =========  =============\n\n            Default: 'C0-', i.e. solid line with the first color of the color\n            cycle.\n\n            Note: While it is technically possible to specify valid formats\n            other than color or color and linestyle (e.g. 'rx' or '-.'), this\n            is beyond the intention of the method and will most likely not\n            result in a reasonable reasonable plot.\n\n        markerfmt : str, optional\n            A string defining the properties of the markers at the stem heads.\n            Default: 'C0o', i.e. filled circles with the first color of the\n            color cycle.\n\n        basefmt : str, optional\n            A format string defining the properties of the baseline.\n\n            Default: 'C3-' ('C2-' in classic mode).\n\n        bottom : float, optional, default: 0\n            The y-position of the baseline.\n\n        label : str, optional, default: None\n            The label to use for the stems in legends.\n\n        use_line_collection : bool, optional, default: False\n            If ``True``, store and plot the stem lines as a\n            `~.collections.LineCollection` instead of individual lines. This\n            significantly increases performance, and will become the default\n            option in Matplotlib 3.3. If ``False``, defaults to the old\n            behavior of using a list of `.Line2D` objects.\n\n\n        Returns\n        -------\n        container : :class:`~matplotlib.container.StemContainer`\n            The container may be treated like a tuple\n            (*markerline*, *stemlines*, *baseline*)\n\n\n        Notes\n        -----\n        .. seealso::\n            The MATLAB function\n            `stem <http://www.mathworks.com/help/techdoc/ref/stem.html>`_\n            which inspired this method.\n\n        \"\"\"\n        if not 1 <= len(args) <= 5:\n            raise TypeError('stem expected between 1 and 5 positional '\n                            'arguments, got {}'.format(args))\n\n        if len(args) == 1:\n            y, = args\n            x = np.arange(len(y))\n            args = ()\n        else:\n            x, y, *args = args\n\n        self._process_unit_info(xdata=x, ydata=y)\n        x = self.convert_xunits(x)\n        y = self.convert_yunits(y)\n\n        # defaults for formats\n        if linefmt is None:\n            try:\n                # fallback to positional argument\n                linefmt = args[0]\n            except IndexError:\n                linecolor = 'C0'\n                linemarker = 'None'\n                linestyle = '-'\n            else:\n                linestyle, linemarker, linecolor = \\\n                    _process_plot_format(linefmt)\n        else:\n            linestyle, linemarker, linecolor = _process_plot_format(linefmt)\n\n        if markerfmt is None:\n            try:\n                # fallback to positional argument\n                markerfmt = args[1]\n            except IndexError:\n                markercolor = 'C0'\n                markermarker = 'o'\n                markerstyle = 'None'\n            else:\n                markerstyle, markermarker, markercolor = \\\n                    _process_plot_format(markerfmt)\n        else:\n            markerstyle, markermarker, markercolor = \\\n                _process_plot_format(markerfmt)\n\n        if basefmt is None:\n            try:\n                # fallback to positional argument\n                basefmt = args[2]\n            except IndexError:\n                if rcParams['_internal.classic_mode']:\n                    basecolor = 'C2'\n                else:\n                    basecolor = 'C3'\n                basemarker = 'None'\n                basestyle = '-'\n            else:\n                basestyle, basemarker, basecolor = \\\n                    _process_plot_format(basefmt)\n        else:\n            basestyle, basemarker, basecolor = _process_plot_format(basefmt)\n\n        # New behaviour in 3.1 is to use a LineCollection for the stemlines\n        if use_line_collection:\n            stemlines = [((xi, bottom), (xi, yi)) for xi, yi in zip(x, y)]\n            if linestyle is None:\n                linestyle = rcParams['lines.linestyle']\n            stemlines = mcoll.LineCollection(stemlines, linestyles=linestyle,\n                                             colors=linecolor,\n                                             label='_nolegend_')\n            self.add_collection(stemlines)\n        # Old behaviour is to plot each of the lines individually\n        else:\n            cbook._warn_external(\n                'In Matplotlib 3.3 individual lines on a stem plot will be '\n                'added as a LineCollection instead of individual lines. '\n                'This significantly improves the performance of a stem plot. '\n                'To remove this warning and switch to the new behaviour, '\n                'set the \"use_line_collection\" keyword argument to True.')\n            stemlines = []\n            for xi, yi in zip(x, y):\n                l, = self.plot([xi, xi], [bottom, yi],\n                               color=linecolor, linestyle=linestyle,\n                               marker=linemarker, label=\"_nolegend_\")\n                stemlines.append(l)\n\n        markerline, = self.plot(x, y, color=markercolor, linestyle=markerstyle,\n                                marker=markermarker, label=\"_nolegend_\")\n\n        baseline, = self.plot([np.min(x), np.max(x)], [bottom, bottom],\n                              color=basecolor, linestyle=basestyle,\n                              marker=basemarker, label=\"_nolegend_\")\n\n        stem_container = StemContainer((markerline, stemlines, baseline),\n                                       label=label)\n        self.add_container(stem_container)\n        return stem_container",
        "begin_line": 2625,
        "end_line": 2804,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.pie#2807",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.pie(self, x, explode=None, labels=None, colors=None, autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1, startangle=None, radius=None, counterclock=True, wedgeprops=None, textprops=None, center=(0, 0), frame=False, rotatelabels=False)",
        "snippet": "    def pie(self, x, explode=None, labels=None, colors=None,\n            autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1,\n            startangle=None, radius=None, counterclock=True,\n            wedgeprops=None, textprops=None, center=(0, 0),\n            frame=False, rotatelabels=False):\n        \"\"\"\n        Plot a pie chart.\n\n        Make a pie chart of array *x*.  The fractional area of each wedge is\n        given by ``x/sum(x)``.  If ``sum(x) < 1``, then the values of *x* give\n        the fractional area directly and the array will not be normalized. The\n        resulting pie will have an empty wedge of size ``1 - sum(x)``.\n\n        The wedges are plotted counterclockwise, by default starting from the\n        x-axis.\n\n        Parameters\n        ----------\n        x : array-like\n            The wedge sizes.\n\n        explode : array-like, optional, default: None\n            If not *None*, is a ``len(x)`` array which specifies the fraction\n            of the radius with which to offset each wedge.\n\n        labels : list, optional, default: None\n            A sequence of strings providing the labels for each wedge\n\n        colors : array-like, optional, default: None\n            A sequence of matplotlib color args through which the pie chart\n            will cycle.  If *None*, will use the colors in the currently\n            active cycle.\n\n        autopct : None (default), str, or function, optional\n            If not *None*, is a string or function used to label the wedges\n            with their numeric value.  The label will be placed inside the\n            wedge.  If it is a format string, the label will be ``fmt%pct``.\n            If it is a function, it will be called.\n\n        pctdistance : float, optional, default: 0.6\n            The ratio between the center of each pie slice and the start of\n            the text generated by *autopct*.  Ignored if *autopct* is *None*.\n\n        shadow : bool, optional, default: False\n            Draw a shadow beneath the pie.\n\n        labeldistance : float or None, optional, default: 1.1\n            The radial distance at which the pie labels are drawn.\n            If set to ``None``, label are not drawn, but are stored for use in\n            ``legend()``\n\n        startangle : float, optional, default: None\n            If not *None*, rotates the start of the pie chart by *angle*\n            degrees counterclockwise from the x-axis.\n\n        radius : float, optional, default: None\n            The radius of the pie, if *radius* is *None* it will be set to 1.\n\n        counterclock : bool, optional, default: True\n            Specify fractions direction, clockwise or counterclockwise.\n\n        wedgeprops : dict, optional, default: None\n            Dict of arguments passed to the wedge objects making the pie.\n            For example, you can pass in ``wedgeprops = {'linewidth': 3}``\n            to set the width of the wedge border lines equal to 3.\n            For more details, look at the doc/arguments of the wedge object.\n            By default ``clip_on=False``.\n\n        textprops : dict, optional, default: None\n            Dict of arguments to pass to the text objects.\n\n        center :  list of float, optional, default: (0, 0)\n            Center position of the chart. Takes value (0, 0) or is a sequence\n            of 2 scalars.\n\n        frame : bool, optional, default: False\n            Plot axes frame with the chart if true.\n\n        rotatelabels : bool, optional, default: False\n            Rotate each label to the angle of the corresponding slice if true.\n\n        Returns\n        -------\n        patches : list\n            A sequence of :class:`matplotlib.patches.Wedge` instances\n\n        texts : list\n            A list of the label :class:`matplotlib.text.Text` instances.\n\n        autotexts : list\n            A list of :class:`~matplotlib.text.Text` instances for the numeric\n            labels. This will only be returned if the parameter *autopct* is\n            not *None*.\n\n        Notes\n        -----\n        The pie chart will probably look best if the figure and axes are\n        square, or the Axes aspect is equal.\n        This method sets the aspect ratio of the axis to \"equal\".\n        The axes aspect ratio can be controlled with `Axes.set_aspect`.\n        \"\"\"\n        self.set_aspect('equal')\n        # The use of float32 is \"historical\", but can't be changed without\n        # regenerating the test baselines.\n        x = np.asarray(x, np.float32)\n        if x.ndim != 1 and x.squeeze().ndim <= 1:\n            cbook.warn_deprecated(\n                \"3.1\", message=\"Non-1D inputs to pie() are currently \"\n                \"squeeze()d, but this behavior is deprecated since %(since)s \"\n                \"and will be removed %(removal)s; pass a 1D array instead.\")\n            x = np.atleast_1d(x.squeeze())\n\n        sx = x.sum()\n        if sx > 1:\n            x = x / sx\n\n        if labels is None:\n            labels = [''] * len(x)\n        if explode is None:\n            explode = [0] * len(x)\n        if len(x) != len(labels):\n            raise ValueError(\"'label' must be of length 'x'\")\n        if len(x) != len(explode):\n            raise ValueError(\"'explode' must be of length 'x'\")\n        if colors is None:\n            get_next_color = self._get_patches_for_fill.get_next_color\n        else:\n            color_cycle = itertools.cycle(colors)\n\n            def get_next_color():\n                return next(color_cycle)\n\n        if radius is None:\n            radius = 1\n\n        # Starting theta1 is the start fraction of the circle\n        if startangle is None:\n            theta1 = 0\n        else:\n            theta1 = startangle / 360.0\n\n        # set default values in wedge_prop\n        if wedgeprops is None:\n            wedgeprops = {}\n        wedgeprops.setdefault('clip_on', False)\n\n        if textprops is None:\n            textprops = {}\n        textprops.setdefault('clip_on', False)\n\n        texts = []\n        slices = []\n        autotexts = []\n\n        for frac, label, expl in zip(x, labels, explode):\n            x, y = center\n            theta2 = (theta1 + frac) if counterclock else (theta1 - frac)\n            thetam = 2 * np.pi * 0.5 * (theta1 + theta2)\n            x += expl * math.cos(thetam)\n            y += expl * math.sin(thetam)\n\n            w = mpatches.Wedge((x, y), radius, 360. * min(theta1, theta2),\n                               360. * max(theta1, theta2),\n                               facecolor=get_next_color(),\n                               **wedgeprops)\n            slices.append(w)\n            self.add_patch(w)\n            w.set_label(label)\n\n            if shadow:\n                # make sure to add a shadow after the call to\n                # add_patch so the figure and transform props will be\n                # set\n                shad = mpatches.Shadow(w, -0.02, -0.02)\n                shad.set_zorder(0.9 * w.get_zorder())\n                shad.set_label('_nolegend_')\n                self.add_patch(shad)\n\n            if labeldistance is not None:\n                xt = x + labeldistance * radius * math.cos(thetam)\n                yt = y + labeldistance * radius * math.sin(thetam)\n                label_alignment_h = 'left' if xt > 0 else 'right'\n                label_alignment_v = 'center'\n                label_rotation = 'horizontal'\n                if rotatelabels:\n                    label_alignment_v = 'bottom' if yt > 0 else 'top'\n                    label_rotation = (np.rad2deg(thetam)\n                                      + (0 if xt > 0 else 180))\n                props = dict(horizontalalignment=label_alignment_h,\n                             verticalalignment=label_alignment_v,\n                             rotation=label_rotation,\n                             size=rcParams['xtick.labelsize'])\n                props.update(textprops)\n\n                t = self.text(xt, yt, label, **props)\n\n                texts.append(t)\n\n            if autopct is not None:\n                xt = x + pctdistance * radius * math.cos(thetam)\n                yt = y + pctdistance * radius * math.sin(thetam)\n                if isinstance(autopct, str):\n                    s = autopct % (100. * frac)\n                elif callable(autopct):\n                    s = autopct(100. * frac)\n                else:\n                    raise TypeError(\n                        'autopct must be callable or a format string')\n\n                props = dict(horizontalalignment='center',\n                             verticalalignment='center')\n                props.update(textprops)\n                t = self.text(xt, yt, s, **props)\n\n                autotexts.append(t)\n\n            theta1 = theta2\n\n        if not frame:\n            self.set_frame_on(False)\n\n            self.set_xlim((-1.25 + center[0],\n                           1.25 + center[0]))\n            self.set_ylim((-1.25 + center[1],\n                           1.25 + center[1]))\n            self.set_xticks([])\n            self.set_yticks([])\n\n        if autopct is None:\n            return slices, texts\n        else:\n            return slices, texts, autotexts",
        "begin_line": 2807,
        "end_line": 3038,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022993791676247414,
            "pseudo_dstar_susp": 0.00019372336303758234,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00019372336303758234,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.errorbar#3043",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.errorbar(self, x, y, yerr=None, xerr=None, fmt='', ecolor=None, elinewidth=None, capsize=None, barsabove=False, lolims=False, uplims=False, xlolims=False, xuplims=False, errorevery=1, capthick=None, **kwargs)",
        "snippet": "    def errorbar(self, x, y, yerr=None, xerr=None,\n                 fmt='', ecolor=None, elinewidth=None, capsize=None,\n                 barsabove=False, lolims=False, uplims=False,\n                 xlolims=False, xuplims=False, errorevery=1, capthick=None,\n                 **kwargs):\n        \"\"\"\n        Plot y versus x as lines and/or markers with attached errorbars.\n\n        *x*, *y* define the data locations, *xerr*, *yerr* define the errorbar\n        sizes. By default, this draws the data markers/lines as well the\n        errorbars. Use fmt='none' to draw errorbars without any data markers.\n\n        Parameters\n        ----------\n        x, y : scalar or array-like\n            The data positions.\n\n        xerr, yerr : scalar or array-like, shape(N,) or shape(2, N), optional\n            The errorbar sizes:\n\n            - scalar: Symmetric +/- values for all data points.\n            - shape(N,): Symmetric +/-values for each data point.\n            - shape(2, N): Separate - and + values for each bar. First row\n              contains the lower errors, the second row contains the upper\n              errors.\n            - *None*: No errorbar.\n\n            Note that all error arrays should have *positive* values.\n\n            See :doc:`/gallery/statistics/errorbar_features`\n            for an example on the usage of ``xerr`` and ``yerr``.\n\n        fmt : str, optional, default: ''\n            The format for the data points / data lines. See `.plot` for\n            details.\n\n            Use 'none' (case insensitive) to plot errorbars without any data\n            markers.\n\n        ecolor : color, optional, default: None\n            The color of the errorbar lines.  If None, use the color of the\n            line connecting the markers.\n\n        elinewidth : scalar, optional, default: None\n            The linewidth of the errorbar lines. If None, the linewidth of\n            the current style is used.\n\n        capsize : scalar, optional, default: None\n            The length of the error bar caps in points. If None, it will take\n            the value from :rc:`errorbar.capsize`.\n\n        capthick : scalar, optional, default: None\n            An alias to the keyword argument *markeredgewidth* (a.k.a. *mew*).\n            This setting is a more sensible name for the property that\n            controls the thickness of the error bar cap in points. For\n            backwards compatibility, if *mew* or *markeredgewidth* are given,\n            then they will over-ride *capthick*. This may change in future\n            releases.\n\n        barsabove : bool, optional, default: False\n            If True, will plot the errorbars above the plot\n            symbols. Default is below.\n\n        lolims, uplims, xlolims, xuplims : bool, optional, default: False\n            These arguments can be used to indicate that a value gives only\n            upper/lower limits. In that case a caret symbol is used to\n            indicate this. *lims*-arguments may be of the same type as *xerr*\n            and *yerr*.  To use limits with inverted axes, :meth:`set_xlim`\n            or :meth:`set_ylim` must be called before :meth:`errorbar`.\n\n        errorevery : int or (int, int), optional, default: 1\n            draws error bars on a subset of the data. *errorevery* =N draws\n            error bars on the points (x[::N], y[::N]).\n            *errorevery* =(start, N) draws error bars on the points\n            (x[start::N], y[start::N]). e.g. errorevery=(6, 3)\n            adds error bars to the data at (x[6], x[9], x[12], x[15], ...).\n            Used to avoid overlapping error bars when two series share x-axis\n            values.\n\n        Returns\n        -------\n        container : :class:`~.container.ErrorbarContainer`\n            The container contains:\n\n            - plotline: `.Line2D` instance of x, y plot markers and/or line.\n            - caplines: A tuple of `.Line2D` instances of the error bar caps.\n            - barlinecols: A tuple of\n              :class:`~matplotlib.collections.LineCollection` with the\n              horizontal and vertical error ranges.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            All other keyword arguments are passed on to the plot\n            command for the markers. For example, this code makes big red\n            squares with thick green edges::\n\n                x, y, yerr = rand(3, 10)\n                errorbar(x, y, yerr, marker='s', mfc='red',\n                         mec='green', ms=20, mew=4)\n\n            where *mfc*, *mec*, *ms* and *mew* are aliases for the longer\n            property names, *markerfacecolor*, *markeredgecolor*, *markersize*\n            and *markeredgewidth*.\n\n            Valid kwargs for the marker properties are `.Lines2D` properties:\n\n            %(_Line2D_docstr)s\n        \"\"\"\n        kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)\n        # anything that comes in as 'None', drop so the default thing\n        # happens down stream\n        kwargs = {k: v for k, v in kwargs.items() if v is not None}\n        kwargs.setdefault('zorder', 2)\n\n        try:\n            offset, errorevery = errorevery\n        except TypeError:\n            offset = 0\n\n        if errorevery < 1 or int(errorevery) != errorevery:\n            raise ValueError(\n                'errorevery must be positive integer or tuple of integers')\n        if int(offset) != offset:\n            raise ValueError(\"errorevery's starting index must be an integer\")\n\n        self._process_unit_info(xdata=x, ydata=y, kwargs=kwargs)\n\n        plot_line = (fmt.lower() != 'none')\n        label = kwargs.pop(\"label\", None)\n\n        if fmt == '':\n            fmt_style_kwargs = {}\n        else:\n            fmt_style_kwargs = {k: v for k, v in\n                                zip(('linestyle', 'marker', 'color'),\n                                    _process_plot_format(fmt))\n                                if v is not None}\n        if fmt == 'none':\n            # Remove alpha=0 color that _process_plot_format returns\n            fmt_style_kwargs.pop('color')\n\n        if ('color' in kwargs or 'color' in fmt_style_kwargs or\n                ecolor is not None):\n            base_style = {}\n            if 'color' in kwargs:\n                base_style['color'] = kwargs.pop('color')\n        else:\n            base_style = next(self._get_lines.prop_cycler)\n\n        base_style['label'] = '_nolegend_'\n        base_style.update(fmt_style_kwargs)\n        if 'color' not in base_style:\n            base_style['color'] = 'C0'\n        if ecolor is None:\n            ecolor = base_style['color']\n        # make sure all the args are iterable; use lists not arrays to\n        # preserve units\n        if not np.iterable(x):\n            x = [x]\n\n        if not np.iterable(y):\n            y = [y]\n\n        if xerr is not None:\n            if not np.iterable(xerr):\n                xerr = [xerr] * len(x)\n\n        if yerr is not None:\n            if not np.iterable(yerr):\n                yerr = [yerr] * len(y)\n\n        # make the style dict for the 'normal' plot line\n        plot_line_style = {\n            **base_style,\n            **kwargs,\n            'zorder': (kwargs['zorder'] - .1 if barsabove else\n                       kwargs['zorder'] + .1),\n        }\n\n        # make the style dict for the line collections (the bars)\n        eb_lines_style = dict(base_style)\n        eb_lines_style.pop('marker', None)\n        eb_lines_style.pop('linestyle', None)\n        eb_lines_style['color'] = ecolor\n\n        if elinewidth:\n            eb_lines_style['linewidth'] = elinewidth\n        elif 'linewidth' in kwargs:\n            eb_lines_style['linewidth'] = kwargs['linewidth']\n\n        for key in ('transform', 'alpha', 'zorder', 'rasterized'):\n            if key in kwargs:\n                eb_lines_style[key] = kwargs[key]\n\n        # set up cap style dictionary\n        eb_cap_style = dict(base_style)\n        # eject any marker information from format string\n        eb_cap_style.pop('marker', None)\n        eb_lines_style.pop('markerfacecolor', None)\n        eb_lines_style.pop('markeredgewidth', None)\n        eb_lines_style.pop('markeredgecolor', None)\n        eb_cap_style.pop('ls', None)\n        eb_cap_style['linestyle'] = 'none'\n        if capsize is None:\n            capsize = rcParams[\"errorbar.capsize\"]\n        if capsize > 0:\n            eb_cap_style['markersize'] = 2. * capsize\n        if capthick is not None:\n            eb_cap_style['markeredgewidth'] = capthick\n\n        # For backwards-compat, allow explicit setting of\n        # 'markeredgewidth' to over-ride capthick.\n        for key in ('markeredgewidth', 'transform', 'alpha',\n                    'zorder', 'rasterized'):\n            if key in kwargs:\n                eb_cap_style[key] = kwargs[key]\n        eb_cap_style['color'] = ecolor\n\n        data_line = None\n        if plot_line:\n            data_line = mlines.Line2D(x, y, **plot_line_style)\n            self.add_line(data_line)\n\n        barcols = []\n        caplines = []\n\n        # arrays fine here, they are booleans and hence not units\n        lolims = np.broadcast_to(lolims, len(x)).astype(bool)\n        uplims = np.broadcast_to(uplims, len(x)).astype(bool)\n        xlolims = np.broadcast_to(xlolims, len(x)).astype(bool)\n        xuplims = np.broadcast_to(xuplims, len(x)).astype(bool)\n\n        everymask = np.zeros(len(x), bool)\n        everymask[offset::errorevery] = True\n\n        def xywhere(xs, ys, mask):\n            \"\"\"\n            return xs[mask], ys[mask] where mask is True but xs and\n            ys are not arrays\n            \"\"\"\n            assert len(xs) == len(ys)\n            assert len(xs) == len(mask)\n            xs = [thisx for thisx, b in zip(xs, mask) if b]\n            ys = [thisy for thisy, b in zip(ys, mask) if b]\n            return xs, ys\n\n        def extract_err(err, data):\n            \"\"\"\n            Private function to parse *err* and subtract/add it to *data*.\n\n            Both *err* and *data* are already iterables at this point.\n            \"\"\"\n            try:  # Asymmetric error: pair of 1D iterables.\n                a, b = err\n                iter(a)\n                iter(b)\n            except (TypeError, ValueError):\n                a = b = err  # Symmetric error: 1D iterable.\n            # This could just be `np.ndim(a) > 1 and np.ndim(b) > 1`, except\n            # for the (undocumented, but tested) support for (n, 1) arrays.\n            a_sh = np.shape(a)\n            b_sh = np.shape(b)\n            if (len(a_sh) > 2 or (len(a_sh) == 2 and a_sh[1] != 1)\n                    or len(b_sh) > 2 or (len(b_sh) == 2 and b_sh[1] != 1)):\n                raise ValueError(\n                    \"err must be a scalar or a 1D or (2, n) array-like\")\n            if len(a_sh) == 2 or len(b_sh) == 2:\n                cbook.warn_deprecated(\n                    \"3.1\", message=\"Support for passing a (n, 1)-shaped error \"\n                    \"array to errorbar() is deprecated since Matplotlib \"\n                    \"%(since)s and will be removed %(removal)s; pass a 1D \"\n                    \"array instead.\")\n            # Using list comprehensions rather than arrays to preserve units.\n            for e in [a, b]:\n                if len(data) != len(e):\n                    raise ValueError(\n                        f\"The lengths of the data ({len(data)}) and the \"\n                        f\"error {len(e)} do not match\")\n            low = [v - e for v, e in zip(data, a)]\n            high = [v + e for v, e in zip(data, b)]\n            return low, high\n\n        if xerr is not None:\n            left, right = extract_err(xerr, x)\n            # select points without upper/lower limits in x and\n            # draw normal errorbars for these points\n            noxlims = ~(xlolims | xuplims)\n            if noxlims.any() or len(noxlims) == 0:\n                yo, _ = xywhere(y, right, noxlims & everymask)\n                lo, ro = xywhere(left, right, noxlims & everymask)\n                barcols.append(self.hlines(yo, lo, ro, **eb_lines_style))\n                if capsize > 0:\n                    caplines.append(mlines.Line2D(lo, yo, marker='|',\n                                                  **eb_cap_style))\n                    caplines.append(mlines.Line2D(ro, yo, marker='|',\n                                                  **eb_cap_style))\n\n            if xlolims.any():\n                yo, _ = xywhere(y, right, xlolims & everymask)\n                lo, ro = xywhere(x, right, xlolims & everymask)\n                barcols.append(self.hlines(yo, lo, ro, **eb_lines_style))\n                rightup, yup = xywhere(right, y, xlolims & everymask)\n                if self.xaxis_inverted():\n                    marker = mlines.CARETLEFTBASE\n                else:\n                    marker = mlines.CARETRIGHTBASE\n                caplines.append(\n                    mlines.Line2D(rightup, yup, ls='None', marker=marker,\n                                  **eb_cap_style))\n                if capsize > 0:\n                    xlo, ylo = xywhere(x, y, xlolims & everymask)\n                    caplines.append(mlines.Line2D(xlo, ylo, marker='|',\n                                                  **eb_cap_style))\n\n            if xuplims.any():\n                yo, _ = xywhere(y, right, xuplims & everymask)\n                lo, ro = xywhere(left, x, xuplims & everymask)\n                barcols.append(self.hlines(yo, lo, ro, **eb_lines_style))\n                leftlo, ylo = xywhere(left, y, xuplims & everymask)\n                if self.xaxis_inverted():\n                    marker = mlines.CARETRIGHTBASE\n                else:\n                    marker = mlines.CARETLEFTBASE\n                caplines.append(\n                    mlines.Line2D(leftlo, ylo, ls='None', marker=marker,\n                                  **eb_cap_style))\n                if capsize > 0:\n                    xup, yup = xywhere(x, y, xuplims & everymask)\n                    caplines.append(mlines.Line2D(xup, yup, marker='|',\n                                                  **eb_cap_style))\n\n        if yerr is not None:\n            lower, upper = extract_err(yerr, y)\n            # select points without upper/lower limits in y and\n            # draw normal errorbars for these points\n            noylims = ~(lolims | uplims)\n            if noylims.any() or len(noylims) == 0:\n                xo, _ = xywhere(x, lower, noylims & everymask)\n                lo, uo = xywhere(lower, upper, noylims & everymask)\n                barcols.append(self.vlines(xo, lo, uo, **eb_lines_style))\n                if capsize > 0:\n                    caplines.append(mlines.Line2D(xo, lo, marker='_',\n                                                  **eb_cap_style))\n                    caplines.append(mlines.Line2D(xo, uo, marker='_',\n                                                  **eb_cap_style))\n\n            if lolims.any():\n                xo, _ = xywhere(x, lower, lolims & everymask)\n                lo, uo = xywhere(y, upper, lolims & everymask)\n                barcols.append(self.vlines(xo, lo, uo, **eb_lines_style))\n                xup, upperup = xywhere(x, upper, lolims & everymask)\n                if self.yaxis_inverted():\n                    marker = mlines.CARETDOWNBASE\n                else:\n                    marker = mlines.CARETUPBASE\n                caplines.append(\n                    mlines.Line2D(xup, upperup, ls='None', marker=marker,\n                                  **eb_cap_style))\n                if capsize > 0:\n                    xlo, ylo = xywhere(x, y, lolims & everymask)\n                    caplines.append(mlines.Line2D(xlo, ylo, marker='_',\n                                                  **eb_cap_style))\n\n            if uplims.any():\n                xo, _ = xywhere(x, lower, uplims & everymask)\n                lo, uo = xywhere(lower, y, uplims & everymask)\n                barcols.append(self.vlines(xo, lo, uo, **eb_lines_style))\n                xlo, lowerlo = xywhere(x, lower, uplims & everymask)\n                if self.yaxis_inverted():\n                    marker = mlines.CARETUPBASE\n                else:\n                    marker = mlines.CARETDOWNBASE\n                caplines.append(\n                    mlines.Line2D(xlo, lowerlo, ls='None', marker=marker,\n                                  **eb_cap_style))\n                if capsize > 0:\n                    xup, yup = xywhere(x, y, uplims & everymask)\n                    caplines.append(mlines.Line2D(xup, yup, marker='_',\n                                                  **eb_cap_style))\n        for l in caplines:\n            self.add_line(l)\n\n        self._request_autoscale_view()\n        errorbar_container = ErrorbarContainer((data_line, tuple(caplines),\n                                                tuple(barcols)),\n                                               has_xerr=(xerr is not None),\n                                               has_yerr=(yerr is not None),\n                                               label=label)\n        self.containers.append(errorbar_container)\n\n        return errorbar_container  # (l0, caplines, barcols)",
        "begin_line": 3043,
        "end_line": 3434,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016315875346712352,
            "pseudo_dstar_susp": 0.00016625103906899418,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00016625103906899418,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.xywhere#3279",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.xywhere(xs, ys, mask)",
        "snippet": "        def xywhere(xs, ys, mask):\n            \"\"\"\n            return xs[mask], ys[mask] where mask is True but xs and\n            ys are not arrays\n            \"\"\"\n            assert len(xs) == len(ys)\n            assert len(xs) == len(mask)\n            xs = [thisx for thisx, b in zip(xs, mask) if b]\n            ys = [thisy for thisy, b in zip(ys, mask) if b]\n            return xs, ys",
        "begin_line": 3279,
        "end_line": 3288,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016315875346712352,
            "pseudo_dstar_susp": 0.00016597510373443983,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00016597510373443983,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.extract_err#3290",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.extract_err(err, data)",
        "snippet": "        def extract_err(err, data):\n            \"\"\"\n            Private function to parse *err* and subtract/add it to *data*.\n\n            Both *err* and *data* are already iterables at this point.\n            \"\"\"\n            try:  # Asymmetric error: pair of 1D iterables.\n                a, b = err\n                iter(a)\n                iter(b)\n            except (TypeError, ValueError):\n                a = b = err  # Symmetric error: 1D iterable.\n            # This could just be `np.ndim(a) > 1 and np.ndim(b) > 1`, except\n            # for the (undocumented, but tested) support for (n, 1) arrays.\n            a_sh = np.shape(a)\n            b_sh = np.shape(b)\n            if (len(a_sh) > 2 or (len(a_sh) == 2 and a_sh[1] != 1)\n                    or len(b_sh) > 2 or (len(b_sh) == 2 and b_sh[1] != 1)):\n                raise ValueError(\n                    \"err must be a scalar or a 1D or (2, n) array-like\")\n            if len(a_sh) == 2 or len(b_sh) == 2:\n                cbook.warn_deprecated(\n                    \"3.1\", message=\"Support for passing a (n, 1)-shaped error \"\n                    \"array to errorbar() is deprecated since Matplotlib \"\n                    \"%(since)s and will be removed %(removal)s; pass a 1D \"\n                    \"array instead.\")\n            # Using list comprehensions rather than arrays to preserve units.\n            for e in [a, b]:\n                if len(data) != len(e):\n                    raise ValueError(\n                        f\"The lengths of the data ({len(data)}) and the \"\n                        f\"error {len(e)} do not match\")\n            low = [v - e for v, e in zip(data, a)]\n            high = [v + e for v, e in zip(data, b)]\n            return low, high",
        "begin_line": 3290,
        "end_line": 3324,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016315875346712352,
            "pseudo_dstar_susp": 0.00016611295681063124,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00016611295681063124,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.boxplot#3438",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.boxplot(self, x, notch=None, sym=None, vert=None, whis=None, positions=None, widths=None, patch_artist=None, bootstrap=None, usermedians=None, conf_intervals=None, meanline=None, showmeans=None, showcaps=None, showbox=None, showfliers=None, boxprops=None, labels=None, flierprops=None, medianprops=None, meanprops=None, capprops=None, whiskerprops=None, manage_ticks=True, autorange=False, zorder=None)",
        "snippet": "    def boxplot(self, x, notch=None, sym=None, vert=None, whis=None,\n                positions=None, widths=None, patch_artist=None,\n                bootstrap=None, usermedians=None, conf_intervals=None,\n                meanline=None, showmeans=None, showcaps=None,\n                showbox=None, showfliers=None, boxprops=None,\n                labels=None, flierprops=None, medianprops=None,\n                meanprops=None, capprops=None, whiskerprops=None,\n                manage_ticks=True, autorange=False, zorder=None):\n        \"\"\"\n        Make a box and whisker plot.\n\n        Make a box and whisker plot for each column of ``x`` or each\n        vector in sequence ``x``.  The box extends from the lower to\n        upper quartile values of the data, with a line at the median.\n        The whiskers extend from the box to show the range of the\n        data.  Flier points are those past the end of the whiskers.\n\n        Parameters\n        ----------\n        x : Array or a sequence of vectors.\n            The input data.\n\n        notch : bool, optional (False)\n            If `True`, will produce a notched box plot. Otherwise, a\n            rectangular boxplot is produced. The notches represent the\n            confidence interval (CI) around the median. See the entry\n            for the ``bootstrap`` parameter for information regarding\n            how the locations of the notches are computed.\n\n            .. note::\n\n                In cases where the values of the CI are less than the\n                lower quartile or greater than the upper quartile, the\n                notches will extend beyond the box, giving it a\n                distinctive \"flipped\" appearance. This is expected\n                behavior and consistent with other statistical\n                visualization packages.\n\n        sym : str, optional\n            The default symbol for flier points. Enter an empty string\n            ('') if you don't want to show fliers. If `None`, then the\n            fliers default to 'b+'  If you want more control use the\n            flierprops kwarg.\n\n        vert : bool, optional (True)\n            If `True` (default), makes the boxes vertical. If `False`,\n            everything is drawn horizontally.\n\n        whis : float or (float, float) (default = 1.5)\n            The position of the whiskers.\n\n            If a float, the lower whisker is at the lowest datum above\n            ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum\n            below ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and\n            third quartiles.  The default value of ``whis = 1.5`` corresponds\n            to Tukey's original definition of boxplots.\n\n            If a pair of floats, they indicate the percentiles at which to\n            draw the whiskers (e.g., (5, 95)).  In particular, setting this to\n            (0, 100) results in whiskers covering the whole range of the data.\n            \"range\" is a deprecated synonym for (0, 100).\n\n            In the edge case where ``Q1 == Q3``, *whis* is automatically set\n            to (0, 100) (cover the whole range of the data) if *autorange* is\n            True.\n\n            Beyond the whiskers, data are considered outliers and are plotted\n            as individual points.\n\n        bootstrap : int, optional\n            Specifies whether to bootstrap the confidence intervals\n            around the median for notched boxplots. If ``bootstrap`` is\n            None, no bootstrapping is performed, and notches are\n            calculated using a Gaussian-based asymptotic approximation\n            (see McGill, R., Tukey, J.W., and Larsen, W.A., 1978, and\n            Kendall and Stuart, 1967). Otherwise, bootstrap specifies\n            the number of times to bootstrap the median to determine its\n            95% confidence intervals. Values between 1000 and 10000 are\n            recommended.\n\n        usermedians : array-like, optional\n            An array or sequence whose first dimension (or length) is\n            compatible with ``x``. This overrides the medians computed\n            by matplotlib for each element of ``usermedians`` that is not\n            `None`. When an element of ``usermedians`` is None, the median\n            will be computed by matplotlib as normal.\n\n        conf_intervals : array-like, optional\n            Array or sequence whose first dimension (or length) is\n            compatible with ``x`` and whose second dimension is 2. When\n            the an element of ``conf_intervals`` is not None, the\n            notch locations computed by matplotlib are overridden\n            (provided ``notch`` is `True`). When an element of\n            ``conf_intervals`` is `None`, the notches are computed by the\n            method specified by the other kwargs (e.g., ``bootstrap``).\n\n        positions : array-like, optional\n            Sets the positions of the boxes. The ticks and limits are\n            automatically set to match the positions. Defaults to\n            `range(1, N+1)` where N is the number of boxes to be drawn.\n\n        widths : scalar or array-like\n            Sets the width of each box either with a scalar or a\n            sequence. The default is 0.5, or ``0.15*(distance between\n            extreme positions)``, if that is smaller.\n\n        patch_artist : bool, optional (False)\n            If `False` produces boxes with the Line2D artist. Otherwise,\n            boxes and drawn with Patch artists.\n\n        labels : sequence, optional\n            Labels for each dataset. Length must be compatible with\n            dimensions of ``x``.\n\n        manage_ticks : bool, optional (True)\n            If True, the tick locations and labels will be adjusted to match\n            the boxplot positions.\n\n        autorange : bool, optional (False)\n            When `True` and the data are distributed such that the 25th and\n            75th percentiles are equal, ``whis`` is set to (0, 100) such\n            that the whisker ends are at the minimum and maximum of the data.\n\n        meanline : bool, optional (False)\n            If `True` (and ``showmeans`` is `True`), will try to render\n            the mean as a line spanning the full width of the box\n            according to ``meanprops`` (see below). Not recommended if\n            ``shownotches`` is also True. Otherwise, means will be shown\n            as points.\n\n        zorder : scalar, optional (None)\n            Sets the zorder of the boxplot.\n\n        Other Parameters\n        ----------------\n        showcaps : bool, optional (True)\n            Show the caps on the ends of whiskers.\n        showbox : bool, optional (True)\n            Show the central box.\n        showfliers : bool, optional (True)\n            Show the outliers beyond the caps.\n        showmeans : bool, optional (False)\n            Show the arithmetic means.\n        capprops : dict, optional (None)\n            Specifies the style of the caps.\n        boxprops : dict, optional (None)\n            Specifies the style of the box.\n        whiskerprops : dict, optional (None)\n            Specifies the style of the whiskers.\n        flierprops : dict, optional (None)\n            Specifies the style of the fliers.\n        medianprops : dict, optional (None)\n            Specifies the style of the median.\n        meanprops : dict, optional (None)\n            Specifies the style of the mean.\n\n        Returns\n        -------\n        result : dict\n          A dictionary mapping each component of the boxplot to a list\n          of the `.Line2D` instances created. That dictionary has the\n          following keys (assuming vertical boxplots):\n\n          - ``boxes``: the main body of the boxplot showing the\n            quartiles and the median's confidence intervals if\n            enabled.\n\n          - ``medians``: horizontal lines at the median of each box.\n\n          - ``whiskers``: the vertical lines extending to the most\n            extreme, non-outlier data points.\n\n          - ``caps``: the horizontal lines at the ends of the\n            whiskers.\n\n          - ``fliers``: points representing data that extend beyond\n            the whiskers (fliers).\n\n          - ``means``: points or lines representing the means.\n\n        \"\"\"\n\n        # Missing arguments default to rcParams.\n        if whis is None:\n            whis = rcParams['boxplot.whiskers']\n        if bootstrap is None:\n            bootstrap = rcParams['boxplot.bootstrap']\n\n        bxpstats = cbook.boxplot_stats(x, whis=whis, bootstrap=bootstrap,\n                                       labels=labels, autorange=autorange)\n        if notch is None:\n            notch = rcParams['boxplot.notch']\n        if vert is None:\n            vert = rcParams['boxplot.vertical']\n        if patch_artist is None:\n            patch_artist = rcParams['boxplot.patchartist']\n        if meanline is None:\n            meanline = rcParams['boxplot.meanline']\n        if showmeans is None:\n            showmeans = rcParams['boxplot.showmeans']\n        if showcaps is None:\n            showcaps = rcParams['boxplot.showcaps']\n        if showbox is None:\n            showbox = rcParams['boxplot.showbox']\n        if showfliers is None:\n            showfliers = rcParams['boxplot.showfliers']\n\n        if boxprops is None:\n            boxprops = {}\n        if whiskerprops is None:\n            whiskerprops = {}\n        if capprops is None:\n            capprops = {}\n        if medianprops is None:\n            medianprops = {}\n        if meanprops is None:\n            meanprops = {}\n        if flierprops is None:\n            flierprops = {}\n\n        if patch_artist:\n            boxprops['linestyle'] = 'solid'  # Not consistent with bxp.\n            if 'color' in boxprops:\n                boxprops['edgecolor'] = boxprops.pop('color')\n\n        # if non-default sym value, put it into the flier dictionary\n        # the logic for providing the default symbol ('b+') now lives\n        # in bxp in the initial value of final_flierprops\n        # handle all of the *sym* related logic here so we only have to pass\n        # on the flierprops dict.\n        if sym is not None:\n            # no-flier case, which should really be done with\n            # 'showfliers=False' but none-the-less deal with it to keep back\n            # compatibility\n            if sym == '':\n                # blow away existing dict and make one for invisible markers\n                flierprops = dict(linestyle='none', marker='', color='none')\n                # turn the fliers off just to be safe\n                showfliers = False\n            # now process the symbol string\n            else:\n                # process the symbol string\n                # discarded linestyle\n                _, marker, color = _process_plot_format(sym)\n                # if we have a marker, use it\n                if marker is not None:\n                    flierprops['marker'] = marker\n                # if we have a color, use it\n                if color is not None:\n                    # assume that if color is passed in the user want\n                    # filled symbol, if the users want more control use\n                    # flierprops\n                    flierprops['color'] = color\n                    flierprops['markerfacecolor'] = color\n                    flierprops['markeredgecolor'] = color\n\n        # replace medians if necessary:\n        if usermedians is not None:\n            if (len(np.ravel(usermedians)) != len(bxpstats) or\n                    np.shape(usermedians)[0] != len(bxpstats)):\n                raise ValueError('usermedians length not compatible with x')\n            else:\n                # reassign medians as necessary\n                for stats, med in zip(bxpstats, usermedians):\n                    if med is not None:\n                        stats['med'] = med\n\n        if conf_intervals is not None:\n            if np.shape(conf_intervals)[0] != len(bxpstats):\n                err_mess = 'conf_intervals length not compatible with x'\n                raise ValueError(err_mess)\n            else:\n                for stats, ci in zip(bxpstats, conf_intervals):\n                    if ci is not None:\n                        if len(ci) != 2:\n                            raise ValueError('each confidence interval must '\n                                             'have two values')\n                        else:\n                            if ci[0] is not None:\n                                stats['cilo'] = ci[0]\n                            if ci[1] is not None:\n                                stats['cihi'] = ci[1]\n\n        artists = self.bxp(bxpstats, positions=positions, widths=widths,\n                           vert=vert, patch_artist=patch_artist,\n                           shownotches=notch, showmeans=showmeans,\n                           showcaps=showcaps, showbox=showbox,\n                           boxprops=boxprops, flierprops=flierprops,\n                           medianprops=medianprops, meanprops=meanprops,\n                           meanline=meanline, showfliers=showfliers,\n                           capprops=capprops, whiskerprops=whiskerprops,\n                           manage_ticks=manage_ticks, zorder=zorder)\n        return artists",
        "begin_line": 3438,
        "end_line": 3730,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013468013468013467,
            "pseudo_dstar_susp": 0.00014990256333383302,
            "pseudo_tarantula_susp": 0.00014322543683758235,
            "pseudo_op2_susp": 0.00014990256333383302,
            "pseudo_barinel_susp": 0.00014324595330181923
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.bxp#3733",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.bxp(self, bxpstats, positions=None, widths=None, vert=True, patch_artist=False, shownotches=False, showmeans=False, showcaps=True, showbox=True, showfliers=True, boxprops=None, whiskerprops=None, flierprops=None, medianprops=None, capprops=None, meanprops=None, meanline=False, manage_ticks=True, zorder=None)",
        "snippet": "    def bxp(self, bxpstats, positions=None, widths=None, vert=True,\n            patch_artist=False, shownotches=False, showmeans=False,\n            showcaps=True, showbox=True, showfliers=True,\n            boxprops=None, whiskerprops=None, flierprops=None,\n            medianprops=None, capprops=None, meanprops=None,\n            meanline=False, manage_ticks=True, zorder=None):\n        \"\"\"\n        Drawing function for box and whisker plots.\n\n        Make a box and whisker plot for each column of *x* or each\n        vector in sequence *x*.  The box extends from the lower to\n        upper quartile values of the data, with a line at the median.\n        The whiskers extend from the box to show the range of the\n        data.  Flier points are those past the end of the whiskers.\n\n        Parameters\n        ----------\n        bxpstats : list of dicts\n          A list of dictionaries containing stats for each boxplot.\n          Required keys are:\n\n          - ``med``: The median (scalar float).\n\n          - ``q1``: The first quartile (25th percentile) (scalar\n            float).\n\n          - ``q3``: The third quartile (75th percentile) (scalar\n            float).\n\n          - ``whislo``: Lower bound of the lower whisker (scalar\n            float).\n\n          - ``whishi``: Upper bound of the upper whisker (scalar\n            float).\n\n          Optional keys are:\n\n          - ``mean``: The mean (scalar float). Needed if\n            ``showmeans=True``.\n\n          - ``fliers``: Data beyond the whiskers (sequence of floats).\n            Needed if ``showfliers=True``.\n\n          - ``cilo`` & ``cihi``: Lower and upper confidence intervals\n            about the median. Needed if ``shownotches=True``.\n\n          - ``label``: Name of the dataset (string). If available,\n            this will be used a tick label for the boxplot\n\n        positions : array-like, default = [1, 2, ..., n]\n          Sets the positions of the boxes. The ticks and limits\n          are automatically set to match the positions.\n\n        widths : array-like, default = None\n          Either a scalar or a vector and sets the width of each\n          box. The default is ``0.15*(distance between extreme\n          positions)``, clipped to no less than 0.15 and no more than\n          0.5.\n\n        vert : bool, default = True\n          If `True` (default), makes the boxes vertical.  If `False`,\n          makes horizontal boxes.\n\n        patch_artist : bool, default = False\n          If `False` produces boxes with the `.Line2D` artist.\n          If `True` produces boxes with the `~matplotlib.patches.Patch` artist.\n\n        shownotches : bool, default = False\n          If `False` (default), produces a rectangular box plot.\n          If `True`, will produce a notched box plot\n\n        showmeans : bool, default = False\n          If `True`, will toggle on the rendering of the means\n\n        showcaps  : bool, default = True\n          If `True`, will toggle on the rendering of the caps\n\n        showbox  : bool, default = True\n          If `True`, will toggle on the rendering of the box\n\n        showfliers : bool, default = True\n          If `True`, will toggle on the rendering of the fliers\n\n        boxprops : dict or None (default)\n          If provided, will set the plotting style of the boxes\n\n        whiskerprops : dict or None (default)\n          If provided, will set the plotting style of the whiskers\n\n        capprops : dict or None (default)\n          If provided, will set the plotting style of the caps\n\n        flierprops : dict or None (default)\n          If provided will set the plotting style of the fliers\n\n        medianprops : dict or None (default)\n          If provided, will set the plotting style of the medians\n\n        meanprops : dict or None (default)\n          If provided, will set the plotting style of the means\n\n        meanline : bool, default = False\n          If `True` (and *showmeans* is `True`), will try to render the mean\n          as a line spanning the full width of the box according to\n          *meanprops*. Not recommended if *shownotches* is also True.\n          Otherwise, means will be shown as points.\n\n        manage_ticks : bool, default = True\n          If True, the tick locations and labels will be adjusted to match the\n          boxplot positions.\n\n        zorder : scalar, default = None\n          The zorder of the resulting boxplot.\n\n        Returns\n        -------\n        result : dict\n          A dictionary mapping each component of the boxplot to a list\n          of the `.Line2D` instances created. That dictionary has the\n          following keys (assuming vertical boxplots):\n\n          - ``boxes``: the main body of the boxplot showing the\n            quartiles and the median's confidence intervals if\n            enabled.\n\n          - ``medians``: horizontal lines at the median of each box.\n\n          - ``whiskers``: the vertical lines extending to the most\n            extreme, non-outlier data points.\n\n          - ``caps``: the horizontal lines at the ends of the\n            whiskers.\n\n          - ``fliers``: points representing data that extend beyond\n            the whiskers (fliers).\n\n          - ``means``: points or lines representing the means.\n\n        Examples\n        --------\n        .. plot:: gallery/statistics/bxp.py\n\n        \"\"\"\n        # lists of artists to be output\n        whiskers = []\n        caps = []\n        boxes = []\n        medians = []\n        means = []\n        fliers = []\n\n        # empty list of xticklabels\n        datalabels = []\n\n        # Use default zorder if none specified\n        if zorder is None:\n            zorder = mlines.Line2D.zorder\n\n        zdelta = 0.1\n\n        def line_props_with_rcdefaults(subkey, explicit, zdelta=0):\n            d = {k.split('.')[-1]: v for k, v in rcParams.items()\n                 if k.startswith(f'boxplot.{subkey}')}\n            d['zorder'] = zorder + zdelta\n            if explicit is not None:\n                d.update(\n                    cbook.normalize_kwargs(explicit, mlines.Line2D._alias_map))\n            return d\n\n        # box properties\n        if patch_artist:\n            final_boxprops = dict(\n                linestyle=rcParams['boxplot.boxprops.linestyle'],\n                linewidth=rcParams['boxplot.boxprops.linewidth'],\n                edgecolor=rcParams['boxplot.boxprops.color'],\n                facecolor=('white' if rcParams['_internal.classic_mode'] else\n                           rcParams['patch.facecolor']),\n                zorder=zorder,\n            )\n            if boxprops is not None:\n                final_boxprops.update(\n                    cbook.normalize_kwargs(\n                        boxprops, mpatches.PathPatch._alias_map))\n        else:\n            final_boxprops = line_props_with_rcdefaults('boxprops', boxprops)\n        final_whiskerprops = line_props_with_rcdefaults(\n            'whiskerprops', whiskerprops)\n        final_capprops = line_props_with_rcdefaults(\n            'capprops', capprops)\n        final_flierprops = line_props_with_rcdefaults(\n            'flierprops', flierprops)\n        final_medianprops = line_props_with_rcdefaults(\n            'medianprops', medianprops, zdelta)\n        final_meanprops = line_props_with_rcdefaults(\n            'meanprops', meanprops, zdelta)\n        removed_prop = 'marker' if meanline else 'linestyle'\n        # Only remove the property if it's not set explicitly as a parameter.\n        if meanprops is None or removed_prop not in meanprops:\n            final_meanprops[removed_prop] = ''\n\n        def to_vc(xs, ys):\n            # convert arguments to verts and codes, append (0, 0) (ignored).\n            verts = np.append(np.column_stack([xs, ys]), [(0, 0)], 0)\n            codes = ([mpath.Path.MOVETO]\n                     + [mpath.Path.LINETO] * (len(verts) - 2)\n                     + [mpath.Path.CLOSEPOLY])\n            return verts, codes\n\n        def patch_list(xs, ys, **kwargs):\n            verts, codes = to_vc(xs, ys)\n            path = mpath.Path(verts, codes)\n            patch = mpatches.PathPatch(path, **kwargs)\n            self.add_artist(patch)\n            return [patch]\n\n        # vertical or horizontal plot?\n        if vert:\n            def doplot(*args, **kwargs):\n                return self.plot(*args, **kwargs)\n\n            def dopatch(xs, ys, **kwargs):\n                return patch_list(xs, ys, **kwargs)\n\n        else:\n            def doplot(*args, **kwargs):\n                shuffled = []\n                for i in range(0, len(args), 2):\n                    shuffled.extend([args[i + 1], args[i]])\n                return self.plot(*shuffled, **kwargs)\n\n            def dopatch(xs, ys, **kwargs):\n                xs, ys = ys, xs  # flip X, Y\n                return patch_list(xs, ys, **kwargs)\n\n        # input validation\n        N = len(bxpstats)\n        datashape_message = (\"List of boxplot statistics and `{0}` \"\n                             \"values must have same the length\")\n        # check position\n        if positions is None:\n            positions = list(range(1, N + 1))\n        elif len(positions) != N:\n            raise ValueError(datashape_message.format(\"positions\"))\n\n        positions = np.array(positions)\n        if len(positions) > 0 and not isinstance(positions[0], Number):\n            raise TypeError(\"positions should be an iterable of numbers\")\n\n        # width\n        if widths is None:\n            widths = [np.clip(0.15 * np.ptp(positions), 0.15, 0.5)] * N\n        elif np.isscalar(widths):\n            widths = [widths] * N\n        elif len(widths) != N:\n            raise ValueError(datashape_message.format(\"widths\"))\n\n        for pos, width, stats in zip(positions, widths, bxpstats):\n            # try to find a new label\n            datalabels.append(stats.get('label', pos))\n\n            # whisker coords\n            whisker_x = np.ones(2) * pos\n            whiskerlo_y = np.array([stats['q1'], stats['whislo']])\n            whiskerhi_y = np.array([stats['q3'], stats['whishi']])\n\n            # cap coords\n            cap_left = pos - width * 0.25\n            cap_right = pos + width * 0.25\n            cap_x = np.array([cap_left, cap_right])\n            cap_lo = np.ones(2) * stats['whislo']\n            cap_hi = np.ones(2) * stats['whishi']\n\n            # box and median coords\n            box_left = pos - width * 0.5\n            box_right = pos + width * 0.5\n            med_y = [stats['med'], stats['med']]\n\n            # notched boxes\n            if shownotches:\n                box_x = [box_left, box_right, box_right, cap_right, box_right,\n                         box_right, box_left, box_left, cap_left, box_left,\n                         box_left]\n                box_y = [stats['q1'], stats['q1'], stats['cilo'],\n                         stats['med'], stats['cihi'], stats['q3'],\n                         stats['q3'], stats['cihi'], stats['med'],\n                         stats['cilo'], stats['q1']]\n                med_x = cap_x\n\n            # plain boxes\n            else:\n                box_x = [box_left, box_right, box_right, box_left, box_left]\n                box_y = [stats['q1'], stats['q1'], stats['q3'], stats['q3'],\n                         stats['q1']]\n                med_x = [box_left, box_right]\n\n            # maybe draw the box:\n            if showbox:\n                if patch_artist:\n                    boxes.extend(dopatch(box_x, box_y, **final_boxprops))\n                else:\n                    boxes.extend(doplot(box_x, box_y, **final_boxprops))\n\n            # draw the whiskers\n            whiskers.extend(doplot(\n                whisker_x, whiskerlo_y, **final_whiskerprops\n            ))\n            whiskers.extend(doplot(\n                whisker_x, whiskerhi_y, **final_whiskerprops\n            ))\n\n            # maybe draw the caps:\n            if showcaps:\n                caps.extend(doplot(cap_x, cap_lo, **final_capprops))\n                caps.extend(doplot(cap_x, cap_hi, **final_capprops))\n\n            # draw the medians\n            medians.extend(doplot(med_x, med_y, **final_medianprops))\n\n            # maybe draw the means\n            if showmeans:\n                if meanline:\n                    means.extend(doplot(\n                        [box_left, box_right], [stats['mean'], stats['mean']],\n                        **final_meanprops\n                    ))\n                else:\n                    means.extend(doplot(\n                        [pos], [stats['mean']], **final_meanprops\n                    ))\n\n            # maybe draw the fliers\n            if showfliers:\n                # fliers coords\n                flier_x = np.full(len(stats['fliers']), pos, dtype=np.float64)\n                flier_y = stats['fliers']\n\n                fliers.extend(doplot(\n                    flier_x, flier_y, **final_flierprops\n                ))\n\n        if manage_ticks:\n            axis_name = \"x\" if vert else \"y\"\n            interval = getattr(self.dataLim, f\"interval{axis_name}\")\n            axis = getattr(self, f\"{axis_name}axis\")\n            positions = axis.convert_units(positions)\n            # The 0.5 additional padding ensures reasonable-looking boxes\n            # even when drawing a single box.  We set the sticky edge to\n            # prevent margins expansion, in order to match old behavior (back\n            # when separate calls to boxplot() would completely reset the axis\n            # limits regardless of what was drawn before).  The sticky edges\n            # are attached to the median lines, as they are always present.\n            interval[:] = (min(interval[0], min(positions) - .5),\n                           max(interval[1], max(positions) + .5))\n            for median, position in zip(medians, positions):\n                getattr(median.sticky_edges, axis_name).extend(\n                    [position - .5, position + .5])\n            # Modified from Axis.set_ticks and Axis.set_ticklabels.\n            locator = axis.get_major_locator()\n            if not isinstance(axis.get_major_locator(),\n                              mticker.FixedLocator):\n                locator = mticker.FixedLocator([])\n                axis.set_major_locator(locator)\n            locator.locs = np.array([*locator.locs, *positions])\n            formatter = axis.get_major_formatter()\n            if not isinstance(axis.get_major_formatter(),\n                              mticker.FixedFormatter):\n                formatter = mticker.FixedFormatter([])\n                axis.set_major_formatter(formatter)\n            formatter.seq = [*formatter.seq, *datalabels]\n\n            self._request_autoscale_view(\n                scalex=self._autoscaleXon, scaley=self._autoscaleYon)\n\n        return dict(whiskers=whiskers, caps=caps, boxes=boxes,\n                    medians=medians, fliers=fliers, means=means)",
        "begin_line": 3733,
        "end_line": 4107,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016350555918901244,
            "pseudo_dstar_susp": 0.00018487705675725643,
            "pseudo_tarantula_susp": 0.00022187708009762592,
            "pseudo_op2_susp": 0.00018487705675725643,
            "pseudo_barinel_susp": 0.00022187708009762592
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.line_props_with_rcdefaults#3893",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.line_props_with_rcdefaults(subkey, explicit, zdelta=0)",
        "snippet": "        def line_props_with_rcdefaults(subkey, explicit, zdelta=0):\n            d = {k.split('.')[-1]: v for k, v in rcParams.items()\n                 if k.startswith(f'boxplot.{subkey}')}\n            d['zorder'] = zorder + zdelta\n            if explicit is not None:\n                d.update(\n                    cbook.normalize_kwargs(explicit, mlines.Line2D._alias_map))\n            return d",
        "begin_line": 3893,
        "end_line": 3900,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015855398763278897,
            "pseudo_dstar_susp": 0.00018268176835951772,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00018268176835951772,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.to_vc#3933",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.to_vc(xs, ys)",
        "snippet": "        def to_vc(xs, ys):\n            # convert arguments to verts and codes, append (0, 0) (ignored).\n            verts = np.append(np.column_stack([xs, ys]), [(0, 0)], 0)\n            codes = ([mpath.Path.MOVETO]\n                     + [mpath.Path.LINETO] * (len(verts) - 2)\n                     + [mpath.Path.CLOSEPOLY])\n            return verts, codes",
        "begin_line": 3933,
        "end_line": 3939,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015855398763278897,
            "pseudo_dstar_susp": 0.00018268176835951772,
            "pseudo_tarantula_susp": 0.0001455604075691412,
            "pseudo_op2_susp": 0.00018268176835951772,
            "pseudo_barinel_susp": 0.0001455604075691412
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.patch_list#3941",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.patch_list(xs, ys, **kwargs)",
        "snippet": "        def patch_list(xs, ys, **kwargs):\n            verts, codes = to_vc(xs, ys)\n            path = mpath.Path(verts, codes)\n            patch = mpatches.PathPatch(path, **kwargs)\n            self.add_artist(patch)\n            return [patch]",
        "begin_line": 3941,
        "end_line": 3946,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015855398763278897,
            "pseudo_dstar_susp": 0.00018268176835951772,
            "pseudo_tarantula_susp": 0.0001455604075691412,
            "pseudo_op2_susp": 0.00018268176835951772,
            "pseudo_barinel_susp": 0.0001455604075691412
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.doplot#3950",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.doplot(*args, **kwargs)",
        "snippet": "            def doplot(*args, **kwargs):\n                return self.plot(*args, **kwargs)",
        "begin_line": 3950,
        "end_line": 3951,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015625,
            "pseudo_dstar_susp": 0.0001784121320249777,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0001784121320249777,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.dopatch#3953",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.dopatch(xs, ys, **kwargs)",
        "snippet": "            def dopatch(xs, ys, **kwargs):\n                return patch_list(xs, ys, **kwargs)",
        "begin_line": 3953,
        "end_line": 3954,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001554726368159204,
            "pseudo_dstar_susp": 0.00017828489926903192,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00017828489926903192,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.doplot#3957",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.doplot(*args, **kwargs)",
        "snippet": "            def doplot(*args, **kwargs):\n                shuffled = []\n                for i in range(0, len(args), 2):\n                    shuffled.extend([args[i + 1], args[i]])\n                return self.plot(*shuffled, **kwargs)",
        "begin_line": 3957,
        "end_line": 3961,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015625,
            "pseudo_dstar_susp": 0.0001784121320249777,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0001784121320249777,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.dopatch#3963",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.dopatch(xs, ys, **kwargs)",
        "snippet": "            def dopatch(xs, ys, **kwargs):\n                xs, ys = ys, xs  # flip X, Y\n                return patch_list(xs, ys, **kwargs)",
        "begin_line": 3963,
        "end_line": 3965,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001554726368159204,
            "pseudo_dstar_susp": 0.00017828489926903192,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00017828489926903192,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes._parse_scatter_color_args#4110",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes._parse_scatter_color_args(c, edgecolors, kwargs, xsize, get_next_color_func)",
        "snippet": "    def _parse_scatter_color_args(c, edgecolors, kwargs, xsize,\n                                  get_next_color_func):\n        \"\"\"\n        Helper function to process color related arguments of `.Axes.scatter`.\n\n        Argument precedence for facecolors:\n\n        - c (if not None)\n        - kwargs['facecolors']\n        - kwargs['facecolor']\n        - kwargs['color'] (==kwcolor)\n        - 'b' if in classic mode else the result of ``get_next_color_func()``\n\n        Argument precedence for edgecolors:\n\n        - edgecolors (is an explicit kw argument in scatter())\n        - kwargs['edgecolor']\n        - kwargs['color'] (==kwcolor)\n        - 'face' if not in classic mode else None\n\n        Parameters\n        ----------\n        c : color or sequence or sequence of color or None\n            See argument description of `.Axes.scatter`.\n        edgecolors : color or sequence of color or {'face', 'none'} or None\n            See argument description of `.Axes.scatter`.\n        kwargs : dict\n            Additional kwargs. If these keys exist, we pop and process them:\n            'facecolors', 'facecolor', 'edgecolor', 'color'\n            Note: The dict is modified by this function.\n        xsize : int\n            The size of the x and y arrays passed to `.Axes.scatter`.\n        get_next_color_func : callable\n            A callable that returns a color. This color is used as facecolor\n            if no other color is provided.\n\n            Note, that this is a function rather than a fixed color value to\n            support conditional evaluation of the next color.  As of the\n            current implementation obtaining the next color from the\n            property cycle advances the cycle. This must only happen if we\n            actually use the color, which will only be decided within this\n            method.\n\n        Returns\n        -------\n        c\n            The input *c* if it was not *None*, else a color derived from the\n            other inputs or defaults.\n        colors : array(N, 4) or None\n            The facecolors as RGBA values, or *None* if a colormap is used.\n        edgecolors\n            The edgecolor.\n\n        \"\"\"\n        facecolors = kwargs.pop('facecolors', None)\n        facecolors = kwargs.pop('facecolor', facecolors)\n        edgecolors = kwargs.pop('edgecolor', edgecolors)\n\n        kwcolor = kwargs.pop('color', None)\n\n        if kwcolor is not None and c is not None:\n            raise ValueError(\"Supply a 'c' argument or a 'color'\"\n                             \" kwarg but not both; they differ but\"\n                             \" their functionalities overlap.\")\n\n        if kwcolor is not None:\n            try:\n                mcolors.to_rgba_array(kwcolor)\n            except ValueError:\n                raise ValueError(\n                    \"'color' kwarg must be an color or sequence of color \"\n                    \"specs.  For a sequence of values to be color-mapped, use \"\n                    \"the 'c' argument instead.\")\n            if edgecolors is None:\n                edgecolors = kwcolor\n            if facecolors is None:\n                facecolors = kwcolor\n\n        if edgecolors is None and not rcParams['_internal.classic_mode']:\n            edgecolors = rcParams['scatter.edgecolors']\n\n        c_was_none = c is None\n        if c is None:\n            c = (facecolors if facecolors is not None\n                 else \"b\" if rcParams['_internal.classic_mode']\n                 else get_next_color_func())\n        c_is_string_or_strings = (\n            isinstance(c, str)\n            or (isinstance(c, collections.abc.Iterable) and len(c) > 0\n                and isinstance(cbook.safe_first_element(c), str)))\n\n        def invalid_shape_exception(csize, xsize):\n            return ValueError(\n                f\"'c' argument has {csize} elements, which is inconsistent \"\n                f\"with 'x' and 'y' with size {xsize}.\")\n\n        c_is_mapped = False  # Unless proven otherwise below.\n        valid_shape = True  # Unless proven otherwise below.\n        if not c_was_none and kwcolor is None and not c_is_string_or_strings:\n            try:  # First, does 'c' look suitable for value-mapping?\n                c = np.asanyarray(c, dtype=float)\n            except ValueError:\n                pass  # Failed to convert to float array; must be color specs.\n            else:\n                # If c can be either mapped values or a RGB(A) color, prefer\n                # the former if shapes match, the latter otherwise.\n                if c.size == xsize:\n                    c = c.ravel()\n                    c_is_mapped = True\n                else:  # Wrong size; it must not be intended for mapping.\n                    if c.shape in ((3,), (4,)):\n                        _log.warning(\n                            \"'c' argument looks like a single numeric RGB or \"\n                            \"RGBA sequence, which should be avoided as value-\"\n                            \"mapping will have precedence in case its length \"\n                            \"matches with 'x' & 'y'.  Please use a 2-D array \"\n                            \"with a single row if you really want to specify \"\n                            \"the same RGB or RGBA value for all points.\")\n                    valid_shape = False\n        if not c_is_mapped:\n            try:  # Is 'c' acceptable as PathCollection facecolors?\n                colors = mcolors.to_rgba_array(c)\n            except ValueError:\n                if not valid_shape:\n                    raise invalid_shape_exception(c.size, xsize)\n                # Both the mapping *and* the RGBA conversion failed: pretty\n                # severe failure => one may appreciate a verbose feedback.\n                raise ValueError(\n                    f\"'c' argument must be a color, a sequence of colors, or \"\n                    f\"a sequence of numbers, not {c}\")\n            else:\n                if len(colors) not in (0, 1, xsize):\n                    # NB: remember that a single color is also acceptable.\n                    # Besides *colors* will be an empty array if c == 'none'.\n                    raise invalid_shape_exception(len(colors), xsize)\n        else:\n            colors = None  # use cmap, norm after collection is created\n        return c, colors, edgecolors",
        "begin_line": 4110,
        "end_line": 4247,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018001800180018,
            "pseudo_dstar_susp": 0.00021920210434020167,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00021920210434020167,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.invalid_shape_exception#4201",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.invalid_shape_exception(csize, xsize)",
        "snippet": "        def invalid_shape_exception(csize, xsize):\n            return ValueError(\n                f\"'c' argument has {csize} elements, which is inconsistent \"\n                f\"with 'x' and 'y' with size {xsize}.\")",
        "begin_line": 4201,
        "end_line": 4204,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012195121951219512,
            "pseudo_dstar_susp": 0.00013462574044157243,
            "pseudo_tarantula_susp": 0.00012138868657441127,
            "pseudo_op2_susp": 0.00013462574044157243,
            "pseudo_barinel_susp": 0.00012134449702705982
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.scatter#4254",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.scatter(self, x, y, s=None, c=None, marker=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, verts=None, edgecolors=None, *, plotnonfinite=False, **kwargs)",
        "snippet": "    def scatter(self, x, y, s=None, c=None, marker=None, cmap=None, norm=None,\n                vmin=None, vmax=None, alpha=None, linewidths=None,\n                verts=None, edgecolors=None, *, plotnonfinite=False,\n                **kwargs):\n        \"\"\"\n        A scatter plot of *y* vs. *x* with varying marker size and/or color.\n\n        Parameters\n        ----------\n        x, y : scalar or array-like, shape (n, )\n            The data positions.\n\n        s : scalar or array-like, shape (n, ), optional\n            The marker size in points**2.\n            Default is ``rcParams['lines.markersize'] ** 2``.\n\n        c : color, sequence, or sequence of colors, optional\n            The marker color. Possible values:\n\n            - A single color format string.\n            - A sequence of colors of length n.\n            - A scalar or sequence of n numbers to be mapped to colors using\n              *cmap* and *norm*.\n            - A 2-D array in which the rows are RGB or RGBA.\n\n            Note that *c* should not be a single numeric RGB or RGBA sequence\n            because that is indistinguishable from an array of values to be\n            colormapped. If you want to specify the same RGB or RGBA value for\n            all points, use a 2-D array with a single row.  Otherwise, value-\n            matching will have precedence in case of a size matching with *x*\n            and *y*.\n\n            Defaults to ``None``. In that case the marker color is determined\n            by the value of ``color``, ``facecolor`` or ``facecolors``. In case\n            those are not specified or ``None``, the marker color is determined\n            by the next color of the ``Axes``' current \"shape and fill\" color\n            cycle. This cycle defaults to :rc:`axes.prop_cycle`.\n\n        marker : `~matplotlib.markers.MarkerStyle`, optional\n            The marker style. *marker* can be either an instance of the class\n            or the text shorthand for a particular marker.\n            Defaults to ``None``, in which case it takes the value of\n            :rc:`scatter.marker` = 'o'.\n            See `~matplotlib.markers` for more information about marker styles.\n\n        cmap : `~matplotlib.colors.Colormap`, optional, default: None\n            A `.Colormap` instance or registered colormap name. *cmap* is only\n            used if *c* is an array of floats. If ``None``, defaults to rc\n            ``image.cmap``.\n\n        norm : `~matplotlib.colors.Normalize`, optional, default: None\n            A `.Normalize` instance is used to scale luminance data to 0, 1.\n            *norm* is only used if *c* is an array of floats. If *None*, use\n            the default `.colors.Normalize`.\n\n        vmin, vmax : scalar, optional, default: None\n            *vmin* and *vmax* are used in conjunction with *norm* to normalize\n            luminance data. If None, the respective min and max of the color\n            array is used. *vmin* and *vmax* are ignored if you pass a *norm*\n            instance.\n\n        alpha : scalar, optional, default: None\n            The alpha blending value, between 0 (transparent) and 1 (opaque).\n\n        linewidths : scalar or array-like, optional, default: None\n            The linewidth of the marker edges. Note: The default *edgecolors*\n            is 'face'. You may want to change this as well.\n            If *None*, defaults to :rc:`lines.linewidth`.\n\n        edgecolors : {'face', 'none', *None*} or color or sequence of color, \\\noptional.\n            The edge color of the marker. Possible values:\n\n            - 'face': The edge color will always be the same as the face color.\n            - 'none': No patch boundary will be drawn.\n            - A Matplotlib color or sequence of color.\n\n            Defaults to ``None``, in which case it takes the value of\n            :rc:`scatter.edgecolors` = 'face'.\n\n            For non-filled markers, the *edgecolors* kwarg is ignored and\n            forced to 'face' internally.\n\n        plotnonfinite : boolean, optional, default: False\n            Set to plot points with nonfinite *c*, in conjunction with\n            `~matplotlib.colors.Colormap.set_bad`.\n\n        Returns\n        -------\n        paths : `~matplotlib.collections.PathCollection`\n\n        Other Parameters\n        ----------------\n        **kwargs : `~matplotlib.collections.Collection` properties\n\n        See Also\n        --------\n        plot : To plot scatter plots when markers are identical in size and\n            color.\n\n        Notes\n        -----\n        * The `.plot` function will be faster for scatterplots where markers\n          don't vary in size or color.\n\n        * Any or all of *x*, *y*, *s*, and *c* may be masked arrays, in which\n          case all masks will be combined and only unmasked points will be\n          plotted.\n\n        * Fundamentally, scatter works with 1-D arrays; *x*, *y*, *s*, and *c*\n          may be input as N-D arrays, but within scatter they will be\n          flattened. The exception is *c*, which will be flattened only if its\n          size matches the size of *x* and *y*.\n\n        \"\"\"\n        # Process **kwargs to handle aliases, conflicts with explicit kwargs:\n\n        self._process_unit_info(xdata=x, ydata=y, kwargs=kwargs)\n        x = self.convert_xunits(x)\n        y = self.convert_yunits(y)\n\n        # np.ma.ravel yields an ndarray, not a masked array,\n        # unless its argument is a masked array.\n        x = np.ma.ravel(x)\n        y = np.ma.ravel(y)\n        if x.size != y.size:\n            raise ValueError(\"x and y must be the same size\")\n\n        if s is None:\n            s = (20 if rcParams['_internal.classic_mode'] else\n                 rcParams['lines.markersize'] ** 2.0)\n        s = np.ma.ravel(s)\n        if len(s) not in (1, x.size):\n            raise ValueError(\"s must be a scalar, or the same size as x and y\")\n\n        c, colors, edgecolors = \\\n            self._parse_scatter_color_args(\n                c, edgecolors, kwargs, x.size,\n                get_next_color_func=self._get_patches_for_fill.get_next_color)\n\n        if plotnonfinite and colors is None:\n            c = np.ma.masked_invalid(c)\n            x, y, s, edgecolors, linewidths = \\\n                cbook._combine_masks(x, y, s, edgecolors, linewidths)\n        else:\n            x, y, s, c, colors, edgecolors, linewidths = \\\n                cbook._combine_masks(\n                    x, y, s, c, colors, edgecolors, linewidths)\n\n        scales = s   # Renamed for readability below.\n\n        # load default marker from rcParams\n        if marker is None:\n            marker = rcParams['scatter.marker']\n\n        if isinstance(marker, mmarkers.MarkerStyle):\n            marker_obj = marker\n        else:\n            marker_obj = mmarkers.MarkerStyle(marker)\n\n        path = marker_obj.get_path().transformed(\n            marker_obj.get_transform())\n        if not marker_obj.is_filled():\n            edgecolors = 'face'\n            linewidths = rcParams['lines.linewidth']\n\n        offsets = np.ma.column_stack([x, y])\n\n        collection = mcoll.PathCollection(\n                (path,), scales,\n                facecolors=colors,\n                edgecolors=edgecolors,\n                linewidths=linewidths,\n                offsets=offsets,\n                transOffset=kwargs.pop('transform', self.transData),\n                alpha=alpha\n                )\n        collection.set_transform(mtransforms.IdentityTransform())\n        collection.update(kwargs)\n\n        if colors is None:\n            collection.set_array(c)\n            collection.set_cmap(cmap)\n            collection.set_norm(norm)\n\n            if vmin is not None or vmax is not None:\n                collection.set_clim(vmin, vmax)\n            else:\n                collection.autoscale_None()\n\n        # Classic mode only:\n        # ensure there are margins to allow for the\n        # finite size of the symbols.  In v2.x, margins\n        # are present by default, so we disable this\n        # scatter-specific override.\n        if rcParams['_internal.classic_mode']:\n            if self._xmargin < 0.05 and x.size > 0:\n                self.set_xmargin(0.05)\n            if self._ymargin < 0.05 and x.size > 0:\n                self.set_ymargin(0.05)\n\n        self.add_collection(collection)\n        self._request_autoscale_view()\n\n        return collection",
        "begin_line": 4254,
        "end_line": 4458,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00014255167498218105,
            "pseudo_dstar_susp": 0.00018178512997636792,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00018178512997636792,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.hexbin#4462",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.hexbin(self, x, y, C=None, gridsize=100, bins=None, xscale='linear', yscale='linear', extent=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, edgecolors='face', reduce_C_function=np.mean, mincnt=None, marginals=False, **kwargs)",
        "snippet": "    def hexbin(self, x, y, C=None, gridsize=100, bins=None,\n               xscale='linear', yscale='linear', extent=None,\n               cmap=None, norm=None, vmin=None, vmax=None,\n               alpha=None, linewidths=None, edgecolors='face',\n               reduce_C_function=np.mean, mincnt=None, marginals=False,\n               **kwargs):\n        \"\"\"\n        Make a 2D hexagonal binning plot of points *x*, *y*.\n\n        If *C* is *None*, the value of the hexagon is determined by the number\n        of points in the hexagon. Otherwise, *C* specifies values at the\n        coordinate (x[i], y[i]). For each hexagon, these values are reduced\n        using *reduce_C_function*.\n\n        Parameters\n        ----------\n        x, y : array-like\n            The data positions. *x* and *y* must be of the same length.\n\n        C : array-like, optional\n            If given, these values are accumulated in the bins. Otherwise,\n            every point has a value of 1. Must be of the same length as *x*\n            and *y*.\n\n        gridsize : int or (int, int), default: 100\n            If a single int, the number of hexagons in the *x*-direction.\n            The number of hexagons in the *y*-direction is chosen such that\n            the hexagons are approximately regular.\n\n            Alternatively, if a tuple (*nx*, *ny*), the number of hexagons\n            in the *x*-direction and the *y*-direction.\n\n        bins : 'log' or int or sequence, default: *None*\n            Discretization of the hexagon values.\n\n            - If *None*, no binning is applied; the color of each hexagon\n              directly corresponds to its count value.\n            - If 'log', use a logarithmic scale for the color map.\n              Internally, :math:`log_{10}(i+1)` is used to determine the\n              hexagon color. This is equivalent to ``norm=LogNorm()``.\n            - If an integer, divide the counts in the specified number\n              of bins, and color the hexagons accordingly.\n            - If a sequence of values, the values of the lower bound of\n              the bins to be used.\n\n        xscale : {'linear', 'log'}, default: 'linear'\n            Use a linear or log10 scale on the horizontal axis.\n\n        yscale : {'linear', 'log'}, default: 'linear'\n            Use a linear or log10 scale on the vertical axis.\n\n        mincnt : int > 0, default: *None*\n            If not *None*, only display cells with more than *mincnt*\n            number of points in the cell.\n\n        marginals : bool, default: *False*\n            If marginals is *True*, plot the marginal density as\n            colormapped rectangles along the bottom of the x-axis and\n            left of the y-axis.\n\n        extent : float, default: *None*\n            The limits of the bins. The default assigns the limits\n            based on *gridsize*, *x*, *y*, *xscale* and *yscale*.\n\n            If *xscale* or *yscale* is set to 'log', the limits are\n            expected to be the exponent for a power of 10. E.g. for\n            x-limits of 1 and 50 in 'linear' scale and y-limits\n            of 10 and 1000 in 'log' scale, enter (1, 50, 1, 3).\n\n            Order of scalars is (left, right, bottom, top).\n\n        Other Parameters\n        ----------------\n        cmap : str or `~matplotlib.colors.Colormap`, optional\n            The Colormap instance or registered colormap name used to map\n            the bin values to colors. Defaults to :rc:`image.cmap`.\n\n        norm : `~matplotlib.colors.Normalize`, optional\n            The Normalize instance scales the bin values to the canonical\n            colormap range [0, 1] for mapping to colors. By default, the data\n            range is mapped to the colorbar range using linear scaling.\n\n        vmin, vmax : float, optional, default: None\n            The colorbar range. If *None*, suitable min/max values are\n            automatically chosen by the `~.Normalize` instance (defaults to\n            the respective min/max values of the bins in case of the default\n            linear scaling). This is ignored if *norm* is given.\n\n        alpha : float between 0 and 1, optional\n            The alpha blending value, between 0 (transparent) and 1 (opaque).\n\n        linewidths : float, default: *None*\n            If *None*, defaults to 1.0.\n\n        edgecolors : {'face', 'none', *None*} or color, default: 'face'\n            The color of the hexagon edges. Possible values are:\n\n            - 'face': Draw the edges in the same color as the fill color.\n            - 'none': No edges are drawn. This can sometimes lead to unsightly\n              unpainted pixels between the hexagons.\n            - *None*: Draw outlines in the default color.\n            - An explicit matplotlib color.\n\n        reduce_C_function : callable, default is `numpy.mean`\n            The function to aggregate *C* within the bins. It is ignored if\n            *C* is not given. This must have the signature::\n\n                def reduce_C_function(C: array) -> float\n\n            Commonly used functions are:\n\n            - `numpy.mean`: average of the points\n            - `numpy.sum`: integral of the point values\n            - `numpy.max`: value taken from the largest point\n\n        **kwargs : `~matplotlib.collections.PolyCollection` properties\n            All other keyword arguments are passed on to `.PolyCollection`:\n\n            %(PolyCollection)s\n\n        Returns\n        -------\n        polycollection : `~matplotlib.collections.PolyCollection`\n            A `.PolyCollection` defining the hexagonal bins.\n\n            - `.PolyCollection.get_offset` contains a Mx2 array containing\n              the x, y positions of the M hexagon centers.\n            - `.PolyCollection.get_array` contains the values of the M\n              hexagons.\n\n            If *marginals* is *True*, horizontal\n            bar and vertical bar (both PolyCollections) will be attached\n            to the return collection as attributes *hbar* and *vbar*.\n\n        \"\"\"\n        self._process_unit_info(xdata=x, ydata=y, kwargs=kwargs)\n\n        x, y, C = cbook.delete_masked_points(x, y, C)\n\n        # Set the size of the hexagon grid\n        if np.iterable(gridsize):\n            nx, ny = gridsize\n        else:\n            nx = gridsize\n            ny = int(nx / math.sqrt(3))\n        # Count the number of data in each hexagon\n        x = np.array(x, float)\n        y = np.array(y, float)\n        if xscale == 'log':\n            if np.any(x <= 0.0):\n                raise ValueError(\"x contains non-positive values, so can not\"\n                                 \" be log-scaled\")\n            x = np.log10(x)\n        if yscale == 'log':\n            if np.any(y <= 0.0):\n                raise ValueError(\"y contains non-positive values, so can not\"\n                                 \" be log-scaled\")\n            y = np.log10(y)\n        if extent is not None:\n            xmin, xmax, ymin, ymax = extent\n        else:\n            xmin, xmax = (np.min(x), np.max(x)) if len(x) else (0, 1)\n            ymin, ymax = (np.min(y), np.max(y)) if len(y) else (0, 1)\n\n            # to avoid issues with singular data, expand the min/max pairs\n            xmin, xmax = mtransforms.nonsingular(xmin, xmax, expander=0.1)\n            ymin, ymax = mtransforms.nonsingular(ymin, ymax, expander=0.1)\n\n        # In the x-direction, the hexagons exactly cover the region from\n        # xmin to xmax. Need some padding to avoid roundoff errors.\n        padding = 1.e-9 * (xmax - xmin)\n        xmin -= padding\n        xmax += padding\n        sx = (xmax - xmin) / nx\n        sy = (ymax - ymin) / ny\n\n        if marginals:\n            xorig = x.copy()\n            yorig = y.copy()\n\n        x = (x - xmin) / sx\n        y = (y - ymin) / sy\n        ix1 = np.round(x).astype(int)\n        iy1 = np.round(y).astype(int)\n        ix2 = np.floor(x).astype(int)\n        iy2 = np.floor(y).astype(int)\n\n        nx1 = nx + 1\n        ny1 = ny + 1\n        nx2 = nx\n        ny2 = ny\n        n = nx1 * ny1 + nx2 * ny2\n\n        d1 = (x - ix1) ** 2 + 3.0 * (y - iy1) ** 2\n        d2 = (x - ix2 - 0.5) ** 2 + 3.0 * (y - iy2 - 0.5) ** 2\n        bdist = (d1 < d2)\n        if C is None:\n            lattice1 = np.zeros((nx1, ny1))\n            lattice2 = np.zeros((nx2, ny2))\n            c1 = (0 <= ix1) & (ix1 < nx1) & (0 <= iy1) & (iy1 < ny1) & bdist\n            c2 = (0 <= ix2) & (ix2 < nx2) & (0 <= iy2) & (iy2 < ny2) & ~bdist\n            np.add.at(lattice1, (ix1[c1], iy1[c1]), 1)\n            np.add.at(lattice2, (ix2[c2], iy2[c2]), 1)\n            if mincnt is not None:\n                lattice1[lattice1 < mincnt] = np.nan\n                lattice2[lattice2 < mincnt] = np.nan\n            accum = np.concatenate([lattice1.ravel(), lattice2.ravel()])\n            good_idxs = ~np.isnan(accum)\n\n        else:\n            if mincnt is None:\n                mincnt = 0\n\n            # create accumulation arrays\n            lattice1 = np.empty((nx1, ny1), dtype=object)\n            for i in range(nx1):\n                for j in range(ny1):\n                    lattice1[i, j] = []\n            lattice2 = np.empty((nx2, ny2), dtype=object)\n            for i in range(nx2):\n                for j in range(ny2):\n                    lattice2[i, j] = []\n\n            for i in range(len(x)):\n                if bdist[i]:\n                    if 0 <= ix1[i] < nx1 and 0 <= iy1[i] < ny1:\n                        lattice1[ix1[i], iy1[i]].append(C[i])\n                else:\n                    if 0 <= ix2[i] < nx2 and 0 <= iy2[i] < ny2:\n                        lattice2[ix2[i], iy2[i]].append(C[i])\n\n            for i in range(nx1):\n                for j in range(ny1):\n                    vals = lattice1[i, j]\n                    if len(vals) > mincnt:\n                        lattice1[i, j] = reduce_C_function(vals)\n                    else:\n                        lattice1[i, j] = np.nan\n            for i in range(nx2):\n                for j in range(ny2):\n                    vals = lattice2[i, j]\n                    if len(vals) > mincnt:\n                        lattice2[i, j] = reduce_C_function(vals)\n                    else:\n                        lattice2[i, j] = np.nan\n\n            accum = np.hstack((lattice1.astype(float).ravel(),\n                               lattice2.astype(float).ravel()))\n            good_idxs = ~np.isnan(accum)\n\n        offsets = np.zeros((n, 2), float)\n        offsets[:nx1 * ny1, 0] = np.repeat(np.arange(nx1), ny1)\n        offsets[:nx1 * ny1, 1] = np.tile(np.arange(ny1), nx1)\n        offsets[nx1 * ny1:, 0] = np.repeat(np.arange(nx2) + 0.5, ny2)\n        offsets[nx1 * ny1:, 1] = np.tile(np.arange(ny2), nx2) + 0.5\n        offsets[:, 0] *= sx\n        offsets[:, 1] *= sy\n        offsets[:, 0] += xmin\n        offsets[:, 1] += ymin\n        # remove accumulation bins with no data\n        offsets = offsets[good_idxs, :]\n        accum = accum[good_idxs]\n\n        polygon = [sx, sy / 3] * np.array(\n            [[.5, -.5], [.5, .5], [0., 1.], [-.5, .5], [-.5, -.5], [0., -1.]])\n\n        if linewidths is None:\n            linewidths = [1.0]\n\n        if xscale == 'log' or yscale == 'log':\n            polygons = np.expand_dims(polygon, 0) + np.expand_dims(offsets, 1)\n            if xscale == 'log':\n                polygons[:, :, 0] = 10.0 ** polygons[:, :, 0]\n                xmin = 10.0 ** xmin\n                xmax = 10.0 ** xmax\n                self.set_xscale(xscale)\n            if yscale == 'log':\n                polygons[:, :, 1] = 10.0 ** polygons[:, :, 1]\n                ymin = 10.0 ** ymin\n                ymax = 10.0 ** ymax\n                self.set_yscale(yscale)\n            collection = mcoll.PolyCollection(\n                polygons,\n                edgecolors=edgecolors,\n                linewidths=linewidths,\n                )\n        else:\n            collection = mcoll.PolyCollection(\n                [polygon],\n                edgecolors=edgecolors,\n                linewidths=linewidths,\n                offsets=offsets,\n                transOffset=mtransforms.IdentityTransform(),\n                offset_position=\"data\"\n                )\n\n        # Set normalizer if bins is 'log'\n        if bins == 'log':\n            if norm is not None:\n                cbook._warn_external(\"Only one of 'bins' and 'norm' \"\n                                     \"arguments can be supplied, ignoring \"\n                                     \"bins={}\".format(bins))\n            else:\n                norm = mcolors.LogNorm()\n            bins = None\n\n        if isinstance(norm, mcolors.LogNorm):\n            if (accum == 0).any():\n                # make sure we have no zeros\n                accum += 1\n\n        # autoscale the norm with curren accum values if it hasn't\n        # been set\n        if norm is not None:\n            if norm.vmin is None and norm.vmax is None:\n                norm.autoscale(accum)\n\n        if bins is not None:\n            if not np.iterable(bins):\n                minimum, maximum = min(accum), max(accum)\n                bins -= 1  # one less edge than bins\n                bins = minimum + (maximum - minimum) * np.arange(bins) / bins\n            bins = np.sort(bins)\n            accum = bins.searchsorted(accum)\n\n        collection.set_array(accum)\n        collection.set_cmap(cmap)\n        collection.set_norm(norm)\n        collection.set_alpha(alpha)\n        collection.update(kwargs)\n\n        if vmin is not None or vmax is not None:\n            collection.set_clim(vmin, vmax)\n        else:\n            collection.autoscale_None()\n\n        corners = ((xmin, ymin), (xmax, ymax))\n        self.update_datalim(corners)\n        self._request_autoscale_view(tight=True)\n\n        # add the collection last\n        self.add_collection(collection, autolim=False)\n        if not marginals:\n            return collection\n\n        if C is None:\n            C = np.ones(len(x))\n\n        def coarse_bin(x, y, coarse):\n            ind = coarse.searchsorted(x).clip(0, len(coarse) - 1)\n            mus = np.zeros(len(coarse))\n            for i in range(len(coarse)):\n                yi = y[ind == i]\n                if len(yi) > 0:\n                    mu = reduce_C_function(yi)\n                else:\n                    mu = np.nan\n                mus[i] = mu\n            return mus\n\n        coarse = np.linspace(xmin, xmax, gridsize)\n\n        xcoarse = coarse_bin(xorig, C, coarse)\n        valid = ~np.isnan(xcoarse)\n        verts, values = [], []\n        for i, val in enumerate(xcoarse):\n            thismin = coarse[i]\n            if i < len(coarse) - 1:\n                thismax = coarse[i + 1]\n            else:\n                thismax = thismin + np.diff(coarse)[-1]\n\n            if not valid[i]:\n                continue\n\n            verts.append([(thismin, 0),\n                          (thismin, 0.05),\n                          (thismax, 0.05),\n                          (thismax, 0)])\n            values.append(val)\n\n        values = np.array(values)\n        trans = self.get_xaxis_transform(which='grid')\n\n        hbar = mcoll.PolyCollection(verts, transform=trans, edgecolors='face')\n\n        hbar.set_array(values)\n        hbar.set_cmap(cmap)\n        hbar.set_norm(norm)\n        hbar.set_alpha(alpha)\n        hbar.update(kwargs)\n        self.add_collection(hbar, autolim=False)\n\n        coarse = np.linspace(ymin, ymax, gridsize)\n        ycoarse = coarse_bin(yorig, C, coarse)\n        valid = ~np.isnan(ycoarse)\n        verts, values = [], []\n        for i, val in enumerate(ycoarse):\n            thismin = coarse[i]\n            if i < len(coarse) - 1:\n                thismax = coarse[i + 1]\n            else:\n                thismax = thismin + np.diff(coarse)[-1]\n            if not valid[i]:\n                continue\n            verts.append([(0, thismin), (0.0, thismax),\n                          (0.05, thismax), (0.05, thismin)])\n            values.append(val)\n\n        values = np.array(values)\n\n        trans = self.get_yaxis_transform(which='grid')\n\n        vbar = mcoll.PolyCollection(verts, transform=trans, edgecolors='face')\n        vbar.set_array(values)\n        vbar.set_cmap(cmap)\n        vbar.set_norm(norm)\n        vbar.set_alpha(alpha)\n        vbar.update(kwargs)\n        self.add_collection(vbar, autolim=False)\n\n        collection.hbar = hbar\n        collection.vbar = vbar\n\n        def on_changed(collection):\n            hbar.set_cmap(collection.get_cmap())\n            hbar.set_clim(collection.get_clim())\n            vbar.set_cmap(collection.get_cmap())\n            vbar.set_clim(collection.get_clim())\n\n        collection.callbacksSM.connect('changed', on_changed)\n\n        return collection",
        "begin_line": 4462,
        "end_line": 4894,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.arrow#4897",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.arrow(self, x, y, dx, dy, **kwargs)",
        "snippet": "    def arrow(self, x, y, dx, dy, **kwargs):\n        \"\"\"\n        Add an arrow to the axes.\n\n        This draws an arrow from ``(x, y)`` to ``(x+dx, y+dy)``.\n\n        Parameters\n        ----------\n        x, y : float\n            The x and y coordinates of the arrow base.\n        dx, dy : float\n            The length of the arrow along x and y direction.\n\n        Returns\n        -------\n        arrow : `.FancyArrow`\n            The created `.FancyArrow` object.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Optional kwargs (inherited from `.FancyArrow` patch) control the\n            arrow construction and properties:\n\n        %(FancyArrow)s\n\n        Notes\n        -----\n        The resulting arrow is affected by the axes aspect ratio and limits.\n        This may produce an arrow whose head is not square with its stem. To\n        create an arrow whose head is square with its stem,\n        use :meth:`annotate` for example:\n\n        >>> ax.annotate(\"\", xy=(0.5, 0.5), xytext=(0, 0),\n        ...             arrowprops=dict(arrowstyle=\"->\"))\n\n        \"\"\"\n        # Strip away units for the underlying patch since units\n        # do not make sense to most patch-like code\n        x = self.convert_xunits(x)\n        y = self.convert_yunits(y)\n        dx = self.convert_xunits(dx)\n        dy = self.convert_yunits(dy)\n\n        a = mpatches.FancyArrow(x, y, dx, dy, **kwargs)\n        self.add_artist(a)\n        return a",
        "begin_line": 4897,
        "end_line": 4943,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.quiverkey#4946",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.quiverkey(self, Q, X, Y, U, label, **kw)",
        "snippet": "    def quiverkey(self, Q, X, Y, U, label, **kw):\n        qk = mquiver.QuiverKey(Q, X, Y, U, label, **kw)\n        self.add_artist(qk)\n        return qk",
        "begin_line": 4946,
        "end_line": 4949,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016315875346712352,
            "pseudo_dstar_susp": 0.00015213753232922562,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00015213753232922562,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes._quiver_units#4952",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes._quiver_units(self, args, kw)",
        "snippet": "    def _quiver_units(self, args, kw):\n        if len(args) > 3:\n            x, y = args[0:2]\n            self._process_unit_info(xdata=x, ydata=y, kwargs=kw)\n            x = self.convert_xunits(x)\n            y = self.convert_yunits(y)\n            return (x, y) + args[2:]\n        return args",
        "begin_line": 4952,
        "end_line": 4959,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015785319652722967,
            "pseudo_dstar_susp": 0.0001579778830963665,
            "pseudo_tarantula_susp": 0.00022680880018144704,
            "pseudo_op2_susp": 0.0001579778830963665,
            "pseudo_barinel_susp": 0.00022686025408348456
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.quiver#4963",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.quiver(self, *args, **kw)",
        "snippet": "    def quiver(self, *args, **kw):\n        # Make sure units are handled for x and y values\n        args = self._quiver_units(args, kw)\n\n        q = mquiver.Quiver(self, *args, **kw)\n\n        self.add_collection(q, autolim=True)\n        self._request_autoscale_view()\n        return q",
        "begin_line": 4963,
        "end_line": 4971,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001424298532972511,
            "pseudo_dstar_susp": 0.00015873015873015873,
            "pseudo_tarantula_susp": 0.00016909029421711193,
            "pseudo_op2_susp": 0.00015873015873015873,
            "pseudo_barinel_susp": 0.00016909029421711193
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.barbs#4977",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.barbs(self, *args, **kw)",
        "snippet": "    def barbs(self, *args, **kw):\n        \"\"\"\n        %(barbs_doc)s\n        \"\"\"\n        # Make sure units are handled for x and y values\n        args = self._quiver_units(args, kw)\n\n        b = mquiver.Barbs(self, *args, **kw)\n        self.add_collection(b, autolim=True)\n        self._request_autoscale_view()\n        return b",
        "begin_line": 4977,
        "end_line": 4987,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.34306691139663e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.fill#4991",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.fill(self, *args, data=None, **kwargs)",
        "snippet": "    def fill(self, *args, data=None, **kwargs):\n        \"\"\"\n        Plot filled polygons.\n\n        Parameters\n        ----------\n        *args : sequence of x, y, [color]\n            Each polygon is defined by the lists of *x* and *y* positions of\n            its nodes, optionally followed by a *color* specifier. See\n            :mod:`matplotlib.colors` for supported color specifiers. The\n            standard color cycle is used for polygons without a color\n            specifier.\n\n            You can plot multiple polygons by providing multiple *x*, *y*,\n            *[color]* groups.\n\n            For example, each of the following is legal::\n\n                ax.fill(x, y)                    # a polygon with default color\n                ax.fill(x, y, \"b\")               # a blue polygon\n                ax.fill(x, y, x2, y2)            # two polygons\n                ax.fill(x, y, \"b\", x2, y2, \"r\")  # a blue and a red polygon\n\n        data : indexable object, optional\n            An object with labelled data. If given, provide the label names to\n            plot in *x* and *y*, e.g.::\n\n                ax.fill(\"time\", \"signal\",\n                        data={\"time\": [0, 1, 2], \"signal\": [0, 1, 0]})\n\n        Returns\n        -------\n        a list of :class:`~matplotlib.patches.Polygon`\n\n        Other Parameters\n        ----------------\n        **kwargs : :class:`~matplotlib.patches.Polygon` properties\n\n        Notes\n        -----\n        Use :meth:`fill_between` if you would like to fill the region between\n        two curves.\n        \"\"\"\n        # For compatibility(!), get aliases from Line2D rather than Patch.\n        kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)\n        # _get_patches_for_fill returns a generator, convert it to a list.\n        patches = [*self._get_patches_for_fill(*args, data=data, **kwargs)]\n        for poly in patches:\n            self.add_patch(poly)\n        self._request_autoscale_view()\n        return patches",
        "begin_line": 4991,
        "end_line": 5041,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00015098897780462027,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00015098897780462027,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.fill_between#5045",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.fill_between(self, x, y1, y2=0, where=None, interpolate=False, step=None, **kwargs)",
        "snippet": "    def fill_between(self, x, y1, y2=0, where=None, interpolate=False,\n                     step=None, **kwargs):\n        \"\"\"\n        Fill the area between two horizontal curves.\n\n        The curves are defined by the points (*x*, *y1*) and (*x*, *y2*). This\n        creates one or multiple polygons describing the filled area.\n\n        You may exclude some horizontal sections from filling using *where*.\n\n        By default, the edges connect the given points directly. Use *step* if\n        the filling should be a step function, i.e. constant in between *x*.\n\n\n        Parameters\n        ----------\n        x : array (length N)\n            The x coordinates of the nodes defining the curves.\n\n        y1 : array (length N) or scalar\n            The y coordinates of the nodes defining the first curve.\n\n        y2 : array (length N) or scalar, optional, default: 0\n            The y coordinates of the nodes defining the second curve.\n\n        where : array of bool (length N), optional, default: None\n            Define *where* to exclude some horizontal regions from being\n            filled. The filled regions are defined by the coordinates\n            ``x[where]``.  More precisely, fill between ``x[i]`` and ``x[i+1]``\n            if ``where[i] and where[i+1]``.  Note that this definition implies\n            that an isolated *True* value between two *False* values in\n            *where* will not result in filling.  Both sides of the *True*\n            position remain unfilled due to the adjacent *False* values.\n\n        interpolate : bool, optional\n            This option is only relevant if *where* is used and the two curves\n            are crossing each other.\n\n            Semantically, *where* is often used for *y1* > *y2* or similar.\n            By default, the nodes of the polygon defining the filled region\n            will only be placed at the positions in the *x* array.  Such a\n            polygon cannot describe the above semantics close to the\n            intersection.  The x-sections containing the intersection are\n            simply clipped.\n\n            Setting *interpolate* to *True* will calculate the actual\n            intersection point and extend the filled region up to this point.\n\n        step : {'pre', 'post', 'mid'}, optional\n            Define *step* if the filling should be a step function,\n            i.e. constant in between *x*. The value determines where the\n            step will occur:\n\n            - 'pre': The y value is continued constantly to the left from\n              every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the\n              value ``y[i]``.\n            - 'post': The y value is continued constantly to the right from\n              every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the\n              value ``y[i]``.\n            - 'mid': Steps occur half-way between the *x* positions.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            All other keyword arguments are passed on to `.PolyCollection`.\n            They control the `.Polygon` properties:\n\n            %(PolyCollection)s\n\n        Returns\n        -------\n        `.PolyCollection`\n            A `.PolyCollection` containing the plotted polygons.\n\n        See Also\n        --------\n        fill_betweenx : Fill between two sets of x-values.\n\n        Notes\n        -----\n        .. [notes section required to get data note injection right]\n\n        \"\"\"\n        if not rcParams['_internal.classic_mode']:\n            kwargs = cbook.normalize_kwargs(kwargs, mcoll.Collection)\n            if not any(c in kwargs for c in ('color', 'facecolor')):\n                kwargs['facecolor'] = \\\n                    self._get_patches_for_fill.get_next_color()\n\n        # Handle united data, such as dates\n        self._process_unit_info(xdata=x, ydata=y1, kwargs=kwargs)\n        self._process_unit_info(ydata=y2)\n\n        # Convert the arrays so we can work with them\n        x = ma.masked_invalid(self.convert_xunits(x))\n        y1 = ma.masked_invalid(self.convert_yunits(y1))\n        y2 = ma.masked_invalid(self.convert_yunits(y2))\n\n        for name, array in [('x', x), ('y1', y1), ('y2', y2)]:\n            if array.ndim > 1:\n                raise ValueError('Input passed into argument \"%r\"' % name +\n                                 'is not 1-dimensional.')\n\n        if where is None:\n            where = True\n        else:\n            where = np.asarray(where, dtype=bool)\n            if where.size != x.size:\n                cbook.warn_deprecated(\n                    \"3.2\",\n                    message=\"The parameter where must have the same size as x \"\n                            \"in fill_between(). This will become an error in \"\n                            \"future versions of Matplotlib.\")\n        where = where & ~functools.reduce(np.logical_or,\n                                          map(np.ma.getmask, [x, y1, y2]))\n\n        x, y1, y2 = np.broadcast_arrays(np.atleast_1d(x), y1, y2)\n\n        polys = []\n        for ind0, ind1 in cbook.contiguous_regions(where):\n            xslice = x[ind0:ind1]\n            y1slice = y1[ind0:ind1]\n            y2slice = y2[ind0:ind1]\n            if step is not None:\n                step_func = cbook.STEP_LOOKUP_MAP[\"steps-\" + step]\n                xslice, y1slice, y2slice = step_func(xslice, y1slice, y2slice)\n\n            if not len(xslice):\n                continue\n\n            N = len(xslice)\n            X = np.zeros((2 * N + 2, 2), float)\n\n            if interpolate:\n                def get_interp_point(ind):\n                    im1 = max(ind - 1, 0)\n                    x_values = x[im1:ind + 1]\n                    diff_values = y1[im1:ind + 1] - y2[im1:ind + 1]\n                    y1_values = y1[im1:ind + 1]\n\n                    if len(diff_values) == 2:\n                        if np.ma.is_masked(diff_values[1]):\n                            return x[im1], y1[im1]\n                        elif np.ma.is_masked(diff_values[0]):\n                            return x[ind], y1[ind]\n\n                    diff_order = diff_values.argsort()\n                    diff_root_x = np.interp(\n                        0, diff_values[diff_order], x_values[diff_order])\n                    x_order = x_values.argsort()\n                    diff_root_y = np.interp(diff_root_x, x_values[x_order],\n                                            y1_values[x_order])\n                    return diff_root_x, diff_root_y\n\n                start = get_interp_point(ind0)\n                end = get_interp_point(ind1)\n            else:\n                # the purpose of the next two lines is for when y2 is a\n                # scalar like 0 and we want the fill to go all the way\n                # down to 0 even if none of the y1 sample points do\n                start = xslice[0], y2slice[0]\n                end = xslice[-1], y2slice[-1]\n\n            X[0] = start\n            X[N + 1] = end\n\n            X[1:N + 1, 0] = xslice\n            X[1:N + 1, 1] = y1slice\n            X[N + 2:, 0] = xslice[::-1]\n            X[N + 2:, 1] = y2slice[::-1]\n\n            polys.append(X)\n\n        collection = mcoll.PolyCollection(polys, **kwargs)\n\n        # now update the datalim and autoscale\n        XY1 = np.array([x[where], y1[where]]).T\n        XY2 = np.array([x[where], y2[where]]).T\n        self.dataLim.update_from_data_xy(XY1, self.ignore_existing_data_limits,\n                                         updatex=True, updatey=True)\n        self.ignore_existing_data_limits = False\n        self.dataLim.update_from_data_xy(XY2, self.ignore_existing_data_limits,\n                                         updatex=False, updatey=True)\n        self.add_collection(collection, autolim=False)\n        self._request_autoscale_view()\n        return collection",
        "begin_line": 5045,
        "end_line": 5230,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021867483052700635,
            "pseudo_dstar_susp": 0.00020048115477145148,
            "pseudo_tarantula_susp": 0.0002891008962127783,
            "pseudo_op2_susp": 0.00020048115477145148,
            "pseudo_barinel_susp": 0.0002891008962127783
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.get_interp_point#5179",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.get_interp_point(ind)",
        "snippet": "                def get_interp_point(ind):\n                    im1 = max(ind - 1, 0)\n                    x_values = x[im1:ind + 1]\n                    diff_values = y1[im1:ind + 1] - y2[im1:ind + 1]\n                    y1_values = y1[im1:ind + 1]\n\n                    if len(diff_values) == 2:\n                        if np.ma.is_masked(diff_values[1]):\n                            return x[im1], y1[im1]\n                        elif np.ma.is_masked(diff_values[0]):\n                            return x[ind], y1[ind]\n\n                    diff_order = diff_values.argsort()\n                    diff_root_x = np.interp(\n                        0, diff_values[diff_order], x_values[diff_order])\n                    x_order = x_values.argsort()\n                    diff_root_y = np.interp(diff_root_x, x_values[x_order],\n                                            y1_values[x_order])\n                    return diff_root_x, diff_root_y",
        "begin_line": 5179,
        "end_line": 5197,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.fill_betweenx#5234",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.fill_betweenx(self, y, x1, x2=0, where=None, step=None, interpolate=False, **kwargs)",
        "snippet": "    def fill_betweenx(self, y, x1, x2=0, where=None,\n                      step=None, interpolate=False, **kwargs):\n        \"\"\"\n        Fill the area between two vertical curves.\n\n        The curves are defined by the points (*x1*, *y*) and (*x2*, *y*). This\n        creates one or multiple polygons describing the filled area.\n\n        You may exclude some vertical sections from filling using *where*.\n\n        By default, the edges connect the given points directly. Use *step* if\n        the filling should be a step function, i.e. constant in between *y*.\n\n\n        Parameters\n        ----------\n        y : array (length N)\n            The y coordinates of the nodes defining the curves.\n\n        x1 : array (length N) or scalar\n            The x coordinates of the nodes defining the first curve.\n\n        x2 : array (length N) or scalar, optional, default: 0\n            The x coordinates of the nodes defining the second curve.\n\n        where : array of bool (length N), optional, default: None\n            Define *where* to exclude some vertical regions from being\n            filled. The filled regions are defined by the coordinates\n            ``y[where]``.  More precisely, fill between ``y[i]`` and ``y[i+1]``\n            if ``where[i] and where[i+1]``.  Note that this definition implies\n            that an isolated *True* value between two *False* values in\n            *where* will not result in filling.  Both sides of the *True*\n            position remain unfilled due to the adjacent *False* values.\n\n        interpolate : bool, optional\n            This option is only relevant if *where* is used and the two curves\n            are crossing each other.\n\n            Semantically, *where* is often used for *x1* > *x2* or similar.\n            By default, the nodes of the polygon defining the filled region\n            will only be placed at the positions in the *y* array.  Such a\n            polygon cannot describe the above semantics close to the\n            intersection.  The y-sections containing the intersection are\n            simply clipped.\n\n            Setting *interpolate* to *True* will calculate the actual\n            intersection point and extend the filled region up to this point.\n\n        step : {'pre', 'post', 'mid'}, optional\n            Define *step* if the filling should be a step function,\n            i.e. constant in between *y*. The value determines where the\n            step will occur:\n\n            - 'pre': The y value is continued constantly to the left from\n              every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the\n              value ``y[i]``.\n            - 'post': The y value is continued constantly to the right from\n              every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the\n              value ``y[i]``.\n            - 'mid': Steps occur half-way between the *x* positions.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            All other keyword arguments are passed on to `.PolyCollection`.\n            They control the `.Polygon` properties:\n\n            %(PolyCollection)s\n\n        Returns\n        -------\n        `.PolyCollection`\n            A `.PolyCollection` containing the plotted polygons.\n\n        See Also\n        --------\n        fill_between : Fill between two sets of y-values.\n\n        Notes\n        -----\n        .. [notes section required to get data note injection right]\n\n        \"\"\"\n        if not rcParams['_internal.classic_mode']:\n            kwargs = cbook.normalize_kwargs(kwargs, mcoll.Collection)\n            if not any(c in kwargs for c in ('color', 'facecolor')):\n                kwargs['facecolor'] = \\\n                    self._get_patches_for_fill.get_next_color()\n\n        # Handle united data, such as dates\n        self._process_unit_info(ydata=y, xdata=x1, kwargs=kwargs)\n        self._process_unit_info(xdata=x2)\n\n        # Convert the arrays so we can work with them\n        y = ma.masked_invalid(self.convert_yunits(y))\n        x1 = ma.masked_invalid(self.convert_xunits(x1))\n        x2 = ma.masked_invalid(self.convert_xunits(x2))\n\n        for name, array in [('y', y), ('x1', x1), ('x2', x2)]:\n            if array.ndim > 1:\n                raise ValueError('Input passed into argument \"%r\"' % name +\n                                 'is not 1-dimensional.')\n\n        if where is None:\n            where = True\n        else:\n            where = np.asarray(where, dtype=bool)\n            if where.size != y.size:\n                cbook.warn_deprecated(\n                    \"3.2\",\n                    message=\"The parameter where must have the same size as y \"\n                            \"in fill_between(). This will become an error in \"\n                            \"future versions of Matplotlib.\")\n        where = where & ~functools.reduce(np.logical_or,\n                                          map(np.ma.getmask, [y, x1, x2]))\n\n        y, x1, x2 = np.broadcast_arrays(np.atleast_1d(y), x1, x2)\n\n        polys = []\n        for ind0, ind1 in cbook.contiguous_regions(where):\n            yslice = y[ind0:ind1]\n            x1slice = x1[ind0:ind1]\n            x2slice = x2[ind0:ind1]\n            if step is not None:\n                step_func = cbook.STEP_LOOKUP_MAP[\"steps-\" + step]\n                yslice, x1slice, x2slice = step_func(yslice, x1slice, x2slice)\n\n            if not len(yslice):\n                continue\n\n            N = len(yslice)\n            Y = np.zeros((2 * N + 2, 2), float)\n            if interpolate:\n                def get_interp_point(ind):\n                    im1 = max(ind - 1, 0)\n                    y_values = y[im1:ind + 1]\n                    diff_values = x1[im1:ind + 1] - x2[im1:ind + 1]\n                    x1_values = x1[im1:ind + 1]\n\n                    if len(diff_values) == 2:\n                        if np.ma.is_masked(diff_values[1]):\n                            return x1[im1], y[im1]\n                        elif np.ma.is_masked(diff_values[0]):\n                            return x1[ind], y[ind]\n\n                    diff_order = diff_values.argsort()\n                    diff_root_y = np.interp(\n                        0, diff_values[diff_order], y_values[diff_order])\n                    y_order = y_values.argsort()\n                    diff_root_x = np.interp(diff_root_y, y_values[y_order],\n                                            x1_values[y_order])\n                    return diff_root_x, diff_root_y\n\n                start = get_interp_point(ind0)\n                end = get_interp_point(ind1)\n            else:\n                # the purpose of the next two lines is for when x2 is a\n                # scalar like 0 and we want the fill to go all the way\n                # down to 0 even if none of the x1 sample points do\n                start = x2slice[0], yslice[0]\n                end = x2slice[-1], yslice[-1]\n\n            Y[0] = start\n            Y[N + 1] = end\n\n            Y[1:N + 1, 0] = x1slice\n            Y[1:N + 1, 1] = yslice\n            Y[N + 2:, 0] = x2slice[::-1]\n            Y[N + 2:, 1] = yslice[::-1]\n\n            polys.append(Y)\n\n        collection = mcoll.PolyCollection(polys, **kwargs)\n\n        # now update the datalim and autoscale\n        X1Y = np.array([x1[where], y[where]]).T\n        X2Y = np.array([x2[where], y[where]]).T\n        self.dataLim.update_from_data_xy(X1Y, self.ignore_existing_data_limits,\n                                         updatex=True, updatey=True)\n        self.ignore_existing_data_limits = False\n        self.dataLim.update_from_data_xy(X2Y, self.ignore_existing_data_limits,\n                                         updatex=True, updatey=False)\n        self.add_collection(collection, autolim=False)\n        self._request_autoscale_view()\n        return collection",
        "begin_line": 5234,
        "end_line": 5418,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020889910173386254,
            "pseudo_dstar_susp": 0.00018846588767433095,
            "pseudo_tarantula_susp": 0.0003184713375796178,
            "pseudo_op2_susp": 0.00018846588767433095,
            "pseudo_barinel_susp": 0.0003184713375796178
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.get_interp_point#5367",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.get_interp_point(ind)",
        "snippet": "                def get_interp_point(ind):\n                    im1 = max(ind - 1, 0)\n                    y_values = y[im1:ind + 1]\n                    diff_values = x1[im1:ind + 1] - x2[im1:ind + 1]\n                    x1_values = x1[im1:ind + 1]\n\n                    if len(diff_values) == 2:\n                        if np.ma.is_masked(diff_values[1]):\n                            return x1[im1], y[im1]\n                        elif np.ma.is_masked(diff_values[0]):\n                            return x1[ind], y[ind]\n\n                    diff_order = diff_values.argsort()\n                    diff_root_y = np.interp(\n                        0, diff_values[diff_order], y_values[diff_order])\n                    y_order = y_values.argsort()\n                    diff_root_x = np.interp(diff_root_y, y_values[y_order],\n                                            x1_values[y_order])\n                    return diff_root_x, diff_root_y",
        "begin_line": 5367,
        "end_line": 5385,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.imshow#5424",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.imshow(self, X, cmap=None, norm=None, aspect=None, interpolation=None, alpha=None, vmin=None, vmax=None, origin=None, extent=None, shape=None, filternorm=1, filterrad=4.0, imlim=None, resample=None, url=None, **kwargs)",
        "snippet": "    def imshow(self, X, cmap=None, norm=None, aspect=None,\n               interpolation=None, alpha=None, vmin=None, vmax=None,\n               origin=None, extent=None, shape=None, filternorm=1,\n               filterrad=4.0, imlim=None, resample=None, url=None, **kwargs):\n        \"\"\"\n        Display data as an image; i.e. on a 2D regular raster.\n\n        The input may either be actual RGB(A) data, or 2D scalar data, which\n        will be rendered as a pseudocolor image. Note: For actually displaying\n        a grayscale image set up the color mapping using the parameters\n        ``cmap='gray', vmin=0, vmax=255``.\n\n        Parameters\n        ----------\n        X : array-like or PIL image\n            The image data. Supported array shapes are:\n\n            - (M, N): an image with scalar data. The values are mapped to\n              colors using normalization and a colormap. See parameters *norm*,\n              *cmap*, *vmin*, *vmax*.\n            - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).\n            - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),\n              i.e. including transparency.\n\n            The first two dimensions (M, N) define the rows and columns of\n            the image.\n\n            Out-of-range RGB(A) values are clipped.\n\n        cmap : str or `~matplotlib.colors.Colormap`, optional\n            The Colormap instance or registered colormap name used to map\n            scalar data to colors. This parameter is ignored for RGB(A) data.\n            Defaults to :rc:`image.cmap`.\n\n        norm : `~matplotlib.colors.Normalize`, optional\n            The `Normalize` instance used to scale scalar data to the [0, 1]\n            range before mapping to colors using *cmap*. By default, a linear\n            scaling mapping the lowest value to 0 and the highest to 1 is used.\n            This parameter is ignored for RGB(A) data.\n\n        aspect : {'equal', 'auto'} or float, optional\n            Controls the aspect ratio of the axes. The aspect is of particular\n            relevance for images since it may distort the image, i.e. pixel\n            will not be square.\n\n            This parameter is a shortcut for explicitly calling\n            `.Axes.set_aspect`. See there for further details.\n\n            - 'equal': Ensures an aspect ratio of 1. Pixels will be square\n              (unless pixel sizes are explicitly made non-square in data\n              coordinates using *extent*).\n            - 'auto': The axes is kept fixed and the aspect is adjusted so\n              that the data fit in the axes. In general, this will result in\n              non-square pixels.\n\n            If not given, use :rc:`image.aspect`.\n\n        interpolation : str, optional\n            The interpolation method used. If *None*, :rc:`image.interpolation`\n            is used.\n\n            Supported values are 'none', 'antialiased', 'nearest', 'bilinear',\n            'bicubic', 'spline16', 'spline36', 'hanning', 'hamming', 'hermite',\n            'kaiser', 'quadric', 'catrom', 'gaussian', 'bessel', 'mitchell',\n            'sinc', 'lanczos'.\n\n            If *interpolation* is 'none', then no interpolation is performed\n            on the Agg, ps, pdf and svg backends. Other backends will fall back\n            to 'nearest'. Note that most SVG renders perform interpolation at\n            rendering and that the default interpolation method they implement\n            may differ.\n\n            If *interpolation* is the default 'antialiased', then 'nearest'\n            interpolation is used if the image is upsampled by more than a\n            factor of three (i.e. the number of display pixels is at least\n            three times the size of the data array).  If the upsampling rate is\n            smaller than 3, or the image is downsampled, then 'hanning'\n            interpolation is used to act as an anti-aliasing filter, unless the\n            image happens to be upsampled by exactly a factor of two or one.\n\n            See\n            :doc:`/gallery/images_contours_and_fields/interpolation_methods`\n            for an overview of the supported interpolation methods, and\n            :doc:`/gallery/images_contours_and_fields/image_antialiasing` for\n            a discussion of image antialiasing.\n\n            Some interpolation methods require an additional radius parameter,\n            which can be set by *filterrad*. Additionally, the antigrain image\n            resize filter is controlled by the parameter *filternorm*.\n\n        alpha : scalar or array-like, optional\n            The alpha blending value, between 0 (transparent) and 1 (opaque).\n            If *alpha* is an array, the alpha blending values are applied pixel\n            by pixel, and *alpha* must have the same shape as *X*.\n\n        vmin, vmax : scalar, optional\n            When using scalar data and no explicit *norm*, *vmin* and *vmax*\n            define the data range that the colormap covers. By default,\n            the colormap covers the complete value range of the supplied\n            data. *vmin*, *vmax* are ignored if the *norm* parameter is used.\n\n        origin : {'upper', 'lower'}, optional\n            Place the [0, 0] index of the array in the upper left or lower left\n            corner of the axes. The convention 'upper' is typically used for\n            matrices and images.\n            If not given, :rc:`image.origin` is used, defaulting to 'upper'.\n\n            Note that the vertical axes points upward for 'lower'\n            but downward for 'upper'.\n\n            See the :doc:`/tutorials/intermediate/imshow_extent` tutorial for\n            examples and a more detailed description.\n\n        extent : scalars (left, right, bottom, top), optional\n            The bounding box in data coordinates that the image will fill.\n            The image is stretched individually along x and y to fill the box.\n\n            The default extent is determined by the following conditions.\n            Pixels have unit size in data coordinates. Their centers are on\n            integer coordinates, and their center coordinates range from 0 to\n            columns-1 horizontally and from 0 to rows-1 vertically.\n\n            Note that the direction of the vertical axis and thus the default\n            values for top and bottom depend on *origin*:\n\n            - For ``origin == 'upper'`` the default is\n              ``(-0.5, numcols-0.5, numrows-0.5, -0.5)``.\n            - For ``origin == 'lower'`` the default is\n              ``(-0.5, numcols-0.5, -0.5, numrows-0.5)``.\n\n            See the :doc:`/tutorials/intermediate/imshow_extent` tutorial for\n            examples and a more detailed description.\n\n        filternorm : bool, optional, default: True\n            A parameter for the antigrain image resize filter (see the\n            antigrain documentation).  If *filternorm* is set, the filter\n            normalizes integer values and corrects the rounding errors. It\n            doesn't do anything with the source floating point values, it\n            corrects only integers according to the rule of 1.0 which means\n            that any sum of pixel weights must be equal to 1.0.  So, the\n            filter function must produce a graph of the proper shape.\n\n        filterrad : float > 0, optional, default: 4.0\n            The filter radius for filters that have a radius parameter, i.e.\n            when interpolation is one of: 'sinc', 'lanczos' or 'blackman'.\n\n        resample : bool, optional\n            When *True*, use a full resampling method.  When *False*, only\n            resample when the output image is larger than the input image.\n\n        url : str, optional\n            Set the url of the created `.AxesImage`. See `.Artist.set_url`.\n\n        Returns\n        -------\n        image : `~matplotlib.image.AxesImage`\n\n        Other Parameters\n        ----------------\n        **kwargs : `~matplotlib.artist.Artist` properties\n            These parameters are passed on to the constructor of the\n            `.AxesImage` artist.\n\n        See also\n        --------\n        matshow : Plot a matrix or an array as an image.\n\n        Notes\n        -----\n        Unless *extent* is used, pixel centers will be located at integer\n        coordinates. In other words: the origin will coincide with the center\n        of pixel (0, 0).\n\n        There are two common representations for RGB images with an alpha\n        channel:\n\n        -   Straight (unassociated) alpha: R, G, and B channels represent the\n            color of the pixel, disregarding its opacity.\n        -   Premultiplied (associated) alpha: R, G, and B channels represent\n            the color of the pixel, adjusted for its opacity by multiplication.\n\n        `~matplotlib.pyplot.imshow` expects RGB images adopting the straight\n        (unassociated) alpha representation.\n        \"\"\"\n        if aspect is None:\n            aspect = rcParams['image.aspect']\n        self.set_aspect(aspect)\n        im = mimage.AxesImage(self, cmap, norm, interpolation, origin, extent,\n                              filternorm=filternorm, filterrad=filterrad,\n                              resample=resample, **kwargs)\n\n        im.set_data(X)\n        im.set_alpha(alpha)\n        if im.get_clip_path() is None:\n            # image does not already have clipping set, clip to axes patch\n            im.set_clip_path(self.patch)\n        if vmin is not None or vmax is not None:\n            im.set_clim(vmin, vmax)\n        else:\n            im.autoscale_None()\n        im.set_url(url)\n\n        # update ax.dataLim, and, if autoscaling, set viewLim\n        # to tightly fit the image, regardless of dataLim.\n        im.set_extent(im.get_extent())\n\n        self.add_image(im)\n        return im",
        "begin_line": 5424,
        "end_line": 5631,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016493485073396007,
            "pseudo_dstar_susp": 0.00021208907741251324,
            "pseudo_tarantula_susp": 0.0001273723092599669,
            "pseudo_op2_susp": 0.00021208907741251324,
            "pseudo_barinel_susp": 0.00012740476493820868
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes._pcolorargs#5634",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes._pcolorargs(funcname, *args, allmatch=False)",
        "snippet": "    def _pcolorargs(funcname, *args, allmatch=False):\n        # If allmatch is True, then the incoming X, Y, C must have matching\n        # dimensions, taking into account that X and Y can be 1-D rather than\n        # 2-D.  This perfect match is required for Gouraud shading.  For flat\n        # shading, X and Y specify boundaries, so we need one more boundary\n        # than color in each direction.  For convenience, and consistent with\n        # Matlab, we discard the last row and/or column of C if necessary to\n        # meet this condition.  This is done if allmatch is False.\n\n        if len(args) == 1:\n            C = np.asanyarray(args[0])\n            nrows, ncols = C.shape\n            if allmatch:\n                X, Y = np.meshgrid(np.arange(ncols), np.arange(nrows))\n            else:\n                X, Y = np.meshgrid(np.arange(ncols + 1), np.arange(nrows + 1))\n            C = cbook.safe_masked_invalid(C)\n            return X, Y, C\n\n        if len(args) == 3:\n            # Check x and y for bad data...\n            C = np.asanyarray(args[2])\n            X, Y = [cbook.safe_masked_invalid(a) for a in args[:2]]\n            if funcname == 'pcolormesh':\n                if np.ma.is_masked(X) or np.ma.is_masked(Y):\n                    raise ValueError(\n                        'x and y arguments to pcolormesh cannot have '\n                        'non-finite values or be of type '\n                        'numpy.ma.core.MaskedArray with masked values')\n                # safe_masked_invalid() returns an ndarray for dtypes other\n                # than floating point.\n                if isinstance(X, np.ma.core.MaskedArray):\n                    X = X.data  # strip mask as downstream doesn't like it...\n                if isinstance(Y, np.ma.core.MaskedArray):\n                    Y = Y.data\n            nrows, ncols = C.shape\n        else:\n            raise TypeError(\n                'Illegal arguments to %s; see help(%s)' % (funcname, funcname))\n\n        Nx = X.shape[-1]\n        Ny = Y.shape[0]\n        if X.ndim != 2 or X.shape[0] == 1:\n            x = X.reshape(1, Nx)\n            X = x.repeat(Ny, axis=0)\n        if Y.ndim != 2 or Y.shape[1] == 1:\n            y = Y.reshape(Ny, 1)\n            Y = y.repeat(Nx, axis=1)\n        if X.shape != Y.shape:\n            raise TypeError(\n                'Incompatible X, Y inputs to %s; see help(%s)' % (\n                funcname, funcname))\n        if allmatch:\n            if (Nx, Ny) != (ncols, nrows):\n                raise TypeError('Dimensions of C %s are incompatible with'\n                                ' X (%d) and/or Y (%d); see help(%s)' % (\n                                    C.shape, Nx, Ny, funcname))\n        else:\n            if not (ncols in (Nx, Nx - 1) and nrows in (Ny, Ny - 1)):\n                raise TypeError('Dimensions of C %s are incompatible with'\n                                ' X (%d) and/or Y (%d); see help(%s)' % (\n                                    C.shape, Nx, Ny, funcname))\n            C = C[:Ny - 1, :Nx - 1]\n        C = cbook.safe_masked_invalid(C)\n        return X, Y, C",
        "begin_line": 5634,
        "end_line": 5698,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020458265139116204,
            "pseudo_dstar_susp": 0.00023126734505087883,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00023126734505087883,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.pcolor#5702",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.pcolor(self, *args, alpha=None, norm=None, cmap=None, vmin=None, vmax=None, **kwargs)",
        "snippet": "    def pcolor(self, *args, alpha=None, norm=None, cmap=None, vmin=None,\n               vmax=None, **kwargs):\n        r\"\"\"\n        Create a pseudocolor plot with a non-regular rectangular grid.\n\n        Call signature::\n\n            pcolor([X, Y,] C, **kwargs)\n\n        *X* and *Y* can be used to specify the corners of the quadrilaterals.\n\n        .. hint::\n\n            ``pcolor()`` can be very slow for large arrays. In most\n            cases you should use the similar but much faster\n            `~.Axes.pcolormesh` instead. See there for a discussion of the\n            differences.\n\n        Parameters\n        ----------\n        C : array-like\n            A scalar 2-D array. The values will be color-mapped.\n\n        X, Y : array-like, optional\n            The coordinates of the quadrilateral corners. The quadrilateral\n            for ``C[i, j]`` has corners at::\n\n                (X[i+1, j], Y[i+1, j])           (X[i+1, j+1], Y[i+1, j+1])\n                                      +---------+\n                                      | C[i, j] |\n                                      +---------+\n                    (X[i, j], Y[i, j])           (X[i, j+1], Y[i, j+1])\n\n            Note that the column index corresponds to the\n            x-coordinate, and the row index corresponds to y. For\n            details, see the :ref:`Notes <axes-pcolor-grid-orientation>`\n            section below.\n\n            The dimensions of *X* and *Y* should be one greater than those of\n            *C*. Alternatively, *X*, *Y* and *C* may have equal dimensions, in\n            which case the last row and column of *C* will be ignored.\n\n            If *X* and/or *Y* are 1-D arrays or column vectors they will be\n            expanded as needed into the appropriate 2-D arrays, making a\n            rectangular grid.\n\n        cmap : str or `~matplotlib.colors.Colormap`, optional\n            A Colormap instance or registered colormap name. The colormap\n            maps the *C* values to colors. Defaults to :rc:`image.cmap`.\n\n        norm : `~matplotlib.colors.Normalize`, optional\n            The Normalize instance scales the data values to the canonical\n            colormap range [0, 1] for mapping to colors. By default, the data\n            range is mapped to the colorbar range using linear scaling.\n\n        vmin, vmax : scalar, optional, default: None\n            The colorbar range. If *None*, suitable min/max values are\n            automatically chosen by the `~.Normalize` instance (defaults to\n            the respective min/max values of *C* in case of the default linear\n            scaling).\n\n        edgecolors : {'none', None, 'face', color, color sequence}, optional\n            The color of the edges. Defaults to 'none'. Possible values:\n\n            - 'none' or '': No edge.\n            - *None*: :rc:`patch.edgecolor` will be used. Note that currently\n              :rc:`patch.force_edgecolor` has to be True for this to work.\n            - 'face': Use the adjacent face color.\n            - A color or sequence of colors will set the edge color.\n\n            The singular form *edgecolor* works as an alias.\n\n        alpha : scalar, optional, default: None\n            The alpha blending value of the face color, between 0 (transparent)\n            and 1 (opaque). Note: The edgecolor is currently not affected by\n            this.\n\n        snap : bool, optional, default: False\n            Whether to snap the mesh to pixel boundaries.\n\n        Returns\n        -------\n        collection : `matplotlib.collections.Collection`\n\n        Other Parameters\n        ----------------\n        antialiaseds : bool, optional, default: False\n            The default *antialiaseds* is False if the default\n            *edgecolors*\\ =\"none\" is used.  This eliminates artificial lines\n            at patch boundaries, and works regardless of the value of alpha.\n            If *edgecolors* is not \"none\", then the default *antialiaseds*\n            is taken from :rc:`patch.antialiased`.\n            Stroking the edges may be preferred if *alpha* is 1, but will\n            cause artifacts otherwise.\n\n        **kwargs\n            Additionally, the following arguments are allowed. They are passed\n            along to the `~matplotlib.collections.PolyCollection` constructor:\n\n        %(PolyCollection)s\n\n        See Also\n        --------\n        pcolormesh : for an explanation of the differences between\n            pcolor and pcolormesh.\n        imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a\n            faster alternative.\n\n        Notes\n        -----\n        **Masked arrays**\n\n        *X*, *Y* and *C* may be masked arrays. If either ``C[i, j]``, or one\n        of the vertices surrounding ``C[i, j]`` (*X* or *Y* at\n        ``[i, j], [i+1, j], [i, j+1], [i+1, j+1]``) is masked, nothing is\n        plotted.\n\n        .. _axes-pcolor-grid-orientation:\n\n        **Grid orientation**\n\n        The grid orientation follows the standard matrix convention: An array\n        *C* with shape (nrows, ncolumns) is plotted with the column number as\n        *X* and the row number as *Y*.\n\n        **Handling of pcolor() end-cases**\n\n        ``pcolor()`` displays all columns of *C* if *X* and *Y* are not\n        specified, or if *X* and *Y* have one more column than *C*.\n        If *X* and *Y* have the same number of columns as *C* then the last\n        column of *C* is dropped. Similarly for the rows.\n\n        Note: This behavior is different from MATLAB's ``pcolor()``, which\n        always discards the last row and column of *C*.\n        \"\"\"\n        X, Y, C = self._pcolorargs('pcolor', *args, allmatch=False)\n        Ny, Nx = X.shape\n\n        # unit conversion allows e.g. datetime objects as axis values\n        self._process_unit_info(xdata=X, ydata=Y, kwargs=kwargs)\n        X = self.convert_xunits(X)\n        Y = self.convert_yunits(Y)\n\n        # convert to MA, if necessary.\n        C = ma.asarray(C)\n        X = ma.asarray(X)\n        Y = ma.asarray(Y)\n\n        mask = ma.getmaskarray(X) + ma.getmaskarray(Y)\n        xymask = (mask[0:-1, 0:-1] + mask[1:, 1:] +\n                  mask[0:-1, 1:] + mask[1:, 0:-1])\n        # don't plot if C or any of the surrounding vertices are masked.\n        mask = ma.getmaskarray(C) + xymask\n\n        unmask = ~mask\n        X1 = ma.filled(X[:-1, :-1])[unmask]\n        Y1 = ma.filled(Y[:-1, :-1])[unmask]\n        X2 = ma.filled(X[1:, :-1])[unmask]\n        Y2 = ma.filled(Y[1:, :-1])[unmask]\n        X3 = ma.filled(X[1:, 1:])[unmask]\n        Y3 = ma.filled(Y[1:, 1:])[unmask]\n        X4 = ma.filled(X[:-1, 1:])[unmask]\n        Y4 = ma.filled(Y[:-1, 1:])[unmask]\n        npoly = len(X1)\n\n        xy = np.stack([X1, Y1, X2, Y2, X3, Y3, X4, Y4, X1, Y1], axis=-1)\n        verts = xy.reshape((npoly, 5, 2))\n\n        C = ma.filled(C[:Ny - 1, :Nx - 1])[unmask]\n\n        linewidths = (0.25,)\n        if 'linewidth' in kwargs:\n            kwargs['linewidths'] = kwargs.pop('linewidth')\n        kwargs.setdefault('linewidths', linewidths)\n\n        if 'edgecolor' in kwargs:\n            kwargs['edgecolors'] = kwargs.pop('edgecolor')\n        ec = kwargs.setdefault('edgecolors', 'none')\n\n        # aa setting will default via collections to patch.antialiased\n        # unless the boundary is not stroked, in which case the\n        # default will be False; with unstroked boundaries, aa\n        # makes artifacts that are often disturbing.\n        if 'antialiased' in kwargs:\n            kwargs['antialiaseds'] = kwargs.pop('antialiased')\n        if 'antialiaseds' not in kwargs and cbook._str_lower_equal(ec, \"none\"):\n            kwargs['antialiaseds'] = False\n\n        kwargs.setdefault('snap', False)\n\n        collection = mcoll.PolyCollection(verts, **kwargs)\n\n        collection.set_alpha(alpha)\n        collection.set_array(C)\n        collection.set_cmap(cmap)\n        collection.set_norm(norm)\n        collection.set_clim(vmin, vmax)\n        collection.autoscale_None()\n        self.grid(False)\n\n        x = X.compressed()\n        y = Y.compressed()\n\n        # Transform from native to data coordinates?\n        t = collection._transform\n        if (not isinstance(t, mtransforms.Transform) and\n            hasattr(t, '_as_mpl_transform')):\n            t = t._as_mpl_transform(self.axes)\n\n        if t and any(t.contains_branch_seperately(self.transData)):\n            trans_to_data = t - self.transData\n            pts = np.vstack([x, y]).T.astype(float)\n            transformed_pts = trans_to_data.transform(pts)\n            x = transformed_pts[..., 0]\n            y = transformed_pts[..., 1]\n\n        self.add_collection(collection, autolim=False)\n\n        minx = np.min(x)\n        maxx = np.max(x)\n        miny = np.min(y)\n        maxy = np.max(y)\n        collection.sticky_edges.x[:] = [minx, maxx]\n        collection.sticky_edges.y[:] = [miny, maxy]\n        corners = (minx, miny), (maxx, maxy)\n        self.update_datalim(corners)\n        self._request_autoscale_view()\n        return collection",
        "begin_line": 5702,
        "end_line": 5929,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001380071763731714,
            "pseudo_dstar_susp": 0.00013869625520110957,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00013869625520110957,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.pcolormesh#5933",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.pcolormesh(self, *args, alpha=None, norm=None, cmap=None, vmin=None, vmax=None, shading='flat', antialiased=False, **kwargs)",
        "snippet": "    def pcolormesh(self, *args, alpha=None, norm=None, cmap=None, vmin=None,\n                   vmax=None, shading='flat', antialiased=False, **kwargs):\n        \"\"\"\n        Create a pseudocolor plot with a non-regular rectangular grid.\n\n        Call signature::\n\n            pcolor([X, Y,] C, **kwargs)\n\n        *X* and *Y* can be used to specify the corners of the quadrilaterals.\n\n        .. note::\n\n           `~Axes.pcolormesh` is similar to `~Axes.pcolor`. It's much faster\n           and preferred in most cases. For a detailed discussion on the\n           differences see :ref:`Differences between pcolor() and pcolormesh()\n           <differences-pcolor-pcolormesh>`.\n\n        Parameters\n        ----------\n        C : array-like\n            A scalar 2-D array. The values will be color-mapped.\n\n        X, Y : array-like, optional\n            The coordinates of the quadrilateral corners. The quadrilateral\n            for ``C[i, j]`` has corners at::\n\n                (X[i+1, j], Y[i+1, j])           (X[i+1, j+1], Y[i+1, j+1])\n                                      +---------+\n                                      | C[i, j] |\n                                      +---------+\n                    (X[i, j], Y[i, j])           (X[i, j+1], Y[i, j+1])\n\n            Note that the column index corresponds to the\n            x-coordinate, and the row index corresponds to y. For\n            details, see the :ref:`Notes <axes-pcolormesh-grid-orientation>`\n            section below.\n\n            The dimensions of *X* and *Y* should be one greater than those of\n            *C*. Alternatively, *X*, *Y* and *C* may have equal dimensions, in\n            which case the last row and column of *C* will be ignored.\n\n            If *X* and/or *Y* are 1-D arrays or column vectors they will be\n            expanded as needed into the appropriate 2-D arrays, making a\n            rectangular grid.\n\n        cmap : str or `~matplotlib.colors.Colormap`, optional\n            A Colormap instance or registered colormap name. The colormap\n            maps the *C* values to colors. Defaults to :rc:`image.cmap`.\n\n        norm : `~matplotlib.colors.Normalize`, optional\n            The Normalize instance scales the data values to the canonical\n            colormap range [0, 1] for mapping to colors. By default, the data\n            range is mapped to the colorbar range using linear scaling.\n\n        vmin, vmax : scalar, optional, default: None\n            The colorbar range. If *None*, suitable min/max values are\n            automatically chosen by the `~.Normalize` instance (defaults to\n            the respective min/max values of *C* in case of the default linear\n            scaling).\n\n        edgecolors : {'none', None, 'face', color, color sequence}, optional\n            The color of the edges. Defaults to 'none'. Possible values:\n\n            - 'none' or '': No edge.\n            - *None*: :rc:`patch.edgecolor` will be used. Note that currently\n              :rc:`patch.force_edgecolor` has to be True for this to work.\n            - 'face': Use the adjacent face color.\n            - A color or sequence of colors will set the edge color.\n\n            The singular form *edgecolor* works as an alias.\n\n        alpha : scalar, optional, default: None\n            The alpha blending value, between 0 (transparent) and 1 (opaque).\n\n        shading : {'flat', 'gouraud'}, optional\n            The fill style, Possible values:\n\n            - 'flat': A solid color is used for each quad. The color of the\n              quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by\n              ``C[i, j]``.\n            - 'gouraud': Each quad will be Gouraud shaded: The color of the\n              corners (i', j') are given by ``C[i',j']``. The color values of\n              the area in between is interpolated from the corner values.\n              When Gouraud shading is used, *edgecolors* is ignored.\n\n        snap : bool, optional, default: False\n            Whether to snap the mesh to pixel boundaries.\n\n        Returns\n        -------\n        mesh : `matplotlib.collections.QuadMesh`\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Additionally, the following arguments are allowed. They are passed\n            along to the `~matplotlib.collections.QuadMesh` constructor:\n\n        %(QuadMesh)s\n\n        See Also\n        --------\n        pcolor : An alternative implementation with slightly different\n            features. For a detailed discussion on the differences see\n            :ref:`Differences between pcolor() and pcolormesh()\n            <differences-pcolor-pcolormesh>`.\n        imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a\n            faster alternative.\n\n        Notes\n        -----\n        **Masked arrays**\n\n        *C* may be a masked array. If ``C[i, j]`` is masked, the corresponding\n        quadrilateral will be transparent. Masking of *X* and *Y* is not\n        supported. Use `~.Axes.pcolor` if you need this functionality.\n\n        .. _axes-pcolormesh-grid-orientation:\n\n        **Grid orientation**\n\n        The grid orientation follows the standard matrix convention: An array\n        *C* with shape (nrows, ncolumns) is plotted with the column number as\n        *X* and the row number as *Y*.\n\n        .. _differences-pcolor-pcolormesh:\n\n        **Differences between pcolor() and pcolormesh()**\n\n        Both methods are used to create a pseudocolor plot of a 2-D array\n        using quadrilaterals.\n\n        The main difference lies in the created object and internal data\n        handling:\n        While `~.Axes.pcolor` returns a `.PolyCollection`, `~.Axes.pcolormesh`\n        returns a `.QuadMesh`. The latter is more specialized for the given\n        purpose and thus is faster. It should almost always be preferred.\n\n        There is also a slight difference in the handling of masked arrays.\n        Both `~.Axes.pcolor` and `~.Axes.pcolormesh` support masked arrays\n        for *C*. However, only `~.Axes.pcolor` supports masked arrays for *X*\n        and *Y*. The reason lies in the internal handling of the masked values.\n        `~.Axes.pcolor` leaves out the respective polygons from the\n        PolyCollection. `~.Axes.pcolormesh` sets the facecolor of the masked\n        elements to transparent. You can see the difference when using\n        edgecolors. While all edges are drawn irrespective of masking in a\n        QuadMesh, the edge between two adjacent masked quadrilaterals in\n        `~.Axes.pcolor` is not drawn as the corresponding polygons do not\n        exist in the PolyCollection.\n\n        Another difference is the support of Gouraud shading in\n        `~.Axes.pcolormesh`, which is not available with `~.Axes.pcolor`.\n\n        \"\"\"\n        shading = shading.lower()\n        kwargs.setdefault('edgecolors', 'None')\n\n        allmatch = (shading == 'gouraud')\n\n        X, Y, C = self._pcolorargs('pcolormesh', *args, allmatch=allmatch)\n        Ny, Nx = X.shape\n        X = X.ravel()\n        Y = Y.ravel()\n        # unit conversion allows e.g. datetime objects as axis values\n        self._process_unit_info(xdata=X, ydata=Y, kwargs=kwargs)\n        X = self.convert_xunits(X)\n        Y = self.convert_yunits(Y)\n\n        # convert to one dimensional arrays\n        C = C.ravel()\n        coords = np.column_stack((X, Y)).astype(float, copy=False)\n        collection = mcoll.QuadMesh(Nx - 1, Ny - 1, coords,\n                                    antialiased=antialiased, shading=shading,\n                                    **kwargs)\n        collection.set_alpha(alpha)\n        collection.set_array(C)\n        collection.set_cmap(cmap)\n        collection.set_norm(norm)\n        collection.set_clim(vmin, vmax)\n        collection.autoscale_None()\n\n        self.grid(False)\n\n        # Transform from native to data coordinates?\n        t = collection._transform\n        if (not isinstance(t, mtransforms.Transform) and\n            hasattr(t, '_as_mpl_transform')):\n            t = t._as_mpl_transform(self.axes)\n\n        if t and any(t.contains_branch_seperately(self.transData)):\n            trans_to_data = t - self.transData\n            coords = trans_to_data.transform(coords)\n\n        self.add_collection(collection, autolim=False)\n\n        minx, miny = np.min(coords, axis=0)\n        maxx, maxy = np.max(coords, axis=0)\n        collection.sticky_edges.x[:] = [minx, maxx]\n        collection.sticky_edges.y[:] = [miny, maxy]\n        corners = (minx, miny), (maxx, maxy)\n        self.update_datalim(corners)\n        self._request_autoscale_view()\n        return collection",
        "begin_line": 5933,
        "end_line": 6136,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020496003279360525,
            "pseudo_dstar_susp": 0.00022930520522815867,
            "pseudo_tarantula_susp": 0.00017605633802816902,
            "pseudo_op2_susp": 0.00022930520522815867,
            "pseudo_barinel_susp": 0.00017605633802816902
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.pcolorfast#6140",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.pcolorfast(self, *args, alpha=None, norm=None, cmap=None, vmin=None, vmax=None, **kwargs)",
        "snippet": "    def pcolorfast(self, *args, alpha=None, norm=None, cmap=None, vmin=None,\n                   vmax=None, **kwargs):\n        \"\"\"\n        Create a pseudocolor plot with a non-regular rectangular grid.\n\n        Call signature::\n\n          ax.pcolorfast([X, Y], C, /, **kwargs)\n\n        This method is similar to ~.Axes.pcolor` and `~.Axes.pcolormesh`.\n        It's designed to provide the fastest pcolor-type plotting with the\n        Agg backend. To achieve this, it uses different algorithms internally\n        depending on the complexity of the input grid (regular rectangular,\n        non-regular rectangular or arbitrary quadrilateral).\n\n        .. warning::\n\n           This method is experimental. Compared to `~.Axes.pcolor` or\n           `~.Axes.pcolormesh` it has some limitations:\n\n           - It supports only flat shading (no outlines)\n           - It lacks support for log scaling of the axes.\n           - It does not have a have a pyplot wrapper.\n\n        Parameters\n        ----------\n        C : array-like(M, N)\n            The image data. Supported array shapes are:\n\n            - (M, N): an image with scalar data. The data is visualized\n              using a colormap.\n            - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).\n            - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),\n              i.e. including transparency.\n\n            The first two dimensions (M, N) define the rows and columns of\n            the image.\n\n            This parameter can only be passed positionally.\n\n        X, Y : tuple or array-like, default: ``(0, N)``, ``(0, M)``\n            *X* and *Y* are used to specify the coordinates of the\n            quadrilaterals. There are different ways to do this:\n\n            - Use tuples ``X=(xmin, xmax)`` and ``Y=(ymin, ymax)`` to define\n              a *uniform rectangular grid*.\n\n              The tuples define the outer edges of the grid. All individual\n              quadrilaterals will be of the same size. This is the fastest\n              version.\n\n            - Use 1D arrays *X*, *Y* to specify a *non-uniform rectangular\n              grid*.\n\n              In this case *X* and *Y* have to be monotonic 1D arrays of length\n              *N+1* and *M+1*, specifying the x and y boundaries of the cells.\n\n              The speed is intermediate. Note: The grid is checked, and if\n              found to be uniform the fast version is used.\n\n            - Use 2D arrays *X*, *Y* if you need an *arbitrary quadrilateral\n              grid* (i.e. if the quadrilaterals are not rectangular).\n\n              In this case *X* and *Y* are 2D arrays with shape (M + 1, N + 1),\n              specifying the x and y coordinates of the corners of the colored\n              quadrilaterals.\n\n              This is the most general, but the slowest to render.  It may\n              produce faster and more compact output using ps, pdf, and\n              svg backends, however.\n\n            These arguments can only be passed positionally.\n\n        cmap : str or `~matplotlib.colors.Colormap`, optional\n            A Colormap instance or registered colormap name. The colormap\n            maps the *C* values to colors. Defaults to :rc:`image.cmap`.\n\n        norm : `~matplotlib.colors.Normalize`, optional\n            The Normalize instance scales the data values to the canonical\n            colormap range [0, 1] for mapping to colors. By default, the data\n            range is mapped to the colorbar range using linear scaling.\n\n        vmin, vmax : scalar, optional, default: None\n            The colorbar range. If *None*, suitable min/max values are\n            automatically chosen by the `~.Normalize` instance (defaults to\n            the respective min/max values of *C* in case of the default linear\n            scaling).\n\n        alpha : scalar, optional, default: None\n            The alpha blending value, between 0 (transparent) and 1 (opaque).\n\n        snap : bool, optional, default: False\n            Whether to snap the mesh to pixel boundaries.\n\n        Returns\n        -------\n        image : `.AxesImage` or `.PcolorImage` or `.QuadMesh`\n            The return type depends on the type of grid:\n\n            - `.AxesImage` for a regular rectangular grid.\n            - `.PcolorImage` for a non-regular rectangular grid.\n            - `.QuadMesh` for a non-rectangular grid.\n\n        Notes\n        -----\n        .. [notes section required to get data note injection right]\n        \"\"\"\n\n        C = args[-1]\n        nr, nc = np.shape(C)[:2]\n        if len(args) == 1:\n            style = \"image\"\n            x = [0, nc]\n            y = [0, nr]\n        elif len(args) == 3:\n            x, y = args[:2]\n            x = np.asarray(x)\n            y = np.asarray(y)\n            if x.ndim == 1 and y.ndim == 1:\n                if x.size == 2 and y.size == 2:\n                    style = \"image\"\n                else:\n                    dx = np.diff(x)\n                    dy = np.diff(y)\n                    if (np.ptp(dx) < 0.01 * np.abs(dx.mean()) and\n                        np.ptp(dy) < 0.01 * np.abs(dy.mean())):\n                        style = \"image\"\n                    else:\n                        style = \"pcolorimage\"\n            elif x.ndim == 2 and y.ndim == 2:\n                style = \"quadmesh\"\n            else:\n                raise TypeError(\"arguments do not match valid signatures\")\n        else:\n            raise TypeError(\"need 1 argument or 3 arguments\")\n\n        if style == \"quadmesh\":\n            # data point in each cell is value at lower left corner\n            coords = np.stack([x, y], axis=-1)\n            if np.ndim(C) == 2:\n                qm_kwargs = {\"array\": np.ma.ravel(C)}\n            elif np.ndim(C) == 3:\n                qm_kwargs = {\"color\": np.ma.reshape(C, (-1, C.shape[-1]))}\n            else:\n                raise ValueError(\"C must be 2D or 3D\")\n            collection = mcoll.QuadMesh(\n                nc, nr, coords, **qm_kwargs,\n                alpha=alpha, cmap=cmap, norm=norm,\n                antialiased=False, edgecolors=\"none\")\n            self.add_collection(collection, autolim=False)\n            xl, xr, yb, yt = x.min(), x.max(), y.min(), y.max()\n            ret = collection\n\n        else:  # It's one of the two image styles.\n            extent = xl, xr, yb, yt = x[0], x[-1], y[0], y[-1]\n            if style == \"image\":\n                im = mimage.AxesImage(\n                    self, cmap, norm,\n                    data=C, alpha=alpha, extent=extent,\n                    interpolation='nearest', origin='lower',\n                    **kwargs)\n            elif style == \"pcolorimage\":\n                im = mimage.PcolorImage(\n                    self, x, y, C,\n                    cmap=cmap, norm=norm, alpha=alpha, extent=extent,\n                    **kwargs)\n            self.add_image(im)\n            ret = im\n\n        if vmin is not None or vmax is not None:\n            ret.set_clim(vmin, vmax)\n        elif np.ndim(C) == 2:  # C.ndim == 3 is RGB(A) so doesn't need scaling.\n            ret.autoscale_None()\n        if ret.get_clip_path() is None:\n            # image does not already have clipping set, clip to axes patch\n            ret.set_clip_path(self.patch)\n\n        ret.sticky_edges.x[:] = [xl, xr]\n        ret.sticky_edges.y[:] = [yb, yt]\n        self.update_datalim(np.array([[xl, yb], [xr, yt]]))\n        self._request_autoscale_view(tight=True)\n        return ret",
        "begin_line": 6140,
        "end_line": 6321,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.contour#6324",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.contour(self, *args, **kwargs)",
        "snippet": "    def contour(self, *args, **kwargs):\n        kwargs['filled'] = False\n        contours = mcontour.QuadContourSet(self, *args, **kwargs)\n        self._request_autoscale_view()\n        return contours",
        "begin_line": 6324,
        "end_line": 6328,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019638648860958367,
            "pseudo_dstar_susp": 0.00019584802193497845,
            "pseudo_tarantula_susp": 0.00022411474675033618,
            "pseudo_op2_susp": 0.00019584802193497845,
            "pseudo_barinel_susp": 0.00022411474675033618
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.contourf#6332",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.contourf(self, *args, **kwargs)",
        "snippet": "    def contourf(self, *args, **kwargs):\n        kwargs['filled'] = True\n        contours = mcontour.QuadContourSet(self, *args, **kwargs)\n        self._request_autoscale_view()\n        return contours",
        "begin_line": 6332,
        "end_line": 6336,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015595757953836556,
            "pseudo_dstar_susp": 0.00015895724050230488,
            "pseudo_tarantula_susp": 0.00017739932588256165,
            "pseudo_op2_susp": 0.00015895724050230488,
            "pseudo_barinel_susp": 0.00017739932588256165
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.clabel#6339",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.clabel(self, CS, *args, **kwargs)",
        "snippet": "    def clabel(self, CS, *args, **kwargs):\n        return CS.clabel(*args, **kwargs)",
        "begin_line": 6339,
        "end_line": 6340,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018463810930576072,
            "pseudo_dstar_susp": 0.00016136840406648378,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00016136840406648378,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.hist#6346",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.hist(self, x, bins=None, range=None, density=False, weights=None, cumulative=False, bottom=None, histtype='bar', align='mid', orientation='vertical', rwidth=None, log=False, color=None, label=None, stacked=False, **kwargs)",
        "snippet": "    def hist(self, x, bins=None, range=None, density=False, weights=None,\n             cumulative=False, bottom=None, histtype='bar', align='mid',\n             orientation='vertical', rwidth=None, log=False,\n             color=None, label=None, stacked=False, **kwargs):\n        \"\"\"\n        Plot a histogram.\n\n        Compute and draw the histogram of *x*.  The return value is a tuple\n        (*n*, *bins*, *patches*) or ([*n0*, *n1*, ...], *bins*, [*patches0*,\n        *patches1*,...]) if the input contains multiple data.  See the\n        documentation of the *weights* parameter to draw a histogram of\n        already-binned data.\n\n        Multiple data can be provided via *x* as a list of datasets\n        of potentially different length ([*x0*, *x1*, ...]), or as\n        a 2-D ndarray in which each column is a dataset.  Note that\n        the ndarray form is transposed relative to the list form.\n\n        Masked arrays are not supported.\n\n        The *bins*, *range*, *weights*, and *density* parameters behave as in\n        `numpy.histogram`.\n\n        Parameters\n        ----------\n        x : (n,) array or sequence of (n,) arrays\n            Input values, this takes either a single array or a sequence of\n            arrays which are not required to be of the same length.\n\n        bins : int or sequence or str, optional\n            If *bins* is an integer, it defines the number of equal-width bins\n            in the range.\n\n            If *bins* is a sequence, it defines the bin edges, including the\n            left edge of the first bin and the right edge of the last bin;\n            in this case, bins may be unequally spaced.  All but the last\n            (righthand-most) bin is half-open.  In other words, if *bins* is::\n\n                [1, 2, 3, 4]\n\n            then the first bin is ``[1, 2)`` (including 1, but excluding 2) and\n            the second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which\n            *includes* 4.\n\n            If *bins* is a string, it is one of the binning strategies\n            supported by `numpy.histogram_bin_edges`: 'auto', 'fd', 'doane',\n            'scott', 'stone', 'rice', 'sturges', or 'sqrt'.\n\n            The default is :rc:`hist.bins`.\n\n        range : tuple or None, optional\n            The lower and upper range of the bins. Lower and upper outliers\n            are ignored. If not provided, *range* is ``(x.min(), x.max())``.\n            Range has no effect if *bins* is a sequence.\n\n            If *bins* is a sequence or *range* is specified, autoscaling\n            is based on the specified bin range instead of the\n            range of x.\n\n            Default is ``None``\n\n        density : bool, optional\n            If ``True``, the first element of the return tuple will\n            be the counts normalized to form a probability density, i.e.,\n            the area (or integral) under the histogram will sum to 1.\n            This is achieved by dividing the count by the number of\n            observations times the bin width and not dividing by the total\n            number of observations. If *stacked* is also ``True``, the sum of\n            the histograms is normalized to 1.\n\n            Default is ``False``.\n\n        weights : (n, ) array-like or None, optional\n            An array of weights, of the same shape as *x*.  Each value in *x*\n            only contributes its associated weight towards the bin count\n            (instead of 1).  If *normed* or *density* is ``True``,\n            the weights are normalized, so that the integral of the density\n            over the range remains 1.\n\n            Default is ``None``.\n\n            This parameter can be used to draw a histogram of data that has\n            already been binned, e.g. using `np.histogram` (by treating each\n            bin as a single point with a weight equal to its count) ::\n\n                counts, bins = np.histogram(data)\n                plt.hist(bins[:-1], bins, weights=counts)\n\n            (or you may alternatively use `~.bar()`).\n\n        cumulative : bool or -1, optional\n            If ``True``, then a histogram is computed where each bin gives the\n            counts in that bin plus all bins for smaller values. The last bin\n            gives the total number of datapoints.\n\n            If *density* is also ``True`` then the histogram is normalized such\n            that the last bin equals 1.\n\n            If *cumulative* is a number less than 0 (e.g., -1), the direction\n            of accumulation is reversed.  In this case, if *density* is also\n            ``True``, then the histogram is normalized such that the first bin\n            equals 1.\n\n            Default is ``False``\n\n        bottom : array-like, scalar, or None\n            Location of the bottom baseline of each bin.  If a scalar,\n            the base line for each bin is shifted by the same amount.\n            If an array, each bin is shifted independently and the length\n            of bottom must match the number of bins.  If None, defaults to 0.\n\n            Default is ``None``\n\n        histtype : {'bar', 'barstacked', 'step',  'stepfilled'}, optional\n            The type of histogram to draw.\n\n            - 'bar' is a traditional bar-type histogram.  If multiple data\n              are given the bars are arranged side by side.\n            - 'barstacked' is a bar-type histogram where multiple\n              data are stacked on top of each other.\n            - 'step' generates a lineplot that is by default unfilled.\n            - 'stepfilled' generates a lineplot that is by default filled.\n\n            Default is 'bar'\n\n        align : {'left', 'mid', 'right'}, optional\n            Controls how the histogram is plotted.\n\n            - 'left': bars are centered on the left bin edges.\n            - 'mid': bars are centered between the bin edges.\n            - 'right': bars are centered on the right bin edges.\n\n            Default is 'mid'\n\n        orientation : {'horizontal', 'vertical'}, optional\n            If 'horizontal', `~matplotlib.pyplot.barh` will be used for\n            bar-type histograms and the *bottom* kwarg will be the left edges.\n\n        rwidth : scalar or None, optional\n            The relative width of the bars as a fraction of the bin width.  If\n            ``None``, automatically compute the width.\n\n            Ignored if *histtype* is 'step' or 'stepfilled'.\n\n            Default is ``None``\n\n        log : bool, optional\n            If ``True``, the histogram axis will be set to a log scale. If\n            *log* is ``True`` and *x* is a 1D array, empty bins will be\n            filtered out and only the non-empty ``(n, bins, patches)``\n            will be returned.\n\n            Default is ``False``\n\n        color : color or array-like of colors or None, optional\n            Color or sequence of colors, one per dataset.  Default (``None``)\n            uses the standard line color sequence.\n\n            Default is ``None``\n\n        label : str or None, optional\n            String, or sequence of strings to match multiple datasets.  Bar\n            charts yield multiple patches per dataset, but only the first gets\n            the label, so that the legend command will work as expected.\n\n            default is ``None``\n\n        stacked : bool, optional\n            If ``True``, multiple data are stacked on top of each other If\n            ``False`` multiple data are arranged side by side if histtype is\n            'bar' or on top of each other if histtype is 'step'\n\n            Default is ``False``\n\n        Returns\n        -------\n        n : array or list of arrays\n            The values of the histogram bins. See *density* and *weights* for a\n            description of the possible semantics.  If input *x* is an array,\n            then this is an array of length *nbins*. If input is a sequence of\n            arrays ``[data1, data2, ...]``, then this is a list of arrays with\n            the values of the histograms for each of the arrays in the same\n            order.  The dtype of the array *n* (or of its element arrays) will\n            always be float even if no weighting or normalization is used.\n\n        bins : array\n            The edges of the bins. Length nbins + 1 (nbins left edges and right\n            edge of last bin).  Always a single array even when multiple data\n            sets are passed in.\n\n        patches : list or list of lists\n            Silent list of individual patches used to create the histogram\n            or list of such list if multiple input datasets.\n\n        Other Parameters\n        ----------------\n        **kwargs : `~matplotlib.patches.Patch` properties\n\n        See also\n        --------\n        hist2d : 2D histograms\n\n        \"\"\"\n        # Avoid shadowing the builtin.\n        bin_range = range\n        from builtins import range\n\n        if np.isscalar(x):\n            x = [x]\n\n        if bins is None:\n            bins = rcParams['hist.bins']\n\n        # Validate string inputs here to avoid cluttering subsequent code.\n        cbook._check_in_list(['bar', 'barstacked', 'step', 'stepfilled'],\n                             histtype=histtype)\n        cbook._check_in_list(['left', 'mid', 'right'], align=align)\n        cbook._check_in_list(['horizontal', 'vertical'],\n                             orientation=orientation)\n\n        if histtype == 'barstacked' and not stacked:\n            stacked = True\n\n        # basic input validation\n        input_empty = np.size(x) == 0\n        # Massage 'x' for processing.\n        x = cbook._reshape_2D(x, 'x')\n        nx = len(x)  # number of datasets\n\n        # Process unit information\n        # Unit conversion is done individually on each dataset\n        self._process_unit_info(xdata=x[0], kwargs=kwargs)\n        x = [self.convert_xunits(xi) for xi in x]\n\n        if bin_range is not None:\n            bin_range = self.convert_xunits(bin_range)\n\n        if not cbook.is_scalar_or_string(bins):\n            bins = self.convert_xunits(bins)\n\n        # We need to do to 'weights' what was done to 'x'\n        if weights is not None:\n            w = cbook._reshape_2D(weights, 'weights')\n        else:\n            w = [None] * nx\n\n        if len(w) != nx:\n            raise ValueError('weights should have the same shape as x')\n\n        for xi, wi in zip(x, w):\n            if wi is not None and len(wi) != len(xi):\n                raise ValueError(\n                    'weights should have the same shape as x')\n\n        if color is None:\n            color = [self._get_lines.get_next_color() for i in range(nx)]\n        else:\n            color = mcolors.to_rgba_array(color)\n            if len(color) != nx:\n                error_message = (\n                    \"color kwarg must have one color per data set. %d data \"\n                    \"sets and %d colors were provided\" % (nx, len(color)))\n                raise ValueError(error_message)\n\n        hist_kwargs = dict()\n\n        # if the bin_range is not given, compute without nan numpy\n        # does not do this for us when guessing the range (but will\n        # happily ignore nans when computing the histogram).\n        if bin_range is None:\n            xmin = np.inf\n            xmax = -np.inf\n            for xi in x:\n                if len(xi):\n                    # python's min/max ignore nan,\n                    # np.minnan returns nan for all nan input\n                    xmin = min(xmin, np.nanmin(xi))\n                    xmax = max(xmax, np.nanmax(xi))\n            # make sure we have seen at least one non-nan and finite\n            # value before we reset the bin range\n            if not np.isnan([xmin, xmax]).any() and not (xmin > xmax):\n                bin_range = (xmin, xmax)\n\n        # If bins are not specified either explicitly or via range,\n        # we need to figure out the range required for all datasets,\n        # and supply that to np.histogram.\n        if not input_empty and len(x) > 1:\n            if weights is not None:\n                _w = np.concatenate(w)\n            else:\n                _w = None\n\n            bins = _histogram_bin_edges(np.concatenate(x), bins, bin_range, _w)\n        else:\n            hist_kwargs['range'] = bin_range\n\n        density = bool(density)\n        if density and not stacked:\n            hist_kwargs['density'] = density\n\n        # List to store all the top coordinates of the histograms\n        tops = []  # Will have shape (n_datasets, n_bins).\n        # Loop through datasets\n        for i in range(nx):\n            # this will automatically overwrite bins,\n            # so that each histogram uses the same bins\n            m, bins = np.histogram(x[i], bins, weights=w[i], **hist_kwargs)\n            tops.append(m)\n        tops = np.array(tops, float)  # causes problems later if it's an int\n        if stacked:\n            tops = tops.cumsum(axis=0)\n            # If a stacked density plot, normalize so the area of all the\n            # stacked histograms together is 1\n            if density:\n                tops = (tops / np.diff(bins)) / tops[-1].sum()\n        if cumulative:\n            slc = slice(None)\n            if isinstance(cumulative, Number) and cumulative < 0:\n                slc = slice(None, None, -1)\n            if density:\n                tops = (tops * np.diff(bins))[:, slc].cumsum(axis=1)[:, slc]\n            else:\n                tops = tops[:, slc].cumsum(axis=1)[:, slc]\n\n        patches = []\n\n        # Save autoscale state for later restoration; turn autoscaling\n        # off so we can do it all a single time at the end, instead\n        # of having it done by bar or fill and then having to be redone.\n        _saved_autoscalex = self.get_autoscalex_on()\n        _saved_autoscaley = self.get_autoscaley_on()\n        self.set_autoscalex_on(False)\n        self.set_autoscaley_on(False)\n\n        if histtype.startswith('bar'):\n\n            totwidth = np.diff(bins)\n\n            if rwidth is not None:\n                dr = np.clip(rwidth, 0, 1)\n            elif (len(tops) > 1 and\n                  ((not stacked) or rcParams['_internal.classic_mode'])):\n                dr = 0.8\n            else:\n                dr = 1.0\n\n            if histtype == 'bar' and not stacked:\n                width = dr * totwidth / nx\n                dw = width\n                boffset = -0.5 * dr * totwidth * (1 - 1 / nx)\n            elif histtype == 'barstacked' or stacked:\n                width = dr * totwidth\n                boffset, dw = 0.0, 0.0\n\n            if align == 'mid':\n                boffset += 0.5 * totwidth\n            elif align == 'right':\n                boffset += totwidth\n\n            if orientation == 'horizontal':\n                _barfunc = self.barh\n                bottom_kwarg = 'left'\n            else:  # orientation == 'vertical'\n                _barfunc = self.bar\n                bottom_kwarg = 'bottom'\n\n            for m, c in zip(tops, color):\n                if bottom is None:\n                    bottom = np.zeros(len(m))\n                if stacked:\n                    height = m - bottom\n                else:\n                    height = m\n                patch = _barfunc(bins[:-1]+boffset, height, width,\n                                 align='center', log=log,\n                                 color=c, **{bottom_kwarg: bottom})\n                patches.append(patch)\n                if stacked:\n                    bottom[:] = m\n                boffset += dw\n\n        elif histtype.startswith('step'):\n            # these define the perimeter of the polygon\n            x = np.zeros(4 * len(bins) - 3)\n            y = np.zeros(4 * len(bins) - 3)\n\n            x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]\n            x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]\n\n            if bottom is None:\n                bottom = np.zeros(len(bins) - 1)\n\n            y[1:2*len(bins)-1:2], y[2:2*len(bins):2] = bottom, bottom\n            y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]\n\n            if log:\n                if orientation == 'horizontal':\n                    self.set_xscale('log', nonposx='clip')\n                else:  # orientation == 'vertical'\n                    self.set_yscale('log', nonposy='clip')\n\n            if align == 'left':\n                x -= 0.5*(bins[1]-bins[0])\n            elif align == 'right':\n                x += 0.5*(bins[1]-bins[0])\n\n            # If fill kwarg is set, it will be passed to the patch collection,\n            # overriding this\n            fill = (histtype == 'stepfilled')\n\n            xvals, yvals = [], []\n            for m in tops:\n                if stacked:\n                    # starting point for drawing polygon\n                    y[0] = y[1]\n                    # top of the previous polygon becomes the bottom\n                    y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]\n                # set the top of this polygon\n                y[1:2*len(bins)-1:2], y[2:2*len(bins):2] = (m + bottom,\n                                                            m + bottom)\n                if orientation == 'horizontal':\n                    xvals.append(y.copy())\n                    yvals.append(x.copy())\n                else:\n                    xvals.append(x.copy())\n                    yvals.append(y.copy())\n\n            # stepfill is closed, step is not\n            split = -1 if fill else 2 * len(bins)\n            # add patches in reverse order so that when stacking,\n            # items lower in the stack are plotted on top of\n            # items higher in the stack\n            for x, y, c in reversed(list(zip(xvals, yvals, color))):\n                patches.append(self.fill(\n                    x[:split], y[:split],\n                    closed=True if fill else None,\n                    facecolor=c,\n                    edgecolor=None if fill else c,\n                    fill=fill if fill else None))\n            for patch_list in patches:\n                for patch in patch_list:\n                    if orientation == 'vertical':\n                        patch.sticky_edges.y.append(0)\n                    elif orientation == 'horizontal':\n                        patch.sticky_edges.x.append(0)\n\n            # we return patches, so put it back in the expected order\n            patches.reverse()\n\n        self.set_autoscalex_on(_saved_autoscalex)\n        self.set_autoscaley_on(_saved_autoscaley)\n        self._request_autoscale_view()\n\n        if label is None:\n            labels = [None]\n        elif isinstance(label, str):\n            labels = [label]\n        elif not np.iterable(label):\n            labels = [str(label)]\n        else:\n            labels = [str(lab) for lab in label]\n\n        for patch, lbl in itertools.zip_longest(patches, labels):\n            if patch:\n                p = patch[0]\n                p.update(kwargs)\n                if lbl is not None:\n                    p.set_label(lbl)\n\n                for p in patch[1:]:\n                    p.update(kwargs)\n                    p.set_label('_nolegend_')\n\n        if nx == 1:\n            return tops[0], bins, cbook.silent_list('Patch', patches[0])\n        else:\n            return tops, bins, cbook.silent_list('Lists of Patches', patches)",
        "begin_line": 6346,
        "end_line": 6822,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019083969465648855,
            "pseudo_dstar_susp": 0.00020631318341242006,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00020631318341242006,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.hist2d#6826",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.hist2d(self, x, y, bins=10, range=None, density=False, weights=None, cmin=None, cmax=None, **kwargs)",
        "snippet": "    def hist2d(self, x, y, bins=10, range=None, density=False, weights=None,\n               cmin=None, cmax=None, **kwargs):\n        \"\"\"\n        Make a 2D histogram plot.\n\n        Parameters\n        ----------\n        x, y : array-like, shape (n, )\n            Input values\n\n        bins : None or int or [int, int] or array-like or [array, array]\n\n            The bin specification:\n\n            - If int, the number of bins for the two dimensions\n              (nx=ny=bins).\n            - If ``[int, int]``, the number of bins in each dimension\n              (nx, ny = bins).\n            - If array-like, the bin edges for the two dimensions\n              (x_edges=y_edges=bins).\n            - If ``[array, array]``, the bin edges in each dimension\n              (x_edges, y_edges = bins).\n\n            The default value is 10.\n\n        range : array-like shape(2, 2), optional, default: None\n            The leftmost and rightmost edges of the bins along each dimension\n            (if not specified explicitly in the bins parameters): ``[[xmin,\n            xmax], [ymin, ymax]]``. All values outside of this range will be\n            considered outliers and not tallied in the histogram.\n\n        density : bool, optional, default: False\n            Normalize histogram.  *normed* is a deprecated synonym for this\n            parameter.\n\n        weights : array-like, shape (n, ), optional, default: None\n            An array of values w_i weighing each sample (x_i, y_i).\n\n        cmin : scalar, optional, default: None\n            All bins that has count less than cmin will not be displayed (set\n            to NaN before passing to imshow) and these count values in the\n            return value count histogram will also be set to nan upon return.\n\n        cmax : scalar, optional, default: None\n            All bins that has count more than cmax will not be displayed (set\n            to NaN before passing to imshow) and these count values in the\n            return value count histogram will also be set to nan upon return.\n\n        Returns\n        -------\n        h : 2D array\n            The bi-dimensional histogram of samples x and y. Values in x are\n            histogrammed along the first dimension and values in y are\n            histogrammed along the second dimension.\n        xedges : 1D array\n            The bin edges along the x axis.\n        yedges : 1D array\n            The bin edges along the y axis.\n        image : `~.matplotlib.collections.QuadMesh`\n\n        Other Parameters\n        ----------------\n        cmap : Colormap or str, optional\n            A `.colors.Colormap` instance.  If not set, use rc settings.\n\n        norm : Normalize, optional\n            A `.colors.Normalize` instance is used to\n            scale luminance data to ``[0, 1]``. If not set, defaults to\n            `.colors.Normalize()`.\n\n        vmin/vmax : None or scalar, optional\n            Arguments passed to the `~.colors.Normalize` instance.\n\n        alpha : ``0 <= scalar <= 1`` or ``None``, optional\n            The alpha blending value.\n\n        See also\n        --------\n        hist : 1D histogram plotting\n\n        Notes\n        -----\n        - Currently ``hist2d`` calculates its own axis limits, and any limits\n          previously set are ignored.\n        - Rendering the histogram with a logarithmic color scale is\n          accomplished by passing a `.colors.LogNorm` instance to the *norm*\n          keyword argument. Likewise, power-law normalization (similar\n          in effect to gamma correction) can be accomplished with\n          `.colors.PowerNorm`.\n        \"\"\"\n\n        h, xedges, yedges = np.histogram2d(x, y, bins=bins, range=range,\n                                           normed=density, weights=weights)\n\n        if cmin is not None:\n            h[h < cmin] = None\n        if cmax is not None:\n            h[h > cmax] = None\n\n        pc = self.pcolormesh(xedges, yedges, h.T, **kwargs)\n        self.set_xlim(xedges[0], xedges[-1])\n        self.set_ylim(yedges[0], yedges[-1])\n\n        return h, xedges, yedges, pc",
        "begin_line": 6826,
        "end_line": 6929,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.psd#6933",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.psd(self, x, NFFT=None, Fs=None, Fc=None, detrend=None, window=None, noverlap=None, pad_to=None, sides=None, scale_by_freq=None, return_line=None, **kwargs)",
        "snippet": "    def psd(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,\n            window=None, noverlap=None, pad_to=None,\n            sides=None, scale_by_freq=None, return_line=None, **kwargs):\n        r\"\"\"\n        Plot the power spectral density.\n\n        The power spectral density :math:`P_{xx}` by Welch's average\n        periodogram method.  The vector *x* is divided into *NFFT* length\n        segments.  Each segment is detrended by function *detrend* and\n        windowed by function *window*.  *noverlap* gives the length of\n        the overlap between segments.  The :math:`|\\mathrm{fft}(i)|^2`\n        of each segment :math:`i` are averaged to compute :math:`P_{xx}`,\n        with a scaling to correct for power loss due to windowing.\n\n        If len(*x*) < *NFFT*, it will be zero padded to *NFFT*.\n\n        Parameters\n        ----------\n        x : 1-D array or sequence\n            Array or sequence containing the data\n\n        %(Spectral)s\n\n        %(PSD)s\n\n        noverlap : int\n            The number of points of overlap between segments.\n            The default value is 0 (no overlap).\n\n        Fc : int\n            The center frequency of *x* (defaults to 0), which offsets\n            the x extents of the plot to reflect the frequency range used\n            when a signal is acquired and then filtered and downsampled to\n            baseband.\n\n        return_line : bool\n            Whether to include the line object plotted in the returned values.\n            Default is False.\n\n        Returns\n        -------\n        Pxx : 1-D array\n            The values for the power spectrum `P_{xx}` before scaling\n            (real valued).\n\n        freqs : 1-D array\n            The frequencies corresponding to the elements in *Pxx*.\n\n        line : `~matplotlib.lines.Line2D`\n            The line created by this function.\n            Only returned if *return_line* is True.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Keyword arguments control the `.Line2D` properties:\n\n            %(_Line2D_docstr)s\n\n        See Also\n        --------\n        :func:`specgram`\n            :func:`specgram` differs in the default overlap; in not returning\n            the mean of the segment periodograms; in returning the times of the\n            segments; and in plotting a colormap instead of a line.\n\n        :func:`magnitude_spectrum`\n            :func:`magnitude_spectrum` plots the magnitude spectrum.\n\n        :func:`csd`\n            :func:`csd` plots the spectral density between two signals.\n\n        Notes\n        -----\n        For plotting, the power is plotted as\n        :math:`10\\log_{10}(P_{xx})` for decibels, though *Pxx* itself\n        is returned.\n\n        References\n        ----------\n        Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,\n        John Wiley & Sons (1986)\n        \"\"\"\n        if Fc is None:\n            Fc = 0\n\n        pxx, freqs = mlab.psd(x=x, NFFT=NFFT, Fs=Fs, detrend=detrend,\n                              window=window, noverlap=noverlap, pad_to=pad_to,\n                              sides=sides, scale_by_freq=scale_by_freq)\n        freqs += Fc\n\n        if scale_by_freq in (None, True):\n            psd_units = 'dB/Hz'\n        else:\n            psd_units = 'dB'\n\n        line = self.plot(freqs, 10 * np.log10(pxx), **kwargs)\n        self.set_xlabel('Frequency')\n        self.set_ylabel('Power Spectral Density (%s)' % psd_units)\n        self.grid(True)\n        vmin, vmax = self.viewLim.intervaly\n        intv = vmax - vmin\n        logi = int(np.log10(intv))\n        if logi == 0:\n            logi = .1\n        step = 10 * logi\n        ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)\n        self.set_yticks(ticks)\n\n        if return_line is None or not return_line:\n            return pxx, freqs\n        else:\n            return pxx, freqs, line",
        "begin_line": 6933,
        "end_line": 7045,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.csd#7049",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.csd(self, x, y, NFFT=None, Fs=None, Fc=None, detrend=None, window=None, noverlap=None, pad_to=None, sides=None, scale_by_freq=None, return_line=None, **kwargs)",
        "snippet": "    def csd(self, x, y, NFFT=None, Fs=None, Fc=None, detrend=None,\n            window=None, noverlap=None, pad_to=None,\n            sides=None, scale_by_freq=None, return_line=None, **kwargs):\n        r\"\"\"\n        Plot the cross-spectral density.\n\n        The cross spectral density :math:`P_{xy}` by Welch's average\n        periodogram method.  The vectors *x* and *y* are divided into\n        *NFFT* length segments.  Each segment is detrended by function\n        *detrend* and windowed by function *window*.  *noverlap* gives\n        the length of the overlap between segments.  The product of\n        the direct FFTs of *x* and *y* are averaged over each segment\n        to compute :math:`P_{xy}`, with a scaling to correct for power\n        loss due to windowing.\n\n        If len(*x*) < *NFFT* or len(*y*) < *NFFT*, they will be zero\n        padded to *NFFT*.\n\n        Parameters\n        ----------\n        x, y : 1-D arrays or sequences\n            Arrays or sequences containing the data.\n\n        %(Spectral)s\n\n        %(PSD)s\n\n        noverlap : int\n            The number of points of overlap between segments.\n            The default value is 0 (no overlap).\n\n        Fc : int\n            The center frequency of *x* (defaults to 0), which offsets\n            the x extents of the plot to reflect the frequency range used\n            when a signal is acquired and then filtered and downsampled to\n            baseband.\n\n        return_line : bool\n            Whether to include the line object plotted in the returned values.\n            Default is False.\n\n        Returns\n        -------\n        Pxy : 1-D array\n            The values for the cross spectrum `P_{xy}` before scaling\n            (complex valued).\n\n        freqs : 1-D array\n            The frequencies corresponding to the elements in *Pxy*.\n\n        line : `~matplotlib.lines.Line2D`\n            The line created by this function.\n            Only returned if *return_line* is True.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Keyword arguments control the `.Line2D` properties:\n\n            %(_Line2D_docstr)s\n\n        See Also\n        --------\n        :func:`psd`\n            :func:`psd` is the equivalent to setting y=x.\n\n        Notes\n        -----\n        For plotting, the power is plotted as\n        :math:`10 \\log_{10}(P_{xy})` for decibels, though `P_{xy}` itself\n        is returned.\n\n        References\n        ----------\n        Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,\n        John Wiley & Sons (1986)\n        \"\"\"\n        if Fc is None:\n            Fc = 0\n\n        pxy, freqs = mlab.csd(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,\n                              window=window, noverlap=noverlap, pad_to=pad_to,\n                              sides=sides, scale_by_freq=scale_by_freq)\n        # pxy is complex\n        freqs += Fc\n\n        line = self.plot(freqs, 10 * np.log10(np.abs(pxy)), **kwargs)\n        self.set_xlabel('Frequency')\n        self.set_ylabel('Cross Spectrum Magnitude (dB)')\n        self.grid(True)\n        vmin, vmax = self.viewLim.intervaly\n\n        intv = vmax - vmin\n        step = 10 * int(np.log10(intv))\n\n        ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)\n        self.set_yticks(ticks)\n\n        if return_line is None or not return_line:\n            return pxy, freqs\n        else:\n            return pxy, freqs, line",
        "begin_line": 7049,
        "end_line": 7150,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.magnitude_spectrum#7154",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.magnitude_spectrum(self, x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, scale=None, **kwargs)",
        "snippet": "    def magnitude_spectrum(self, x, Fs=None, Fc=None, window=None,\n                           pad_to=None, sides=None, scale=None,\n                           **kwargs):\n        \"\"\"\n        Plot the magnitude spectrum.\n\n        Compute the magnitude spectrum of *x*.  Data is padded to a\n        length of *pad_to* and the windowing function *window* is applied to\n        the signal.\n\n        Parameters\n        ----------\n        x : 1-D array or sequence\n            Array or sequence containing the data.\n\n        %(Spectral)s\n\n        %(Single_Spectrum)s\n\n        scale : {'default', 'linear', 'dB'}\n            The scaling of the values in the *spec*.  'linear' is no scaling.\n            'dB' returns the values in dB scale, i.e., the dB amplitude\n            (20 * log10). 'default' is 'linear'.\n\n        Fc : int\n            The center frequency of *x* (defaults to 0), which offsets\n            the x extents of the plot to reflect the frequency range used\n            when a signal is acquired and then filtered and downsampled to\n            baseband.\n\n        Returns\n        -------\n        spectrum : 1-D array\n            The values for the magnitude spectrum before scaling (real valued).\n\n        freqs : 1-D array\n            The frequencies corresponding to the elements in *spectrum*.\n\n        line : `~matplotlib.lines.Line2D`\n            The line created by this function.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Keyword arguments control the `.Line2D` properties:\n\n            %(_Line2D_docstr)s\n\n        See Also\n        --------\n        :func:`psd`\n            :func:`psd` plots the power spectral density.`.\n\n        :func:`angle_spectrum`\n            :func:`angle_spectrum` plots the angles of the corresponding\n            frequencies.\n\n        :func:`phase_spectrum`\n            :func:`phase_spectrum` plots the phase (unwrapped angle) of the\n            corresponding frequencies.\n\n        :func:`specgram`\n            :func:`specgram` can plot the magnitude spectrum of segments within\n            the signal in a colormap.\n\n        \"\"\"\n        if Fc is None:\n            Fc = 0\n\n        if scale is None or scale == 'default':\n            scale = 'linear'\n\n        spec, freqs = mlab.magnitude_spectrum(x=x, Fs=Fs, window=window,\n                                              pad_to=pad_to, sides=sides)\n        freqs += Fc\n\n        if scale == 'linear':\n            Z = spec\n            yunits = 'energy'\n        elif scale == 'dB':\n            Z = 20. * np.log10(spec)\n            yunits = 'dB'\n        else:\n            raise ValueError('Unknown scale %s', scale)\n\n        lines = self.plot(freqs, Z, **kwargs)\n        self.set_xlabel('Frequency')\n        self.set_ylabel('Magnitude (%s)' % yunits)\n\n        return spec, freqs, lines[0]",
        "begin_line": 7154,
        "end_line": 7243,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.angle_spectrum#7247",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.angle_spectrum(self, x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, **kwargs)",
        "snippet": "    def angle_spectrum(self, x, Fs=None, Fc=None, window=None,\n                       pad_to=None, sides=None, **kwargs):\n        \"\"\"\n        Plot the angle spectrum.\n\n        Compute the angle spectrum (wrapped phase spectrum) of *x*.\n        Data is padded to a length of *pad_to* and the windowing function\n        *window* is applied to the signal.\n\n        Parameters\n        ----------\n        x : 1-D array or sequence\n            Array or sequence containing the data.\n\n        %(Spectral)s\n\n        %(Single_Spectrum)s\n\n        Fc : int\n            The center frequency of *x* (defaults to 0), which offsets\n            the x extents of the plot to reflect the frequency range used\n            when a signal is acquired and then filtered and downsampled to\n            baseband.\n\n        Returns\n        -------\n        spectrum : 1-D array\n            The values for the angle spectrum in radians (real valued).\n\n        freqs : 1-D array\n            The frequencies corresponding to the elements in *spectrum*.\n\n        line : `~matplotlib.lines.Line2D`\n            The line created by this function.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Keyword arguments control the `.Line2D` properties:\n\n            %(_Line2D_docstr)s\n\n        See Also\n        --------\n        :func:`magnitude_spectrum`\n            :func:`angle_spectrum` plots the magnitudes of the corresponding\n            frequencies.\n\n        :func:`phase_spectrum`\n            :func:`phase_spectrum` plots the unwrapped version of this\n            function.\n\n        :func:`specgram`\n            :func:`specgram` can plot the angle spectrum of segments within the\n            signal in a colormap.\n\n        \"\"\"\n        if Fc is None:\n            Fc = 0\n\n        spec, freqs = mlab.angle_spectrum(x=x, Fs=Fs, window=window,\n                                          pad_to=pad_to, sides=sides)\n        freqs += Fc\n\n        lines = self.plot(freqs, spec, **kwargs)\n        self.set_xlabel('Frequency')\n        self.set_ylabel('Angle (radians)')\n\n        return spec, freqs, lines[0]",
        "begin_line": 7247,
        "end_line": 7315,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.phase_spectrum#7319",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.phase_spectrum(self, x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, **kwargs)",
        "snippet": "    def phase_spectrum(self, x, Fs=None, Fc=None, window=None,\n                       pad_to=None, sides=None, **kwargs):\n        \"\"\"\n        Plot the phase spectrum.\n\n        Compute the phase spectrum (unwrapped angle spectrum) of *x*.\n        Data is padded to a length of *pad_to* and the windowing function\n        *window* is applied to the signal.\n\n        Parameters\n        ----------\n        x : 1-D array or sequence\n            Array or sequence containing the data\n\n        %(Spectral)s\n\n        %(Single_Spectrum)s\n\n        Fc : int\n            The center frequency of *x* (defaults to 0), which offsets\n            the x extents of the plot to reflect the frequency range used\n            when a signal is acquired and then filtered and downsampled to\n            baseband.\n\n        Returns\n        -------\n        spectrum : 1-D array\n            The values for the phase spectrum in radians (real valued).\n\n        freqs : 1-D array\n            The frequencies corresponding to the elements in *spectrum*.\n\n        line : `~matplotlib.lines.Line2D`\n            The line created by this function.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Keyword arguments control the `.Line2D` properties:\n\n            %(_Line2D_docstr)s\n\n        See Also\n        --------\n        :func:`magnitude_spectrum`\n            :func:`magnitude_spectrum` plots the magnitudes of the\n            corresponding frequencies.\n\n        :func:`angle_spectrum`\n            :func:`angle_spectrum` plots the wrapped version of this function.\n\n        :func:`specgram`\n            :func:`specgram` can plot the phase spectrum of segments within the\n            signal in a colormap.\n\n        \"\"\"\n        if Fc is None:\n            Fc = 0\n\n        spec, freqs = mlab.phase_spectrum(x=x, Fs=Fs, window=window,\n                                          pad_to=pad_to, sides=sides)\n        freqs += Fc\n\n        lines = self.plot(freqs, spec, **kwargs)\n        self.set_xlabel('Frequency')\n        self.set_ylabel('Phase (radians)')\n\n        return spec, freqs, lines[0]",
        "begin_line": 7319,
        "end_line": 7386,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.specgram#7454",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.specgram(self, x, NFFT=None, Fs=None, Fc=None, detrend=None, window=None, noverlap=None, cmap=None, xextent=None, pad_to=None, sides=None, scale_by_freq=None, mode=None, scale=None, vmin=None, vmax=None, **kwargs)",
        "snippet": "    def specgram(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,\n                 window=None, noverlap=None,\n                 cmap=None, xextent=None, pad_to=None, sides=None,\n                 scale_by_freq=None, mode=None, scale=None,\n                 vmin=None, vmax=None, **kwargs):\n        \"\"\"\n        Plot a spectrogram.\n\n        Compute and plot a spectrogram of data in *x*.  Data are split into\n        *NFFT* length segments and the spectrum of each section is\n        computed.  The windowing function *window* is applied to each\n        segment, and the amount of overlap of each segment is\n        specified with *noverlap*. The spectrogram is plotted as a colormap\n        (using imshow).\n\n        Parameters\n        ----------\n        x : 1-D array or sequence\n            Array or sequence containing the data.\n\n        %(Spectral)s\n\n        %(PSD)s\n\n        mode : {'default', 'psd', 'magnitude', 'angle', 'phase'}\n            What sort of spectrum to use.  Default is 'psd', which takes the\n            power spectral density.  'magnitude' returns the magnitude\n            spectrum.  'angle' returns the phase spectrum without unwrapping.\n            'phase' returns the phase spectrum with unwrapping.\n\n        noverlap : int\n            The number of points of overlap between blocks.  The\n            default value is 128.\n\n        scale : {'default', 'linear', 'dB'}\n            The scaling of the values in the *spec*.  'linear' is no scaling.\n            'dB' returns the values in dB scale.  When *mode* is 'psd',\n            this is dB power (10 * log10).  Otherwise this is dB amplitude\n            (20 * log10). 'default' is 'dB' if *mode* is 'psd' or\n            'magnitude' and 'linear' otherwise.  This must be 'linear'\n            if *mode* is 'angle' or 'phase'.\n\n        Fc : int\n            The center frequency of *x* (defaults to 0), which offsets\n            the x extents of the plot to reflect the frequency range used\n            when a signal is acquired and then filtered and downsampled to\n            baseband.\n\n        cmap\n            A :class:`matplotlib.colors.Colormap` instance; if *None*, use\n            default determined by rc\n\n        xextent : *None* or (xmin, xmax)\n            The image extent along the x-axis. The default sets *xmin* to the\n            left border of the first bin (*spectrum* column) and *xmax* to the\n            right border of the last bin. Note that for *noverlap>0* the width\n            of the bins is smaller than those of the segments.\n\n        **kwargs\n            Additional keyword arguments are passed on to imshow which makes\n            the specgram image.\n\n        Returns\n        -------\n        spectrum : 2-D array\n            Columns are the periodograms of successive segments.\n\n        freqs : 1-D array\n            The frequencies corresponding to the rows in *spectrum*.\n\n        t : 1-D array\n            The times corresponding to midpoints of segments (i.e., the columns\n            in *spectrum*).\n\n        im : instance of class :class:`~matplotlib.image.AxesImage`\n            The image created by imshow containing the spectrogram\n\n        See Also\n        --------\n        :func:`psd`\n            :func:`psd` differs in the default overlap; in returning the mean\n            of the segment periodograms; in not returning times; and in\n            generating a line plot instead of colormap.\n\n        :func:`magnitude_spectrum`\n            A single spectrum, similar to having a single segment when *mode*\n            is 'magnitude'. Plots a line instead of a colormap.\n\n        :func:`angle_spectrum`\n            A single spectrum, similar to having a single segment when *mode*\n            is 'angle'. Plots a line instead of a colormap.\n\n        :func:`phase_spectrum`\n            A single spectrum, similar to having a single segment when *mode*\n            is 'phase'. Plots a line instead of a colormap.\n\n        Notes\n        -----\n        The parameters *detrend* and *scale_by_freq* do only apply when *mode*\n        is set to 'psd'.\n        \"\"\"\n        if NFFT is None:\n            NFFT = 256  # same default as in mlab.specgram()\n        if Fc is None:\n            Fc = 0  # same default as in mlab._spectral_helper()\n        if noverlap is None:\n            noverlap = 128  # same default as in mlab.specgram()\n\n        if mode == 'complex':\n            raise ValueError('Cannot plot a complex specgram')\n\n        if scale is None or scale == 'default':\n            if mode in ['angle', 'phase']:\n                scale = 'linear'\n            else:\n                scale = 'dB'\n        elif mode in ['angle', 'phase'] and scale == 'dB':\n            raise ValueError('Cannot use dB scale with angle or phase mode')\n\n        spec, freqs, t = mlab.specgram(x=x, NFFT=NFFT, Fs=Fs,\n                                       detrend=detrend, window=window,\n                                       noverlap=noverlap, pad_to=pad_to,\n                                       sides=sides,\n                                       scale_by_freq=scale_by_freq,\n                                       mode=mode)\n\n        if scale == 'linear':\n            Z = spec\n        elif scale == 'dB':\n            if mode is None or mode == 'default' or mode == 'psd':\n                Z = 10. * np.log10(spec)\n            else:\n                Z = 20. * np.log10(spec)\n        else:\n            raise ValueError('Unknown scale %s', scale)\n\n        Z = np.flipud(Z)\n\n        if xextent is None:\n            # padding is needed for first and last segment:\n            pad_xextent = (NFFT-noverlap) / Fs / 2\n            xextent = np.min(t) - pad_xextent, np.max(t) + pad_xextent\n        xmin, xmax = xextent\n        freqs += Fc\n        extent = xmin, xmax, freqs[0], freqs[-1]\n        im = self.imshow(Z, cmap, extent=extent, vmin=vmin, vmax=vmax,\n                         **kwargs)\n        self.axis('auto')\n\n        return spec, freqs, t, im",
        "begin_line": 7454,
        "end_line": 7603,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.spy#7606",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.spy(self, Z, precision=0, marker=None, markersize=None, aspect='equal', origin='upper', **kwargs)",
        "snippet": "    def spy(self, Z, precision=0, marker=None, markersize=None,\n            aspect='equal', origin=\"upper\", **kwargs):\n        \"\"\"\n        Plot the sparsity pattern of a 2D array.\n\n        This visualizes the non-zero values of the array.\n\n        Two plotting styles are available: image and marker. Both\n        are available for full arrays, but only the marker style\n        works for `scipy.sparse.spmatrix` instances.\n\n        **Image style**\n\n        If *marker* and *markersize* are *None*, `~.Axes.imshow` is used. Any\n        extra remaining keyword arguments are passed to this method.\n\n        **Marker style**\n\n        If *Z* is a `scipy.sparse.spmatrix` or *marker* or *markersize* are\n        *None*, a `.Line2D` object will be returned with the value of marker\n        determining the marker type, and any remaining keyword arguments\n        passed to `~.Axes.plot`.\n\n        Parameters\n        ----------\n        Z : array-like (M, N)\n            The array to be plotted.\n\n        precision : float or 'present', optional, default: 0\n            If *precision* is 0, any non-zero value will be plotted. Otherwise,\n            values of :math:`|Z| > precision` will be plotted.\n\n            For :class:`scipy.sparse.spmatrix` instances, you can also\n            pass 'present'. In this case any value present in the array\n            will be plotted, even if it is identically zero.\n\n        origin : {'upper', 'lower'}, optional\n            Place the [0, 0] index of the array in the upper left or lower left\n            corner of the axes. The convention 'upper' is typically used for\n            matrices and images.\n            If not given, :rc:`image.origin` is used, defaulting to 'upper'.\n\n\n        aspect : {'equal', 'auto', None} or float, optional\n            Controls the aspect ratio of the axes. The aspect is of particular\n            relevance for images since it may distort the image, i.e. pixel\n            will not be square.\n\n            This parameter is a shortcut for explicitly calling\n            `.Axes.set_aspect`. See there for further details.\n\n            - 'equal': Ensures an aspect ratio of 1. Pixels will be square.\n            - 'auto': The axes is kept fixed and the aspect is adjusted so\n              that the data fit in the axes. In general, this will result in\n              non-square pixels.\n            - *None*: Use :rc:`image.aspect`.\n\n            Default: 'equal'\n\n        Returns\n        -------\n        ret : `~matplotlib.image.AxesImage` or `.Line2D`\n            The return type depends on the plotting style (see above).\n\n        Other Parameters\n        ----------------\n        **kwargs\n            The supported additional parameters depend on the plotting style.\n\n            For the image style, you can pass the following additional\n            parameters of `~.Axes.imshow`:\n\n            - *cmap*\n            - *alpha*\n            - *url*\n            - any `.Artist` properties (passed on to the `.AxesImage`)\n\n            For the marker style, you can pass any `.Line2D` property except\n            for *linestyle*:\n\n            %(_Line2D_docstr)s\n        \"\"\"\n        if marker is None and markersize is None and hasattr(Z, 'tocoo'):\n            marker = 's'\n        if marker is None and markersize is None:\n            Z = np.asarray(Z)\n            mask = np.abs(Z) > precision\n\n            if 'cmap' not in kwargs:\n                kwargs['cmap'] = mcolors.ListedColormap(['w', 'k'],\n                                                        name='binary')\n            if 'interpolation' in kwargs:\n                raise TypeError(\n                    \"spy() got an unexpected keyword argument 'interpolation'\")\n            ret = self.imshow(mask, interpolation='nearest', aspect=aspect,\n                              origin=origin, **kwargs)\n        else:\n            if hasattr(Z, 'tocoo'):\n                c = Z.tocoo()\n                if precision == 'present':\n                    y = c.row\n                    x = c.col\n                else:\n                    nonzero = np.abs(c.data) > precision\n                    y = c.row[nonzero]\n                    x = c.col[nonzero]\n            else:\n                Z = np.asarray(Z)\n                nonzero = np.abs(Z) > precision\n                y, x = np.nonzero(nonzero)\n            if marker is None:\n                marker = 's'\n            if markersize is None:\n                markersize = 10\n            if 'linestyle' in kwargs:\n                raise TypeError(\n                    \"spy() got an unexpected keyword argument 'linestyle'\")\n            marks = mlines.Line2D(x, y, linestyle='None',\n                         marker=marker, markersize=markersize, **kwargs)\n            self.add_line(marks)\n            nr, nc = Z.shape\n            self.set_xlim(-0.5, nc - 0.5)\n            self.set_ylim(nr - 0.5, -0.5)\n            self.set_aspect(aspect)\n            ret = marks\n        self.title.set_y(1.05)\n        self.xaxis.tick_top()\n        self.xaxis.set_ticks_position('both')\n        self.xaxis.set_major_locator(mticker.MaxNLocator(nbins=9,\n                                                 steps=[1, 2, 5, 10],\n                                                 integer=True))\n        self.yaxis.set_major_locator(mticker.MaxNLocator(nbins=9,\n                                                 steps=[1, 2, 5, 10],\n                                                 integer=True))\n        return ret",
        "begin_line": 7606,
        "end_line": 7740,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.matshow#7742",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.matshow(self, Z, **kwargs)",
        "snippet": "    def matshow(self, Z, **kwargs):\n        \"\"\"\n        Plot the values of a 2D matrix or array as color-coded image.\n\n        The matrix will be shown the way it would be printed, with the first\n        row at the top.  Row and column numbering is zero-based.\n\n        Parameters\n        ----------\n        Z : array-like(M, N)\n            The matrix to be displayed.\n\n        Returns\n        -------\n        image : `~matplotlib.image.AxesImage`\n\n        Other Parameters\n        ----------------\n        **kwargs : `~matplotlib.axes.Axes.imshow` arguments\n\n        See Also\n        --------\n        imshow : More general function to plot data on a 2D regular raster.\n\n        Notes\n        -----\n        This is just a convenience function wrapping `.imshow` to set useful\n        defaults for displaying a matrix. In particular:\n\n        - Set ``origin='upper'``.\n        - Set ``interpolation='nearest'``.\n        - Set ``aspect='equal'``.\n        - Ticks are placed to the left and above.\n        - Ticks are formatted to show integer indices.\n\n        \"\"\"\n        Z = np.asanyarray(Z)\n        kw = {'origin': 'upper',\n              'interpolation': 'nearest',\n              'aspect': 'equal',          # (already the imshow default)\n              **kwargs}\n        im = self.imshow(Z, **kw)\n        self.title.set_y(1.05)\n        self.xaxis.tick_top()\n        self.xaxis.set_ticks_position('both')\n        self.xaxis.set_major_locator(mticker.MaxNLocator(nbins=9,\n                                                 steps=[1, 2, 5, 10],\n                                                 integer=True))\n        self.yaxis.set_major_locator(mticker.MaxNLocator(nbins=9,\n                                                 steps=[1, 2, 5, 10],\n                                                 integer=True))\n        return im",
        "begin_line": 7742,
        "end_line": 7793,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes._kde_method#7881",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes._kde_method(X, coords)",
        "snippet": "        def _kde_method(X, coords):\n            # fallback gracefully if the vector contains only one value\n            if np.all(X[0] == X):\n                return (X[0] == coords).astype(float)\n            kde = mlab.GaussianKDE(X, bw_method)\n            return kde.evaluate(coords)",
        "begin_line": 7881,
        "end_line": 7886,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002493143854400399,
            "pseudo_dstar_susp": 0.00022148394241417498,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00022148394241417498,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.violinplot#7796",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.violinplot(self, dataset, positions=None, vert=True, widths=0.5, showmeans=False, showextrema=True, showmedians=False, quantiles=None, points=100, bw_method=None)",
        "snippet": "    def violinplot(self, dataset, positions=None, vert=True, widths=0.5,\n                   showmeans=False, showextrema=True, showmedians=False,\n                   quantiles=None, points=100, bw_method=None):\n        \"\"\"\n        Make a violin plot.\n\n        Make a violin plot for each column of *dataset* or each vector in\n        sequence *dataset*.  Each filled area extends to represent the\n        entire data range, with optional lines at the mean, the median,\n        the minimum, the maximum, and user-specified quantiles.\n\n        Parameters\n        ----------\n        dataset : Array or a sequence of vectors.\n          The input data.\n\n        positions : array-like, default = [1, 2, ..., n]\n          Sets the positions of the violins. The ticks and limits are\n          automatically set to match the positions.\n\n        vert : bool, default = True.\n          If true, creates a vertical violin plot.\n          Otherwise, creates a horizontal violin plot.\n\n        widths : array-like, default = 0.5\n          Either a scalar or a vector that sets the maximal width of\n          each violin. The default is 0.5, which uses about half of the\n          available horizontal space.\n\n        showmeans : bool, default = False\n          If `True`, will toggle rendering of the means.\n\n        showextrema : bool, default = True\n          If `True`, will toggle rendering of the extrema.\n\n        showmedians : bool, default = False\n          If `True`, will toggle rendering of the medians.\n\n        quantiles : array-like, default = None\n          If not None, set a list of floats in interval [0, 1] for each violin,\n          which stands for the quantiles that will be rendered for that\n          violin.\n\n        points : scalar, default = 100\n          Defines the number of points to evaluate each of the\n          gaussian kernel density estimations at.\n\n        bw_method : str, scalar or callable, optional\n          The method used to calculate the estimator bandwidth.  This can be\n          'scott', 'silverman', a scalar constant or a callable.  If a\n          scalar, this will be used directly as `kde.factor`.  If a\n          callable, it should take a `GaussianKDE` instance as its only\n          parameter and return a scalar. If None (default), 'scott' is used.\n\n        Returns\n        -------\n        result : dict\n          A dictionary mapping each component of the violinplot to a\n          list of the corresponding collection instances created. The\n          dictionary has the following keys:\n\n          - ``bodies``: A list of the `~.collections.PolyCollection`\n            instances containing the filled area of each violin.\n\n          - ``cmeans``: A `~.collections.LineCollection` instance that marks\n            the mean values of each of the violin's distribution.\n\n          - ``cmins``: A `~.collections.LineCollection` instance that marks\n            the bottom of each violin's distribution.\n\n          - ``cmaxes``: A `~.collections.LineCollection` instance that marks\n            the top of each violin's distribution.\n\n          - ``cbars``: A `~.collections.LineCollection` instance that marks\n            the centers of each violin's distribution.\n\n          - ``cmedians``: A `~.collections.LineCollection` instance that\n            marks the median values of each of the violin's distribution.\n\n          - ``cquantiles``: A `~.collections.LineCollection` instance created\n            to identify the quantile values of each of the violin's\n            distribution.\n\n        \"\"\"\n\n        def _kde_method(X, coords):\n            # fallback gracefully if the vector contains only one value\n            if np.all(X[0] == X):\n                return (X[0] == coords).astype(float)\n            kde = mlab.GaussianKDE(X, bw_method)\n            return kde.evaluate(coords)\n\n        vpstats = cbook.violin_stats(dataset, _kde_method, points=points,\n                                     quantiles=quantiles)\n        return self.violin(vpstats, positions=positions, vert=vert,\n                           widths=widths, showmeans=showmeans,\n                           showextrema=showextrema, showmedians=showmedians)",
        "begin_line": 7796,
        "end_line": 7892,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002467308166790032,
            "pseudo_dstar_susp": 0.00022104332449160034,
            "pseudo_tarantula_susp": 0.00035587188612099647,
            "pseudo_op2_susp": 0.00022104332449160034,
            "pseudo_barinel_susp": 0.00035587188612099647
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.violin#7894",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.violin(self, vpstats, positions=None, vert=True, widths=0.5, showmeans=False, showextrema=True, showmedians=False)",
        "snippet": "    def violin(self, vpstats, positions=None, vert=True, widths=0.5,\n               showmeans=False, showextrema=True, showmedians=False):\n        \"\"\"Drawing function for violin plots.\n\n        Draw a violin plot for each column of *vpstats*. Each filled area\n        extends to represent the entire data range, with optional lines at the\n        mean, the median, the minimum, the maximum, and the quantiles values.\n\n        Parameters\n        ----------\n        vpstats : list of dicts\n          A list of dictionaries containing stats for each violin plot.\n          Required keys are:\n\n          - ``coords``: A list of scalars containing the coordinates that\n            the violin's kernel density estimate were evaluated at.\n\n          - ``vals``: A list of scalars containing the values of the\n            kernel density estimate at each of the coordinates given\n            in *coords*.\n\n          - ``mean``: The mean value for this violin's dataset.\n\n          - ``median``: The median value for this violin's dataset.\n\n          - ``min``: The minimum value for this violin's dataset.\n\n          - ``max``: The maximum value for this violin's dataset.\n\n          Optional keys are:\n\n          - ``quantiles``: A list of scalars containing the quantile values\n            for this violin's dataset.\n\n        positions : array-like, default = [1, 2, ..., n]\n          Sets the positions of the violins. The ticks and limits are\n          automatically set to match the positions.\n\n        vert : bool, default = True.\n          If true, plots the violins vertically.\n          Otherwise, plots the violins horizontally.\n\n        widths : array-like, default = 0.5\n          Either a scalar or a vector that sets the maximal width of\n          each violin. The default is 0.5, which uses about half of the\n          available horizontal space.\n\n        showmeans : bool, default = False\n          If true, will toggle rendering of the means.\n\n        showextrema : bool, default = True\n          If true, will toggle rendering of the extrema.\n\n        showmedians : bool, default = False\n          If true, will toggle rendering of the medians.\n\n        Returns\n        -------\n        result : dict\n          A dictionary mapping each component of the violinplot to a\n          list of the corresponding collection instances created. The\n          dictionary has the following keys:\n\n          - ``bodies``: A list of the `~.collections.PolyCollection`\n            instances containing the filled area of each violin.\n\n          - ``cmeans``: A `~.collections.LineCollection` instance that marks\n            the mean values of each of the violin's distribution.\n\n          - ``cmins``: A `~.collections.LineCollection` instance that marks\n            the bottom of each violin's distribution.\n\n          - ``cmaxes``: A `~.collections.LineCollection` instance that marks\n            the top of each violin's distribution.\n\n          - ``cbars``: A `~.collections.LineCollection` instance that marks\n            the centers of each violin's distribution.\n\n          - ``cmedians``: A `~.collections.LineCollection` instance that\n            marks the median values of each of the violin's distribution.\n\n          - ``cquantiles``: A `~.collections.LineCollection` instance created\n            to identify the quantiles values of each of the violin's\n            distribution.\n\n        \"\"\"\n\n        # Statistical quantities to be plotted on the violins\n        means = []\n        mins = []\n        maxes = []\n        medians = []\n        quantiles = np.asarray([])\n\n        # Collections to be returned\n        artists = {}\n\n        N = len(vpstats)\n        datashape_message = (\"List of violinplot statistics and `{0}` \"\n                             \"values must have the same length\")\n\n        # Validate positions\n        if positions is None:\n            positions = range(1, N + 1)\n        elif len(positions) != N:\n            raise ValueError(datashape_message.format(\"positions\"))\n\n        # Validate widths\n        if np.isscalar(widths):\n            widths = [widths] * N\n        elif len(widths) != N:\n            raise ValueError(datashape_message.format(\"widths\"))\n\n        # Calculate ranges for statistics lines\n        pmins = -0.25 * np.array(widths) + positions\n        pmaxes = 0.25 * np.array(widths) + positions\n\n        # Check whether we are rendering vertically or horizontally\n        if vert:\n            fill = self.fill_betweenx\n            perp_lines = self.hlines\n            par_lines = self.vlines\n        else:\n            fill = self.fill_between\n            perp_lines = self.vlines\n            par_lines = self.hlines\n\n        if rcParams['_internal.classic_mode']:\n            fillcolor = 'y'\n            edgecolor = 'r'\n        else:\n            fillcolor = edgecolor = self._get_lines.get_next_color()\n\n        # Render violins\n        bodies = []\n        for stats, pos, width in zip(vpstats, positions, widths):\n            # The 0.5 factor reflects the fact that we plot from v-p to\n            # v+p\n            vals = np.array(stats['vals'])\n            vals = 0.5 * width * vals / vals.max()\n            bodies += [fill(stats['coords'],\n                            -vals + pos,\n                            vals + pos,\n                            facecolor=fillcolor,\n                            alpha=0.3)]\n            means.append(stats['mean'])\n            mins.append(stats['min'])\n            maxes.append(stats['max'])\n            medians.append(stats['median'])\n            q = stats.get('quantiles')\n            if q is not None:\n                # If exist key quantiles, assume it's a list of floats\n                quantiles = np.concatenate((quantiles, q))\n        artists['bodies'] = bodies\n\n        # Render means\n        if showmeans:\n            artists['cmeans'] = perp_lines(means, pmins, pmaxes,\n                                           colors=edgecolor)\n\n        # Render extrema\n        if showextrema:\n            artists['cmaxes'] = perp_lines(maxes, pmins, pmaxes,\n                                           colors=edgecolor)\n            artists['cmins'] = perp_lines(mins, pmins, pmaxes,\n                                          colors=edgecolor)\n            artists['cbars'] = par_lines(positions, mins, maxes,\n                                         colors=edgecolor)\n\n        # Render medians\n        if showmedians:\n            artists['cmedians'] = perp_lines(medians,\n                                             pmins,\n                                             pmaxes,\n                                             colors=edgecolor)\n\n        # Render quantile values\n        if quantiles.size > 0:\n            # Recalculate ranges for statistics lines for quantiles.\n            # ppmins are the left end of quantiles lines\n            ppmins = np.asarray([])\n            # pmaxes are the right end of quantiles lines\n            ppmaxs = np.asarray([])\n            for stats, cmin, cmax in zip(vpstats, pmins, pmaxes):\n                q = stats.get('quantiles')\n                if q is not None:\n                    ppmins = np.concatenate((ppmins, [cmin] * np.size(q)))\n                    ppmaxs = np.concatenate((ppmaxs, [cmax] * np.size(q)))\n            # Start rendering\n            artists['cquantiles'] = perp_lines(quantiles, ppmins, ppmaxs,\n                                                 colors=edgecolor)\n\n        return artists",
        "begin_line": 7894,
        "end_line": 8086,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002523977788995457,
            "pseudo_dstar_susp": 0.00022232103156958648,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00022232103156958648,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.testing.__init__.set_font_settings_for_testing#21",
        "src_path": "lib/matplotlib/testing/__init__.py",
        "class_name": "lib.matplotlib.testing.__init__",
        "signature": "lib.matplotlib.testing.__init__.set_font_settings_for_testing()",
        "snippet": "def set_font_settings_for_testing():\n    mpl.rcParams['font.family'] = 'DejaVu Sans'\n    mpl.rcParams['text.hinting'] = 'none'\n    mpl.rcParams['text.hinting_factor'] = 8",
        "begin_line": 21,
        "end_line": 24,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012048192771084338,
            "pseudo_dstar_susp": 0.005813953488372093,
            "pseudo_tarantula_susp": 0.0002183406113537118,
            "pseudo_op2_susp": 0.005813953488372093,
            "pseudo_barinel_susp": 0.0002183406113537118
        }
    },
    {
        "name": "lib.matplotlib.testing.__init__.setup#31",
        "src_path": "lib/matplotlib/testing/__init__.py",
        "class_name": "lib.matplotlib.testing.__init__",
        "signature": "lib.matplotlib.testing.__init__.setup()",
        "snippet": "def setup():\n    # The baseline images are created in this locale, so we should use\n    # it during all of the tests.\n\n    try:\n        locale.setlocale(locale.LC_ALL, 'en_US.UTF-8')\n    except locale.Error:\n        try:\n            locale.setlocale(locale.LC_ALL, 'English_United States.1252')\n        except locale.Error:\n            _log.warning(\n                \"Could not set locale to English/United States. \"\n                \"Some date-related tests may fail.\")\n\n    mpl.use('Agg')\n\n    with cbook._suppress_matplotlib_deprecation_warning():\n        mpl.rcdefaults()  # Start with all defaults\n\n    # These settings *must* be hardcoded for running the comparison tests and\n    # are not necessarily the default values as specified in rcsetup.py.\n    set_font_settings_for_testing()\n    set_reproducibility_for_testing()",
        "begin_line": 31,
        "end_line": 53,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011362345188046812,
            "pseudo_dstar_susp": 0.0001893580761219466,
            "pseudo_tarantula_susp": 0.00011366219595362583,
            "pseudo_op2_susp": 0.0001893580761219466,
            "pseudo_barinel_susp": 0.00011366219595362583
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.pdfRepr#134",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf",
        "signature": "lib.matplotlib.backends.backend_pdf.pdfRepr(obj)",
        "snippet": "def pdfRepr(obj):\n    \"\"\"Map Python objects to PDF syntax.\"\"\"\n\n    # Some objects defined later have their own pdfRepr method.\n    if hasattr(obj, 'pdfRepr'):\n        return obj.pdfRepr()\n\n    # Floats. PDF does not have exponential notation (1.0e-10) so we\n    # need to use %f with some precision.  Perhaps the precision\n    # should adapt to the magnitude of the number?\n    elif isinstance(obj, (float, np.floating)):\n        if not np.isfinite(obj):\n            raise ValueError(\"Can only output finite numbers in PDF\")\n        r = b\"%.10f\" % obj\n        return r.rstrip(b'0').rstrip(b'.')\n\n    # Booleans. Needs to be tested before integers since\n    # isinstance(True, int) is true.\n    elif isinstance(obj, bool):\n        return [b'false', b'true'][obj]\n\n    # Integers are written as such.\n    elif isinstance(obj, (int, np.integer)):\n        return b\"%d\" % obj\n\n    # Unicode strings are encoded in UTF-16BE with byte-order mark.\n    elif isinstance(obj, str):\n        try:\n            # But maybe it's really ASCII?\n            s = obj.encode('ASCII')\n            return pdfRepr(s)\n        except UnicodeEncodeError:\n            s = codecs.BOM_UTF16_BE + obj.encode('UTF-16BE')\n            return pdfRepr(s)\n\n    # Strings are written in parentheses, with backslashes and parens\n    # escaped. Actually balanced parens are allowed, but it is\n    # simpler to escape them all. TODO: cut long strings into lines;\n    # I believe there is some maximum line length in PDF.\n    elif isinstance(obj, bytes):\n        return b'(' + _string_escape_regex.sub(_string_escape, obj) + b')'\n\n    # Dictionaries. The keys must be PDF names, so if we find strings\n    # there, we make Name objects from them. The values may be\n    # anything, so the caller must ensure that PDF names are\n    # represented as Name objects.\n    elif isinstance(obj, dict):\n        return fill([\n            b\"<<\",\n            *[Name(key).pdfRepr() + b\" \" + pdfRepr(obj[key])\n              for key in sorted(obj)],\n            b\">>\",\n        ])\n\n    # Lists.\n    elif isinstance(obj, (list, tuple)):\n        return fill([b\"[\", *[pdfRepr(val) for val in obj], b\"]\"])\n\n    # The null keyword.\n    elif obj is None:\n        return b'null'\n\n    # A date.\n    elif isinstance(obj, datetime):\n        r = obj.strftime('D:%Y%m%d%H%M%S')\n        z = obj.utcoffset()\n        if z is not None:\n            z = z.seconds\n        else:\n            if time.daylight:\n                z = time.altzone\n            else:\n                z = time.timezone\n        if z == 0:\n            r += 'Z'\n        elif z < 0:\n            r += \"+%02d'%02d'\" % ((-z) // 3600, (-z) % 3600)\n        else:\n            r += \"-%02d'%02d'\" % (z // 3600, z % 3600)\n        return pdfRepr(r)\n\n    # A bounding box\n    elif isinstance(obj, BboxBase):\n        return fill([pdfRepr(val) for val in obj.bounds])\n\n    else:\n        raise TypeError(\"Don't know a PDF representation for {} objects\"\n                        .format(type(obj)))",
        "begin_line": 134,
        "end_line": 221,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.Name.__init__#251",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.Name",
        "signature": "lib.matplotlib.backends.backend_pdf.Name.__init__(self, name)",
        "snippet": "    def __init__(self, name):\n        if isinstance(name, Name):\n            self.name = name.name\n        else:\n            if isinstance(name, bytes):\n                name = name.decode('ascii')\n            self.name = self._regex.sub(Name.hexify, name).encode('ascii')",
        "begin_line": 251,
        "end_line": 257,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.Name.__lt__#268",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.Name",
        "signature": "lib.matplotlib.backends.backend_pdf.Name.__lt__(self, other)",
        "snippet": "    def __lt__(self, other):\n        return isinstance(other, Name) and self.name < other.name",
        "begin_line": 268,
        "end_line": 269,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.Name.pdfRepr#278",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.Name",
        "signature": "lib.matplotlib.backends.backend_pdf.Name.pdfRepr(self)",
        "snippet": "    def pdfRepr(self):\n        return b'/' + self.name",
        "begin_line": 278,
        "end_line": 279,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.Stream.__init__#348",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.Stream",
        "signature": "lib.matplotlib.backends.backend_pdf.Stream.__init__(self, id, len, file, extra=None, png=None)",
        "snippet": "    def __init__(self, id, len, file, extra=None, png=None):\n        \"\"\"\n        Parameters\n        ----------\n\n        id : int\n            Object id of the stream.\n        len : Reference or None\n            An unused Reference object for the length of the stream;\n            None means to use a memory buffer so the length can be inlined.\n        file : PdfFile\n            The underlying object to write the stream to.\n        extra : dict from Name to anything, or None\n            Extra key-value pairs to include in the stream header.\n        png : dict or None\n            If the data is already png encoded, the decode parameters.\n        \"\"\"\n        self.id = id            # object id\n        self.len = len          # id of length object\n        self.pdfFile = file\n        self.file = file.fh      # file to which the stream is written\n        self.compressobj = None  # compression object\n        if extra is None:\n            self.extra = dict()\n        else:\n            self.extra = extra.copy()\n        if png is not None:\n            self.extra.update({'Filter':      Name('FlateDecode'),\n                               'DecodeParms': png})\n\n        self.pdfFile.recordXref(self.id)\n        if rcParams['pdf.compression'] and not png:\n            self.compressobj = zlib.compressobj(rcParams['pdf.compression'])\n        if self.len is None:\n            self.file = BytesIO()\n        else:\n            self._writeHeader()\n            self.pos = self.file.tell()",
        "begin_line": 348,
        "end_line": 385,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.Stream.write#414",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.Stream",
        "signature": "lib.matplotlib.backends.backend_pdf.Stream.write(self, data)",
        "snippet": "    def write(self, data):\n        \"\"\"Write some data on the stream.\"\"\"\n\n        if self.compressobj is None:\n            self.file.write(data)\n        else:\n            compressed = self.compressobj.compress(data)\n            self.file.write(compressed)",
        "begin_line": 414,
        "end_line": 421,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.228420966016621e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.__init__#435",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.__init__(self, filename, metadata=None)",
        "snippet": "    def __init__(self, filename, metadata=None):\n        \"\"\"\n        Parameters\n        ----------\n\n        filename : str or path-like or file-like\n            Output target; if a string, a file will be opened for writing.\n        metadata : dict from strings to strings and dates\n            Information dictionary object (see PDF reference section 10.2.1\n            'Document Information Dictionary'), e.g.:\n            `{'Creator': 'My software', 'Author': 'Me',\n            'Title': 'Awesome fig'}`.\n\n            The standard keys are `'Title'`, `'Author'`, `'Subject'`,\n            `'Keywords'`, `'Creator'`, `'Producer'`, `'CreationDate'`,\n            `'ModDate'`, and `'Trapped'`. Values have been predefined\n            for `'Creator'`, `'Producer'` and `'CreationDate'`. They\n            can be removed by setting them to `None`.\n        \"\"\"\n        self._object_seq = itertools.count(1)  # consumed by reserveObject\n        self.xrefTable = [[0, 65535, 'the zero object']]\n        self.passed_in_file_object = False\n        self.original_file_like = None\n        self.tell_base = 0\n        fh, opened = cbook.to_filehandle(filename, \"wb\", return_opened=True)\n        if not opened:\n            try:\n                self.tell_base = filename.tell()\n            except IOError:\n                fh = BytesIO()\n                self.original_file_like = filename\n            else:\n                fh = filename\n                self.passed_in_file_object = True\n\n        self.fh = fh\n        self.currentstream = None  # stream object to write to, if any\n        fh.write(b\"%PDF-1.4\\n\")    # 1.4 is the first version to have alpha\n        # Output some eight-bit chars as a comment so various utilities\n        # recognize the file as binary by looking at the first few\n        # lines (see note in section 3.4.1 of the PDF reference).\n        fh.write(b\"%\\254\\334 \\253\\272\\n\")\n\n        self.rootObject = self.reserveObject('root')\n        self.pagesObject = self.reserveObject('pages')\n        self.pageList = []\n        self.fontObject = self.reserveObject('fonts')\n        self._extGStateObject = self.reserveObject('extended graphics states')\n        self.hatchObject = self.reserveObject('tiling patterns')\n        self.gouraudObject = self.reserveObject('Gouraud triangles')\n        self.XObjectObject = self.reserveObject('external objects')\n        self.resourceObject = self.reserveObject('resources')\n\n        root = {'Type': Name('Catalog'),\n                'Pages': self.pagesObject}\n        self.writeObject(self.rootObject, root)\n\n        # get source date from SOURCE_DATE_EPOCH, if set\n        # See https://reproducible-builds.org/specs/source-date-epoch/\n        source_date_epoch = os.getenv(\"SOURCE_DATE_EPOCH\")\n        if source_date_epoch:\n            source_date = datetime.utcfromtimestamp(int(source_date_epoch))\n            source_date = source_date.replace(tzinfo=UTC)\n        else:\n            source_date = datetime.today()\n\n        self.infoDict = {\n            'Creator': 'matplotlib %s, http://matplotlib.org' % __version__,\n            'Producer': 'matplotlib pdf backend %s' % __version__,\n            'CreationDate': source_date\n        }\n        if metadata is not None:\n            self.infoDict.update(metadata)\n        self.infoDict = {k: v for (k, v) in self.infoDict.items()\n                         if v is not None}\n\n        self.fontNames = {}     # maps filenames to internal font names\n        self._internal_font_seq = (Name(f'F{i}') for i in itertools.count(1))\n        self.dviFontInfo = {}   # maps dvi font names to embedding information\n        # differently encoded Type-1 fonts may share the same descriptor\n        self.type1Descriptors = {}\n        self.used_characters = {}\n\n        self.alphaStates = {}   # maps alpha values to graphics state objects\n        self._alpha_state_seq = (Name(f'A{i}') for i in itertools.count(1))\n        self._soft_mask_states = {}\n        self._soft_mask_seq = (Name(f'SM{i}') for i in itertools.count(1))\n        self._soft_mask_groups = []\n        # reproducible writeHatches needs an ordered dict:\n        self.hatchPatterns = collections.OrderedDict()\n        self._hatch_pattern_seq = (Name(f'H{i}') for i in itertools.count(1))\n        self.gouraudTriangles = []\n\n        self._images = collections.OrderedDict()   # reproducible writeImages\n        self._image_seq = (Name(f'I{i}') for i in itertools.count(1))\n\n        self.markers = collections.OrderedDict()   # reproducible writeMarkers\n        self.multi_byte_charprocs = {}\n\n        self.paths = []\n\n        self.pageAnnotations = []  # A list of annotations for the current page\n\n        # The PDF spec recommends to include every procset\n        procsets = [Name(x)\n                    for x in \"PDF Text ImageB ImageC ImageI\".split()]\n\n        # Write resource dictionary.\n        # Possibly TODO: more general ExtGState (graphics state dictionaries)\n        #                ColorSpace Pattern Shading Properties\n        resources = {'Font': self.fontObject,\n                     'XObject': self.XObjectObject,\n                     'ExtGState': self._extGStateObject,\n                     'Pattern': self.hatchObject,\n                     'Shading': self.gouraudObject,\n                     'ProcSet': procsets}\n        self.writeObject(self.resourceObject, resources)",
        "begin_line": 435,
        "end_line": 551,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.newPage#553",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.newPage(self, width, height)",
        "snippet": "    def newPage(self, width, height):\n        self.endStream()\n\n        self.width, self.height = width, height\n        contentObject = self.reserveObject('page contents')\n        thePage = {'Type': Name('Page'),\n                   'Parent': self.pagesObject,\n                   'Resources': self.resourceObject,\n                   'MediaBox': [0, 0, 72 * width, 72 * height],\n                   'Contents': contentObject,\n                   'Group': {'Type': Name('Group'),\n                             'S': Name('Transparency'),\n                             'CS': Name('DeviceRGB')},\n                   'Annots': self.pageAnnotations,\n                   }\n        pageObject = self.reserveObject('page')\n        self.writeObject(pageObject, thePage)\n        self.pageList.append(pageObject)\n\n        self.beginStream(contentObject.id,\n                         self.reserveObject('length of content stream'))\n        # Initialize the pdf graphics state to match the default mpl\n        # graphics context: currently only the join style needs to be set\n        self.output(GraphicsContextPdf.joinstyles['round'], Op.setlinejoin)\n\n        # Clear the list of annotations for the next page\n        self.pageAnnotations = []",
        "begin_line": 553,
        "end_line": 579,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.finalize#592",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.finalize(self)",
        "snippet": "    def finalize(self):\n        \"Write out the various deferred objects and the pdf end matter.\"\n\n        self.endStream()\n        self.writeFonts()\n        self.writeExtGSTates()\n        self._write_soft_mask_groups()\n        self.writeHatches()\n        self.writeGouraudTriangles()\n        xobjects = {\n            name: ob for image, name, ob in self._images.values()}\n        for tup in self.markers.values():\n            xobjects[tup[0]] = tup[1]\n        for name, value in self.multi_byte_charprocs.items():\n            xobjects[name] = value\n        for name, path, trans, ob, join, cap, padding, filled, stroked \\\n                in self.paths:\n            xobjects[name] = ob\n        self.writeObject(self.XObjectObject, xobjects)\n        self.writeImages()\n        self.writeMarkers()\n        self.writePathCollectionTemplates()\n        self.writeObject(self.pagesObject,\n                         {'Type': Name('Pages'),\n                          'Kids': self.pageList,\n                          'Count': len(self.pageList)})\n        self.writeInfoDict()\n\n        # Finalize the file\n        self.writeXref()\n        self.writeTrailer()",
        "begin_line": 592,
        "end_line": 622,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.close#624",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.close(self)",
        "snippet": "    def close(self):\n        \"Flush all buffers and free all resources.\"\n\n        self.endStream()\n        if self.passed_in_file_object:\n            self.fh.flush()\n        else:\n            if self.original_file_like is not None:\n                self.original_file_like.write(self.fh.getvalue())\n            self.fh.close()",
        "begin_line": 624,
        "end_line": 633,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.03793907242183e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.endStream#649",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.endStream(self)",
        "snippet": "    def endStream(self):\n        if self.currentstream is not None:\n            self.currentstream.end()\n            self.currentstream = None",
        "begin_line": 649,
        "end_line": 652,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.03793907242183e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.fontName#654",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.fontName(self, fontprop)",
        "snippet": "    def fontName(self, fontprop):\n        \"\"\"\n        Select a font based on fontprop and return a name suitable for\n        Op.selectfont. If fontprop is a string, it will be interpreted\n        as the filename of the font.\n        \"\"\"\n\n        if isinstance(fontprop, str):\n            filename = fontprop\n        elif rcParams['pdf.use14corefonts']:\n            filename = findfont(\n                fontprop, fontext='afm', directory=RendererPdf._afm_font_dir)\n            if filename is None:\n                filename = findfont(\n                    \"Helvetica\",\n                    fontext='afm', directory=RendererPdf._afm_font_dir)\n        else:\n            filename = findfont(fontprop)\n\n        Fx = self.fontNames.get(filename)\n        if Fx is None:\n            Fx = next(self._internal_font_seq)\n            self.fontNames[filename] = Fx\n            _log.debug('Assigning font %s = %r', Fx, filename)\n\n        return Fx",
        "begin_line": 654,
        "end_line": 679,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.writeFonts#711",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.writeFonts(self)",
        "snippet": "    def writeFonts(self):\n        fonts = {}\n        for dviname, info in sorted(self.dviFontInfo.items()):\n            Fx = info.pdfname\n            _log.debug('Embedding Type-1 font %s from dvi.', dviname)\n            fonts[Fx] = self._embedTeXFont(info)\n        for filename in sorted(self.fontNames):\n            Fx = self.fontNames[filename]\n            _log.debug('Embedding font %s.', filename)\n            if filename.endswith('.afm'):\n                # from pdf.use14corefonts\n                _log.debug('Writing AFM font.')\n                fonts[Fx] = self._write_afm_font(filename)\n            else:\n                # a normal TrueType font\n                _log.debug('Writing TrueType font.')\n                realpath, stat_key = cbook.get_realpath_and_stat(filename)\n                chars = self.used_characters.get(stat_key)\n                if chars is not None and len(chars[1]):\n                    fonts[Fx] = self.embedTTF(realpath, chars[1])\n        self.writeObject(self.fontObject, fonts)",
        "begin_line": 711,
        "end_line": 731,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.embedTTFType3#913",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.embedTTFType3(font, characters, descriptor)",
        "snippet": "        def embedTTFType3(font, characters, descriptor):\n            \"\"\"The Type 3-specific part of embedding a Truetype font\"\"\"\n            widthsObject = self.reserveObject('font widths')\n            fontdescObject = self.reserveObject('font descriptor')\n            fontdictObject = self.reserveObject('font dictionary')\n            charprocsObject = self.reserveObject('character procs')\n            differencesArray = []\n            firstchar, lastchar = 0, 255\n            bbox = [cvt(x, nearest=False) for x in font.bbox]\n\n            fontdict = {\n                'Type': Name('Font'),\n                'BaseFont': ps_name,\n                'FirstChar': firstchar,\n                'LastChar': lastchar,\n                'FontDescriptor': fontdescObject,\n                'Subtype': Name('Type3'),\n                'Name': descriptor['FontName'],\n                'FontBBox': bbox,\n                'FontMatrix': [.001, 0, 0, .001, 0, 0],\n                'CharProcs': charprocsObject,\n                'Encoding': {\n                    'Type': Name('Encoding'),\n                    'Differences': differencesArray},\n                'Widths': widthsObject\n                }\n\n            from encodings import cp1252\n\n            # Make the \"Widths\" array\n            def get_char_width(charcode):\n                s = ord(cp1252.decoding_table[charcode])\n                width = font.load_char(\n                    s, flags=LOAD_NO_SCALE | LOAD_NO_HINTING).horiAdvance\n                return cvt(width)\n\n            with warnings.catch_warnings():\n                # Ignore 'Required glyph missing from current font' warning\n                # from ft2font: here we're just building the widths table, but\n                # the missing glyphs may not even be used in the actual string.\n                warnings.filterwarnings(\"ignore\")\n                widths = [get_char_width(charcode)\n                          for charcode in range(firstchar, lastchar+1)]\n            descriptor['MaxWidth'] = max(widths)\n\n            # Make the \"Differences\" array, sort the ccodes < 255 from\n            # the multi-byte ccodes, and build the whole set of glyph ids\n            # that we need from this font.\n            glyph_ids = []\n            differences = []\n            multi_byte_chars = set()\n            for c in characters:\n                ccode = c\n                gind = font.get_char_index(ccode)\n                glyph_ids.append(gind)\n                glyph_name = font.get_glyph_name(gind)\n                if ccode <= 255:\n                    differences.append((ccode, glyph_name))\n                else:\n                    multi_byte_chars.add(glyph_name)\n            differences.sort()\n\n            last_c = -2\n            for c, name in differences:\n                if c != last_c + 1:\n                    differencesArray.append(c)\n                differencesArray.append(Name(name))\n                last_c = c\n\n            # Make the charprocs array (using ttconv to generate the\n            # actual outlines)\n            try:\n                rawcharprocs = ttconv.get_pdf_charprocs(\n                    os.fsencode(filename), glyph_ids)\n            except RuntimeError:\n                _log.warning(\"The PDF backend does not currently support the \"\n                             \"selected font.\")\n                raise\n            charprocs = {}\n            for charname in sorted(rawcharprocs):\n                stream = rawcharprocs[charname]\n                charprocDict = {'Length': len(stream)}\n                # The 2-byte characters are used as XObjects, so they\n                # need extra info in their dictionary\n                if charname in multi_byte_chars:\n                    charprocDict['Type'] = Name('XObject')\n                    charprocDict['Subtype'] = Name('Form')\n                    charprocDict['BBox'] = bbox\n                    # Each glyph includes bounding box information,\n                    # but xpdf and ghostscript can't handle it in a\n                    # Form XObject (they segfault!!!), so we remove it\n                    # from the stream here.  It's not needed anyway,\n                    # since the Form XObject includes it in its BBox\n                    # value.\n                    stream = stream[stream.find(b\"d1\") + 2:]\n                charprocObject = self.reserveObject('charProc')\n                self.beginStream(charprocObject.id, None, charprocDict)\n                self.currentstream.write(stream)\n                self.endStream()\n\n                # Send the glyphs with ccode > 255 to the XObject dictionary,\n                # and the others to the font itself\n                if charname in multi_byte_chars:\n                    name = self._get_xobject_symbol_name(filename, charname)\n                    self.multi_byte_charprocs[name] = charprocObject\n                else:\n                    charprocs[charname] = charprocObject\n\n            # Write everything out\n            self.writeObject(fontdictObject, fontdict)\n            self.writeObject(fontdescObject, descriptor)\n            self.writeObject(widthsObject, widths)\n            self.writeObject(charprocsObject, charprocs)\n\n            return fontdictObject",
        "begin_line": 913,
        "end_line": 1027,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.embedTTF#896",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.embedTTF(self, filename, characters)",
        "snippet": "    def embedTTF(self, filename, characters):\n        \"\"\"Embed the TTF font from the named file into the document.\"\"\"\n\n        font = get_font(filename)\n        fonttype = rcParams['pdf.fonttype']\n\n        def cvt(length, upe=font.units_per_EM, nearest=True):\n            \"Convert font coordinates to PDF glyph coordinates\"\n            value = length / upe * 1000\n            if nearest:\n                return round(value)\n            # Best(?) to round away from zero for bounding boxes and the like.\n            if value < 0:\n                return math.floor(value)\n            else:\n                return math.ceil(value)\n\n        def embedTTFType3(font, characters, descriptor):\n            \"\"\"The Type 3-specific part of embedding a Truetype font\"\"\"\n            widthsObject = self.reserveObject('font widths')\n            fontdescObject = self.reserveObject('font descriptor')\n            fontdictObject = self.reserveObject('font dictionary')\n            charprocsObject = self.reserveObject('character procs')\n            differencesArray = []\n            firstchar, lastchar = 0, 255\n            bbox = [cvt(x, nearest=False) for x in font.bbox]\n\n            fontdict = {\n                'Type': Name('Font'),\n                'BaseFont': ps_name,\n                'FirstChar': firstchar,\n                'LastChar': lastchar,\n                'FontDescriptor': fontdescObject,\n                'Subtype': Name('Type3'),\n                'Name': descriptor['FontName'],\n                'FontBBox': bbox,\n                'FontMatrix': [.001, 0, 0, .001, 0, 0],\n                'CharProcs': charprocsObject,\n                'Encoding': {\n                    'Type': Name('Encoding'),\n                    'Differences': differencesArray},\n                'Widths': widthsObject\n                }\n\n            from encodings import cp1252\n\n            # Make the \"Widths\" array\n            def get_char_width(charcode):\n                s = ord(cp1252.decoding_table[charcode])\n                width = font.load_char(\n                    s, flags=LOAD_NO_SCALE | LOAD_NO_HINTING).horiAdvance\n                return cvt(width)\n\n            with warnings.catch_warnings():\n                # Ignore 'Required glyph missing from current font' warning\n                # from ft2font: here we're just building the widths table, but\n                # the missing glyphs may not even be used in the actual string.\n                warnings.filterwarnings(\"ignore\")\n                widths = [get_char_width(charcode)\n                          for charcode in range(firstchar, lastchar+1)]\n            descriptor['MaxWidth'] = max(widths)\n\n            # Make the \"Differences\" array, sort the ccodes < 255 from\n            # the multi-byte ccodes, and build the whole set of glyph ids\n            # that we need from this font.\n            glyph_ids = []\n            differences = []\n            multi_byte_chars = set()\n            for c in characters:\n                ccode = c\n                gind = font.get_char_index(ccode)\n                glyph_ids.append(gind)\n                glyph_name = font.get_glyph_name(gind)\n                if ccode <= 255:\n                    differences.append((ccode, glyph_name))\n                else:\n                    multi_byte_chars.add(glyph_name)\n            differences.sort()\n\n            last_c = -2\n            for c, name in differences:\n                if c != last_c + 1:\n                    differencesArray.append(c)\n                differencesArray.append(Name(name))\n                last_c = c\n\n            # Make the charprocs array (using ttconv to generate the\n            # actual outlines)\n            try:\n                rawcharprocs = ttconv.get_pdf_charprocs(\n                    os.fsencode(filename), glyph_ids)\n            except RuntimeError:\n                _log.warning(\"The PDF backend does not currently support the \"\n                             \"selected font.\")\n                raise\n            charprocs = {}\n            for charname in sorted(rawcharprocs):\n                stream = rawcharprocs[charname]\n                charprocDict = {'Length': len(stream)}\n                # The 2-byte characters are used as XObjects, so they\n                # need extra info in their dictionary\n                if charname in multi_byte_chars:\n                    charprocDict['Type'] = Name('XObject')\n                    charprocDict['Subtype'] = Name('Form')\n                    charprocDict['BBox'] = bbox\n                    # Each glyph includes bounding box information,\n                    # but xpdf and ghostscript can't handle it in a\n                    # Form XObject (they segfault!!!), so we remove it\n                    # from the stream here.  It's not needed anyway,\n                    # since the Form XObject includes it in its BBox\n                    # value.\n                    stream = stream[stream.find(b\"d1\") + 2:]\n                charprocObject = self.reserveObject('charProc')\n                self.beginStream(charprocObject.id, None, charprocDict)\n                self.currentstream.write(stream)\n                self.endStream()\n\n                # Send the glyphs with ccode > 255 to the XObject dictionary,\n                # and the others to the font itself\n                if charname in multi_byte_chars:\n                    name = self._get_xobject_symbol_name(filename, charname)\n                    self.multi_byte_charprocs[name] = charprocObject\n                else:\n                    charprocs[charname] = charprocObject\n\n            # Write everything out\n            self.writeObject(fontdictObject, fontdict)\n            self.writeObject(fontdescObject, descriptor)\n            self.writeObject(widthsObject, widths)\n            self.writeObject(charprocsObject, charprocs)\n\n            return fontdictObject\n\n        def embedTTFType42(font, characters, descriptor):\n            \"\"\"The Type 42-specific part of embedding a Truetype font\"\"\"\n            fontdescObject = self.reserveObject('font descriptor')\n            cidFontDictObject = self.reserveObject('CID font dictionary')\n            type0FontDictObject = self.reserveObject('Type 0 font dictionary')\n            cidToGidMapObject = self.reserveObject('CIDToGIDMap stream')\n            fontfileObject = self.reserveObject('font file stream')\n            wObject = self.reserveObject('Type 0 widths')\n            toUnicodeMapObject = self.reserveObject('ToUnicode map')\n\n            cidFontDict = {\n                'Type': Name('Font'),\n                'Subtype': Name('CIDFontType2'),\n                'BaseFont': ps_name,\n                'CIDSystemInfo': {\n                    'Registry': 'Adobe',\n                    'Ordering': 'Identity',\n                    'Supplement': 0},\n                'FontDescriptor': fontdescObject,\n                'W': wObject,\n                'CIDToGIDMap': cidToGidMapObject\n                }\n\n            type0FontDict = {\n                'Type': Name('Font'),\n                'Subtype': Name('Type0'),\n                'BaseFont': ps_name,\n                'Encoding': Name('Identity-H'),\n                'DescendantFonts': [cidFontDictObject],\n                'ToUnicode': toUnicodeMapObject\n                }\n\n            # Make fontfile stream\n            descriptor['FontFile2'] = fontfileObject\n            length1Object = self.reserveObject('decoded length of a font')\n            self.beginStream(\n                fontfileObject.id,\n                self.reserveObject('length of font stream'),\n                {'Length1': length1Object})\n            with open(filename, 'rb') as fontfile:\n                length1 = 0\n                while True:\n                    data = fontfile.read(4096)\n                    if not data:\n                        break\n                    length1 += len(data)\n                    self.currentstream.write(data)\n            self.endStream()\n            self.writeObject(length1Object, length1)\n\n            # Make the 'W' (Widths) array, CidToGidMap and ToUnicode CMap\n            # at the same time\n            cid_to_gid_map = ['\\0'] * 65536\n            widths = []\n            max_ccode = 0\n            for c in characters:\n                ccode = c\n                gind = font.get_char_index(ccode)\n                glyph = font.load_char(ccode,\n                                       flags=LOAD_NO_SCALE | LOAD_NO_HINTING)\n                widths.append((ccode, cvt(glyph.horiAdvance)))\n                if ccode < 65536:\n                    cid_to_gid_map[ccode] = chr(gind)\n                max_ccode = max(ccode, max_ccode)\n            widths.sort()\n            cid_to_gid_map = cid_to_gid_map[:max_ccode + 1]\n\n            last_ccode = -2\n            w = []\n            max_width = 0\n            unicode_groups = []\n            for ccode, width in widths:\n                if ccode != last_ccode + 1:\n                    w.append(ccode)\n                    w.append([width])\n                    unicode_groups.append([ccode, ccode])\n                else:\n                    w[-1].append(width)\n                    unicode_groups[-1][1] = ccode\n                max_width = max(max_width, width)\n                last_ccode = ccode\n\n            unicode_bfrange = []\n            for start, end in unicode_groups:\n                unicode_bfrange.append(\n                    b\"<%04x> <%04x> [%s]\" %\n                    (start, end,\n                     b\" \".join(b\"<%04x>\" % x for x in range(start, end+1))))\n            unicode_cmap = (self._identityToUnicodeCMap %\n                            (len(unicode_groups), b\"\\n\".join(unicode_bfrange)))\n\n            # CIDToGIDMap stream\n            cid_to_gid_map = \"\".join(cid_to_gid_map).encode(\"utf-16be\")\n            self.beginStream(cidToGidMapObject.id,\n                             None,\n                             {'Length': len(cid_to_gid_map)})\n            self.currentstream.write(cid_to_gid_map)\n            self.endStream()\n\n            # ToUnicode CMap\n            self.beginStream(toUnicodeMapObject.id,\n                             None,\n                             {'Length': unicode_cmap})\n            self.currentstream.write(unicode_cmap)\n            self.endStream()\n\n            descriptor['MaxWidth'] = max_width\n\n            # Write everything out\n            self.writeObject(cidFontDictObject, cidFontDict)\n            self.writeObject(type0FontDictObject, type0FontDict)\n            self.writeObject(fontdescObject, descriptor)\n            self.writeObject(wObject, w)\n\n            return type0FontDictObject\n\n        # Beginning of main embedTTF function...\n\n        ps_name = font.postscript_name.encode('ascii', 'replace')\n        ps_name = Name(ps_name)\n        pclt = font.get_sfnt_table('pclt') or {'capHeight': 0, 'xHeight': 0}\n        post = font.get_sfnt_table('post') or {'italicAngle': (0, 0)}\n        ff = font.face_flags\n        sf = font.style_flags\n\n        flags = 0\n        symbolic = False  # ps_name.name in ('Cmsy10', 'Cmmi10', 'Cmex10')\n        if ff & FIXED_WIDTH:\n            flags |= 1 << 0\n        if 0:  # TODO: serif\n            flags |= 1 << 1\n        if symbolic:\n            flags |= 1 << 2\n        else:\n            flags |= 1 << 5\n        if sf & ITALIC:\n            flags |= 1 << 6\n        if 0:  # TODO: all caps\n            flags |= 1 << 16\n        if 0:  # TODO: small caps\n            flags |= 1 << 17\n        if 0:  # TODO: force bold\n            flags |= 1 << 18\n\n        descriptor = {\n            'Type': Name('FontDescriptor'),\n            'FontName': ps_name,\n            'Flags': flags,\n            'FontBBox': [cvt(x, nearest=False) for x in font.bbox],\n            'Ascent': cvt(font.ascender, nearest=False),\n            'Descent': cvt(font.descender, nearest=False),\n            'CapHeight': cvt(pclt['capHeight'], nearest=False),\n            'XHeight': cvt(pclt['xHeight']),\n            'ItalicAngle': post['italicAngle'][1],  # ???\n            'StemV': 0  # ???\n            }\n\n        # The font subsetting to a Type 3 font does not work for\n        # OpenType (.otf) that embed a Postscript CFF font, so avoid that --\n        # save as a (non-subsetted) Type 42 font instead.\n        if is_opentype_cff_font(filename):\n            fonttype = 42\n            _log.warning(\"%r can not be subsetted into a Type 3 font. The \"\n                         \"entire font will be embedded in the output.\",\n                         os.path.basename(filename))\n\n        if fonttype == 3:\n            return embedTTFType3(font, characters, descriptor)\n        elif fonttype == 42:\n            return embedTTFType42(font, characters, descriptor)",
        "begin_line": 896,
        "end_line": 1198,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.alphaState#1200",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.alphaState(self, alpha)",
        "snippet": "    def alphaState(self, alpha):\n        \"\"\"Return name of an ExtGState that sets alpha to the given value.\"\"\"\n\n        state = self.alphaStates.get(alpha, None)\n        if state is not None:\n            return state[0]\n\n        name = next(self._alpha_state_seq)\n        self.alphaStates[alpha] = \\\n            (name, {'Type': Name('ExtGState'),\n                    'CA': alpha[0], 'ca': alpha[1]})\n        return name",
        "begin_line": 1200,
        "end_line": 1211,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.writeExtGSTates#1264",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.writeExtGSTates(self)",
        "snippet": "    def writeExtGSTates(self):\n        self.writeObject(\n            self._extGStateObject,\n            dict([\n                *self.alphaStates.values(),\n                *self._soft_mask_states.values()\n            ])\n        )",
        "begin_line": 1264,
        "end_line": 1271,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.667764583513912e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile._write_soft_mask_groups#1273",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile._write_soft_mask_groups(self)",
        "snippet": "    def _write_soft_mask_groups(self):\n        for ob, attributes, content in self._soft_mask_groups:\n            self.beginStream(ob.id, None, attributes)\n            self.output(*content)\n            self.endStream()",
        "begin_line": 1273,
        "end_line": 1277,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.writeHatches#1297",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.writeHatches(self)",
        "snippet": "    def writeHatches(self):\n        hatchDict = dict()\n        sidelen = 72.0\n        for hatch_style, name in self.hatchPatterns.items():\n            ob = self.reserveObject('hatch pattern')\n            hatchDict[name] = ob\n            res = {'Procsets':\n                   [Name(x) for x in \"PDF Text ImageB ImageC ImageI\".split()]}\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('Pattern'),\n                 'PatternType': 1, 'PaintType': 1, 'TilingType': 1,\n                 'BBox': [0, 0, sidelen, sidelen],\n                 'XStep': sidelen, 'YStep': sidelen,\n                 'Resources': res,\n                 # Change origin to match Agg at top-left.\n                 'Matrix': [1, 0, 0, 1, 0, self.height * 72]})\n\n            stroke_rgb, fill_rgb, path = hatch_style\n            self.output(stroke_rgb[0], stroke_rgb[1], stroke_rgb[2],\n                        Op.setrgb_stroke)\n            if fill_rgb is not None:\n                self.output(fill_rgb[0], fill_rgb[1], fill_rgb[2],\n                            Op.setrgb_nonstroke,\n                            0, 0, sidelen, sidelen, Op.rectangle,\n                            Op.fill)\n\n            self.output(rcParams['hatch.linewidth'], Op.setlinewidth)\n\n            self.output(*self.pathOperations(\n                Path.hatch(path),\n                Affine2D().scale(sidelen),\n                simplify=False))\n            self.output(Op.fill_stroke)\n\n            self.endStream()\n        self.writeObject(self.hatchObject, hatchDict)",
        "begin_line": 1297,
        "end_line": 1333,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.03793907242183e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.writeGouraudTriangles#1357",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.writeGouraudTriangles(self)",
        "snippet": "    def writeGouraudTriangles(self):\n        gouraudDict = dict()\n        for name, ob, points, colors in self.gouraudTriangles:\n            gouraudDict[name] = ob\n            shape = points.shape\n            flat_points = points.reshape((shape[0] * shape[1], 2))\n            colordim = colors.shape[2]\n            assert colordim in (1, 4)\n            flat_colors = colors.reshape((shape[0] * shape[1], colordim))\n            if colordim == 4:\n                # strip the alpha channel\n                colordim = 3\n            points_min = np.min(flat_points, axis=0) - (1 << 8)\n            points_max = np.max(flat_points, axis=0) + (1 << 8)\n            factor = 0xffffffff / (points_max - points_min)\n\n            self.beginStream(\n                ob.id, None,\n                {'ShadingType': 4,\n                 'BitsPerCoordinate': 32,\n                 'BitsPerComponent': 8,\n                 'BitsPerFlag': 8,\n                 'ColorSpace': Name(\n                     'DeviceRGB' if colordim == 3 else 'DeviceGray'\n                 ),\n                 'AntiAlias': False,\n                 'Decode': ([points_min[0], points_max[0],\n                             points_min[1], points_max[1]]\n                            + [0, 1] * colordim),\n                 })\n\n            streamarr = np.empty(\n                (shape[0] * shape[1],),\n                dtype=[('flags', 'u1'),\n                       ('points', '>u4', (2,)),\n                       ('colors', 'u1', (colordim,))])\n            streamarr['flags'] = 0\n            streamarr['points'] = (flat_points - points_min) * factor\n            streamarr['colors'] = flat_colors[:, :colordim] * 255.0\n\n            self.write(streamarr.tostring())\n            self.endStream()\n        self.writeObject(self.gouraudObject, gouraudDict)",
        "begin_line": 1357,
        "end_line": 1399,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.228420966016621e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.imageObject#1401",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.imageObject(self, image)",
        "snippet": "    def imageObject(self, image):\n        \"\"\"Return name of an image XObject representing the given image.\"\"\"\n\n        entry = self._images.get(id(image), None)\n        if entry is not None:\n            return entry[1]\n\n        name = next(self._image_seq)\n        ob = self.reserveObject(f'image {name}')\n        self._images[id(image)] = (image, name, ob)\n        return name",
        "begin_line": 1401,
        "end_line": 1411,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile._unpack#1413",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile._unpack(self, im)",
        "snippet": "    def _unpack(self, im):\n        \"\"\"\n        Unpack the image object im into height, width, data, alpha,\n        where data and alpha are HxWx3 (RGB) or HxWx1 (grayscale or alpha)\n        arrays, except alpha is None if the image is fully opaque.\n        \"\"\"\n        h, w = im.shape[:2]\n        im = im[::-1]\n        if im.ndim == 2:\n            return h, w, im, None\n        else:\n            rgb = im[:, :, :3]\n            rgb = np.array(rgb, order='C')\n            # PDF needs a separate alpha image\n            if im.shape[2] == 4:\n                alpha = im[:, :, 3][..., None]\n                if np.all(alpha == 255):\n                    alpha = None\n                else:\n                    alpha = np.array(alpha, order='C')\n            else:\n                alpha = None\n            return h, w, rgb, alpha",
        "begin_line": 1413,
        "end_line": 1435,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile._writePng#1437",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile._writePng(self, data)",
        "snippet": "    def _writePng(self, data):\n        \"\"\"\n        Write the image *data* into the pdf file using png\n        predictors with Flate compression.\n        \"\"\"\n        buffer = BytesIO()\n        _png.write_png(data, buffer)\n        buffer.seek(8)\n        while True:\n            length, type = struct.unpack(b'!L4s', buffer.read(8))\n            if type == b'IDAT':\n                data = buffer.read(length)\n                if len(data) != length:\n                    raise RuntimeError(\"truncated data\")\n                self.currentstream.write(data)\n            elif type == b'IEND':\n                break\n            else:\n                buffer.seek(length, 1)\n            buffer.seek(4, 1)   # skip CRC",
        "begin_line": 1437,
        "end_line": 1456,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile._writeImg#1458",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile._writeImg(self, data, height, width, grayscale, id, smask=None)",
        "snippet": "    def _writeImg(self, data, height, width, grayscale, id, smask=None):\n        \"\"\"\n        Write the image *data* of size *height* x *width*, as grayscale\n        if *grayscale* is true and RGB otherwise, as pdf object *id*\n        and with the soft mask (alpha channel) *smask*, which should be\n        either None or a *height* x *width* x 1 array.\n        \"\"\"\n\n        obj = {'Type':             Name('XObject'),\n               'Subtype':          Name('Image'),\n               'Width':            width,\n               'Height':           height,\n               'ColorSpace':       Name('DeviceGray' if grayscale\n                                        else 'DeviceRGB'),\n               'BitsPerComponent': 8}\n        if smask:\n            obj['SMask'] = smask\n        if rcParams['pdf.compression']:\n            png = {'Predictor': 10,\n                   'Colors':    1 if grayscale else 3,\n                   'Columns':   width}\n        else:\n            png = None\n        self.beginStream(\n            id,\n            self.reserveObject('length of image stream'),\n            obj,\n            png=png\n            )\n        if png:\n            self._writePng(data)\n        else:\n            self.currentstream.write(data.tostring())\n        self.endStream()",
        "begin_line": 1458,
        "end_line": 1491,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.writeImages#1493",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.writeImages(self)",
        "snippet": "    def writeImages(self):\n        for img, name, ob in self._images.values():\n            height, width, data, adata = self._unpack(img)\n            if adata is not None:\n                smaskObject = self.reserveObject(\"smask\")\n                self._writeImg(adata, height, width, True, smaskObject.id)\n            else:\n                smaskObject = None\n            self._writeImg(data, height, width, False,\n                           ob.id, smaskObject)",
        "begin_line": 1493,
        "end_line": 1502,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject#1504",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject(self, path, trans, fill, stroke, lw, joinstyle, capstyle)",
        "snippet": "    def markerObject(self, path, trans, fill, stroke, lw, joinstyle,\n                     capstyle):\n        \"\"\"Return name of a marker XObject representing the given path.\"\"\"\n        # self.markers used by markerObject, writeMarkers, close:\n        # mapping from (path operations, fill?, stroke?) to\n        #   [name, object reference, bounding box, linewidth]\n        # This enables different draw_markers calls to share the XObject\n        # if the gc is sufficiently similar: colors etc can vary, but\n        # the choices of whether to fill and whether to stroke cannot.\n        # We need a bounding box enclosing all of the XObject path,\n        # but since line width may vary, we store the maximum of all\n        # occurring line widths in self.markers.\n        # close() is somewhat tightly coupled in that it expects the\n        # first two components of each value in self.markers to be the\n        # name and object reference.\n        pathops = self.pathOperations(path, trans, simplify=False)\n        key = (tuple(pathops), bool(fill), bool(stroke), joinstyle, capstyle)\n        result = self.markers.get(key)\n        if result is None:\n            name = Name('M%d' % len(self.markers))\n            ob = self.reserveObject('marker %d' % len(self.markers))\n            bbox = path.get_extents(trans)\n            self.markers[key] = [name, ob, bbox, lw]\n        else:\n            if result[-1] < lw:\n                result[-1] = lw\n            name = result[0]\n        return name",
        "begin_line": 1504,
        "end_line": 1531,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.writeMarkers#1533",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.writeMarkers(self)",
        "snippet": "    def writeMarkers(self):\n        for ((pathops, fill, stroke, joinstyle, capstyle),\n             (name, ob, bbox, lw)) in self.markers.items():\n            bbox = bbox.padded(lw * 0.5)\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('XObject'), 'Subtype': Name('Form'),\n                 'BBox': list(bbox.extents)})\n            self.output(GraphicsContextPdf.joinstyles[joinstyle],\n                        Op.setlinejoin)\n            self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)\n            self.output(*pathops)\n            self.output(Op.paint_path(fill, stroke))\n            self.endStream()",
        "begin_line": 1533,
        "end_line": 1546,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.writePathCollectionTemplates#1556",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.writePathCollectionTemplates(self)",
        "snippet": "    def writePathCollectionTemplates(self):\n        for (name, path, trans, ob, joinstyle, capstyle, padding, filled,\n             stroked) in self.paths:\n            pathops = self.pathOperations(path, trans, simplify=False)\n            bbox = path.get_extents(trans)\n            if not np.all(np.isfinite(bbox.extents)):\n                extents = [0, 0, 0, 0]\n            else:\n                bbox = bbox.padded(padding)\n                extents = list(bbox.extents)\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('XObject'), 'Subtype': Name('Form'),\n                 'BBox': extents})\n            self.output(GraphicsContextPdf.joinstyles[joinstyle],\n                        Op.setlinejoin)\n            self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)\n            self.output(*pathops)\n            self.output(Op.paint_path(filled, stroked))\n            self.endStream()",
        "begin_line": 1556,
        "end_line": 1575,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.pathOperations#1578",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.pathOperations(path, transform, clip=None, simplify=None, sketch=None)",
        "snippet": "    def pathOperations(path, transform, clip=None, simplify=None, sketch=None):\n        return [Verbatim(_path.convert_to_string(\n            path, transform, clip, simplify, sketch,\n            6,\n            [Op.moveto.op, Op.lineto.op, b'', Op.curveto.op, Op.closepath.op],\n            True))]",
        "begin_line": 1578,
        "end_line": 1583,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.writePath#1585",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.writePath(self, path, transform, clip=False, sketch=None)",
        "snippet": "    def writePath(self, path, transform, clip=False, sketch=None):\n        if clip:\n            clip = (0.0, 0.0, self.width * 72, self.height * 72)\n            simplify = path.should_simplify\n        else:\n            clip = None\n            simplify = False\n        cmds = self.pathOperations(path, transform, clip, simplify=simplify,\n                                   sketch=sketch)\n        self.output(*cmds)",
        "begin_line": 1585,
        "end_line": 1594,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.reserveObject#1596",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.reserveObject(self, name='')",
        "snippet": "    def reserveObject(self, name=''):\n        \"\"\"Reserve an ID for an indirect object.\n        The name is used for debugging in case we forget to print out\n        the object with writeObject.\n        \"\"\"\n\n        id = next(self._object_seq)\n        self.xrefTable.append([None, 0, name])\n        return Reference(id)",
        "begin_line": 1596,
        "end_line": 1604,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.recordXref#1606",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.recordXref(self, id)",
        "snippet": "    def recordXref(self, id):\n        self.xrefTable[id][0] = self.fh.tell() - self.tell_base",
        "begin_line": 1606,
        "end_line": 1607,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.writeObject#1609",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.writeObject(self, object, contents)",
        "snippet": "    def writeObject(self, object, contents):\n        self.recordXref(object.id)\n        object.write(contents, self)",
        "begin_line": 1609,
        "end_line": 1611,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.writeXref#1613",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.writeXref(self)",
        "snippet": "    def writeXref(self):\n        \"\"\"Write out the xref table.\"\"\"\n        self.startxref = self.fh.tell() - self.tell_base\n        self.write(b\"xref\\n0 %d\\n\" % len(self.xrefTable))\n        for i, (offset, generation, name) in enumerate(self.xrefTable):\n            if offset is None:\n                raise AssertionError(\n                    'No offset for object %d (%s)' % (i, name))\n            else:\n                key = b\"f\" if name == 'the zero object' else b\"n\"\n                text = b\"%010d %05d %b \\n\" % (offset, generation, key)\n                self.write(text)",
        "begin_line": 1613,
        "end_line": 1624,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.writeInfoDict#1626",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.writeInfoDict(self)",
        "snippet": "    def writeInfoDict(self):\n        \"\"\"Write out the info dictionary, checking it for good form\"\"\"\n\n        def is_string_like(x):\n            return isinstance(x, str)\n\n        def is_date(x):\n            return isinstance(x, datetime)\n\n        check_trapped = (lambda x: isinstance(x, Name) and\n                         x.name in ('True', 'False', 'Unknown'))\n\n        keywords = {'Title': is_string_like,\n                    'Author': is_string_like,\n                    'Subject': is_string_like,\n                    'Keywords': is_string_like,\n                    'Creator': is_string_like,\n                    'Producer': is_string_like,\n                    'CreationDate': is_date,\n                    'ModDate': is_date,\n                    'Trapped': check_trapped}\n        for k in self.infoDict:\n            if k not in keywords:\n                cbook._warn_external('Unknown infodict keyword: %s' % k)\n            else:\n                if not keywords[k](self.infoDict[k]):\n                    cbook._warn_external(\n                        'Bad value for infodict keyword %s' % k)\n\n        self.infoObject = self.reserveObject('info')\n        self.writeObject(self.infoObject, self.infoDict)",
        "begin_line": 1626,
        "end_line": 1656,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.writeTrailer#1658",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.writeTrailer(self)",
        "snippet": "    def writeTrailer(self):\n        \"\"\"Write out the PDF trailer.\"\"\"\n\n        self.write(b\"trailer\\n\")\n        self.write(pdfRepr(\n            {'Size': len(self.xrefTable),\n             'Root': self.rootObject,\n             'Info': self.infoObject}))\n        # Could add 'ID'\n        self.write(b\"\\nstartxref\\n%d\\n%%%%EOF\\n\" % self.startxref)",
        "begin_line": 1658,
        "end_line": 1667,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.970032677133976e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.RendererPdf.__init__#1679",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.RendererPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.RendererPdf.__init__(self, file, image_dpi, height, width)",
        "snippet": "    def __init__(self, file, image_dpi, height, width):\n        RendererBase.__init__(self)\n        self.height = height\n        self.width = width\n        self.file = file\n        self.gc = self.new_gc()\n        self.mathtext_parser = MathTextParser(\"Pdf\")\n        self.image_dpi = image_dpi",
        "begin_line": 1679,
        "end_line": 1686,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.RendererPdf.check_gc#1691",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.RendererPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.RendererPdf.check_gc(self, gc, fillcolor=None)",
        "snippet": "    def check_gc(self, gc, fillcolor=None):\n        orig_fill = getattr(gc, '_fillcolor', (0., 0., 0.))\n        gc._fillcolor = fillcolor\n\n        orig_alphas = getattr(gc, '_effective_alphas', (1.0, 1.0))\n\n        if gc.get_rgb() is None:\n            # It should not matter what color here since linewidth should be\n            # 0 unless affected by global settings in rcParams, hence setting\n            # zero alpha just in case.\n            gc.set_foreground((0, 0, 0, 0), isRGBA=True)\n\n        if gc._forced_alpha:\n            gc._effective_alphas = (gc._alpha, gc._alpha)\n        elif fillcolor is None or len(fillcolor) < 4:\n            gc._effective_alphas = (gc._rgb[3], 1.0)\n        else:\n            gc._effective_alphas = (gc._rgb[3], fillcolor[3])\n\n        delta = self.gc.delta(gc)\n        if delta:\n            self.file.output(*delta)\n\n        # Restore gc to avoid unwanted side effects\n        gc._fillcolor = orig_fill\n        gc._effective_alphas = orig_alphas",
        "begin_line": 1691,
        "end_line": 1716,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.RendererPdf.track_characters#1718",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.RendererPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.RendererPdf.track_characters(self, font, s)",
        "snippet": "    def track_characters(self, font, s):\n        \"\"\"Keeps track of which characters are required from each font.\"\"\"\n        if isinstance(font, str):\n            fname = font\n        else:\n            fname = font.fname\n        realpath, stat_key = cbook.get_realpath_and_stat(fname)\n        used_characters = self.file.used_characters.setdefault(\n            stat_key, (realpath, set()))\n        used_characters[1].update(map(ord, s))",
        "begin_line": 1718,
        "end_line": 1727,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image#1738",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.RendererPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image(self, gc, x, y, im, transform=None)",
        "snippet": "    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        if w == 0 or h == 0:\n            return\n\n        if transform is None:\n            # If there's no transform, alpha has already been applied\n            gc.set_alpha(1.0)\n\n        self.check_gc(gc)\n\n        w = 72.0 * w / self.image_dpi\n        h = 72.0 * h / self.image_dpi\n\n        imob = self.file.imageObject(im)\n\n        if transform is None:\n            self.file.output(Op.gsave,\n                             w, 0, 0, h, x, y, Op.concat_matrix,\n                             imob, Op.use_xobject, Op.grestore)\n        else:\n            tr1, tr2, tr3, tr4, tr5, tr6 = transform.frozen().to_values()\n\n            self.file.output(Op.gsave,\n                             1, 0, 0, 1, x, y, Op.concat_matrix,\n                             tr1, tr2, tr3, tr4, tr5, tr6, Op.concat_matrix,\n                             imob, Op.use_xobject, Op.grestore)",
        "begin_line": 1738,
        "end_line": 1766,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path#1768",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.RendererPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path(self, gc, path, transform, rgbFace=None)",
        "snippet": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        self.check_gc(gc, rgbFace)\n        self.file.writePath(\n            path, transform,\n            rgbFace is None and gc.get_hatch_path() is None,\n            gc.get_sketch_params())\n        self.file.output(self.gc.paint())",
        "begin_line": 1768,
        "end_line": 1775,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.08996035919424e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers#1847",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.RendererPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers(self, gc, marker_path, marker_trans, path, trans, rgbFace=None)",
        "snippet": "    def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n                     rgbFace=None):\n        # docstring inherited\n\n        # Same logic as in draw_path_collection\n        len_marker_path = len(marker_path)\n        uses = len(path)\n        if len_marker_path * uses < len_marker_path + uses + 5:\n            RendererBase.draw_markers(self, gc, marker_path, marker_trans,\n                                      path, trans, rgbFace)\n            return\n\n        self.check_gc(gc, rgbFace)\n        fill = gc.fill(rgbFace)\n        stroke = gc.stroke()\n\n        output = self.file.output\n        marker = self.file.markerObject(\n            marker_path, marker_trans, fill, stroke, self.gc._linewidth,\n            gc.get_joinstyle(), gc.get_capstyle())\n\n        output(Op.gsave)\n        lastx, lasty = 0, 0\n        for vertices, code in path.iter_segments(\n                trans,\n                clip=(0, 0, self.file.width*72, self.file.height*72),\n                simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                if not (0 <= x <= self.file.width * 72\n                        and 0 <= y <= self.file.height * 72):\n                    continue\n                dx, dy = x - lastx, y - lasty\n                output(1, 0, 0, 1, dx, dy, Op.concat_matrix,\n                       marker, Op.use_xobject)\n                lastx, lasty = x, y\n        output(Op.grestore)",
        "begin_line": 1847,
        "end_line": 1883,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.RendererPdf._setup_textpos#1929",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.RendererPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.RendererPdf._setup_textpos(self, x, y, angle, oldx=0, oldy=0, oldangle=0)",
        "snippet": "    def _setup_textpos(self, x, y, angle, oldx=0, oldy=0, oldangle=0):\n        if angle == oldangle == 0:\n            self.file.output(x - oldx, y - oldy, Op.textpos)\n        else:\n            angle = math.radians(angle)\n            self.file.output(math.cos(angle), math.sin(angle),\n                             -math.sin(angle), math.cos(angle),\n                             x, y, Op.textmatrix)\n            self.file.output(0, 0, Op.textpos)",
        "begin_line": 1929,
        "end_line": 1937,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.667764583513912e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.RendererPdf.encode_string#2085",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.RendererPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.RendererPdf.encode_string(self, s, fonttype)",
        "snippet": "    def encode_string(self, s, fonttype):\n        if fonttype in (1, 3):\n            return s.encode('cp1252', 'replace')\n        return s.encode('utf-16be', 'replace')",
        "begin_line": 2085,
        "end_line": 2088,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text#2090",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.RendererPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None)",
        "snippet": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        # TODO: combine consecutive texts into one BT/ET delimited section\n\n        self.check_gc(gc, gc._rgb)\n        if ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        fontsize = prop.get_size_in_points()\n\n        if rcParams['pdf.use14corefonts']:\n            font = self._get_font_afm(prop)\n            fonttype = 1\n        else:\n            font = self._get_font_ttf(prop)\n            self.track_characters(font, s)\n            fonttype = rcParams['pdf.fonttype']\n            # We can't subset all OpenType fonts, so switch to Type 42\n            # in that case.\n            if is_opentype_cff_font(font.fname):\n                fonttype = 42\n\n        # If fonttype != 3 or there are no multibyte characters, emit the whole\n        # string at once.\n        if fonttype != 3 or all(ord(char) <= 255 for char in s):\n            self.file.output(Op.begin_text,\n                             self.file.fontName(prop), fontsize, Op.selectfont)\n            self._setup_textpos(x, y, angle)\n            self.file.output(self.encode_string(s, fonttype), Op.show,\n                             Op.end_text)\n\n        # There is no way to access multibyte characters of Type 3 fonts, as\n        # they cannot have a CIDMap.  Therefore, in this case we break the\n        # string into chunks, where each chunk contains either a string of\n        # consecutive 1-byte characters or a single multibyte character.  Each\n        # chunk is emitted with a separate command: 1-byte characters use the\n        # regular text show command (Tj), whereas multibyte characters use\n        # the XObject command (Do).  (If using Type 42 fonts, all of this\n        # complication is avoided, but of course, those fonts can not be\n        # subsetted.)\n        else:\n            singlebyte_chunks = []  # List of (start_x, list-of-1-byte-chars).\n            multibyte_glyphs = []  # List of (start_x, glyph_index).\n            prev_was_singlebyte = False\n            for char, (glyph_idx, glyph_x) in zip(\n                    s,\n                    _text_layout.layout(s, font, kern_mode=KERNING_UNFITTED)):\n                if ord(char) <= 255:\n                    if prev_was_singlebyte:\n                        singlebyte_chunks[-1][1].append(char)\n                    else:\n                        singlebyte_chunks.append((glyph_x, [char]))\n                    prev_was_singlebyte = True\n                else:\n                    multibyte_glyphs.append((glyph_x, glyph_idx))\n                    prev_was_singlebyte = False\n            # Do the rotation and global translation as a single matrix\n            # concatenation up front\n            self.file.output(Op.gsave)\n            a = math.radians(angle)\n            self.file.output(math.cos(a), math.sin(a),\n                             -math.sin(a), math.cos(a),\n                             x, y, Op.concat_matrix)\n            # Emit all the 1-byte characters in a BT/ET group.\n            self.file.output(Op.begin_text,\n                             self.file.fontName(prop), fontsize, Op.selectfont)\n            prev_start_x = 0\n            for start_x, chars in singlebyte_chunks:\n                self._setup_textpos(start_x, 0, 0, prev_start_x, 0, 0)\n                self.file.output(self.encode_string(''.join(chars), fonttype),\n                                 Op.show)\n                prev_start_x = start_x\n            self.file.output(Op.end_text)\n            # Then emit all the multibyte characters, one at a time.\n            for start_x, glyph_idx in multibyte_glyphs:\n                glyph_name = font.get_glyph_name(glyph_idx)\n                self.file.output(Op.gsave)\n                self.file.output(0.001 * fontsize, 0,\n                                 0, 0.001 * fontsize,\n                                 start_x, 0, Op.concat_matrix)\n                name = self.file._get_xobject_symbol_name(\n                    font.fname, glyph_name)\n                self.file.output(Name(name), Op.use_xobject)\n                self.file.output(Op.grestore)\n            self.file.output(Op.grestore)",
        "begin_line": 2090,
        "end_line": 2175,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.RendererPdf.new_gc#2177",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.RendererPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.RendererPdf.new_gc(self)",
        "snippet": "    def new_gc(self):\n        # docstring inherited\n        return GraphicsContextPdf(self.file)",
        "begin_line": 2177,
        "end_line": 2179,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.498342823149486e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.__init__#2184",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.__init__(self, file)",
        "snippet": "    def __init__(self, file):\n        GraphicsContextBase.__init__(self)\n        self._fillcolor = (0.0, 0.0, 0.0)\n        self._effective_alphas = (1.0, 1.0)\n        self.file = file\n        self.parent = None",
        "begin_line": 2184,
        "end_line": 2189,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.498342823149486e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fill#2208",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fill(self, *args)",
        "snippet": "    def fill(self, *args):\n        \"\"\"\n        Predicate: does the path need to be filled?\n\n        An optional argument can be used to specify an alternative\n        _fillcolor, as needed by RendererPdf.draw_markers.\n        \"\"\"\n        if len(args):\n            _fillcolor = args[0]\n        else:\n            _fillcolor = self._fillcolor\n        return (self._hatch or\n                (_fillcolor is not None and\n                 (len(_fillcolor) <= 3 or _fillcolor[3] != 0.0)))",
        "begin_line": 2208,
        "end_line": 2221,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.rgb_cmd#2265",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.rgb_cmd(self, rgb)",
        "snippet": "    def rgb_cmd(self, rgb):\n        if rcParams['pdf.inheritcolor']:\n            return []\n        if rgb[0] == rgb[1] == rgb[2]:\n            return [rgb[0], Op.setgray_stroke]\n        else:\n            return [*rgb[:3], Op.setrgb_stroke]",
        "begin_line": 2265,
        "end_line": 2271,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fillcolor_cmd#2273",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fillcolor_cmd(self, rgb)",
        "snippet": "    def fillcolor_cmd(self, rgb):\n        if rgb is None or rcParams['pdf.inheritcolor']:\n            return []\n        elif rgb[0] == rgb[1] == rgb[2]:\n            return [rgb[0], Op.setgray_nonstroke]\n        else:\n            return [*rgb[:3], Op.setrgb_nonstroke]",
        "begin_line": 2273,
        "end_line": 2279,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.push#2281",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.push(self)",
        "snippet": "    def push(self):\n        parent = GraphicsContextPdf(self.file)\n        parent.copy_properties(self)\n        parent.parent = self.parent\n        self.parent = parent\n        return [Op.gsave]",
        "begin_line": 2281,
        "end_line": 2286,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.pop#2288",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.pop(self)",
        "snippet": "    def pop(self):\n        assert self.parent is not None\n        self.copy_properties(self.parent)\n        self.parent = self.parent.parent\n        return [Op.grestore]",
        "begin_line": 2288,
        "end_line": 2292,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.clip_cmd#2294",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.clip_cmd(self, cliprect, clippath)",
        "snippet": "    def clip_cmd(self, cliprect, clippath):\n        \"\"\"Set clip rectangle. Calls self.pop() and self.push().\"\"\"\n        cmds = []\n        # Pop graphics state until we hit the right one or the stack is empty\n        while ((self._cliprect, self._clippath) != (cliprect, clippath)\n                and self.parent is not None):\n            cmds.extend(self.pop())\n        # Unless we hit the right one, set the clip polygon\n        if ((self._cliprect, self._clippath) != (cliprect, clippath) or\n                self.parent is None):\n            cmds.extend(self.push())\n            if self._cliprect != cliprect:\n                cmds.extend([cliprect, Op.rectangle, Op.clip, Op.endpath])\n            if self._clippath != clippath:\n                path, affine = clippath.get_transformed_path_and_affine()\n                cmds.extend(\n                    PdfFile.pathOperations(path, affine, simplify=False) +\n                    [Op.clip, Op.endpath])\n        return cmds",
        "begin_line": 2294,
        "end_line": 2312,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.delta#2328",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.delta(self, other)",
        "snippet": "    def delta(self, other):\n        \"\"\"\n        Copy properties of other into self and return PDF commands\n        needed to transform self into other.\n        \"\"\"\n        cmds = []\n        fill_performed = False\n        for params, cmd in self.commands:\n            different = False\n            for p in params:\n                ours = getattr(self, p)\n                theirs = getattr(other, p)\n                try:\n                    if ours is None or theirs is None:\n                        different = ours is not theirs\n                    else:\n                        different = bool(ours != theirs)\n                except ValueError:\n                    ours = np.asarray(ours)\n                    theirs = np.asarray(theirs)\n                    different = (ours.shape != theirs.shape or\n                                 np.any(ours != theirs))\n                if different:\n                    break\n\n            # Need to update hatching if we also updated fillcolor\n            if params == ('_hatch', '_hatch_color') and fill_performed:\n                different = True\n\n            if different:\n                if params == ('_fillcolor',):\n                    fill_performed = True\n                theirs = [getattr(other, p) for p in params]\n                cmds.extend(cmd(self, *theirs))\n                for p in params:\n                    setattr(self, p, getattr(other, p))\n        return cmds",
        "begin_line": 2328,
        "end_line": 2364,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.copy_properties#2366",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.copy_properties(self, other)",
        "snippet": "    def copy_properties(self, other):\n        \"\"\"\n        Copy properties of other into self.\n        \"\"\"\n        GraphicsContextBase.copy_properties(self, other)\n        fillcolor = getattr(other, '_fillcolor', self._fillcolor)\n        effective_alphas = getattr(other, '_effective_alphas',\n                                   self._effective_alphas)\n        self._fillcolor = fillcolor\n        self._effective_alphas = effective_alphas",
        "begin_line": 2366,
        "end_line": 2375,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.finalize#2377",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.finalize(self)",
        "snippet": "    def finalize(self):\n        \"\"\"\n        Make sure every pushed graphics state is popped.\n        \"\"\"\n        cmds = []\n        while self.parent is not None:\n            cmds.extend(self.pop())\n        return cmds",
        "begin_line": 2377,
        "end_line": 2384,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfPages.__enter__#2438",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfPages",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfPages.__enter__(self)",
        "snippet": "    def __enter__(self):\n        return self",
        "begin_line": 2438,
        "end_line": 2439,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfPages.__exit__#2441",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfPages",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfPages.__exit__(self, exc_type, exc_val, exc_tb)",
        "snippet": "    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()",
        "begin_line": 2441,
        "end_line": 2442,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfPages.close#2444",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfPages",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfPages.close(self)",
        "snippet": "    def close(self):\n        \"\"\"\n        Finalize this object, making the underlying file a complete\n        PDF file.\n        \"\"\"\n        self._file.finalize()\n        self._file.close()\n        if (self.get_pagecount() == 0 and not self.keep_empty and\n                not self._file.passed_in_file_object):\n            os.remove(self._file.fh.name)\n        self._file = None",
        "begin_line": 2444,
        "end_line": 2454,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.498342823149486e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfPages.savefig#2464",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfPages",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfPages.savefig(self, figure=None, **kwargs)",
        "snippet": "    def savefig(self, figure=None, **kwargs):\n        \"\"\"\n        Saves a `.Figure` to this file as a new page.\n\n        Any other keyword arguments are passed to `~.Figure.savefig`.\n\n        Parameters\n        ----------\n        figure : `.Figure` or int, optional\n            Specifies what figure is saved to file. If not specified, the\n            active figure is saved. If a `.Figure` instance is provided, this\n            figure is saved. If an int is specified, the figure instance to\n            save is looked up by number.\n        \"\"\"\n        if not isinstance(figure, Figure):\n            if figure is None:\n                manager = Gcf.get_active()\n            else:\n                manager = Gcf.get_fig_manager(figure)\n            if manager is None:\n                raise ValueError(\"No figure {}\".format(figure))\n            figure = manager.canvas.figure\n        # Force use of pdf backend, as PdfPages is tightly coupled with it.\n        try:\n            orig_canvas = figure.canvas\n            figure.canvas = FigureCanvasPdf(figure)\n            figure.savefig(self, format=\"pdf\", **kwargs)\n        finally:\n            figure.canvas = orig_canvas",
        "begin_line": 2464,
        "end_line": 2492,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfPages.get_pagecount#2494",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfPages",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfPages.get_pagecount(self)",
        "snippet": "    def get_pagecount(self):\n        \"\"\"\n        Returns the current number of pages in the multipage pdf file.\n        \"\"\"\n        return len(self._file.pageList)",
        "begin_line": 2494,
        "end_line": 2498,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.498342823149486e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.print_pdf#2532",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.print_pdf(self, filename, *, dpi=72, bbox_inches_restore=None, metadata=None, **kwargs)",
        "snippet": "    def print_pdf(self, filename, *,\n                  dpi=72,  # dpi to use for images\n                  bbox_inches_restore=None, metadata=None,\n                  **kwargs):\n        self.figure.set_dpi(72)            # there are 72 pdf points to an inch\n        width, height = self.figure.get_size_inches()\n        if isinstance(filename, PdfPages):\n            file = filename._file\n        else:\n            file = PdfFile(filename, metadata=metadata)\n        try:\n            file.newPage(width, height)\n            renderer = MixedModeRenderer(\n                self.figure, width, height, dpi,\n                RendererPdf(file, dpi, height, width),\n                bbox_inches_restore=bbox_inches_restore)\n            self.figure.draw(renderer)\n            renderer.finalize()\n            if not isinstance(filename, PdfPages):\n                file.finalize()\n        finally:\n            if isinstance(filename, PdfPages):  # finish off this page\n                file.endStream()\n            else:            # we opened the file above; now finish it off\n                file.close()",
        "begin_line": 2532,
        "end_line": 2556,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.hatch.HorizontalHatch.__init__#17",
        "src_path": "lib/matplotlib/hatch.py",
        "class_name": "lib.matplotlib.hatch.HorizontalHatch",
        "signature": "lib.matplotlib.hatch.HorizontalHatch.__init__(self, hatch, density)",
        "snippet": "    def __init__(self, hatch, density):\n        self.num_lines = int((hatch.count('-') + hatch.count('+')) * density)\n        self.num_vertices = self.num_lines * 2",
        "begin_line": 17,
        "end_line": 19,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00015598190609889253,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00015598190609889253,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.hatch.HorizontalHatch.set_vertices_and_codes#21",
        "src_path": "lib/matplotlib/hatch.py",
        "class_name": "lib.matplotlib.hatch.HorizontalHatch",
        "signature": "lib.matplotlib.hatch.HorizontalHatch.set_vertices_and_codes(self, vertices, codes)",
        "snippet": "    def set_vertices_and_codes(self, vertices, codes):\n        steps, stepsize = np.linspace(0.0, 1.0, self.num_lines, False,\n                                      retstep=True)\n        steps += stepsize / 2.\n        vertices[0::2, 0] = 0.0\n        vertices[0::2, 1] = steps\n        vertices[1::2, 0] = 1.0\n        vertices[1::2, 1] = steps\n        codes[0::2] = Path.MOVETO\n        codes[1::2] = Path.LINETO",
        "begin_line": 21,
        "end_line": 30,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013071895424836603,
            "pseudo_dstar_susp": 0.0001763979537837361,
            "pseudo_tarantula_susp": 0.00013345789403443215,
            "pseudo_op2_susp": 0.0001763979537837361,
            "pseudo_barinel_susp": 0.00013338668800853674
        }
    },
    {
        "name": "lib.matplotlib.hatch.VerticalHatch.set_vertices_and_codes#38",
        "src_path": "lib/matplotlib/hatch.py",
        "class_name": "lib.matplotlib.hatch.VerticalHatch",
        "signature": "lib.matplotlib.hatch.VerticalHatch.set_vertices_and_codes(self, vertices, codes)",
        "snippet": "    def set_vertices_and_codes(self, vertices, codes):\n        steps, stepsize = np.linspace(0.0, 1.0, self.num_lines, False,\n                                      retstep=True)\n        steps += stepsize / 2.\n        vertices[0::2, 0] = steps\n        vertices[0::2, 1] = 0.0\n        vertices[1::2, 0] = steps\n        vertices[1::2, 1] = 1.0\n        codes[0::2] = Path.MOVETO\n        codes[1::2] = Path.LINETO",
        "begin_line": 38,
        "end_line": 47,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012088974854932302,
            "pseudo_dstar_susp": 0.0001552072016141549,
            "pseudo_tarantula_susp": 0.00011551345731777752,
            "pseudo_op2_susp": 0.0001552072016141549,
            "pseudo_barinel_susp": 0.00011551345731777752
        }
    },
    {
        "name": "lib.matplotlib.hatch.NorthEastHatch.__init__#51",
        "src_path": "lib/matplotlib/hatch.py",
        "class_name": "lib.matplotlib.hatch.NorthEastHatch",
        "signature": "lib.matplotlib.hatch.NorthEastHatch.__init__(self, hatch, density)",
        "snippet": "    def __init__(self, hatch, density):\n        self.num_lines = int((hatch.count('/') + hatch.count('x') +\n                          hatch.count('X')) * density)\n        if self.num_lines:\n            self.num_vertices = (self.num_lines + 1) * 2\n        else:\n            self.num_vertices = 0",
        "begin_line": 51,
        "end_line": 57,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011551345731777752,
            "pseudo_dstar_susp": 0.00018125793003443902,
            "pseudo_tarantula_susp": 0.00011444266422522316,
            "pseudo_op2_susp": 0.00018125793003443902,
            "pseudo_barinel_susp": 0.00011444266422522316
        }
    },
    {
        "name": "lib.matplotlib.hatch.SouthEastHatch.__init__#70",
        "src_path": "lib/matplotlib/hatch.py",
        "class_name": "lib.matplotlib.hatch.SouthEastHatch",
        "signature": "lib.matplotlib.hatch.SouthEastHatch.__init__(self, hatch, density)",
        "snippet": "    def __init__(self, hatch, density):\n        self.num_lines = int((hatch.count('\\\\') + hatch.count('x') +\n                          hatch.count('X')) * density)\n        self.num_vertices = (self.num_lines + 1) * 2\n        if self.num_lines:\n            self.num_vertices = (self.num_lines + 1) * 2\n        else:\n            self.num_vertices = 0",
        "begin_line": 70,
        "end_line": 77,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00014166312508853945,
            "pseudo_dstar_susp": 0.000177999288002848,
            "pseudo_tarantula_susp": 0.000129315918789603,
            "pseudo_op2_susp": 0.000177999288002848,
            "pseudo_barinel_susp": 0.000129315918789603
        }
    },
    {
        "name": "lib.matplotlib.hatch.Shapes.__init__#92",
        "src_path": "lib/matplotlib/hatch.py",
        "class_name": "lib.matplotlib.hatch.Shapes",
        "signature": "lib.matplotlib.hatch.Shapes.__init__(self, hatch, density)",
        "snippet": "    def __init__(self, hatch, density):\n        if self.num_rows == 0:\n            self.num_shapes = 0\n            self.num_vertices = 0\n        else:\n            self.num_shapes = ((self.num_rows // 2 + 1) * (self.num_rows + 1) +\n                               (self.num_rows // 2) * (self.num_rows))\n            self.num_vertices = (self.num_shapes *\n                                 len(self.shape_vertices) *\n                                 (1 if self.filled else 2))",
        "begin_line": 92,
        "end_line": 101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012324377618930243,
            "pseudo_dstar_susp": 0.00020955574182732607,
            "pseudo_tarantula_susp": 0.00011661807580174928,
            "pseudo_op2_susp": 0.00020955574182732607,
            "pseudo_barinel_susp": 0.00011661807580174928
        }
    },
    {
        "name": "lib.matplotlib.hatch.Shapes.set_vertices_and_codes#103",
        "src_path": "lib/matplotlib/hatch.py",
        "class_name": "lib.matplotlib.hatch.Shapes",
        "signature": "lib.matplotlib.hatch.Shapes.set_vertices_and_codes(self, vertices, codes)",
        "snippet": "    def set_vertices_and_codes(self, vertices, codes):\n        offset = 1.0 / self.num_rows\n        shape_vertices = self.shape_vertices * offset * self.size\n        if not self.filled:\n            inner_vertices = shape_vertices[::-1] * 0.9\n        shape_codes = self.shape_codes\n        shape_size = len(shape_vertices)\n\n        cursor = 0\n        for row in range(self.num_rows + 1):\n            if row % 2 == 0:\n                cols = np.linspace(0, 1, self.num_rows + 1)\n            else:\n                cols = np.linspace(offset / 2, 1 - offset / 2, self.num_rows)\n            row_pos = row * offset\n            for col_pos in cols:\n                vertices[cursor:cursor + shape_size] = (shape_vertices +\n                                                        (col_pos, row_pos))\n                codes[cursor:cursor + shape_size] = shape_codes\n                cursor += shape_size\n                if not self.filled:\n                    vertices[cursor:cursor + shape_size] = (inner_vertices +\n                                                            (col_pos, row_pos))\n                    codes[cursor:cursor + shape_size] = shape_codes\n                    cursor += shape_size",
        "begin_line": 103,
        "end_line": 127,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015634771732332708,
            "pseudo_dstar_susp": 0.00021500752526338422,
            "pseudo_tarantula_susp": 0.00012193634922570419,
            "pseudo_op2_susp": 0.00021500752526338422,
            "pseudo_barinel_susp": 0.00012193634922570419
        }
    },
    {
        "name": "lib.matplotlib.hatch.SmallCircles.__init__#141",
        "src_path": "lib/matplotlib/hatch.py",
        "class_name": "lib.matplotlib.hatch.SmallCircles",
        "signature": "lib.matplotlib.hatch.SmallCircles.__init__(self, hatch, density)",
        "snippet": "    def __init__(self, hatch, density):\n        self.num_rows = (hatch.count('o')) * density\n        Circles.__init__(self, hatch, density)",
        "begin_line": 141,
        "end_line": 143,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000125203455615375,
            "pseudo_dstar_susp": 0.00017627357659086903,
            "pseudo_tarantula_susp": 0.00011524720525527257,
            "pseudo_op2_susp": 0.00017627357659086903,
            "pseudo_barinel_susp": 0.00011524720525527257
        }
    },
    {
        "name": "lib.matplotlib.hatch.SmallFilledCircles.__init__#158",
        "src_path": "lib/matplotlib/hatch.py",
        "class_name": "lib.matplotlib.hatch.SmallFilledCircles",
        "signature": "lib.matplotlib.hatch.SmallFilledCircles.__init__(self, hatch, density)",
        "snippet": "    def __init__(self, hatch, density):\n        self.num_rows = (hatch.count('.')) * density\n        Circles.__init__(self, hatch, density)",
        "begin_line": 158,
        "end_line": 160,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000157035175879397,
            "pseudo_dstar_susp": 0.00016952025767079165,
            "pseudo_tarantula_susp": 0.00016972165648336727,
            "pseudo_op2_susp": 0.00016952025767079165,
            "pseudo_barinel_susp": 0.00016972165648336727
        }
    },
    {
        "name": "lib.matplotlib.hatch.get_path#188",
        "src_path": "lib/matplotlib/hatch.py",
        "class_name": "lib.matplotlib.hatch",
        "signature": "lib.matplotlib.hatch.get_path(hatchpattern, density=6)",
        "snippet": "def get_path(hatchpattern, density=6):\n    \"\"\"\n    Given a hatch specifier, *hatchpattern*, generates Path to render\n    the hatch in a unit square.  *density* is the number of lines per\n    unit square.\n    \"\"\"\n    density = int(density)\n\n    patterns = [hatch_type(hatchpattern, density)\n                for hatch_type in _hatch_types]\n    num_vertices = sum([pattern.num_vertices for pattern in patterns])\n\n    if num_vertices == 0:\n        return Path(np.empty((0, 2)))\n\n    vertices = np.empty((num_vertices, 2))\n    codes = np.empty(num_vertices, Path.code_type)\n\n    cursor = 0\n    for pattern in patterns:\n        if pattern.num_vertices != 0:\n            vertices_chunk = vertices[cursor:cursor + pattern.num_vertices]\n            codes_chunk = codes[cursor:cursor + pattern.num_vertices]\n            pattern.set_vertices_and_codes(vertices_chunk, codes_chunk)\n            cursor += pattern.num_vertices\n\n    return Path(vertices, codes)",
        "begin_line": 188,
        "end_line": 214,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016178611875101117,
            "pseudo_dstar_susp": 0.00021510002151000216,
            "pseudo_tarantula_susp": 0.00014322543683758235,
            "pseudo_op2_susp": 0.00021510002151000216,
            "pseudo_barinel_susp": 0.00014324595330181923
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_ps.RendererPS.set_color#243",
        "src_path": "lib/matplotlib/backends/backend_ps.py",
        "class_name": "lib.matplotlib.backends.backend_ps.RendererPS",
        "signature": "lib.matplotlib.backends.backend_ps.RendererPS.set_color(self, r, g, b, store=1)",
        "snippet": "    def set_color(self, r, g, b, store=1):\n        if (r, g, b) != self.color:\n            if r == g and r == b:\n                self._pswriter.write(\"%1.3f setgray\\n\" % r)\n            else:\n                self._pswriter.write(\n                    \"%1.3f %1.3f %1.3f setrgbcolor\\n\" % (r, g, b))\n            if store:\n                self.color = (r, g, b)",
        "begin_line": 243,
        "end_line": 251,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.228420966016621e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers#422",
        "src_path": "lib/matplotlib/backends/backend_ps.py",
        "class_name": "lib.matplotlib.backends.backend_ps.RendererPS",
        "signature": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers(self, gc, marker_path, marker_trans, path, trans, rgbFace=None)",
        "snippet": "    def draw_markers(\n            self, gc, marker_path, marker_trans, path, trans, rgbFace=None):\n        # docstring inherited\n\n        if debugPS:\n            self._pswriter.write('% draw_markers \\n')\n\n        ps_color = (\n            None\n            if _is_transparent(rgbFace)\n            else '%1.3f setgray' % rgbFace[0]\n            if rgbFace[0] == rgbFace[1] == rgbFace[2]\n            else '%1.3f %1.3f %1.3f setrgbcolor' % rgbFace[:3])\n\n        # construct the generic marker command:\n\n        # don't want the translate to be global\n        ps_cmd = ['/o {', 'gsave', 'newpath', 'translate']\n\n        lw = gc.get_linewidth()\n        alpha = (gc.get_alpha()\n                 if gc.get_forced_alpha() or len(gc.get_rgb()) == 3\n                 else gc.get_rgb()[3])\n        stroke = lw > 0 and alpha > 0\n        if stroke:\n            ps_cmd.append('%.1f setlinewidth' % lw)\n            jint = gc.get_joinstyle()\n            ps_cmd.append('%d setlinejoin' % jint)\n            cint = gc.get_capstyle()\n            ps_cmd.append('%d setlinecap' % cint)\n\n        ps_cmd.append(self._convert_path(marker_path, marker_trans,\n                                         simplify=False))\n\n        if rgbFace:\n            if stroke:\n                ps_cmd.append('gsave')\n            if ps_color:\n                ps_cmd.extend([ps_color, 'fill'])\n            if stroke:\n                ps_cmd.append('grestore')\n\n        if stroke:\n            ps_cmd.append('stroke')\n        ps_cmd.extend(['grestore', '} bind def'])\n\n        for vertices, code in path.iter_segments(\n                trans,\n                clip=(0, 0, self.width*72, self.height*72),\n                simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                ps_cmd.append(\"%g %g o\" % (x, y))\n\n        ps = '\\n'.join(ps_cmd)\n        self._draw_ps(ps, gc, rgbFace, fill=False, stroke=False)",
        "begin_line": 422,
        "end_line": 477,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text#562",
        "src_path": "lib/matplotlib/backends/backend_ps.py",
        "class_name": "lib.matplotlib.backends.backend_ps.RendererPS",
        "signature": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None)",
        "snippet": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        # local to avoid repeated attribute lookups\n        write = self._pswriter.write\n        if debugPS:\n            write(\"% text\\n\")\n\n        if _is_transparent(gc.get_rgb()):\n            return  # Special handling for fully transparent.\n\n        if ismath == 'TeX':\n            return self.draw_tex(gc, x, y, s, prop, angle)\n\n        elif ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        elif rcParams['ps.useafm']:\n            self.set_color(*gc.get_rgb())\n\n            font = self._get_font_afm(prop)\n            fontname = font.get_fontname()\n            fontsize = prop.get_size_in_points()\n            scale = 0.001 * fontsize\n\n            thisx = 0\n            thisy = font.get_str_bbox_and_descent(s)[4] * scale\n            last_name = None\n            lines = []\n            for c in s:\n                name = uni2type1.get(ord(c), 'question')\n                try:\n                    width = font.get_width_from_char_name(name)\n                except KeyError:\n                    name = 'question'\n                    width = font.get_width_char('?')\n                if last_name is not None:\n                    kern = font.get_kern_dist_from_name(last_name, name)\n                else:\n                    kern = 0\n                last_name = name\n                thisx += kern * scale\n\n                lines.append('%f %f m /%s glyphshow' % (thisx, thisy, name))\n\n                thisx += width * scale\n\n            thetext = \"\\n\".join(lines)\n            self._pswriter.write(f\"\"\"\\\ngsave\n/{fontname} findfont\n{fontsize} scalefont\nsetfont\n{x:f} {y:f} translate\n{angle:f} rotate\n{thetext}\ngrestore\n\"\"\")\n\n        else:\n            font = self._get_font_ttf(prop)\n            font.set_text(s, 0, flags=LOAD_NO_HINTING)\n            self.track_characters(font, s)\n\n            self.set_color(*gc.get_rgb())\n            ps_name = (font.postscript_name\n                       .encode('ascii', 'replace').decode('ascii'))\n            self.set_font(ps_name, prop.get_size_in_points())\n\n            thetext = '\\n'.join(\n                '%f 0 m /%s glyphshow' % (x, font.get_glyph_name(glyph_idx))\n                for glyph_idx, x in _text_layout.layout(s, font))\n            self._pswriter.write(f\"\"\"\\\ngsave\n{x:f} {y:f} translate\n{angle:f} rotate\n{thetext}\ngrestore\n\"\"\")",
        "begin_line": 562,
        "end_line": 640,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_ps.RendererPS._draw_ps#714",
        "src_path": "lib/matplotlib/backends/backend_ps.py",
        "class_name": "lib.matplotlib.backends.backend_ps.RendererPS",
        "signature": "lib.matplotlib.backends.backend_ps.RendererPS._draw_ps(self, ps, gc, rgbFace, fill=True, stroke=True, command=None)",
        "snippet": "    def _draw_ps(self, ps, gc, rgbFace, fill=True, stroke=True, command=None):\n        \"\"\"\n        Emit the PostScript snippet 'ps' with all the attributes from 'gc'\n        applied.  'ps' must consist of PostScript commands to construct a path.\n\n        The fill and/or stroke kwargs can be set to False if the\n        'ps' string already includes filling and/or stroking, in\n        which case _draw_ps is just supplying properties and\n        clipping.\n        \"\"\"\n        # local variable eliminates all repeated attribute lookups\n        write = self._pswriter.write\n        if debugPS and command:\n            write(\"% \"+command+\"\\n\")\n        mightstroke = (gc.get_linewidth() > 0\n                       and not _is_transparent(gc.get_rgb()))\n        if not mightstroke:\n            stroke = False\n        if _is_transparent(rgbFace):\n            fill = False\n        hatch = gc.get_hatch()\n\n        if mightstroke:\n            self.set_linewidth(gc.get_linewidth())\n            jint = gc.get_joinstyle()\n            self.set_linejoin(jint)\n            cint = gc.get_capstyle()\n            self.set_linecap(cint)\n            self.set_linedash(*gc.get_dashes())\n            self.set_color(*gc.get_rgb()[:3])\n        write('gsave\\n')\n\n        cliprect = gc.get_clip_rectangle()\n        if cliprect:\n            x, y, w, h = cliprect.bounds\n            write('%1.4g %1.4g %1.4g %1.4g clipbox\\n' % (w, h, x, y))\n        clippath, clippath_trans = gc.get_clip_path()\n        if clippath:\n            id = self._get_clip_path(clippath, clippath_trans)\n            write('%s\\n' % id)\n\n        # Jochen, is the strip necessary? - this could be a honking big string\n        write(ps.strip())\n        write(\"\\n\")\n\n        if fill:\n            if stroke or hatch:\n                write(\"gsave\\n\")\n            self.set_color(store=0, *rgbFace[:3])\n            write(\"fill\\n\")\n            if stroke or hatch:\n                write(\"grestore\\n\")\n\n        if hatch:\n            hatch_name = self.create_hatch(hatch)\n            write(\"gsave\\n\")\n            write(\"%f %f %f \" % gc.get_hatch_color()[:3])\n            write(\"%s setpattern fill grestore\\n\" % hatch_name)\n\n        if stroke:\n            write(\"stroke\\n\")\n\n        write(\"grestore\\n\")",
        "begin_line": 714,
        "end_line": 776,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.228420966016621e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_ps.FigureCanvasPS._print_figure#855",
        "src_path": "lib/matplotlib/backends/backend_ps.py",
        "class_name": "lib.matplotlib.backends.backend_ps.FigureCanvasPS",
        "signature": "lib.matplotlib.backends.backend_ps.FigureCanvasPS._print_figure(self, outfile, format, dpi, facecolor, edgecolor, orientation, papertype, *, metadata=None, dryrun=False, bbox_inches_restore=None, **kwargs)",
        "snippet": "    def _print_figure(\n            self, outfile, format, dpi, facecolor, edgecolor,\n            orientation, papertype, *,\n            metadata=None, dryrun=False, bbox_inches_restore=None, **kwargs):\n        \"\"\"\n        Render the figure to hardcopy.  Set the figure patch face and\n        edge colors.  This is useful because some of the GUIs have a\n        gray figure face color background and you'll probably want to\n        override this on hardcopy\n\n        If outfile is a string, it is interpreted as a file name.\n        If the extension matches .ep* write encapsulated postscript,\n        otherwise write a stand-alone PostScript file.\n\n        If outfile is a file object, a stand-alone PostScript file is\n        written into this file object.\n\n        metadata must be a dictionary. Currently, only the value for\n        the key 'Creator' is used.\n        \"\"\"\n        is_eps = format == 'eps'\n        if isinstance(outfile, (str, os.PathLike)):\n            outfile = title = os.fspath(outfile)\n            title = title.encode(\"ascii\", \"replace\").decode(\"ascii\")\n            passed_in_file_object = False\n        elif is_writable_file_like(outfile):\n            title = None\n            passed_in_file_object = True\n        else:\n            raise ValueError(\"outfile must be a path or a file-like object\")\n\n        # find the appropriate papertype\n        width, height = self.figure.get_size_inches()\n        if papertype == 'auto':\n            papertype = _get_papertype(\n                *orientation.swap_if_landscape((width, height)))\n        paper_width, paper_height = orientation.swap_if_landscape(\n            papersize[papertype])\n\n        if rcParams['ps.usedistiller']:\n            # distillers improperly clip eps files if pagesize is too small\n            if width > paper_width or height > paper_height:\n                papertype = _get_papertype(\n                    *orientation.swap_if_landscape(width, height))\n                paper_width, paper_height = orientation.swap_if_landscape(\n                    papersize[papertype])\n\n        # center the figure on the paper\n        xo = 72 * 0.5 * (paper_width - width)\n        yo = 72 * 0.5 * (paper_height - height)\n\n        l, b, w, h = self.figure.bbox.bounds\n        llx = xo\n        lly = yo\n        urx = llx + w\n        ury = lly + h\n        rotation = 0\n        if orientation is _Orientation.landscape:\n            llx, lly, urx, ury = lly, llx, ury, urx\n            xo, yo = 72 * paper_height - yo, xo\n            rotation = 90\n        bbox = (llx, lly, urx, ury)\n\n        # generate PostScript code for the figure and store it in a string\n        origfacecolor = self.figure.get_facecolor()\n        origedgecolor = self.figure.get_edgecolor()\n        self.figure.set_facecolor(facecolor)\n        self.figure.set_edgecolor(edgecolor)\n\n        if dryrun:\n            class NullWriter:\n                def write(self, *args, **kwargs):\n                    pass\n\n            self._pswriter = NullWriter()\n        else:\n            self._pswriter = StringIO()\n\n        # mixed mode rendering\n        ps_renderer = RendererPS(width, height, self._pswriter, imagedpi=dpi)\n        renderer = MixedModeRenderer(\n            self.figure, width, height, dpi, ps_renderer,\n            bbox_inches_restore=bbox_inches_restore)\n\n        self.figure.draw(renderer)\n\n        if dryrun:  # return immediately if dryrun (tightbbox=True)\n            return\n\n        self.figure.set_facecolor(origfacecolor)\n        self.figure.set_edgecolor(origedgecolor)\n\n        # check for custom metadata\n        if metadata is not None and 'Creator' in metadata:\n            creator_str = metadata['Creator']\n        else:\n            creator_str = \"matplotlib version \" + __version__ + \\\n                \", http://matplotlib.org/\"\n\n        def print_figure_impl(fh):\n            # write the PostScript headers\n            if is_eps:\n                print(\"%!PS-Adobe-3.0 EPSF-3.0\", file=fh)\n            else:\n                print(f\"%!PS-Adobe-3.0\\n\"\n                      f\"%%DocumentPaperSizes: {papertype}\\n\"\n                      f\"%%Pages: 1\\n\",\n                      end=\"\", file=fh)\n            if title:\n                print(\"%%Title: \" + title, file=fh)\n            # get source date from SOURCE_DATE_EPOCH, if set\n            # See https://reproducible-builds.org/specs/source-date-epoch/\n            source_date_epoch = os.getenv(\"SOURCE_DATE_EPOCH\")\n            if source_date_epoch:\n                source_date = datetime.datetime.utcfromtimestamp(\n                    int(source_date_epoch)).strftime(\"%a %b %d %H:%M:%S %Y\")\n            else:\n                source_date = time.ctime()\n            print(f\"%%Creator: {creator_str}\\n\"\n                  f\"%%CreationDate: {source_date}\\n\"\n                  f\"%%Orientation: {orientation.name}\\n\"\n                  f\"%%BoundingBox: {bbox[0]} {bbox[1]} {bbox[2]} {bbox[3]}\\n\"\n                  f\"%%EndComments\\n\",\n                  end=\"\", file=fh)\n\n            Ndict = len(psDefs)\n            print(\"%%BeginProlog\", file=fh)\n            if not rcParams['ps.useafm']:\n                Ndict += len(ps_renderer.used_characters)\n            print(\"/mpldict %d dict def\" % Ndict, file=fh)\n            print(\"mpldict begin\", file=fh)\n            for d in psDefs:\n                d = d.strip()\n                for l in d.split('\\n'):\n                    print(l.strip(), file=fh)\n            if not rcParams['ps.useafm']:\n                for font_filename, chars in \\\n                        ps_renderer.used_characters.values():\n                    if len(chars):\n                        font = get_font(font_filename)\n                        glyph_ids = [font.get_char_index(c) for c in chars]\n\n                        fonttype = rcParams['ps.fonttype']\n\n                        # Can not use more than 255 characters from a\n                        # single font for Type 3\n                        if len(glyph_ids) > 255:\n                            fonttype = 42\n\n                        # The ttf to ps (subsetting) support doesn't work for\n                        # OpenType fonts that are Postscript inside (like the\n                        # STIX fonts).  This will simply turn that off to avoid\n                        # errors.\n                        if is_opentype_cff_font(font_filename):\n                            raise RuntimeError(\n                                \"OpenType CFF fonts can not be saved using \"\n                                \"the internal Postscript backend at this \"\n                                \"time; consider using the Cairo backend\")\n                        else:\n                            fh.flush()\n                            try:\n                                convert_ttf_to_ps(os.fsencode(font_filename),\n                                                  fh, fonttype, glyph_ids)\n                            except RuntimeError:\n                                _log.warning(\"The PostScript backend does not \"\n                                             \"currently support the selected \"\n                                             \"font.\")\n                                raise\n            print(\"end\", file=fh)\n            print(\"%%EndProlog\", file=fh)\n\n            if not is_eps:\n                print(\"%%Page: 1 1\", file=fh)\n            print(\"mpldict begin\", file=fh)\n\n            print(\"%s translate\" % _nums_to_str(xo, yo), file=fh)\n            if rotation:\n                print(\"%d rotate\" % rotation, file=fh)\n            print(\"%s clipbox\" % _nums_to_str(width*72, height*72, 0, 0),\n                  file=fh)\n\n            # write the figure\n            content = self._pswriter.getvalue()\n            if not isinstance(content, str):\n                content = content.decode('ascii')\n            print(content, file=fh)\n\n            # write the trailer\n            print(\"end\", file=fh)\n            print(\"showpage\", file=fh)\n            if not is_eps:\n                print(\"%%EOF\", file=fh)\n            fh.flush()\n\n        if rcParams['ps.usedistiller']:\n            # We are going to use an external program to process the output.\n            # Write to a temporary file.\n            with TemporaryDirectory() as tmpdir:\n                tmpfile = os.path.join(tmpdir, \"tmp.ps\")\n                with open(tmpfile, 'w', encoding='latin-1') as fh:\n                    print_figure_impl(fh)\n                if rcParams['ps.usedistiller'] == 'ghostscript':\n                    gs_distill(tmpfile, is_eps, ptype=papertype, bbox=bbox)\n                elif rcParams['ps.usedistiller'] == 'xpdf':\n                    xpdf_distill(tmpfile, is_eps, ptype=papertype, bbox=bbox)\n                _move_path_to_path_or_stream(tmpfile, outfile)\n\n        else:\n            # Write directly to outfile.\n            if passed_in_file_object:\n                requires_unicode = file_requires_unicode(outfile)\n\n                if not requires_unicode:\n                    fh = TextIOWrapper(outfile, encoding=\"latin-1\")\n                    # Prevent the TextIOWrapper from closing the underlying\n                    # file.\n                    fh.close = lambda: None\n                else:\n                    fh = outfile\n\n                print_figure_impl(fh)\n            else:\n                with open(outfile, 'w', encoding='latin-1') as fh:\n                    print_figure_impl(fh)",
        "begin_line": 855,
        "end_line": 1078,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.228420966016621e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.print_figure_impl#954",
        "src_path": "lib/matplotlib/backends/backend_ps.py",
        "class_name": "lib.matplotlib.backends.backend_ps.FigureCanvasPS",
        "signature": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.print_figure_impl(fh)",
        "snippet": "        def print_figure_impl(fh):\n            # write the PostScript headers\n            if is_eps:\n                print(\"%!PS-Adobe-3.0 EPSF-3.0\", file=fh)\n            else:\n                print(f\"%!PS-Adobe-3.0\\n\"\n                      f\"%%DocumentPaperSizes: {papertype}\\n\"\n                      f\"%%Pages: 1\\n\",\n                      end=\"\", file=fh)\n            if title:\n                print(\"%%Title: \" + title, file=fh)\n            # get source date from SOURCE_DATE_EPOCH, if set\n            # See https://reproducible-builds.org/specs/source-date-epoch/\n            source_date_epoch = os.getenv(\"SOURCE_DATE_EPOCH\")\n            if source_date_epoch:\n                source_date = datetime.datetime.utcfromtimestamp(\n                    int(source_date_epoch)).strftime(\"%a %b %d %H:%M:%S %Y\")\n            else:\n                source_date = time.ctime()\n            print(f\"%%Creator: {creator_str}\\n\"\n                  f\"%%CreationDate: {source_date}\\n\"\n                  f\"%%Orientation: {orientation.name}\\n\"\n                  f\"%%BoundingBox: {bbox[0]} {bbox[1]} {bbox[2]} {bbox[3]}\\n\"\n                  f\"%%EndComments\\n\",\n                  end=\"\", file=fh)\n\n            Ndict = len(psDefs)\n            print(\"%%BeginProlog\", file=fh)\n            if not rcParams['ps.useafm']:\n                Ndict += len(ps_renderer.used_characters)\n            print(\"/mpldict %d dict def\" % Ndict, file=fh)\n            print(\"mpldict begin\", file=fh)\n            for d in psDefs:\n                d = d.strip()\n                for l in d.split('\\n'):\n                    print(l.strip(), file=fh)\n            if not rcParams['ps.useafm']:\n                for font_filename, chars in \\\n                        ps_renderer.used_characters.values():\n                    if len(chars):\n                        font = get_font(font_filename)\n                        glyph_ids = [font.get_char_index(c) for c in chars]\n\n                        fonttype = rcParams['ps.fonttype']\n\n                        # Can not use more than 255 characters from a\n                        # single font for Type 3\n                        if len(glyph_ids) > 255:\n                            fonttype = 42\n\n                        # The ttf to ps (subsetting) support doesn't work for\n                        # OpenType fonts that are Postscript inside (like the\n                        # STIX fonts).  This will simply turn that off to avoid\n                        # errors.\n                        if is_opentype_cff_font(font_filename):\n                            raise RuntimeError(\n                                \"OpenType CFF fonts can not be saved using \"\n                                \"the internal Postscript backend at this \"\n                                \"time; consider using the Cairo backend\")\n                        else:\n                            fh.flush()\n                            try:\n                                convert_ttf_to_ps(os.fsencode(font_filename),\n                                                  fh, fonttype, glyph_ids)\n                            except RuntimeError:\n                                _log.warning(\"The PostScript backend does not \"\n                                             \"currently support the selected \"\n                                             \"font.\")\n                                raise\n            print(\"end\", file=fh)\n            print(\"%%EndProlog\", file=fh)\n\n            if not is_eps:\n                print(\"%%Page: 1 1\", file=fh)\n            print(\"mpldict begin\", file=fh)\n\n            print(\"%s translate\" % _nums_to_str(xo, yo), file=fh)\n            if rotation:\n                print(\"%d rotate\" % rotation, file=fh)\n            print(\"%s clipbox\" % _nums_to_str(width*72, height*72, 0, 0),\n                  file=fh)\n\n            # write the figure\n            content = self._pswriter.getvalue()\n            if not isinstance(content, str):\n                content = content.decode('ascii')\n            print(content, file=fh)\n\n            # write the trailer\n            print(\"end\", file=fh)\n            print(\"showpage\", file=fh)\n            if not is_eps:\n                print(\"%%EOF\", file=fh)\n            fh.flush()",
        "begin_line": 954,
        "end_line": 1047,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axis.Tick.__init__#56",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Tick",
        "signature": "lib.matplotlib.axis.Tick.__init__(self, axes, loc, label, size=None, width=None, color=None, tickdir=None, pad=None, labelsize=None, labelcolor=None, zorder=None, gridOn=None, tick1On=True, tick2On=True, label1On=True, label2On=False, major=True, labelrotation=0, grid_color=None, grid_linestyle=None, grid_linewidth=None, grid_alpha=None, **kw)",
        "snippet": "    def __init__(self, axes, loc, label,\n                 size=None,  # points\n                 width=None,\n                 color=None,\n                 tickdir=None,\n                 pad=None,\n                 labelsize=None,\n                 labelcolor=None,\n                 zorder=None,\n                 gridOn=None,  # defaults to axes.grid depending on\n                               # axes.grid.which\n                 tick1On=True,\n                 tick2On=True,\n                 label1On=True,\n                 label2On=False,\n                 major=True,\n                 labelrotation=0,\n                 grid_color=None,\n                 grid_linestyle=None,\n                 grid_linewidth=None,\n                 grid_alpha=None,\n                 **kw  # Other Line2D kwargs applied to gridlines.\n                 ):\n        \"\"\"\n        bbox is the Bound2D bounding box in display coords of the Axes\n        loc is the tick location in data coords\n        size is the tick size in points\n        \"\"\"\n        martist.Artist.__init__(self)\n\n        if gridOn is None:\n            if major and (rcParams['axes.grid.which'] in ('both', 'major')):\n                gridOn = rcParams['axes.grid']\n            elif (not major) and (rcParams['axes.grid.which']\n                                  in ('both', 'minor')):\n                gridOn = rcParams['axes.grid']\n            else:\n                gridOn = False\n\n        self.set_figure(axes.figure)\n        self.axes = axes\n\n        name = self.__name__.lower()\n\n        self._loc = loc\n\n        if size is None:\n            if major:\n                size = rcParams['%s.major.size' % name]\n            else:\n                size = rcParams['%s.minor.size' % name]\n        self._size = size\n\n        if width is None:\n            if major:\n                width = rcParams['%s.major.width' % name]\n            else:\n                width = rcParams['%s.minor.width' % name]\n        self._width = width\n\n        if color is None:\n            color = rcParams['%s.color' % name]\n        self._color = color\n\n        if pad is None:\n            if major:\n                pad = rcParams['%s.major.pad' % name]\n            else:\n                pad = rcParams['%s.minor.pad' % name]\n        self._base_pad = pad\n\n        if labelcolor is None:\n            labelcolor = rcParams['%s.color' % name]\n        self._labelcolor = labelcolor\n\n        if labelsize is None:\n            labelsize = rcParams['%s.labelsize' % name]\n        self._labelsize = labelsize\n\n        self._set_labelrotation(labelrotation)\n\n        if zorder is None:\n            if major:\n                zorder = mlines.Line2D.zorder + 0.01\n            else:\n                zorder = mlines.Line2D.zorder\n        self._zorder = zorder\n\n        self._grid_color = (rcParams['grid.color']\n                            if grid_color is None else grid_color)\n        self._grid_linestyle = (rcParams['grid.linestyle']\n                                if grid_linestyle is None else grid_linestyle)\n        self._grid_linewidth = (rcParams['grid.linewidth']\n                                if grid_linewidth is None else grid_linewidth)\n        self._grid_alpha = (rcParams['grid.alpha']\n                            if grid_alpha is None else grid_alpha)\n\n        self._grid_kw = {k[5:]: v for k, v in kw.items()}\n\n        self.apply_tickdir(tickdir)\n\n        self.tick1line = self._get_tick1line()\n        self.tick2line = self._get_tick2line()\n        self.gridline = self._get_gridline()\n        self.label1 = self._get_text1()\n        self.label2 = self._get_text2()\n\n        self.gridline.set_visible(gridOn)\n        self.tick1line.set_visible(tick1On)\n        self.tick2line.set_visible(tick2On)\n        self.label1.set_visible(label1On)\n        self.label2.set_visible(label2On)\n\n        self.update_position(loc)",
        "begin_line": 56,
        "end_line": 169,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007087172218284905,
            "pseudo_dstar_susp": 0.0008658008658008658,
            "pseudo_tarantula_susp": 0.00017812611328820805,
            "pseudo_op2_susp": 0.0008658008658008658,
            "pseudo_barinel_susp": 0.00017812611328820805
        }
    },
    {
        "name": "lib.matplotlib.axis.Tick._set_labelrotation#197",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Tick",
        "signature": "lib.matplotlib.axis.Tick._set_labelrotation(self, labelrotation)",
        "snippet": "    def _set_labelrotation(self, labelrotation):\n        if isinstance(labelrotation, str):\n            mode = labelrotation\n            angle = 0\n        elif isinstance(labelrotation, (tuple, list)):\n            mode, angle = labelrotation\n        else:\n            mode = 'default'\n            angle = labelrotation\n        cbook._check_in_list(['auto', 'default'], labelrotation=mode)\n        self._labelrotation = (mode, angle)",
        "begin_line": 197,
        "end_line": 207,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005847953216374269,
            "pseudo_dstar_susp": 0.0006934812760055479,
            "pseudo_tarantula_susp": 0.0001598976654940838,
            "pseudo_op2_susp": 0.0006934812760055479,
            "pseudo_barinel_susp": 0.0001598976654940838
        }
    },
    {
        "name": "lib.matplotlib.axis.Tick.get_tick_padding#215",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Tick",
        "signature": "lib.matplotlib.axis.Tick.get_tick_padding(self)",
        "snippet": "    def get_tick_padding(self):\n        \"\"\"Get the length of the tick outside of the axes.\"\"\"\n        padding = {\n            'in': 0.0,\n            'inout': 0.5,\n            'out': 1.0\n        }\n        return self._size * padding[self._tickdir]",
        "begin_line": 215,
        "end_line": 222,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.587253414264036e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axis.Tick.get_children#224",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Tick",
        "signature": "lib.matplotlib.axis.Tick.get_children(self)",
        "snippet": "    def get_children(self):\n        children = [self.tick1line, self.tick2line,\n                    self.gridline, self.label1, self.label2]\n        return children",
        "begin_line": 224,
        "end_line": 227,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001638001638001638,
            "pseudo_dstar_susp": 0.00017943656917279743,
            "pseudo_tarantula_susp": 0.00017683465959328028,
            "pseudo_op2_susp": 0.00017943656917279743,
            "pseudo_barinel_susp": 0.00017683465959328028
        }
    },
    {
        "name": "lib.matplotlib.axis.Tick.set_clip_path#229",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Tick",
        "signature": "lib.matplotlib.axis.Tick.set_clip_path(self, clippath, transform=None)",
        "snippet": "    def set_clip_path(self, clippath, transform=None):\n        # docstring inherited\n        martist.Artist.set_clip_path(self, clippath, transform)\n        self.gridline.set_clip_path(clippath, transform)\n        self.stale = True",
        "begin_line": 229,
        "end_line": 233,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005837711617046118,
            "pseudo_dstar_susp": 0.0007457121551081282,
            "pseudo_tarantula_susp": 0.00017825311942959,
            "pseudo_op2_susp": 0.0007457121551081282,
            "pseudo_barinel_susp": 0.00017825311942959
        }
    },
    {
        "name": "lib.matplotlib.axis.Tick.get_pad#261",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Tick",
        "signature": "lib.matplotlib.axis.Tick.get_pad(self)",
        "snippet": "    def get_pad(self):\n        'Get the value of the tick label pad in points'\n        return self._base_pad",
        "begin_line": 261,
        "end_line": 263,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axis.Tick.get_loc#285",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Tick",
        "signature": "lib.matplotlib.axis.Tick.get_loc(self)",
        "snippet": "    def get_loc(self):\n        'Return the tick location (data coords) as a scalar'\n        return self._loc",
        "begin_line": 285,
        "end_line": 287,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00047732696897374703,
            "pseudo_dstar_susp": 0.00037439161362785476,
            "pseudo_tarantula_susp": 0.00019157088122605365,
            "pseudo_op2_susp": 0.00037439161362785476,
            "pseudo_barinel_susp": 0.00019157088122605365
        }
    },
    {
        "name": "lib.matplotlib.axis.Tick.draw#290",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Tick",
        "signature": "lib.matplotlib.axis.Tick.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        if not self.get_visible():\n            self.stale = False\n            return\n        renderer.open_group(self.__name__, gid=self.get_gid())\n        for artist in [self.gridline, self.tick1line, self.tick2line,\n                       self.label1, self.label2]:\n            artist.draw(renderer)\n        renderer.close_group(self.__name__)\n        self.stale = False",
        "begin_line": 290,
        "end_line": 299,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002986857825567503,
            "pseudo_dstar_susp": 0.0003181673560292714,
            "pseudo_tarantula_susp": 0.0001886080724254998,
            "pseudo_op2_susp": 0.0003181673560292714,
            "pseudo_barinel_susp": 0.0001886080724254998
        }
    },
    {
        "name": "lib.matplotlib.axis.Tick.set_label1#301",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Tick",
        "signature": "lib.matplotlib.axis.Tick.set_label1(self, s)",
        "snippet": "    def set_label1(self, s):\n        \"\"\"\n        Set the label1 text.\n\n        Parameters\n        ----------\n        s : str\n        \"\"\"\n        self.label1.set_text(s)\n        self.stale = True",
        "begin_line": 301,
        "end_line": 310,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004837929366231253,
            "pseudo_dstar_susp": 0.0003835826620636747,
            "pseudo_tarantula_susp": 0.00020214271275520516,
            "pseudo_op2_susp": 0.0003835826620636747,
            "pseudo_barinel_susp": 0.00020214271275520516
        }
    },
    {
        "name": "lib.matplotlib.axis.Tick.set_label2#314",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Tick",
        "signature": "lib.matplotlib.axis.Tick.set_label2(self, s)",
        "snippet": "    def set_label2(self, s):\n        \"\"\"\n        Set the label2 text.\n\n        Parameters\n        ----------\n        s : str\n        \"\"\"\n        self.label2.set_text(s)\n        self.stale = True",
        "begin_line": 314,
        "end_line": 323,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003158559696778269,
            "pseudo_dstar_susp": 0.00032615786040443573,
            "pseudo_tarantula_susp": 0.00018518518518518518,
            "pseudo_op2_susp": 0.00032615786040443573,
            "pseudo_barinel_susp": 0.00018518518518518518
        }
    },
    {
        "name": "lib.matplotlib.axis.Tick._set_artist_props#325",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Tick",
        "signature": "lib.matplotlib.axis.Tick._set_artist_props(self, a)",
        "snippet": "    def _set_artist_props(self, a):\n        a.set_figure(self.figure)",
        "begin_line": 325,
        "end_line": 326,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002176278563656148,
            "pseudo_dstar_susp": 0.00029403116730373417,
            "pseudo_tarantula_susp": 0.00013080444735120994,
            "pseudo_op2_susp": 0.00029403116730373417,
            "pseudo_barinel_susp": 0.00013080444735120994
        }
    },
    {
        "name": "lib.matplotlib.axis.Tick._apply_params#334",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Tick",
        "signature": "lib.matplotlib.axis.Tick._apply_params(self, **kw)",
        "snippet": "    def _apply_params(self, **kw):\n        for name, target in [(\"gridOn\", self.gridline),\n                               (\"tick1On\", self.tick1line),\n                               (\"tick2On\", self.tick2line),\n                               (\"label1On\", self.label1),\n                               (\"label2On\", self.label2)]:\n            if name in kw:\n                target.set_visible(kw.pop(name))\n        if any(k in kw for k in ['size', 'width', 'pad', 'tickdir']):\n            self._size = kw.pop('size', self._size)\n            # Width could be handled outside this block, but it is\n            # convenient to leave it here.\n            self._width = kw.pop('width', self._width)\n            self._base_pad = kw.pop('pad', self._base_pad)\n            # apply_tickdir uses _size and _base_pad to make _pad,\n            # and also makes _tickmarkers.\n            self.apply_tickdir(kw.pop('tickdir', self._tickdir))\n            self.tick1line.set_marker(self._tickmarkers[0])\n            self.tick2line.set_marker(self._tickmarkers[1])\n            for line in (self.tick1line, self.tick2line):\n                line.set_markersize(self._size)\n                line.set_markeredgewidth(self._width)\n            # _get_text1_transform uses _pad from apply_tickdir.\n            trans = self._get_text1_transform()[0]\n            self.label1.set_transform(trans)\n            trans = self._get_text2_transform()[0]\n            self.label2.set_transform(trans)\n        tick_kw = {k: v for k, v in kw.items() if k in ['color', 'zorder']}\n        self.tick1line.set(**tick_kw)\n        self.tick2line.set(**tick_kw)\n        for k, v in tick_kw.items():\n            setattr(self, '_' + k, v)\n\n        if 'labelrotation' in kw:\n            self._set_labelrotation(kw.pop('labelrotation'))\n            self.label1.set(rotation=self._labelrotation[1])\n            self.label2.set(rotation=self._labelrotation[1])\n\n        label_kw = {k[5:]: v for k, v in kw.items()\n                    if k in ['labelsize', 'labelcolor']}\n        self.label1.set(**label_kw)\n        self.label2.set(**label_kw)\n        for k, v in label_kw.items():\n            # for labelsize the text objects covert str ('small')\n            # -> points. grab the integer from the `Text` object\n            # instead of saving the string representation\n            v = getattr(self.label1, 'get_' + k)()\n            setattr(self, '_label' + k, v)\n\n        grid_kw = {k[5:]: v for k, v in kw.items()\n                   if k in _gridline_param_names}\n        self.gridline.set(**grid_kw)\n        for k, v in grid_kw.items():\n            setattr(self, '_grid_' + k, v)",
        "begin_line": 334,
        "end_line": 387,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003929273084479371,
            "pseudo_dstar_susp": 0.0005035246727089627,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.0005035246727089627,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.axis.XTick.apply_tickdir#413",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XTick",
        "signature": "lib.matplotlib.axis.XTick.apply_tickdir(self, tickdir)",
        "snippet": "    def apply_tickdir(self, tickdir):\n        if tickdir is None:\n            tickdir = rcParams['%s.direction' % self.__name__.lower()]\n        self._tickdir = tickdir\n\n        if self._tickdir == 'in':\n            self._tickmarkers = (mlines.TICKUP, mlines.TICKDOWN)\n        elif self._tickdir == 'inout':\n            self._tickmarkers = ('|', '|')\n        else:\n            self._tickmarkers = (mlines.TICKDOWN, mlines.TICKUP)\n        self._pad = self._base_pad + self.get_tick_padding()\n        self.stale = True",
        "begin_line": 413,
        "end_line": 425,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043649061545176777,
            "pseudo_dstar_susp": 0.0005763688760806917,
            "pseudo_tarantula_susp": 0.00022825838849577722,
            "pseudo_op2_susp": 0.0005763688760806917,
            "pseudo_barinel_susp": 0.00022825838849577722
        }
    },
    {
        "name": "lib.matplotlib.axis.XTick._get_text1#427",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XTick",
        "signature": "lib.matplotlib.axis.XTick._get_text1(self)",
        "snippet": "    def _get_text1(self):\n        'Get the default Text instance'\n        # the y loc is 3 points below the min of y axis\n        # get the affine as an a, b, c, d, tx, ty list\n        # x in data coords, y in axes coords\n        trans, vert, horiz = self._get_text1_transform()\n        t = mtext.Text(\n            x=0, y=0,\n            fontproperties=font_manager.FontProperties(size=self._labelsize),\n            color=self._labelcolor,\n            verticalalignment=vert,\n            horizontalalignment=horiz,\n            )\n        t.set_transform(trans)\n        self._set_artist_props(t)\n        return t",
        "begin_line": 427,
        "end_line": 442,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003913894324853229,
            "pseudo_dstar_susp": 0.0005224660397074191,
            "pseudo_tarantula_susp": 0.00014923145799134458,
            "pseudo_op2_susp": 0.0005224660397074191,
            "pseudo_barinel_susp": 0.00014923145799134458
        }
    },
    {
        "name": "lib.matplotlib.axis.XTick._get_text2#444",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XTick",
        "signature": "lib.matplotlib.axis.XTick._get_text2(self)",
        "snippet": "    def _get_text2(self):\n        'Get the default Text 2 instance'\n        # x in data coords, y in axes coords\n        trans, vert, horiz = self._get_text2_transform()\n        t = mtext.Text(\n            x=0, y=1,\n            fontproperties=font_manager.FontProperties(size=self._labelsize),\n            color=self._labelcolor,\n            verticalalignment=vert,\n            horizontalalignment=horiz,\n            )\n        t.set_transform(trans)\n        self._set_artist_props(t)\n        return t",
        "begin_line": 444,
        "end_line": 457,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004253509145044662,
            "pseudo_dstar_susp": 0.0005656108597285068,
            "pseudo_tarantula_susp": 0.00030012004801920766,
            "pseudo_op2_susp": 0.0005656108597285068,
            "pseudo_barinel_susp": 0.00030012004801920766
        }
    },
    {
        "name": "lib.matplotlib.axis.XTick._get_tick1line#459",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XTick",
        "signature": "lib.matplotlib.axis.XTick._get_tick1line(self)",
        "snippet": "    def _get_tick1line(self):\n        'Get the default line2D instance'\n        # x in data coords, y in axes coords\n        l = mlines.Line2D(xdata=(0,), ydata=(0,), color=self._color,\n                          linestyle='None', marker=self._tickmarkers[0],\n                          markersize=self._size,\n                          markeredgewidth=self._width, zorder=self._zorder)\n        l.set_transform(self.axes.get_xaxis_transform(which='tick1'))\n        self._set_artist_props(l)\n        return l",
        "begin_line": 459,
        "end_line": 468,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00039032006245121,
            "pseudo_dstar_susp": 0.0004899559039686428,
            "pseudo_tarantula_susp": 0.00027570995312930797,
            "pseudo_op2_susp": 0.0004899559039686428,
            "pseudo_barinel_susp": 0.00027570995312930797
        }
    },
    {
        "name": "lib.matplotlib.axis.XTick._get_tick2line#470",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XTick",
        "signature": "lib.matplotlib.axis.XTick._get_tick2line(self)",
        "snippet": "    def _get_tick2line(self):\n        'Get the default line2D instance'\n        # x in data coords, y in axes coords\n        l = mlines.Line2D(xdata=(0,), ydata=(1,),\n                          color=self._color,\n                          linestyle='None',\n                          marker=self._tickmarkers[1],\n                          markersize=self._size,\n                          markeredgewidth=self._width,\n                          zorder=self._zorder)\n\n        l.set_transform(self.axes.get_xaxis_transform(which='tick2'))\n        self._set_artist_props(l)\n        return l",
        "begin_line": 470,
        "end_line": 483,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040241448692152917,
            "pseudo_dstar_susp": 0.000554016620498615,
            "pseudo_tarantula_susp": 0.00029069767441860465,
            "pseudo_op2_susp": 0.000554016620498615,
            "pseudo_barinel_susp": 0.00029069767441860465
        }
    },
    {
        "name": "lib.matplotlib.axis.XTick._get_gridline#485",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XTick",
        "signature": "lib.matplotlib.axis.XTick._get_gridline(self)",
        "snippet": "    def _get_gridline(self):\n        'Get the default line2D instance'\n        # x in data coords, y in axes coords\n        l = mlines.Line2D(xdata=(0.0, 0.0), ydata=(0, 1.0),\n                          color=self._grid_color,\n                          linestyle=self._grid_linestyle,\n                          linewidth=self._grid_linewidth,\n                          alpha=self._grid_alpha,\n                          markersize=0,\n                          **self._grid_kw)\n        l.set_transform(self.axes.get_xaxis_transform(which='grid'))\n        l.get_path()._interpolation_steps = GRIDLINE_INTERPOLATION_STEPS\n        self._set_artist_props(l)\n\n        return l",
        "begin_line": 485,
        "end_line": 499,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040032025620496394,
            "pseudo_dstar_susp": 0.0005555555555555556,
            "pseudo_tarantula_susp": 0.0002925687536571094,
            "pseudo_op2_susp": 0.0005555555555555556,
            "pseudo_barinel_susp": 0.0002925687536571094
        }
    },
    {
        "name": "lib.matplotlib.axis.XTick.update_position#501",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XTick",
        "signature": "lib.matplotlib.axis.XTick.update_position(self, loc)",
        "snippet": "    def update_position(self, loc):\n        \"\"\"Set the location of tick in data coords with scalar *loc*.\"\"\"\n        self.tick1line.set_xdata((loc,))\n        self.tick2line.set_xdata((loc,))\n        self.gridline.set_xdata((loc,))\n        self.label1.set_x(loc)\n        self.label2.set_x(loc)\n        self._loc = loc\n        self.stale = True",
        "begin_line": 501,
        "end_line": 509,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003946329913180742,
            "pseudo_dstar_susp": 0.0005241090146750524,
            "pseudo_tarantula_susp": 0.0003023888720895071,
            "pseudo_op2_susp": 0.0005241090146750524,
            "pseudo_barinel_susp": 0.0003023888720895071
        }
    },
    {
        "name": "lib.matplotlib.axis.YTick.apply_tickdir#529",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YTick",
        "signature": "lib.matplotlib.axis.YTick.apply_tickdir(self, tickdir)",
        "snippet": "    def apply_tickdir(self, tickdir):\n        if tickdir is None:\n            tickdir = rcParams['%s.direction' % self.__name__.lower()]\n        self._tickdir = tickdir\n\n        if self._tickdir == 'in':\n            self._tickmarkers = (mlines.TICKRIGHT, mlines.TICKLEFT)\n        elif self._tickdir == 'inout':\n            self._tickmarkers = ('_', '_')\n        else:\n            self._tickmarkers = (mlines.TICKLEFT, mlines.TICKRIGHT)\n        self._pad = self._base_pad + self.get_tick_padding()\n        self.stale = True",
        "begin_line": 529,
        "end_line": 541,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003979307600477517,
            "pseudo_dstar_susp": 0.00046490004649000463,
            "pseudo_tarantula_susp": 0.000152114390021296,
            "pseudo_op2_susp": 0.00046490004649000463,
            "pseudo_barinel_susp": 0.000152114390021296
        }
    },
    {
        "name": "lib.matplotlib.axis.YTick._get_text1#544",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YTick",
        "signature": "lib.matplotlib.axis.YTick._get_text1(self)",
        "snippet": "    def _get_text1(self):\n        'Get the default Text instance'\n        # x in axes coords, y in data coords\n        trans, vert, horiz = self._get_text1_transform()\n        t = mtext.Text(\n            x=0, y=0,\n            fontproperties=font_manager.FontProperties(size=self._labelsize),\n            color=self._labelcolor,\n            verticalalignment=vert,\n            horizontalalignment=horiz,\n            )\n        t.set_transform(trans)\n        self._set_artist_props(t)\n        return t",
        "begin_line": 544,
        "end_line": 557,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003904724716907458,
            "pseudo_dstar_susp": 0.00046425255338904364,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.00046425255338904364,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.axis.YTick._get_text2#559",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YTick",
        "signature": "lib.matplotlib.axis.YTick._get_text2(self)",
        "snippet": "    def _get_text2(self):\n        'Get the default Text instance'\n        # x in axes coords, y in data coords\n        trans, vert, horiz = self._get_text2_transform()\n        t = mtext.Text(\n            x=1, y=0,\n            fontproperties=font_manager.FontProperties(size=self._labelsize),\n            color=self._labelcolor,\n            verticalalignment=vert,\n            horizontalalignment=horiz,\n            )\n        t.set_transform(trans)\n        self._set_artist_props(t)\n        return t",
        "begin_line": 559,
        "end_line": 572,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003878975950349108,
            "pseudo_dstar_susp": 0.0005211047420531526,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.0005211047420531526,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.axis.YTick._get_tick1line#574",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YTick",
        "signature": "lib.matplotlib.axis.YTick._get_tick1line(self)",
        "snippet": "    def _get_tick1line(self):\n        'Get the default line2D instance'\n        # x in axes coords, y in data coords\n\n        l = mlines.Line2D((0,), (0,),\n                          color=self._color,\n                          marker=self._tickmarkers[0],\n                          linestyle='None',\n                          markersize=self._size,\n                          markeredgewidth=self._width,\n                          zorder=self._zorder)\n        l.set_transform(self.axes.get_yaxis_transform(which='tick1'))\n        self._set_artist_props(l)\n        return l",
        "begin_line": 574,
        "end_line": 587,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00039108330074305825,
            "pseudo_dstar_susp": 0.0004551661356395084,
            "pseudo_tarantula_susp": 0.000280662363177098,
            "pseudo_op2_susp": 0.0004551661356395084,
            "pseudo_barinel_susp": 0.000280662363177098
        }
    },
    {
        "name": "lib.matplotlib.axis.YTick._get_tick2line#589",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YTick",
        "signature": "lib.matplotlib.axis.YTick._get_tick2line(self)",
        "snippet": "    def _get_tick2line(self):\n        'Get the default line2D instance'\n        # x in axes coords, y in data coords\n        l = mlines.Line2D((1,), (0,),\n                          color=self._color,\n                          marker=self._tickmarkers[1],\n                          linestyle='None',\n                          markersize=self._size,\n                          markeredgewidth=self._width,\n                          zorder=self._zorder)\n        l.set_transform(self.axes.get_yaxis_transform(which='tick2'))\n        self._set_artist_props(l)\n        return l",
        "begin_line": 589,
        "end_line": 601,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00039308176100628933,
            "pseudo_dstar_susp": 0.0005232862375719519,
            "pseudo_tarantula_susp": 0.0002617801047120419,
            "pseudo_op2_susp": 0.0005232862375719519,
            "pseudo_barinel_susp": 0.0002615746795710175
        }
    },
    {
        "name": "lib.matplotlib.axis.YTick._get_gridline#603",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YTick",
        "signature": "lib.matplotlib.axis.YTick._get_gridline(self)",
        "snippet": "    def _get_gridline(self):\n        'Get the default line2D instance'\n        # x in axes coords, y in data coords\n        l = mlines.Line2D(xdata=(0, 1), ydata=(0, 0),\n                          color=self._grid_color,\n                          linestyle=self._grid_linestyle,\n                          linewidth=self._grid_linewidth,\n                          alpha=self._grid_alpha,\n                          markersize=0,\n                          **self._grid_kw)\n        l.set_transform(self.axes.get_yaxis_transform(which='grid'))\n        l.get_path()._interpolation_steps = GRIDLINE_INTERPOLATION_STEPS\n        self._set_artist_props(l)\n        return l",
        "begin_line": 603,
        "end_line": 616,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003808073115003808,
            "pseudo_dstar_susp": 0.0004828585224529213,
            "pseudo_tarantula_susp": 0.0001486546751895347,
            "pseudo_op2_susp": 0.0004828585224529213,
            "pseudo_barinel_susp": 0.0001486546751895347
        }
    },
    {
        "name": "lib.matplotlib.axis.YTick.update_position#618",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YTick",
        "signature": "lib.matplotlib.axis.YTick.update_position(self, loc)",
        "snippet": "    def update_position(self, loc):\n        \"\"\"Set the location of tick in data coords with scalar *loc*.\"\"\"\n        self.tick1line.set_ydata((loc,))\n        self.tick2line.set_ydata((loc,))\n        self.gridline.set_ydata((loc,))\n        self.label1.set_y(loc)\n        self.label2.set_y(loc)\n        self._loc = loc\n        self.stale = True",
        "begin_line": 618,
        "end_line": 626,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003862495171881035,
            "pseudo_dstar_susp": 0.0005208333333333333,
            "pseudo_tarantula_susp": 0.0002925687536571094,
            "pseudo_op2_susp": 0.0005208333333333333,
            "pseudo_barinel_susp": 0.0002925687536571094
        }
    },
    {
        "name": "lib.matplotlib.axis.Ticker.__init__#645",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Ticker",
        "signature": "lib.matplotlib.axis.Ticker.__init__(self)",
        "snippet": "    def __init__(self):\n        self._locator = None\n        self._formatter = None",
        "begin_line": 645,
        "end_line": 647,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00026860059092130003,
            "pseudo_dstar_susp": 0.0003367003367003367,
            "pseudo_tarantula_susp": 0.0001350438892640108,
            "pseudo_op2_susp": 0.0003367003367003367,
            "pseudo_barinel_susp": 0.0001350438892640108
        }
    },
    {
        "name": "lib.matplotlib.axis.Ticker.locator#654",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Ticker",
        "signature": "lib.matplotlib.axis.Ticker.locator(self, locator)",
        "snippet": "    def locator(self, locator):\n        if not isinstance(locator, mticker.Locator):\n            cbook.warn_deprecated(\n                \"3.2\", message=\"Support for locators that do not subclass \"\n                \"matplotlib.ticker.Locator is deprecated since %(since)s and \"\n                \"support for them will be removed %(removal)s.\")\n        self._locator = locator",
        "begin_line": 654,
        "end_line": 660,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000361271676300578,
            "pseudo_dstar_susp": 0.0004965243296921549,
            "pseudo_tarantula_susp": 0.00013991884706870015,
            "pseudo_op2_susp": 0.0004965243296921549,
            "pseudo_barinel_susp": 0.00013991884706870015
        }
    },
    {
        "name": "lib.matplotlib.axis.Ticker.formatter#663",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Ticker",
        "signature": "lib.matplotlib.axis.Ticker.formatter(self)",
        "snippet": "    def formatter(self):\n        return self._formatter",
        "begin_line": 663,
        "end_line": 664,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.616146230007616e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axis._LazyTickList.__get__#687",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis._LazyTickList",
        "signature": "lib.matplotlib.axis._LazyTickList.__get__(self, instance, cls)",
        "snippet": "    def __get__(self, instance, cls):\n        if instance is None:\n            return self\n        else:\n            # instance._get_tick() can itself try to access the majorTicks\n            # attribute (e.g. in certain projection classes which override\n            # e.g. get_xaxis_text1_transform).  In order to avoid infinite\n            # recursion, first set the majorTicks on the instance to an empty\n            # list, then create the tick and append it.\n            if self._major:\n                instance.majorTicks = []\n                tick = instance._get_tick(major=True)\n                instance.majorTicks.append(tick)\n                return instance.majorTicks\n            else:\n                instance.minorTicks = []\n                tick = instance._get_tick(major=False)\n                instance.minorTicks.append(tick)\n                return instance.minorTicks",
        "begin_line": 687,
        "end_line": 705,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022237046920169,
            "pseudo_dstar_susp": 0.00030003000300030005,
            "pseudo_tarantula_susp": 0.00022805017103762827,
            "pseudo_op2_susp": 0.00030003000300030005,
            "pseudo_barinel_susp": 0.00022805017103762827
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.__init__#744",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.__init__(self, axes, pickradius=15)",
        "snippet": "    def __init__(self, axes, pickradius=15):\n        \"\"\"\n        Parameters\n        ----------\n        axes : `matplotlib.axes.Axes`\n            The `~.axes.Axes` to which the created Axis belongs.\n        pickradius : float\n            The acceptance radius for containment tests. See also\n            `.Axis.contains`.\n        \"\"\"\n        martist.Artist.__init__(self)\n        self._remove_overlapping_locs = True\n\n        self.set_figure(axes.figure)\n\n        self.isDefault_label = True\n\n        self.axes = axes\n        self.major = Ticker()\n        self.minor = Ticker()\n        self.callbacks = cbook.CallbackRegistry()\n\n        self._autolabelpos = True\n        self._smart_bounds = False  # Deprecated in 3.2\n\n        self.label = self._get_label()\n        self.labelpad = rcParams['axes.labelpad']\n        self.offsetText = self._get_offset_text()\n\n        self.pickradius = pickradius\n\n        # Initialize here for testing; later add API\n        self._major_tick_kw = dict()\n        self._minor_tick_kw = dict()\n\n        self.cla()\n        self._set_scale('linear')",
        "begin_line": 744,
        "end_line": 780,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002707092582566324,
            "pseudo_dstar_susp": 0.0003325573661456601,
            "pseudo_tarantula_susp": 0.00013883104262113008,
            "pseudo_op2_susp": 0.0003325573661456601,
            "pseudo_barinel_susp": 0.00013883104262113008
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_remove_overlapping_locs#788",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_remove_overlapping_locs(self)",
        "snippet": "    def get_remove_overlapping_locs(self):\n        return self._remove_overlapping_locs",
        "begin_line": 788,
        "end_line": 789,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020889910173386254,
            "pseudo_dstar_susp": 0.00023934897079942556,
            "pseudo_tarantula_susp": 0.00016857720836142953,
            "pseudo_op2_susp": 0.00023934897079942556,
            "pseudo_barinel_susp": 0.00016857720836142953
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_transform#819",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_transform(self)",
        "snippet": "    def get_transform(self):\n        return self._scale.get_transform()",
        "begin_line": 819,
        "end_line": 820,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.34306691139663e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis._set_scale#825",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis._set_scale(self, value, **kwargs)",
        "snippet": "    def _set_scale(self, value, **kwargs):\n        self._scale = mscale.scale_factory(value, self, **kwargs)\n        self._scale.set_default_locators_and_formatters(self)\n\n        self.isDefault_majloc = True\n        self.isDefault_minloc = True\n        self.isDefault_majfmt = True\n        self.isDefault_minfmt = True",
        "begin_line": 825,
        "end_line": 832,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000354735721887194,
            "pseudo_dstar_susp": 0.0004462293618920125,
            "pseudo_tarantula_susp": 0.00014398848092152627,
            "pseudo_op2_susp": 0.0004462293618920125,
            "pseudo_barinel_susp": 0.00014398848092152627
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.limit_range_for_scale#834",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.limit_range_for_scale(self, vmin, vmax)",
        "snippet": "    def limit_range_for_scale(self, vmin, vmax):\n        return self._scale.limit_range_for_scale(vmin, vmax, self.get_minpos())",
        "begin_line": 834,
        "end_line": 835,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00033840947546531303,
            "pseudo_dstar_susp": 0.00046707146193367583,
            "pseudo_tarantula_susp": 0.0002640612622128334,
            "pseudo_op2_susp": 0.00046707146193367583,
            "pseudo_barinel_susp": 0.0002640612622128334
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_children#837",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_children(self)",
        "snippet": "    def get_children(self):\n        return [self.label, self.offsetText,\n                *self.get_major_ticks(), *self.get_minor_ticks()]",
        "begin_line": 837,
        "end_line": 839,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.cla#841",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.cla(self)",
        "snippet": "    def cla(self):\n        \"\"\"Clear this axis.\"\"\"\n\n        self.label.set_text('')  # self.set_label_text would change isDefault_\n\n        self._set_scale('linear')\n\n        # Clear the callback registry for this axis, or it may \"leak\"\n        self.callbacks = cbook.CallbackRegistry()\n\n        # whether the grids are on\n        self._gridOnMajor = (rcParams['axes.grid'] and\n                             rcParams['axes.grid.which'] in ('both', 'major'))\n        self._gridOnMinor = (rcParams['axes.grid'] and\n                             rcParams['axes.grid.which'] in ('both', 'minor'))\n\n        self.reset_ticks()\n\n        self.converter = None\n        self.units = None\n        self.set_units(None)\n        self.stale = True",
        "begin_line": 841,
        "end_line": 862,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002838489923360772,
            "pseudo_dstar_susp": 0.0002617801047120419,
            "pseudo_tarantula_susp": 0.0002913752913752914,
            "pseudo_op2_susp": 0.0002617801047120419,
            "pseudo_barinel_susp": 0.0002913752913752914
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.reset_ticks#864",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.reset_ticks(self)",
        "snippet": "    def reset_ticks(self):\n        \"\"\"\n        Re-initialize the major and minor Tick lists.\n\n        Each list starts with a single fresh Tick.\n        \"\"\"\n        # Restore the lazy tick lists.\n        try:\n            del self.majorTicks\n        except AttributeError:\n            pass\n        try:\n            del self.minorTicks\n        except AttributeError:\n            pass\n        try:\n            self.set_clip_path(self.axes.patch)\n        except AttributeError:\n            pass",
        "begin_line": 864,
        "end_line": 882,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043591979075850045,
            "pseudo_dstar_susp": 0.0006215040397762585,
            "pseudo_tarantula_susp": 0.0002878526194588371,
            "pseudo_op2_susp": 0.0006215040397762585,
            "pseudo_barinel_susp": 0.0002878526194588371
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.set_tick_params#884",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.set_tick_params(self, which='major', reset=False, **kw)",
        "snippet": "    def set_tick_params(self, which='major', reset=False, **kw):\n        \"\"\"\n        Set appearance parameters for ticks, ticklabels, and gridlines.\n\n        For documentation of keyword arguments, see\n        :meth:`matplotlib.axes.Axes.tick_params`.\n        \"\"\"\n        dicts = []\n        if which == 'major' or which == 'both':\n            dicts.append(self._major_tick_kw)\n        if which == 'minor' or which == 'both':\n            dicts.append(self._minor_tick_kw)\n        kwtrans = self._translate_tick_kw(kw)\n\n        # this stashes the parameter changes so any new ticks will\n        # automatically get them\n        for d in dicts:\n            if reset:\n                d.clear()\n            d.update(kwtrans)\n\n        if reset:\n            self.reset_ticks()\n        else:\n            # apply the new kwargs to the existing ticks\n            if which == 'major' or which == 'both':\n                for tick in self.majorTicks:\n                    tick._apply_params(**kwtrans)\n            if which == 'minor' or which == 'both':\n                for tick in self.minorTicks:\n                    tick._apply_params(**kwtrans)\n            # special-case label color to also apply to the offset\n            # text\n            if 'labelcolor' in kwtrans:\n                self.offsetText.set_color(kwtrans['labelcolor'])\n\n        self.stale = True",
        "begin_line": 884,
        "end_line": 920,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043271311120726956,
            "pseudo_dstar_susp": 0.0005583472920156337,
            "pseudo_tarantula_susp": 0.00026497085320614734,
            "pseudo_op2_susp": 0.0005583472920156337,
            "pseudo_barinel_susp": 0.00026497085320614734
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis._translate_tick_kw#923",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis._translate_tick_kw(kw)",
        "snippet": "    def _translate_tick_kw(kw):\n        # The following lists may be moved to a more accessible location.\n        kwkeys = ['size', 'width', 'color', 'tickdir', 'pad',\n                  'labelsize', 'labelcolor', 'zorder', 'gridOn',\n                  'tick1On', 'tick2On', 'label1On', 'label2On',\n                  'length', 'direction', 'left', 'bottom', 'right', 'top',\n                  'labelleft', 'labelbottom', 'labelright', 'labeltop',\n                  'labelrotation'] + _gridline_param_names\n        kwtrans = {}\n        if 'length' in kw:\n            kwtrans['size'] = kw.pop('length')\n        if 'direction' in kw:\n            kwtrans['tickdir'] = kw.pop('direction')\n        if 'rotation' in kw:\n            kwtrans['labelrotation'] = kw.pop('rotation')\n        if 'left' in kw:\n            kwtrans['tick1On'] = kw.pop('left')\n        if 'bottom' in kw:\n            kwtrans['tick1On'] = kw.pop('bottom')\n        if 'right' in kw:\n            kwtrans['tick2On'] = kw.pop('right')\n        if 'top' in kw:\n            kwtrans['tick2On'] = kw.pop('top')\n        if 'labelleft' in kw:\n            kwtrans['label1On'] = kw.pop('labelleft')\n        if 'labelbottom' in kw:\n            kwtrans['label1On'] = kw.pop('labelbottom')\n        if 'labelright' in kw:\n            kwtrans['label2On'] = kw.pop('labelright')\n        if 'labeltop' in kw:\n            kwtrans['label2On'] = kw.pop('labeltop')\n        if 'colors' in kw:\n            c = kw.pop('colors')\n            kwtrans['color'] = c\n            kwtrans['labelcolor'] = c\n        # Maybe move the checking up to the caller of this method.\n        for key in kw:\n            if key not in kwkeys:\n                raise ValueError(\n                    \"keyword %s is not recognized; valid keywords are %s\"\n                    % (key, kwkeys))\n            kwtrans.update(kw)\n        return kwtrans",
        "begin_line": 923,
        "end_line": 965,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000434593654932638,
            "pseudo_dstar_susp": 0.0006211180124223603,
            "pseudo_tarantula_susp": 0.00015190642564180464,
            "pseudo_op2_susp": 0.0006211180124223603,
            "pseudo_barinel_susp": 0.00015190642564180464
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.set_clip_path#967",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.set_clip_path(self, clippath, transform=None)",
        "snippet": "    def set_clip_path(self, clippath, transform=None):\n        martist.Artist.set_clip_path(self, clippath, transform)\n        for child in self.majorTicks + self.minorTicks:\n            child.set_clip_path(clippath, transform)\n        self.stale = True",
        "begin_line": 967,
        "end_line": 971,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004422821760283061,
            "pseudo_dstar_susp": 0.0006261740763932373,
            "pseudo_tarantula_susp": 0.0002966478789676654,
            "pseudo_op2_susp": 0.0006261740763932373,
            "pseudo_barinel_susp": 0.0002966478789676654
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_inverted#1010",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_inverted(self)",
        "snippet": "    def get_inverted(self):\n        \"\"\"\n        Return whether the axis is oriented in the \"inverse\" direction.\n\n        The \"normal\" direction is increasing to the right for the x-axis and to\n        the top for the y-axis; the \"inverse\" direction is increasing to the\n        left for the x-axis and to the bottom for the y-axis.\n        \"\"\"\n        low, high = self.get_view_interval()\n        return high < low",
        "begin_line": 1010,
        "end_line": 1019,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004042037186742118,
            "pseudo_dstar_susp": 0.000361271676300578,
            "pseudo_tarantula_susp": 0.0003526093088857546,
            "pseudo_op2_susp": 0.000361271676300578,
            "pseudo_barinel_susp": 0.0003526093088857546
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis._set_artist_props#1048",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis._set_artist_props(self, a)",
        "snippet": "    def _set_artist_props(self, a):\n        if a is None:\n            return\n        a.set_figure(self.figure)",
        "begin_line": 1048,
        "end_line": 1051,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043878894251864854,
            "pseudo_dstar_susp": 0.0006242197253433209,
            "pseudo_tarantula_susp": 0.0001497454327643007,
            "pseudo_op2_susp": 0.0006242197253433209,
            "pseudo_barinel_susp": 0.0001497454327643007
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis._update_ticks#1098",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis._update_ticks(self)",
        "snippet": "    def _update_ticks(self):\n        \"\"\"\n        Update ticks (position and labels) using the current data interval of\n        the axes.  Return the list of ticks that will be drawn.\n        \"\"\"\n        major_locs = self.get_majorticklocs()\n        major_labels = self.major.formatter.format_ticks(major_locs)\n        major_ticks = self.get_major_ticks(len(major_locs))\n        self.major.formatter.set_locs(major_locs)\n        for tick, loc, label in zip(major_ticks, major_locs, major_labels):\n            tick.update_position(loc)\n            tick.set_label1(label)\n            tick.set_label2(label)\n        minor_locs = self.get_minorticklocs()\n        minor_labels = self.minor.formatter.format_ticks(minor_locs)\n        minor_ticks = self.get_minor_ticks(len(minor_locs))\n        self.minor.formatter.set_locs(minor_locs)\n        for tick, loc, label in zip(minor_ticks, minor_locs, minor_labels):\n            tick.update_position(loc)\n            tick.set_label1(label)\n            tick.set_label2(label)\n        ticks = [*major_ticks, *minor_ticks]\n\n        view_low, view_high = self.get_view_interval()\n        if view_low > view_high:\n            view_low, view_high = view_high, view_low\n\n        if self._smart_bounds and ticks:  # _smart_bounds is deprecated in 3.2\n            # handle inverted limits\n            data_low, data_high = sorted(self.get_data_interval())\n            locs = np.sort([tick.get_loc() for tick in ticks])\n            if data_low <= view_low:\n                # data extends beyond view, take view as limit\n                ilow = view_low\n            else:\n                # data stops within view, take best tick\n                good_locs = locs[locs <= data_low]\n                if len(good_locs):\n                    # last tick prior or equal to first data point\n                    ilow = good_locs[-1]\n                else:\n                    # No ticks (why not?), take first tick\n                    ilow = locs[0]\n            if data_high >= view_high:\n                # data extends beyond view, take view as limit\n                ihigh = view_high\n            else:\n                # data stops within view, take best tick\n                good_locs = locs[locs >= data_high]\n                if len(good_locs):\n                    # first tick after or equal to last data point\n                    ihigh = good_locs[0]\n                else:\n                    # No ticks (why not?), take last tick\n                    ihigh = locs[-1]\n            ticks = [tick for tick in ticks if ilow <= tick.get_loc() <= ihigh]\n\n        interval_t = self.get_transform().transform([view_low, view_high])\n\n        ticks_to_draw = []\n        for tick in ticks:\n            try:\n                loc_t = self.get_transform().transform(tick.get_loc())\n            except AssertionError:\n                # transforms.transform doesn't allow masked values but\n                # some scales might make them, so we need this try/except.\n                pass\n            else:\n                if mtransforms._interval_contains_close(interval_t, loc_t):\n                    ticks_to_draw.append(tick)\n\n        return ticks_to_draw",
        "begin_line": 1098,
        "end_line": 1169,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005688282138794084,
            "pseudo_dstar_susp": 0.00045187528242205153,
            "pseudo_tarantula_susp": 0.00020652622883106156,
            "pseudo_op2_susp": 0.00045187528242205153,
            "pseudo_barinel_susp": 0.00020652622883106156
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis._get_tick_bboxes#1171",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis._get_tick_bboxes(self, ticks, renderer)",
        "snippet": "    def _get_tick_bboxes(self, ticks, renderer):\n        \"\"\"Return lists of bboxes for ticks' label1's and label2's.\"\"\"\n        return ([tick.label1.get_window_extent(renderer)\n                 for tick in ticks if tick.label1.get_visible()],\n                [tick.label2.get_window_extent(renderer)\n                 for tick in ticks if tick.label2.get_visible()])",
        "begin_line": 1171,
        "end_line": 1176,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005649717514124294,
            "pseudo_dstar_susp": 0.00045187528242205153,
            "pseudo_tarantula_susp": 0.0003208213025344883,
            "pseudo_op2_susp": 0.00045187528242205153,
            "pseudo_barinel_susp": 0.0003208213025344883
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_tightbbox#1178",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_tightbbox(self, renderer)",
        "snippet": "    def get_tightbbox(self, renderer):\n        \"\"\"\n        Return a bounding box that encloses the axis. It only accounts\n        tick labels, axis label, and offsetText.\n        \"\"\"\n        if not self.get_visible():\n            return\n\n        ticks_to_draw = self._update_ticks()\n\n        self._update_label_position(renderer)\n\n        # go back to just this axis's tick labels\n        ticklabelBoxes, ticklabelBoxes2 = self._get_tick_bboxes(\n                    ticks_to_draw, renderer)\n\n        self._update_offset_text_position(ticklabelBoxes, ticklabelBoxes2)\n        self.offsetText.set_text(self.major.formatter.get_offset())\n\n        bboxes = [\n            *(a.get_window_extent(renderer)\n              for a in [self.label, self.offsetText]\n              if a.get_visible()),\n            *ticklabelBoxes,\n            *ticklabelBoxes2,\n        ]\n        bboxes = [b for b in bboxes\n                  if 0 < b.width < np.inf and 0 < b.height < np.inf]\n        if bboxes:\n            return mtransforms.Bbox.union(bboxes)\n        else:\n            return None",
        "begin_line": 1178,
        "end_line": 1209,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003123048094940662,
            "pseudo_dstar_susp": 0.0002984183825723665,
            "pseudo_tarantula_susp": 0.00032133676092544985,
            "pseudo_op2_susp": 0.0002984183825723665,
            "pseudo_barinel_susp": 0.00032133676092544985
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.draw#1220",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.draw(self, renderer, *args, **kwargs)",
        "snippet": "    def draw(self, renderer, *args, **kwargs):\n        'Draw the axis lines, grid lines, tick lines and labels'\n\n        if not self.get_visible():\n            return\n        renderer.open_group(__name__, gid=self.get_gid())\n\n        ticks_to_draw = self._update_ticks()\n        ticklabelBoxes, ticklabelBoxes2 = self._get_tick_bboxes(ticks_to_draw,\n                                                                renderer)\n\n        for tick in ticks_to_draw:\n            tick.draw(renderer)\n\n        # scale up the axis label box to also find the neighbors, not\n        # just the tick labels that actually overlap note we need a\n        # *copy* of the axis label box because we don't wan't to scale\n        # the actual bbox\n\n        self._update_label_position(renderer)\n\n        self.label.draw(renderer)\n\n        self._update_offset_text_position(ticklabelBoxes, ticklabelBoxes2)\n        self.offsetText.set_text(self.major.formatter.get_offset())\n        self.offsetText.draw(renderer)\n\n        renderer.close_group(__name__)\n        self.stale = False",
        "begin_line": 1220,
        "end_line": 1248,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005564830272676684,
            "pseudo_dstar_susp": 0.0004084967320261438,
            "pseudo_tarantula_susp": 0.00021367521367521368,
            "pseudo_op2_susp": 0.0004084967320261438,
            "pseudo_barinel_susp": 0.00021367521367521368
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_label#1262",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_label(self)",
        "snippet": "    def get_label(self):\n        'Return the axis label as a Text instance'\n        return self.label",
        "begin_line": 1262,
        "end_line": 1264,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_offset_text#1266",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_offset_text(self)",
        "snippet": "    def get_offset_text(self):\n        'Return the axis offsetText as a Text instance'\n        return self.offsetText",
        "begin_line": 1266,
        "end_line": 1268,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_majorticklabels#1274",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_majorticklabels(self)",
        "snippet": "    def get_majorticklabels(self):\n        'Return a list of Text instances for the major ticklabels.'\n        ticks = self.get_major_ticks()\n        labels1 = [tick.label1 for tick in ticks if tick.label1.get_visible()]\n        labels2 = [tick.label2 for tick in ticks if tick.label2.get_visible()]\n        return cbook.silent_list('Text major ticklabel', labels1 + labels2)",
        "begin_line": 1274,
        "end_line": 1279,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002153316106804479,
            "pseudo_dstar_susp": 0.00021616947686986597,
            "pseudo_tarantula_susp": 0.0003696857670979667,
            "pseudo_op2_susp": 0.00021616947686986597,
            "pseudo_barinel_susp": 0.0003696857670979667
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_minorticklabels#1281",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_minorticklabels(self)",
        "snippet": "    def get_minorticklabels(self):\n        'Return a list of Text instances for the minor ticklabels.'\n        ticks = self.get_minor_ticks()\n        labels1 = [tick.label1 for tick in ticks if tick.label1.get_visible()]\n        labels2 = [tick.label2 for tick in ticks if tick.label2.get_visible()]\n        return cbook.silent_list('Text minor ticklabel', labels1 + labels2)",
        "begin_line": 1281,
        "end_line": 1286,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_ticklabels#1288",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_ticklabels(self, minor=False, which=None)",
        "snippet": "    def get_ticklabels(self, minor=False, which=None):\n        \"\"\"\n        Get the tick labels as a list of `~matplotlib.text.Text` instances.\n\n        Parameters\n        ----------\n        minor : bool\n           If True return the minor ticklabels,\n           else return the major ticklabels\n\n        which : None, ('minor', 'major', 'both')\n           Overrides *minor*.\n\n           Selects which ticklabels to return\n\n        Returns\n        -------\n        ret : list\n           List of `~matplotlib.text.Text` instances.\n        \"\"\"\n\n        if which is not None:\n            if which == 'minor':\n                return self.get_minorticklabels()\n            elif which == 'major':\n                return self.get_majorticklabels()\n            elif which == 'both':\n                return self.get_majorticklabels() + self.get_minorticklabels()\n            else:\n                cbook._check_in_list(['major', 'minor', 'both'], which=which)\n        if minor:\n            return self.get_minorticklabels()\n        return self.get_majorticklabels()",
        "begin_line": 1288,
        "end_line": 1320,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019179133103183735,
            "pseudo_dstar_susp": 0.00016220600162206002,
            "pseudo_tarantula_susp": 0.0003696857670979667,
            "pseudo_op2_susp": 0.00016220600162206002,
            "pseudo_barinel_susp": 0.0003696857670979667
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_majorticklines#1322",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_majorticklines(self)",
        "snippet": "    def get_majorticklines(self):\n        'Return the major tick lines as a list of Line2D instances'\n        lines = []\n        ticks = self.get_major_ticks()\n        for tick in ticks:\n            lines.append(tick.tick1line)\n            lines.append(tick.tick2line)\n        return cbook.silent_list('Line2D ticklines', lines)",
        "begin_line": 1322,
        "end_line": 1329,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_majorticklocs#1346",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_majorticklocs(self)",
        "snippet": "    def get_majorticklocs(self):\n        \"\"\"Get the array of major tick locations in data coordinates.\"\"\"\n        return self.major.locator()",
        "begin_line": 1346,
        "end_line": 1348,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_minorticklocs#1350",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_minorticklocs(self)",
        "snippet": "    def get_minorticklocs(self):\n        \"\"\"Get the array of minor tick locations in data coordinates.\"\"\"\n        # Remove minor ticks duplicating major ticks.\n        major_locs = self.major.locator()\n        minor_locs = self.minor.locator()\n        transform = self._scale.get_transform()\n        tr_minor_locs = transform.transform(minor_locs)\n        tr_major_locs = transform.transform(major_locs)\n        lo, hi = sorted(transform.transform(self.get_view_interval()))\n        # Use the transformed view limits as scale.  1e-5 is the default rtol\n        # for np.isclose.\n        tol = (hi - lo) * 1e-5\n        if self.remove_overlapping_locs:\n            minor_locs = [\n                loc for loc, tr_loc in zip(minor_locs, tr_minor_locs)\n                if ~np.isclose(tr_loc, tr_major_locs, atol=tol, rtol=0).any()]\n        return minor_locs",
        "begin_line": 1350,
        "end_line": 1366,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005313496280552603,
            "pseudo_dstar_susp": 0.00045045045045045046,
            "pseudo_tarantula_susp": 0.00031416902293433867,
            "pseudo_op2_susp": 0.00045045045045045046,
            "pseudo_barinel_susp": 0.00031416902293433867
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis._copy_tick_props#1398",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis._copy_tick_props(self, src, dest)",
        "snippet": "    def _copy_tick_props(self, src, dest):\n        \"\"\"Copy the properties from *src* tick to *dest* tick.\"\"\"\n        if src is None or dest is None:\n            return\n        dest.label1.update_from(src.label1)\n        dest.label2.update_from(src.label2)\n        dest.tick1line.update_from(src.tick1line)\n        dest.tick2line.update_from(src.tick2line)\n        dest.gridline.update_from(src.gridline)",
        "begin_line": 1398,
        "end_line": 1406,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000510986203372509,
            "pseudo_dstar_susp": 0.0004158004158004158,
            "pseudo_tarantula_susp": 0.00032123353678124,
            "pseudo_op2_susp": 0.0004158004158004158,
            "pseudo_barinel_susp": 0.00032123353678124
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_major_locator#1412",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_major_locator(self)",
        "snippet": "    def get_major_locator(self):\n        'Get the locator of the major ticker'\n        return self.major.locator",
        "begin_line": 1412,
        "end_line": 1414,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00029163021289005544,
            "pseudo_dstar_susp": 0.00026896180742334586,
            "pseudo_tarantula_susp": 0.0002860411899313501,
            "pseudo_op2_susp": 0.00026896180742334586,
            "pseudo_barinel_susp": 0.0002860411899313501
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_major_formatter#1420",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_major_formatter(self)",
        "snippet": "    def get_major_formatter(self):\n        'Get the formatter of the major ticker'\n        return self.major.formatter",
        "begin_line": 1420,
        "end_line": 1422,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00016028209648982208,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00016028209648982208,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_minor_formatter#1424",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_minor_formatter(self)",
        "snippet": "    def get_minor_formatter(self):\n        'Get the formatter of the minor ticker'\n        return self.minor.formatter",
        "begin_line": 1424,
        "end_line": 1426,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_major_ticks#1428",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_major_ticks(self, numticks=None)",
        "snippet": "    def get_major_ticks(self, numticks=None):\n        'Get the tick instances; grow as necessary.'\n        if numticks is None:\n            numticks = len(self.get_majorticklocs())\n\n        while len(self.majorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=True)\n            self.majorTicks.append(tick)\n            tick.gridline.set_visible(self._gridOnMajor)\n            self._copy_tick_props(self.majorTicks[0], tick)\n\n        return self.majorTicks[:numticks]",
        "begin_line": 1428,
        "end_line": 1440,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005296610169491525,
            "pseudo_dstar_susp": 0.00045004500450045,
            "pseudo_tarantula_susp": 0.00019179133103183735,
            "pseudo_op2_susp": 0.00045004500450045,
            "pseudo_barinel_susp": 0.00019179133103183735
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_minor_ticks#1442",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_minor_ticks(self, numticks=None)",
        "snippet": "    def get_minor_ticks(self, numticks=None):\n        'Get the minor tick instances; grow as necessary.'\n        if numticks is None:\n            numticks = len(self.get_minorticklocs())\n\n        while len(self.minorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=False)\n            self.minorTicks.append(tick)\n            tick.gridline.set_visible(self._gridOnMinor)\n            self._copy_tick_props(self.minorTicks[0], tick)\n\n        return self.minorTicks[:numticks]",
        "begin_line": 1442,
        "end_line": 1454,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005288207297726071,
            "pseudo_dstar_susp": 0.000449842555105713,
            "pseudo_tarantula_susp": 0.00031928480204342275,
            "pseudo_op2_susp": 0.000449842555105713,
            "pseudo_barinel_susp": 0.00031928480204342275
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.grid#1456",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.grid(self, b=None, which='major', **kwargs)",
        "snippet": "    def grid(self, b=None, which='major', **kwargs):\n        \"\"\"\n        Configure the grid lines.\n\n        Parameters\n        ----------\n        b : bool or None\n            Whether to show the grid lines. If any *kwargs* are supplied,\n            it is assumed you want the grid on and *b* will be set to True.\n\n            If *b* is *None* and there are no *kwargs*, this toggles the\n            visibility of the lines.\n\n        which : {'major', 'minor', 'both'}\n            The grid lines to apply the changes on.\n\n        **kwargs : `.Line2D` properties\n            Define the line properties of the grid, e.g.::\n\n                grid(color='r', linestyle='-', linewidth=2)\n\n        \"\"\"\n        if len(kwargs):\n            if not b and b is not None:  # something false-like but not None\n                cbook._warn_external('First parameter to grid() is false, '\n                                     'but line properties are supplied. The '\n                                     'grid will be enabled.')\n            b = True\n        which = which.lower()\n        cbook._check_in_list(['major', 'minor', 'both'], which=which)\n        gridkw = {'grid_' + item[0]: item[1] for item in kwargs.items()}\n\n        if which in ['minor', 'both']:\n            if b is None:\n                self._gridOnMinor = not self._gridOnMinor\n            else:\n                self._gridOnMinor = b\n            self.set_tick_params(which='minor', gridOn=self._gridOnMinor,\n                                 **gridkw)\n        if which in ['major', 'both']:\n            if b is None:\n                self._gridOnMajor = not self._gridOnMajor\n            else:\n                self._gridOnMajor = b\n            self.set_tick_params(which='major', gridOn=self._gridOnMajor,\n                                 **gridkw)\n        self.stale = True",
        "begin_line": 1456,
        "end_line": 1502,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043122035360068997,
            "pseudo_dstar_susp": 0.0006180469715698393,
            "pseudo_tarantula_susp": 0.0002860411899313501,
            "pseudo_op2_susp": 0.0006180469715698393,
            "pseudo_barinel_susp": 0.0002860411899313501
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.update_units#1504",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.update_units(self, data)",
        "snippet": "    def update_units(self, data):\n        \"\"\"\n        Introspect *data* for units converter and update the\n        axis.converter instance if necessary. Return *True*\n        if *data* is registered for unit conversion.\n        \"\"\"\n        converter = munits.registry.get_converter(data)\n        if converter is None:\n            return False\n\n        neednew = self.converter != converter\n        self.converter = converter\n        default = self.converter.default_units(data, self)\n        if default is not None and self.units is None:\n            self.set_units(default)\n\n        if neednew:\n            self._update_axisinfo()\n        self.stale = True\n        return True",
        "begin_line": 1504,
        "end_line": 1523,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00034234851078397807,
            "pseudo_dstar_susp": 0.0005120327700972862,
            "pseudo_tarantula_susp": 0.0003450655624568668,
            "pseudo_op2_susp": 0.0005120327700972862,
            "pseudo_barinel_susp": 0.00034494653328734045
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis._update_axisinfo#1525",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis._update_axisinfo(self)",
        "snippet": "    def _update_axisinfo(self):\n        \"\"\"\n        Check the axis converter for the stored units to see if the\n        axis info needs to be updated.\n        \"\"\"\n        if self.converter is None:\n            return\n\n        info = self.converter.axisinfo(self.units, self)\n\n        if info is None:\n            return\n        if info.majloc is not None and \\\n           self.major.locator != info.majloc and self.isDefault_majloc:\n            self.set_major_locator(info.majloc)\n            self.isDefault_majloc = True\n        if info.minloc is not None and \\\n           self.minor.locator != info.minloc and self.isDefault_minloc:\n            self.set_minor_locator(info.minloc)\n            self.isDefault_minloc = True\n        if info.majfmt is not None and \\\n           self.major.formatter != info.majfmt and self.isDefault_majfmt:\n            self.set_major_formatter(info.majfmt)\n            self.isDefault_majfmt = True\n        if info.minfmt is not None and \\\n           self.minor.formatter != info.minfmt and self.isDefault_minfmt:\n            self.set_minor_formatter(info.minfmt)\n            self.isDefault_minfmt = True\n        if info.label is not None and self.isDefault_label:\n            self.set_label_text(info.label)\n            self.isDefault_label = True\n\n        self.set_default_intervals()",
        "begin_line": 1525,
        "end_line": 1557,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022026431718061675,
            "pseudo_dstar_susp": 0.00024319066147859923,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.00024319066147859923,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.have_units#1559",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.have_units(self)",
        "snippet": "    def have_units(self):\n        return self.converter is not None or self.units is not None",
        "begin_line": 1559,
        "end_line": 1560,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00039824771007566706,
            "pseudo_dstar_susp": 0.0005797101449275362,
            "pseudo_tarantula_susp": 0.0002834467120181406,
            "pseudo_op2_susp": 0.0005797101449275362,
            "pseudo_barinel_susp": 0.0002834467120181406
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.convert_units#1562",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.convert_units(self, x)",
        "snippet": "    def convert_units(self, x):\n        # If x is natively supported by Matplotlib, doesn't need converting\n        if munits._is_natively_supported(x):\n            return x\n\n        if self.converter is None:\n            self.converter = munits.registry.get_converter(x)\n\n        if self.converter is None:\n            return x\n        try:\n            ret = self.converter.convert(x, self.units, self)\n        except Exception as e:\n            raise munits.ConversionError('Failed to convert value(s) to axis '\n                                         f'units: {x!r}') from e\n        return ret",
        "begin_line": 1562,
        "end_line": 1577,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00039952057530962844,
            "pseudo_dstar_susp": 0.0005803830528148578,
            "pseudo_tarantula_susp": 0.0002860411899313501,
            "pseudo_op2_susp": 0.0005803830528148578,
            "pseudo_barinel_susp": 0.0002860411899313501
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.set_units#1579",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.set_units(self, u)",
        "snippet": "    def set_units(self, u):\n        \"\"\"\n        Set the units for axis.\n\n        Parameters\n        ----------\n        u : units tag\n        \"\"\"\n        if u == self.units:\n            return\n        self.units = u\n        self._update_axisinfo()\n        self.callbacks.process('units')\n        self.callbacks.process('units finalize')\n        self.stale = True",
        "begin_line": 1579,
        "end_line": 1593,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003732736095558044,
            "pseudo_dstar_susp": 0.00047824007651841227,
            "pseudo_tarantula_susp": 0.0002860411899313501,
            "pseudo_op2_susp": 0.00047824007651841227,
            "pseudo_barinel_susp": 0.0002860411899313501
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.set_label_text#1599",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.set_label_text(self, label, fontdict=None, **kwargs)",
        "snippet": "    def set_label_text(self, label, fontdict=None, **kwargs):\n        \"\"\"\n        Set the text value of the axis label.\n\n        Parameters\n        ----------\n        label : str\n            Text string.\n        fontdict : dict\n            Text properties.\n        **kwargs\n            Merged into fontdict.\n        \"\"\"\n        self.isDefault_label = False\n        self.label.set_text(label)\n        if fontdict is not None:\n            self.label.update(fontdict)\n        self.label.update(kwargs)\n        self.stale = True\n        return self.label",
        "begin_line": 1599,
        "end_line": 1618,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00029308323563892143,
            "pseudo_dstar_susp": 0.0003125,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.0003125,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.set_major_formatter#1620",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.set_major_formatter(self, formatter)",
        "snippet": "    def set_major_formatter(self, formatter):\n        \"\"\"\n        Set the formatter of the major ticker.\n\n        Parameters\n        ----------\n        formatter : `~matplotlib.ticker.Formatter`\n        \"\"\"\n        cbook._check_isinstance(mticker.Formatter, formatter=formatter)\n        self.isDefault_majfmt = False\n        self.major.formatter = formatter\n        formatter.set_axis(self)\n        self.stale = True",
        "begin_line": 1620,
        "end_line": 1632,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004033884630899556,
            "pseudo_dstar_susp": 0.0005820721769499418,
            "pseudo_tarantula_susp": 0.00029967036260113877,
            "pseudo_op2_susp": 0.0005820721769499418,
            "pseudo_barinel_susp": 0.00029967036260113877
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.set_minor_formatter#1634",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.set_minor_formatter(self, formatter)",
        "snippet": "    def set_minor_formatter(self, formatter):\n        \"\"\"\n        Set the formatter of the minor ticker.\n\n        Parameters\n        ----------\n        formatter : `~matplotlib.ticker.Formatter`\n        \"\"\"\n        cbook._check_isinstance(mticker.Formatter, formatter=formatter)\n        self.isDefault_minfmt = False\n        self.minor.formatter = formatter\n        formatter.set_axis(self)\n        self.stale = True",
        "begin_line": 1634,
        "end_line": 1646,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043878894251864854,
            "pseudo_dstar_susp": 0.0006242197253433209,
            "pseudo_tarantula_susp": 0.00029036004645760743,
            "pseudo_op2_susp": 0.0006242197253433209,
            "pseudo_barinel_susp": 0.00029036004645760743
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.set_major_locator#1648",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.set_major_locator(self, locator)",
        "snippet": "    def set_major_locator(self, locator):\n        \"\"\"\n        Set the locator of the major ticker.\n\n        Parameters\n        ----------\n        locator : `~matplotlib.ticker.Locator`\n        \"\"\"\n        cbook._check_isinstance(mticker.Locator, locator=locator)\n        self.isDefault_majloc = False\n        self.major.locator = locator\n        if self.major.formatter:\n            self.major.formatter._set_locator(locator)\n        locator.set_axis(self)\n        self.stale = True",
        "begin_line": 1648,
        "end_line": 1662,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004033884630899556,
            "pseudo_dstar_susp": 0.0005820721769499418,
            "pseudo_tarantula_susp": 0.0002644802962179318,
            "pseudo_op2_susp": 0.0005820721769499418,
            "pseudo_barinel_susp": 0.0002644802962179318
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.set_minor_locator#1664",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.set_minor_locator(self, locator)",
        "snippet": "    def set_minor_locator(self, locator):\n        \"\"\"\n        Set the locator of the minor ticker.\n\n        Parameters\n        ----------\n        locator : `~matplotlib.ticker.Locator`\n        \"\"\"\n        cbook._check_isinstance(mticker.Locator, locator=locator)\n        self.isDefault_minloc = False\n        self.minor.locator = locator\n        if self.minor.formatter:\n            self.minor.formatter._set_locator(locator)\n        locator.set_axis(self)\n        self.stale = True",
        "begin_line": 1664,
        "end_line": 1678,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003961965134706815,
            "pseudo_dstar_susp": 0.00046468401486988845,
            "pseudo_tarantula_susp": 0.0002860411899313501,
            "pseudo_op2_susp": 0.00046468401486988845,
            "pseudo_barinel_susp": 0.0002860411899313501
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.set_ticklabels#1690",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.set_ticklabels(self, ticklabels, *args, minor=False, **kwargs)",
        "snippet": "    def set_ticklabels(self, ticklabels, *args, minor=False, **kwargs):\n        r\"\"\"\n        Set the text values of the tick labels.\n\n        Parameters\n        ----------\n        ticklabels : sequence of str or of `Text`\\s\n            List of texts for tick labels; must include values for non-visible\n            labels.\n        minor : bool\n            If True, set minor ticks instead of major ticks.\n        **kwargs\n            Text properties.\n\n        Returns\n        -------\n        labels : list of `Text`\\s\n            For each tick, includes ``tick.label1`` if it is visible, then\n            ``tick.label2`` if it is visible, in that order.\n        \"\"\"\n        if args:\n            cbook.warn_deprecated(\n                \"3.1\", message=\"Additional positional arguments to \"\n                \"set_ticklabels are ignored, and deprecated since Matplotlib \"\n                \"3.1; passing them will raise a TypeError in Matplotlib 3.3.\")\n        get_labels = []\n        for t in ticklabels:\n            # try calling get_text() to check whether it is Text object\n            # if it is Text, get label content\n            try:\n                get_labels.append(t.get_text())\n            # otherwise add the label to the list directly\n            except AttributeError:\n                get_labels.append(t)\n        # replace the ticklabels list with the processed one\n        ticklabels = get_labels\n\n        if minor:\n            self.set_minor_formatter(mticker.FixedFormatter(ticklabels))\n            ticks = self.get_minor_ticks()\n        else:\n            self.set_major_formatter(mticker.FixedFormatter(ticklabels))\n            ticks = self.get_major_ticks()\n        ret = []\n        for tick_label, tick in zip(ticklabels, ticks):\n            # deal with label1\n            tick.label1.set_text(tick_label)\n            tick.label1.update(kwargs)\n            # deal with label2\n            tick.label2.set_text(tick_label)\n            tick.label2.update(kwargs)\n            # only return visible tick labels\n            if tick.label1.get_visible():\n                ret.append(tick.label1)\n            if tick.label2.get_visible():\n                ret.append(tick.label2)\n\n        self.stale = True\n        return ret",
        "begin_line": 1690,
        "end_line": 1748,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002031694433157253,
            "pseudo_dstar_susp": 0.00020699648105982198,
            "pseudo_tarantula_susp": 0.00032393909944930353,
            "pseudo_op2_susp": 0.00020699648105982198,
            "pseudo_barinel_susp": 0.00032393909944930353
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.set_ticks#1751",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.set_ticks(self, ticks, minor=False)",
        "snippet": "    def set_ticks(self, ticks, minor=False):\n        \"\"\"\n        Set the locations of the tick marks from sequence ticks\n\n        Parameters\n        ----------\n        ticks : sequence of floats\n        minor : bool\n        \"\"\"\n        # XXX if the user changes units, the information will be lost here\n        ticks = self.convert_units(ticks)\n        if len(ticks) > 1:\n            xleft, xright = self.get_view_interval()\n            if xright > xleft:\n                self.set_view_interval(min(ticks), max(ticks))\n            else:\n                self.set_view_interval(max(ticks), min(ticks))\n        if minor:\n            self.set_minor_locator(mticker.FixedLocator(ticks))\n            return self.get_minor_ticks(len(ticks))\n        else:\n            self.set_major_locator(mticker.FixedLocator(ticks))\n            return self.get_major_ticks(len(ticks))",
        "begin_line": 1751,
        "end_line": 1773,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00025131942699170643,
            "pseudo_dstar_susp": 0.00027948574622694243,
            "pseudo_tarantula_susp": 0.00020296326364927948,
            "pseudo_op2_susp": 0.00027948574622694243,
            "pseudo_barinel_susp": 0.00020296326364927948
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.axis_date#1806",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.axis_date(self, tz=None)",
        "snippet": "    def axis_date(self, tz=None):\n        \"\"\"\n        Sets up axis ticks and labels treating data along this axis as dates.\n\n        Parameters\n        ----------\n        tz : tzinfo or str or None\n            The timezone used to create date labels.\n        \"\"\"\n        # By providing a sample datetime instance with the desired timezone,\n        # the registered converter can be selected, and the \"units\" attribute,\n        # which is the timezone, can be set.\n        if isinstance(tz, str):\n            import dateutil.tz\n            tz = dateutil.tz.gettz(tz)\n        self.update_units(datetime.datetime(2009, 1, 1, 0, 0, 0, 0, tz))",
        "begin_line": 1806,
        "end_line": 1821,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis._get_ticks_position#1828",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis._get_ticks_position(self)",
        "snippet": "    def _get_ticks_position(self):\n        \"\"\"\n        Helper for `XAxis.get_ticks_position` and `YAxis.get_ticks_position`.\n\n        Check the visibility of tick1line, label1, tick2line, and label2 on\n        the first major and the first minor ticks, and return\n\n        - 1 if only tick1line and label1 are visible (which corresponds to\n          \"bottom\" for the x-axis and \"left\" for the y-axis);\n        - 2 if only tick2line and label2 are visible (which corresponds to\n          \"top\" for the x-axis and \"right\" for the y-axis);\n        - \"default\" if only tick1line, tick2line and label1 are visible;\n        - \"unknown\" otherwise.\n        \"\"\"\n        major = self.majorTicks[0]\n        minor = self.minorTicks[0]\n        if all(tick.tick1line.get_visible()\n               and not tick.tick2line.get_visible()\n               and tick.label1.get_visible()\n               and not tick.label2.get_visible()\n               for tick in [major, minor]):\n            return 1\n        elif all(tick.tick2line.get_visible()\n                 and not tick.tick1line.get_visible()\n                 and tick.label2.get_visible()\n                 and not tick.label1.get_visible()\n                 for tick in [major, minor]):\n            return 2\n        elif all(tick.tick1line.get_visible()\n                 and tick.tick2line.get_visible()\n                 and tick.label1.get_visible()\n                 and not tick.label2.get_visible()\n                 for tick in [major, minor]):\n            return \"default\"\n        else:\n            return \"unknown\"",
        "begin_line": 1828,
        "end_line": 1863,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005393743257820927,
            "pseudo_dstar_susp": 0.00042607584149978694,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00042607584149978694,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_label_position#1865",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_label_position(self)",
        "snippet": "    def get_label_position(self):\n        \"\"\"\n        Return the label position (top or bottom)\n        \"\"\"\n        return self.label_position",
        "begin_line": 1865,
        "end_line": 1869,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005408328826392645,
            "pseudo_dstar_susp": 0.000423728813559322,
            "pseudo_tarantula_susp": 0.00032393909944930353,
            "pseudo_op2_susp": 0.000423728813559322,
            "pseudo_barinel_susp": 0.00032393909944930353
        }
    },
    {
        "name": "lib.matplotlib.axis.getter#1891",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis",
        "signature": "lib.matplotlib.axis.getter(self)",
        "snippet": "    def getter(self):\n        # docstring inherited.\n        return getattr(getattr(self.axes, lim_name), attr_name)",
        "begin_line": 1891,
        "end_line": 1893,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004791566842357451,
            "pseudo_dstar_susp": 0.0004496402877697842,
            "pseudo_tarantula_susp": 0.00031625553447185326,
            "pseudo_op2_susp": 0.0004496402877697842,
            "pseudo_barinel_susp": 0.00031625553447185326
        }
    },
    {
        "name": "lib.matplotlib.axis.setter#1895",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis",
        "signature": "lib.matplotlib.axis.setter(self, vmin, vmax, ignore=False)",
        "snippet": "    def setter(self, vmin, vmax, ignore=False):\n        # docstring inherited.\n        if ignore:\n            setattr(getattr(self.axes, lim_name), attr_name, (vmin, vmax))\n        else:\n            oldmin, oldmax = getter(self)\n            if oldmin < oldmax:\n                setter(self, min(vmin, vmax, oldmin), max(vmin, vmax, oldmax),\n                       ignore=True)\n            else:\n                setter(self, max(vmin, vmax, oldmin), min(vmin, vmax, oldmax),\n                       ignore=True)\n        self.stale = True",
        "begin_line": 1895,
        "end_line": 1907,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002549069589599796,
            "pseudo_dstar_susp": 0.00025806451612903227,
            "pseudo_tarantula_susp": 0.0003992015968063872,
            "pseudo_op2_susp": 0.00025806451612903227,
            "pseudo_barinel_susp": 0.0003990422984836393
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis._get_tick#1938",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis._get_tick(self, major)",
        "snippet": "    def _get_tick(self, major):\n        if major:\n            tick_kw = self._major_tick_kw\n        else:\n            tick_kw = self._minor_tick_kw\n        return XTick(self.axes, 0, '', major=major, **tick_kw)",
        "begin_line": 1938,
        "end_line": 1943,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00037821482602118004,
            "pseudo_dstar_susp": 0.0005012531328320802,
            "pseudo_tarantula_susp": 0.00031338138514572234,
            "pseudo_op2_susp": 0.0005012531328320802,
            "pseudo_barinel_susp": 0.00031338138514572234
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis._get_label#1945",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis._get_label(self)",
        "snippet": "    def _get_label(self):\n        # x in axes coords, y in display coords (to be updated at draw\n        # time by _update_label_positions)\n        label = mtext.Text(x=0.5, y=0,\n                           fontproperties=font_manager.FontProperties(\n                               size=rcParams['axes.labelsize'],\n                               weight=rcParams['axes.labelweight']),\n                           color=rcParams['axes.labelcolor'],\n                           verticalalignment='top',\n                           horizontalalignment='center')\n\n        label.set_transform(mtransforms.blended_transform_factory(\n            self.axes.transAxes, mtransforms.IdentityTransform()))\n\n        self._set_artist_props(label)\n        self.label_position = 'bottom'\n        return label",
        "begin_line": 1945,
        "end_line": 1961,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004562043795620438,
            "pseudo_dstar_susp": 0.0006269592476489029,
            "pseudo_tarantula_susp": 0.00030012004801920766,
            "pseudo_op2_susp": 0.0006269592476489029,
            "pseudo_barinel_susp": 0.00030012004801920766
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis._get_offset_text#1963",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis._get_offset_text(self)",
        "snippet": "    def _get_offset_text(self):\n        # x in axes coords, y in display coords (to be updated at draw time)\n        offsetText = mtext.Text(x=1, y=0,\n                                fontproperties=font_manager.FontProperties(\n                                    size=rcParams['xtick.labelsize']),\n                                color=rcParams['xtick.color'],\n                                verticalalignment='top',\n                                horizontalalignment='right')\n        offsetText.set_transform(mtransforms.blended_transform_factory(\n            self.axes.transAxes, mtransforms.IdentityTransform())\n        )\n        self._set_artist_props(offsetText)\n        self.offset_text_position = 'bottom'\n        return offsetText",
        "begin_line": 1963,
        "end_line": 1976,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00045454545454545455,
            "pseudo_dstar_susp": 0.0006277463904582549,
            "pseudo_tarantula_susp": 0.0002977963073257892,
            "pseudo_op2_susp": 0.0006277463904582549,
            "pseudo_barinel_susp": 0.0002977963073257892
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis.set_label_position#1978",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis.set_label_position(self, position)",
        "snippet": "    def set_label_position(self, position):\n        \"\"\"\n        Set the label position (top or bottom)\n\n        Parameters\n        ----------\n        position : {'top', 'bottom'}\n        \"\"\"\n        self.label.set_verticalalignment(cbook._check_getitem({\n            'top': 'baseline', 'bottom': 'top',\n        }, position=position))\n        self.label_position = position\n        self.stale = True",
        "begin_line": 1978,
        "end_line": 1990,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018053800324968405,
            "pseudo_dstar_susp": 0.0001529987760097919,
            "pseudo_tarantula_susp": 0.0003450655624568668,
            "pseudo_op2_susp": 0.0001529987760097919,
            "pseudo_barinel_susp": 0.00034494653328734045
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis._get_tick_boxes_siblings#1992",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis._get_tick_boxes_siblings(self, renderer)",
        "snippet": "    def _get_tick_boxes_siblings(self, renderer):\n        \"\"\"\n        Get the bounding boxes for this `.axis` and its siblings\n        as set by `.Figure.align_xlabels` or  `.Figure.align_ylablels`.\n\n        By default it just gets bboxes for self.\n        \"\"\"\n        bboxes = []\n        bboxes2 = []\n        # get the Grouper that keeps track of x-label groups for this figure\n        grp = self.figure._align_xlabel_grp\n        # if we want to align labels from other axes:\n        for nn, axx in enumerate(grp.get_siblings(self.axes)):\n            ticks_to_draw = axx.xaxis._update_ticks()\n            tlb, tlb2 = axx.xaxis._get_tick_bboxes(ticks_to_draw, renderer)\n            bboxes.extend(tlb)\n            bboxes2.extend(tlb2)\n        return bboxes, bboxes2",
        "begin_line": 1992,
        "end_line": 2009,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000572737686139748,
            "pseudo_dstar_susp": 0.00045187528242205153,
            "pseudo_tarantula_susp": 0.0003297065611605671,
            "pseudo_op2_susp": 0.00045187528242205153,
            "pseudo_barinel_susp": 0.0003297065611605671
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis._update_label_position#2011",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis._update_label_position(self, renderer)",
        "snippet": "    def _update_label_position(self, renderer):\n        \"\"\"\n        Update the label position based on the bounding box enclosing\n        all the ticklabels and axis spine\n        \"\"\"\n        if not self._autolabelpos:\n            return\n\n        # get bounding boxes for this axis and any siblings\n        # that have been set by `fig.align_xlabels()`\n        bboxes, bboxes2 = self._get_tick_boxes_siblings(renderer=renderer)\n\n        x, y = self.label.get_position()\n        if self.label_position == 'bottom':\n            try:\n                spine = self.axes.spines['bottom']\n                spinebbox = spine.get_transform().transform_path(\n                    spine.get_path()).get_extents()\n            except KeyError:\n                # use axes if spine doesn't exist\n                spinebbox = self.axes.bbox\n            bbox = mtransforms.Bbox.union(bboxes + [spinebbox])\n            bottom = bbox.y0\n\n            self.label.set_position(\n                (x, bottom - self.labelpad * self.figure.dpi / 72)\n            )\n\n        else:\n            try:\n                spine = self.axes.spines['top']\n                spinebbox = spine.get_transform().transform_path(\n                    spine.get_path()).get_extents()\n            except KeyError:\n                # use axes if spine doesn't exist\n                spinebbox = self.axes.bbox\n            bbox = mtransforms.Bbox.union(bboxes2 + [spinebbox])\n            top = bbox.y1\n\n            self.label.set_position(\n                (x, top + self.labelpad * self.figure.dpi / 72)\n            )",
        "begin_line": 2011,
        "end_line": 2052,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005546311702717693,
            "pseudo_dstar_susp": 0.00041736227045075126,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00041736227045075126,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis._update_offset_text_position#2054",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis._update_offset_text_position(self, bboxes, bboxes2)",
        "snippet": "    def _update_offset_text_position(self, bboxes, bboxes2):\n        \"\"\"\n        Update the offset_text position based on the sequence of bounding\n        boxes of all the ticklabels\n        \"\"\"\n        x, y = self.offsetText.get_position()\n        if not len(bboxes):\n            bottom = self.axes.bbox.ymin\n        else:\n            bbox = mtransforms.Bbox.union(bboxes)\n            bottom = bbox.y0\n        self.offsetText.set_position(\n            (x, bottom - self.OFFSETTEXTPAD * self.figure.dpi / 72)\n        )",
        "begin_line": 2054,
        "end_line": 2067,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005649717514124294,
            "pseudo_dstar_susp": 0.00045187528242205153,
            "pseudo_tarantula_susp": 0.00034048348655090226,
            "pseudo_op2_susp": 0.00045187528242205153,
            "pseudo_barinel_susp": 0.00034048348655090226
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis.set_ticks_position#2091",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis.set_ticks_position(self, position)",
        "snippet": "    def set_ticks_position(self, position):\n        \"\"\"\n        Set the ticks position (top, bottom, both, default or none)\n        both sets the ticks to appear on both positions, but does not\n        change the tick labels.  'default' resets the tick positions to\n        the default: ticks on both positions, labels at bottom.  'none'\n        can be used if you don't want any ticks. 'none' and 'both'\n        affect only the ticks, not the labels.\n\n        Parameters\n        ----------\n        position : {'top', 'bottom', 'both', 'default', 'none'}\n        \"\"\"\n        if position == 'top':\n            self.set_tick_params(which='both', top=True, labeltop=True,\n                                 bottom=False, labelbottom=False)\n        elif position == 'bottom':\n            self.set_tick_params(which='both', top=False, labeltop=False,\n                                 bottom=True, labelbottom=True)\n        elif position == 'both':\n            self.set_tick_params(which='both', top=True,\n                                 bottom=True)\n        elif position == 'none':\n            self.set_tick_params(which='both', top=False,\n                                 bottom=False)\n        elif position == 'default':\n            self.set_tick_params(which='both', top=True, labeltop=False,\n                                 bottom=True, labelbottom=True)\n        else:\n            raise ValueError(\"invalid position: %s\" % position)\n        self.stale = True",
        "begin_line": 2091,
        "end_line": 2121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022609088853719196,
            "pseudo_dstar_susp": 0.00024195499637067505,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00024195499637067505,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis.tick_top#2123",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis.tick_top(self)",
        "snippet": "    def tick_top(self):\n        \"\"\"\n        Move ticks and ticklabels (if present) to the top of the axes.\n        \"\"\"\n        label = True\n        if 'label1On' in self._major_tick_kw:\n            label = (self._major_tick_kw['label1On']\n                     or self._major_tick_kw['label2On'])\n        self.set_ticks_position('top')\n        # If labels were turned off before this was called, leave them off.\n        self.set_tick_params(which='both', labeltop=label)",
        "begin_line": 2123,
        "end_line": 2133,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016616816218012627,
            "pseudo_dstar_susp": 0.00016989466530750936,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00016989466530750936,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis.tick_bottom#2135",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis.tick_bottom(self)",
        "snippet": "    def tick_bottom(self):\n        \"\"\"\n        Move ticks and ticklabels (if present) to the bottom of the axes.\n        \"\"\"\n        label = True\n        if 'label1On' in self._major_tick_kw:\n            label = (self._major_tick_kw['label1On']\n                     or self._major_tick_kw['label2On'])\n        self.set_ticks_position('bottom')\n        # If labels were turned off before this was called, leave them off.\n        self.set_tick_params(which='both', labelbottom=label)",
        "begin_line": 2135,
        "end_line": 2145,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis.get_minpos#2160",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis.get_minpos(self)",
        "snippet": "    def get_minpos(self):\n        return self.axes.dataLim.minposx",
        "begin_line": 2160,
        "end_line": 2161,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00035612535612535614,
            "pseudo_dstar_susp": 0.000496031746031746,
            "pseudo_tarantula_susp": 0.0002844141069397042,
            "pseudo_op2_susp": 0.000496031746031746,
            "pseudo_barinel_susp": 0.0002844141069397042
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis.set_default_intervals#2169",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis.set_default_intervals(self)",
        "snippet": "    def set_default_intervals(self):\n        # docstring inherited\n        xmin, xmax = 0., 1.\n        dataMutated = self.axes.dataLim.mutatedx()\n        viewMutated = self.axes.viewLim.mutatedx()\n        if not dataMutated or not viewMutated:\n            if self.converter is not None:\n                info = self.converter.axisinfo(self.units, self)\n                if info.default_limits is not None:\n                    valmin, valmax = info.default_limits\n                    xmin = self.converter.convert(valmin, self.units, self)\n                    xmax = self.converter.convert(valmax, self.units, self)\n            if not dataMutated:\n                self.axes.dataLim.intervalx = xmin, xmax\n            if not viewMutated:\n                self.axes.viewLim.intervalx = xmin, xmax\n        self.stale = True",
        "begin_line": 2169,
        "end_line": 2185,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020458265139116204,
            "pseudo_dstar_susp": 0.000196078431372549,
            "pseudo_tarantula_susp": 0.00023282887077997672,
            "pseudo_op2_susp": 0.000196078431372549,
            "pseudo_barinel_susp": 0.00023282887077997672
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis.get_tick_space#2187",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis.get_tick_space(self)",
        "snippet": "    def get_tick_space(self):\n        ends = self.axes.transAxes.transform([[0, 0], [1, 0]])\n        length = ((ends[1][0] - ends[0][0]) / self.axes.figure.dpi) * 72\n        tick = self._get_tick(True)\n        # There is a heuristic here that the aspect ratio of tick text\n        # is no more than 3:1\n        size = tick.label1.get_size() * 3\n        if size > 0:\n            return int(np.floor(length / size))\n        else:\n            return 2**31 - 1",
        "begin_line": 2187,
        "end_line": 2197,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376425855513308,
            "pseudo_dstar_susp": 0.0002608242044861763,
            "pseudo_tarantula_susp": 0.0002789400278940028,
            "pseudo_op2_susp": 0.0002608242044861763,
            "pseudo_barinel_susp": 0.0002789400278940028
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis._get_tick#2225",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis._get_tick(self, major)",
        "snippet": "    def _get_tick(self, major):\n        if major:\n            tick_kw = self._major_tick_kw\n        else:\n            tick_kw = self._minor_tick_kw\n        return YTick(self.axes, 0, '', major=major, **tick_kw)",
        "begin_line": 2225,
        "end_line": 2230,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003812428516965307,
            "pseudo_dstar_susp": 0.0005382131324004305,
            "pseudo_tarantula_susp": 0.00014394702749388226,
            "pseudo_op2_susp": 0.0005382131324004305,
            "pseudo_barinel_susp": 0.00014394702749388226
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis._get_label#2232",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis._get_label(self)",
        "snippet": "    def _get_label(self):\n        # x in display coords (updated by _update_label_position)\n        # y in axes coords\n        label = mtext.Text(x=0, y=0.5,\n                           # todo: get the label position\n                           fontproperties=font_manager.FontProperties(\n                               size=rcParams['axes.labelsize'],\n                               weight=rcParams['axes.labelweight']),\n                           color=rcParams['axes.labelcolor'],\n                           verticalalignment='bottom',\n                           horizontalalignment='center',\n                           rotation='vertical',\n                           rotation_mode='anchor')\n        label.set_transform(mtransforms.blended_transform_factory(\n            mtransforms.IdentityTransform(), self.axes.transAxes))\n\n        self._set_artist_props(label)\n        self.label_position = 'left'\n        return label",
        "begin_line": 2232,
        "end_line": 2250,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004351610095735422,
            "pseudo_dstar_susp": 0.0006180469715698393,
            "pseudo_tarantula_susp": 0.00015062509414068384,
            "pseudo_op2_susp": 0.0006180469715698393,
            "pseudo_barinel_susp": 0.00015062509414068384
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis._get_offset_text#2252",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis._get_offset_text(self)",
        "snippet": "    def _get_offset_text(self):\n        # x in display coords, y in axes coords (to be updated at draw time)\n        offsetText = mtext.Text(x=0, y=0.5,\n                                fontproperties=font_manager.FontProperties(\n                                    size=rcParams['ytick.labelsize']\n                                ),\n                                color=rcParams['ytick.color'],\n                                verticalalignment='baseline',\n                                horizontalalignment='left')\n        offsetText.set_transform(mtransforms.blended_transform_factory(\n            self.axes.transAxes, mtransforms.IdentityTransform())\n        )\n        self._set_artist_props(offsetText)\n        self.offset_text_position = 'left'\n        return offsetText",
        "begin_line": 2252,
        "end_line": 2266,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004351610095735422,
            "pseudo_dstar_susp": 0.0006180469715698393,
            "pseudo_tarantula_susp": 0.0002860411899313501,
            "pseudo_op2_susp": 0.0006180469715698393,
            "pseudo_barinel_susp": 0.0002860411899313501
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis.set_label_position#2268",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis.set_label_position(self, position)",
        "snippet": "    def set_label_position(self, position):\n        \"\"\"\n        Set the label position (left or right)\n\n        Parameters\n        ----------\n        position : {'left', 'right'}\n        \"\"\"\n        self.label.set_rotation_mode('anchor')\n        self.label.set_horizontalalignment('center')\n        self.label.set_verticalalignment(cbook._check_getitem({\n            'left': 'bottom', 'right': 'top',\n        }, position=position))\n        self.label_position = position\n        self.stale = True",
        "begin_line": 2268,
        "end_line": 2282,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002061855670103093,
            "pseudo_dstar_susp": 0.00022930520522815867,
            "pseudo_tarantula_susp": 0.0002946375957572186,
            "pseudo_op2_susp": 0.00022930520522815867,
            "pseudo_barinel_susp": 0.0002945508100147275
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis._get_tick_boxes_siblings#2284",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis._get_tick_boxes_siblings(self, renderer)",
        "snippet": "    def _get_tick_boxes_siblings(self, renderer):\n        \"\"\"\n        Get the bounding boxes for this `.axis` and its siblings\n        as set by `.Figure.align_xlabels` or  `.Figure.align_ylablels`.\n\n        By default it just gets bboxes for self.\n        \"\"\"\n        bboxes = []\n        bboxes2 = []\n        # get the Grouper that keeps track of y-label groups for this figure\n        grp = self.figure._align_ylabel_grp\n        # if we want to align labels from other axes:\n        for axx in grp.get_siblings(self.axes):\n            ticks_to_draw = axx.yaxis._update_ticks()\n            tlb, tlb2 = axx.yaxis._get_tick_bboxes(ticks_to_draw, renderer)\n            bboxes.extend(tlb)\n            bboxes2.extend(tlb2)\n        return bboxes, bboxes2",
        "begin_line": 2284,
        "end_line": 2301,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005737234652897303,
            "pseudo_dstar_susp": 0.0004450378282153983,
            "pseudo_tarantula_susp": 0.0003170577045022194,
            "pseudo_op2_susp": 0.0004450378282153983,
            "pseudo_barinel_susp": 0.0003170577045022194
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis._update_label_position#2303",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis._update_label_position(self, renderer)",
        "snippet": "    def _update_label_position(self, renderer):\n        \"\"\"\n        Update the label position based on the bounding box enclosing\n        all the ticklabels and axis spine\n        \"\"\"\n        if not self._autolabelpos:\n            return\n\n        # get bounding boxes for this axis and any siblings\n        # that have been set by `fig.align_ylabels()`\n        bboxes, bboxes2 = self._get_tick_boxes_siblings(renderer=renderer)\n\n        x, y = self.label.get_position()\n        if self.label_position == 'left':\n            try:\n                spine = self.axes.spines['left']\n                spinebbox = spine.get_transform().transform_path(\n                    spine.get_path()).get_extents()\n            except KeyError:\n                # use axes if spine doesn't exist\n                spinebbox = self.axes.bbox\n            bbox = mtransforms.Bbox.union(bboxes + [spinebbox])\n            left = bbox.x0\n            self.label.set_position(\n                (left - self.labelpad * self.figure.dpi / 72, y)\n            )\n\n        else:\n            try:\n                spine = self.axes.spines['right']\n                spinebbox = spine.get_transform().transform_path(\n                    spine.get_path()).get_extents()\n            except KeyError:\n                # use axes if spine doesn't exist\n                spinebbox = self.axes.bbox\n            bbox = mtransforms.Bbox.union(bboxes2 + [spinebbox])\n            right = bbox.x1\n\n            self.label.set_position(\n                (right + self.labelpad * self.figure.dpi / 72, y)\n            )",
        "begin_line": 2303,
        "end_line": 2343,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000576036866359447,
            "pseudo_dstar_susp": 0.00045248868778280545,
            "pseudo_tarantula_susp": 0.0003401360544217687,
            "pseudo_op2_susp": 0.00045248868778280545,
            "pseudo_barinel_susp": 0.0003401360544217687
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis._update_offset_text_position#2345",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis._update_offset_text_position(self, bboxes, bboxes2)",
        "snippet": "    def _update_offset_text_position(self, bboxes, bboxes2):\n        \"\"\"\n        Update the offset_text position based on the sequence of bounding\n        boxes of all the ticklabels\n        \"\"\"\n        x, y = self.offsetText.get_position()\n        top = self.axes.bbox.ymax\n        self.offsetText.set_position(\n            (x, top + self.OFFSETTEXTPAD * self.figure.dpi / 72)\n        )",
        "begin_line": 2345,
        "end_line": 2354,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005698005698005698,
            "pseudo_dstar_susp": 0.00045187528242205153,
            "pseudo_tarantula_susp": 0.00032123353678124,
            "pseudo_op2_susp": 0.00045187528242205153,
            "pseudo_barinel_susp": 0.00032123353678124
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis.set_offset_position#2356",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis.set_offset_position(self, position)",
        "snippet": "    def set_offset_position(self, position):\n        \"\"\"\n        Parameters\n        ----------\n        position : {'left', 'right'}\n        \"\"\"\n        x, y = self.offsetText.get_position()\n        x = cbook._check_getitem({'left': 0, 'right': 1}, position=position)\n\n        self.offsetText.set_ha(position)\n        self.offsetText.set_position((x, y))\n        self.stale = True",
        "begin_line": 2356,
        "end_line": 2367,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020815986677768527,
            "pseudo_dstar_susp": 0.0002313208420078649,
            "pseudo_tarantula_susp": 0.0002644802962179318,
            "pseudo_op2_susp": 0.0002313208420078649,
            "pseudo_barinel_susp": 0.0002644802962179318
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis.set_ticks_position#2387",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis.set_ticks_position(self, position)",
        "snippet": "    def set_ticks_position(self, position):\n        \"\"\"\n        Set the ticks position (left, right, both, default or none)\n        'both' sets the ticks to appear on both positions, but does not\n        change the tick labels.  'default' resets the tick positions to\n        the default: ticks on both positions, labels at left.  'none'\n        can be used if you don't want any ticks. 'none' and 'both'\n        affect only the ticks, not the labels.\n\n        Parameters\n        ----------\n        position : {'left', 'right', 'both', 'default', 'none'}\n        \"\"\"\n        if position == 'right':\n            self.set_tick_params(which='both', right=True, labelright=True,\n                                 left=False, labelleft=False)\n            self.set_offset_position(position)\n        elif position == 'left':\n            self.set_tick_params(which='both', right=False, labelright=False,\n                                 left=True, labelleft=True)\n            self.set_offset_position(position)\n        elif position == 'both':\n            self.set_tick_params(which='both', right=True,\n                                 left=True)\n        elif position == 'none':\n            self.set_tick_params(which='both', right=False,\n                                 left=False)\n        elif position == 'default':\n            self.set_tick_params(which='both', right=True, labelright=False,\n                                 left=True, labelleft=True)\n        else:\n            raise ValueError(\"invalid position: %s\" % position)\n        self.stale = True",
        "begin_line": 2387,
        "end_line": 2419,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021150592216582064,
            "pseudo_dstar_susp": 0.0002158428663932657,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0002158428663932657,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis.tick_right#2421",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis.tick_right(self)",
        "snippet": "    def tick_right(self):\n        \"\"\"\n        Move ticks and ticklabels (if present) to the right of the axes.\n        \"\"\"\n        label = True\n        if 'label1On' in self._major_tick_kw:\n            label = (self._major_tick_kw['label1On']\n                     or self._major_tick_kw['label2On'])\n        self.set_ticks_position('right')\n        # if labels were turned off before this was called\n        # leave them off\n        self.set_tick_params(which='both', labelright=label)",
        "begin_line": 2421,
        "end_line": 2432,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis.tick_left#2434",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis.tick_left(self)",
        "snippet": "    def tick_left(self):\n        \"\"\"\n        Move ticks and ticklabels (if present) to the left of the axes.\n        \"\"\"\n        label = True\n        if 'label1On' in self._major_tick_kw:\n            label = (self._major_tick_kw['label1On']\n                     or self._major_tick_kw['label2On'])\n        self.set_ticks_position('left')\n        # if labels were turned off before this was called\n        # leave them off\n        self.set_tick_params(which='both', labelleft=label)",
        "begin_line": 2434,
        "end_line": 2445,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.0001348799568384138,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0001348799568384138,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis.get_minpos#2460",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis.get_minpos(self)",
        "snippet": "    def get_minpos(self):\n        return self.axes.dataLim.minposy",
        "begin_line": 2460,
        "end_line": 2461,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00042052144659377626,
            "pseudo_dstar_susp": 0.0005649717514124294,
            "pseudo_tarantula_susp": 0.0002891008962127783,
            "pseudo_op2_susp": 0.0005649717514124294,
            "pseudo_barinel_susp": 0.0002891008962127783
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis.set_inverted#2463",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis.set_inverted(self, inverted)",
        "snippet": "    def set_inverted(self, inverted):\n        # docstring inherited\n        a, b = self.get_view_interval()\n        # cast to bool to avoid bad interaction between python 3.8 and np.bool_\n        self.axes.set_ylim(sorted((a, b), reverse=bool(inverted)), auto=None)",
        "begin_line": 2463,
        "end_line": 2467,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00013766519823788548,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00013766519823788548,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis.set_default_intervals#2469",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis.set_default_intervals(self)",
        "snippet": "    def set_default_intervals(self):\n        # docstring inherited\n        ymin, ymax = 0., 1.\n        dataMutated = self.axes.dataLim.mutatedy()\n        viewMutated = self.axes.viewLim.mutatedy()\n        if not dataMutated or not viewMutated:\n            if self.converter is not None:\n                info = self.converter.axisinfo(self.units, self)\n                if info.default_limits is not None:\n                    valmin, valmax = info.default_limits\n                    ymin = self.converter.convert(valmin, self.units, self)\n                    ymax = self.converter.convert(valmax, self.units, self)\n            if not dataMutated:\n                self.axes.dataLim.intervaly = ymin, ymax\n            if not viewMutated:\n                self.axes.viewLim.intervaly = ymin, ymax\n        self.stale = True",
        "begin_line": 2469,
        "end_line": 2485,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001863932898415657,
            "pseudo_dstar_susp": 0.00020593080724876442,
            "pseudo_tarantula_susp": 0.00027210884353741496,
            "pseudo_op2_susp": 0.00020593080724876442,
            "pseudo_barinel_susp": 0.0002720348204570185
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis.get_tick_space#2487",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis.get_tick_space(self)",
        "snippet": "    def get_tick_space(self):\n        ends = self.axes.transAxes.transform([[0, 0], [0, 1]])\n        length = ((ends[1][1] - ends[0][1]) / self.axes.figure.dpi) * 72\n        tick = self._get_tick(True)\n        # Having a spacing of at least 2 just looks good.\n        size = tick.label1.get_size() * 2.0\n        if size > 0:\n            return int(np.floor(length / size))\n        else:\n            return 2**31 - 1",
        "begin_line": 2487,
        "end_line": 2496,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002726281352235551,
            "pseudo_dstar_susp": 0.00030129557095510696,
            "pseudo_tarantula_susp": 0.00026068821689259646,
            "pseudo_op2_susp": 0.00030129557095510696,
            "pseudo_barinel_susp": 0.0002615746795710175
        }
    },
    {
        "name": "lib.matplotlib.backend_tools.ToolHelpBase.format_shortcut#1041",
        "src_path": "lib/matplotlib/backend_tools.py",
        "class_name": "lib.matplotlib.backend_tools.ToolHelpBase",
        "signature": "lib.matplotlib.backend_tools.ToolHelpBase.format_shortcut(key_sequence)",
        "snippet": "    def format_shortcut(key_sequence):\n        \"\"\"\n        Converts a shortcut string from the notation used in rc config to the\n        standard notation for displaying shortcuts, e.g. 'ctrl+a' -> 'Ctrl+A'.\n        \"\"\"\n        return (key_sequence if len(key_sequence) == 1 else\n                re.sub(r\"\\+[A-Z]\", r\"+Shift\\g<0>\", key_sequence).title())",
        "begin_line": 1041,
        "end_line": 1047,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.146639511201629e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.__init__#90",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.__init__(self, edgecolors=None, facecolors=None, linewidths=None, linestyles='solid', capstyle=None, joinstyle=None, antialiaseds=None, offsets=None, transOffset=None, norm=None, cmap=None, pickradius=5.0, hatch=None, urls=None, offset_position='screen', zorder=1, **kwargs)",
        "snippet": "    def __init__(self,\n                 edgecolors=None,\n                 facecolors=None,\n                 linewidths=None,\n                 linestyles='solid',\n                 capstyle=None,\n                 joinstyle=None,\n                 antialiaseds=None,\n                 offsets=None,\n                 transOffset=None,\n                 norm=None,  # optional for ScalarMappable\n                 cmap=None,  # ditto\n                 pickradius=5.0,\n                 hatch=None,\n                 urls=None,\n                 offset_position='screen',\n                 zorder=1,\n                 **kwargs\n                 ):\n        \"\"\"\n        Create a Collection\n\n        %(Collection)s\n        \"\"\"\n        artist.Artist.__init__(self)\n        cm.ScalarMappable.__init__(self, norm, cmap)\n        # list of un-scaled dash patterns\n        # this is needed scaling the dash pattern by linewidth\n        self._us_linestyles = [(None, None)]\n        # list of dash patterns\n        self._linestyles = [(None, None)]\n        # list of unbroadcast/scaled linewidths\n        self._us_lw = [0]\n        self._linewidths = [0]\n        self._is_filled = True  # May be modified by set_facecolor().\n\n        self._hatch_color = mcolors.to_rgba(mpl.rcParams['hatch.color'])\n        self.set_facecolor(facecolors)\n        self.set_edgecolor(edgecolors)\n        self.set_linewidth(linewidths)\n        self.set_linestyle(linestyles)\n        self.set_antialiased(antialiaseds)\n        self.set_pickradius(pickradius)\n        self.set_urls(urls)\n        self.set_hatch(hatch)\n        self.set_offset_position(offset_position)\n        self.set_zorder(zorder)\n\n        if capstyle:\n            self.set_capstyle(capstyle)\n        else:\n            self._capstyle = None\n\n        if joinstyle:\n            self.set_joinstyle(joinstyle)\n        else:\n            self._joinstyle = None\n\n        self._offsets = np.zeros((1, 2))\n        # save if offsets passed in were none...\n        self._offsetsNone = offsets is None\n        self._uniform_offsets = None\n        if offsets is not None:\n            offsets = np.asanyarray(offsets, float)\n            # Broadcast (2,) -> (1, 2) but nothing else.\n            if offsets.shape == (2,):\n                offsets = offsets[None, :]\n            if transOffset is not None:\n                self._offsets = offsets\n                self._transOffset = transOffset\n            else:\n                self._uniform_offsets = offsets\n\n        self._path_effects = None\n        self.update(kwargs)\n        self._paths = None",
        "begin_line": 90,
        "end_line": 165,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007047216349541931,
            "pseudo_dstar_susp": 0.0008703220191470844,
            "pseudo_tarantula_susp": 0.00019976028765481422,
            "pseudo_op2_susp": 0.0008703220191470844,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.get_transforms#173",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.get_transforms(self)",
        "snippet": "    def get_transforms(self):\n        return self._transforms",
        "begin_line": 173,
        "end_line": 174,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006349206349206349,
            "pseudo_dstar_susp": 0.0007782101167315176,
            "pseudo_tarantula_susp": 0.00018982536066818528,
            "pseudo_op2_susp": 0.0007782101167315176,
            "pseudo_barinel_susp": 0.00018982536066818528
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.get_offset_transform#176",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.get_offset_transform(self)",
        "snippet": "    def get_offset_transform(self):\n        t = self._transOffset\n        if (not isinstance(t, transforms.Transform)\n                and hasattr(t, '_as_mpl_transform')):\n            t = t._as_mpl_transform(self.axes)\n        return t",
        "begin_line": 176,
        "end_line": 181,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006675567423230974,
            "pseudo_dstar_susp": 0.0008176614881439084,
            "pseudo_tarantula_susp": 0.0001703867779860283,
            "pseudo_op2_susp": 0.0008176614881439084,
            "pseudo_barinel_susp": 0.0001703867779860283
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.get_datalim#183",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.get_datalim(self, transData)",
        "snippet": "    def get_datalim(self, transData):\n\n        # Get the automatic datalim of the collection.\n        #\n        # This operation depends on the transforms for the data in the\n        # collection and whether the collection has offsets.\n        #\n        # 1) offsets = None, transform child of transData: use the paths for\n        # the automatic limits (i.e. for LineCollection in streamline).\n        # 2) offsets != None: offset_transform is child of transData:\n        #    a) transform is child of transData: use the path + offset for\n        #       limits (i.e for bar).\n        #    b) transform is not a child of transData: just use the offsets\n        #       for the limits (i.e. for scatter)\n        # 3) otherwise return a null Bbox.\n\n        transform = self.get_transform()\n        transOffset = self.get_offset_transform()\n        if (not self._offsetsNone and\n            not transOffset.contains_branch(transData)):\n            # if there are offsets but in some co-ords other than data,\n            # then don't use them for autoscaling.\n            return transforms.Bbox.null()\n        offsets = self._offsets\n\n        paths = self.get_paths()\n\n        if not transform.is_affine:\n            paths = [transform.transform_path_non_affine(p) for p in paths]\n            # Don't convert transform to transform.get_affine() here because\n            # we may have transform.contains_branch(transData) but not\n            # transforms.get_affine().contains_branch(transData).  But later,\n            # be careful to only apply the affine part that remains.\n        if not transOffset.is_affine:\n            offsets = transOffset.transform_non_affine(offsets)\n\n        if isinstance(offsets, np.ma.MaskedArray):\n            offsets = offsets.filled(np.nan)\n            # get_path_collection_extents handles nan but not masked arrays\n\n        if len(paths) and len(offsets):\n            if transform.contains_branch(transData):\n                # collections that are just in data units (like quiver)\n                # can properly have the axes limits set by their shape +\n                # offset.  LineCollections that have no offsets can\n                # also use this algorithm (like streamplot).\n                result = mpath.get_path_collection_extents(\n                    transform.get_affine(), paths, self.get_transforms(),\n                    offsets, transOffset.get_affine().frozen())\n                return result.inverse_transformed(transData)\n            if not self._offsetsNone:\n                # this is for collections that have their paths (shapes)\n                # in physical, axes-relative, or figure-relative units\n                # (i.e. like scatter). We can't uniquely set limits based on\n                # those shapes, so we just set the limits based on their\n                # location.\n                # Finish the transform:\n                offsets = (transOffset.get_affine() +\n                           transData.inverted()).transform(offsets)\n                offsets = np.ma.masked_invalid(offsets)\n                if not offsets.mask.all():\n                    points = np.row_stack((offsets.min(axis=0),\n                                           offsets.max(axis=0)))\n                    return transforms.Bbox(points)\n        return transforms.Bbox.null()",
        "begin_line": 183,
        "end_line": 247,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004438526409232135,
            "pseudo_dstar_susp": 0.00035486160397445,
            "pseudo_tarantula_susp": 0.00021468441391155003,
            "pseudo_op2_susp": 0.00035486160397445,
            "pseudo_barinel_susp": 0.00021468441391155003
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection._prepare_points#254",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection._prepare_points(self)",
        "snippet": "    def _prepare_points(self):\n        # Helper for drawing and hit testing.\n\n        transform = self.get_transform()\n        transOffset = self.get_offset_transform()\n        offsets = self._offsets\n        paths = self.get_paths()\n\n        if self.have_units():\n            paths = []\n            for path in self.get_paths():\n                vertices = path.vertices\n                xs, ys = vertices[:, 0], vertices[:, 1]\n                xs = self.convert_xunits(xs)\n                ys = self.convert_yunits(ys)\n                paths.append(mpath.Path(np.column_stack([xs, ys]), path.codes))\n            if offsets.size:\n                xs = self.convert_xunits(offsets[:, 0])\n                ys = self.convert_yunits(offsets[:, 1])\n                offsets = np.column_stack([xs, ys])\n\n        if not transform.is_affine:\n            paths = [transform.transform_path_non_affine(path)\n                     for path in paths]\n            transform = transform.get_affine()\n        if not transOffset.is_affine:\n            offsets = transOffset.transform_non_affine(offsets)\n            # This might have changed an ndarray into a masked array.\n            transOffset = transOffset.get_affine()\n\n        if isinstance(offsets, np.ma.MaskedArray):\n            offsets = offsets.filled(np.nan)\n            # Changing from a masked array to nan-filled ndarray\n            # is probably most efficient at this point.\n\n        return transform, transOffset, offsets, paths",
        "begin_line": 254,
        "end_line": 289,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005871990604815032,
            "pseudo_dstar_susp": 0.0005678591709256105,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0005678591709256105,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.draw#292",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        if not self.get_visible():\n            return\n        renderer.open_group(self.__class__.__name__, self.get_gid())\n\n        self.update_scalarmappable()\n\n        transform, transOffset, offsets, paths = self._prepare_points()\n\n        gc = renderer.new_gc()\n        self._set_gc_clip(gc)\n        gc.set_snap(self.get_snap())\n\n        if self._hatch:\n            gc.set_hatch(self._hatch)\n            try:\n                gc.set_hatch_color(self._hatch_color)\n            except AttributeError:\n                # if we end up with a GC that does not have this method\n                cbook.warn_deprecated(\n                    \"3.1\", message=\"Your backend does not support setting the \"\n                    \"hatch color; such backends will become unsupported in \"\n                    \"Matplotlib 3.3.\")\n\n        if self.get_sketch_params() is not None:\n            gc.set_sketch_params(*self.get_sketch_params())\n\n        if self.get_path_effects():\n            from matplotlib.patheffects import PathEffectRenderer\n            renderer = PathEffectRenderer(self.get_path_effects(), renderer)\n\n        # If the collection is made up of a single shape/color/stroke,\n        # it can be rendered once and blitted multiple times, using\n        # `draw_markers` rather than `draw_path_collection`.  This is\n        # *much* faster for Agg, and results in smaller file sizes in\n        # PDF/SVG/PS.\n\n        trans = self.get_transforms()\n        facecolors = self.get_facecolor()\n        edgecolors = self.get_edgecolor()\n        do_single_path_optimization = False\n        if (len(paths) == 1 and len(trans) <= 1 and\n            len(facecolors) == 1 and len(edgecolors) == 1 and\n            len(self._linewidths) == 1 and\n            self._linestyles == [(None, None)] and\n            len(self._antialiaseds) == 1 and len(self._urls) == 1 and\n            self.get_hatch() is None):\n            if len(trans):\n                combined_transform = transforms.Affine2D(trans[0]) + transform\n            else:\n                combined_transform = transform\n            extents = paths[0].get_extents(combined_transform)\n            if (extents.width < self.figure.bbox.width\n                    and extents.height < self.figure.bbox.height):\n                do_single_path_optimization = True\n\n        if self._joinstyle:\n            gc.set_joinstyle(self._joinstyle)\n\n        if self._capstyle:\n            gc.set_capstyle(self._capstyle)\n\n        if do_single_path_optimization:\n            gc.set_foreground(tuple(edgecolors[0]))\n            gc.set_linewidth(self._linewidths[0])\n            gc.set_dashes(*self._linestyles[0])\n            gc.set_antialiased(self._antialiaseds[0])\n            gc.set_url(self._urls[0])\n            renderer.draw_markers(\n                gc, paths[0], combined_transform.frozen(),\n                mpath.Path(offsets), transOffset, tuple(facecolors[0]))\n        else:\n            renderer.draw_path_collection(\n                gc, transform.frozen(), paths,\n                self.get_transforms(), offsets, transOffset,\n                self.get_facecolor(), self.get_edgecolor(),\n                self._linewidths, self._linestyles,\n                self._antialiaseds, self._urls,\n                self._offset_position)\n\n        gc.restore()\n        renderer.close_group(self.__class__.__name__)\n        self.stale = False",
        "begin_line": 292,
        "end_line": 374,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002901915264074289,
            "pseudo_dstar_susp": 0.0003049710277523635,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0003049710277523635,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.set_pickradius#376",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.set_pickradius(self, pr)",
        "snippet": "    def set_pickradius(self, pr):\n        \"\"\"\n        Set the pick radius used for containment tests.\n\n        Parameters\n        ----------\n        d : float\n            Pick radius, in points.\n        \"\"\"\n        self._pickradius = pr",
        "begin_line": 376,
        "end_line": 385,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023674242424242425,
            "pseudo_dstar_susp": 0.0003104625892579944,
            "pseudo_tarantula_susp": 0.000135189941868325,
            "pseudo_op2_susp": 0.0003104625892579944,
            "pseudo_barinel_susp": 0.000135189941868325
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.set_urls#423",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.set_urls(self, urls)",
        "snippet": "    def set_urls(self, urls):\n        \"\"\"\n        Parameters\n        ----------\n        urls : List[str] or None\n        \"\"\"\n        self._urls = urls if urls is not None else [None]\n        self.stale = True",
        "begin_line": 423,
        "end_line": 430,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023741690408357076,
            "pseudo_dstar_susp": 0.00031133250311332503,
            "pseudo_tarantula_susp": 0.0003850596842510589,
            "pseudo_op2_susp": 0.00031133250311332503,
            "pseudo_barinel_susp": 0.00038491147036181676
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.set_hatch#435",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.set_hatch(self, hatch)",
        "snippet": "    def set_hatch(self, hatch):\n        r\"\"\"\n        Set the hatching pattern\n\n        *hatch* can be one of::\n\n          /   - diagonal hatching\n          \\   - back diagonal\n          |   - vertical\n          -   - horizontal\n          +   - crossed\n          x   - crossed diagonal\n          o   - small circle\n          O   - large circle\n          .   - dots\n          *   - stars\n\n        Letters can be combined, in which case all the specified\n        hatchings are done.  If same letter repeats, it increases the\n        density of hatching of that pattern.\n\n        Hatching is supported in the PostScript, PDF, SVG and Agg\n        backends only.\n\n        Unlike other properties such as linewidth and colors, hatching\n        can only be specified for the collection as a whole, not separately\n        for each member.\n\n        Parameters\n        ----------\n        hatch : {'/', '\\\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}\n        \"\"\"\n        self._hatch = hatch\n        self.stale = True",
        "begin_line": 435,
        "end_line": 468,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023142791020597085,
            "pseudo_dstar_susp": 0.00030193236714975844,
            "pseudo_tarantula_susp": 0.00037750094375235937,
            "pseudo_op2_susp": 0.00030193236714975844,
            "pseudo_barinel_susp": 0.00037750094375235937
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.get_hatch#470",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.get_hatch(self)",
        "snippet": "    def get_hatch(self):\n        \"\"\"Return the current hatching pattern.\"\"\"\n        return self._hatch",
        "begin_line": 470,
        "end_line": 472,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018115942028985507,
            "pseudo_dstar_susp": 0.0001703867779860283,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.0001703867779860283,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.set_offset_position#500",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.set_offset_position(self, offset_position)",
        "snippet": "    def set_offset_position(self, offset_position):\n        \"\"\"\n        Set how offsets are applied.  If *offset_position* is 'screen'\n        (default) the offset is applied after the master transform has\n        been applied, that is, the offsets are in screen coordinates.\n        If offset_position is 'data', the offset is applied before the\n        master transform, i.e., the offsets are in data coordinates.\n\n        Parameters\n        ----------\n        offset_position : {'screen', 'data'}\n        \"\"\"\n        cbook._check_in_list(['screen', 'data'],\n                             offset_position=offset_position)\n        self._offset_position = offset_position\n        self.stale = True",
        "begin_line": 500,
        "end_line": 515,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002357934449422306,
            "pseudo_dstar_susp": 0.0003097893432465923,
            "pseudo_tarantula_susp": 0.0003850596842510589,
            "pseudo_op2_susp": 0.0003097893432465923,
            "pseudo_barinel_susp": 0.00038491147036181676
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.set_linewidth#528",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.set_linewidth(self, lw)",
        "snippet": "    def set_linewidth(self, lw):\n        \"\"\"\n        Set the linewidth(s) for the collection.  *lw* can be a scalar\n        or a sequence; if it is a sequence the patches will cycle\n        through the sequence\n\n        Parameters\n        ----------\n        lw : float or sequence of floats\n        \"\"\"\n        if lw is None:\n            lw = mpl.rcParams['patch.linewidth']\n            if lw is None:\n                lw = mpl.rcParams['lines.linewidth']\n        # get the un-scaled/broadcast lw\n        self._us_lw = np.atleast_1d(np.asarray(lw))\n\n        # scale all of the dash patterns.\n        self._linewidths, self._linestyles = self._bcast_lwls(\n            self._us_lw, self._us_linestyles)\n        self.stale = True",
        "begin_line": 528,
        "end_line": 548,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023741690408357076,
            "pseudo_dstar_susp": 0.00031133250311332503,
            "pseudo_tarantula_susp": 0.00013557483731019523,
            "pseudo_op2_susp": 0.00031133250311332503,
            "pseudo_barinel_susp": 0.00013557483731019523
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.set_linestyle#550",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.set_linestyle(self, ls)",
        "snippet": "    def set_linestyle(self, ls):\n        \"\"\"\n        Set the linestyle(s) for the collection.\n\n        ===========================   =================\n        linestyle                     description\n        ===========================   =================\n        ``'-'`` or ``'solid'``        solid line\n        ``'--'`` or  ``'dashed'``     dashed line\n        ``'-.'`` or  ``'dashdot'``    dash-dotted line\n        ``':'`` or ``'dotted'``       dotted line\n        ===========================   =================\n\n        Alternatively a dash tuple of the following form can be provided::\n\n            (offset, onoffseq),\n\n        where ``onoffseq`` is an even length tuple of on and off ink in points.\n\n        Parameters\n        ----------\n        ls : {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}\n            The line style.\n        \"\"\"\n        try:\n            if isinstance(ls, str):\n                ls = cbook.ls_mapper.get(ls, ls)\n                dashes = [mlines._get_dash_pattern(ls)]\n            else:\n                try:\n                    dashes = [mlines._get_dash_pattern(ls)]\n                except ValueError:\n                    dashes = [mlines._get_dash_pattern(x) for x in ls]\n\n        except ValueError:\n            raise ValueError(\n                'Do not know how to convert {!r} to dashes'.format(ls))\n\n        # get the list of raw 'unscaled' dash patterns\n        self._us_linestyles = dashes\n\n        # broadcast and scale the lw and dash patterns\n        self._linewidths, self._linestyles = self._bcast_lwls(\n            self._us_lw, self._us_linestyles)",
        "begin_line": 550,
        "end_line": 593,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023741690408357076,
            "pseudo_dstar_susp": 0.00031133250311332503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00031133250311332503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.set_capstyle#595",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.set_capstyle(self, cs)",
        "snippet": "    def set_capstyle(self, cs):\n        \"\"\"\n        Set the capstyle for the collection (for all its elements).\n\n        Parameters\n        ----------\n        cs : {'butt', 'round', 'projecting'}\n            The capstyle\n        \"\"\"\n        cbook._check_in_list(('butt', 'round', 'projecting'), capstyle=cs)\n        self._capstyle = cs",
        "begin_line": 595,
        "end_line": 605,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.set_joinstyle#610",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.set_joinstyle(self, js)",
        "snippet": "    def set_joinstyle(self, js):\n        \"\"\"\n        Set the joinstyle for the collection (for all its elements).\n\n        Parameters\n        ----------\n        js : {'miter', 'round', 'bevel'}\n            The joinstyle\n        \"\"\"\n        cbook._check_in_list(('miter', 'round', 'bevel'), joinstyle=js)\n        self._joinstyle = js",
        "begin_line": 610,
        "end_line": 620,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection._bcast_lwls#626",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection._bcast_lwls(linewidths, dashes)",
        "snippet": "    def _bcast_lwls(linewidths, dashes):\n        \"\"\"\n        Internal helper function to broadcast + scale ls/lw\n\n        In the collection drawing code, the linewidth and linestyle are cycled\n        through as circular buffers (via ``v[i % len(v)]``).  Thus, if we are\n        going to scale the dash pattern at set time (not draw time) we need to\n        do the broadcasting now and expand both lists to be the same length.\n\n        Parameters\n        ----------\n        linewidths : list\n            line widths of collection\n        dashes : list\n            dash specification (offset, (dash pattern tuple))\n\n        Returns\n        -------\n        linewidths, dashes : list\n             Will be the same length, dashes are scaled by paired linewidth\n        \"\"\"\n        if mpl.rcParams['_internal.classic_mode']:\n            return linewidths, dashes\n        # make sure they are the same length so we can zip them\n        if len(dashes) != len(linewidths):\n            l_dashes = len(dashes)\n            l_lw = len(linewidths)\n            gcd = math.gcd(l_dashes, l_lw)\n            dashes = list(dashes) * (l_lw // gcd)\n            linewidths = list(linewidths) * (l_dashes // gcd)\n\n        # scale the dash patters\n        dashes = [mlines._scale_dashes(o, d, lw)\n                  for (o, d), lw in zip(dashes, linewidths)]\n\n        return linewidths, dashes",
        "begin_line": 626,
        "end_line": 661,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023674242424242425,
            "pseudo_dstar_susp": 0.0003104625892579944,
            "pseudo_tarantula_susp": 0.00021673168617251842,
            "pseudo_op2_susp": 0.0003104625892579944,
            "pseudo_barinel_susp": 0.00021673168617251842
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.set_antialiased#663",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.set_antialiased(self, aa)",
        "snippet": "    def set_antialiased(self, aa):\n        \"\"\"\n        Set the antialiasing state for rendering.\n\n        Parameters\n        ----------\n        aa : bool or sequence of bools\n        \"\"\"\n        if aa is None:\n            aa = mpl.rcParams['patch.antialiased']\n        self._antialiaseds = np.atleast_1d(np.asarray(aa, bool))\n        self.stale = True",
        "begin_line": 663,
        "end_line": 674,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001343183344526528,
            "pseudo_dstar_susp": 0.00016672224074691563,
            "pseudo_tarantula_susp": 0.00012186205215695832,
            "pseudo_op2_susp": 0.00016672224074691563,
            "pseudo_barinel_susp": 0.00012186205215695832
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection._set_facecolor#692",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection._set_facecolor(self, c)",
        "snippet": "    def _set_facecolor(self, c):\n        if c is None:\n            c = mpl.rcParams['patch.facecolor']\n\n        self._is_filled = True\n        try:\n            if c.lower() == 'none':\n                self._is_filled = False\n        except AttributeError:\n            pass\n        self._facecolors = mcolors.to_rgba_array(c, self._alpha)\n        self.stale = True",
        "begin_line": 692,
        "end_line": 703,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023674242424242425,
            "pseudo_dstar_susp": 0.0003104625892579944,
            "pseudo_tarantula_susp": 0.0003450655624568668,
            "pseudo_op2_susp": 0.0003104625892579944,
            "pseudo_barinel_susp": 0.00034494653328734045
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.set_facecolor#705",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.set_facecolor(self, c)",
        "snippet": "    def set_facecolor(self, c):\n        \"\"\"\n        Set the facecolor(s) of the collection. *c* can be a color (all patches\n        have same color), or a sequence of colors; if it is a sequence the\n        patches will cycle through the sequence.\n\n        If *c* is 'none', the patch will not be filled.\n\n        Parameters\n        ----------\n        c : color or sequence of colors\n        \"\"\"\n        self._original_facecolor = c\n        self._set_facecolor(c)",
        "begin_line": 705,
        "end_line": 718,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023741690408357076,
            "pseudo_dstar_susp": 0.00031133250311332503,
            "pseudo_tarantula_susp": 0.00035323207347227127,
            "pseudo_op2_susp": 0.00031133250311332503,
            "pseudo_barinel_susp": 0.00035323207347227127
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.get_facecolor#720",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.get_facecolor(self)",
        "snippet": "    def get_facecolor(self):\n        return self._facecolors",
        "begin_line": 720,
        "end_line": 721,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023849272597185786,
            "pseudo_dstar_susp": 0.00024366471734892786,
            "pseudo_tarantula_susp": 0.00043271311120726956,
            "pseudo_op2_susp": 0.00024366471734892786,
            "pseudo_barinel_susp": 0.00043271311120726956
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.get_edgecolor#723",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.get_edgecolor(self)",
        "snippet": "    def get_edgecolor(self):\n        if cbook._str_equal(self._edgecolors, 'face'):\n            return self.get_facecolor()\n        else:\n            return self._edgecolors",
        "begin_line": 723,
        "end_line": 727,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002878526194588371,
            "pseudo_dstar_susp": 0.0003093102381688834,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0003093102381688834,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection._set_edgecolor#729",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection._set_edgecolor(self, c)",
        "snippet": "    def _set_edgecolor(self, c):\n        set_hatch_color = True\n        if c is None:\n            if (mpl.rcParams['patch.force_edgecolor'] or\n                    not self._is_filled or self._edge_default):\n                c = mpl.rcParams['patch.edgecolor']\n            else:\n                c = 'none'\n                set_hatch_color = False\n\n        self._is_stroked = True\n        try:\n            if c.lower() == 'none':\n                self._is_stroked = False\n        except AttributeError:\n            pass\n\n        try:\n            if c.lower() == 'face':   # Special case: lookup in \"get\" method.\n                self._edgecolors = 'face'\n                return\n        except AttributeError:\n            pass\n        self._edgecolors = mcolors.to_rgba_array(c, self._alpha)\n        if set_hatch_color and len(self._edgecolors):\n            self._hatch_color = tuple(self._edgecolors[0])\n        self.stale = True",
        "begin_line": 729,
        "end_line": 755,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002583311805734952,
            "pseudo_dstar_susp": 0.0003191828917969997,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0003191828917969997,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.set_edgecolor#757",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.set_edgecolor(self, c)",
        "snippet": "    def set_edgecolor(self, c):\n        \"\"\"\n        Set the edgecolor(s) of the collection.\n\n        Parameters\n        ----------\n        c : color or sequence of colors or 'face'\n            The collection edgecolor(s).  If a sequence, the patches cycle\n            through it.  If 'face', match the facecolor.\n        \"\"\"\n        self._original_edgecolor = c\n        self._set_edgecolor(c)",
        "begin_line": 757,
        "end_line": 768,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023674242424242425,
            "pseudo_dstar_susp": 0.0003104625892579944,
            "pseudo_tarantula_susp": 0.0003850596842510589,
            "pseudo_op2_susp": 0.0003104625892579944,
            "pseudo_barinel_susp": 0.00038491147036181676
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.update_scalarmappable#783",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.update_scalarmappable(self)",
        "snippet": "    def update_scalarmappable(self):\n        \"\"\"Update colors from the scalar mappable array, if it is not None.\"\"\"\n        if self._A is None:\n            return\n        if self._A.ndim > 1:\n            raise ValueError('Collections can only map rank 1 arrays')\n        if not self.check_update(\"array\"):\n            return\n        if self._is_filled:\n            self._facecolors = self.to_rgba(self._A, self._alpha)\n        elif self._is_stroked:\n            self._edgecolors = self.to_rgba(self._A, self._alpha)\n        self.stale = True",
        "begin_line": 783,
        "end_line": 795,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022851919561243144,
            "pseudo_dstar_susp": 0.0002007628990162618,
            "pseudo_tarantula_susp": 0.00035323207347227127,
            "pseudo_op2_susp": 0.0002007628990162618,
            "pseudo_barinel_susp": 0.00035323207347227127
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.update_from#801",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.update_from(self, other)",
        "snippet": "    def update_from(self, other):\n        'copy properties from other to self'\n\n        artist.Artist.update_from(self, other)\n        self._antialiaseds = other._antialiaseds\n        self._original_edgecolor = other._original_edgecolor\n        self._edgecolors = other._edgecolors\n        self._original_facecolor = other._original_facecolor\n        self._facecolors = other._facecolors\n        self._linewidths = other._linewidths\n        self._linestyles = other._linestyles\n        self._us_linestyles = other._us_linestyles\n        self._pickradius = other._pickradius\n        self._hatch = other._hatch\n\n        # update_from for scalarmappable\n        self._A = other._A\n        self.norm = other.norm\n        self.cmap = other.cmap\n        # self.update_dict = other.update_dict # do we need to copy this? -JJL\n        self.stale = True",
        "begin_line": 801,
        "end_line": 821,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.collections._CollectionWithSizes.get_sizes#856",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections._CollectionWithSizes",
        "signature": "lib.matplotlib.collections._CollectionWithSizes.get_sizes(self)",
        "snippet": "    def get_sizes(self):\n        \"\"\"\n        Returns the sizes of the elements in the collection.  The\n        value represents the 'area' of the element.\n\n        Returns\n        -------\n        sizes : array\n            The 'area' of each element.\n        \"\"\"\n        return self._sizes",
        "begin_line": 856,
        "end_line": 866,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.collections._CollectionWithSizes.set_sizes#868",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections._CollectionWithSizes",
        "signature": "lib.matplotlib.collections._CollectionWithSizes.set_sizes(self, sizes, dpi=72.0)",
        "snippet": "    def set_sizes(self, sizes, dpi=72.0):\n        \"\"\"\n        Set the sizes of each member of the collection.\n\n        Parameters\n        ----------\n        sizes : ndarray or None\n            The size to set for each element of the collection.  The\n            value is the 'area' of the element.\n        dpi : float\n            The dpi of the canvas. Defaults to 72.0.\n        \"\"\"\n        if sizes is None:\n            self._sizes = np.array([])\n            self._transforms = np.empty((0, 3, 3))\n        else:\n            self._sizes = np.asarray(sizes)\n            self._transforms = np.zeros((len(self._sizes), 3, 3))\n            scale = np.sqrt(self._sizes) * dpi / 72.0 * self._factor\n            self._transforms[:, 0, 0] = scale\n            self._transforms[:, 1, 1] = scale\n            self._transforms[:, 2, 2] = 1.0\n        self.stale = True",
        "begin_line": 868,
        "end_line": 890,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019527436047646945,
            "pseudo_dstar_susp": 0.00018556318426424197,
            "pseudo_tarantula_susp": 0.00032393909944930353,
            "pseudo_op2_susp": 0.00018556318426424197,
            "pseudo_barinel_susp": 0.00032393909944930353
        }
    },
    {
        "name": "lib.matplotlib.collections._CollectionWithSizes.draw#893",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections._CollectionWithSizes",
        "signature": "lib.matplotlib.collections._CollectionWithSizes.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        self.set_sizes(self._sizes, self.figure.dpi)\n        Collection.draw(self, renderer)",
        "begin_line": 893,
        "end_line": 895,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001820830298616169,
            "pseudo_dstar_susp": 0.00018570102135561745,
            "pseudo_tarantula_susp": 0.00020008003201280514,
            "pseudo_op2_susp": 0.00018570102135561745,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.collections.PathCollection.__init__#904",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.PathCollection",
        "signature": "lib.matplotlib.collections.PathCollection.__init__(self, paths, sizes=None, **kwargs)",
        "snippet": "    def __init__(self, paths, sizes=None, **kwargs):\n        \"\"\"\n        *paths* is a sequence of :class:`matplotlib.path.Path`\n        instances.\n\n        %(Collection)s\n        \"\"\"\n\n        Collection.__init__(self, **kwargs)\n        self.set_paths(paths)\n        self.set_sizes(sizes)\n        self.stale = True",
        "begin_line": 904,
        "end_line": 915,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00015130882130428205,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00015130882130428205,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.collections.PathCollection.set_paths#917",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.PathCollection",
        "signature": "lib.matplotlib.collections.PathCollection.set_paths(self, paths)",
        "snippet": "    def set_paths(self, paths):\n        self._paths = paths\n        self.stale = True",
        "begin_line": 917,
        "end_line": 919,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018846588767433095,
            "pseudo_dstar_susp": 0.0001541782300339192,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0001541782300339192,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.collections.PathCollection.get_paths#921",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.PathCollection",
        "signature": "lib.matplotlib.collections.PathCollection.get_paths(self)",
        "snippet": "    def get_paths(self):\n        return self._paths",
        "begin_line": 921,
        "end_line": 922,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015785319652722967,
            "pseudo_dstar_susp": 0.00015179113539769278,
            "pseudo_tarantula_susp": 0.00022680880018144704,
            "pseudo_op2_susp": 0.00015179113539769278,
            "pseudo_barinel_susp": 0.00022686025408348456
        }
    },
    {
        "name": "lib.matplotlib.collections.PathCollection.legend_elements#924",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.PathCollection",
        "signature": "lib.matplotlib.collections.PathCollection.legend_elements(self, prop='colors', num='auto', fmt=None, func=lambda x: x, **kwargs)",
        "snippet": "    def legend_elements(self, prop=\"colors\", num=\"auto\",\n                     fmt=None, func=lambda x: x, **kwargs):\n        \"\"\"\n        Creates legend handles and labels for a PathCollection. This is useful\n        for obtaining a legend for a :meth:`~.Axes.scatter` plot. E.g.::\n\n            scatter = plt.scatter([1, 2, 3],  [4, 5, 6],  c=[7, 2, 3])\n            plt.legend(*scatter.legend_elements())\n\n        Also see the :ref:`automatedlegendcreation` example.\n\n        Parameters\n        ----------\n        prop : string, optional, default *\"colors\"*\n            Can be *\"colors\"* or *\"sizes\"*. In case of *\"colors\"*, the legend\n            handles will show the different colors of the collection. In case\n            of \"sizes\", the legend will show the different sizes.\n        num : int, None, \"auto\" (default), array-like, or `~.ticker.Locator`,\n            optional\n            Target number of elements to create.\n            If None, use all unique elements of the mappable array. If an\n            integer, target to use *num* elements in the normed range.\n            If *\"auto\"*, try to determine which option better suits the nature\n            of the data.\n            The number of created elements may slightly deviate from *num* due\n            to a `~.ticker.Locator` being used to find useful locations.\n            If a list or array, use exactly those elements for the legend.\n            Finally, a `~.ticker.Locator` can be provided.\n        fmt : str, `~matplotlib.ticker.Formatter`, or None (default)\n            The format or formatter to use for the labels. If a string must be\n            a valid input for a `~.StrMethodFormatter`. If None (the default),\n            use a `~.ScalarFormatter`.\n        func : function, default *lambda x: x*\n            Function to calculate the labels. Often the size (or color)\n            argument to :meth:`~.Axes.scatter` will have been pre-processed\n            by the user using a function *s = f(x)* to make the markers\n            visible; e.g. *size = np.log10(x)*. Providing the inverse of this\n            function here allows that pre-processing to be inverted, so that\n            the legend labels have the correct values;\n            e.g. *func = np.exp(x, 10)*.\n        kwargs : further parameters\n            Allowed keyword arguments are *color* and *size*. E.g. it may be\n            useful to set the color of the markers if *prop=\"sizes\"* is used;\n            similarly to set the size of the markers if *prop=\"colors\"* is\n            used. Any further parameters are passed onto the `.Line2D`\n            instance. This may be useful to e.g. specify a different\n            *markeredgecolor* or *alpha* for the legend handles.\n\n        Returns\n        -------\n        tuple (handles, labels)\n            with *handles* being a list of `.Line2D`  objects\n            and *labels* a matching list of strings.\n        \"\"\"\n        handles = []\n        labels = []\n        hasarray = self.get_array() is not None\n        if fmt is None:\n            fmt = mpl.ticker.ScalarFormatter(useOffset=False, useMathText=True)\n        elif isinstance(fmt, str):\n            fmt = mpl.ticker.StrMethodFormatter(fmt)\n        fmt.create_dummy_axis()\n\n        if prop == \"colors\":\n            if not hasarray:\n                warnings.warn(\"Collection without array used. Make sure to \"\n                              \"specify the values to be colormapped via the \"\n                              \"`c` argument.\")\n                return handles, labels\n            u = np.unique(self.get_array())\n            size = kwargs.pop(\"size\", mpl.rcParams[\"lines.markersize\"])\n        elif prop == \"sizes\":\n            u = np.unique(self.get_sizes())\n            color = kwargs.pop(\"color\", \"k\")\n        else:\n            raise ValueError(\"Valid values for `prop` are 'colors' or \"\n                             f\"'sizes'. You supplied '{prop}' instead.\")\n\n        fmt.set_bounds(func(u).min(), func(u).max())\n        if num == \"auto\":\n            num = 9\n            if len(u) <= num:\n                num = None\n        if num is None:\n            values = u\n            label_values = func(values)\n        else:\n            if prop == \"colors\":\n                arr = self.get_array()\n            elif prop == \"sizes\":\n                arr = self.get_sizes()\n            if isinstance(num, mpl.ticker.Locator):\n                loc = num\n            elif np.iterable(num):\n                loc = mpl.ticker.FixedLocator(num)\n            else:\n                num = int(num)\n                loc = mpl.ticker.MaxNLocator(nbins=num, min_n_ticks=num-1,\n                                             steps=[1, 2, 2.5, 3, 5, 6, 8, 10])\n            label_values = loc.tick_values(func(arr).min(), func(arr).max())\n            cond = ((label_values >= func(arr).min()) &\n                    (label_values <= func(arr).max()))\n            label_values = label_values[cond]\n            xarr = np.linspace(arr.min(), arr.max(), 256)\n            values = np.interp(label_values, func(xarr), xarr)\n\n        kw = dict(markeredgewidth=self.get_linewidths()[0],\n                  alpha=self.get_alpha())\n        kw.update(kwargs)\n\n        for val, lab in zip(values, label_values):\n            if prop == \"colors\":\n                color = self.cmap(self.norm(val))\n            elif prop == \"sizes\":\n                size = np.sqrt(val)\n                if np.isclose(size, 0.0):\n                    continue\n            h = mlines.Line2D([0], [0], ls=\"\", color=color, ms=size,\n                              marker=self.get_paths()[0], **kw)\n            handles.append(h)\n            if hasattr(fmt, \"set_locs\"):\n                fmt.set_locs(label_values)\n            l = fmt(lab)\n            labels.append(l)\n\n        return handles, labels",
        "begin_line": 924,
        "end_line": 1049,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.collections.PolyCollection.__init__#1054",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.PolyCollection",
        "signature": "lib.matplotlib.collections.PolyCollection.__init__(self, verts, sizes=None, closed=True, **kwargs)",
        "snippet": "    def __init__(self, verts, sizes=None, closed=True, **kwargs):\n        \"\"\"\n        *verts* is a sequence of ( *verts0*, *verts1*, ...) where\n        *verts_i* is a sequence of *xy* tuples of vertices, or an\n        equivalent :mod:`numpy` array of shape (*nv*, 2).\n\n        *sizes* is *None* (default) or a sequence of floats that\n        scale the corresponding *verts_i*.  The scaling is applied\n        before the Artist master transform; if the latter is an identity\n        transform, then the overall scaling is such that if\n        *verts_i* specify a unit square, then *sizes_i* is the area\n        of that square in points^2.\n        If len(*sizes*) < *nv*, the additional values will be\n        taken cyclically from the array.\n\n        *closed*, when *True*, will explicitly close the polygon.\n\n        %(Collection)s\n        \"\"\"\n        Collection.__init__(self, **kwargs)\n        self.set_sizes(sizes)\n        self.set_verts(verts, closed)\n        self.stale = True",
        "begin_line": 1054,
        "end_line": 1076,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015992323684631377,
            "pseudo_dstar_susp": 0.00016952025767079165,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.00016952025767079165,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.collections.PolyCollection.set_verts#1078",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.PolyCollection",
        "signature": "lib.matplotlib.collections.PolyCollection.set_verts(self, verts, closed=True)",
        "snippet": "    def set_verts(self, verts, closed=True):\n        '''This allows one to delay initialization of the vertices.'''\n        if isinstance(verts, np.ma.MaskedArray):\n            verts = verts.astype(float).filled(np.nan)\n            # This is much faster than having Path do it one at a time.\n        if closed:\n            self._paths = []\n            for xy in verts:\n                if len(xy):\n                    if isinstance(xy, np.ma.MaskedArray):\n                        xy = np.ma.concatenate([xy, xy[0:1]])\n                    else:\n                        xy = np.asarray(xy)\n                        xy = np.concatenate([xy, xy[0:1]])\n                    codes = np.empty(xy.shape[0], dtype=mpath.Path.code_type)\n                    codes[:] = mpath.Path.LINETO\n                    codes[0] = mpath.Path.MOVETO\n                    codes[-1] = mpath.Path.CLOSEPOLY\n                    self._paths.append(mpath.Path(xy, codes))\n                else:\n                    self._paths.append(mpath.Path(xy))\n        else:\n            self._paths = [mpath.Path(xy) for xy in verts]\n        self.stale = True",
        "begin_line": 1078,
        "end_line": 1101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001830831197363603,
            "pseudo_dstar_susp": 0.00017076502732240437,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00017076502732240437,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.collections.RegularPolyCollection.__init__#1173",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.RegularPolyCollection",
        "signature": "lib.matplotlib.collections.RegularPolyCollection.__init__(self, numsides, rotation=0, sizes=(1,), **kwargs)",
        "snippet": "    def __init__(self,\n                 numsides,\n                 rotation=0,\n                 sizes=(1,),\n                 **kwargs):\n        \"\"\"\n        *numsides*\n            the number of sides of the polygon\n\n        *rotation*\n            the rotation of the polygon in radians\n\n        *sizes*\n            gives the area of the circle circumscribing the\n            regular polygon in points^2\n\n        %(Collection)s\n\n        Example: see :doc:`/gallery/event_handling/lasso_demo` for a\n        complete example::\n\n            offsets = np.random.rand(20, 2)\n            facecolors = [cm.jet(x) for x in np.random.rand(20)]\n\n            collection = RegularPolyCollection(\n                numsides=5, # a pentagon\n                rotation=0, sizes=(50,),\n                facecolors=facecolors,\n                edgecolors=(\"black\",),\n                linewidths=(1,),\n                offsets=offsets,\n                transOffset=ax.transData,\n                )\n        \"\"\"\n        Collection.__init__(self, **kwargs)\n        self.set_sizes(sizes)\n        self._numsides = numsides\n        self._paths = [self._path_generator(numsides)]\n        self._rotation = rotation\n        self.set_transform(transforms.IdentityTransform())",
        "begin_line": 1173,
        "end_line": 1212,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.collections.LineCollection.__init__#1254",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.LineCollection",
        "signature": "lib.matplotlib.collections.LineCollection.__init__(self, segments, linewidths=None, colors=None, antialiaseds=None, linestyles='solid', offsets=None, transOffset=None, norm=None, cmap=None, pickradius=5, zorder=2, facecolors='none', **kwargs)",
        "snippet": "    def __init__(self, segments,     # Can be None.\n                 linewidths=None,\n                 colors=None,\n                 antialiaseds=None,\n                 linestyles='solid',\n                 offsets=None,\n                 transOffset=None,\n                 norm=None,\n                 cmap=None,\n                 pickradius=5,\n                 zorder=2,\n                 facecolors='none',\n                 **kwargs\n                 ):\n        \"\"\"\n        Parameters\n        ----------\n        segments\n            A sequence of (*line0*, *line1*, *line2*), where::\n\n                linen = (x0, y0), (x1, y1), ... (xm, ym)\n\n            or the equivalent numpy array with two columns. Each line\n            can be a different length.\n\n        colors : sequence, optional\n            A sequence of RGBA tuples (e.g., arbitrary color\n            strings, etc, not allowed).\n\n        antialiaseds : sequence, optional\n            A sequence of ones or zeros.\n\n        linestyles : str or tuple, optional\n            Either one of {'solid', 'dashed', 'dashdot', 'dotted'}, or\n            a dash tuple. The dash tuple is::\n\n                (offset, onoffseq)\n\n            where ``onoffseq`` is an even length tuple of on and off ink\n            in points.\n\n        norm : Normalize, optional\n            `~.colors.Normalize` instance.\n\n        cmap : str or Colormap, optional\n            Colormap name or `~.colors.Colormap` instance.\n\n        pickradius : float, optional\n            The tolerance in points for mouse clicks picking a line.\n            Default is 5 pt.\n\n        zorder : int, optional\n           zorder of the LineCollection. Default is 2.\n\n        facecolors : optional\n           The facecolors of the LineCollection. Default is 'none'.\n           Setting to a value other than 'none' will lead to a filled\n           polygon being drawn between points on each line.\n\n        Notes\n        -----\n        If *linewidths*, *colors*, or *antialiaseds* is None, they\n        default to their rcParams setting, in sequence form.\n\n        If *offsets* and *transOffset* are not None, then\n        *offsets* are transformed by *transOffset* and applied after\n        the segments have been transformed to display coordinates.\n\n        If *offsets* is not None but *transOffset* is None, then the\n        *offsets* are added to the segments before any transformation.\n        In this case, a single offset can be specified as::\n\n            offsets=(xo, yo)\n\n        and this value will be added cumulatively to each successive\n        segment, so as to produce a set of successively offset curves.\n\n        The use of :class:`~matplotlib.cm.ScalarMappable` is optional.\n        If the :class:`~matplotlib.cm.ScalarMappable` array\n        :attr:`~matplotlib.cm.ScalarMappable._A` is not None (i.e., a call to\n        :meth:`~matplotlib.cm.ScalarMappable.set_array` has been made), at\n        draw time a call to scalar mappable will be made to set the colors.\n        \"\"\"\n        if colors is None:\n            colors = mpl.rcParams['lines.color']\n        if linewidths is None:\n            linewidths = (mpl.rcParams['lines.linewidth'],)\n        if antialiaseds is None:\n            antialiaseds = (mpl.rcParams['lines.antialiased'],)\n\n        colors = mcolors.to_rgba_array(colors)\n        Collection.__init__(\n            self,\n            edgecolors=colors,\n            facecolors=facecolors,\n            linewidths=linewidths,\n            linestyles=linestyles,\n            antialiaseds=antialiaseds,\n            offsets=offsets,\n            transOffset=transOffset,\n            norm=norm,\n            cmap=cmap,\n            pickradius=pickradius,\n            zorder=zorder,\n            **kwargs)\n\n        self.set_segments(segments)",
        "begin_line": 1254,
        "end_line": 1360,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002332089552238806,
            "pseudo_dstar_susp": 0.0002898550724637681,
            "pseudo_tarantula_susp": 0.00032393909944930353,
            "pseudo_op2_susp": 0.0002898550724637681,
            "pseudo_barinel_susp": 0.00032393909944930353
        }
    },
    {
        "name": "lib.matplotlib.collections.LineCollection.set_segments#1362",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.LineCollection",
        "signature": "lib.matplotlib.collections.LineCollection.set_segments(self, segments)",
        "snippet": "    def set_segments(self, segments):\n        if segments is None:\n            return\n        _segments = []\n\n        for seg in segments:\n            if not isinstance(seg, np.ma.MaskedArray):\n                seg = np.asarray(seg, float)\n            _segments.append(seg)\n\n        if self._uniform_offsets is not None:\n            _segments = self._add_offsets(_segments)\n\n        self._paths = [mpath.Path(_seg) for _seg in _segments]\n        self.stale = True",
        "begin_line": 1362,
        "end_line": 1376,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002332089552238806,
            "pseudo_dstar_susp": 0.0002898550724637681,
            "pseudo_tarantula_susp": 0.0003450655624568668,
            "pseudo_op2_susp": 0.0002898550724637681,
            "pseudo_barinel_susp": 0.00034494653328734045
        }
    },
    {
        "name": "lib.matplotlib.collections.LineCollection.get_segments#1381",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.LineCollection",
        "signature": "lib.matplotlib.collections.LineCollection.get_segments(self)",
        "snippet": "    def get_segments(self):\n        \"\"\"\n        Returns\n        -------\n        segments : list\n            List of segments in the LineCollection. Each list item contains an\n            array of vertices.\n        \"\"\"\n        segments = []\n\n        for path in self._paths:\n            vertices = [vertex for vertex, _ in path.iter_segments()]\n            vertices = np.asarray(vertices)\n            segments.append(vertices)\n\n        return segments",
        "begin_line": 1381,
        "end_line": 1396,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023618327822390176,
            "pseudo_dstar_susp": 0.0002018978396931153,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0002018978396931153,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.collections.LineCollection.set_color#1411",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.LineCollection",
        "signature": "lib.matplotlib.collections.LineCollection.set_color(self, c)",
        "snippet": "    def set_color(self, c):\n        \"\"\"\n        Set the color(s) of the LineCollection.\n\n        Parameters\n        ----------\n        c : color or list of colors\n            Matplotlib color argument (all patches have same color), or a\n            sequence or rgba tuples; if it is a sequence the patches will\n            cycle through the sequence.\n        \"\"\"\n        self.set_edgecolor(c)\n        self.stale = True",
        "begin_line": 1411,
        "end_line": 1423,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019179133103183735,
            "pseudo_dstar_susp": 0.00022466861379465288,
            "pseudo_tarantula_susp": 0.0003696857670979667,
            "pseudo_op2_susp": 0.00022466861379465288,
            "pseudo_barinel_susp": 0.0003696857670979667
        }
    },
    {
        "name": "lib.matplotlib.collections.LineCollection.get_color#1425",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.LineCollection",
        "signature": "lib.matplotlib.collections.LineCollection.get_color(self)",
        "snippet": "    def get_color(self):\n        return self._edgecolors",
        "begin_line": 1425,
        "end_line": 1426,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.__init__#1442",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.__init__(self, positions, orientation=None, lineoffset=0, linelength=1, linewidth=None, color=None, linestyle='solid', antialiased=None, **kwargs)",
        "snippet": "    def __init__(self,\n                 positions,     # Cannot be None.\n                 orientation=None,\n                 lineoffset=0,\n                 linelength=1,\n                 linewidth=None,\n                 color=None,\n                 linestyle='solid',\n                 antialiased=None,\n                 **kwargs\n                 ):\n        \"\"\"\n        Parameters\n        ----------\n        positions : 1D array-like object\n            Each value is an event.\n\n        orientation : {None, 'horizontal', 'vertical'}, optional\n            The orientation of the **collection** (the event bars are along\n            the orthogonal direction). Defaults to 'horizontal' if not\n            specified or None.\n\n        lineoffset : scalar, optional, default: 0\n            The offset of the center of the markers from the origin, in the\n            direction orthogonal to *orientation*.\n\n        linelength : scalar, optional, default: 1\n            The total height of the marker (i.e. the marker stretches from\n            ``lineoffset - linelength/2`` to ``lineoffset + linelength/2``).\n\n        linewidth : scalar or None, optional, default: None\n            If it is None, defaults to its rcParams setting, in sequence form.\n\n        color : color, sequence of colors or None, optional, default: None\n            If it is None, defaults to its rcParams setting, in sequence form.\n\n        linestyle : str or tuple, optional, default: 'solid'\n            Valid strings are ['solid', 'dashed', 'dashdot', 'dotted',\n            '-', '--', '-.', ':']. Dash tuples should be of the form::\n\n                (offset, onoffseq),\n\n            where *onoffseq* is an even length tuple of on and off ink\n            in points.\n\n        antialiased : {None, 1, 2}, optional\n            If it is None, defaults to its rcParams setting, in sequence form.\n\n        **kwargs : optional\n            Other keyword arguments are line collection properties.  See\n            :class:`~matplotlib.collections.LineCollection` for a list of\n            the valid properties.\n\n        Examples\n        --------\n        .. plot:: gallery/lines_bars_and_markers/eventcollection_demo.py\n        \"\"\"\n        if positions is None:\n            raise ValueError('positions must be an array-like object')\n        # Force a copy of positions\n        positions = np.array(positions, copy=True)\n        segment = (lineoffset + linelength / 2.,\n                   lineoffset - linelength / 2.)\n        if positions.size == 0:\n            segments = []\n        elif positions.ndim > 1:\n            raise ValueError('positions cannot be an array with more than '\n                             'one dimension.')\n        elif (orientation is None or orientation.lower() == 'none' or\n              orientation.lower() == 'horizontal'):\n            positions.sort()\n            segments = [[(coord1, coord2) for coord2 in segment] for\n                        coord1 in positions]\n            self._is_horizontal = True\n        elif orientation.lower() == 'vertical':\n            positions.sort()\n            segments = [[(coord2, coord1) for coord2 in segment] for\n                        coord1 in positions]\n            self._is_horizontal = False\n        else:\n            cbook._check_in_list(['horizontal', 'vertical'],\n                                 orientation=orientation)\n\n        LineCollection.__init__(self,\n                                segments,\n                                linewidths=linewidth,\n                                colors=color,\n                                antialiaseds=antialiased,\n                                linestyles=linestyle,\n                                **kwargs)\n\n        self._linelength = linelength\n        self._lineoffset = lineoffset",
        "begin_line": 1442,
        "end_line": 1534,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002305209774089442,
            "pseudo_dstar_susp": 0.00021791239921551536,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00021791239921551536,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.get_positions#1536",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.get_positions(self)",
        "snippet": "    def get_positions(self):\n        '''\n        return an array containing the floating-point values of the positions\n        '''\n        pos = 0 if self.is_horizontal() else 1\n        return [segment[0, pos] for segment in self.get_segments()]",
        "begin_line": 1536,
        "end_line": 1541,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002133560913164071,
            "pseudo_dstar_susp": 0.0001808972503617945,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0001808972503617945,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.set_positions#1543",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.set_positions(self, positions)",
        "snippet": "    def set_positions(self, positions):\n        '''\n        set the positions of the events to the specified value\n        '''\n        if positions is None or (hasattr(positions, 'len') and\n                                 len(positions) == 0):\n            self.set_segments([])\n            return\n\n        lineoffset = self.get_lineoffset()\n        linelength = self.get_linelength()\n        segment = (lineoffset + linelength / 2.,\n                   lineoffset - linelength / 2.)\n        positions = np.asanyarray(positions)\n        positions.sort()\n        if self.is_horizontal():\n            segments = [[(coord1, coord2) for coord2 in segment] for\n                        coord1 in positions]\n        else:\n            segments = [[(coord2, coord1) for coord2 in segment] for\n                        coord1 in positions]\n        self.set_segments(segments)",
        "begin_line": 1543,
        "end_line": 1564,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019916351324437363,
            "pseudo_dstar_susp": 0.00016353229762878168,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00016353229762878168,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.add_positions#1566",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.add_positions(self, position)",
        "snippet": "    def add_positions(self, position):\n        '''\n        add one or more events at the specified positions\n        '''\n        if position is None or (hasattr(position, 'len') and\n                                len(position) == 0):\n            return\n        positions = self.get_positions()\n        positions = np.hstack([positions, np.asanyarray(position)])\n        self.set_positions(positions)",
        "begin_line": 1566,
        "end_line": 1575,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018846588767433095,
            "pseudo_dstar_susp": 0.0001541782300339192,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0001541782300339192,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.is_horizontal#1578",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.is_horizontal(self)",
        "snippet": "    def is_horizontal(self):\n        '''\n        True if the eventcollection is horizontal, False if vertical\n        '''\n        return self._is_horizontal",
        "begin_line": 1578,
        "end_line": 1582,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022163120567375886,
            "pseudo_dstar_susp": 0.00019650225977598743,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00019650225977598743,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.get_orientation#1584",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.get_orientation(self)",
        "snippet": "    def get_orientation(self):\n        \"\"\"\n        Return the orientation of the event line ('horizontal' or 'vertical').\n        \"\"\"\n        return 'horizontal' if self.is_horizontal() else 'vertical'",
        "begin_line": 1584,
        "end_line": 1588,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.switch_orientation#1590",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.switch_orientation(self)",
        "snippet": "    def switch_orientation(self):\n        '''\n        switch the orientation of the event line, either from vertical to\n        horizontal or vice versus\n        '''\n        segments = self.get_segments()\n        for i, segment in enumerate(segments):\n            segments[i] = np.fliplr(segment)\n        self.set_segments(segments)\n        self._is_horizontal = not self.is_horizontal()\n        self.stale = True",
        "begin_line": 1590,
        "end_line": 1600,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018846588767433095,
            "pseudo_dstar_susp": 0.0001541782300339192,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0001541782300339192,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.set_orientation#1602",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.set_orientation(self, orientation=None)",
        "snippet": "    def set_orientation(self, orientation=None):\n        \"\"\"\n        Set the orientation of the event line.\n\n        Parameters\n        ----------\n        orientation: {'horizontal', 'vertical'} or None\n            Defaults to 'horizontal' if not specified or None.\n        \"\"\"\n        if (orientation is None or orientation.lower() == 'none' or\n                orientation.lower() == 'horizontal'):\n            is_horizontal = True\n        elif orientation.lower() == 'vertical':\n            is_horizontal = False\n        else:\n            cbook._check_in_list(['horizontal', 'vertical'],\n                                 orientation=orientation)\n        if is_horizontal == self.is_horizontal():\n            return\n        self.switch_orientation()",
        "begin_line": 1602,
        "end_line": 1621,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.get_linelength#1623",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.get_linelength(self)",
        "snippet": "    def get_linelength(self):\n        '''\n        get the length of the lines used to mark each event\n        '''\n        return self._linelength",
        "begin_line": 1623,
        "end_line": 1627,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002133560913164071,
            "pseudo_dstar_susp": 0.0001808972503617945,
            "pseudo_tarantula_susp": 0.0003992015968063872,
            "pseudo_op2_susp": 0.0001808972503617945,
            "pseudo_barinel_susp": 0.0003990422984836393
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.set_linelength#1629",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.set_linelength(self, linelength)",
        "snippet": "    def set_linelength(self, linelength):\n        '''\n        set the length of the lines used to mark each event\n        '''\n        if linelength == self.get_linelength():\n            return\n        lineoffset = self.get_lineoffset()\n        segments = self.get_segments()\n        pos = 1 if self.is_horizontal() else 0\n        for segment in segments:\n            segment[0, pos] = lineoffset + linelength / 2.\n            segment[1, pos] = lineoffset - linelength / 2.\n        self.set_segments(segments)\n        self._linelength = linelength",
        "begin_line": 1629,
        "end_line": 1642,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.set_lineoffset#1650",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.set_lineoffset(self, lineoffset)",
        "snippet": "    def set_lineoffset(self, lineoffset):\n        '''\n        set the offset of the lines used to mark each event\n        '''\n        if lineoffset == self.get_lineoffset():\n            return\n        linelength = self.get_linelength()\n        segments = self.get_segments()\n        pos = 1 if self.is_horizontal() else 0\n        for segment in segments:\n            segment[0, pos] = lineoffset + linelength / 2.\n            segment[1, pos] = lineoffset - linelength / 2.\n        self.set_segments(segments)\n        self._lineoffset = lineoffset",
        "begin_line": 1650,
        "end_line": 1663,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.get_linewidth#1665",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.get_linewidth(self)",
        "snippet": "    def get_linewidth(self):\n        \"\"\"Get the width of the lines used to mark each event.\"\"\"\n        return super(EventCollection, self).get_linewidth()[0]",
        "begin_line": 1665,
        "end_line": 1667,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.collections.EllipseCollection.__init__#1702",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EllipseCollection",
        "signature": "lib.matplotlib.collections.EllipseCollection.__init__(self, widths, heights, angles, units='points', **kwargs)",
        "snippet": "    def __init__(self, widths, heights, angles, units='points', **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        widths : array-like\n            The lengths of the first axes (e.g., major axis lengths).\n\n        heights : array-like\n            The lengths of second axes.\n\n        angles : array-like\n            The angles of the first axes, degrees CCW from the x-axis.\n\n        units : {'points', 'inches', 'dots', 'width', 'height', 'x', 'y', 'xy'}\n\n            The units in which majors and minors are given; 'width' and\n            'height' refer to the dimensions of the axes, while 'x'\n            and 'y' refer to the *offsets* data units. 'xy' differs\n            from all others in that the angle as plotted varies with\n            the aspect ratio, and equals the specified angle only when\n            the aspect ratio is unity.  Hence it behaves the same as\n            the :class:`~matplotlib.patches.Ellipse` with\n            ``axes.transData`` as its transform.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Additional kwargs inherited from the base :class:`Collection`.\n\n        %(Collection)s\n        \"\"\"\n        Collection.__init__(self, **kwargs)\n        self._widths = 0.5 * np.asarray(widths).ravel()\n        self._heights = 0.5 * np.asarray(heights).ravel()\n        self._angles = np.deg2rad(angles).ravel()\n        self._units = units\n        self.set_transform(transforms.IdentityTransform())\n        self._transforms = np.empty((0, 3, 3))\n        self._paths = [mpath.Path.unit_circle()]",
        "begin_line": 1702,
        "end_line": 1740,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.collections.EllipseCollection._set_transforms#1742",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EllipseCollection",
        "signature": "lib.matplotlib.collections.EllipseCollection._set_transforms(self)",
        "snippet": "    def _set_transforms(self):\n        \"\"\"Calculate transforms immediately before drawing.\"\"\"\n\n        ax = self.axes\n        fig = self.figure\n\n        if self._units == 'xy':\n            sc = 1\n        elif self._units == 'x':\n            sc = ax.bbox.width / ax.viewLim.width\n        elif self._units == 'y':\n            sc = ax.bbox.height / ax.viewLim.height\n        elif self._units == 'inches':\n            sc = fig.dpi\n        elif self._units == 'points':\n            sc = fig.dpi / 72.0\n        elif self._units == 'width':\n            sc = ax.bbox.width\n        elif self._units == 'height':\n            sc = ax.bbox.height\n        elif self._units == 'dots':\n            sc = 1.0\n        else:\n            raise ValueError('unrecognized units: %s' % self._units)\n\n        self._transforms = np.zeros((len(self._widths), 3, 3))\n        widths = self._widths * sc\n        heights = self._heights * sc\n        sin_angle = np.sin(self._angles)\n        cos_angle = np.cos(self._angles)\n        self._transforms[:, 0, 0] = widths * cos_angle\n        self._transforms[:, 0, 1] = heights * -sin_angle\n        self._transforms[:, 1, 0] = widths * sin_angle\n        self._transforms[:, 1, 1] = heights * cos_angle\n        self._transforms[:, 2, 2] = 1.0\n\n        _affine = transforms.Affine2D\n        if self._units == 'xy':\n            m = ax.transData.get_affine().get_matrix().copy()\n            m[:2, 2:] = 0\n            self.set_transform(_affine(m))",
        "begin_line": 1742,
        "end_line": 1782,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.collections.EllipseCollection.draw#1785",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EllipseCollection",
        "signature": "lib.matplotlib.collections.EllipseCollection.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        self._set_transforms()\n        Collection.draw(self, renderer)",
        "begin_line": 1785,
        "end_line": 1787,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.collections.PatchCollection.__init__#1801",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.PatchCollection",
        "signature": "lib.matplotlib.collections.PatchCollection.__init__(self, patches, match_original=False, **kwargs)",
        "snippet": "    def __init__(self, patches, match_original=False, **kwargs):\n        \"\"\"\n        *patches*\n            a sequence of Patch objects.  This list may include\n            a heterogeneous assortment of different patch types.\n\n        *match_original*\n            If True, use the colors and linewidths of the original\n            patches.  If False, new colors may be assigned by\n            providing the standard collection arguments, facecolor,\n            edgecolor, linewidths, norm or cmap.\n\n        If any of *edgecolors*, *facecolors*, *linewidths*,\n        *antialiaseds* are None, they default to their\n        :data:`matplotlib.rcParams` patch setting, in sequence form.\n\n        The use of :class:`~matplotlib.cm.ScalarMappable` is optional.\n        If the :class:`~matplotlib.cm.ScalarMappable` matrix _A is not\n        None (i.e., a call to set_array has been made), at draw time a\n        call to scalar mappable will be made to set the face colors.\n        \"\"\"\n\n        if match_original:\n            def determine_facecolor(patch):\n                if patch.get_fill():\n                    return patch.get_facecolor()\n                return [0, 0, 0, 0]\n\n            kwargs['facecolors'] = [determine_facecolor(p) for p in patches]\n            kwargs['edgecolors'] = [p.get_edgecolor() for p in patches]\n            kwargs['linewidths'] = [p.get_linewidth() for p in patches]\n            kwargs['linestyles'] = [p.get_linestyle() for p in patches]\n            kwargs['antialiaseds'] = [p.get_antialiased() for p in patches]\n\n        Collection.__init__(self, **kwargs)\n\n        self.set_paths(patches)",
        "begin_line": 1801,
        "end_line": 1837,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012454851164528583,
            "pseudo_dstar_susp": 0.00011988970147464332,
            "pseudo_tarantula_susp": 0.00017415534656913968,
            "pseudo_op2_susp": 0.00011988970147464332,
            "pseudo_barinel_susp": 0.0001742767514813524
        }
    },
    {
        "name": "lib.matplotlib.collections.PatchCollection.set_paths#1839",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.PatchCollection",
        "signature": "lib.matplotlib.collections.PatchCollection.set_paths(self, patches)",
        "snippet": "    def set_paths(self, patches):\n        paths = [p.get_transform().transform_path(p.get_path())\n                 for p in patches]\n        self._paths = paths",
        "begin_line": 1839,
        "end_line": 1842,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012454851164528583,
            "pseudo_dstar_susp": 0.00011988970147464332,
            "pseudo_tarantula_susp": 0.00017415534656913968,
            "pseudo_op2_susp": 0.00011988970147464332,
            "pseudo_barinel_susp": 0.0001742767514813524
        }
    },
    {
        "name": "lib.matplotlib.collections.QuadMesh.__init__#1940",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.QuadMesh",
        "signature": "lib.matplotlib.collections.QuadMesh.__init__(self, meshWidth, meshHeight, coordinates, antialiased=True, shading='flat', **kwargs)",
        "snippet": "    def __init__(self, meshWidth, meshHeight, coordinates,\n                 antialiased=True, shading='flat', **kwargs):\n        Collection.__init__(self, **kwargs)\n        self._meshWidth = meshWidth\n        self._meshHeight = meshHeight\n        # By converting to floats now, we can avoid that on every draw.\n        self._coordinates = np.asarray(coordinates, float).reshape(\n            (meshHeight + 1, meshWidth + 1, 2))\n        self._antialiased = antialiased\n        self._shading = shading\n\n        self._bbox = transforms.Bbox.unit()\n        self._bbox.update_from_data_xy(coordinates.reshape(\n            ((meshWidth + 1) * (meshHeight + 1), 2)))",
        "begin_line": 1940,
        "end_line": 1953,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019916351324437363,
            "pseudo_dstar_susp": 0.00021987686895338611,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00021987686895338611,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.collections.QuadMesh.convert_mesh_to_paths#1969",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.QuadMesh",
        "signature": "lib.matplotlib.collections.QuadMesh.convert_mesh_to_paths(meshWidth, meshHeight, coordinates)",
        "snippet": "    def convert_mesh_to_paths(meshWidth, meshHeight, coordinates):\n        \"\"\"\n        Converts a given mesh into a sequence of `~.Path` objects.\n\n        This function is primarily of use to implementers of backends that do\n        not directly support quadmeshes.\n        \"\"\"\n        if isinstance(coordinates, np.ma.MaskedArray):\n            c = coordinates.data\n        else:\n            c = coordinates\n        points = np.concatenate((\n                    c[:-1, :-1],\n                    c[:-1, 1:],\n                    c[1:, 1:],\n                    c[1:, :-1],\n                    c[:-1, :-1]\n                ), axis=2)\n        points = points.reshape((meshWidth * meshHeight, 5, 2))\n        return [mpath.Path(x) for x in points]",
        "begin_line": 1969,
        "end_line": 1988,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.collections.QuadMesh.convert_mesh_to_triangles#1990",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.QuadMesh",
        "signature": "lib.matplotlib.collections.QuadMesh.convert_mesh_to_triangles(self, meshWidth, meshHeight, coordinates)",
        "snippet": "    def convert_mesh_to_triangles(self, meshWidth, meshHeight, coordinates):\n        \"\"\"\n        Converts a given mesh into a sequence of triangles, each point\n        with its own color.  This is useful for experiments using\n        `draw_gouraud_triangle`.\n        \"\"\"\n        if isinstance(coordinates, np.ma.MaskedArray):\n            p = coordinates.data\n        else:\n            p = coordinates\n\n        p_a = p[:-1, :-1]\n        p_b = p[:-1, 1:]\n        p_c = p[1:, 1:]\n        p_d = p[1:, :-1]\n        p_center = (p_a + p_b + p_c + p_d) / 4.0\n\n        triangles = np.concatenate((\n                p_a, p_b, p_center,\n                p_b, p_c, p_center,\n                p_c, p_d, p_center,\n                p_d, p_a, p_center,\n            ), axis=2)\n        triangles = triangles.reshape((meshWidth * meshHeight * 4, 3, 2))\n\n        c = self.get_facecolor().reshape((meshHeight + 1, meshWidth + 1, 4))\n        c_a = c[:-1, :-1]\n        c_b = c[:-1, 1:]\n        c_c = c[1:, 1:]\n        c_d = c[1:, :-1]\n        c_center = (c_a + c_b + c_c + c_d) / 4.0\n\n        colors = np.concatenate((\n                        c_a, c_b, c_center,\n                        c_b, c_c, c_center,\n                        c_c, c_d, c_center,\n                        c_d, c_a, c_center,\n                    ), axis=2)\n        colors = colors.reshape((meshWidth * meshHeight * 4, 3, 4))\n\n        return triangles, colors",
        "begin_line": 1990,
        "end_line": 2030,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.collections.QuadMesh.draw#2033",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.QuadMesh",
        "signature": "lib.matplotlib.collections.QuadMesh.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        if not self.get_visible():\n            return\n        renderer.open_group(self.__class__.__name__, self.get_gid())\n        transform = self.get_transform()\n        transOffset = self.get_offset_transform()\n        offsets = self._offsets\n\n        if self.have_units():\n            if len(self._offsets):\n                xs = self.convert_xunits(self._offsets[:, 0])\n                ys = self.convert_yunits(self._offsets[:, 1])\n                offsets = np.column_stack([xs, ys])\n\n        self.update_scalarmappable()\n\n        if not transform.is_affine:\n            coordinates = self._coordinates.reshape((-1, 2))\n            coordinates = transform.transform(coordinates)\n            coordinates = coordinates.reshape(self._coordinates.shape)\n            transform = transforms.IdentityTransform()\n        else:\n            coordinates = self._coordinates\n\n        if not transOffset.is_affine:\n            offsets = transOffset.transform_non_affine(offsets)\n            transOffset = transOffset.get_affine()\n\n        gc = renderer.new_gc()\n        self._set_gc_clip(gc)\n        gc.set_linewidth(self.get_linewidth()[0])\n\n        if self._shading == 'gouraud':\n            triangles, colors = self.convert_mesh_to_triangles(\n                self._meshWidth, self._meshHeight, coordinates)\n            renderer.draw_gouraud_triangles(\n                gc, triangles, colors, transform.frozen())\n        else:\n            renderer.draw_quad_mesh(\n                gc, transform.frozen(), self._meshWidth, self._meshHeight,\n                coordinates, offsets, transOffset, self.get_facecolor(),\n                self._antialiased, self.get_edgecolors())\n        gc.restore()\n        renderer.close_group(self.__class__.__name__)\n        self.stale = False",
        "begin_line": 2033,
        "end_line": 2077,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023126734505087883,
            "pseudo_dstar_susp": 0.0002295684113865932,
            "pseudo_tarantula_susp": 0.0002644802962179318,
            "pseudo_op2_susp": 0.0002295684113865932,
            "pseudo_barinel_susp": 0.0002644802962179318
        }
    },
    {
        "name": "lib.matplotlib.testing.conftest.mpl_test_settings#33",
        "src_path": "lib/matplotlib/testing/conftest.py",
        "class_name": "lib.matplotlib.testing.conftest",
        "signature": "lib.matplotlib.testing.conftest.mpl_test_settings(request)",
        "snippet": "def mpl_test_settings(request):\n    from matplotlib.testing.decorators import _cleanup_cm\n\n    with _cleanup_cm():\n\n        backend = None\n        backend_marker = request.node.get_closest_marker('backend')\n        if backend_marker is not None:\n            assert len(backend_marker.args) == 1, \\\n                \"Marker 'backend' must specify 1 backend.\"\n            backend, = backend_marker.args\n            skip_on_importerror = backend_marker.kwargs.get(\n                'skip_on_importerror', False)\n            prev_backend = matplotlib.get_backend()\n\n        # Default of cleanup and image_comparison too.\n        style = [\"classic\", \"_classic_test_patch\"]\n        style_marker = request.node.get_closest_marker('style')\n        if style_marker is not None:\n            assert len(style_marker.args) == 1, \\\n                \"Marker 'style' must specify 1 style.\"\n            style, = style_marker.args\n\n        matplotlib.testing.setup()\n        if backend is not None:\n            # This import must come after setup() so it doesn't load the\n            # default backend prematurely.\n            import matplotlib.pyplot as plt\n            try:\n                plt.switch_backend(backend)\n            except ImportError as exc:\n                # Should only occur for the cairo backend tests, if neither\n                # pycairo nor cairocffi are installed.\n                if 'cairo' in backend.lower() or skip_on_importerror:\n                    pytest.skip(\"Failed to switch to backend {} ({}).\"\n                                .format(backend, exc))\n                else:\n                    raise\n        with cbook._suppress_matplotlib_deprecation_warning():\n            matplotlib.style.use(style)\n        try:\n            yield\n        finally:\n            if backend is not None:\n                plt.switch_backend(prev_backend)",
        "begin_line": 33,
        "end_line": 77,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.022222222222222223,
            "pseudo_dstar_susp": 0.5,
            "pseudo_tarantula_susp": 0.0002627430373095113,
            "pseudo_op2_susp": 0.5,
            "pseudo_barinel_susp": 0.0002627430373095113
        }
    },
    {
        "name": "lib.matplotlib.testing.conftest.mpl_image_comparison_parameters#81",
        "src_path": "lib/matplotlib/testing/conftest.py",
        "class_name": "lib.matplotlib.testing.conftest",
        "signature": "lib.matplotlib.testing.conftest.mpl_image_comparison_parameters(request, extension)",
        "snippet": "def mpl_image_comparison_parameters(request, extension):\n    # This fixture is applied automatically by the image_comparison decorator.\n    #\n    # The sole purpose of this fixture is to provide an indirect method of\n    # obtaining parameters *without* modifying the decorated function\n    # signature. In this way, the function signature can stay the same and\n    # pytest won't get confused.\n    # We annotate the decorated function with any parameters captured by this\n    # fixture so that they can be used by the wrapper in image_comparison.\n    baseline_images, = request.node.get_closest_marker('baseline_images').args\n    if baseline_images is None:\n        # Allow baseline image list to be produced on the fly based on current\n        # parametrization.\n        baseline_images = request.getfixturevalue('baseline_images')\n\n    func = request.function\n    with cbook._setattr_cm(func.__wrapped__,\n                           parameters=(baseline_images, extension)):\n        yield",
        "begin_line": 81,
        "end_line": 99,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.06666666666666667,
            "pseudo_dstar_susp": 0.037037037037037035,
            "pseudo_tarantula_susp": 0.0004803073967339097,
            "pseudo_op2_susp": 0.03571428571428571,
            "pseudo_barinel_susp": 0.0004803073967339097
        }
    },
    {
        "name": "lib.matplotlib.testing.conftest.pd#103",
        "src_path": "lib/matplotlib/testing/conftest.py",
        "class_name": "lib.matplotlib.testing.conftest",
        "signature": "lib.matplotlib.testing.conftest.pd()",
        "snippet": "def pd():\n    \"\"\"Fixture to import and configure pandas.\"\"\"\n    pd = pytest.importorskip('pandas')\n    try:\n        from pandas.plotting import (\n            deregister_matplotlib_converters as deregister)\n        deregister()\n    except ImportError:\n        pass\n    return pd",
        "begin_line": 103,
        "end_line": 112,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.testing.compare.crop_to_same#299",
        "src_path": "lib/matplotlib/testing/compare.py",
        "class_name": "lib.matplotlib.testing.compare",
        "signature": "lib.matplotlib.testing.compare.crop_to_same(actual_path, actual_image, expected_path, expected_image)",
        "snippet": "def crop_to_same(actual_path, actual_image, expected_path, expected_image):\n    # clip the images to the same size -- this is useful only when\n    # comparing eps to pdf\n    if actual_path[-7:-4] == 'eps' and expected_path[-7:-4] == 'pdf':\n        aw, ah, ad = actual_image.shape\n        ew, eh, ed = expected_image.shape\n        actual_image = actual_image[int(aw / 2 - ew / 2):int(\n            aw / 2 + ew / 2), int(ah / 2 - eh / 2):int(ah / 2 + eh / 2)]\n    return actual_image, expected_image",
        "begin_line": 299,
        "end_line": 307,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019179133103183735,
            "pseudo_dstar_susp": 0.00016220600162206002,
            "pseudo_tarantula_susp": 0.0003696857670979667,
            "pseudo_op2_susp": 0.00016220600162206002,
            "pseudo_barinel_susp": 0.0003696857670979667
        }
    },
    {
        "name": "lib.matplotlib.testing.compare.calculate_rms#310",
        "src_path": "lib/matplotlib/testing/compare.py",
        "class_name": "lib.matplotlib.testing.compare",
        "signature": "lib.matplotlib.testing.compare.calculate_rms(expected_image, actual_image)",
        "snippet": "def calculate_rms(expected_image, actual_image):\n    \"Calculate the per-pixel errors, then compute the root mean square error.\"\n    if expected_image.shape != actual_image.shape:\n        raise ImageComparisonFailure(\n            \"Image sizes do not match expected size: {} \"\n            \"actual size {}\".format(expected_image.shape, actual_image.shape))\n    # Convert to float to avoid overflowing finite integer types.\n    return np.sqrt(((expected_image - actual_image).astype(float) ** 2).mean())",
        "begin_line": 310,
        "end_line": 317,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.testing.compare.compare_images#320",
        "src_path": "lib/matplotlib/testing/compare.py",
        "class_name": "lib.matplotlib.testing.compare",
        "signature": "lib.matplotlib.testing.compare.compare_images(expected, actual, tol, in_decorator=False)",
        "snippet": "def compare_images(expected, actual, tol, in_decorator=False):\n    \"\"\"\n    Compare two \"image\" files checking differences within a tolerance.\n\n    The two given filenames may point to files which are convertible to\n    PNG via the `.converter` dictionary. The underlying RMS is calculated\n    with the `.calculate_rms` function.\n\n    Parameters\n    ----------\n    expected : str\n        The filename of the expected image.\n    actual : str\n        The filename of the actual image.\n    tol : float\n        The tolerance (a color value difference, where 255 is the\n        maximal difference).  The test fails if the average pixel\n        difference is greater than this value.\n    in_decorator : bool\n        Determines the output format. If called from image_comparison\n        decorator, this should be True. (default=False)\n\n    Returns\n    -------\n    comparison_result : None or dict or str\n        Return *None* if the images are equal within the given tolerance.\n\n        If the images differ, the return value depends on  *in_decorator*.\n        If *in_decorator* is true, a dict with the following entries is\n        returned:\n\n        - *rms*: The RMS of the image difference.\n        - *expected*: The filename of the expected image.\n        - *actual*: The filename of the actual image.\n        - *diff_image*: The filename of the difference image.\n        - *tol*: The comparison tolerance.\n\n        Otherwise, a human-readable multi-line string representation of this\n        information is returned.\n\n    Examples\n    --------\n    ::\n\n        img1 = \"./baseline/plot.png\"\n        img2 = \"./output/plot.png\"\n        compare_images(img1, img2, 0.001)\n\n    \"\"\"\n    from matplotlib import _png\n\n    actual = os.fspath(actual)\n    if not os.path.exists(actual):\n        raise Exception(\"Output image %s does not exist.\" % actual)\n    if os.stat(actual).st_size == 0:\n        raise Exception(\"Output image file %s is empty.\" % actual)\n\n    # Convert the image to png\n    expected = os.fspath(expected)\n    if not os.path.exists(expected):\n        raise IOError('Baseline image %r does not exist.' % expected)\n    extension = expected.split('.')[-1]\n    if extension != 'png':\n        actual = convert(actual, False)\n        expected = convert(expected, True)\n\n    # open the image files and remove the alpha channel (if it exists)\n    with open(expected, \"rb\") as expected_file:\n        expected_image = _png.read_png_int(expected_file)[:, :, :3]\n    with open(actual, \"rb\") as actual_file:\n        actual_image = _png.read_png_int(actual_file)[:, :, :3]\n\n    actual_image, expected_image = crop_to_same(\n        actual, actual_image, expected, expected_image)\n\n    diff_image = make_test_filename(actual, 'failed-diff')\n\n    if tol <= 0:\n        if np.array_equal(expected_image, actual_image):\n            return None\n\n    # convert to signed integers, so that the images can be subtracted without\n    # overflow\n    expected_image = expected_image.astype(np.int16)\n    actual_image = actual_image.astype(np.int16)\n\n    rms = calculate_rms(expected_image, actual_image)\n\n    if rms <= tol:\n        return None\n\n    save_diff_image(expected, actual, diff_image)\n\n    results = dict(rms=rms, expected=str(expected),\n                   actual=str(actual), diff=str(diff_image), tol=tol)\n\n    if not in_decorator:\n        # Then the results should be a string suitable for stdout.\n        template = ['Error: Image files did not match.',\n                    'RMS Value: {rms}',\n                    'Expected:  \\n    {expected}',\n                    'Actual:    \\n    {actual}',\n                    'Difference:\\n    {diff}',\n                    'Tolerance: \\n    {tol}', ]\n        results = '\\n  '.join([line.format(**results) for line in template])\n    return results",
        "begin_line": 320,
        "end_line": 425,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005405405405405406,
            "pseudo_dstar_susp": 0.001876172607879925,
            "pseudo_tarantula_susp": 0.0006435006435006435,
            "pseudo_op2_susp": 0.001876172607879925,
            "pseudo_barinel_susp": 0.0006435006435006435
        }
    },
    {
        "name": "lib.matplotlib.testing.compare.save_diff_image#428",
        "src_path": "lib/matplotlib/testing/compare.py",
        "class_name": "lib.matplotlib.testing.compare",
        "signature": "lib.matplotlib.testing.compare.save_diff_image(expected, actual, output)",
        "snippet": "def save_diff_image(expected, actual, output):\n    '''\n    Parameters\n    ----------\n    expected : str\n        File path of expected image.\n    actual : str\n        File path of actual image.\n    output : str\n        File path to save difference image to.\n    '''\n    # Drop alpha channels, similarly to compare_images.\n    from matplotlib import _png\n    with open(expected, \"rb\") as expected_file:\n        expected_image = _png.read_png(expected_file)[..., :3]\n    with open(actual, \"rb\") as actual_file:\n        actual_image = _png.read_png(actual_file)[..., :3]\n    actual_image, expected_image = crop_to_same(\n        actual, actual_image, expected, expected_image)\n    expected_image = np.array(expected_image).astype(float)\n    actual_image = np.array(actual_image).astype(float)\n    if expected_image.shape != actual_image.shape:\n        raise ImageComparisonFailure(\n            \"Image sizes do not match expected size: {} \"\n            \"actual size {}\".format(expected_image.shape, actual_image.shape))\n    abs_diff_image = np.abs(expected_image - actual_image)\n\n    # expand differences in luminance domain\n    abs_diff_image *= 255 * 10\n    save_image_np = np.clip(abs_diff_image, 0, 255).astype(np.uint8)\n    height, width, depth = save_image_np.shape\n\n    # The PDF renderer doesn't produce an alpha channel, but the\n    # matplotlib PNG writer requires one, so expand the array\n    if depth == 3:\n        with_alpha = np.empty((height, width, 4), dtype=np.uint8)\n        with_alpha[:, :, 0:3] = save_image_np\n        save_image_np = with_alpha\n\n    # Hard-code the alpha channel to fully solid\n    save_image_np[:, :, 3] = 255\n\n    with open(output, \"wb\") as output_file:\n        _png.write_png(save_image_np, output_file)",
        "begin_line": 428,
        "end_line": 471,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005128205128205128,
            "pseudo_dstar_susp": 0.001447178002894356,
            "pseudo_tarantula_susp": 0.0006435006435006435,
            "pseudo_op2_susp": 0.001447178002894356,
            "pseudo_barinel_susp": 0.0006435006435006435
        }
    },
    {
        "name": "lib.matplotlib.style.core._remove_blacklisted_style_params#44",
        "src_path": "lib/matplotlib/style/core.py",
        "class_name": "lib.matplotlib.style.core",
        "signature": "lib.matplotlib.style.core._remove_blacklisted_style_params(d, warn=True)",
        "snippet": "def _remove_blacklisted_style_params(d, warn=True):\n    o = {}\n    for key, val in d.items():\n        if key in STYLE_BLACKLIST:\n            if warn:\n                cbook._warn_external(\n                    \"Style includes a parameter, '{0}', that is not related \"\n                    \"to style.  Ignoring\".format(key))\n        else:\n            o[key] = val\n    return o",
        "begin_line": 44,
        "end_line": 54,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0055248618784530384,
            "pseudo_dstar_susp": 0.006756756756756757,
            "pseudo_tarantula_susp": 0.0002260397830018083,
            "pseudo_op2_susp": 0.006756756756756757,
            "pseudo_barinel_susp": 0.0002260397830018083
        }
    },
    {
        "name": "lib.matplotlib.style.core.use#67",
        "src_path": "lib/matplotlib/style/core.py",
        "class_name": "lib.matplotlib.style.core",
        "signature": "lib.matplotlib.style.core.use(style)",
        "snippet": "def use(style):\n    \"\"\"Use matplotlib style settings from a style specification.\n\n    The style name of 'default' is reserved for reverting back to\n    the default style settings.\n\n    Parameters\n    ----------\n    style : str, dict, Path or list\n        A style specification. Valid options are:\n\n        +------+-------------------------------------------------------------+\n        | str  | The name of a style or a path/URL to a style file. For a    |\n        |      | list of available style names, see `style.available`.       |\n        +------+-------------------------------------------------------------+\n        | dict | Dictionary with valid key/value pairs for                   |\n        |      | `matplotlib.rcParams`.                                      |\n        +------+-------------------------------------------------------------+\n        | Path | A path-like object which is a path to a style file.         |\n        +------+-------------------------------------------------------------+\n        | list | A list of style specifiers (str, Path or dict) applied from |\n        |      | first to last in the list.                                  |\n        +------+-------------------------------------------------------------+\n\n    \"\"\"\n    style_alias = {'mpl20': 'default',\n                   'mpl15': 'classic'}\n    if isinstance(style, (str, Path)) or hasattr(style, 'keys'):\n        # If name is a single str, Path or dict, make it a single element list.\n        styles = [style]\n    else:\n        styles = style\n\n    styles = (style_alias.get(s, s) if isinstance(s, str) else s\n              for s in styles)\n    for style in styles:\n        if not isinstance(style, (str, Path)):\n            _apply_style(style)\n        elif style == 'default':\n            # Deprecation warnings were already handled when creating\n            # rcParamsDefault, no need to reemit them here.\n            with cbook._suppress_matplotlib_deprecation_warning():\n                _apply_style(rcParamsDefault, warn=False)\n        elif style in library:\n            _apply_style(library[style])\n        else:\n            try:\n                rc = rc_params_from_file(style, use_default_template=False)\n                _apply_style(rc)\n            except IOError:\n                raise IOError(\n                    \"{!r} not found in the style library and input is not a \"\n                    \"valid URL or path; see `style.available` for list of \"\n                    \"available styles\".format(style))",
        "begin_line": 67,
        "end_line": 120,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001081081081081081,
            "pseudo_dstar_susp": 0.00510204081632653,
            "pseudo_tarantula_susp": 0.0002151462994836489,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0002151462994836489
        }
    },
    {
        "name": "lib.matplotlib.style.core.iter_user_libraries#162",
        "src_path": "lib/matplotlib/style/core.py",
        "class_name": "lib.matplotlib.style.core",
        "signature": "lib.matplotlib.style.core.iter_user_libraries()",
        "snippet": "def iter_user_libraries():\n    for stylelib_path in USER_LIBRARY_PATHS:\n        stylelib_path = os.path.expanduser(stylelib_path)\n        if os.path.exists(stylelib_path) and os.path.isdir(stylelib_path):\n            yield stylelib_path",
        "begin_line": 162,
        "end_line": 166,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.869058860560277e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.style.core.update_user_library#169",
        "src_path": "lib/matplotlib/style/core.py",
        "class_name": "lib.matplotlib.style.core",
        "signature": "lib.matplotlib.style.core.update_user_library(library)",
        "snippet": "def update_user_library(library):\n    \"\"\"Update style library with user-defined rc files\"\"\"\n    for stylelib_path in iter_user_libraries():\n        styles = read_style_directory(stylelib_path)\n        update_nested_dict(library, styles)\n    return library",
        "begin_line": 169,
        "end_line": 174,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.893905904641616e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.style.core.read_style_directory#188",
        "src_path": "lib/matplotlib/style/core.py",
        "class_name": "lib.matplotlib.style.core",
        "signature": "lib.matplotlib.style.core.read_style_directory(style_dir)",
        "snippet": "def read_style_directory(style_dir):\n    \"\"\"Return dictionary of styles defined in *style_dir*.\"\"\"\n    styles = dict()\n    for path in Path(style_dir).glob(f\"*.{STYLE_EXTENSION}\"):\n        with warnings.catch_warnings(record=True) as warns:\n            styles[path.stem] = rc_params_from_file(\n                path, use_default_template=False)\n        for w in warns:\n            _log.warning('In %s: %s', path, w.message)\n    return styles",
        "begin_line": 188,
        "end_line": 197,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.893905904641616e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.style.core.update_nested_dict#200",
        "src_path": "lib/matplotlib/style/core.py",
        "class_name": "lib.matplotlib.style.core",
        "signature": "lib.matplotlib.style.core.update_nested_dict(main_dict, new_dict)",
        "snippet": "def update_nested_dict(main_dict, new_dict):\n    \"\"\"Update nested dict (only level of nesting) with new values.\n\n    Unlike dict.update, this assumes that the values of the parent dict are\n    dicts (or dict-like), so you shouldn't replace the nested dict if it\n    already exists. Instead you should update the sub-dict.\n    \"\"\"\n    # update named styles specified by user\n    for name, rc_dict in new_dict.items():\n        main_dict.setdefault(name, {}).update(rc_dict)\n    return main_dict",
        "begin_line": 200,
        "end_line": 210,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.869058860560277e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.style.core.reload_library#221",
        "src_path": "lib/matplotlib/style/core.py",
        "class_name": "lib.matplotlib.style.core",
        "signature": "lib.matplotlib.style.core.reload_library()",
        "snippet": "def reload_library():\n    \"\"\"Reload style library.\"\"\"\n    global library\n    library = update_user_library(_base_library)\n    available[:] = sorted(library.keys())",
        "begin_line": 221,
        "end_line": 225,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.833307222309259e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.font_manager.get_fontext_synonyms#134",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager",
        "signature": "lib.matplotlib.font_manager.get_fontext_synonyms(fontext)",
        "snippet": "def get_fontext_synonyms(fontext):\n    \"\"\"\n    Return a list of file extensions extensions that are synonyms for\n    the given file extension *fileext*.\n    \"\"\"\n    return {\n        'afm': ['afm'],\n        'otf': ['otf', 'ttc', 'ttf'],\n        'ttc': ['otf', 'ttc', 'ttf'],\n        'ttf': ['otf', 'ttc', 'ttf'],\n    }[fontext]",
        "begin_line": 134,
        "end_line": 144,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015785319652722967,
            "pseudo_dstar_susp": 0.00015179113539769278,
            "pseudo_tarantula_susp": 0.00022680880018144704,
            "pseudo_op2_susp": 0.00015179113539769278,
            "pseudo_barinel_susp": 0.00022686025408348456
        }
    },
    {
        "name": "lib.matplotlib.font_manager.list_fonts#147",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager",
        "signature": "lib.matplotlib.font_manager.list_fonts(directory, extensions)",
        "snippet": "def list_fonts(directory, extensions):\n    \"\"\"\n    Return a list of all fonts matching any of the extensions, found\n    recursively under the directory.\n    \"\"\"\n    extensions = [\".\" + ext for ext in extensions]\n    return [os.path.join(dirpath, filename)\n            # os.walk ignores access errors, unlike Path.glob.\n            for dirpath, _, filenames in os.walk(directory)\n            for filename in filenames\n            if Path(filename).suffix.lower() in extensions]",
        "begin_line": 147,
        "end_line": 157,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001380071763731714,
            "pseudo_dstar_susp": 0.00014954389113204725,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00014954389113204725,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.font_manager._call_fc_list#267",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager",
        "signature": "lib.matplotlib.font_manager._call_fc_list()",
        "snippet": "def _call_fc_list():\n    \"\"\"Cache and list the font filenames known to `fc-list`.\n    \"\"\"\n    # Delay the warning by 5s.\n    timer = Timer(5, lambda: _log.warning(\n        'Matplotlib is building the font cache using fc-list. '\n        'This may take a moment.'))\n    timer.start()\n    try:\n        if b'--format' not in subprocess.check_output(['fc-list', '--help']):\n            _log.warning(  # fontconfig 2.7 implemented --format.\n                'Matplotlib needs fontconfig>=2.7 to query system fonts.')\n            return []\n        out = subprocess.check_output(['fc-list', '--format=%{file}\\\\n'])\n    except (OSError, subprocess.CalledProcessError):\n        return []\n    finally:\n        timer.cancel()\n    return [os.fsdecode(fname) for fname in out.split(b'\\n')]",
        "begin_line": 267,
        "end_line": 285,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.font_manager.get_fontconfig_fonts#288",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager",
        "signature": "lib.matplotlib.font_manager.get_fontconfig_fonts(fontext='ttf')",
        "snippet": "def get_fontconfig_fonts(fontext='ttf'):\n    \"\"\"List the font filenames known to `fc-list` having the given extension.\n    \"\"\"\n    fontext = ['.' + ext for ext in get_fontext_synonyms(fontext)]\n    return [fname for fname in _call_fc_list()\n            if Path(fname).suffix.lower() in fontext]",
        "begin_line": 288,
        "end_line": 293,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.font_manager.findSystemFonts#296",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager",
        "signature": "lib.matplotlib.font_manager.findSystemFonts(fontpaths=None, fontext='ttf')",
        "snippet": "def findSystemFonts(fontpaths=None, fontext='ttf'):\n    \"\"\"\n    Search for fonts in the specified font paths.  If no paths are\n    given, will use a standard set of system paths, as well as the\n    list of fonts tracked by fontconfig if fontconfig is installed and\n    available.  A list of TrueType fonts are returned by default with\n    AFM fonts as an option.\n    \"\"\"\n    fontfiles = set()\n    fontexts = get_fontext_synonyms(fontext)\n\n    if fontpaths is None:\n        if sys.platform == 'win32':\n            fontpaths = MSUserFontDirectories + [win32FontDirectory()]\n            # now get all installed fonts directly...\n            fontfiles.update(win32InstalledFonts(fontext=fontext))\n        else:\n            fontpaths = X11FontDirectories\n            if sys.platform == 'darwin':\n                fontpaths = [*X11FontDirectories, *OSXFontDirectories]\n            fontfiles.update(get_fontconfig_fonts(fontext))\n\n    elif isinstance(fontpaths, str):\n        fontpaths = [fontpaths]\n\n    for path in fontpaths:\n        fontfiles.update(map(os.path.abspath, list_fonts(path, fontexts)))\n\n    return [fname for fname in fontfiles if os.path.exists(fname)]",
        "begin_line": 296,
        "end_line": 324,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontEntry.__init__#332",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontEntry",
        "signature": "lib.matplotlib.font_manager.FontEntry.__init__(self, fname='', name='', style='normal', variant='normal', weight='normal', stretch='normal', size='medium')",
        "snippet": "    def __init__(self,\n                 fname  ='',\n                 name   ='',\n                 style  ='normal',\n                 variant='normal',\n                 weight ='normal',\n                 stretch='normal',\n                 size   ='medium',\n                 ):\n        self.fname   = fname\n        self.name    = name\n        self.style   = style\n        self.variant = variant\n        self.weight  = weight\n        self.stretch = stretch\n        try:\n            self.size = str(float(size))\n        except ValueError:\n            self.size = size",
        "begin_line": 332,
        "end_line": 350,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.font_manager.afmFontProperty#441",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager",
        "signature": "lib.matplotlib.font_manager.afmFontProperty(fontpath, font)",
        "snippet": "def afmFontProperty(fontpath, font):\n    \"\"\"\n    Extract information from an AFM font file.\n\n    Parameters\n    ----------\n    font : `.AFM`\n        The AFM font file from which information will be extracted.\n\n    Returns\n    -------\n    `FontEntry`\n        The extracted font properties.\n    \"\"\"\n\n    name = font.get_familyname()\n    fontname = font.get_fontname().lower()\n\n    #  Styles are: italic, oblique, and normal (default)\n\n    if font.get_angle() != 0 or 'italic' in name.lower():\n        style = 'italic'\n    elif 'oblique' in name.lower():\n        style = 'oblique'\n    else:\n        style = 'normal'\n\n    #  Variants are: small-caps and normal (default)\n\n    # !!!!  Untested\n    if name.lower() in ['capitals', 'small-caps']:\n        variant = 'small-caps'\n    else:\n        variant = 'normal'\n\n    weight = font.get_weight().lower()\n    if weight not in weight_dict:\n        weight = 'normal'\n\n    #  Stretch can be absolute and relative\n    #  Absolute stretches are: ultra-condensed, extra-condensed, condensed,\n    #    semi-condensed, normal, semi-expanded, expanded, extra-expanded,\n    #    and ultra-expanded.\n    #  Relative stretches are: wider, narrower\n    #  Child value is: inherit\n    if 'demi cond' in fontname:\n        stretch = 'semi-condensed'\n    elif any(word in fontname for word in ['narrow', 'cond']):\n        stretch = 'condensed'\n    elif any(word in fontname for word in ['wide', 'expanded', 'extended']):\n        stretch = 'expanded'\n    else:\n        stretch = 'normal'\n\n    #  Sizes can be absolute and relative.\n    #  Absolute sizes are: xx-small, x-small, small, medium, large, x-large,\n    #    and xx-large.\n    #  Relative sizes are: larger, smaller\n    #  Length value is an absolute font size, e.g., 12pt\n    #  Percentage values are in 'em's.  Most robust specification.\n\n    #  All AFM fonts are apparently scalable.\n\n    size = 'scalable'\n\n    return FontEntry(fontpath, name, style, variant, weight, stretch, size)",
        "begin_line": 441,
        "end_line": 506,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.__init__#623",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.__init__(self, family=None, style=None, variant=None, weight=None, stretch=None, size=None, fname=None)",
        "snippet": "    def __init__(self,\n                 family = None,\n                 style  = None,\n                 variant= None,\n                 weight = None,\n                 stretch= None,\n                 size   = None,\n                 fname  = None,  # if set, it's a hardcoded filename to use\n                 ):\n        self._family = _normalize_font_family(rcParams['font.family'])\n        self._slant = rcParams['font.style']\n        self._variant = rcParams['font.variant']\n        self._weight = rcParams['font.weight']\n        self._stretch = rcParams['font.stretch']\n        self._size = rcParams['font.size']\n        self._file = None\n\n        if isinstance(family, str):\n            # Treat family as a fontconfig pattern if it is the only\n            # parameter provided.\n            if (style is None and\n                variant is None and\n                weight is None and\n                stretch is None and\n                size is None and\n                fname is None):\n                self.set_fontconfig_pattern(family)\n                return\n\n        self.set_family(family)\n        self.set_style(style)\n        self.set_variant(variant)\n        self.set_weight(weight)\n        self.set_stretch(stretch)\n        self.set_file(fname)\n        self.set_size(size)",
        "begin_line": 623,
        "end_line": 658,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010905125408942203,
            "pseudo_dstar_susp": 0.0034965034965034965,
            "pseudo_tarantula_susp": 0.00030084235860409147,
            "pseudo_op2_susp": 0.0034965034965034965,
            "pseudo_barinel_susp": 0.00030084235860409147
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties._parse_fontconfig_pattern#660",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties._parse_fontconfig_pattern(self, pattern)",
        "snippet": "    def _parse_fontconfig_pattern(self, pattern):\n        return parse_fontconfig_pattern(pattern)",
        "begin_line": 660,
        "end_line": 661,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00016028209648982208,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00016028209648982208,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.__hash__#663",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.__hash__(self)",
        "snippet": "    def __hash__(self):\n        l = (tuple(self.get_family()),\n             self.get_slant(),\n             self.get_variant(),\n             self.get_weight(),\n             self.get_stretch(),\n             self.get_size_in_points(),\n             self.get_file())\n        return hash(l)",
        "begin_line": 663,
        "end_line": 671,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024875621890547263,
            "pseudo_dstar_susp": 0.002364066193853428,
            "pseudo_tarantula_susp": 0.0004017677782241864,
            "pseudo_op2_susp": 0.002364066193853428,
            "pseudo_barinel_susp": 0.0004017677782241864
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.__eq__#673",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.__eq__(self, other)",
        "snippet": "    def __eq__(self, other):\n        return hash(self) == hash(other)",
        "begin_line": 673,
        "end_line": 674,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002551020408163265,
            "pseudo_dstar_susp": 0.002173913043478261,
            "pseudo_tarantula_susp": 0.0004043671653861706,
            "pseudo_op2_susp": 0.002173913043478261,
            "pseudo_barinel_susp": 0.0004043671653861706
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.__str__#676",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.__str__(self)",
        "snippet": "    def __str__(self):\n        return self.get_fontconfig_pattern()",
        "begin_line": 676,
        "end_line": 677,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.get_family#679",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.get_family(self)",
        "snippet": "    def get_family(self):\n        \"\"\"\n        Return a list of font names that comprise the font family.\n        \"\"\"\n        return self._family",
        "begin_line": 679,
        "end_line": 683,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006016847172081829,
            "pseudo_dstar_susp": 0.0004266211604095563,
            "pseudo_tarantula_susp": 0.00037593984962406017,
            "pseudo_op2_susp": 0.0004266211604095563,
            "pseudo_barinel_susp": 0.00037593984962406017
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.get_style#691",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.get_style(self)",
        "snippet": "    def get_style(self):\n        \"\"\"\n        Return the font style.  Values are: 'normal', 'italic' or 'oblique'.\n        \"\"\"\n        return self._slant",
        "begin_line": 691,
        "end_line": 695,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006020469596628537,
            "pseudo_dstar_susp": 0.00043159257660768235,
            "pseudo_tarantula_susp": 0.00036429872495446266,
            "pseudo_op2_susp": 0.00043159257660768235,
            "pseudo_barinel_susp": 0.00036429872495446266
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.get_variant#698",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.get_variant(self)",
        "snippet": "    def get_variant(self):\n        \"\"\"\n        Return the font variant.  Values are: 'normal' or 'small-caps'.\n        \"\"\"\n        return self._variant",
        "begin_line": 698,
        "end_line": 702,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024330900243309003,
            "pseudo_dstar_susp": 0.00234192037470726,
            "pseudo_tarantula_susp": 0.0004008016032064128,
            "pseudo_op2_susp": 0.00234192037470726,
            "pseudo_barinel_susp": 0.0004008016032064128
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.get_weight#704",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.get_weight(self)",
        "snippet": "    def get_weight(self):\n        \"\"\"\n        Set the font weight.  Options are: A numeric value in the\n        range 0-1000 or one of 'light', 'normal', 'regular', 'book',\n        'medium', 'roman', 'semibold', 'demibold', 'demi', 'bold',\n        'heavy', 'extra bold', 'black'\n        \"\"\"\n        return self._weight",
        "begin_line": 704,
        "end_line": 711,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024875621890547263,
            "pseudo_dstar_susp": 0.002364066193853428,
            "pseudo_tarantula_susp": 0.0004017677782241864,
            "pseudo_op2_susp": 0.002364066193853428,
            "pseudo_barinel_susp": 0.0004017677782241864
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.get_stretch#713",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.get_stretch(self)",
        "snippet": "    def get_stretch(self):\n        \"\"\"\n        Return the font stretch or width.  Options are: 'ultra-condensed',\n        'extra-condensed', 'condensed', 'semi-condensed', 'normal',\n        'semi-expanded', 'expanded', 'extra-expanded', 'ultra-expanded'.\n        \"\"\"\n        return self._stretch",
        "begin_line": 713,
        "end_line": 719,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002512562814070352,
            "pseudo_dstar_susp": 0.002380952380952381,
            "pseudo_tarantula_susp": 0.00040241448692152917,
            "pseudo_op2_susp": 0.002380952380952381,
            "pseudo_barinel_susp": 0.00040241448692152917
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.get_size#721",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.get_size(self)",
        "snippet": "    def get_size(self):\n        \"\"\"\n        Return the font size.\n        \"\"\"\n        return self._size",
        "begin_line": 721,
        "end_line": 725,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002440214738897023,
            "pseudo_dstar_susp": 0.00022416498542927594,
            "pseudo_tarantula_susp": 0.0003696857670979667,
            "pseudo_op2_susp": 0.00022416498542927594,
            "pseudo_barinel_susp": 0.0003696857670979667
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.get_size_in_points#727",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.get_size_in_points(self)",
        "snippet": "    def get_size_in_points(self):\n        return self._size",
        "begin_line": 727,
        "end_line": 728,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013192612137203166,
            "pseudo_dstar_susp": 0.002320185614849188,
            "pseudo_tarantula_susp": 0.00037537537537537537,
            "pseudo_op2_susp": 0.002320185614849188,
            "pseudo_barinel_susp": 0.00037537537537537537
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.get_file#730",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.get_file(self)",
        "snippet": "    def get_file(self):\n        \"\"\"\n        Return the filename of the associated font.\n        \"\"\"\n        return self._file",
        "begin_line": 730,
        "end_line": 734,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002512562814070352,
            "pseudo_dstar_susp": 0.002380952380952381,
            "pseudo_tarantula_susp": 0.00040241448692152917,
            "pseudo_op2_susp": 0.002380952380952381,
            "pseudo_barinel_susp": 0.00040241448692152917
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.get_fontconfig_pattern#736",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.get_fontconfig_pattern(self)",
        "snippet": "    def get_fontconfig_pattern(self):\n        \"\"\"\n        Get a fontconfig_ pattern_ suitable for looking up the font as\n        specified with fontconfig's ``fc-match`` utility.\n\n        This support does not depend on fontconfig; we are merely borrowing its\n        pattern syntax for use here.\n        \"\"\"\n        return generate_fontconfig_pattern(self)",
        "begin_line": 736,
        "end_line": 744,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.set_family#746",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.set_family(self, family)",
        "snippet": "    def set_family(self, family):\n        \"\"\"\n        Change the font family.  May be either an alias (generic name\n        is CSS parlance), such as: 'serif', 'sans-serif', 'cursive',\n        'fantasy', or 'monospace', a real font name or a list of real\n        font names.  Real font names are not supported when\n        `text.usetex` is `True`.\n        \"\"\"\n        if family is None:\n            family = rcParams['font.family']\n        self._family = _normalize_font_family(family)",
        "begin_line": 746,
        "end_line": 756,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001026694045174538,
            "pseudo_dstar_susp": 0.0035211267605633804,
            "pseudo_tarantula_susp": 0.0003132832080200501,
            "pseudo_op2_susp": 0.0035211267605633804,
            "pseudo_barinel_susp": 0.0003132832080200501
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.set_style#759",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.set_style(self, style)",
        "snippet": "    def set_style(self, style):\n        \"\"\"\n        Set the font style.  Values are: 'normal', 'italic' or 'oblique'.\n        \"\"\"\n        if style is None:\n            style = rcParams['font.style']\n        cbook._check_in_list(['normal', 'italic', 'oblique'], style=style)\n        self._slant = style",
        "begin_line": 759,
        "end_line": 766,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001002004008016032,
            "pseudo_dstar_susp": 0.003278688524590164,
            "pseudo_tarantula_susp": 0.00030303030303030303,
            "pseudo_op2_susp": 0.003278688524590164,
            "pseudo_barinel_susp": 0.00030303030303030303
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.set_variant#769",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.set_variant(self, variant)",
        "snippet": "    def set_variant(self, variant):\n        \"\"\"\n        Set the font variant.  Values are: 'normal' or 'small-caps'.\n        \"\"\"\n        if variant is None:\n            variant = rcParams['font.variant']\n        cbook._check_in_list(['normal', 'small-caps'], variant=variant)\n        self._variant = variant",
        "begin_line": 769,
        "end_line": 776,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010235414534288639,
            "pseudo_dstar_susp": 0.0034965034965034965,
            "pseudo_tarantula_susp": 0.00033090668431502316,
            "pseudo_op2_susp": 0.0034965034965034965,
            "pseudo_barinel_susp": 0.00033090668431502316
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.set_weight#778",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.set_weight(self, weight)",
        "snippet": "    def set_weight(self, weight):\n        \"\"\"\n        Set the font weight.  May be either a numeric value in the\n        range 0-1000 or one of 'ultralight', 'light', 'normal',\n        'regular', 'book', 'medium', 'roman', 'semibold', 'demibold',\n        'demi', 'bold', 'heavy', 'extra bold', 'black'\n        \"\"\"\n        if weight is None:\n            weight = rcParams['font.weight']\n        try:\n            weight = int(weight)\n            if weight < 0 or weight > 1000:\n                raise ValueError()\n        except ValueError:\n            if weight not in weight_dict:\n                raise ValueError(\"weight is invalid\")\n        self._weight = weight",
        "begin_line": 778,
        "end_line": 794,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001092896174863388,
            "pseudo_dstar_susp": 0.0035335689045936395,
            "pseudo_tarantula_susp": 0.00031575623618566466,
            "pseudo_op2_susp": 0.0035335689045936395,
            "pseudo_barinel_susp": 0.00031575623618566466
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.set_stretch#796",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.set_stretch(self, stretch)",
        "snippet": "    def set_stretch(self, stretch):\n        \"\"\"\n        Set the font stretch or width.  Options are: 'ultra-condensed',\n        'extra-condensed', 'condensed', 'semi-condensed', 'normal',\n        'semi-expanded', 'expanded', 'extra-expanded' or\n        'ultra-expanded', or a numeric value in the range 0-1000.\n        \"\"\"\n        if stretch is None:\n            stretch = rcParams['font.stretch']\n        try:\n            stretch = int(stretch)\n            if stretch < 0 or stretch > 1000:\n                raise ValueError()\n        except ValueError:\n            if stretch not in stretch_dict:\n                raise ValueError(\"stretch is invalid\")\n        self._stretch = stretch",
        "begin_line": 796,
        "end_line": 812,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010869565217391304,
            "pseudo_dstar_susp": 0.003278688524590164,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.003278688524590164,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.set_size#814",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.set_size(self, size)",
        "snippet": "    def set_size(self, size):\n        \"\"\"\n        Set the font size.  Either an relative value of 'xx-small',\n        'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'\n        or an absolute font size, e.g., 12.\n        \"\"\"\n        if size is None:\n            size = rcParams['font.size']\n        try:\n            size = float(size)\n        except ValueError:\n            try:\n                scale = font_scalings[size]\n            except KeyError:\n                raise ValueError(\n                    \"Size is invalid. Valid font size are \"\n                    + \", \".join(map(str, font_scalings)))\n            else:\n                size = scale * FontManager.get_default_size()\n        if size < 1.0:\n            _log.info('Fontsize %1.2f < 1.0 pt not allowed by FreeType. '\n                      'Setting fontsize = 1 pt', size)\n            size = 1.0\n        self._size = size",
        "begin_line": 814,
        "end_line": 837,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010070493454179255,
            "pseudo_dstar_susp": 0.003278688524590164,
            "pseudo_tarantula_susp": 0.00030303030303030303,
            "pseudo_op2_susp": 0.003278688524590164,
            "pseudo_barinel_susp": 0.00030303030303030303
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.set_file#839",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.set_file(self, file)",
        "snippet": "    def set_file(self, file):\n        \"\"\"\n        Set the filename of the fontfile to use.  In this case, all\n        other properties will be ignored.\n        \"\"\"\n        self._file = os.fspath(file) if file is not None else None",
        "begin_line": 839,
        "end_line": 844,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010183299389002036,
            "pseudo_dstar_susp": 0.003436426116838488,
            "pseudo_tarantula_susp": 0.00030303030303030303,
            "pseudo_op2_susp": 0.003436426116838488,
            "pseudo_barinel_susp": 0.00030303030303030303
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.set_fontconfig_pattern#846",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.set_fontconfig_pattern(self, pattern)",
        "snippet": "    def set_fontconfig_pattern(self, pattern):\n        \"\"\"\n        Set the properties by parsing a fontconfig_ *pattern*.\n\n        This support does not depend on fontconfig; we are merely borrowing its\n        pattern syntax for use here.\n        \"\"\"\n        for key, val in self._parse_fontconfig_pattern(pattern).items():\n            if type(val) == list:\n                getattr(self, \"set_\" + key)(val[0])\n            else:\n                getattr(self, \"set_\" + key)(val)",
        "begin_line": 846,
        "end_line": 857,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00016028209648982208,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00016028209648982208,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.copy#859",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.copy(self)",
        "snippet": "    def copy(self):\n        \"\"\"Return a copy of self.\"\"\"\n        new = type(self)()\n        vars(new).update(vars(self))\n        return new",
        "begin_line": 859,
        "end_line": 863,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00045454545454545455,
            "pseudo_dstar_susp": 0.0005216484089723526,
            "pseudo_tarantula_susp": 0.00029036004645760743,
            "pseudo_op2_susp": 0.0005216484089723526,
            "pseudo_barinel_susp": 0.00029036004645760743
        }
    },
    {
        "name": "lib.matplotlib.font_manager._JSONEncoder.default#867",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager._JSONEncoder",
        "signature": "lib.matplotlib.font_manager._JSONEncoder.default(self, o)",
        "snippet": "    def default(self, o):\n        if isinstance(o, FontManager):\n            return dict(o.__dict__, __class__='FontManager')\n        elif isinstance(o, FontEntry):\n            d = dict(o.__dict__, __class__='FontEntry')\n            try:\n                # Cache paths of fonts shipped with Matplotlib relative to the\n                # Matplotlib data path, which helps in the presence of venvs.\n                d[\"fname\"] = str(\n                    Path(d[\"fname\"]).relative_to(mpl.get_data_path()))\n            except ValueError:\n                pass\n            return d\n        else:\n            return super().default(o)",
        "begin_line": 867,
        "end_line": 881,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.font_manager._json_decode#889",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager",
        "signature": "lib.matplotlib.font_manager._json_decode(o)",
        "snippet": "def _json_decode(o):\n    cls = o.pop('__class__', None)\n    if cls is None:\n        return o\n    elif cls == 'FontManager':\n        r = FontManager.__new__(FontManager)\n        r.__dict__.update(o)\n        return r\n    elif cls == 'FontEntry':\n        r = FontEntry.__new__(FontEntry)\n        r.__dict__.update(o)\n        if not os.path.isabs(r.fname):\n            r.fname = os.path.join(mpl.get_data_path(), r.fname)\n        return r\n    else:\n        raise ValueError(\"don't know how to deserialize __class__=%s\" % cls)",
        "begin_line": 889,
        "end_line": 904,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.font_manager.json_dump#907",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager",
        "signature": "lib.matplotlib.font_manager.json_dump(data, filename)",
        "snippet": "def json_dump(data, filename):\n    \"\"\"\n    Dump `FontManager` *data* as JSON to the file named *filename*.\n\n    Notes\n    -----\n    File paths that are children of the Matplotlib data path (typically, fonts\n    shipped with Matplotlib) are stored relative to that data path (to remain\n    valid across virtualenvs).\n\n    See Also\n    --------\n    json_load\n    \"\"\"\n    with open(filename, 'w') as fh:\n        try:\n            json.dump(data, fh, cls=_JSONEncoder, indent=2)\n        except OSError as e:\n            _log.warning('Could not save font_manager cache {}'.format(e))",
        "begin_line": 907,
        "end_line": 925,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.font_manager.json_load#928",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager",
        "signature": "lib.matplotlib.font_manager.json_load(filename)",
        "snippet": "def json_load(filename):\n    \"\"\"\n    Load a `FontManager` from the JSON file named *filename*.\n\n    See Also\n    --------\n    json_dump\n    \"\"\"\n    with open(filename, 'r') as fh:\n        return json.load(fh, object_hook=_json_decode)",
        "begin_line": 928,
        "end_line": 937,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.font_manager._normalize_font_family#940",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager",
        "signature": "lib.matplotlib.font_manager._normalize_font_family(family)",
        "snippet": "def _normalize_font_family(family):\n    if isinstance(family, str):\n        family = [family]\n    return family",
        "begin_line": 940,
        "end_line": 943,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010090817356205853,
            "pseudo_dstar_susp": 0.0033444816053511705,
            "pseudo_tarantula_susp": 0.00030303030303030303,
            "pseudo_op2_susp": 0.0033444816053511705,
            "pseudo_barinel_susp": 0.00030303030303030303
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontManager.get_default_size#1031",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontManager",
        "signature": "lib.matplotlib.font_manager.FontManager.get_default_size()",
        "snippet": "    def get_default_size():\n        \"\"\"\n        Return the default font size.\n        \"\"\"\n        return rcParams['font.size']",
        "begin_line": 1031,
        "end_line": 1035,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00038446751249519417,
            "pseudo_dstar_susp": 0.0005025125628140704,
            "pseudo_tarantula_susp": 0.0001465630954125751,
            "pseudo_op2_susp": 0.0005025125628140704,
            "pseudo_barinel_susp": 0.0001465630954125751
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontManager.score_family#1045",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontManager",
        "signature": "lib.matplotlib.font_manager.FontManager.score_family(self, families, family2)",
        "snippet": "    def score_family(self, families, family2):\n        \"\"\"\n        Returns a match score between the list of font families in\n        *families* and the font family name *family2*.\n\n        An exact match at the head of the list returns 0.0.\n\n        A match further down the list will return between 0 and 1.\n\n        No match will return 1.0.\n        \"\"\"\n        if not isinstance(families, (list, tuple)):\n            families = [families]\n        elif len(families) == 0:\n            return 1.0\n        family2 = family2.lower()\n        step = 1 / len(families)\n        for i, family1 in enumerate(families):\n            family1 = family1.lower()\n            if family1 in font_family_aliases:\n                if family1 in ('sans', 'sans serif'):\n                    family1 = 'sans-serif'\n                options = rcParams['font.' + family1]\n                options = [x.lower() for x in options]\n                if family2 in options:\n                    idx = options.index(family2)\n                    return (i + (idx / len(options))) * step\n            elif family1 == family2:\n                # The score should be weighted by where in the\n                # list the font was found.\n                return i * step\n        return 1.0",
        "begin_line": 1045,
        "end_line": 1076,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00029824038174768865,
            "pseudo_dstar_susp": 0.00024968789013732833,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00024968789013732833,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontManager.score_style#1078",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontManager",
        "signature": "lib.matplotlib.font_manager.FontManager.score_style(self, style1, style2)",
        "snippet": "    def score_style(self, style1, style2):\n        \"\"\"\n        Returns a match score between *style1* and *style2*.\n\n        An exact match returns 0.0.\n\n        A match between 'italic' and 'oblique' returns 0.1.\n\n        No match returns 1.0.\n        \"\"\"\n        if style1 == style2:\n            return 0.0\n        elif (style1 in ('italic', 'oblique')\n              and style2 in ('italic', 'oblique')):\n            return 0.1\n        return 1.0",
        "begin_line": 1078,
        "end_line": 1093,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00027731558513588466,
            "pseudo_dstar_susp": 0.00024594195769798326,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00024594195769798326,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontManager.score_variant#1095",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontManager",
        "signature": "lib.matplotlib.font_manager.FontManager.score_variant(self, variant1, variant2)",
        "snippet": "    def score_variant(self, variant1, variant2):\n        \"\"\"\n        Returns a match score between *variant1* and *variant2*.\n\n        An exact match returns 0.0, otherwise 1.0.\n        \"\"\"\n        if variant1 == variant2:\n            return 0.0\n        else:\n            return 1.0",
        "begin_line": 1095,
        "end_line": 1104,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00027731558513588466,
            "pseudo_dstar_susp": 0.00024594195769798326,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00024594195769798326,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontManager.score_stretch#1106",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontManager",
        "signature": "lib.matplotlib.font_manager.FontManager.score_stretch(self, stretch1, stretch2)",
        "snippet": "    def score_stretch(self, stretch1, stretch2):\n        \"\"\"\n        Returns a match score between *stretch1* and *stretch2*.\n\n        The result is the absolute value of the difference between the\n        CSS numeric values of *stretch1* and *stretch2*, normalized\n        between 0.0 and 1.0.\n        \"\"\"\n        try:\n            stretchval1 = int(stretch1)\n        except ValueError:\n            stretchval1 = stretch_dict.get(stretch1, 500)\n        try:\n            stretchval2 = int(stretch2)\n        except ValueError:\n            stretchval2 = stretch_dict.get(stretch2, 500)\n        return abs(stretchval1 - stretchval2) / 1000.0",
        "begin_line": 1106,
        "end_line": 1122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002801905295601009,
            "pseudo_dstar_susp": 0.00024968789013732833,
            "pseudo_tarantula_susp": 0.0003850596842510589,
            "pseudo_op2_susp": 0.00024968789013732833,
            "pseudo_barinel_susp": 0.00038491147036181676
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontManager.score_weight#1124",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontManager",
        "signature": "lib.matplotlib.font_manager.FontManager.score_weight(self, weight1, weight2)",
        "snippet": "    def score_weight(self, weight1, weight2):\n        \"\"\"\n        Returns a match score between *weight1* and *weight2*.\n\n        The result is 0.0 if both weight1 and weight 2 are given as strings\n        and have the same value.\n\n        Otherwise, the result is the absolute value of the difference between\n        the CSS numeric values of *weight1* and *weight2*, normalized between\n        0.05 and 1.0.\n        \"\"\"\n        # exact match of the weight names, e.g. weight1 == weight2 == \"regular\"\n        if cbook._str_equal(weight1, weight2):\n            return 0.0\n        w1 = weight1 if isinstance(weight1, Number) else weight_dict[weight1]\n        w2 = weight2 if isinstance(weight2, Number) else weight_dict[weight2]\n        return 0.95 * (abs(w1 - w2) / 1000) + 0.05",
        "begin_line": 1124,
        "end_line": 1140,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002754820936639118,
            "pseudo_dstar_susp": 0.0002493143854400399,
            "pseudo_tarantula_susp": 0.0003850596842510589,
            "pseudo_op2_susp": 0.0002493143854400399,
            "pseudo_barinel_susp": 0.00038491147036181676
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontManager.score_size#1142",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontManager",
        "signature": "lib.matplotlib.font_manager.FontManager.score_size(self, size1, size2)",
        "snippet": "    def score_size(self, size1, size2):\n        \"\"\"\n        Returns a match score between *size1* and *size2*.\n\n        If *size2* (the size specified in the font file) is 'scalable', this\n        function always returns 0.0, since any font size can be generated.\n\n        Otherwise, the result is the absolute distance between *size1* and\n        *size2*, normalized so that the usual range of font sizes (6pt -\n        72pt) will lie between 0.0 and 1.0.\n        \"\"\"\n        if size2 == 'scalable':\n            return 0.0\n        # Size value should have already been\n        try:\n            sizeval1 = float(size1)\n        except ValueError:\n            sizeval1 = self.default_size * font_scalings[size1]\n        try:\n            sizeval2 = float(size2)\n        except ValueError:\n            return 1.0\n        return abs(sizeval1 - sizeval2) / 72",
        "begin_line": 1142,
        "end_line": 1164,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00028208744710860365,
            "pseudo_dstar_susp": 0.00025,
            "pseudo_tarantula_susp": 0.0003935458480913026,
            "pseudo_op2_susp": 0.00025,
            "pseudo_barinel_susp": 0.0003935458480913026
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontManager.findfont#1166",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontManager",
        "signature": "lib.matplotlib.font_manager.FontManager.findfont(self, prop, fontext='ttf', directory=None, fallback_to_default=True, rebuild_if_missing=True)",
        "snippet": "    def findfont(self, prop, fontext='ttf', directory=None,\n                 fallback_to_default=True, rebuild_if_missing=True):\n        \"\"\"\n        Find a font that most closely matches the given font properties.\n\n        Parameters\n        ----------\n        prop : str or `~matplotlib.font_manager.FontProperties`\n            The font properties to search for. This can be either a\n            `.FontProperties` object or a string defining a\n            `fontconfig patterns`_.\n\n        fontext : {'ttf', 'afm'}, optional, default: 'ttf'\n            The extension of the font file:\n\n            - 'ttf': TrueType and OpenType fonts (.ttf, .ttc, .otf)\n            - 'afm': Adobe Font Metrics (.afm)\n\n        directory : str, optional\n            If given, only search this directory and its subdirectories.\n        fallback_to_default : bool\n            If True, will fallback to the default font family (usually\n            \"DejaVu Sans\" or \"Helvetica\") if the first lookup hard-fails.\n        rebuild_if_missing : bool\n            Whether to rebuild the font cache and search again if no match\n            is found.\n\n        Returns\n        -------\n        fontfile : str\n            The filename of the best matching font.\n\n        Notes\n        -----\n        This performs a nearest neighbor search.  Each font is given a\n        similarity score to the target font properties.  The first font with\n        the highest score is returned.  If no matches below a certain\n        threshold are found, the default font (usually DejaVu Sans) is\n        returned.\n\n        The result is cached, so subsequent lookups don't have to\n        perform the O(n) nearest neighbor search.\n\n        See the `W3C Cascading Style Sheet, Level 1\n        <http://www.w3.org/TR/1998/REC-CSS2-19980512/>`_ documentation\n        for a description of the font finding algorithm.\n\n        .. _fontconfig patterns:\n           https://www.freedesktop.org/software/fontconfig/fontconfig-user.html\n\n        \"\"\"\n        # Pass the relevant rcParams (and the font manager, as `self`) to\n        # _findfont_cached so to prevent using a stale cache entry after an\n        # rcParam was changed.\n        rc_params = tuple(tuple(rcParams[key]) for key in [\n            \"font.serif\", \"font.sans-serif\", \"font.cursive\", \"font.fantasy\",\n            \"font.monospace\"])\n        return self._findfont_cached(\n            prop, fontext, directory, fallback_to_default, rebuild_if_missing,\n            rc_params)",
        "begin_line": 1166,
        "end_line": 1225,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024330900243309003,
            "pseudo_dstar_susp": 0.00234192037470726,
            "pseudo_tarantula_susp": 0.0004008016032064128,
            "pseudo_op2_susp": 0.00234192037470726,
            "pseudo_barinel_susp": 0.0004008016032064128
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontManager._findfont_cached#1228",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontManager",
        "signature": "lib.matplotlib.font_manager.FontManager._findfont_cached(self, prop, fontext, directory, fallback_to_default, rebuild_if_missing, rc_params)",
        "snippet": "    def _findfont_cached(self, prop, fontext, directory, fallback_to_default,\n                         rebuild_if_missing, rc_params):\n\n        if not isinstance(prop, FontProperties):\n            prop = FontProperties(prop)\n\n        fname = prop.get_file()\n        if fname is not None:\n            return fname\n\n        if fontext == 'afm':\n            fontlist = self.afmlist\n        else:\n            fontlist = self.ttflist\n\n        best_score = 1e64\n        best_font = None\n\n        _log.debug('findfont: Matching %s.', prop)\n        for font in fontlist:\n            if (directory is not None and\n                    Path(directory) not in Path(font.fname).parents):\n                continue\n            # Matching family should have top priority, so multiply it by 10.\n            score = (self.score_family(prop.get_family(), font.name) * 10\n                     + self.score_style(prop.get_style(), font.style)\n                     + self.score_variant(prop.get_variant(), font.variant)\n                     + self.score_weight(prop.get_weight(), font.weight)\n                     + self.score_stretch(prop.get_stretch(), font.stretch)\n                     + self.score_size(prop.get_size(), font.size))\n            _log.debug('findfont: score(%s) = %s', font, score)\n            if score < best_score:\n                best_score = score\n                best_font = font\n            if score == 0:\n                break\n\n        if best_font is None or best_score >= 10.0:\n            if fallback_to_default:\n                _log.warning(\n                    'findfont: Font family %s not found. Falling back to %s.',\n                    prop.get_family(), self.defaultFamily[fontext])\n                default_prop = prop.copy()\n                default_prop.set_family(self.defaultFamily[fontext])\n                return self.findfont(default_prop, fontext, directory, False)\n            else:\n                # This is a hard fail -- we can't find anything reasonable,\n                # so just return the DejaVuSans.ttf\n                _log.warning('findfont: Could not match %s. Returning %s.',\n                             prop, self.defaultFont[fontext])\n                result = self.defaultFont[fontext]\n        else:\n            _log.debug('findfont: Matching %s to %s (%r) with score of %f.',\n                       prop, best_font.name, best_font.fname, best_score)\n            result = best_font.fname\n\n        if not os.path.isfile(result):\n            if rebuild_if_missing:\n                _log.info(\n                    'findfont: Found a missing font file.  Rebuilding cache.')\n                _rebuild()\n                return fontManager.findfont(\n                    prop, fontext, directory, True, False)\n            else:\n                raise ValueError(\"No valid font could be found\")\n\n        return result",
        "begin_line": 1228,
        "end_line": 1294,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00028208744710860365,
            "pseudo_dstar_susp": 0.00025,
            "pseudo_tarantula_susp": 0.00041152263374485596,
            "pseudo_op2_susp": 0.00025,
            "pseudo_barinel_susp": 0.00041135335252982314
        }
    },
    {
        "name": "lib.matplotlib.font_manager.get_font#1325",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager",
        "signature": "lib.matplotlib.font_manager.get_font(filename, hinting_factor=None)",
        "snippet": "def get_font(filename, hinting_factor=None):\n    if hinting_factor is None:\n        hinting_factor = rcParams['text.hinting_factor']\n    return _get_font(os.fspath(filename), hinting_factor,\n                     _kerning_factor=rcParams['text.kerning_factor'])",
        "begin_line": 1325,
        "end_line": 1329,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002544529262086514,
            "pseudo_dstar_susp": 0.002386634844868735,
            "pseudo_tarantula_susp": 0.00040306328093510683,
            "pseudo_op2_susp": 0.002386634844868735,
            "pseudo_barinel_susp": 0.00040306328093510683
        }
    },
    {
        "name": "lib.matplotlib.projections.__init__.ProjectionRegistry.get_projection_class#19",
        "src_path": "lib/matplotlib/projections/__init__.py",
        "class_name": "lib.matplotlib.projections.__init__.ProjectionRegistry",
        "signature": "lib.matplotlib.projections.__init__.ProjectionRegistry.get_projection_class(self, name)",
        "snippet": "    def get_projection_class(self, name):\n        \"\"\"Get a projection class from its *name*.\"\"\"\n        return self._all_projection_types[name]",
        "begin_line": 19,
        "end_line": 21,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006165228113440197,
            "pseudo_dstar_susp": 0.0007645259938837921,
            "pseudo_tarantula_susp": 0.00016742005692281934,
            "pseudo_op2_susp": 0.0007645259938837921,
            "pseudo_barinel_susp": 0.00016742005692281934
        }
    },
    {
        "name": "lib.matplotlib.image._draw_list_compositing_images#119",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image",
        "signature": "lib.matplotlib.image._draw_list_compositing_images(renderer, parent, artists, suppress_composite=None)",
        "snippet": "def _draw_list_compositing_images(\n        renderer, parent, artists, suppress_composite=None):\n    \"\"\"\n    Draw a sorted list of artists, compositing images into a single\n    image where possible.\n\n    For internal matplotlib use only: It is here to reduce duplication\n    between `Figure.draw` and `Axes.draw`, but otherwise should not be\n    generally useful.\n    \"\"\"\n    has_images = any(isinstance(x, _ImageBase) for x in artists)\n\n    # override the renderer default if suppressComposite is not None\n    not_composite = (suppress_composite if suppress_composite is not None\n                     else renderer.option_image_nocomposite())\n\n    if not_composite or not has_images:\n        for a in artists:\n            a.draw(renderer)\n    else:\n        # Composite any adjacent images together\n        image_group = []\n        mag = renderer.get_image_magnification()\n\n        def flush_images():\n            if len(image_group) == 1:\n                image_group[0].draw(renderer)\n            elif len(image_group) > 1:\n                data, l, b = composite_images(image_group, renderer, mag)\n                if data.size != 0:\n                    gc = renderer.new_gc()\n                    gc.set_clip_rectangle(parent.bbox)\n                    gc.set_clip_path(parent.get_clip_path())\n                    renderer.draw_image(gc, round(l), round(b), data)\n                    gc.restore()\n            del image_group[:]\n\n        for a in artists:\n            if isinstance(a, _ImageBase) and a.can_composite():\n                image_group.append(a)\n            else:\n                flush_images()\n                a.draw(renderer)\n        flush_images()",
        "begin_line": 119,
        "end_line": 162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006024096385542169,
            "pseudo_dstar_susp": 0.00641025641025641,
            "pseudo_tarantula_susp": 0.0004422821760283061,
            "pseudo_op2_susp": 0.00641025641025641,
            "pseudo_barinel_susp": 0.0004422821760283061
        }
    },
    {
        "name": "lib.matplotlib.image._ImageBase.__init__#237",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image._ImageBase",
        "signature": "lib.matplotlib.image._ImageBase.__init__(self, ax, cmap=None, norm=None, interpolation=None, origin=None, filternorm=True, filterrad=4.0, resample=False, **kwargs)",
        "snippet": "    def __init__(self, ax,\n                 cmap=None,\n                 norm=None,\n                 interpolation=None,\n                 origin=None,\n                 filternorm=True,\n                 filterrad=4.0,\n                 resample=False,\n                 **kwargs\n                 ):\n        martist.Artist.__init__(self)\n        cm.ScalarMappable.__init__(self, norm, cmap)\n        self._mouseover = True\n        if origin is None:\n            origin = rcParams['image.origin']\n        self.origin = origin\n        self.set_filternorm(filternorm)\n        self.set_filterrad(filterrad)\n        self.set_interpolation(interpolation)\n        self.set_resample(resample)\n        self.axes = ax\n\n        self._imcache = None\n\n        self.update(kwargs)",
        "begin_line": 237,
        "end_line": 261,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001932367149758454,
            "pseudo_dstar_susp": 0.00023929169657812874,
            "pseudo_tarantula_susp": 0.00013206550449022716,
            "pseudo_op2_susp": 0.00023929169657812874,
            "pseudo_barinel_susp": 0.00013206550449022716
        }
    },
    {
        "name": "lib.matplotlib.image._ImageBase._make_image#316",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image._ImageBase",
        "signature": "lib.matplotlib.image._ImageBase._make_image(self, A, in_bbox, out_bbox, clip_bbox, magnification=1.0, unsampled=False, round_to_pixel_border=True)",
        "snippet": "    def _make_image(self, A, in_bbox, out_bbox, clip_bbox, magnification=1.0,\n                    unsampled=False, round_to_pixel_border=True):\n        \"\"\"\n        Normalize, rescale, and colormap the image *A* from the given *in_bbox*\n        (in data space), to the given *out_bbox* (in pixel space) clipped to\n        the given *clip_bbox* (also in pixel space), and magnified by the\n        *magnification* factor.\n\n        *A* may be a greyscale image (M, N) with a dtype of float32, float64,\n        float128, uint16 or uint8, or an (M, N, 4) RGBA image with a dtype of\n        float32, float64, float128, or uint8.\n\n        If *unsampled* is True, the image will not be scaled, but an\n        appropriate affine transformation will be returned instead.\n\n        If *round_to_pixel_border* is True, the output image size will be\n        rounded to the nearest pixel boundary.  This makes the images align\n        correctly with the axes.  It should not be used if exact scaling is\n        needed, such as for `FigureImage`.\n\n        Returns\n        -------\n        image : (M, N, 4) uint8 array\n            The RGBA image, resampled unless *unsampled* is True.\n        x, y : float\n            The upper left corner where the image should be drawn, in pixel\n            space.\n        trans : Affine2D\n            The affine transformation from image to pixel space.\n        \"\"\"\n        if A is None:\n            raise RuntimeError('You must first set the image '\n                               'array or the image attribute')\n        if A.size == 0:\n            raise RuntimeError(\"_make_image must get a non-empty image. \"\n                               \"Your Artist's draw method must filter before \"\n                               \"this method is called.\")\n\n        clipped_bbox = Bbox.intersection(out_bbox, clip_bbox)\n\n        if clipped_bbox is None:\n            return None, 0, 0, None\n\n        out_width_base = clipped_bbox.width * magnification\n        out_height_base = clipped_bbox.height * magnification\n\n        if out_width_base == 0 or out_height_base == 0:\n            return None, 0, 0, None\n\n        if self.origin == 'upper':\n            # Flip the input image using a transform.  This avoids the\n            # problem with flipping the array, which results in a copy\n            # when it is converted to contiguous in the C wrapper\n            t0 = Affine2D().translate(0, -A.shape[0]).scale(1, -1)\n        else:\n            t0 = IdentityTransform()\n\n        t0 += (\n            Affine2D()\n            .scale(\n                in_bbox.width / A.shape[1],\n                in_bbox.height / A.shape[0])\n            .translate(in_bbox.x0, in_bbox.y0)\n            + self.get_transform())\n\n        t = (t0\n             + (Affine2D()\n                .translate(-clipped_bbox.x0, -clipped_bbox.y0)\n                .scale(magnification)))\n\n        # So that the image is aligned with the edge of the axes, we want to\n        # round up the output width to the next integer.  This also means\n        # scaling the transform slightly to account for the extra subpixel.\n        if (t.is_affine and round_to_pixel_border and\n                (out_width_base % 1.0 != 0.0 or out_height_base % 1.0 != 0.0)):\n            out_width = math.ceil(out_width_base)\n            out_height = math.ceil(out_height_base)\n            extra_width = (out_width - out_width_base) / out_width_base\n            extra_height = (out_height - out_height_base) / out_height_base\n            t += Affine2D().scale(1.0 + extra_width, 1.0 + extra_height)\n        else:\n            out_width = int(out_width_base)\n            out_height = int(out_height_base)\n        out_shape = (out_height, out_width)\n\n        if not unsampled:\n            if not (A.ndim == 2 or A.ndim == 3 and A.shape[-1] in (3, 4)):\n                raise ValueError(f\"Invalid shape {A.shape} for image data\")\n\n            if A.ndim == 2:\n                # if we are a 2D array, then we are running through the\n                # norm + colormap transformation.  However, in general the\n                # input data is not going to match the size on the screen so we\n                # have to resample to the correct number of pixels\n\n                # TODO slice input array first\n                inp_dtype = A.dtype\n                a_min = A.min()\n                a_max = A.max()\n                # figure out the type we should scale to.  For floats,\n                # leave as is.  For integers cast to an appropriate-sized\n                # float.  Small integers get smaller floats in an attempt\n                # to keep the memory footprint reasonable.\n                if a_min is np.ma.masked:\n                    # all masked, so values don't matter\n                    a_min, a_max = np.int32(0), np.int32(1)\n                if inp_dtype.kind == 'f':\n                    scaled_dtype = A.dtype\n                    # Cast to float64\n                    if A.dtype not in (np.float32, np.float16):\n                        if A.dtype != np.float64:\n                            cbook._warn_external(\n                                f\"Casting input data from '{A.dtype}' to \"\n                                f\"'float64' for imshow\")\n                        scaled_dtype = np.float64\n                else:\n                    # probably an integer of some type.\n                    da = a_max.astype(np.float64) - a_min.astype(np.float64)\n                    # give more breathing room if a big dynamic range\n                    scaled_dtype = np.float64 if da > 1e8 else np.float32\n\n                # scale the input data to [.1, .9].  The Agg\n                # interpolators clip to [0, 1] internally, use a\n                # smaller input scale to identify which of the\n                # interpolated points need to be should be flagged as\n                # over / under.\n                # This may introduce numeric instabilities in very broadly\n                # scaled data\n                # Always copy, and don't allow array subtypes.\n                A_scaled = np.array(A, dtype=scaled_dtype)\n                # clip scaled data around norm if necessary.\n                # This is necessary for big numbers at the edge of\n                # float64's ability to represent changes.  Applying\n                # a norm first would be good, but ruins the interpolation\n                # of over numbers.\n                self.norm.autoscale_None(A)\n                dv = np.float64(self.norm.vmax) - np.float64(self.norm.vmin)\n                vmid = self.norm.vmin + dv / 2\n                fact = 1e7 if scaled_dtype == np.float64 else 1e4\n                newmin = vmid - dv * fact\n                if newmin < a_min:\n                    newmin = None\n                else:\n                    a_min = np.float64(newmin)\n                newmax = vmid + dv * fact\n                if newmax > a_max:\n                    newmax = None\n                else:\n                    a_max = np.float64(newmax)\n                if newmax is not None or newmin is not None:\n                    np.clip(A_scaled, newmin, newmax, out=A_scaled)\n\n                A_scaled -= a_min\n                # a_min and a_max might be ndarray subclasses so use\n                # item to avoid errors\n                a_min = a_min.astype(scaled_dtype).item()\n                a_max = a_max.astype(scaled_dtype).item()\n\n                if a_min != a_max:\n                    A_scaled /= ((a_max - a_min) / 0.8)\n                A_scaled += 0.1\n                # resample the input data to the correct resolution and shape\n                A_resampled = _resample(self, A_scaled, out_shape, t)\n                # done with A_scaled now, remove from namespace to be sure!\n                del A_scaled\n                # un-scale the resampled data to approximately the\n                # original range things that interpolated to above /\n                # below the original min/max will still be above /\n                # below, but possibly clipped in the case of higher order\n                # interpolation + drastically changing data.\n                A_resampled -= 0.1\n                if a_min != a_max:\n                    A_resampled *= ((a_max - a_min) / 0.8)\n                A_resampled += a_min\n                # if using NoNorm, cast back to the original datatype\n                if isinstance(self.norm, mcolors.NoNorm):\n                    A_resampled = A_resampled.astype(A.dtype)\n\n                mask = (np.where(A.mask, np.float32(np.nan), np.float32(1))\n                        if A.mask.shape == A.shape  # nontrivial mask\n                        else np.ones_like(A, np.float32))\n                # we always have to interpolate the mask to account for\n                # non-affine transformations\n                out_alpha = _resample(self, mask, out_shape, t, resample=True)\n                # done with the mask now, delete from namespace to be sure!\n                del mask\n                # Agg updates out_alpha in place.  If the pixel has no image\n                # data it will not be updated (and still be 0 as we initialized\n                # it), if input data that would go into that output pixel than\n                # it will be `nan`, if all the input data for a pixel is good\n                # it will be 1, and if there is _some_ good data in that output\n                # pixel it will be between [0, 1] (such as a rotated image).\n                out_mask = np.isnan(out_alpha)\n                out_alpha[out_mask] = 1\n                # Apply the pixel-by-pixel alpha values if present\n                alpha = self.get_alpha()\n                if alpha is not None and np.ndim(alpha) > 0:\n                    out_alpha *= _resample(self, alpha, out_shape,\n                                           t, resample=True)\n                # mask and run through the norm\n                output = self.norm(np.ma.masked_array(A_resampled, out_mask))\n            else:\n                if A.shape[2] == 3:\n                    A = _rgb_to_rgba(A)\n                alpha = self._get_scalar_alpha()\n                output_alpha = _resample(  # resample alpha channel\n                    self, A[..., 3], out_shape, t, alpha=alpha)\n                output = _resample(  # resample rgb channels\n                    self, _rgb_to_rgba(A[..., :3]), out_shape, t, alpha=alpha)\n                output[..., 3] = output_alpha  # recombine rgb and alpha\n\n            # at this point output is either a 2D array of normed data\n            # (of int or float)\n            # or an RGBA array of re-sampled input\n            output = self.to_rgba(output, bytes=True, norm=False)\n            # output is now a correctly sized RGBA array of uint8\n\n            # Apply alpha *after* if the input was greyscale without a mask\n            if A.ndim == 2:\n                alpha = self._get_scalar_alpha()\n                alpha_channel = output[:, :, 3]\n                alpha_channel[:] = np.asarray(\n                    np.asarray(alpha_channel, np.float32) * out_alpha * alpha,\n                    np.uint8)\n\n        else:\n            if self._imcache is None:\n                self._imcache = self.to_rgba(A, bytes=True, norm=(A.ndim == 2))\n            output = self._imcache\n\n            # Subset the input image to only the part that will be\n            # displayed\n            subset = TransformedBbox(clip_bbox, t0.inverted()).frozen()\n            output = output[\n                int(max(subset.ymin, 0)):\n                int(min(subset.ymax + 1, output.shape[0])),\n                int(max(subset.xmin, 0)):\n                int(min(subset.xmax + 1, output.shape[1]))]\n\n            t = Affine2D().translate(\n                int(max(subset.xmin, 0)), int(max(subset.ymin, 0))) + t\n\n        return output, clipped_bbox.x0, clipped_bbox.y0, t",
        "begin_line": 316,
        "end_line": 558,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016512549537648613,
            "pseudo_dstar_susp": 0.00019786307874950534,
            "pseudo_tarantula_susp": 0.00013345789403443215,
            "pseudo_op2_susp": 0.00019786307874950534,
            "pseudo_barinel_susp": 0.00013338668800853674
        }
    },
    {
        "name": "lib.matplotlib.image._ImageBase.draw#603",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image._ImageBase",
        "signature": "lib.matplotlib.image._ImageBase.draw(self, renderer, *args, **kwargs)",
        "snippet": "    def draw(self, renderer, *args, **kwargs):\n        # if not visible, declare victory and return\n        if not self.get_visible():\n            self.stale = False\n            return\n\n        # for empty images, there is nothing to draw!\n        if self.get_array().size == 0:\n            self.stale = False\n            return\n\n        # actually render the image.\n        gc = renderer.new_gc()\n        self._set_gc_clip(gc)\n        gc.set_alpha(self._get_scalar_alpha())\n        gc.set_url(self.get_url())\n        gc.set_gid(self.get_gid())\n\n        if (self._check_unsampled_image(renderer) and\n                self.get_transform().is_affine):\n            self._draw_unsampled_image(renderer, gc)\n        else:\n            im, l, b, trans = self.make_image(\n                renderer, renderer.get_image_magnification())\n            if im is not None:\n                renderer.draw_image(gc, l, b, im)\n        gc.restore()\n        self.stale = False",
        "begin_line": 603,
        "end_line": 630,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016775708773695687,
            "pseudo_dstar_susp": 0.00020559210526315788,
            "pseudo_tarantula_susp": 0.00013743815283122595,
            "pseudo_op2_susp": 0.00020559210526315788,
            "pseudo_barinel_susp": 0.00013743815283122595
        }
    },
    {
        "name": "lib.matplotlib.image._ImageBase.set_data#672",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image._ImageBase",
        "signature": "lib.matplotlib.image._ImageBase.set_data(self, A)",
        "snippet": "    def set_data(self, A):\n        \"\"\"\n        Set the image array.\n\n        Note that this function does *not* update the normalization used.\n\n        Parameters\n        ----------\n        A : array-like or `PIL.Image.Image`\n        \"\"\"\n        try:\n            from PIL import Image\n        except ImportError:\n            pass\n        else:\n            if isinstance(A, Image.Image):\n                A = pil_to_array(A)  # Needed e.g. to apply png palette.\n        self._A = cbook.safe_masked_invalid(A, copy=True)\n\n        if (self._A.dtype != np.uint8 and\n                not np.can_cast(self._A.dtype, float, \"same_kind\")):\n            raise TypeError(\"Image data of dtype {} cannot be converted to \"\n                            \"float\".format(self._A.dtype))\n\n        if not (self._A.ndim == 2\n                or self._A.ndim == 3 and self._A.shape[-1] in [3, 4]):\n            raise TypeError(\"Invalid shape {} for image data\"\n                            .format(self._A.shape))\n\n        if self._A.ndim == 3:\n            # If the input data has values outside the valid range (after\n            # normalisation), we issue a warning and then clip X to the bounds\n            # - otherwise casting wraps extreme values, hiding outliers and\n            # making reliable interpretation impossible.\n            high = 255 if np.issubdtype(self._A.dtype, np.integer) else 1\n            if self._A.min() < 0 or high < self._A.max():\n                _log.warning(\n                    'Clipping input data to the valid range for imshow with '\n                    'RGB data ([0..1] for floats or [0..255] for integers).'\n                )\n                self._A = np.clip(self._A, 0, high)\n            # Cast unsupported integer types to uint8\n            if self._A.dtype != np.uint8 and np.issubdtype(self._A.dtype,\n                                                           np.integer):\n                self._A = self._A.astype(np.uint8)\n\n        self._imcache = None\n        self._rgbacache = None\n        self.stale = True",
        "begin_line": 672,
        "end_line": 720,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.image._ImageBase.get_resample#791",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image._ImageBase",
        "signature": "lib.matplotlib.image._ImageBase.get_resample(self)",
        "snippet": "    def get_resample(self):\n        \"\"\"Return whether image resampling is used.\"\"\"\n        return self._resample",
        "begin_line": 791,
        "end_line": 793,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012812299807815503,
            "pseudo_dstar_susp": 0.00015554518587649713,
            "pseudo_tarantula_susp": 0.00011986096128490951,
            "pseudo_op2_susp": 0.00015554518587649713,
            "pseudo_barinel_susp": 0.00011986096128490951
        }
    },
    {
        "name": "lib.matplotlib.image.AxesImage.__init__#876",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image.AxesImage",
        "signature": "lib.matplotlib.image.AxesImage.__init__(self, ax, cmap=None, norm=None, interpolation=None, origin=None, extent=None, filternorm=1, filterrad=4.0, resample=False, **kwargs)",
        "snippet": "    def __init__(self, ax,\n                 cmap=None,\n                 norm=None,\n                 interpolation=None,\n                 origin=None,\n                 extent=None,\n                 filternorm=1,\n                 filterrad=4.0,\n                 resample=False,\n                 **kwargs\n                 ):\n\n        self._extent = extent\n\n        super().__init__(\n            ax,\n            cmap=cmap,\n            norm=norm,\n            interpolation=interpolation,\n            origin=origin,\n            filternorm=filternorm,\n            filterrad=filterrad,\n            resample=resample,\n            **kwargs\n        )",
        "begin_line": 876,
        "end_line": 900,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013468013468013467,
            "pseudo_dstar_susp": 0.0001764602082230457,
            "pseudo_tarantula_susp": 0.00012091898428053205,
            "pseudo_op2_susp": 0.0001764602082230457,
            "pseudo_barinel_susp": 0.00012091898428053205
        }
    },
    {
        "name": "lib.matplotlib.image.AxesImage._check_unsampled_image#919",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image.AxesImage",
        "signature": "lib.matplotlib.image.AxesImage._check_unsampled_image(self, renderer)",
        "snippet": "    def _check_unsampled_image(self, renderer):\n        \"\"\"\n        Return whether the image would be better drawn unsampled.\n        \"\"\"\n        return (self.get_interpolation() == \"none\"\n                and renderer.option_scale_image())",
        "begin_line": 919,
        "end_line": 924,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015693659761456373,
            "pseudo_dstar_susp": 0.0001820498816675769,
            "pseudo_tarantula_susp": 0.00013345789403443215,
            "pseudo_op2_susp": 0.0001820498816675769,
            "pseudo_barinel_susp": 0.00013338668800853674
        }
    },
    {
        "name": "lib.matplotlib.image.AxesImage.get_cursor_data#966",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image.AxesImage",
        "signature": "lib.matplotlib.image.AxesImage.get_cursor_data(self, event)",
        "snippet": "    def get_cursor_data(self, event):\n        \"\"\"\n        Return the image value at the event position or *None* if the event is\n        outside the image.\n\n        See Also\n        --------\n        matplotlib.artist.Artist.get_cursor_data\n        \"\"\"\n        xmin, xmax, ymin, ymax = self.get_extent()\n        if self.origin == 'upper':\n            ymin, ymax = ymax, ymin\n        arr = self.get_array()\n        data_extent = Bbox([[ymin, xmin], [ymax, xmax]])\n        array_extent = Bbox([[0, 0], arr.shape[:2]])\n        trans = BboxTransform(boxin=data_extent, boxout=array_extent)\n        point = trans.transform([event.ydata, event.xdata])\n        if any(np.isnan(point)):\n            return None\n        i, j = point.astype(int)\n        # Clip the coordinates at array bounds\n        if not (0 <= i < arr.shape[0]) or not (0 <= j < arr.shape[1]):\n            return None\n        else:\n            return arr[i, j]",
        "begin_line": 966,
        "end_line": 990,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.image.AxesImage.format_cursor_data#992",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image.AxesImage",
        "signature": "lib.matplotlib.image.AxesImage.format_cursor_data(self, data)",
        "snippet": "    def format_cursor_data(self, data):\n        if np.ndim(data) == 0 and self.colorbar:\n            return (\n                \"[\"\n                + cbook.strip_math(\n                    self.colorbar.formatter.format_data_short(data)).strip()\n                + \"]\")\n        else:\n            return super().format_cursor_data(data)",
        "begin_line": 992,
        "end_line": 1000,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.image.PcolorImage.set_data#1186",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image.PcolorImage",
        "signature": "lib.matplotlib.image.PcolorImage.set_data(self, x, y, A)",
        "snippet": "    def set_data(self, x, y, A):\n        \"\"\"\n        Set the grid for the rectangle boundaries, and the data values.\n\n        Parameters\n        ----------\n        x, y : 1D array-likes or None\n            Monotonic arrays of shapes (N + 1,) and (M + 1,), respectively,\n            specifying rectangle boundaries.  If None, will default to\n            ``range(N + 1)`` and ``range(M + 1)``, respectively.\n        A : array-like\n            (M, N) ndarray or masked array of values to be colormapped, or\n            (M, N, 3) RGB array, or (M, N, 4) RGBA array.\n        \"\"\"\n        A = cbook.safe_masked_invalid(A, copy=True)\n        if x is None:\n            x = np.arange(0, A.shape[1]+1, dtype=np.float64)\n        else:\n            x = np.array(x, np.float64).ravel()\n        if y is None:\n            y = np.arange(0, A.shape[0]+1, dtype=np.float64)\n        else:\n            y = np.array(y, np.float64).ravel()\n\n        if A.shape[:2] != (y.size-1, x.size-1):\n            raise ValueError(\n                \"Axes don't match array shape. Got %s, expected %s.\" %\n                (A.shape[:2], (y.size - 1, x.size - 1)))\n        if A.ndim not in [2, 3]:\n            raise ValueError(\"A must be 2D or 3D\")\n        if A.ndim == 3 and A.shape[2] == 1:\n            A.shape = A.shape[:2]\n        self.is_grayscale = False\n        if A.ndim == 3:\n            if A.shape[2] in [3, 4]:\n                if ((A[:, :, 0] == A[:, :, 1]).all() and\n                        (A[:, :, 0] == A[:, :, 2]).all()):\n                    self.is_grayscale = True\n            else:\n                raise ValueError(\"3D arrays must have RGB or RGBA as last dim\")\n\n        # For efficient cursor readout, ensure x and y are increasing.\n        if x[-1] < x[0]:\n            x = x[::-1]\n            A = A[:, ::-1]\n        if y[-1] < y[0]:\n            y = y[::-1]\n            A = A[::-1]\n\n        self._A = A\n        self._Ax = x\n        self._Ay = y\n        self._rgbacache = None\n        self.stale = True",
        "begin_line": 1186,
        "end_line": 1239,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.image.FigureImage.__init__#1263",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image.FigureImage",
        "signature": "lib.matplotlib.image.FigureImage.__init__(self, fig, cmap=None, norm=None, offsetx=0, offsety=0, origin=None, **kwargs)",
        "snippet": "    def __init__(self, fig,\n                 cmap=None,\n                 norm=None,\n                 offsetx=0,\n                 offsety=0,\n                 origin=None,\n                 **kwargs\n                 ):\n        \"\"\"\n        cmap is a colors.Colormap instance\n        norm is a colors.Normalize instance to map luminance to 0-1\n\n        kwargs are an optional list of Artist keyword args\n        \"\"\"\n        super().__init__(\n            None,\n            norm=norm,\n            cmap=cmap,\n            origin=origin\n        )\n        self.figure = fig\n        self.ox = offsetx\n        self.oy = offsety\n        self.update(kwargs)\n        self.magnification = 1.0",
        "begin_line": 1263,
        "end_line": 1287,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.image.FigureImage.make_image#1295",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image.FigureImage",
        "signature": "lib.matplotlib.image.FigureImage.make_image(self, renderer, magnification=1.0, unsampled=False)",
        "snippet": "    def make_image(self, renderer, magnification=1.0, unsampled=False):\n        # docstring inherited\n        fac = renderer.dpi/self.figure.dpi\n        # fac here is to account for pdf, eps, svg backends where\n        # figure.dpi is set to 72.  This means we need to scale the\n        # image (using magnification) and offset it appropriately.\n        bbox = Bbox([[self.ox/fac, self.oy/fac],\n                     [(self.ox/fac + self._A.shape[1]),\n                     (self.oy/fac + self._A.shape[0])]])\n        width, height = self.figure.get_size_inches()\n        width *= renderer.dpi\n        height *= renderer.dpi\n        clip = Bbox([[0, 0], [width, height]])\n        return self._make_image(\n            self._A, bbox, bbox, clip, magnification=magnification / fac,\n            unsampled=unsampled, round_to_pixel_border=False)",
        "begin_line": 1295,
        "end_line": 1310,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.image.FigureImage.set_data#1312",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image.FigureImage",
        "signature": "lib.matplotlib.image.FigureImage.set_data(self, A)",
        "snippet": "    def set_data(self, A):\n        \"\"\"Set the image array.\"\"\"\n        cm.ScalarMappable.set_array(self,\n                                    cbook.safe_masked_invalid(A, copy=True))\n        self.stale = True",
        "begin_line": 1312,
        "end_line": 1316,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.image.BboxImage.get_window_extent#1364",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image.BboxImage",
        "signature": "lib.matplotlib.image.BboxImage.get_window_extent(self, renderer=None)",
        "snippet": "    def get_window_extent(self, renderer=None):\n        if renderer is None:\n            renderer = self.get_figure()._cachedRenderer\n\n        if isinstance(self.bbox, BboxBase):\n            return self.bbox\n        elif callable(self.bbox):\n            return self.bbox(renderer)\n        else:\n            raise ValueError(\"unknown type of bbox\")",
        "begin_line": 1364,
        "end_line": 1373,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.image.BboxImage.make_image#1389",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image.BboxImage",
        "signature": "lib.matplotlib.image.BboxImage.make_image(self, renderer, magnification=1.0, unsampled=False)",
        "snippet": "    def make_image(self, renderer, magnification=1.0, unsampled=False):\n        # docstring inherited\n        width, height = renderer.get_canvas_width_height()\n        bbox_in = self.get_window_extent(renderer).frozen()\n        bbox_in._points /= [width, height]\n        bbox_out = self.get_window_extent(renderer)\n        clip = Bbox([[0, 0], [width, height]])\n        self._transform = BboxTransform(Bbox([[0, 0], [1, 1]]), clip)\n        return self._make_image(\n            self._A,\n            bbox_in, bbox_out, clip, magnification, unsampled=unsampled)",
        "begin_line": 1389,
        "end_line": 1399,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.image.imread#1402",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image",
        "signature": "lib.matplotlib.image.imread(fname, format=None)",
        "snippet": "def imread(fname, format=None):\n    \"\"\"\n    Read an image from a file into an array.\n\n    Parameters\n    ----------\n    fname : str or file-like\n        The image file to read: a filename, a URL or a file-like object opened\n        in read-binary mode.\n    format : str, optional\n        The image file format assumed for reading the data. If not\n        given, the format is deduced from the filename.  If nothing can\n        be deduced, PNG is tried.\n\n    Returns\n    -------\n    imagedata : :class:`numpy.array`\n        The image data. The returned array has shape\n\n        - (M, N) for grayscale images.\n        - (M, N, 3) for RGB images.\n        - (M, N, 4) for RGBA images.\n\n    Notes\n    -----\n    Matplotlib can only read PNGs natively. Further image formats are\n    supported via the optional dependency on Pillow. Note, URL strings\n    are not compatible with Pillow. Check the `Pillow documentation`_\n    for more information.\n\n    .. _Pillow documentation: http://pillow.readthedocs.io/en/latest/\n    \"\"\"\n    if format is None:\n        if isinstance(fname, str):\n            parsed = urllib.parse.urlparse(fname)\n            # If the string is a URL (Windows paths appear as if they have a\n            # length-1 scheme), assume png.\n            if len(parsed.scheme) > 1:\n                ext = 'png'\n            else:\n                basename, ext = os.path.splitext(fname)\n                ext = ext.lower()[1:]\n        elif hasattr(fname, 'geturl'):  # Returned by urlopen().\n            # We could try to parse the url's path and use the extension, but\n            # returning png is consistent with the block above.  Note that this\n            # if clause has to come before checking for fname.name as\n            # urlopen(\"file:///...\") also has a name attribute (with the fixed\n            # value \"<urllib response>\").\n            ext = 'png'\n        elif hasattr(fname, 'name'):\n            basename, ext = os.path.splitext(fname.name)\n            ext = ext.lower()[1:]\n        else:\n            ext = 'png'\n    else:\n        ext = format\n    if ext != 'png':\n        try:  # Try to load the image with PIL.\n            from PIL import Image\n        except ImportError:\n            raise ValueError('Only know how to handle PNG; with Pillow '\n                             'installed, Matplotlib can handle more images')\n        with Image.open(fname) as image:\n            return pil_to_array(image)\n    from matplotlib import _png\n    if isinstance(fname, str):\n        parsed = urllib.parse.urlparse(fname)\n        # If fname is a URL, download the data\n        if len(parsed.scheme) > 1:\n            from urllib import request\n            fd = BytesIO(request.urlopen(fname).read())\n            return _png.read_png(fd)\n    with cbook.open_file_cm(fname, \"rb\") as file:\n        return _png.read_png(file)",
        "begin_line": 1402,
        "end_line": 1475,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.image.imsave#1478",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image",
        "signature": "lib.matplotlib.image.imsave(fname, arr, vmin=None, vmax=None, cmap=None, format=None, origin=None, dpi=100, *, metadata=None, pil_kwargs=None)",
        "snippet": "def imsave(fname, arr, vmin=None, vmax=None, cmap=None, format=None,\n           origin=None, dpi=100, *, metadata=None, pil_kwargs=None):\n    \"\"\"\n    Save an array as an image file.\n\n    Parameters\n    ----------\n    fname : str or PathLike or file-like\n        A path or a file-like object to store the image in.\n        If *format* is not set, then the output format is inferred from the\n        extension of *fname*, if any, and from :rc:`savefig.format` otherwise.\n        If *format* is set, it determines the output format.\n    arr : array-like\n        The image data. The shape can be one of\n        MxN (luminance), MxNx3 (RGB) or MxNx4 (RGBA).\n    vmin, vmax : scalar, optional\n        *vmin* and *vmax* set the color scaling for the image by fixing the\n        values that map to the colormap color limits. If either *vmin*\n        or *vmax* is None, that limit is determined from the *arr*\n        min/max value.\n    cmap : str or `~matplotlib.colors.Colormap`, optional\n        A Colormap instance or registered colormap name. The colormap\n        maps scalar data to colors. It is ignored for RGB(A) data.\n        Defaults to :rc:`image.cmap` ('viridis').\n    format : str, optional\n        The file format, e.g. 'png', 'pdf', 'svg', ...  The behavior when this\n        is unset is documented under *fname*.\n    origin : {'upper', 'lower'}, optional\n        Indicates whether the ``(0, 0)`` index of the array is in the upper\n        left or lower left corner of the axes.  Defaults to :rc:`image.origin`\n        ('upper').\n    dpi : int\n        The DPI to store in the metadata of the file.  This does not affect the\n        resolution of the output image.\n    metadata : dict, optional\n        Metadata in the image file.  The supported keys depend on the output\n        format, see the documentation of the respective backends for more\n        information.\n    pil_kwargs : dict, optional\n        If set to a non-None value, always use Pillow to save the figure\n        (regardless of the output format), and pass these keyword arguments to\n        `PIL.Image.save`.\n\n        If the 'pnginfo' key is present, it completely overrides\n        *metadata*, including the default 'Software' key.\n    \"\"\"\n    from matplotlib.figure import Figure\n    from matplotlib import _png\n    if isinstance(fname, os.PathLike):\n        fname = os.fspath(fname)\n    if format is None:\n        format = (Path(fname).suffix[1:] if isinstance(fname, str)\n                  else rcParams[\"savefig.format\"]).lower()\n    if format in [\"pdf\", \"ps\", \"eps\", \"svg\"]:\n        # Vector formats that are not handled by PIL.\n        if pil_kwargs is not None:\n            raise ValueError(\n                f\"Cannot use 'pil_kwargs' when saving to {format}\")\n        fig = Figure(dpi=dpi, frameon=False)\n        fig.figimage(arr, cmap=cmap, vmin=vmin, vmax=vmax, origin=origin,\n                     resize=True)\n        fig.savefig(fname, dpi=dpi, format=format, transparent=True,\n                    metadata=metadata)\n    else:\n        # Don't bother creating an image; this avoids rounding errors on the\n        # size when dividing and then multiplying by dpi.\n        sm = cm.ScalarMappable(cmap=cmap)\n        sm.set_clim(vmin, vmax)\n        if origin is None:\n            origin = rcParams[\"image.origin\"]\n        if origin == \"lower\":\n            arr = arr[::-1]\n        rgba = sm.to_rgba(arr, bytes=True)\n        if format == \"png\" and pil_kwargs is None:\n            with cbook.open_file_cm(fname, \"wb\") as file:\n                _png.write_png(rgba, file, dpi=dpi, metadata=metadata)\n        else:\n            try:\n                from PIL import Image\n                from PIL.PngImagePlugin import PngInfo\n            except ImportError as exc:\n                if pil_kwargs is not None:\n                    raise ImportError(\"Setting 'pil_kwargs' requires Pillow\")\n                else:\n                    raise ImportError(f\"Saving to {format} requires Pillow\")\n            if pil_kwargs is None:\n                pil_kwargs = {}\n            pil_shape = (rgba.shape[1], rgba.shape[0])\n            image = Image.frombuffer(\n                \"RGBA\", pil_shape, rgba, \"raw\", \"RGBA\", 0, 1)\n            if format == \"png\" and metadata:\n                # cf. backend_agg's print_png.\n                if \"pnginfo\" in pil_kwargs:\n                    cbook._warn_external(\"'metadata' is overridden by the \"\n                                         \"'pnginfo' entry in 'pil_kwargs'.\")\n                else:\n                    pnginfo = PngInfo()\n                    for k, v in metadata.items():\n                        pnginfo.add_text(k, v)\n                    pil_kwargs[\"pnginfo\"] = pnginfo\n            if format in [\"jpg\", \"jpeg\"]:\n                format = \"jpeg\"  # Pillow doesn't recognize \"jpg\".\n                color = tuple(\n                    int(x * 255)\n                    for x in mcolors.to_rgb(rcParams[\"savefig.facecolor\"]))\n                background = Image.new(\"RGB\", pil_shape, color)\n                background.paste(image, image)\n                image = background\n            pil_kwargs.setdefault(\"format\", format)\n            pil_kwargs.setdefault(\"dpi\", (dpi, dpi))\n            image.save(fname, **pil_kwargs)",
        "begin_line": 1478,
        "end_line": 1588,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.animation.AbstractMovieWriter.saving#221",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.AbstractMovieWriter",
        "signature": "lib.matplotlib.animation.AbstractMovieWriter.saving(self, fig, outfile, dpi, *args, **kwargs)",
        "snippet": "    def saving(self, fig, outfile, dpi, *args, **kwargs):\n        '''\n        Context manager to facilitate writing the movie file.\n\n        ``*args, **kw`` are any parameters that should be passed to `setup`.\n        '''\n        # This particular sequence is what contextlib.contextmanager wants\n        self.setup(fig, outfile, dpi, *args, **kwargs)\n        try:\n            yield self\n        finally:\n            self.finish()",
        "begin_line": 221,
        "end_line": 232,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.722007722007723e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.animation.MovieWriter.bin_path#415",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.MovieWriter",
        "signature": "lib.matplotlib.animation.MovieWriter.bin_path(cls)",
        "snippet": "    def bin_path(cls):\n        '''\n        Return the binary path to the commandline tool used by a specific\n        subclass. This is a class method so that the tool can be looked for\n        before making a particular MovieWriter subclass available.\n        '''\n        return str(rcParams[cls.exec_key])",
        "begin_line": 415,
        "end_line": 421,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.animation.FFMpegBase.isAvailable#612",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.FFMpegBase",
        "signature": "lib.matplotlib.animation.FFMpegBase.isAvailable(cls)",
        "snippet": "    def isAvailable(cls):\n        return (\n            super().isAvailable()\n            # Ubuntu 12.04 ships a broken ffmpeg binary which we shouldn't use.\n            # NOTE: when removed, remove the same method in AVConvBase.\n            and b'LibAv' not in subprocess.run(\n                [cls.bin_path()], creationflags=subprocess_creation_flags,\n                stdout=subprocess.DEVNULL, stderr=subprocess.PIPE).stderr)",
        "begin_line": 612,
        "end_line": 619,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.animation.HTMLWriter.setup#818",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.HTMLWriter",
        "signature": "lib.matplotlib.animation.HTMLWriter.setup(self, fig, outfile, dpi, frame_dir=None)",
        "snippet": "    def setup(self, fig, outfile, dpi, frame_dir=None):\n        outfile = Path(outfile)\n        cbook._check_in_list(['.html', '.htm'],\n                             outfile_extension=outfile.suffix)\n\n        self._saved_frames = []\n        self._total_bytes = 0\n        self._hit_limit = False\n\n        if not self.embed_frames:\n            if frame_dir is None:\n                frame_dir = outfile.with_name(outfile.stem + '_frames')\n            frame_dir.mkdir(parents=True, exist_ok=True)\n            frame_prefix = frame_dir / 'frame'\n        else:\n            frame_prefix = None\n\n        super().setup(fig, outfile, dpi, frame_prefix, clear_temp=False)",
        "begin_line": 818,
        "end_line": 835,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.animation.HTMLWriter.grab_frame#837",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.HTMLWriter",
        "signature": "lib.matplotlib.animation.HTMLWriter.grab_frame(self, **savefig_kwargs)",
        "snippet": "    def grab_frame(self, **savefig_kwargs):\n        if self.embed_frames:\n            # Just stop processing if we hit the limit\n            if self._hit_limit:\n                return\n            f = BytesIO()\n            self.fig.savefig(f, format=self.frame_format,\n                             dpi=self.dpi, **savefig_kwargs)\n            imgdata64 = base64.encodebytes(f.getvalue()).decode('ascii')\n            self._total_bytes += len(imgdata64)\n            if self._total_bytes >= self._bytes_limit:\n                _log.warning(\n                    \"Animation size has reached %s bytes, exceeding the limit \"\n                    \"of %s. If you're sure you want a larger animation \"\n                    \"embedded, set the animation.embed_limit rc parameter to \"\n                    \"a larger value (in MB). This and further frames will be \"\n                    \"dropped.\", self._total_bytes, self._bytes_limit)\n                self._hit_limit = True\n            else:\n                self._saved_frames.append(imgdata64)\n        else:\n            return super().grab_frame(**savefig_kwargs)",
        "begin_line": 837,
        "end_line": 858,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.animation.Animation.__init__#916",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.Animation",
        "signature": "lib.matplotlib.animation.Animation.__init__(self, fig, event_source=None, blit=False)",
        "snippet": "    def __init__(self, fig, event_source=None, blit=False):\n        self._fig = fig\n        # Disables blitting for backends that don't support it.  This\n        # allows users to request it if available, but still have a\n        # fallback that works if it is not.\n        self._blit = blit and fig.canvas.supports_blit\n\n        # These are the basics of the animation.  The frame sequence represents\n        # information for each frame of the animation and depends on how the\n        # drawing is handled by the subclasses. The event source fires events\n        # that cause the frame sequence to be iterated.\n        self.frame_seq = self.new_frame_seq()\n        self.event_source = event_source\n\n        # Instead of starting the event source now, we connect to the figure's\n        # draw_event, so that we only start once the figure has been drawn.\n        self._first_draw_id = fig.canvas.mpl_connect('draw_event', self._start)\n\n        # Connect to the figure's close_event so that we don't continue to\n        # fire events and try to draw to a deleted figure.\n        self._close_id = self._fig.canvas.mpl_connect('close_event',\n                                                      self._stop)\n        if self._blit:\n            self._setup_blit()",
        "begin_line": 916,
        "end_line": 939,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.animation.Animation.save#966",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.Animation",
        "signature": "lib.matplotlib.animation.Animation.save(self, filename, writer=None, fps=None, dpi=None, codec=None, bitrate=None, extra_args=None, metadata=None, extra_anim=None, savefig_kwargs=None, *, progress_callback=None)",
        "snippet": "    def save(self, filename, writer=None, fps=None, dpi=None, codec=None,\n             bitrate=None, extra_args=None, metadata=None, extra_anim=None,\n             savefig_kwargs=None, *, progress_callback=None):\n        \"\"\"\n        Save the animation as a movie file by drawing every frame.\n\n        Parameters\n        ----------\n        filename : str\n            The output filename, e.g., :file:`mymovie.mp4`.\n\n        writer : :class:`MovieWriter` or str, optional\n            A `MovieWriter` instance to use or a key that identifies a\n            class to use, such as 'ffmpeg'. If ``None``, defaults to\n            :rc:`animation.writer` = 'ffmpeg'.\n\n        fps : number, optional\n           Frames per second in the movie. Defaults to ``None``, which will use\n           the animation's specified interval to set the frames per second.\n\n        dpi : number, optional\n           Controls the dots per inch for the movie frames.  This combined with\n           the figure's size in inches controls the size of the movie.  If\n           ``None``, defaults to :rc:`savefig.dpi`.\n\n        codec : str, optional\n           The video codec to be used. Not all codecs are supported\n           by a given :class:`MovieWriter`. If ``None``, default to\n           :rc:`animation.codec` = 'h264'.\n\n        bitrate : number, optional\n           Specifies the number of bits used per second in the compressed\n           movie, in kilobits per second. A higher number means a higher\n           quality movie, but at the cost of increased file size. If ``None``,\n           defaults to :rc:`animation.bitrate` = -1.\n\n        extra_args : list, optional\n           List of extra string arguments to be passed to the underlying movie\n           utility. If ``None``, defaults to :rc:`animation.extra_args`.\n\n        metadata : Dict[str, str], optional\n           Dictionary of keys and values for metadata to include in\n           the output file. Some keys that may be of use include:\n           title, artist, genre, subject, copyright, srcform, comment.\n\n        extra_anim : list, optional\n           Additional `Animation` objects that should be included\n           in the saved movie file. These need to be from the same\n           `matplotlib.figure.Figure` instance. Also, animation frames will\n           just be simply combined, so there should be a 1:1 correspondence\n           between the frames from the different animations.\n\n        savefig_kwargs : dict, optional\n           Is a dictionary containing keyword arguments to be passed\n           on to the `savefig` command which is called repeatedly to\n           save the individual frames.\n\n        progress_callback : function, optional\n            A callback function that will be called for every frame to notify\n            the saving progress. It must have the signature ::\n\n                def func(current_frame: int, total_frames: int) -> Any\n\n            where *current_frame* is the current frame number and\n            *total_frames* is the total number of frames to be saved.\n            *total_frames* is set to None, if the total number of frames can\n            not be determined. Return values may exist but are ignored.\n\n            Example code to write the progress to stdout::\n\n                progress_callback =\\\n                    lambda i, n: print(f'Saving frame {i} of {n}')\n\n        Notes\n        -----\n        *fps*, *codec*, *bitrate*, *extra_args* and *metadata* are used to\n        construct a `.MovieWriter` instance and can only be passed if\n        *writer* is a string.  If they are passed as non-*None* and *writer*\n        is a `.MovieWriter`, a `RuntimeError` will be raised.\n\n        \"\"\"\n        # If the writer is None, use the rc param to find the name of the one\n        # to use\n        if writer is None:\n            writer = rcParams['animation.writer']\n        elif (not isinstance(writer, str) and\n              any(arg is not None\n                  for arg in (fps, codec, bitrate, extra_args, metadata))):\n            raise RuntimeError('Passing in values for arguments '\n                               'fps, codec, bitrate, extra_args, or metadata '\n                               'is not supported when writer is an existing '\n                               'MovieWriter instance. These should instead be '\n                               'passed as arguments when creating the '\n                               'MovieWriter instance.')\n\n        if savefig_kwargs is None:\n            savefig_kwargs = {}\n\n        # Need to disconnect the first draw callback, since we'll be doing\n        # draws. Otherwise, we'll end up starting the animation.\n        if self._first_draw_id is not None:\n            self._fig.canvas.mpl_disconnect(self._first_draw_id)\n            reconnect_first_draw = True\n        else:\n            reconnect_first_draw = False\n\n        if fps is None and hasattr(self, '_interval'):\n            # Convert interval in ms to frames per second\n            fps = 1000. / self._interval\n\n        # Re-use the savefig DPI for ours if none is given\n        if dpi is None:\n            dpi = rcParams['savefig.dpi']\n        if dpi == 'figure':\n            dpi = self._fig.dpi\n\n        if codec is None:\n            codec = rcParams['animation.codec']\n\n        if bitrate is None:\n            bitrate = rcParams['animation.bitrate']\n\n        all_anim = [self]\n        if extra_anim is not None:\n            all_anim.extend(anim\n                            for anim\n                            in extra_anim if anim._fig is self._fig)\n\n        # If we have the name of a writer, instantiate an instance of the\n        # registered class.\n        if isinstance(writer, str):\n            if writers.is_available(writer):\n                writer = writers[writer](fps, codec, bitrate,\n                                         extra_args=extra_args,\n                                         metadata=metadata)\n            else:\n                alt_writer = next(writers, None)\n                if alt_writer is None:\n                    raise ValueError(\"Cannot save animation: no writers are \"\n                                     \"available. Please install ffmpeg to \"\n                                     \"save animations.\")\n                _log.warning(\"MovieWriter %s unavailable; trying to use %s \"\n                             \"instead.\", writer, alt_writer)\n                writer = alt_writer(\n                    fps, codec, bitrate,\n                    extra_args=extra_args, metadata=metadata)\n        _log.info('Animation.save using %s', type(writer))\n\n        if 'bbox_inches' in savefig_kwargs:\n            _log.warning(\"Warning: discarding the 'bbox_inches' argument in \"\n                         \"'savefig_kwargs' as it may cause frame size \"\n                         \"to vary, which is inappropriate for animation.\")\n            savefig_kwargs.pop('bbox_inches')\n\n        # Create a new sequence of frames for saved data. This is different\n        # from new_frame_seq() to give the ability to save 'live' generated\n        # frame information to be saved later.\n        # TODO: Right now, after closing the figure, saving a movie won't work\n        # since GUI widgets are gone. Either need to remove extra code to\n        # allow for this non-existent use case or find a way to make it work.\n        with rc_context():\n            if rcParams['savefig.bbox'] == 'tight':\n                _log.info(\"Disabling savefig.bbox = 'tight', as it may cause \"\n                          \"frame size to vary, which is inappropriate for \"\n                          \"animation.\")\n                rcParams['savefig.bbox'] = None\n            with writer.saving(self._fig, filename, dpi):\n                for anim in all_anim:\n                    # Clear the initial frame\n                    anim._init_draw()\n                frame_number = 0\n                # TODO: Currently only FuncAnimation has a save_count\n                #       attribute. Can we generalize this to all Animations?\n                save_count_list = [getattr(a, 'save_count', None)\n                                   for a in all_anim]\n                if None in save_count_list:\n                    total_frames = None\n                else:\n                    total_frames = sum(save_count_list)\n                for data in zip(*[a.new_saved_frame_seq() for a in all_anim]):\n                    for anim, d in zip(all_anim, data):\n                        # TODO: See if turning off blit is really necessary\n                        anim._draw_next_frame(d, blit=False)\n                        if progress_callback is not None:\n                            progress_callback(frame_number, total_frames)\n                            frame_number += 1\n                    writer.grab_frame(**savefig_kwargs)\n\n        # Reconnect signal for first draw if necessary\n        if reconnect_first_draw:\n            self._first_draw_id = self._fig.canvas.mpl_connect('draw_event',\n                                                               self._start)",
        "begin_line": 966,
        "end_line": 1157,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.animation.Animation._draw_next_frame#1184",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.Animation",
        "signature": "lib.matplotlib.animation.Animation._draw_next_frame(self, framedata, blit)",
        "snippet": "    def _draw_next_frame(self, framedata, blit):\n        # Breaks down the drawing of the next frame into steps of pre- and\n        # post- draw, as well as the drawing of the frame itself.\n        self._pre_draw(framedata, blit)\n        self._draw_frame(framedata)\n        self._post_draw(framedata, blit)",
        "begin_line": 1184,
        "end_line": 1189,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.animation.Animation._pre_draw#1196",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.Animation",
        "signature": "lib.matplotlib.animation.Animation._pre_draw(self, framedata, blit)",
        "snippet": "    def _pre_draw(self, framedata, blit):\n        # Perform any cleaning or whatnot before the drawing of the frame.\n        # This default implementation allows blit to clear the frame.\n        if blit:\n            self._blit_clear(self._drawn_artists, self._blit_cache)",
        "begin_line": 1196,
        "end_line": 1200,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.animation.Animation._post_draw#1207",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.Animation",
        "signature": "lib.matplotlib.animation.Animation._post_draw(self, framedata, blit)",
        "snippet": "    def _post_draw(self, framedata, blit):\n        # After the frame is rendered, this handles the actual flushing of\n        # the draw, which can be a direct draw_idle() or make use of the\n        # blitting.\n        if blit and self._drawn_artists:\n            self._blit_draw(self._drawn_artists, self._blit_cache)\n        else:\n            self._fig.canvas.draw_idle()",
        "begin_line": 1207,
        "end_line": 1214,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.animation.Animation.to_jshtml#1363",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.Animation",
        "signature": "lib.matplotlib.animation.Animation.to_jshtml(self, fps=None, embed_frames=True, default_mode=None)",
        "snippet": "    def to_jshtml(self, fps=None, embed_frames=True, default_mode=None):\n        \"\"\"Generate HTML representation of the animation\"\"\"\n        if fps is None and hasattr(self, '_interval'):\n            # Convert interval in ms to frames per second\n            fps = 1000 / self._interval\n\n        # If we're not given a default mode, choose one base on the value of\n        # the repeat attribute\n        if default_mode is None:\n            default_mode = 'loop' if self.repeat else 'once'\n\n        if not hasattr(self, \"_html_representation\"):\n            # Can't open a NamedTemporaryFile twice on Windows, so use a\n            # TemporaryDirectory instead.\n            with TemporaryDirectory() as tmpdir:\n                path = Path(tmpdir, \"temp.html\")\n                writer = HTMLWriter(fps=fps,\n                                    embed_frames=embed_frames,\n                                    default_mode=default_mode)\n                self.save(str(path), writer=writer)\n                self._html_representation = path.read_text()\n\n        return self._html_representation",
        "begin_line": 1363,
        "end_line": 1385,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.animation.TimedAnimation.__init__#1423",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.TimedAnimation",
        "signature": "lib.matplotlib.animation.TimedAnimation.__init__(self, fig, interval=200, repeat_delay=None, repeat=True, event_source=None, *args, **kwargs)",
        "snippet": "    def __init__(self, fig, interval=200, repeat_delay=None, repeat=True,\n                 event_source=None, *args, **kwargs):\n        # Store the timing information\n        self._interval = interval\n        self._repeat_delay = repeat_delay\n        self.repeat = repeat\n\n        # If we're not given an event source, create a new timer. This permits\n        # sharing timers between animation objects for syncing animations.\n        if event_source is None:\n            event_source = fig.canvas.new_timer()\n            event_source.interval = self._interval\n\n        Animation.__init__(self, fig, event_source=event_source,\n                           *args, **kwargs)",
        "begin_line": 1423,
        "end_line": 1437,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.animation.FuncAnimation.__init__#1643",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.FuncAnimation",
        "signature": "lib.matplotlib.animation.FuncAnimation.__init__(self, fig, func, frames=None, init_func=None, fargs=None, save_count=None, *, cache_frame_data=True, **kwargs)",
        "snippet": "    def __init__(self, fig, func, frames=None, init_func=None, fargs=None,\n                 save_count=None, *, cache_frame_data=True, **kwargs):\n        if fargs:\n            self._args = fargs\n        else:\n            self._args = ()\n        self._func = func\n        self._init_func = init_func\n\n        # Amount of framedata to keep around for saving movies. This is only\n        # used if we don't know how many frames there will be: in the case\n        # of no generator or in the case of a callable.\n        self.save_count = save_count\n        # Set up a function that creates a new iterable when needed. If nothing\n        # is passed in for frames, just use itertools.count, which will just\n        # keep counting from 0. A callable passed in for frames is assumed to\n        # be a generator. An iterable will be used as is, and anything else\n        # will be treated as a number of frames.\n        if frames is None:\n            self._iter_gen = itertools.count\n        elif callable(frames):\n            self._iter_gen = frames\n        elif np.iterable(frames):\n            if kwargs.get('repeat', True):\n                def iter_frames(frames=frames):\n                    while True:\n                        this, frames = itertools.tee(frames, 2)\n                        yield from this\n                self._iter_gen = iter_frames\n            else:\n                self._iter_gen = lambda: iter(frames)\n            if hasattr(frames, '__len__'):\n                self.save_count = len(frames)\n        else:\n            self._iter_gen = lambda: iter(range(frames))\n            self.save_count = frames\n\n        if self.save_count is None:\n            # If we're passed in and using the default, set save_count to 100.\n            self.save_count = 100\n        else:\n            # itertools.islice returns an error when passed a numpy int instead\n            # of a native python int (http://bugs.python.org/issue30537).\n            # As a workaround, convert save_count to a native python int.\n            self.save_count = int(self.save_count)\n\n        self._cache_frame_data = cache_frame_data\n\n        # Needs to be initialized so the draw functions work without checking\n        self._save_seq = []\n\n        TimedAnimation.__init__(self, fig, **kwargs)\n\n        # Need to reset the saved seq, since right now it will contain data\n        # for a single frame from init, which is not what we want.\n        self._save_seq = []",
        "begin_line": 1643,
        "end_line": 1698,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.animation.FuncAnimation.iter_frames#1667",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.FuncAnimation",
        "signature": "lib.matplotlib.animation.FuncAnimation.iter_frames(frames=frames)",
        "snippet": "                def iter_frames(frames=frames):\n                    while True:\n                        this, frames = itertools.tee(frames, 2)\n                        yield from this",
        "begin_line": 1667,
        "end_line": 1670,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.animation.FuncAnimation.new_frame_seq#1700",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.FuncAnimation",
        "signature": "lib.matplotlib.animation.FuncAnimation.new_frame_seq(self)",
        "snippet": "    def new_frame_seq(self):\n        # Use the generating function to generate a new frame sequence\n        return self._iter_gen()",
        "begin_line": 1700,
        "end_line": 1702,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.animation.FuncAnimation.new_saved_frame_seq#1704",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.FuncAnimation",
        "signature": "lib.matplotlib.animation.FuncAnimation.new_saved_frame_seq(self)",
        "snippet": "    def new_saved_frame_seq(self):\n        # Generate an iterator for the sequence of saved data. If there are\n        # no saved frames, generate a new frame sequence and take the first\n        # save_count entries in it.\n        if self._save_seq:\n            # While iterating we are going to update _save_seq\n            # so make a copy to safely iterate over\n            self._old_saved_seq = list(self._save_seq)\n            return iter(self._old_saved_seq)\n        else:\n            if self.save_count is not None:\n                return itertools.islice(self.new_frame_seq(), self.save_count)\n\n            else:\n                frame_seq = self.new_frame_seq()\n\n                def gen():\n                    try:\n                        for _ in range(100):\n                            yield next(frame_seq)\n                    except StopIteration:\n                        pass\n                    else:\n                        cbook.warn_deprecated(\n                            \"2.2\", message=\"FuncAnimation.save has truncated \"\n                            \"your animation to 100 frames.  In the future, no \"\n                            \"such truncation will occur; please pass \"\n                            \"'save_count' accordingly.\")\n\n                return gen()",
        "begin_line": 1704,
        "end_line": 1733,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.animation.FuncAnimation._init_draw#1735",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.FuncAnimation",
        "signature": "lib.matplotlib.animation.FuncAnimation._init_draw(self)",
        "snippet": "    def _init_draw(self):\n        # Initialize the drawing either using the given init_func or by\n        # calling the draw function with the first item of the frame sequence.\n        # For blitting, the init_func should return a sequence of modified\n        # artists.\n        if self._init_func is None:\n            self._draw_frame(next(self.new_frame_seq()))\n\n        else:\n            self._drawn_artists = self._init_func()\n            if self._blit:\n                if self._drawn_artists is None:\n                    raise RuntimeError('The init_func must return a '\n                                       'sequence of Artist objects.')\n                for a in self._drawn_artists:\n                    a.set_animated(self._blit)\n        self._save_seq = []",
        "begin_line": 1735,
        "end_line": 1751,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.animation.FuncAnimation._draw_frame#1753",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.FuncAnimation",
        "signature": "lib.matplotlib.animation.FuncAnimation._draw_frame(self, framedata)",
        "snippet": "    def _draw_frame(self, framedata):\n        if self._cache_frame_data:\n            # Save the data for potential saving of movies.\n            self._save_seq.append(framedata)\n\n        # Make sure to respect save_count (keep only the last save_count\n        # around)\n        self._save_seq = self._save_seq[-self.save_count:]\n\n        # Call the func with framedata and args. If blitting is desired,\n        # func needs to return a sequence of any artists that were modified.\n        self._drawn_artists = self._func(framedata, *self._args)\n        if self._blit:\n            if self._drawn_artists is None:\n                raise RuntimeError('The animation function must return a '\n                                   'sequence of Artist objects.')\n            self._drawn_artists = sorted(self._drawn_artists,\n                                         key=lambda x: x.get_zorder())\n\n            for a in self._drawn_artists:\n                a.set_animated(self._blit)",
        "begin_line": 1753,
        "end_line": 1773,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.units._is_natively_supported#58",
        "src_path": "lib/matplotlib/units.py",
        "class_name": "lib.matplotlib.units",
        "signature": "lib.matplotlib.units._is_natively_supported(x)",
        "snippet": "def _is_natively_supported(x):\n    \"\"\"\n    Return whether *x* is of a type that Matplotlib natively supports or an\n    array of objects of such types.\n    \"\"\"\n    # Matplotlib natively supports all number types except Decimal.\n    if np.iterable(x):\n        # Assume lists are homogeneous as other functions in unit system.\n        for thisx in x:\n            if thisx is ma.masked:\n                continue\n            return isinstance(thisx, Number) and not isinstance(thisx, Decimal)\n    else:\n        return isinstance(x, Number) and not isinstance(x, Decimal)",
        "begin_line": 58,
        "end_line": 71,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.610929294466855e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.units.AxisInfo.__init__#81",
        "src_path": "lib/matplotlib/units.py",
        "class_name": "lib.matplotlib.units.AxisInfo",
        "signature": "lib.matplotlib.units.AxisInfo.__init__(self, majloc=None, minloc=None, majfmt=None, minfmt=None, label=None, default_limits=None)",
        "snippet": "    def __init__(self, majloc=None, minloc=None,\n                 majfmt=None, minfmt=None, label=None,\n                 default_limits=None):\n        \"\"\"\n        Parameters\n        ----------\n        majloc, minloc : Locator, optional\n            Tick locators for the major and minor ticks.\n        majfmt, minfmt : Formatter, optional\n            Tick formatters for the major and minor ticks.\n        label : str, optional\n            The default axis label.\n        default_limits : optional\n            The default min and max limits of the axis if no data has\n            been plotted.\n\n        Notes\n        -----\n        If any of the above are ``None``, the axis will simply use the\n        default value.\n        \"\"\"\n        self.majloc = majloc\n        self.minloc = minloc\n        self.majfmt = majfmt\n        self.minfmt = minfmt\n        self.label = label\n        self.default_limits = default_limits",
        "begin_line": 81,
        "end_line": 107,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.593591009188245e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.units.ConversionInterface.is_numlike#141",
        "src_path": "lib/matplotlib/units.py",
        "class_name": "lib.matplotlib.units.ConversionInterface",
        "signature": "lib.matplotlib.units.ConversionInterface.is_numlike(x)",
        "snippet": "    def is_numlike(x):\n        \"\"\"\n        The Matplotlib datalim, autoscaling, locators etc work with scalars\n        which are the units converted to floats given the current unit.  The\n        converter may be passed these floats, or arrays of them, even when\n        units are set.\n        \"\"\"\n        if np.iterable(x):\n            for thisx in x:\n                if thisx is ma.masked:\n                    continue\n                return isinstance(thisx, Number)\n        else:\n            return isinstance(x, Number)",
        "begin_line": 141,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.596475235490732e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.units.Registry.get_converter#197",
        "src_path": "lib/matplotlib/units.py",
        "class_name": "lib.matplotlib.units.Registry",
        "signature": "lib.matplotlib.units.Registry.get_converter(self, x)",
        "snippet": "    def get_converter(self, x):\n        \"\"\"Get the converter interface instance for *x*, or None.\"\"\"\n        if hasattr(x, \"values\"):\n            x = x.values  # Unpack pandas Series and DataFrames.\n        if isinstance(x, np.ndarray):\n            # In case x in a masked array, access the underlying data (only its\n            # type matters).  If x is a regular ndarray, getdata() just returns\n            # the array itself.\n            x = np.ma.getdata(x).ravel()\n            # If there are no elements in x, infer the units from its dtype\n            if not x.size:\n                return self.get_converter(np.array([0], dtype=x.dtype))\n        for cls in type(x).__mro__:  # Look up in the cache.\n            try:\n                return self[cls]\n            except KeyError:\n                pass\n        try:  # If cache lookup fails, look up based on first element...\n            first = cbook.safe_first_element(x)\n        except (TypeError, StopIteration):\n            pass\n        else:\n            # ... and avoid infinite recursion for pathological iterables for\n            # which indexing returns instances of the same iterable class.\n            if type(first) is not type(x):\n                return self.get_converter(first)\n        return None",
        "begin_line": 197,
        "end_line": 223,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.635336336565625e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.text._wrap_text#26",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text",
        "signature": "lib.matplotlib.text._wrap_text(textobj)",
        "snippet": "def _wrap_text(textobj):\n    \"\"\"Temporarily inserts newlines to the text if the wrap option is enabled.\n    \"\"\"\n    if textobj.get_wrap():\n        old_text = textobj.get_text()\n        try:\n            textobj.set_text(textobj._get_wrapped_text())\n            yield textobj\n        finally:\n            textobj.set_text(old_text)\n    else:\n        yield textobj",
        "begin_line": 26,
        "end_line": 37,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.011235955056179775,
            "pseudo_dstar_susp": 0.009708737864077669,
            "pseudo_tarantula_susp": 0.00038022813688212925,
            "pseudo_op2_susp": 0.009708737864077669,
            "pseudo_barinel_susp": 0.00038022813688212925
        }
    },
    {
        "name": "lib.matplotlib.text.get_rotation#41",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text",
        "signature": "lib.matplotlib.text.get_rotation(rotation)",
        "snippet": "def get_rotation(rotation):\n    \"\"\"\n    Return the text angle as float between 0 and 360 degrees.\n\n    *rotation* may be 'horizontal', 'vertical', or a numeric value in degrees.\n    \"\"\"\n    try:\n        return float(rotation) % 360\n    except (ValueError, TypeError):\n        if cbook._str_equal(rotation, 'horizontal') or rotation is None:\n            return 0.\n        elif cbook._str_equal(rotation, 'vertical'):\n            return 90.\n        else:\n            raise ValueError(\"rotation is {!r}; expected either 'horizontal', \"\n                             \"'vertical', numeric value, or None\"\n                             .format(rotation))",
        "begin_line": 41,
        "end_line": 57,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006666666666666667,
            "pseudo_dstar_susp": 0.00558659217877095,
            "pseudo_tarantula_susp": 0.000390015600624025,
            "pseudo_op2_susp": 0.00558659217877095,
            "pseudo_barinel_susp": 0.000390015600624025
        }
    },
    {
        "name": "lib.matplotlib.text._get_textbox#60",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text",
        "signature": "lib.matplotlib.text._get_textbox(text, renderer)",
        "snippet": "def _get_textbox(text, renderer):\n    \"\"\"\n    Calculate the bounding box of the text. Unlike\n    :meth:`matplotlib.text.Text.get_extents` method, The bbox size of\n    the text before the rotation is calculated.\n    \"\"\"\n    # TODO : This function may move into the Text class as a method. As a\n    # matter of fact, The information from the _get_textbox function\n    # should be available during the Text._get_layout() call, which is\n    # called within the _get_textbox. So, it would better to move this\n    # function as a method with some refactoring of _get_layout method.\n\n    projected_xs = []\n    projected_ys = []\n\n    theta = np.deg2rad(text.get_rotation())\n    tr = Affine2D().rotate(-theta)\n\n    _, parts, d = text._get_layout(renderer)\n\n    for t, wh, x, y in parts:\n        w, h = wh\n\n        xt1, yt1 = tr.transform((x, y))\n        yt1 -= d\n        xt2, yt2 = xt1 + w, yt1 + h\n\n        projected_xs.extend([xt1, xt2])\n        projected_ys.extend([yt1, yt2])\n\n    xt_box, yt_box = min(projected_xs), min(projected_ys)\n    w_box, h_box = max(projected_xs) - xt_box, max(projected_ys) - yt_box\n\n    x_box, y_box = Affine2D().rotate(theta).transform((xt_box, yt_box))\n\n    return x_box, y_box, w_box, h_box",
        "begin_line": 60,
        "end_line": 95,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001424298532972511,
            "pseudo_dstar_susp": 0.0001897893338394382,
            "pseudo_tarantula_susp": 0.00012342631449024932,
            "pseudo_op2_susp": 0.0001897893338394382,
            "pseudo_barinel_susp": 0.00012342631449024932
        }
    },
    {
        "name": "lib.matplotlib.text.Text.__init__#121",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.__init__(self, x=0, y=0, text='', color=None, verticalalignment='baseline', horizontalalignment='left', multialignment=None, fontproperties=None, rotation=None, linespacing=None, rotation_mode=None, usetex=None, wrap=False, **kwargs)",
        "snippet": "    def __init__(self,\n                 x=0, y=0, text='',\n                 color=None,           # defaults to rc params\n                 verticalalignment='baseline',\n                 horizontalalignment='left',\n                 multialignment=None,\n                 fontproperties=None,  # defaults to FontProperties()\n                 rotation=None,\n                 linespacing=None,\n                 rotation_mode=None,\n                 usetex=None,          # defaults to rcParams['text.usetex']\n                 wrap=False,\n                 **kwargs\n                 ):\n        \"\"\"\n        Create a `.Text` instance at *x*, *y* with string *text*.\n\n        Valid keyword arguments are:\n\n        %(Text)s\n        \"\"\"\n        Artist.__init__(self)\n        self._x, self._y = x, y\n\n        if color is None:\n            color = rcParams['text.color']\n        if fontproperties is None:\n            fontproperties = FontProperties()\n        elif isinstance(fontproperties, str):\n            fontproperties = FontProperties(fontproperties)\n\n        self._text = ''\n        self.set_text(text)\n        self.set_color(color)\n        self.set_usetex(usetex)\n        self.set_wrap(wrap)\n        self.set_verticalalignment(verticalalignment)\n        self.set_horizontalalignment(horizontalalignment)\n        self._multialignment = multialignment\n        self._rotation = rotation\n        self._fontproperties = fontproperties\n        self._bbox_patch = None  # a FancyBboxPatch instance\n        self._renderer = None\n        if linespacing is None:\n            linespacing = 1.2   # Maybe use rcParam later.\n        self._linespacing = linespacing\n        self.set_rotation_mode(rotation_mode)\n        self.update(kwargs)",
        "begin_line": 121,
        "end_line": 168,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007407407407407408,
            "pseudo_dstar_susp": 0.004975124378109453,
            "pseudo_tarantula_susp": 0.0004426737494466578,
            "pseudo_op2_susp": 0.004975124378109453,
            "pseudo_barinel_susp": 0.0004426737494466578
        }
    },
    {
        "name": "lib.matplotlib.text.Text._get_multialignment#230",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text._get_multialignment(self)",
        "snippet": "    def _get_multialignment(self):\n        if self._multialignment is not None:\n            return self._multialignment\n        else:\n            return self._horizontalalignment",
        "begin_line": 230,
        "end_line": 234,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001321003963011889,
            "pseudo_dstar_susp": 0.0017574692442882249,
            "pseudo_tarantula_susp": 0.0004302925989672978,
            "pseudo_op2_susp": 0.0017574692442882249,
            "pseudo_barinel_susp": 0.0004302925989672978
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_rotation_mode#240",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_rotation_mode(self, m)",
        "snippet": "    def set_rotation_mode(self, m):\n        \"\"\"\n        Set text rotation mode.\n\n        Parameters\n        ----------\n        m : {None, 'default', 'anchor'}\n            If ``None`` or ``\"default\"``, the text will be first rotated, then\n            aligned according to their horizontal and vertical alignments.  If\n            ``\"anchor\"``, then alignment occurs before rotation.\n        \"\"\"\n        cbook._check_in_list([\"anchor\", \"default\", None], rotation_mode=m)\n        self._rotation_mode = m\n        self.stale = True",
        "begin_line": 240,
        "end_line": 253,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010787486515641855,
            "pseudo_dstar_susp": 0.0022026431718061676,
            "pseudo_tarantula_susp": 0.00029895366218236175,
            "pseudo_op2_susp": 0.0022026431718061676,
            "pseudo_barinel_susp": 0.00029895366218236175
        }
    },
    {
        "name": "lib.matplotlib.text.Text.get_rotation_mode#255",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.get_rotation_mode(self)",
        "snippet": "    def get_rotation_mode(self):\n        \"\"\"Get the text rotation mode.\"\"\"\n        return self._rotation_mode",
        "begin_line": 255,
        "end_line": 257,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002183406113537118,
            "pseudo_dstar_susp": 0.0018083182640144665,
            "pseudo_tarantula_susp": 0.0005235602094240838,
            "pseudo_op2_susp": 0.0018083182640144665,
            "pseudo_barinel_susp": 0.0005235602094240838
        }
    },
    {
        "name": "lib.matplotlib.text.Text.update_from#259",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.update_from(self, other)",
        "snippet": "    def update_from(self, other):\n        \"\"\"Copy properties from other to self.\"\"\"\n        Artist.update_from(self, other)\n        self._color = other._color\n        self._multialignment = other._multialignment\n        self._verticalalignment = other._verticalalignment\n        self._horizontalalignment = other._horizontalalignment\n        self._fontproperties = other._fontproperties.copy()\n        self._rotation = other._rotation\n        self._picker = other._picker\n        self._linespacing = other._linespacing\n        self.stale = True",
        "begin_line": 259,
        "end_line": 270,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004730368968779565,
            "pseudo_dstar_susp": 0.0003769317753486619,
            "pseudo_tarantula_susp": 0.00018542555164101615,
            "pseudo_op2_susp": 0.0003769317753486619,
            "pseudo_barinel_susp": 0.00018542555164101615
        }
    },
    {
        "name": "lib.matplotlib.text.Text._get_layout#272",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text._get_layout(self, renderer)",
        "snippet": "    def _get_layout(self, renderer):\n        \"\"\"\n        return the extent (bbox) of the text together with\n        multiple-alignment information. Note that it returns an extent\n        of a rotated text when necessary.\n        \"\"\"\n        key = self.get_prop_tup(renderer=renderer)\n        if key in self._cached:\n            return self._cached[key]\n\n        thisx, thisy = 0.0, 0.0\n        lines = self.get_text().split(\"\\n\")  # Ensures lines is not empty.\n\n        ws = []\n        hs = []\n        xs = []\n        ys = []\n\n        # Full vertical extent of font, including ascenders and descenders:\n        _, lp_h, lp_d = renderer.get_text_width_height_descent(\n            \"lp\", self._fontproperties,\n            ismath=\"TeX\" if self.get_usetex() else False)\n        min_dy = (lp_h - lp_d) * self._linespacing\n\n        for i, line in enumerate(lines):\n            clean_line, ismath = self._preprocess_math(line)\n            if clean_line:\n                w, h, d = renderer.get_text_width_height_descent(\n                    clean_line, self._fontproperties, ismath=ismath)\n            else:\n                w = h = d = 0\n\n            # For multiline text, increase the line spacing when the text\n            # net-height (excluding baseline) is larger than that of a \"l\"\n            # (e.g., use of superscripts), which seems what TeX does.\n            h = max(h, lp_h)\n            d = max(d, lp_d)\n\n            ws.append(w)\n            hs.append(h)\n\n            # Metrics of the last line that are needed later:\n            baseline = (h - d) - thisy\n\n            if i == 0:\n                # position at baseline\n                thisy = -(h - d)\n            else:\n                # put baseline a good distance from bottom of previous line\n                thisy -= max(min_dy, (h - d) * self._linespacing)\n\n            xs.append(thisx)  # == 0.\n            ys.append(thisy)\n\n            thisy -= d\n\n        # Metrics of the last line that are needed later:\n        descent = d\n\n        # Bounding box definition:\n        width = max(ws)\n        xmin = 0\n        xmax = width\n        ymax = 0\n        ymin = ys[-1] - descent  # baseline of last line minus its descent\n        height = ymax - ymin\n\n        # get the rotation matrix\n        M = Affine2D().rotate_deg(self.get_rotation())\n\n        # now offset the individual text lines within the box\n        malign = self._get_multialignment()\n        if malign == 'left':\n            offset_layout = [(x, y) for x, y in zip(xs, ys)]\n        elif malign == 'center':\n            offset_layout = [(x + width / 2 - w / 2, y)\n                             for x, y, w in zip(xs, ys, ws)]\n        elif malign == 'right':\n            offset_layout = [(x + width - w, y)\n                             for x, y, w in zip(xs, ys, ws)]\n\n        # the corners of the unrotated bounding box\n        corners_horiz = np.array(\n            [(xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)])\n\n        # now rotate the bbox\n        corners_rotated = M.transform(corners_horiz)\n        # compute the bounds of the rotated box\n        xmin = corners_rotated[:, 0].min()\n        xmax = corners_rotated[:, 0].max()\n        ymin = corners_rotated[:, 1].min()\n        ymax = corners_rotated[:, 1].max()\n        width = xmax - xmin\n        height = ymax - ymin\n\n        # Now move the box to the target position offset the display\n        # bbox by alignment\n        halign = self._horizontalalignment\n        valign = self._verticalalignment\n\n        rotation_mode = self.get_rotation_mode()\n        if rotation_mode != \"anchor\":\n            # compute the text location in display coords and the offsets\n            # necessary to align the bbox with that location\n            if halign == 'center':\n                offsetx = (xmin + xmax) / 2\n            elif halign == 'right':\n                offsetx = xmax\n            else:\n                offsetx = xmin\n\n            if valign == 'center':\n                offsety = (ymin + ymax) / 2\n            elif valign == 'top':\n                offsety = ymax\n            elif valign == 'baseline':\n                offsety = ymin + descent\n            elif valign == 'center_baseline':\n                offsety = ymin + height - baseline / 2.0\n            else:\n                offsety = ymin\n        else:\n            xmin1, ymin1 = corners_horiz[0]\n            xmax1, ymax1 = corners_horiz[2]\n\n            if halign == 'center':\n                offsetx = (xmin1 + xmax1) / 2.0\n            elif halign == 'right':\n                offsetx = xmax1\n            else:\n                offsetx = xmin1\n\n            if valign == 'center':\n                offsety = (ymin1 + ymax1) / 2.0\n            elif valign == 'top':\n                offsety = ymax1\n            elif valign == 'baseline':\n                offsety = ymax1 - baseline\n            elif valign == 'center_baseline':\n                offsety = ymax1 - baseline / 2.0\n            else:\n                offsety = ymin1\n\n            offsetx, offsety = M.transform((offsetx, offsety))\n\n        xmin -= offsetx\n        ymin -= offsety\n\n        bbox = Bbox.from_bounds(xmin, ymin, width, height)\n\n        # now rotate the positions around the first (x, y) position\n        xys = M.transform(offset_layout) - (offsetx, offsety)\n\n        ret = bbox, list(zip(lines, zip(ws, hs), *xys.T)), descent\n        self._cached[key] = ret\n        return ret",
        "begin_line": 272,
        "end_line": 427,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0053475935828877,
            "pseudo_dstar_susp": 0.00205761316872428,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00205761316872428,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_bbox#429",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_bbox(self, rectprops)",
        "snippet": "    def set_bbox(self, rectprops):\n        \"\"\"\n        Draw a bounding box around self.\n\n        Parameters\n        ----------\n        rectprops : dict with properties for `.patches.FancyBboxPatch`\n             The default boxstyle is 'square'. The mutation\n             scale of the `.patches.FancyBboxPatch` is set to the fontsize.\n\n        Examples\n        --------\n        ::\n\n            t.set_bbox(dict(facecolor='red', alpha=0.5))\n        \"\"\"\n\n        if rectprops is not None:\n            props = rectprops.copy()\n            boxstyle = props.pop(\"boxstyle\", None)\n            pad = props.pop(\"pad\", None)\n            if boxstyle is None:\n                boxstyle = \"square\"\n                if pad is None:\n                    pad = 4  # points\n                pad /= self.get_size()  # to fraction of font size\n            else:\n                if pad is None:\n                    pad = 0.3\n\n            # boxstyle could be a callable or a string\n            if isinstance(boxstyle, str) and \"pad\" not in boxstyle:\n                boxstyle += \",pad=%0.2f\" % pad\n\n            bbox_transmuter = props.pop(\"bbox_transmuter\", None)\n\n            self._bbox_patch = FancyBboxPatch(\n                                    (0., 0.),\n                                    1., 1.,\n                                    boxstyle=boxstyle,\n                                    bbox_transmuter=bbox_transmuter,\n                                    transform=IdentityTransform(),\n                                    **props)\n        else:\n            self._bbox_patch = None\n\n        self._update_clip_properties()",
        "begin_line": 429,
        "end_line": 475,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.text.Text._draw_bbox#512",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text._draw_bbox(self, renderer, posx, posy)",
        "snippet": "    def _draw_bbox(self, renderer, posx, posy):\n        \"\"\"\n        Update the location and size of the bbox (`.patches.FancyBboxPatch`),\n        and draw.\n        \"\"\"\n\n        x_box, y_box, w_box, h_box = _get_textbox(self, renderer)\n        self._bbox_patch.set_bounds(0., 0., w_box, h_box)\n        theta = np.deg2rad(self.get_rotation())\n        tr = Affine2D().rotate(theta)\n        tr = tr.translate(posx + x_box, posy + y_box)\n        self._bbox_patch.set_transform(tr)\n        fontsize_in_pixel = renderer.points_to_pixels(self.get_size())\n        self._bbox_patch.set_mutation_scale(fontsize_in_pixel)\n        self._bbox_patch.draw(renderer)",
        "begin_line": 512,
        "end_line": 526,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.text.Text._update_clip_properties#528",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text._update_clip_properties(self)",
        "snippet": "    def _update_clip_properties(self):\n        clipprops = dict(clip_box=self.clipbox,\n                         clip_path=self._clippath,\n                         clip_on=self._clipon)\n        if self._bbox_patch:\n            self._bbox_patch.update(clipprops)",
        "begin_line": 528,
        "end_line": 533,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_wrap#554",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_wrap(self, wrap)",
        "snippet": "    def set_wrap(self, wrap):\n        \"\"\"Set the wrapping state for the text.\n\n        Parameters\n        ----------\n        wrap : bool\n        \"\"\"\n        self._wrap = wrap",
        "begin_line": 554,
        "end_line": 561,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002860411899313501,
            "pseudo_dstar_susp": 0.00025687130747495504,
            "pseudo_tarantula_susp": 0.0003170577045022194,
            "pseudo_op2_susp": 0.00025687130747495504,
            "pseudo_barinel_susp": 0.0003170577045022194
        }
    },
    {
        "name": "lib.matplotlib.text.Text.draw#671",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        \"\"\"\n        Draws the `.Text` object to the given *renderer*.\n        \"\"\"\n        if renderer is not None:\n            self._renderer = renderer\n        if not self.get_visible():\n            return\n        if self.get_text() == '':\n            return\n\n        renderer.open_group('text', self.get_gid())\n\n        with _wrap_text(self) as textobj:\n            bbox, info, descent = textobj._get_layout(renderer)\n            trans = textobj.get_transform()\n\n            # don't use textobj.get_position here, which refers to text\n            # position in Text, and dash position in TextWithDash:\n            posx = float(textobj.convert_xunits(textobj._x))\n            posy = float(textobj.convert_yunits(textobj._y))\n            posx, posy = trans.transform((posx, posy))\n            if not np.isfinite(posx) or not np.isfinite(posy):\n                _log.warning(\"posx and posy should be finite values\")\n                return\n            canvasw, canvash = renderer.get_canvas_width_height()\n\n            # draw the FancyBboxPatch\n            if textobj._bbox_patch:\n                textobj._draw_bbox(renderer, posx, posy)\n\n            gc = renderer.new_gc()\n            gc.set_foreground(textobj.get_color())\n            gc.set_alpha(textobj.get_alpha())\n            gc.set_url(textobj._url)\n            textobj._set_gc_clip(gc)\n\n            angle = textobj.get_rotation()\n\n            for line, wh, x, y in info:\n\n                mtext = textobj if len(info) == 1 else None\n                x = x + posx\n                y = y + posy\n                if renderer.flipy():\n                    y = canvash - y\n                clean_line, ismath = textobj._preprocess_math(line)\n\n                if textobj.get_path_effects():\n                    from matplotlib.patheffects import PathEffectRenderer\n                    textrenderer = PathEffectRenderer(\n                                        textobj.get_path_effects(), renderer)\n                else:\n                    textrenderer = renderer\n\n                if textobj.get_usetex():\n                    textrenderer.draw_tex(gc, x, y, clean_line,\n                                          textobj._fontproperties, angle,\n                                          mtext=mtext)\n                else:\n                    textrenderer.draw_text(gc, x, y, clean_line,\n                                           textobj._fontproperties, angle,\n                                           ismath=ismath, mtext=mtext)\n\n        gc.restore()\n        renderer.close_group('text')\n        self.stale = False",
        "begin_line": 671,
        "end_line": 737,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022624434389140274,
            "pseudo_dstar_susp": 0.001996007984031936,
            "pseudo_tarantula_susp": 0.0005279831045406547,
            "pseudo_op2_susp": 0.001996007984031936,
            "pseudo_barinel_susp": 0.0005279831045406547
        }
    },
    {
        "name": "lib.matplotlib.text.Text.get_color#739",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.get_color(self)",
        "snippet": "    def get_color(self):\n        \"Return the color of the text\"\n        return self._color",
        "begin_line": 739,
        "end_line": 741,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019916351324437363,
            "pseudo_dstar_susp": 0.00016353229762878168,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00016353229762878168,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.text.Text.get_unitless_position#824",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.get_unitless_position(self)",
        "snippet": "    def get_unitless_position(self):\n        \"Return the unitless position of the text as a tuple (*x*, *y*)\"\n        # This will get the position with all unit information stripped away.\n        # This is here for convenience since it is done in several locations.\n        x = float(self.convert_xunits(self._x))\n        y = float(self.convert_yunits(self._y))\n        return x, y",
        "begin_line": 824,
        "end_line": 830,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001367053998632946,
            "pseudo_dstar_susp": 0.0001579778830963665,
            "pseudo_tarantula_susp": 0.000132013201320132,
            "pseudo_op2_susp": 0.0001579778830963665,
            "pseudo_barinel_susp": 0.000132013201320132
        }
    },
    {
        "name": "lib.matplotlib.text.Text.get_position#832",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.get_position(self)",
        "snippet": "    def get_position(self):\n        \"Return the position of the text as a tuple (*x*, *y*)\"\n        # This should return the same data (possible unitized) as was\n        # specified with 'set_x' and 'set_y'.\n        return self._x, self._y",
        "begin_line": 832,
        "end_line": 836,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003189792663476874,
            "pseudo_dstar_susp": 0.0003291639236339697,
            "pseudo_tarantula_susp": 0.00018758206715438003,
            "pseudo_op2_susp": 0.0003291639236339697,
            "pseudo_barinel_susp": 0.00018758206715438003
        }
    },
    {
        "name": "lib.matplotlib.text.Text.get_prop_tup#838",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.get_prop_tup(self, renderer=None)",
        "snippet": "    def get_prop_tup(self, renderer=None):\n        \"\"\"\n        Return a hashable tuple of properties.\n\n        Not intended to be human readable, but useful for backends who\n        want to cache derived information about text (e.g., layouts) and\n        need to know if the text has changed.\n        \"\"\"\n        x, y = self.get_unitless_position()\n        renderer = renderer or self._renderer\n        return (x, y, self.get_text(), self._color,\n                self._verticalalignment, self._horizontalalignment,\n                hash(self._fontproperties),\n                self._rotation, self._rotation_mode,\n                self.figure.dpi, weakref.ref(renderer),\n                self._linespacing\n                )",
        "begin_line": 838,
        "end_line": 854,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002183406113537118,
            "pseudo_dstar_susp": 0.0016863406408094434,
            "pseudo_tarantula_susp": 0.0005235602094240838,
            "pseudo_op2_susp": 0.0016863406408094434,
            "pseudo_barinel_susp": 0.0005235602094240838
        }
    },
    {
        "name": "lib.matplotlib.text.Text.get_text#856",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.get_text(self)",
        "snippet": "    def get_text(self):\n        \"Get the text as string\"\n        return self._text",
        "begin_line": 856,
        "end_line": 858,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017921146953405018,
            "pseudo_dstar_susp": 0.0012903225806451613,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0012903225806451613,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.text.Text.get_window_extent#867",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.get_window_extent(self, renderer=None, dpi=None)",
        "snippet": "    def get_window_extent(self, renderer=None, dpi=None):\n        \"\"\"\n        Return the `.Bbox` bounding the text, in display units.\n\n        In addition to being used internally, this is useful for specifying\n        clickable regions in a png file on a web page.\n\n        Parameters\n        ----------\n        renderer : Renderer, optional\n            A renderer is needed to compute the bounding box.  If the artist\n            has already been drawn, the renderer is cached; thus, it is only\n            necessary to pass this argument when calling `get_window_extent`\n            before the first `draw`.  In practice, it is usually easier to\n            trigger a draw first (e.g. by saving the figure).\n\n        dpi : float, optional\n            The dpi value for computing the bbox, defaults to\n            ``self.figure.dpi`` (*not* the renderer dpi); should be set e.g. if\n            to match regions with a figure saved with a custom dpi value.\n        \"\"\"\n        #return _unit_box\n        if not self.get_visible():\n            return Bbox.unit()\n        if dpi is not None:\n            dpi_orig = self.figure.dpi\n            self.figure.dpi = dpi\n        if self.get_text() == '':\n            tx, ty = self._get_xy_display()\n            return Bbox.from_bounds(tx, ty, 0, 0)\n\n        if renderer is not None:\n            self._renderer = renderer\n        if self._renderer is None:\n            self._renderer = self.figure._cachedRenderer\n        if self._renderer is None:\n            raise RuntimeError('Cannot get window extent w/o renderer')\n\n        bbox, info, descent = self._get_layout(self._renderer)\n        x, y = self.get_unitless_position()\n        x, y = self.get_transform().transform((x, y))\n        bbox = bbox.translated(x, y)\n        if dpi is not None:\n            self.figure.dpi = dpi_orig\n        return bbox",
        "begin_line": 867,
        "end_line": 911,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003109452736318408,
            "pseudo_dstar_susp": 0.00032278889606197545,
            "pseudo_tarantula_susp": 0.0001858736059479554,
            "pseudo_op2_susp": 0.00032278889606197545,
            "pseudo_barinel_susp": 0.0001858736059479554
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_color#933",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_color(self, color)",
        "snippet": "    def set_color(self, color):\n        \"\"\"\n        Set the foreground color of the text\n\n        Parameters\n        ----------\n        color : color\n        \"\"\"\n        # Make sure it is hashable, or get_prop_tup will fail.\n        try:\n            hash(color)\n        except TypeError:\n            color = tuple(color)\n        self._color = color\n        self.stale = True",
        "begin_line": 933,
        "end_line": 947,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016666666666666668,
            "pseudo_dstar_susp": 0.001272264631043257,
            "pseudo_tarantula_susp": 0.0004775549188156638,
            "pseudo_op2_susp": 0.001272264631043257,
            "pseudo_barinel_susp": 0.0004775549188156638
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_horizontalalignment#949",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_horizontalalignment(self, align)",
        "snippet": "    def set_horizontalalignment(self, align):\n        \"\"\"\n        Set the horizontal alignment to one of\n\n        Parameters\n        ----------\n        align : {'center', 'right', 'left'}\n        \"\"\"\n        cbook._check_in_list(['center', 'right', 'left'], align=align)\n        self._horizontalalignment = align\n        self.stale = True",
        "begin_line": 949,
        "end_line": 959,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016666666666666668,
            "pseudo_dstar_susp": 0.001272264631043257,
            "pseudo_tarantula_susp": 0.0004775549188156638,
            "pseudo_op2_susp": 0.001272264631043257,
            "pseudo_barinel_susp": 0.0004775549188156638
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_fontsize#1042",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_fontsize(self, fontsize)",
        "snippet": "    def set_fontsize(self, fontsize):\n        \"\"\"\n        Set the font size.  May be either a size string, relative to\n        the default font size, or an absolute font size in points.\n\n        Parameters\n        ----------\n        fontsize : {size in points, 'xx-small', 'x-small', 'small', 'medium', \\\n'large', 'x-large', 'xx-large'}\n\n        See Also\n        --------\n        .font_manager.FontProperties.set_size\n        \"\"\"\n        self._fontproperties.set_size(fontsize)\n        self.stale = True",
        "begin_line": 1042,
        "end_line": 1057,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002486943546381497,
            "pseudo_dstar_susp": 0.0002864508736751647,
            "pseudo_tarantula_susp": 0.00018942981625307822,
            "pseudo_op2_susp": 0.0002864508736751647,
            "pseudo_barinel_susp": 0.00018942981625307822
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_position#1093",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_position(self, xy)",
        "snippet": "    def set_position(self, xy):\n        \"\"\"\n        Set the (*x*, *y*) position of the text.\n\n        Parameters\n        ----------\n        xy : (float, float)\n        \"\"\"\n        self.set_x(xy[0])\n        self.set_y(xy[1])",
        "begin_line": 1093,
        "end_line": 1102,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00031857279388340236,
            "pseudo_dstar_susp": 0.0003290556103981573,
            "pseudo_tarantula_susp": 0.0001866368047779022,
            "pseudo_op2_susp": 0.0003290556103981573,
            "pseudo_barinel_susp": 0.0001866368047779022
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_x#1104",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_x(self, x)",
        "snippet": "    def set_x(self, x):\n        \"\"\"\n        Set the *x* position of the text.\n\n        Parameters\n        ----------\n        x : float\n        \"\"\"\n        self._x = x\n        self.stale = True",
        "begin_line": 1104,
        "end_line": 1113,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.228420966016621e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_y#1115",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_y(self, y)",
        "snippet": "    def set_y(self, y):\n        \"\"\"\n        Set the *y* position of the text.\n\n        Parameters\n        ----------\n        y : float\n        \"\"\"\n        self._y = y\n        self.stale = True",
        "begin_line": 1115,
        "end_line": 1124,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.228420966016621e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_rotation#1126",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_rotation(self, s)",
        "snippet": "    def set_rotation(self, s):\n        \"\"\"\n        Set the rotation of the text.\n\n        Parameters\n        ----------\n        s : {angle in degrees, 'vertical', 'horizontal'}\n        \"\"\"\n        self._rotation = s\n        self.stale = True",
        "begin_line": 1126,
        "end_line": 1135,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00026504108136761196,
            "pseudo_dstar_susp": 0.0002680246582685607,
            "pseudo_tarantula_susp": 0.00023315458148752622,
            "pseudo_op2_susp": 0.0002680246582685607,
            "pseudo_barinel_susp": 0.00023315458148752622
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_verticalalignment#1137",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_verticalalignment(self, align)",
        "snippet": "    def set_verticalalignment(self, align):\n        \"\"\"\n        Set the vertical alignment\n\n        Parameters\n        ----------\n        align : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}\n        \"\"\"\n        cbook._check_in_list(\n            ['top', 'bottom', 'center', 'baseline', 'center_baseline'],\n            align=align)\n        self._verticalalignment = align\n        self.stale = True",
        "begin_line": 1137,
        "end_line": 1149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016666666666666668,
            "pseudo_dstar_susp": 0.002932551319648094,
            "pseudo_tarantula_susp": 0.0004775549188156638,
            "pseudo_op2_susp": 0.002932551319648094,
            "pseudo_barinel_susp": 0.0004775549188156638
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_text#1151",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_text(self, s)",
        "snippet": "    def set_text(self, s):\n        r\"\"\"\n        Set the text string *s*.\n\n        It may contain newlines (``\\n``) or math in LaTeX syntax.\n\n        Parameters\n        ----------\n        s : object\n            Any object gets converted to its `str`, except ``None`` which\n            becomes ``''``.\n        \"\"\"\n        if s is None:\n            s = ''\n        if s != self._text:\n            self._text = str(s)\n            self.stale = True",
        "begin_line": 1151,
        "end_line": 1167,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020491803278688526,
            "pseudo_dstar_susp": 0.0029154518950437317,
            "pseudo_tarantula_susp": 0.0004952947003467063,
            "pseudo_op2_susp": 0.0029154518950437317,
            "pseudo_barinel_susp": 0.0004952947003467063
        }
    },
    {
        "name": "lib.matplotlib.text.Text._preprocess_math#1193",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text._preprocess_math(self, s)",
        "snippet": "    def _preprocess_math(self, s):\n        \"\"\"\n        Return the string *s* after mathtext preprocessing, and the kind of\n        mathtext support needed.\n\n        - If *self* is configured to use TeX, return *s* unchanged except that\n          a single space gets escaped, and the flag \"TeX\".\n        - Otherwise, if *s* is mathtext (has an even number of unescaped dollar\n          signs), return *s* and the flag True.\n        - Otherwise, return *s* with dollar signs unescaped, and the flag\n          False.\n        \"\"\"\n        if self.get_usetex():\n            if s == \" \":\n                s = r\"\\ \"\n            return s, \"TeX\"\n        elif cbook.is_math_text(s):\n            return s, True\n        else:\n            return s.replace(r\"\\$\", \"$\"), False",
        "begin_line": 1193,
        "end_line": 1212,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029940119760479044,
            "pseudo_dstar_susp": 0.001968503937007874,
            "pseudo_tarantula_susp": 0.000591016548463357,
            "pseudo_op2_susp": 0.00196078431372549,
            "pseudo_barinel_susp": 0.000591016548463357
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_fontproperties#1214",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_fontproperties(self, fp)",
        "snippet": "    def set_fontproperties(self, fp):\n        \"\"\"\n        Set the font properties that control the text.\n\n        Parameters\n        ----------\n        fp : `.font_manager.FontProperties`\n        \"\"\"\n        if isinstance(fp, str):\n            fp = FontProperties(fp)\n        self._fontproperties = fp.copy()\n        self.stale = True",
        "begin_line": 1214,
        "end_line": 1225,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002133560913164071,
            "pseudo_dstar_susp": 0.0001808972503617945,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0001808972503617945,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_usetex#1227",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_usetex(self, usetex)",
        "snippet": "    def set_usetex(self, usetex):\n        \"\"\"\n        Parameters\n        ----------\n        usetex : bool or None\n            Whether to render using TeX, ``None`` means to use\n            :rc:`text.usetex`.\n        \"\"\"\n        if usetex is None:\n            self._usetex = rcParams['text.usetex']\n        else:\n            self._usetex = bool(usetex)\n        self.stale = True",
        "begin_line": 1227,
        "end_line": 1239,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012468827930174563,
            "pseudo_dstar_susp": 0.0029411764705882353,
            "pseudo_tarantula_susp": 0.0004073319755600815,
            "pseudo_op2_susp": 0.0029411764705882353,
            "pseudo_barinel_susp": 0.0004073319755600815
        }
    },
    {
        "name": "lib.matplotlib.text.Text.get_usetex#1241",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.get_usetex(self)",
        "snippet": "    def get_usetex(self):\n        \"\"\"Return whether this `Text` object uses TeX for rendering.\"\"\"\n        return self._usetex",
        "begin_line": 1241,
        "end_line": 1243,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.text._AnnotationBase.__init__#1752",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text._AnnotationBase",
        "signature": "lib.matplotlib.text._AnnotationBase.__init__(self, xy, xycoords='data', annotation_clip=None)",
        "snippet": "    def __init__(self,\n                 xy,\n                 xycoords='data',\n                 annotation_clip=None):\n\n        self.xy = xy\n        self.xycoords = xycoords\n        self.set_annotation_clip(annotation_clip)\n\n        self._draggable = None",
        "begin_line": 1752,
        "end_line": 1761,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018590816136828406,
            "pseudo_dstar_susp": 0.00017135023989033586,
            "pseudo_tarantula_susp": 0.0002587991718426501,
            "pseudo_op2_susp": 0.00017135023989033586,
            "pseudo_barinel_susp": 0.0002587991718426501
        }
    },
    {
        "name": "lib.matplotlib.text._AnnotationBase._get_xy#1763",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text._AnnotationBase",
        "signature": "lib.matplotlib.text._AnnotationBase._get_xy(self, renderer, x, y, s)",
        "snippet": "    def _get_xy(self, renderer, x, y, s):\n        if isinstance(s, tuple):\n            s1, s2 = s\n        else:\n            s1, s2 = s, s\n        if s1 == 'data':\n            x = float(self.convert_xunits(x))\n        if s2 == 'data':\n            y = float(self.convert_yunits(y))\n        return self._get_xy_transform(renderer, s).transform((x, y))",
        "begin_line": 1763,
        "end_line": 1772,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018590816136828406,
            "pseudo_dstar_susp": 0.00017135023989033586,
            "pseudo_tarantula_susp": 0.0002587991718426501,
            "pseudo_op2_susp": 0.00017135023989033586,
            "pseudo_barinel_susp": 0.0002587991718426501
        }
    },
    {
        "name": "lib.matplotlib.text._AnnotationBase._get_xy_transform#1774",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text._AnnotationBase",
        "signature": "lib.matplotlib.text._AnnotationBase._get_xy_transform(self, renderer, s)",
        "snippet": "    def _get_xy_transform(self, renderer, s):\n\n        if isinstance(s, tuple):\n            s1, s2 = s\n            from matplotlib.transforms import blended_transform_factory\n            tr1 = self._get_xy_transform(renderer, s1)\n            tr2 = self._get_xy_transform(renderer, s2)\n            tr = blended_transform_factory(tr1, tr2)\n            return tr\n        elif callable(s):\n            tr = s(renderer)\n            if isinstance(tr, BboxBase):\n                return BboxTransformTo(tr)\n            elif isinstance(tr, Transform):\n                return tr\n            else:\n                raise RuntimeError(\"unknown return type ...\")\n        elif isinstance(s, Artist):\n            bbox = s.get_window_extent(renderer)\n            return BboxTransformTo(bbox)\n        elif isinstance(s, BboxBase):\n            return BboxTransformTo(s)\n        elif isinstance(s, Transform):\n            return s\n        elif not isinstance(s, str):\n            raise RuntimeError(\"unknown coordinate type : %s\" % s)\n\n        if s == 'data':\n            return self.axes.transData\n        elif s == 'polar':\n            from matplotlib.projections import PolarAxes\n            tr = PolarAxes.PolarTransform()\n            trans = tr + self.axes.transData\n            return trans\n\n        s_ = s.split()\n        if len(s_) != 2:\n            raise ValueError(\"%s is not a recognized coordinate\" % s)\n\n        bbox0, xy0 = None, None\n\n        bbox_name, unit = s_\n        # if unit is offset-like\n        if bbox_name == \"figure\":\n            bbox0 = self.figure.bbox\n        elif bbox_name == \"axes\":\n            bbox0 = self.axes.bbox\n        # elif bbox_name == \"bbox\":\n        #     if bbox is None:\n        #         raise RuntimeError(\"bbox is specified as a coordinate but \"\n        #                            \"never set\")\n        #     bbox0 = self._get_bbox(renderer, bbox)\n\n        if bbox0 is not None:\n            xy0 = bbox0.bounds[:2]\n        elif bbox_name == \"offset\":\n            xy0 = self._get_ref_xy(renderer)\n\n        if xy0 is not None:\n            # reference x, y in display coordinate\n            ref_x, ref_y = xy0\n            from matplotlib.transforms import Affine2D\n            if unit == \"points\":\n                # dots per points\n                dpp = self.figure.get_dpi() / 72.\n                tr = Affine2D().scale(dpp)\n            elif unit == \"pixels\":\n                tr = Affine2D()\n            elif unit == \"fontsize\":\n                fontsize = self.get_size()\n                dpp = fontsize * self.figure.get_dpi() / 72.\n                tr = Affine2D().scale(dpp)\n            elif unit == \"fraction\":\n                w, h = bbox0.bounds[2:]\n                tr = Affine2D().scale(w, h)\n            else:\n                raise ValueError(\"%s is not a recognized coordinate\" % s)\n\n            return tr.translate(ref_x, ref_y)\n\n        else:\n            raise ValueError(\"%s is not a recognized coordinate\" % s)",
        "begin_line": 1774,
        "end_line": 1855,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001967729240456513,
            "pseudo_dstar_susp": 0.0001918649270913277,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0001918649270913277,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.text._AnnotationBase._get_ref_xy#1857",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text._AnnotationBase",
        "signature": "lib.matplotlib.text._AnnotationBase._get_ref_xy(self, renderer)",
        "snippet": "    def _get_ref_xy(self, renderer):\n        \"\"\"\n        return x, y (in display coordinate) that is to be used for a reference\n        of any offset coordinate\n        \"\"\"\n        def is_offset(s):\n            return isinstance(s, str) and s.split()[0] == \"offset\"\n\n        if isinstance(self.xycoords, tuple):\n            if any(map(is_offset, self.xycoords)):\n                raise ValueError(\"xycoords should not be an offset coordinate\")\n        elif is_offset(self.xycoords):\n            raise ValueError(\"xycoords should not be an offset coordinate\")\n        x, y = self.xy\n        return self._get_xy(renderer, x, y, self.xycoords)",
        "begin_line": 1857,
        "end_line": 1871,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.text._AnnotationBase.set_annotation_clip#1883",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text._AnnotationBase",
        "signature": "lib.matplotlib.text._AnnotationBase.set_annotation_clip(self, b)",
        "snippet": "    def set_annotation_clip(self, b):\n        \"\"\"\n        set *annotation_clip* attribute.\n\n          * True: the annotation will only be drawn when self.xy is inside\n                  the axes.\n          * False: the annotation will always be drawn regardless of its\n                   position.\n          * None: the self.xy will be checked only if *xycoords* is \"data\"\n        \"\"\"\n        self._annotation_clip = b",
        "begin_line": 1883,
        "end_line": 1893,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015785319652722967,
            "pseudo_dstar_susp": 0.00015179113539769278,
            "pseudo_tarantula_susp": 0.00022680880018144704,
            "pseudo_op2_susp": 0.00015179113539769278,
            "pseudo_barinel_susp": 0.00022686025408348456
        }
    },
    {
        "name": "lib.matplotlib.text._AnnotationBase._check_xy#1907",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text._AnnotationBase",
        "signature": "lib.matplotlib.text._AnnotationBase._check_xy(self, renderer, xy_pixel)",
        "snippet": "    def _check_xy(self, renderer, xy_pixel):\n        \"\"\"\n        given the xy pixel coordinate, check if the annotation need to\n        be drawn.\n        \"\"\"\n\n        b = self.get_annotation_clip()\n\n        if b or (b is None and self.xycoords == \"data\"):\n            # check if self.xy is inside the axes.\n            if not self.axes.contains_point(xy_pixel):\n                return False\n\n        return True",
        "begin_line": 1907,
        "end_line": 1920,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020475020475020476,
            "pseudo_dstar_susp": 0.00019204916458613405,
            "pseudo_tarantula_susp": 0.0003696857670979667,
            "pseudo_op2_susp": 0.00019204916458613405,
            "pseudo_barinel_susp": 0.0003696857670979667
        }
    },
    {
        "name": "lib.matplotlib.text.Annotation.__init__#1973",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Annotation",
        "signature": "lib.matplotlib.text.Annotation.__init__(self, text, xy, xytext=None, xycoords='data', textcoords=None, arrowprops=None, annotation_clip=None, **kwargs)",
        "snippet": "    def __init__(self, text, xy,\n                 xytext=None,\n                 xycoords='data',\n                 textcoords=None,\n                 arrowprops=None,\n                 annotation_clip=None,\n                 **kwargs):\n        \"\"\"\n        Annotate the point *xy* with text *text*.\n\n        In the simplest form, the text is placed at *xy*.\n\n        Optionally, the text can be displayed in another position *xytext*.\n        An arrow pointing from the text to the annotated point *xy* can then\n        be added by defining *arrowprops*.\n\n        Parameters\n        ----------\n        text : str\n            The text of the annotation.  *s* is a deprecated synonym for this\n            parameter.\n\n        xy : (float, float)\n            The point *(x, y)* to annotate.\n\n        xytext : (float, float), optional\n            The position *(x, y)* to place the text at.\n            If *None*, defaults to *xy*.\n\n        xycoords : str, `.Artist`, `.Transform`, callable or tuple, optional\n\n            The coordinate system that *xy* is given in. The following types\n            of values are supported:\n\n            - One of the following strings:\n\n              =================   =============================================\n              Value               Description\n              =================   =============================================\n              'figure points'     Points from the lower left of the figure\n              'figure pixels'     Pixels from the lower left of the figure\n              'figure fraction'   Fraction of figure from lower left\n              'axes points'       Points from lower left corner of axes\n              'axes pixels'       Pixels from lower left corner of axes\n              'axes fraction'     Fraction of axes from lower left\n              'data'              Use the coordinate system of the object being\n                                  annotated (default)\n              'polar'             *(theta, r)* if not native 'data' coordinates\n              =================   =============================================\n\n            - An `.Artist`: *xy* is interpreted as a fraction of the artists\n              `~matplotlib.transforms.Bbox`. E.g. *(0, 0)* would be the lower\n              left corner of the bounding box and *(0.5, 1)* would be the\n              center top of the bounding box.\n\n            - A `.Transform` to transform *xy* to screen coordinates.\n\n            - A function with one of the following signatures::\n\n                def transform(renderer) -> Bbox\n                def transform(renderer) -> Transform\n\n              where *renderer* is a `.RendererBase` subclass.\n\n              The result of the function is interpreted like the `.Artist` and\n              `.Transform` cases above.\n\n            - A tuple *(xcoords, ycoords)* specifying separate coordinate\n              systems for *x* and *y*. *xcoords* and *ycoords* must each be\n              of one of the above described types.\n\n            See :ref:`plotting-guide-annotation` for more details.\n\n            Defaults to 'data'.\n\n        textcoords : str, `.Artist`, `.Transform`, callable or tuple, optional\n            The coordinate system that *xytext* is given in.\n\n            All *xycoords* values are valid as well as the following\n            strings:\n\n            =================   =========================================\n            Value               Description\n            =================   =========================================\n            'offset points'     Offset (in points) from the *xy* value\n            'offset pixels'     Offset (in pixels) from the *xy* value\n            =================   =========================================\n\n            Defaults to the value of *xycoords*, i.e. use the same coordinate\n            system for annotation point and text position.\n\n        arrowprops : dict, optional\n            The properties used to draw a\n            `~matplotlib.patches.FancyArrowPatch` arrow between the\n            positions *xy* and *xytext*.\n\n            If *arrowprops* does not contain the key 'arrowstyle' the\n            allowed keys are:\n\n            ==========   ======================================================\n            Key          Description\n            ==========   ======================================================\n            width        The width of the arrow in points\n            headwidth    The width of the base of the arrow head in points\n            headlength   The length of the arrow head in points\n            shrink       Fraction of total length to shrink from both ends\n            ?            Any key to :class:`matplotlib.patches.FancyArrowPatch`\n            ==========   ======================================================\n\n            If *arrowprops* contains the key 'arrowstyle' the\n            above keys are forbidden.  The allowed values of\n            ``'arrowstyle'`` are:\n\n            ============   =============================================\n            Name           Attrs\n            ============   =============================================\n            ``'-'``        None\n            ``'->'``       head_length=0.4,head_width=0.2\n            ``'-['``       widthB=1.0,lengthB=0.2,angleB=None\n            ``'|-|'``      widthA=1.0,widthB=1.0\n            ``'-|>'``      head_length=0.4,head_width=0.2\n            ``'<-'``       head_length=0.4,head_width=0.2\n            ``'<->'``      head_length=0.4,head_width=0.2\n            ``'<|-'``      head_length=0.4,head_width=0.2\n            ``'<|-|>'``    head_length=0.4,head_width=0.2\n            ``'fancy'``    head_length=0.4,head_width=0.4,tail_width=0.4\n            ``'simple'``   head_length=0.5,head_width=0.5,tail_width=0.2\n            ``'wedge'``    tail_width=0.3,shrink_factor=0.5\n            ============   =============================================\n\n            Valid keys for `~matplotlib.patches.FancyArrowPatch` are:\n\n            ===============  ==================================================\n            Key              Description\n            ===============  ==================================================\n            arrowstyle       the arrow style\n            connectionstyle  the connection style\n            relpos           default is (0.5, 0.5)\n            patchA           default is bounding box of the text\n            patchB           default is None\n            shrinkA          default is 2 points\n            shrinkB          default is 2 points\n            mutation_scale   default is text size (in points)\n            mutation_aspect  default is 1.\n            ?                any key for :class:`matplotlib.patches.PathPatch`\n            ===============  ==================================================\n\n            Defaults to None, i.e. no arrow is drawn.\n\n        annotation_clip : bool or None, optional\n            Whether to draw the annotation when the annotation point *xy* is\n            outside the axes area.\n\n            - If *True*, the annotation will only be drawn when *xy* is\n              within the axes.\n            - If *False*, the annotation will always be drawn.\n            - If *None*, the annotation will only be drawn when *xy* is\n              within the axes and *xycoords* is 'data'.\n\n            Defaults to *None*.\n\n        **kwargs\n            Additional kwargs are passed to `~matplotlib.text.Text`.\n\n        Returns\n        -------\n        annotation : `.Annotation`\n\n        See Also\n        --------\n        :ref:`plotting-guide-annotation`.\n\n        \"\"\"\n        _AnnotationBase.__init__(self,\n                                 xy,\n                                 xycoords=xycoords,\n                                 annotation_clip=annotation_clip)\n        # warn about wonky input data\n        if (xytext is None and\n                textcoords is not None and\n                textcoords != xycoords):\n            cbook._warn_external(\"You have used the `textcoords` kwarg, but \"\n                                 \"not the `xytext` kwarg.  This can lead to \"\n                                 \"surprising results.\")\n\n        # clean up textcoords and assign default\n        if textcoords is None:\n            textcoords = self.xycoords\n        self._textcoords = textcoords\n\n        # cleanup xytext defaults\n        if xytext is None:\n            xytext = self.xy\n        x, y = xytext\n\n        Text.__init__(self, x, y, text, **kwargs)\n\n        self.arrowprops = arrowprops\n\n        if arrowprops is not None:\n            if \"arrowstyle\" in arrowprops:\n                arrowprops = self.arrowprops.copy()\n                self._arrow_relpos = arrowprops.pop(\"relpos\", (0.5, 0.5))\n            else:\n                # modified YAArrow API to be used with FancyArrowPatch\n                shapekeys = ('width', 'headwidth', 'headlength',\n                             'shrink', 'frac')\n                arrowprops = dict()\n                for key, val in self.arrowprops.items():\n                    if key not in shapekeys:\n                        arrowprops[key] = val  # basic Patch properties\n            self.arrow_patch = FancyArrowPatch((0, 0), (1, 1),\n                                               **arrowprops)\n        else:\n            self.arrow_patch = None",
        "begin_line": 1973,
        "end_line": 2187,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018115942028985507,
            "pseudo_dstar_susp": 0.0001703867779860283,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0001703867779860283,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.text.Annotation.anncoords#2213",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Annotation",
        "signature": "lib.matplotlib.text.Annotation.anncoords(self)",
        "snippet": "    def anncoords(self):\n        \"\"\"The coordinate system to use for `.Annotation.xyann`.\"\"\"\n        return self._textcoords",
        "begin_line": 2213,
        "end_line": 2215,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012717792191275595,
            "pseudo_dstar_susp": 0.0001210800339024095,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.0001210800339024095,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.text.Annotation._update_position_xytext#2245",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Annotation",
        "signature": "lib.matplotlib.text.Annotation._update_position_xytext(self, renderer, xy_pixel)",
        "snippet": "    def _update_position_xytext(self, renderer, xy_pixel):\n        \"\"\"\n        Update the pixel positions of the annotation text and the arrow patch.\n        \"\"\"\n        # generate transformation,\n        self.set_transform(self._get_xy_transform(renderer, self.anncoords))\n\n        ox0, oy0 = self._get_xy_display()\n        ox1, oy1 = xy_pixel\n\n        if self.arrowprops is not None:\n            x0, y0 = xy_pixel\n            l, b, w, h = Text.get_window_extent(self, renderer).bounds\n            r = l + w\n            t = b + h\n            xc = 0.5 * (l + r)\n            yc = 0.5 * (b + t)\n\n            d = self.arrowprops.copy()\n            ms = d.pop(\"mutation_scale\", self.get_size())\n            self.arrow_patch.set_mutation_scale(ms)\n\n            if \"arrowstyle\" not in d:\n                # Approximately simulate the YAArrow.\n                # Pop its kwargs:\n                shrink = d.pop('shrink', 0.0)\n                width = d.pop('width', 4)\n                headwidth = d.pop('headwidth', 12)\n                # Ignore frac--it is useless.\n                frac = d.pop('frac', None)\n                if frac is not None:\n                    cbook._warn_external(\n                        \"'frac' option in 'arrowprops' is no longer supported;\"\n                        \" use 'headlength' to set the head length in points.\")\n                headlength = d.pop('headlength', 12)\n\n                # NB: ms is in pts\n                stylekw = dict(head_length=headlength / ms,\n                               head_width=headwidth / ms,\n                               tail_width=width / ms)\n\n                self.arrow_patch.set_arrowstyle('simple', **stylekw)\n\n                # using YAArrow style:\n                # pick the (x, y) corner of the text bbox closest to point\n                # annotated\n                xpos = ((l, 0), (xc, 0.5), (r, 1))\n                ypos = ((b, 0), (yc, 0.5), (t, 1))\n\n                _, (x, relposx) = min((abs(val[0] - x0), val) for val in xpos)\n                _, (y, relposy) = min((abs(val[0] - y0), val) for val in ypos)\n\n                self._arrow_relpos = (relposx, relposy)\n\n                r = np.hypot((y - y0), (x - x0))\n                shrink_pts = shrink * r / renderer.points_to_pixels(1)\n                self.arrow_patch.shrinkA = shrink_pts\n                self.arrow_patch.shrinkB = shrink_pts\n\n            # adjust the starting point of the arrow relative to\n            # the textbox.\n            # TODO : Rotation needs to be accounted.\n            relpos = self._arrow_relpos\n            bbox = Text.get_window_extent(self, renderer)\n            ox0 = bbox.x0 + bbox.width * relpos[0]\n            oy0 = bbox.y0 + bbox.height * relpos[1]\n\n            # The arrow will be drawn from (ox0, oy0) to (ox1,\n            # oy1). It will be first clipped by patchA and patchB.\n            # Then it will be shrunk by shrinkA and shrinkB\n            # (in points). If patch A is not set, self.bbox_patch\n            # is used.\n\n            self.arrow_patch.set_positions((ox0, oy0), (ox1, oy1))\n\n            if \"patchA\" in d:\n                self.arrow_patch.set_patchA(d.pop(\"patchA\"))\n            else:\n                if self._bbox_patch:\n                    self.arrow_patch.set_patchA(self._bbox_patch)\n                else:\n                    pad = renderer.points_to_pixels(4)\n                    if self.get_text() == \"\":\n                        self.arrow_patch.set_patchA(None)\n                        return\n\n                    bbox = Text.get_window_extent(self, renderer)\n                    l, b, w, h = bbox.bounds\n                    l -= pad / 2.\n                    b -= pad / 2.\n                    w += pad\n                    h += pad\n                    r = Rectangle(xy=(l, b),\n                                  width=w,\n                                  height=h,\n                                  )\n                    r.set_transform(IdentityTransform())\n                    r.set_clip_on(False)\n\n                    self.arrow_patch.set_patchA(r)",
        "begin_line": 2245,
        "end_line": 2344,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018463810930576072,
            "pseudo_dstar_susp": 0.00016136840406648378,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00016136840406648378,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.text.Annotation.draw#2347",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Annotation",
        "signature": "lib.matplotlib.text.Annotation.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        \"\"\"\n        Draw the :class:`Annotation` object to the given *renderer*.\n        \"\"\"\n\n        if renderer is not None:\n            self._renderer = renderer\n        if not self.get_visible():\n            return\n\n        xy_pixel = self._get_position_xy(renderer)\n        if not self._check_xy(renderer, xy_pixel):\n            return\n\n        self._update_position_xytext(renderer, xy_pixel)\n        self.update_bbox_position_size(renderer)\n\n        if self.arrow_patch is not None:   # FancyArrowPatch\n            if self.arrow_patch.figure is None and self.figure is not None:\n                self.arrow_patch.figure = self.figure\n            self.arrow_patch.draw(renderer)\n\n        # Draw text, including FancyBboxPatch, after FancyArrowPatch.\n        # Otherwise, a wedge arrowstyle can land partly on top of the Bbox.\n        Text.draw(self, renderer)",
        "begin_line": 2347,
        "end_line": 2371,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020916126333403055,
            "pseudo_dstar_susp": 0.00019241870309794111,
            "pseudo_tarantula_susp": 0.0002829654782116582,
            "pseudo_op2_susp": 0.00019241870309794111,
            "pseudo_barinel_susp": 0.0002829654782116582
        }
    },
    {
        "name": "lib.matplotlib.text.Annotation.get_window_extent#2373",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Annotation",
        "signature": "lib.matplotlib.text.Annotation.get_window_extent(self, renderer=None)",
        "snippet": "    def get_window_extent(self, renderer=None):\n        \"\"\"\n        Return the `.Bbox` bounding the text and arrow, in display units.\n\n        Parameters\n        ----------\n        renderer : Renderer, optional\n            A renderer is needed to compute the bounding box.  If the artist\n            has already been drawn, the renderer is cached; thus, it is only\n            necessary to pass this argument when calling `get_window_extent`\n            before the first `draw`.  In practice, it is usually easier to\n            trigger a draw first (e.g. by saving the figure).\n        \"\"\"\n        # This block is the same as in Text.get_window_extent, but we need to\n        # set the renderer before calling update_positions().\n        if not self.get_visible():\n            return Bbox.unit()\n        if renderer is not None:\n            self._renderer = renderer\n        if self._renderer is None:\n            self._renderer = self.figure._cachedRenderer\n        if self._renderer is None:\n            raise RuntimeError('Cannot get window extent w/o renderer')\n\n        self.update_positions(self._renderer)\n\n        text_bbox = Text.get_window_extent(self)\n        bboxes = [text_bbox]\n\n        if self.arrow_patch is not None:\n            bboxes.append(self.arrow_patch.get_window_extent())\n\n        return Bbox.union(bboxes)",
        "begin_line": 2373,
        "end_line": 2405,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.testing.decorators._cleanup_cm#26",
        "src_path": "lib/matplotlib/testing/decorators.py",
        "class_name": "lib.matplotlib.testing.decorators",
        "signature": "lib.matplotlib.testing.decorators._cleanup_cm()",
        "snippet": "def _cleanup_cm():\n    orig_units_registry = matplotlib.units.registry.copy()\n    try:\n        with warnings.catch_warnings(), matplotlib.rc_context():\n            yield\n    finally:\n        matplotlib.units.registry.clear()\n        matplotlib.units.registry.update(orig_units_registry)\n        plt.close(\"all\")",
        "begin_line": 26,
        "end_line": 34,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008620689655172414,
            "pseudo_dstar_susp": 0.017857142857142856,
            "pseudo_tarantula_susp": 0.00023386342376052386,
            "pseudo_op2_susp": 0.017857142857142856,
            "pseudo_barinel_susp": 0.00023386342376052386
        }
    },
    {
        "name": "lib.matplotlib.testing.decorators.remove_ticks_and_titles#111",
        "src_path": "lib/matplotlib/testing/decorators.py",
        "class_name": "lib.matplotlib.testing.decorators",
        "signature": "lib.matplotlib.testing.decorators.remove_ticks_and_titles(figure)",
        "snippet": "def remove_ticks_and_titles(figure):\n    figure.suptitle(\"\")\n    null_formatter = ticker.NullFormatter()\n    for ax in figure.get_axes():\n        ax.set_title(\"\")\n        ax.xaxis.set_major_formatter(null_formatter)\n        ax.xaxis.set_minor_formatter(null_formatter)\n        ax.yaxis.set_major_formatter(null_formatter)\n        ax.yaxis.set_minor_formatter(null_formatter)\n        try:\n            ax.zaxis.set_major_formatter(null_formatter)\n            ax.zaxis.set_minor_formatter(null_formatter)\n        except AttributeError:\n            pass",
        "begin_line": 111,
        "end_line": 124,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00033277870216306157,
            "pseudo_dstar_susp": 0.00035310734463276836,
            "pseudo_tarantula_susp": 0.0001785076758300607,
            "pseudo_op2_susp": 0.00035310734463276836,
            "pseudo_barinel_susp": 0.0001785076758300607
        }
    },
    {
        "name": "lib.matplotlib.testing.decorators._raise_on_image_difference#127",
        "src_path": "lib/matplotlib/testing/decorators.py",
        "class_name": "lib.matplotlib.testing.decorators",
        "signature": "lib.matplotlib.testing.decorators._raise_on_image_difference(expected, actual, tol)",
        "snippet": "def _raise_on_image_difference(expected, actual, tol):\n    __tracebackhide__ = True\n\n    err = compare_images(expected, actual, tol, in_decorator=True)\n    if err:\n        for key in [\"actual\", \"expected\"]:\n            err[key] = os.path.relpath(err[key])\n        raise ImageComparisonFailure(\n            'images not close (RMS %(rms).3f):\\n\\t%(actual)s\\n\\t%(expected)s '\n             % err)",
        "begin_line": 127,
        "end_line": 136,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007692307692307693,
            "pseudo_dstar_susp": 0.0051813471502590676,
            "pseudo_tarantula_susp": 0.0004438526409232135,
            "pseudo_op2_susp": 0.0051813471502590676,
            "pseudo_barinel_susp": 0.0004438526409232135
        }
    },
    {
        "name": "lib.matplotlib.testing.decorators._ImageComparisonBase.__init__#173",
        "src_path": "lib/matplotlib/testing/decorators.py",
        "class_name": "lib.matplotlib.testing.decorators._ImageComparisonBase",
        "signature": "lib.matplotlib.testing.decorators._ImageComparisonBase.__init__(self, func, tol, remove_text, savefig_kwargs)",
        "snippet": "    def __init__(self, func, tol, remove_text, savefig_kwargs):\n        self.func = func\n        self.baseline_dir, self.result_dir = _image_directories(func)\n        self.tol = tol\n        self.remove_text = remove_text\n        self.savefig_kwargs = savefig_kwargs",
        "begin_line": 173,
        "end_line": 178,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.017857142857142856,
            "pseudo_dstar_susp": 0.009523809523809525,
            "pseudo_tarantula_susp": 0.0004935834155972359,
            "pseudo_op2_susp": 0.009523809523809525,
            "pseudo_barinel_susp": 0.0004935834155972359
        }
    },
    {
        "name": "lib.matplotlib.testing.decorators._ImageComparisonBase.copy_baseline#180",
        "src_path": "lib/matplotlib/testing/decorators.py",
        "class_name": "lib.matplotlib.testing.decorators._ImageComparisonBase",
        "signature": "lib.matplotlib.testing.decorators._ImageComparisonBase.copy_baseline(self, baseline, extension)",
        "snippet": "    def copy_baseline(self, baseline, extension):\n        baseline_path = self.baseline_dir / baseline\n        orig_expected_path = baseline_path.with_suffix(f'.{extension}')\n        if extension == 'eps' and not orig_expected_path.exists():\n            orig_expected_path = orig_expected_path.with_suffix('.pdf')\n        expected_fname = make_test_filename(\n            self.result_dir / orig_expected_path.name, 'expected')\n        try:\n            # os.symlink errors if the target already exists.\n            with contextlib.suppress(OSError):\n                os.remove(expected_fname)\n            try:\n                os.symlink(orig_expected_path, expected_fname)\n            except OSError:  # On Windows, symlink *may* be unavailable.\n                shutil.copyfile(orig_expected_path, expected_fname)\n        except OSError:\n            raise ImageComparisonFailure(\n                f\"Missing baseline image {expected_fname} because the \"\n                f\"following file cannot be accessed: {orig_expected_path}\")\n        return expected_fname",
        "begin_line": 180,
        "end_line": 199,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02702702702702703,
            "pseudo_dstar_susp": 0.014285714285714285,
            "pseudo_tarantula_susp": 0.0005117707267144319,
            "pseudo_op2_susp": 0.014285714285714285,
            "pseudo_barinel_susp": 0.0005117707267144319
        }
    },
    {
        "name": "lib.matplotlib.testing.decorators._ImageComparisonBase.compare#201",
        "src_path": "lib/matplotlib/testing/decorators.py",
        "class_name": "lib.matplotlib.testing.decorators._ImageComparisonBase",
        "signature": "lib.matplotlib.testing.decorators._ImageComparisonBase.compare(self, idx, baseline, extension)",
        "snippet": "    def compare(self, idx, baseline, extension):\n        __tracebackhide__ = True\n        fignum = plt.get_fignums()[idx]\n        fig = plt.figure(fignum)\n\n        if self.remove_text:\n            remove_ticks_and_titles(fig)\n\n        actual_path = (self.result_dir / baseline).with_suffix(f'.{extension}')\n        kwargs = self.savefig_kwargs.copy()\n        if extension == 'pdf':\n            kwargs.setdefault('metadata',\n                              {'Creator': None, 'Producer': None,\n                               'CreationDate': None})\n        fig.savefig(actual_path, **kwargs)\n\n        expected_path = self.copy_baseline(baseline, extension)\n        _raise_on_image_difference(expected_path, actual_path, self.tol)",
        "begin_line": 201,
        "end_line": 218,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005186721991701245,
            "pseudo_dstar_susp": 0.0006406149903907751,
            "pseudo_tarantula_susp": 0.00016954899966090201,
            "pseudo_op2_susp": 0.0006406149903907751,
            "pseudo_barinel_susp": 0.00016954899966090201
        }
    },
    {
        "name": "lib.matplotlib.testing.decorators.wrapper#246",
        "src_path": "lib/matplotlib/testing/decorators.py",
        "class_name": "lib.matplotlib.testing.decorators",
        "signature": "lib.matplotlib.testing.decorators.wrapper(*args, **kwargs)",
        "snippet": "        def wrapper(*args, **kwargs):\n            __tracebackhide__ = True\n            img = _ImageComparisonBase(func, tol=tol, remove_text=remove_text,\n                                       savefig_kwargs=savefig_kwargs)\n            matplotlib.testing.set_font_settings_for_testing()\n            func(*args, **kwargs)\n\n            # Parameter indirection:\n            # This is hacked on via the mpl_image_comparison_parameters fixture\n            # so that we don't need to modify the function's real signature for\n            # any parametrization. Modifying the signature is very very tricky\n            # and likely to confuse pytest.\n            baseline_images, extension = func.parameters\n\n            assert len(plt.get_fignums()) == len(baseline_images), (\n                \"Test generated {} images but there are {} baseline images\"\n                .format(len(plt.get_fignums()), len(baseline_images)))\n            for idx, baseline in enumerate(baseline_images):\n                img.compare(idx, baseline, extension)",
        "begin_line": 246,
        "end_line": 264,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00546448087431694,
            "pseudo_dstar_susp": 0.004524886877828055,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.004524886877828055,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.testing.decorators._image_directories#425",
        "src_path": "lib/matplotlib/testing/decorators.py",
        "class_name": "lib.matplotlib.testing.decorators",
        "signature": "lib.matplotlib.testing.decorators._image_directories(func)",
        "snippet": "def _image_directories(func):\n    \"\"\"\n    Compute the baseline and result image directories for testing *func*.\n\n    For test module ``foo.bar.test_baz``, the baseline directory is at\n    ``foo/bar/baseline_images/test_baz`` and the result directory at\n    ``$(pwd)/result_images/test_baz``.  The result directory is created if it\n    doesn't exist.\n    \"\"\"\n    module_path = Path(sys.modules[func.__module__].__file__)\n    baseline_dir = module_path.parent / \"baseline_images\" / module_path.stem\n    result_dir = Path().resolve() / \"result_images\" / module_path.stem\n    result_dir.mkdir(parents=True, exist_ok=True)\n    return baseline_dir, result_dir",
        "begin_line": 425,
        "end_line": 438,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0027472527472527475,
            "pseudo_dstar_susp": 0.0014265335235378032,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0014265335235378032,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._base._process_plot_format#31",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base",
        "signature": "lib.matplotlib.axes._base._process_plot_format(fmt)",
        "snippet": "def _process_plot_format(fmt):\n    \"\"\"\n    Convert a MATLAB style color/line style format string to a (*linestyle*,\n    *marker*, *color*) tuple.\n\n    Example format strings include:\n\n    * 'ko': black circles\n    * '.b': blue dots\n    * 'r--': red dashed lines\n    * 'C2--': the third color in the color cycle, dashed lines\n\n    See Also\n    --------\n    matplotlib.Line2D.lineStyles, matplotlib.colors.cnames\n        All possible styles and color format strings.\n    \"\"\"\n\n    linestyle = None\n    marker = None\n    color = None\n\n    # Is fmt just a colorspec?\n    try:\n        color = mcolors.to_rgba(fmt)\n\n        # We need to differentiate grayscale '1.0' from tri_down marker '1'\n        try:\n            fmtint = str(int(fmt))\n        except ValueError:\n            return linestyle, marker, color  # Yes\n        else:\n            if fmt != fmtint:\n                # user definitely doesn't want tri_down marker\n                return linestyle, marker, color  # Yes\n            else:\n                # ignore converted color\n                color = None\n    except ValueError:\n        pass  # No, not just a color.\n\n    i = 0\n    while i < len(fmt):\n        c = fmt[i]\n        if fmt[i:i+2] in mlines.lineStyles:  # First, the two-char styles.\n            if linestyle is not None:\n                raise ValueError(\n                    'Illegal format string \"%s\"; two linestyle symbols' % fmt)\n            linestyle = fmt[i:i+2]\n            i += 2\n        elif c in mlines.lineStyles:\n            if linestyle is not None:\n                raise ValueError(\n                    'Illegal format string \"%s\"; two linestyle symbols' % fmt)\n            linestyle = c\n            i += 1\n        elif c in mlines.lineMarkers:\n            if marker is not None:\n                raise ValueError(\n                    'Illegal format string \"%s\"; two marker symbols' % fmt)\n            marker = c\n            i += 1\n        elif c in mcolors.get_named_colors_mapping():\n            if color is not None:\n                raise ValueError(\n                    'Illegal format string \"%s\"; two color symbols' % fmt)\n            color = c\n            i += 1\n        elif c == 'C' and i < len(fmt) - 1:\n            color_cycle_number = int(fmt[i + 1])\n            color = mcolors.to_rgba(\"C{}\".format(color_cycle_number))\n            i += 2\n        else:\n            raise ValueError(\n                'Unrecognized character %c in format string' % c)\n\n    if linestyle is None and marker is None:\n        linestyle = rcParams['lines.linestyle']\n    if linestyle is None:\n        linestyle = 'None'\n    if marker is None:\n        marker = 'None'\n\n    return linestyle, marker, color",
        "begin_line": 31,
        "end_line": 114,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003246753246753247,
            "pseudo_dstar_susp": 0.00034071550255536625,
            "pseudo_tarantula_susp": 0.00021791239921551536,
            "pseudo_op2_susp": 0.00034071550255536625,
            "pseudo_barinel_susp": 0.00021791239921551536
        }
    },
    {
        "name": "lib.matplotlib.axes._base._process_plot_var_args.__call__#153",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._process_plot_var_args",
        "signature": "lib.matplotlib.axes._base._process_plot_var_args.__call__(self, *args, **kwargs)",
        "snippet": "    def __call__(self, *args, **kwargs):\n        self.axes._process_unit_info(kwargs=kwargs)\n\n        for pos_only in \"xy\":\n            if pos_only in kwargs:\n                raise TypeError(\"{} got an unexpected keyword argument {!r}\"\n                                .format(self.command, pos_only))\n\n        if not args:\n            return\n\n        # Process the 'data' kwarg.\n        data = kwargs.pop(\"data\", None)\n        if data is not None:\n            replaced = [mpl._replacer(data, arg) for arg in args]\n            if len(args) == 1:\n                label_namer_idx = 0\n            elif len(args) == 2:  # Can be x, y or y, c.\n                # Figure out what the second argument is.\n                # 1) If the second argument cannot be a format shorthand, the\n                #    second argument is the label_namer.\n                # 2) Otherwise (it could have been a format shorthand),\n                #    a) if we did perform a substitution, emit a warning, and\n                #       use it as label_namer.\n                #    b) otherwise, it is indeed a format shorthand; use the\n                #       first argument as label_namer.\n                try:\n                    _process_plot_format(args[1])\n                except ValueError:  # case 1)\n                    label_namer_idx = 1\n                else:\n                    if replaced[1] is not args[1]:  # case 2a)\n                        cbook._warn_external(\n                            f\"Second argument {args[1]!r} is ambiguous: could \"\n                            f\"be a format string but is in 'data'; using as \"\n                            f\"data.  If it was intended as data, set the \"\n                            f\"format string to an empty string to suppress \"\n                            f\"this warning.  If it was intended as a format \"\n                            f\"string, explicitly pass the x-values as well.  \"\n                            f\"Alternatively, rename the entry in 'data'.\",\n                            RuntimeWarning)\n                        label_namer_idx = 1\n                    else:  # case 2b)\n                        label_namer_idx = 0\n            elif len(args) == 3:\n                label_namer_idx = 1\n            else:\n                raise ValueError(\n                    \"Using arbitrary long args with data is not supported due \"\n                    \"to ambiguity of arguments; use multiple plotting calls \"\n                    \"instead\")\n            if kwargs.get(\"label\") is None:\n                kwargs[\"label\"] = mpl._label_from_arg(\n                    replaced[label_namer_idx], args[label_namer_idx])\n            args = replaced\n\n        # Repeatedly grab (x, y) or (x, y, format) from the front of args and\n        # massage them into arguments to plot() or fill().\n        while args:\n            this, args = args[:2], args[2:]\n            if args and isinstance(args[0], str):\n                this += args[0],\n                args = args[1:]\n            yield from self._plot_args(this, kwargs)",
        "begin_line": 153,
        "end_line": 216,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.732158045310446e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._base._process_plot_var_args._getdefaults#224",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._process_plot_var_args",
        "signature": "lib.matplotlib.axes._base._process_plot_var_args._getdefaults(self, ignore, kw)",
        "snippet": "    def _getdefaults(self, ignore, kw):\n        \"\"\"\n        If some keys in the property cycle (excluding those in the set\n        *ignore*) are absent or set to None in the dict *kw*, return a copy\n        of the next entry in the property cycle, excluding keys in *ignore*.\n        Otherwise, don't advance the property cycle, and return an empty dict.\n        \"\"\"\n        prop_keys = self._prop_keys - ignore\n        if any(kw.get(k, None) is None for k in prop_keys):\n            # Need to copy this dictionary or else the next time around\n            # in the cycle, the dictionary could be missing entries.\n            default_dict = next(self.prop_cycler).copy()\n            for p in ignore:\n                default_dict.pop(p, None)\n        else:\n            default_dict = {}\n        return default_dict",
        "begin_line": 224,
        "end_line": 240,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000591715976331361,
            "pseudo_dstar_susp": 0.000691085003455425,
            "pseudo_tarantula_susp": 0.00017073587160662456,
            "pseudo_op2_susp": 0.000691085003455425,
            "pseudo_barinel_susp": 0.00017073587160662456
        }
    },
    {
        "name": "lib.matplotlib.axes._base._process_plot_var_args._setdefaults#242",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._process_plot_var_args",
        "signature": "lib.matplotlib.axes._base._process_plot_var_args._setdefaults(self, defaults, kw)",
        "snippet": "    def _setdefaults(self, defaults, kw):\n        \"\"\"\n        Add to the dict *kw* the entries in the dict *default* that are absent\n        or set to None in *kw*.\n        \"\"\"\n        for k in defaults:\n            if kw.get(k, None) is None:\n                kw[k] = defaults[k]",
        "begin_line": 242,
        "end_line": 249,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00031036623215394165,
            "pseudo_dstar_susp": 0.00034904013961605586,
            "pseudo_tarantula_susp": 0.00015928639694170118,
            "pseudo_op2_susp": 0.00034904013961605586,
            "pseudo_barinel_susp": 0.00015928639694170118
        }
    },
    {
        "name": "lib.matplotlib.axes._base._process_plot_var_args._makeline#251",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._process_plot_var_args",
        "signature": "lib.matplotlib.axes._base._process_plot_var_args._makeline(self, x, y, kw, kwargs)",
        "snippet": "    def _makeline(self, x, y, kw, kwargs):\n        kw = {**kw, **kwargs}  # Don't modify the original kw.\n        default_dict = self._getdefaults(set(), kw)\n        self._setdefaults(default_dict, kw)\n        seg = mlines.Line2D(x, y, **kw)\n        return seg",
        "begin_line": 251,
        "end_line": 256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005577244841048522,
            "pseudo_dstar_susp": 0.000390015600624025,
            "pseudo_tarantula_susp": 0.00021843599825251202,
            "pseudo_op2_susp": 0.000390015600624025,
            "pseudo_barinel_susp": 0.00021843599825251202
        }
    },
    {
        "name": "lib.matplotlib.axes._base._process_plot_var_args._plot_args#310",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._process_plot_var_args",
        "signature": "lib.matplotlib.axes._base._process_plot_var_args._plot_args(self, tup, kwargs)",
        "snippet": "    def _plot_args(self, tup, kwargs):\n        if len(tup) > 1 and isinstance(tup[-1], str):\n            linestyle, marker, color = _process_plot_format(tup[-1])\n            tup = tup[:-1]\n        elif len(tup) == 3:\n            raise ValueError('third arg must be a format string')\n        else:\n            linestyle, marker, color = None, None, None\n\n        # Don't allow any None value; these would be up-converted to one\n        # element array of None which causes problems downstream.\n        if any(v is None for v in tup):\n            raise ValueError(\"x, y, and format string must not be None\")\n\n        kw = {}\n        for k, v in zip(('linestyle', 'marker', 'color'),\n                        (linestyle, marker, color)):\n            if v is not None:\n                kw[k] = v\n\n        if len(tup) == 2:\n            x = _check_1d(tup[0])\n            y = _check_1d(tup[-1])\n        else:\n            x, y = index_of(tup[-1])\n\n        if self.axes.xaxis is not None:\n            self.axes.xaxis.update_units(x)\n        if self.axes.yaxis is not None:\n            self.axes.yaxis.update_units(y)\n\n        if x.shape[0] != y.shape[0]:\n            raise ValueError(f\"x and y must have same first dimension, but \"\n                             f\"have shapes {x.shape} and {y.shape}\")\n        if x.ndim > 2 or y.ndim > 2:\n            raise ValueError(f\"x and y can be no greater than 2-D, but have \"\n                             f\"shapes {x.shape} and {y.shape}\")\n        if x.ndim == 1:\n            x = x[:, np.newaxis]\n        if y.ndim == 1:\n            y = y[:, np.newaxis]\n\n        if self.command == 'plot':\n            func = self._makeline\n        else:\n            kw['closed'] = kwargs.get('closed', True)\n            func = self._makefill\n\n        ncx, ncy = x.shape[1], y.shape[1]\n        if ncx > 1 and ncy > 1 and ncx != ncy:\n            cbook.warn_deprecated(\n                \"2.2\", message=\"cycling among columns of inputs with \"\n                \"non-matching shapes is deprecated.\")\n        return [func(x[:, j % ncx], y[:, j % ncy], kw, kwargs)\n                for j in range(max(ncx, ncy))]",
        "begin_line": 310,
        "end_line": 364,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002638522427440633,
            "pseudo_dstar_susp": 0.00030111412225233364,
            "pseudo_tarantula_susp": 0.00037750094375235937,
            "pseudo_op2_susp": 0.00030111412225233364,
            "pseudo_barinel_susp": 0.00037750094375235937
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.__init__#378",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.__init__(self, fig, rect, facecolor=None, frameon=True, sharex=None, sharey=None, label='', xscale=None, yscale=None, **kwargs)",
        "snippet": "    def __init__(self, fig, rect,\n                 facecolor=None,  # defaults to rc axes.facecolor\n                 frameon=True,\n                 sharex=None,  # use Axes instance's xaxis info\n                 sharey=None,  # use Axes instance's yaxis info\n                 label='',\n                 xscale=None,\n                 yscale=None,\n                 **kwargs\n                 ):\n        \"\"\"\n        Build an axes in a figure.\n\n        Parameters\n        ----------\n        fig : `~matplotlib.figure.Figure`\n            The axes is build in the `.Figure` *fig*.\n\n        rect : [left, bottom, width, height]\n            The axes is build in the rectangle *rect*. *rect* is in\n            `.Figure` coordinates.\n\n        sharex, sharey : `~.axes.Axes`, optional\n            The x or y `~.matplotlib.axis` is shared with the x or\n            y axis in the input `~.axes.Axes`.\n\n        frameon : bool, optional\n            True means that the axes frame is visible.\n\n        **kwargs\n            Other optional keyword arguments:\n\n            %(Axes)s\n\n        Returns\n        -------\n        axes : `~.axes.Axes`\n            The new `~.axes.Axes` object.\n        \"\"\"\n\n        martist.Artist.__init__(self)\n        if isinstance(rect, mtransforms.Bbox):\n            self._position = rect\n        else:\n            self._position = mtransforms.Bbox.from_bounds(*rect)\n        if self._position.width < 0 or self._position.height < 0:\n            raise ValueError('Width and height specified must be non-negative')\n        self._originalPosition = self._position.frozen()\n        self.axes = self\n        self._aspect = 'auto'\n        self._adjustable = 'box'\n        self._anchor = 'C'\n        self._stale_viewlim_x = False\n        self._stale_viewlim_y = False\n        self._sharex = sharex\n        self._sharey = sharey\n        if sharex is not None:\n            self._shared_x_axes.join(self, sharex)\n        if sharey is not None:\n            self._shared_y_axes.join(self, sharey)\n        self.set_label(label)\n        self.set_figure(fig)\n\n        self.set_axes_locator(kwargs.get(\"axes_locator\", None))\n\n        self.spines = self._gen_axes_spines()\n\n        # this call may differ for non-sep axes, e.g., polar\n        self._init_axis()\n        if facecolor is None:\n            facecolor = rcParams['axes.facecolor']\n        self._facecolor = facecolor\n        self._frameon = frameon\n        self.set_axisbelow(rcParams['axes.axisbelow'])\n\n        self._rasterization_zorder = None\n        self.cla()\n\n        # funcs used to format x and y - fall back on major formatters\n        self.fmt_xdata = None\n        self.fmt_ydata = None\n\n        self.set_navigate(True)\n        self.set_navigate_mode(None)\n\n        if xscale:\n            self.set_xscale(xscale)\n        if yscale:\n            self.set_yscale(yscale)\n\n        self.update(kwargs)\n\n        if self.xaxis is not None:\n            self._xcid = self.xaxis.callbacks.connect(\n                'units finalize', lambda: self._on_units_changed(scalex=True))\n\n        if self.yaxis is not None:\n            self._ycid = self.yaxis.callbacks.connect(\n                'units finalize', lambda: self._on_units_changed(scaley=True))\n\n        self.tick_params(\n            top=rcParams['xtick.top'] and rcParams['xtick.minor.top'],\n            bottom=rcParams['xtick.bottom'] and rcParams['xtick.minor.bottom'],\n            labeltop=(rcParams['xtick.labeltop'] and\n                      rcParams['xtick.minor.top']),\n            labelbottom=(rcParams['xtick.labelbottom'] and\n                         rcParams['xtick.minor.bottom']),\n            left=rcParams['ytick.left'] and rcParams['ytick.minor.left'],\n            right=rcParams['ytick.right'] and rcParams['ytick.minor.right'],\n            labelleft=(rcParams['ytick.labelleft'] and\n                       rcParams['ytick.minor.left']),\n            labelright=(rcParams['ytick.labelright'] and\n                        rcParams['ytick.minor.right']),\n            which='minor')\n\n        self.tick_params(\n            top=rcParams['xtick.top'] and rcParams['xtick.major.top'],\n            bottom=rcParams['xtick.bottom'] and rcParams['xtick.major.bottom'],\n            labeltop=(rcParams['xtick.labeltop'] and\n                      rcParams['xtick.major.top']),\n            labelbottom=(rcParams['xtick.labelbottom'] and\n                         rcParams['xtick.major.bottom']),\n            left=rcParams['ytick.left'] and rcParams['ytick.major.left'],\n            right=rcParams['ytick.right'] and rcParams['ytick.major.right'],\n            labelleft=(rcParams['ytick.labelleft'] and\n                       rcParams['ytick.major.left']),\n            labelright=(rcParams['ytick.labelright'] and\n                        rcParams['ytick.major.right']),\n            which='major')\n\n        self._layoutbox = None\n        self._poslayoutbox = None",
        "begin_line": 378,
        "end_line": 509,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00044033465433729633,
            "pseudo_dstar_susp": 0.0005763688760806917,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.0005763688760806917,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._init_axis#553",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._init_axis(self)",
        "snippet": "    def _init_axis(self):\n        \"move this out of __init__ because non-separable axes don't use it\"\n        self.xaxis = maxis.XAxis(self)\n        self.spines['bottom'].register_axis(self.xaxis)\n        self.spines['top'].register_axis(self.xaxis)\n        self.yaxis = maxis.YAxis(self)\n        self.spines['left'].register_axis(self.yaxis)\n        self.spines['right'].register_axis(self.yaxis)\n        self._update_transScale()",
        "begin_line": 553,
        "end_line": 561,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002630194634402946,
            "pseudo_dstar_susp": 0.00032414910858995135,
            "pseudo_tarantula_susp": 0.00013713658804168953,
            "pseudo_op2_susp": 0.00032414910858995135,
            "pseudo_barinel_susp": 0.00013713658804168953
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_figure#563",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_figure(self, fig)",
        "snippet": "    def set_figure(self, fig):\n        \"\"\"\n        Set the `.Figure` for this `.Axes`.\n\n        Parameters\n        ----------\n        fig : `.Figure`\n        \"\"\"\n        martist.Artist.set_figure(self, fig)\n\n        self.bbox = mtransforms.TransformedBbox(self._position,\n                                                fig.transFigure)\n        # these will be updated later as data is added\n        self.dataLim = mtransforms.Bbox.null()\n        self._viewLim = mtransforms.Bbox.unit()\n        self.transScale = mtransforms.TransformWrapper(\n            mtransforms.IdentityTransform())\n\n        self._set_lim_and_transforms()",
        "begin_line": 563,
        "end_line": 581,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021399529210357372,
            "pseudo_dstar_susp": 0.0002842524161455372,
            "pseudo_tarantula_susp": 0.000129315918789603,
            "pseudo_op2_susp": 0.0002842524161455372,
            "pseudo_barinel_susp": 0.000129315918789603
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._unstale_viewLim#583",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._unstale_viewLim(self)",
        "snippet": "    def _unstale_viewLim(self):\n        # We should arrange to store this information once per share-group\n        # instead of on every axis.\n        scalex = any(ax._stale_viewlim_x\n                     for ax in self._shared_x_axes.get_siblings(self))\n        scaley = any(ax._stale_viewlim_y\n                     for ax in self._shared_y_axes.get_siblings(self))\n        if scalex or scaley:\n            for ax in self._shared_x_axes.get_siblings(self):\n                ax._stale_viewlim_x = False\n            for ax in self._shared_y_axes.get_siblings(self):\n                ax._stale_viewlim_y = False\n            self.autoscale_view(scalex=scalex, scaley=scaley)",
        "begin_line": 583,
        "end_line": 595,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002754820936639118,
            "pseudo_dstar_susp": 0.0002493143854400399,
            "pseudo_tarantula_susp": 0.0003204101249599487,
            "pseudo_op2_susp": 0.0002493143854400399,
            "pseudo_barinel_susp": 0.0003204101249599487
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._request_autoscale_view#604",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._request_autoscale_view(self, tight=None, scalex=True, scaley=True)",
        "snippet": "    def _request_autoscale_view(self, tight=None, scalex=True, scaley=True):\n        if tight is not None:\n            self._tight = tight\n        if scalex:\n            self._stale_viewlim_x = True  # Else keep old state.\n        if scaley:\n            self._stale_viewlim_y = True",
        "begin_line": 604,
        "end_line": 610,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003194888178913738,
            "pseudo_dstar_susp": 0.0003563791874554526,
            "pseudo_tarantula_susp": 0.00030193236714975844,
            "pseudo_op2_susp": 0.0003563791874554526,
            "pseudo_barinel_susp": 0.00030193236714975844
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._set_lim_and_transforms#612",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._set_lim_and_transforms(self)",
        "snippet": "    def _set_lim_and_transforms(self):\n        \"\"\"\n        Set the *_xaxis_transform*, *_yaxis_transform*, *transScale*,\n        *transData*, *transLimits* and *transAxes* transformations.\n\n        .. note::\n\n            This method is primarily used by rectilinear projections of the\n            `~matplotlib.axes.Axes` class, and is meant to be overridden by\n            new kinds of projection axes that need different transformations\n            and limits. (See `~matplotlib.projections.polar.PolarAxes` for an\n            example.)\n        \"\"\"\n        self.transAxes = mtransforms.BboxTransformTo(self.bbox)\n\n        # Transforms the x and y axis separately by a scale factor.\n        # It is assumed that this part will have non-linear components\n        # (e.g., for a log scale).\n        self.transScale = mtransforms.TransformWrapper(\n            mtransforms.IdentityTransform())\n\n        # An affine transformation on the data, generally to limit the\n        # range of the axes\n        self.transLimits = mtransforms.BboxTransformFrom(\n            mtransforms.TransformedBbox(self._viewLim, self.transScale))\n\n        # The parentheses are important for efficiency here -- they\n        # group the last two (which are usually affines) separately\n        # from the first (which, with log-scaling can be non-affine).\n        self.transData = self.transScale + (self.transLimits + self.transAxes)\n\n        self._xaxis_transform = mtransforms.blended_transform_factory(\n            self.transData, self.transAxes)\n        self._yaxis_transform = mtransforms.blended_transform_factory(\n            self.transAxes, self.transData)",
        "begin_line": 612,
        "end_line": 646,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003486750348675035,
            "pseudo_dstar_susp": 0.00047596382674916705,
            "pseudo_tarantula_susp": 0.00013904338153503893,
            "pseudo_op2_susp": 0.00047596382674916705,
            "pseudo_barinel_susp": 0.00013904338153503893
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_xaxis_transform#648",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_xaxis_transform(self, which='grid')",
        "snippet": "    def get_xaxis_transform(self, which='grid'):\n        \"\"\"\n        Get the transformation used for drawing x-axis labels, ticks\n        and gridlines.  The x-direction is in data coordinates and the\n        y-direction is in axis coordinates.\n\n        .. note::\n\n            This transformation is primarily used by the\n            `~matplotlib.axis.Axis` class, and is meant to be\n            overridden by new kinds of projections that may need to\n            place axis elements in different locations.\n        \"\"\"\n        if which == 'grid':\n            return self._xaxis_transform\n        elif which == 'tick1':\n            # for cartesian projection, this is bottom spine\n            return self.spines['bottom'].get_spine_transform()\n        elif which == 'tick2':\n            # for cartesian projection, this is top spine\n            return self.spines['top'].get_spine_transform()\n        else:\n            raise ValueError('unknown value for which')",
        "begin_line": 648,
        "end_line": 670,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.662835249042145e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_xaxis_text1_transform#672",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_xaxis_text1_transform(self, pad_points)",
        "snippet": "    def get_xaxis_text1_transform(self, pad_points):\n        \"\"\"\n        Returns\n        -------\n        transform : Transform\n            The transform used for drawing x-axis labels, which will add\n            *pad_points* of padding (in points) between the axes and the label.\n            The x-direction is in data coordinates and the y-direction is in\n            axis corrdinates\n        valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}\n            The text vertical alignment.\n        halign : {'center', 'left', 'right'}\n            The text horizontal alignment.\n\n        Notes\n        -----\n        This transformation is primarily used by the `~matplotlib.axis.Axis`\n        class, and is meant to be overridden by new kinds of projections that\n        may need to place axis elements in different locations.\n        \"\"\"\n        labels_align = rcParams[\"xtick.alignment\"]\n        return (self.get_xaxis_transform(which='tick1') +\n                mtransforms.ScaledTranslation(0, -1 * pad_points / 72,\n                                              self.figure.dpi_scale_trans),\n                \"top\", labels_align)",
        "begin_line": 672,
        "end_line": 696,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00026932399676811203,
            "pseudo_dstar_susp": 0.0003315649867374005,
            "pseudo_tarantula_susp": 0.00031426775612822125,
            "pseudo_op2_susp": 0.0003315649867374005,
            "pseudo_barinel_susp": 0.00031426775612822125
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_xaxis_text2_transform#698",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_xaxis_text2_transform(self, pad_points)",
        "snippet": "    def get_xaxis_text2_transform(self, pad_points):\n        \"\"\"\n        Returns\n        -------\n        transform : Transform\n            The transform used for drawing secondary x-axis labels, which will\n            add *pad_points* of padding (in points) between the axes and the\n            label.  The x-direction is in data coordinates and the y-direction\n            is in axis corrdinates\n        valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}\n            The text vertical alignment.\n        halign : {'center', 'left', 'right'}\n            The text horizontal alignment.\n\n        Notes\n        -----\n        This transformation is primarily used by the `~matplotlib.axis.Axis`\n        class, and is meant to be overridden by new kinds of projections that\n        may need to place axis elements in different locations.\n        \"\"\"\n        labels_align = rcParams[\"xtick.alignment\"]\n        return (self.get_xaxis_transform(which='tick2') +\n                mtransforms.ScaledTranslation(0, pad_points / 72,\n                                              self.figure.dpi_scale_trans),\n                \"bottom\", labels_align)",
        "begin_line": 698,
        "end_line": 722,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00026961445133459155,
            "pseudo_dstar_susp": 0.00033233632436025255,
            "pseudo_tarantula_susp": 0.00013702384214853386,
            "pseudo_op2_susp": 0.00033233632436025255,
            "pseudo_barinel_susp": 0.00013702384214853386
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_yaxis_transform#724",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_yaxis_transform(self, which='grid')",
        "snippet": "    def get_yaxis_transform(self, which='grid'):\n        \"\"\"\n        Get the transformation used for drawing y-axis labels, ticks\n        and gridlines.  The x-direction is in axis coordinates and the\n        y-direction is in data coordinates.\n\n        .. note::\n\n            This transformation is primarily used by the\n            `~matplotlib.axis.Axis` class, and is meant to be\n            overridden by new kinds of projections that may need to\n            place axis elements in different locations.\n        \"\"\"\n        if which == 'grid':\n            return self._yaxis_transform\n        elif which == 'tick1':\n            # for cartesian projection, this is bottom spine\n            return self.spines['left'].get_spine_transform()\n        elif which == 'tick2':\n            # for cartesian projection, this is top spine\n            return self.spines['right'].get_spine_transform()\n        else:\n            raise ValueError('unknown value for which')",
        "begin_line": 724,
        "end_line": 746,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003447087211306446,
            "pseudo_dstar_susp": 0.0004329004329004329,
            "pseudo_tarantula_susp": 0.00014174344436569808,
            "pseudo_op2_susp": 0.0004329004329004329,
            "pseudo_barinel_susp": 0.00014174344436569808
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_yaxis_text1_transform#748",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_yaxis_text1_transform(self, pad_points)",
        "snippet": "    def get_yaxis_text1_transform(self, pad_points):\n        \"\"\"\n        Returns\n        -------\n        transform : Transform\n            The transform used for drawing y-axis labels, which will add\n            *pad_points* of padding (in points) between the axes and the label.\n            The x-direction is in axis coordinates and the y-direction is in\n            data corrdinates\n        valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}\n            The text vertical alignment.\n        halign : {'center', 'left', 'right'}\n            The text horizontal alignment.\n\n        Notes\n        -----\n        This transformation is primarily used by the `~matplotlib.axis.Axis`\n        class, and is meant to be overridden by new kinds of projections that\n        may need to place axis elements in different locations.\n        \"\"\"\n        labels_align = rcParams[\"ytick.alignment\"]\n        return (self.get_yaxis_transform(which='tick1') +\n                mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,\n                                              self.figure.dpi_scale_trans),\n                labels_align, \"right\")",
        "begin_line": 748,
        "end_line": 772,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002796420581655481,
            "pseudo_dstar_susp": 0.0002585983966899405,
            "pseudo_tarantula_susp": 0.0002878526194588371,
            "pseudo_op2_susp": 0.0002585983966899405,
            "pseudo_barinel_susp": 0.0002878526194588371
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_yaxis_text2_transform#774",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_yaxis_text2_transform(self, pad_points)",
        "snippet": "    def get_yaxis_text2_transform(self, pad_points):\n        \"\"\"\n        Returns\n        -------\n        transform : Transform\n            The transform used for drawing secondart y-axis labels, which will\n            add *pad_points* of padding (in points) between the axes and the\n            label.  The x-direction is in axis coordinates and the y-direction\n            is in data corrdinates\n        valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}\n            The text vertical alignment.\n        halign : {'center', 'left', 'right'}\n            The text horizontal alignment.\n\n        Notes\n        -----\n        This transformation is primarily used by the `~matplotlib.axis.Axis`\n        class, and is meant to be overridden by new kinds of projections that\n        may need to place axis elements in different locations.\n        \"\"\"\n        labels_align = rcParams[\"ytick.alignment\"]\n        return (self.get_yaxis_transform(which='tick2') +\n                mtransforms.ScaledTranslation(pad_points / 72, 0,\n                                              self.figure.dpi_scale_trans),\n                labels_align, \"left\")",
        "begin_line": 774,
        "end_line": 798,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017966223499820338,
            "pseudo_dstar_susp": 0.0002426595486532395,
            "pseudo_tarantula_susp": 0.00012068549360366884,
            "pseudo_op2_susp": 0.0002426595486532395,
            "pseudo_barinel_susp": 0.00012068549360366884
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._update_transScale#800",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._update_transScale(self)",
        "snippet": "    def _update_transScale(self):\n        self.transScale.set(\n            mtransforms.blended_transform_factory(\n                self.xaxis.get_transform(), self.yaxis.get_transform()))\n        for line in getattr(self, \"lines\", []):  # Not set during init.\n            try:\n                line._transformed_path.invalidate()\n            except AttributeError:\n                pass",
        "begin_line": 800,
        "end_line": 808,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00028563267637817766,
            "pseudo_dstar_susp": 0.0003190810465858328,
            "pseudo_tarantula_susp": 0.0002977963073257892,
            "pseudo_op2_susp": 0.0003190810465858328,
            "pseudo_barinel_susp": 0.0002977963073257892
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._set_position#859",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._set_position(self, pos, which='both')",
        "snippet": "    def _set_position(self, pos, which='both'):\n        \"\"\"\n        private version of set_position.  Call this internally\n        to get the same functionality of `get_position`, but not\n        to take the axis out of the constrained_layout\n        hierarchy.\n        \"\"\"\n        if not isinstance(pos, mtransforms.BboxBase):\n            pos = mtransforms.Bbox.from_bounds(*pos)\n        for ax in self._twinned_axes.get_siblings(self):\n            if which in ('both', 'active'):\n                ax._position.set(pos)\n            if which in ('both', 'original'):\n                ax._originalPosition.set(pos)\n        self.stale = True",
        "begin_line": 859,
        "end_line": 873,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005434782608695652,
            "pseudo_dstar_susp": 0.0004210526315789474,
            "pseudo_tarantula_susp": 0.0002039983680130559,
            "pseudo_op2_susp": 0.0004210526315789474,
            "pseudo_barinel_susp": 0.0002039983680130559
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_axes_locator#886",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_axes_locator(self, locator)",
        "snippet": "    def set_axes_locator(self, locator):\n        \"\"\"\n        Set the axes locator.\n\n        Parameters\n        ----------\n        locator : Callable[[Axes, Renderer], Bbox]\n        \"\"\"\n        self._axes_locator = locator\n        self.stale = True",
        "begin_line": 886,
        "end_line": 895,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002461235540241201,
            "pseudo_dstar_susp": 0.00023747328425552126,
            "pseudo_tarantula_susp": 0.00025471217524197657,
            "pseudo_op2_susp": 0.00023747328425552126,
            "pseudo_barinel_susp": 0.00025471217524197657
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_axes_locator#897",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_axes_locator(self)",
        "snippet": "    def get_axes_locator(self):\n        \"\"\"\n        Return the axes_locator.\n        \"\"\"\n        return self._axes_locator",
        "begin_line": 897,
        "end_line": 901,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00028153153153153153,
            "pseudo_dstar_susp": 0.0002516989680342311,
            "pseudo_tarantula_susp": 0.00032393909944930353,
            "pseudo_op2_susp": 0.0002516989680342311,
            "pseudo_barinel_susp": 0.00032393909944930353
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._set_artist_props#903",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._set_artist_props(self, a)",
        "snippet": "    def _set_artist_props(self, a):\n        \"\"\"set the boilerplate props for artists added to axes\"\"\"\n        a.set_figure(self.figure)\n        if not a.is_transform_set():\n            a.set_transform(self.transData)\n\n        a.axes = self\n        if a.mouseover:\n            self._mouseover_set.add(a)",
        "begin_line": 903,
        "end_line": 911,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.70594128072744e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.cla#948",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.cla(self)",
        "snippet": "    def cla(self):\n        \"\"\"Clear the current axes.\"\"\"\n        # Note: this is called by Axes.__init__()\n\n        # stash the current visibility state\n        if hasattr(self, 'patch'):\n            patch_visible = self.patch.get_visible()\n        else:\n            patch_visible = True\n\n        xaxis_visible = self.xaxis.get_visible()\n        yaxis_visible = self.yaxis.get_visible()\n\n        self.xaxis.cla()\n        self.yaxis.cla()\n\n        for name, spine in self.spines.items():\n            spine.cla()\n\n        self.ignore_existing_data_limits = True\n        self.callbacks = cbook.CallbackRegistry()\n\n        if self._sharex is not None:\n            # major and minor are axis.Ticker class instances with\n            # locator and formatter attributes\n            self.xaxis.major = self._sharex.xaxis.major\n            self.xaxis.minor = self._sharex.xaxis.minor\n            x0, x1 = self._sharex.get_xlim()\n            self.set_xlim(x0, x1, emit=False,\n                          auto=self._sharex.get_autoscalex_on())\n            self.xaxis._scale = self._sharex.xaxis._scale\n        else:\n            self.xaxis._set_scale('linear')\n            try:\n                self.set_xlim(0, 1)\n            except TypeError:\n                pass\n\n        if self._sharey is not None:\n            self.yaxis.major = self._sharey.yaxis.major\n            self.yaxis.minor = self._sharey.yaxis.minor\n            y0, y1 = self._sharey.get_ylim()\n            self.set_ylim(y0, y1, emit=False,\n                          auto=self._sharey.get_autoscaley_on())\n            self.yaxis._scale = self._sharey.yaxis._scale\n        else:\n            self.yaxis._set_scale('linear')\n            try:\n                self.set_ylim(0, 1)\n            except TypeError:\n                pass\n        # update the minor locator for x and y axis based on rcParams\n        if rcParams['xtick.minor.visible']:\n            self.xaxis.set_minor_locator(mticker.AutoMinorLocator())\n\n        if rcParams['ytick.minor.visible']:\n            self.yaxis.set_minor_locator(mticker.AutoMinorLocator())\n\n        if self._sharex is None:\n            self._autoscaleXon = True\n        if self._sharey is None:\n            self._autoscaleYon = True\n        self._xmargin = rcParams['axes.xmargin']\n        self._ymargin = rcParams['axes.ymargin']\n        self._tight = None\n        self._use_sticky_edges = True\n        self._update_transScale()  # needed?\n\n        self._get_lines = _process_plot_var_args(self)\n        self._get_patches_for_fill = _process_plot_var_args(self, 'fill')\n\n        self._gridOn = rcParams['axes.grid']\n        self.lines = []\n        self.patches = []\n        self.texts = []\n        self.tables = []\n        self.artists = []\n        self.images = []\n        self._mouseover_set = _OrderedSet()\n        self.child_axes = []\n        self._current_image = None  # strictly for pyplot via _sci, _gci\n        self.legend_ = None\n        self.collections = []  # collection.Collection instances\n        self.containers = []\n\n        self.grid(False)  # Disable grid on init to use rcParameter\n        self.grid(self._gridOn, which=rcParams['axes.grid.which'],\n                  axis=rcParams['axes.grid.axis'])\n        props = font_manager.FontProperties(\n            size=rcParams['axes.titlesize'],\n            weight=rcParams['axes.titleweight'])\n\n        self.title = mtext.Text(\n            x=0.5, y=1.0, text='',\n            fontproperties=props,\n            verticalalignment='baseline',\n            horizontalalignment='center',\n            )\n        self._left_title = mtext.Text(\n            x=0.0, y=1.0, text='',\n            fontproperties=props.copy(),\n            verticalalignment='baseline',\n            horizontalalignment='left', )\n        self._right_title = mtext.Text(\n            x=1.0, y=1.0, text='',\n            fontproperties=props.copy(),\n            verticalalignment='baseline',\n            horizontalalignment='right',\n            )\n        title_offset_points = rcParams['axes.titlepad']\n        # refactor this out so it can be called in ax.set_title if\n        # pad argument used...\n        self._set_title_offset_trans(title_offset_points)\n        # determine if the title position has been set manually:\n        self._autotitlepos = None\n\n        for _title in (self.title, self._left_title, self._right_title):\n            self._set_artist_props(_title)\n\n        # The patch draws the background of the axes.  We want this to be below\n        # the other artists.  We use the frame to draw the edges so we are\n        # setting the edgecolor to None.\n        self.patch = self._gen_axes_patch()\n        self.patch.set_figure(self.figure)\n        self.patch.set_facecolor(self._facecolor)\n        self.patch.set_edgecolor('None')\n        self.patch.set_linewidth(0)\n        self.patch.set_transform(self.transAxes)\n\n        self.set_axis_on()\n\n        self.xaxis.set_clip_path(self.patch)\n        self.yaxis.set_clip_path(self.patch)\n\n        self._shared_x_axes.clean()\n        self._shared_y_axes.clean()\n        if self._sharex:\n            self.xaxis.set_visible(xaxis_visible)\n            self.patch.set_visible(patch_visible)\n\n        if self._sharey:\n            self.yaxis.set_visible(yaxis_visible)\n            self.patch.set_visible(patch_visible)\n\n        self.stale = True",
        "begin_line": 948,
        "end_line": 1092,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043878894251864854,
            "pseudo_dstar_susp": 0.0006242197253433209,
            "pseudo_tarantula_susp": 0.00022187708009762592,
            "pseudo_op2_susp": 0.0006242197253433209,
            "pseudo_barinel_susp": 0.00022187708009762592
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_facecolor#1098",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_facecolor(self)",
        "snippet": "    def get_facecolor(self):\n        \"\"\"Get the facecolor of the Axes.\"\"\"\n        return self.patch.get_facecolor()",
        "begin_line": 1098,
        "end_line": 1100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015992323684631377,
            "pseudo_dstar_susp": 0.0001405086412814388,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.0001405086412814388,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._set_title_offset_trans#1116",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._set_title_offset_trans(self, title_offset_points)",
        "snippet": "    def _set_title_offset_trans(self, title_offset_points):\n        \"\"\"\n        Set the offset for the title either from rcParams['axes.titlepad']\n        or from set_title kwarg ``pad``.\n        \"\"\"\n        self.titleOffsetTrans = mtransforms.ScaledTranslation(\n                0.0, title_offset_points / 72,\n                self.figure.dpi_scale_trans)\n        for _title in (self.title, self._left_title, self._right_title):\n            _title.set_transform(self.transAxes + self.titleOffsetTrans)\n            _title.set_clip_box(None)",
        "begin_line": 1116,
        "end_line": 1126,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043878894251864854,
            "pseudo_dstar_susp": 0.0006242197253433209,
            "pseudo_tarantula_susp": 0.00029069767441860465,
            "pseudo_op2_susp": 0.0006242197253433209,
            "pseudo_barinel_susp": 0.00029069767441860465
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_prop_cycle#1128",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_prop_cycle(self, *args, **kwargs)",
        "snippet": "    def set_prop_cycle(self, *args, **kwargs):\n        \"\"\"\n        Set the property cycle of the Axes.\n\n        The property cycle controls the style properties such as color,\n        marker and linestyle of future plot commands. The style properties\n        of data already added to the Axes are not modified.\n\n        Call signatures::\n\n          set_prop_cycle(cycler)\n          set_prop_cycle(label=values[, label2=values2[, ...]])\n          set_prop_cycle(label, values)\n\n        Form 1 sets given `~cycler.Cycler` object.\n\n        Form 2 creates a `~cycler.Cycler` which cycles over one or more\n        properties simultaneously and set it as the property cycle of the\n        axes. If multiple properties are given, their value lists must have\n        the same length. This is just a shortcut for explicitly creating a\n        cycler and passing it to the function, i.e. it's short for\n        ``set_prop_cycle(cycler(label=values label2=values2, ...))``.\n\n        Form 3 creates a `~cycler.Cycler` for a single property and set it\n        as the property cycle of the axes. This form exists for compatibility\n        with the original `cycler.cycler` interface. Its use is discouraged\n        in favor of the kwarg form, i.e. ``set_prop_cycle(label=values)``.\n\n        Parameters\n        ----------\n        cycler : Cycler\n            Set the given Cycler. *None* resets to the cycle defined by the\n            current style.\n\n        label : str\n            The property key. Must be a valid `.Artist` property.\n            For example, 'color' or 'linestyle'. Aliases are allowed,\n            such as 'c' for 'color' and 'lw' for 'linewidth'.\n\n        values : iterable\n            Finite-length iterable of the property values. These values\n            are validated and will raise a ValueError if invalid.\n\n        Examples\n        --------\n        Setting the property cycle for a single property:\n\n        >>> ax.set_prop_cycle(color=['red', 'green', 'blue'])\n\n        Setting the property cycle for simultaneously cycling over multiple\n        properties (e.g. red circle, green plus, blue cross):\n\n        >>> ax.set_prop_cycle(color=['red', 'green', 'blue'],\n        ...                   marker=['o', '+', 'x'])\n\n        See Also\n        --------\n        matplotlib.rcsetup.cycler\n            Convenience function for creating validated cyclers for properties.\n        cycler.cycler\n            The original function for creating unvalidated cyclers.\n\n        \"\"\"\n        if args and kwargs:\n            raise TypeError(\"Cannot supply both positional and keyword \"\n                            \"arguments to this method.\")\n        # Can't do `args == (None,)` as that crashes cycler.\n        if len(args) == 1 and args[0] is None:\n            prop_cycle = None\n        else:\n            prop_cycle = cycler(*args, **kwargs)\n        self._get_lines.set_prop_cycle(prop_cycle)\n        self._get_patches_for_fill.set_prop_cycle(prop_cycle)",
        "begin_line": 1128,
        "end_line": 1200,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_aspect#1202",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_aspect(self)",
        "snippet": "    def get_aspect(self):\n        return self._aspect",
        "begin_line": 1202,
        "end_line": 1203,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005659309564233164,
            "pseudo_dstar_susp": 0.0004868549172346641,
            "pseudo_tarantula_susp": 0.0002021835826930853,
            "pseudo_op2_susp": 0.0004868549172346641,
            "pseudo_barinel_susp": 0.0002021835826930853
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_aspect#1205",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_aspect(self, aspect, adjustable=None, anchor=None, share=False)",
        "snippet": "    def set_aspect(self, aspect, adjustable=None, anchor=None, share=False):\n        \"\"\"\n        Set the aspect of the axis scaling, i.e. the ratio of y-unit to x-unit.\n\n        Parameters\n        ----------\n        aspect : {'auto', 'equal'} or num\n            Possible values:\n\n            ========   ================================================\n            value      description\n            ========   ================================================\n            'auto'     automatic; fill the position rectangle with data\n            'equal'    same scaling from data to plot units for x and y\n             num       a circle will be stretched such that the height\n                       is num times the width. aspect=1 is the same as\n                       aspect='equal'.\n            ========   ================================================\n\n        adjustable : None or {'box', 'datalim'}, optional\n            If not ``None``, this defines which parameter will be adjusted to\n            meet the required aspect. See `.set_adjustable` for further\n            details.\n\n        anchor : None or str or 2-tuple of float, optional\n            If not ``None``, this defines where the Axes will be drawn if there\n            is extra space due to aspect constraints. The most common way to\n            to specify the anchor are abbreviations of cardinal directions:\n\n            =====   =====================\n            value   description\n            =====   =====================\n            'C'     centered\n            'SW'    lower left corner\n            'S'     middle of bottom edge\n            'SE'    lower right corner\n            etc.\n            =====   =====================\n\n            See `.set_anchor` for further details.\n\n        share : bool, optional\n            If ``True``, apply the settings to all shared Axes.\n            Default is ``False``.\n\n        See Also\n        --------\n        matplotlib.axes.Axes.set_adjustable\n            defining the parameter to adjust in order to meet the required\n            aspect.\n        matplotlib.axes.Axes.set_anchor\n            defining the position in case of extra space.\n        \"\"\"\n        if not (cbook._str_equal(aspect, 'equal')\n                or cbook._str_equal(aspect, 'auto')):\n            aspect = float(aspect)  # raise ValueError if necessary\n\n        if (not cbook._str_equal(aspect, 'auto')) and self.name == '3d':\n            raise NotImplementedError(\n                'It is not currently possible to manually set the aspect '\n                'on 3D axes')\n\n        if share:\n            axes = {*self._shared_x_axes.get_siblings(self),\n                    *self._shared_y_axes.get_siblings(self)}\n        else:\n            axes = [self]\n\n        for ax in axes:\n            ax._aspect = aspect\n\n        if adjustable is None:\n            adjustable = self._adjustable\n        self.set_adjustable(adjustable, share=share)  # Handle sharing.\n\n        if anchor is not None:\n            self.set_anchor(anchor, share=share)\n        self.stale = True",
        "begin_line": 1205,
        "end_line": 1282,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023435669088352472,
            "pseudo_dstar_susp": 0.00028993911278631486,
            "pseudo_tarantula_susp": 0.00016286644951140066,
            "pseudo_op2_susp": 0.00028993911278631486,
            "pseudo_barinel_susp": 0.00016286644951140066
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_adjustable#1287",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_adjustable(self, adjustable, share=False)",
        "snippet": "    def set_adjustable(self, adjustable, share=False):\n        \"\"\"\n        Define which parameter the Axes will change to achieve a given aspect.\n\n        Parameters\n        ----------\n        adjustable : {'box', 'datalim'}\n            If 'box', change the physical dimensions of the Axes.\n            If 'datalim', change the ``x`` or ``y`` data limits.\n\n        share : bool, optional\n            If ``True``, apply the settings to all shared Axes.\n            Default is ``False``.\n\n        See Also\n        --------\n        matplotlib.axes.Axes.set_aspect\n            for a description of aspect handling.\n\n        Notes\n        -----\n        Shared Axes (of which twinned Axes are a special case)\n        impose restrictions on how aspect ratios can be imposed.\n        For twinned Axes, use 'datalim'.  For Axes that share both\n        x and y, use 'box'.  Otherwise, either 'datalim' or 'box'\n        may be used.  These limitations are partly a requirement\n        to avoid over-specification, and partly a result of the\n        particular implementation we are currently using, in\n        which the adjustments for aspect ratios are done sequentially\n        and independently on each Axes as it is drawn.\n        \"\"\"\n        cbook._check_in_list([\"box\", \"datalim\"], adjustable=adjustable)\n        if share:\n            axs = {*self._shared_x_axes.get_siblings(self),\n                   *self._shared_y_axes.get_siblings(self)}\n        else:\n            axs = [self]\n        if (adjustable == \"datalim\"\n                and any(getattr(ax.get_data_ratio, \"__func__\", None)\n                        != _AxesBase.get_data_ratio\n                        for ax in axs)):\n            # Limits adjustment by apply_aspect assumes that the axes' aspect\n            # ratio can be computed from the data limits and scales.\n            raise ValueError(\"Cannot set axes adjustable to 'datalim' for \"\n                             \"Axes which override 'get_data_ratio'\")\n        for ax in axs:\n            ax._adjustable = adjustable\n        self.stale = True",
        "begin_line": 1287,
        "end_line": 1334,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000234192037470726,
            "pseudo_dstar_susp": 0.0002973535533749628,
            "pseudo_tarantula_susp": 0.00016711229946524063,
            "pseudo_op2_susp": 0.0002973535533749628,
            "pseudo_barinel_susp": 0.00016711229946524063
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_anchor#1349",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_anchor(self, anchor, share=False)",
        "snippet": "    def set_anchor(self, anchor, share=False):\n        \"\"\"\n        Define the anchor location.\n\n        The actual drawing area (active position) of the Axes may be smaller\n        than the Bbox (original position) when a fixed aspect is required. The\n        anchor defines where the drawing area will be located within the\n        available space.\n\n        Parameters\n        ----------\n        anchor : 2-tuple of floats or {'C', 'SW', 'S', 'SE', ...}\n            The anchor position may be either:\n\n            - a sequence (*cx*, *cy*). *cx* and *cy* may range from 0\n              to 1, where 0 is left or bottom and 1 is right or top.\n\n            - a string using cardinal directions as abbreviation:\n\n              - 'C' for centered\n              - 'S' (south) for bottom-center\n              - 'SW' (south west) for bottom-left\n              - etc.\n\n              Here is an overview of the possible positions:\n\n              +------+------+------+\n              | 'NW' | 'N'  | 'NE' |\n              +------+------+------+\n              | 'W'  | 'C'  | 'E'  |\n              +------+------+------+\n              | 'SW' | 'S'  | 'SE' |\n              +------+------+------+\n\n        share : bool, optional\n            If ``True``, apply the settings to all shared Axes.\n            Default is ``False``.\n\n        See Also\n        --------\n        matplotlib.axes.Axes.set_aspect\n            for a description of aspect handling.\n        \"\"\"\n        if not (anchor in mtransforms.Bbox.coefs or len(anchor) == 2):\n            raise ValueError('argument must be among %s' %\n                             ', '.join(mtransforms.Bbox.coefs))\n        if share:\n            axes = {*self._shared_x_axes.get_siblings(self),\n                    *self._shared_y_axes.get_siblings(self)}\n        else:\n            axes = [self]\n        for ax in axes:\n            ax._anchor = anchor\n\n        self.stale = True",
        "begin_line": 1349,
        "end_line": 1403,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002442002442002442,
            "pseudo_dstar_susp": 0.0002557544757033248,
            "pseudo_tarantula_susp": 0.0002203128442388191,
            "pseudo_op2_susp": 0.0002557544757033248,
            "pseudo_barinel_susp": 0.0002203128442388191
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.apply_aspect#1436",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.apply_aspect(self, position=None)",
        "snippet": "    def apply_aspect(self, position=None):\n        \"\"\"\n        Adjust the Axes for a specified data aspect ratio.\n\n        Depending on `.get_adjustable` this will modify either the Axes box\n        (position) or the view limits. In the former case, `.get_anchor`\n        will affect the position.\n\n        Notes\n        -----\n        This is called automatically when each Axes is drawn.  You may need\n        to call it yourself if you need to update the Axes position and/or\n        view limits before the Figure is drawn.\n\n        See Also\n        --------\n        matplotlib.axes.Axes.set_aspect\n            for a description of aspect ratio handling.\n        matplotlib.axes.Axes.set_adjustable\n            defining the parameter to adjust in order to meet the required\n            aspect.\n        matplotlib.axes.Axes.set_anchor\n            defining the position in case of extra space.\n        \"\"\"\n        if position is None:\n            position = self.get_position(original=True)\n\n        aspect = self.get_aspect()\n\n        if aspect == 'auto':\n            self._set_position(position, which='active')\n            return\n\n        if aspect == 'equal':\n            aspect = 1\n\n        fig_width, fig_height = self.get_figure().get_size_inches()\n        fig_aspect = fig_height / fig_width\n\n        if self._adjustable == 'box':\n            if self in self._twinned_axes:\n                raise RuntimeError(\"Adjustable 'box' is not allowed in a \"\n                                   \"twinned Axes; use 'datalim' instead\")\n            box_aspect = aspect * self.get_data_ratio()\n            pb = position.frozen()\n            pb1 = pb.shrunk_to_aspect(box_aspect, pb, fig_aspect)\n            self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')\n            return\n\n        # self._adjustable == 'datalim'\n\n        # reset active to original in case it had been changed by prior use\n        # of 'box'\n        self._set_position(position, which='active')\n\n        x_trf = self.xaxis.get_transform()\n        y_trf = self.yaxis.get_transform()\n        xmin, xmax = x_trf.transform(self.get_xbound())\n        ymin, ymax = y_trf.transform(self.get_ybound())\n        xsize = max(abs(xmax - xmin), 1e-30)\n        ysize = max(abs(ymax - ymin), 1e-30)\n\n        l, b, w, h = position.bounds\n        box_aspect = fig_aspect * (h / w)\n        data_ratio = box_aspect / aspect\n\n        y_expander = data_ratio * xsize / ysize - 1\n        # If y_expander > 0, the dy/dx viewLim ratio needs to increase\n        if abs(y_expander) < 0.005:\n            return\n\n        dL = self.dataLim\n        x0, x1 = x_trf.transform(dL.intervalx)\n        y0, y1 = y_trf.transform(dL.intervaly)\n        xr = 1.05 * (x1 - x0)\n        yr = 1.05 * (y1 - y0)\n\n        xmarg = xsize - xr\n        ymarg = ysize - yr\n        Ysize = data_ratio * xsize\n        Xsize = ysize / data_ratio\n        Xmarg = Xsize - xr\n        Ymarg = Ysize - yr\n        # Setting these targets to, e.g., 0.05*xr does not seem to help.\n        xm = 0\n        ym = 0\n\n        shared_x = self in self._shared_x_axes\n        shared_y = self in self._shared_y_axes\n        # Not sure whether we need this check:\n        if shared_x and shared_y:\n            raise RuntimeError(\"adjustable='datalim' is not allowed when both \"\n                               \"axes are shared\")\n\n        # If y is shared, then we are only allowed to change x, etc.\n        if shared_y:\n            adjust_y = False\n        else:\n            if xmarg > xm and ymarg > ym:\n                adjy = ((Ymarg > 0 and y_expander < 0) or\n                        (Xmarg < 0 and y_expander > 0))\n            else:\n                adjy = y_expander > 0\n            adjust_y = shared_x or adjy  # (Ymarg > xmarg)\n\n        if adjust_y:\n            yc = 0.5 * (ymin + ymax)\n            y0 = yc - Ysize / 2.0\n            y1 = yc + Ysize / 2.0\n            self.set_ybound(y_trf.inverted().transform([y0, y1]))\n        else:\n            xc = 0.5 * (xmin + xmax)\n            x0 = xc - Xsize / 2.0\n            x1 = xc + Xsize / 2.0\n            self.set_xbound(x_trf.inverted().transform([x0, x1]))",
        "begin_line": 1436,
        "end_line": 1550,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005473453749315818,
            "pseudo_dstar_susp": 0.0004127115146512588,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0004127115146512588,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.axis#1552",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.axis(self, *args, emit=True, **kwargs)",
        "snippet": "    def axis(self, *args, emit=True, **kwargs):\n        \"\"\"\n        Convenience method to get or set some axis properties.\n\n        Call signatures::\n\n          xmin, xmax, ymin, ymax = axis()\n          xmin, xmax, ymin, ymax = axis([xmin, xmax, ymin, ymax])\n          xmin, xmax, ymin, ymax = axis(option)\n          xmin, xmax, ymin, ymax = axis(**kwargs)\n\n        Parameters\n        ----------\n        xmin, xmax, ymin, ymax : float, optional\n            The axis limits to be set.  This can also be achieved using ::\n\n                ax.set(xlim=(xmin, xmax), ylim=(ymin, ymax))\n\n        option : bool or str\n            If a bool, turns axis lines and labels on or off. If a string,\n            possible values are:\n\n            ======== ==========================================================\n            Value    Description\n            ======== ==========================================================\n            'on'     Turn on axis lines and labels. Same as ``True``.\n            'off'    Turn off axis lines and labels. Same as ``False``.\n            'equal'  Set equal scaling (i.e., make circles circular) by\n                     changing axis limits. This is the same as\n                     ``ax.set_aspect('equal', adjustable='datalim')``.\n                     Explicit data limits may not be respected in this case.\n            'scaled' Set equal scaling (i.e., make circles circular) by\n                     changing dimensions of the plot box. This is the same as\n                     ``ax.set_aspect('equal', adjustable='box', anchor='C')``.\n                     Additionally, further autoscaling will be disabled.\n            'tight'  Set limits just large enough to show all data, then\n                     disable further autoscaling.\n            'auto'   Automatic scaling (fill plot box with data).\n            'normal' Same as 'auto'; deprecated.\n            'image'  'scaled' with axis limits equal to data limits.\n            'square' Square plot; similar to 'scaled', but initially forcing\n                     ``xmax-xmin == ymax-ymin``.\n            ======== ==========================================================\n\n        emit : bool, optional, default *True*\n            Whether observers are notified of the axis limit change.\n            This option is passed on to `~.Axes.set_xlim` and\n            `~.Axes.set_ylim`.\n\n        Returns\n        -------\n        xmin, xmax, ymin, ymax : float\n            The axis limits.\n\n        See also\n        --------\n        matplotlib.axes.Axes.set_xlim\n        matplotlib.axes.Axes.set_ylim\n        \"\"\"\n        if len(args) == 1 and isinstance(args[0], (str, bool)):\n            s = args[0]\n            if s is True:\n                s = 'on'\n            if s is False:\n                s = 'off'\n            s = s.lower()\n            if s == 'on':\n                self.set_axis_on()\n            elif s == 'off':\n                self.set_axis_off()\n            elif s in ('equal', 'tight', 'scaled', 'normal',\n                       'auto', 'image', 'square'):\n                if s == 'normal':\n                    cbook.warn_deprecated(\n                        \"3.1\", message=\"Passing 'normal' to axis() is \"\n                        \"deprecated since %(since)s; use 'auto' instead.\")\n                self.set_autoscale_on(True)\n                self.set_aspect('auto')\n                self.autoscale_view(tight=False)\n                # self.apply_aspect()\n                if s == 'equal':\n                    self.set_aspect('equal', adjustable='datalim')\n                elif s == 'scaled':\n                    self.set_aspect('equal', adjustable='box', anchor='C')\n                    self.set_autoscale_on(False)  # Req. by Mark Bakker\n                elif s == 'tight':\n                    self.autoscale_view(tight=True)\n                    self.set_autoscale_on(False)\n                elif s == 'image':\n                    self.autoscale_view(tight=True)\n                    self.set_autoscale_on(False)\n                    self.set_aspect('equal', adjustable='box', anchor='C')\n                elif s == 'square':\n                    self.set_aspect('equal', adjustable='box', anchor='C')\n                    self.set_autoscale_on(False)\n                    xlim = self.get_xlim()\n                    ylim = self.get_ylim()\n                    edge_size = max(np.diff(xlim), np.diff(ylim))[0]\n                    self.set_xlim([xlim[0], xlim[0] + edge_size],\n                                  emit=emit, auto=False)\n                    self.set_ylim([ylim[0], ylim[0] + edge_size],\n                                  emit=emit, auto=False)\n            else:\n                raise ValueError('Unrecognized string %s to axis; '\n                                 'try on or off' % s)\n        else:\n            if len(args) >= 1:\n                if len(args) != 1:\n                    cbook.warn_deprecated(\n                        \"3.2\", message=\"Passing more than one positional \"\n                        \"argument to axis() is deprecated and will raise a \"\n                        \"TypeError %(removal)s.\")\n                limits = args[0]\n                try:\n                    xmin, xmax, ymin, ymax = limits\n                except (TypeError, ValueError):\n                    raise TypeError('the first argument to axis() must be an '\n                                    'interable of the form '\n                                    '[xmin, xmax, ymin, ymax]')\n            else:\n                xmin = kwargs.pop('xmin', None)\n                xmax = kwargs.pop('xmax', None)\n                ymin = kwargs.pop('ymin', None)\n                ymax = kwargs.pop('ymax', None)\n            xauto = (None  # Keep autoscale state as is.\n                     if xmin is None and xmax is None\n                     else False)  # Turn off autoscale.\n            yauto = (None\n                     if ymin is None and ymax is None\n                     else False)\n            self.set_xlim(xmin, xmax, emit=emit, auto=xauto)\n            self.set_ylim(ymin, ymax, emit=emit, auto=yauto)\n        if kwargs:\n            cbook.warn_deprecated(\n                \"3.1\", message=\"Passing unsupported keyword arguments to \"\n                \"axis() will raise a TypeError %(removal)s.\")\n        return (*self.get_xlim(), *self.get_ylim())",
        "begin_line": 1552,
        "end_line": 1688,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018053800324968405,
            "pseudo_dstar_susp": 0.0001529987760097919,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0001529987760097919,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_legend#1690",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_legend(self)",
        "snippet": "    def get_legend(self):\n        \"\"\"Return the `Legend` instance, or None if no legend is defined.\"\"\"\n        return self.legend_",
        "begin_line": 1690,
        "end_line": 1692,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_xaxis#1702",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_xaxis(self)",
        "snippet": "    def get_xaxis(self):\n        \"\"\"Return the XAxis instance.\"\"\"\n        return self.xaxis",
        "begin_line": 1702,
        "end_line": 1704,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.756748371082842e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._sci#1728",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._sci(self, im)",
        "snippet": "    def _sci(self, im):\n        \"\"\"Set the current image.\n\n        This image will be the target of colormap functions like\n        `~.pyplot.viridis`, and other functions such as `~.pyplot.clim`.  The\n        current image is an attribute of the current axes.\n        \"\"\"\n        if isinstance(im, mpl.contour.ContourSet):\n            if im.collections[0] not in self.collections:\n                raise ValueError(\"ContourSet must be in current Axes\")\n        elif im not in self.images and im not in self.collections:\n            raise ValueError(\"Argument must be an image, collection, or \"\n                             \"ContourSet in this Axes\")\n        self._current_image = im",
        "begin_line": 1728,
        "end_line": 1741,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002145002145002145,
            "pseudo_dstar_susp": 0.00022002200220022002,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.00022002200220022002,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._gci#1743",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._gci(self)",
        "snippet": "    def _gci(self):\n        \"\"\"\n        Helper for :func:`~matplotlib.pyplot.gci`;\n        do not use elsewhere.\n        \"\"\"\n        return self._current_image",
        "begin_line": 1743,
        "end_line": 1748,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.has_data#1750",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.has_data(self)",
        "snippet": "    def has_data(self):\n        \"\"\"\n        Return *True* if any artists have been added to axes.\n\n        This should not be used to determine whether the *dataLim*\n        need to be updated, and may not actually be useful for\n        anything.\n        \"\"\"\n        return (\n            len(self.collections) +\n            len(self.images) +\n            len(self.lines) +\n            len(self.patches)) > 0",
        "begin_line": 1750,
        "end_line": 1762,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.add_artist#1764",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.add_artist(self, a)",
        "snippet": "    def add_artist(self, a):\n        \"\"\"\n        Add an `~.Artist` to the axes, and return the artist.\n\n        Use `add_artist` only for artists for which there is no dedicated\n        \"add\" method; and if necessary, use a method such as `update_datalim`\n        to manually update the dataLim if the artist is to be included in\n        autoscaling.\n\n        If no ``transform`` has been specified when creating the artist (e.g.\n        ``artist.get_transform() == None``) then the transform is set to\n        ``ax.transData``.\n        \"\"\"\n        a.axes = self\n        self.artists.append(a)\n        a._remove_method = self.artists.remove\n        self._set_artist_props(a)\n        a.set_clip_path(self.patch)\n        self.stale = True\n        return a",
        "begin_line": 1764,
        "end_line": 1783,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002294630564479119,
            "pseudo_dstar_susp": 0.0002523977788995457,
            "pseudo_tarantula_susp": 0.00018751171948246765,
            "pseudo_op2_susp": 0.0002523977788995457,
            "pseudo_barinel_susp": 0.00018754688672168043
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.add_child_axes#1785",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.add_child_axes(self, ax)",
        "snippet": "    def add_child_axes(self, ax):\n        \"\"\"\n        Add an `~.AxesBase` to the axes' children; return the child axes.\n\n        This is the lowlevel version.  See `.axes.Axes.inset_axes`.\n        \"\"\"\n\n        # normally axes have themselves as the axes, but these need to have\n        # their parent...\n        # Need to bypass the getter...\n        ax._axes = self\n        ax.stale_callback = martist._stale_axes_callback\n\n        self.child_axes.append(ax)\n        ax._remove_method = self.child_axes.remove\n        self.stale = True\n        return ax",
        "begin_line": 1785,
        "end_line": 1801,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.add_collection#1803",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.add_collection(self, collection, autolim=True)",
        "snippet": "    def add_collection(self, collection, autolim=True):\n        \"\"\"\n        Add a `~.Collection` to the axes' collections; return the collection.\n        \"\"\"\n        label = collection.get_label()\n        if not label:\n            collection.set_label('_collection%d' % len(self.collections))\n        self.collections.append(collection)\n        collection._remove_method = self.collections.remove\n        self._set_artist_props(collection)\n\n        if collection.get_clip_path() is None:\n            collection.set_clip_path(self.patch)\n\n        if autolim:\n            # Make sure viewLim is not stale (mostly to match\n            # pre-lazy-autoscale behavior, which is not really better).\n            self._unstale_viewLim()\n            self.update_datalim(collection.get_datalim(self.transData))\n\n        self.stale = True\n        return collection",
        "begin_line": 1803,
        "end_line": 1824,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00026001040041601667,
            "pseudo_dstar_susp": 0.00032030749519538755,
            "pseudo_tarantula_susp": 0.00023364485981308412,
            "pseudo_op2_susp": 0.00032030749519538755,
            "pseudo_barinel_susp": 0.00023364485981308412
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.add_image#1826",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.add_image(self, image)",
        "snippet": "    def add_image(self, image):\n        \"\"\"\n        Add an `~.AxesImage` to the axes' images; return the image.\n        \"\"\"\n        self._set_artist_props(image)\n        if not image.get_label():\n            image.set_label('_image%d' % len(self.images))\n        self.images.append(image)\n        image._remove_method = self.images.remove\n        self.stale = True\n        return image",
        "begin_line": 1826,
        "end_line": 1836,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019916351324437363,
            "pseudo_dstar_susp": 0.00021105951878429716,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.00021105951878429716,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._update_image_limits#1838",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._update_image_limits(self, image)",
        "snippet": "    def _update_image_limits(self, image):\n        xmin, xmax, ymin, ymax = image.get_extent()\n        self.axes.update_datalim(((xmin, ymin), (xmax, ymax)))",
        "begin_line": 1838,
        "end_line": 1840,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.add_line#1842",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.add_line(self, line)",
        "snippet": "    def add_line(self, line):\n        \"\"\"\n        Add a `.Line2D` to the axes' lines; return the line.\n        \"\"\"\n        self._set_artist_props(line)\n        if line.get_clip_path() is None:\n            line.set_clip_path(self.patch)\n\n        self._update_line_limits(line)\n        if not line.get_label():\n            line.set_label('_line%d' % len(self.lines))\n        self.lines.append(line)\n        line._remove_method = self.lines.remove\n        self.stale = True\n        return line",
        "begin_line": 1842,
        "end_line": 1856,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002824858757062147,
            "pseudo_dstar_susp": 0.00033898305084745765,
            "pseudo_tarantula_susp": 0.00017699115044247788,
            "pseudo_op2_susp": 0.00033898305084745765,
            "pseudo_barinel_susp": 0.00017699115044247788
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._add_text#1858",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._add_text(self, txt)",
        "snippet": "    def _add_text(self, txt):\n        \"\"\"\n        Add a `~.Text` to the axes' texts; return the text.\n        \"\"\"\n        self._set_artist_props(txt)\n        self.texts.append(txt)\n        txt._remove_method = self.texts.remove\n        self.stale = True\n        return txt",
        "begin_line": 1858,
        "end_line": 1866,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002442002442002442,
            "pseudo_dstar_susp": 0.00025290844714213456,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.00025290844714213456,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._update_line_limits#1868",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._update_line_limits(self, line)",
        "snippet": "    def _update_line_limits(self, line):\n        \"\"\"\n        Figures out the data limit of the given line, updating self.dataLim.\n        \"\"\"\n        path = line.get_path()\n        if path.vertices.size == 0:\n            return\n\n        line_trans = line.get_transform()\n\n        if line_trans == self.transData:\n            data_path = path\n\n        elif any(line_trans.contains_branch_seperately(self.transData)):\n            # identify the transform to go from line's coordinates\n            # to data coordinates\n            trans_to_data = line_trans - self.transData\n\n            # if transData is affine we can use the cached non-affine component\n            # of line's path. (since the non-affine part of line_trans is\n            # entirely encapsulated in trans_to_data).\n            if self.transData.is_affine:\n                line_trans_path = line._get_transformed_path()\n                na_path, _ = line_trans_path.get_transformed_path_and_affine()\n                data_path = trans_to_data.transform_path_affine(na_path)\n            else:\n                data_path = trans_to_data.transform_path(path)\n        else:\n            # for backwards compatibility we update the dataLim with the\n            # coordinate range of the given path, even though the coordinate\n            # systems are completely different. This may occur in situations\n            # such as when ax.transAxes is passed through for absolute\n            # positioning.\n            data_path = path\n\n        if data_path.vertices.size > 0:\n            updatex, updatey = line_trans.contains_branch_seperately(\n                self.transData)\n            self.dataLim.update_from_path(data_path,\n                                          self.ignore_existing_data_limits,\n                                          updatex=updatex,\n                                          updatey=updatey)\n            self.ignore_existing_data_limits = False",
        "begin_line": 1868,
        "end_line": 1910,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00029717682020802375,
            "pseudo_dstar_susp": 0.0003427004797806717,
            "pseudo_tarantula_susp": 0.0002314814814814815,
            "pseudo_op2_susp": 0.0003427004797806717,
            "pseudo_barinel_susp": 0.0002314814814814815
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.add_patch#1912",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.add_patch(self, p)",
        "snippet": "    def add_patch(self, p):\n        \"\"\"\n        Add a `~.Patch` to the axes' patches; return the patch.\n        \"\"\"\n        self._set_artist_props(p)\n        if p.get_clip_path() is None:\n            p.set_clip_path(self.patch)\n        self._update_patch_limits(p)\n        self.patches.append(p)\n        p._remove_method = self.patches.remove\n        return p",
        "begin_line": 1912,
        "end_line": 1922,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023474178403755868,
            "pseudo_dstar_susp": 0.00028620492272467084,
            "pseudo_tarantula_susp": 0.0002681684097613301,
            "pseudo_op2_susp": 0.00028620492272467084,
            "pseudo_barinel_susp": 0.0002681684097613301
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._update_patch_limits#1924",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._update_patch_limits(self, patch)",
        "snippet": "    def _update_patch_limits(self, patch):\n        \"\"\"update the data limits for patch *p*\"\"\"\n        # hist can add zero height Rectangles, which is useful to keep\n        # the bins, counts and patches lined up, but it throws off log\n        # scaling.  We'll ignore rects with zero height or width in\n        # the auto-scaling\n\n        # cannot check for '==0' since unitized data may not compare to zero\n        # issue #2150 - we update the limits if patch has non zero width\n        # or height.\n        if (isinstance(patch, mpatches.Rectangle) and\n                ((not patch.get_width()) and (not patch.get_height()))):\n            return\n        vertices = patch.get_path().vertices\n        if vertices.size > 0:\n            xys = patch.get_patch_transform().transform(vertices)\n            if patch.get_data_transform() != self.transData:\n                patch_to_data = (patch.get_data_transform() -\n                                 self.transData)\n                xys = patch_to_data.transform(xys)\n\n            updatex, updatey = patch.get_transform().\\\n                contains_branch_seperately(self.transData)\n            self.update_datalim(xys, updatex=updatex,\n                                updatey=updatey)",
        "begin_line": 1924,
        "end_line": 1948,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002306805074971165,
            "pseudo_dstar_susp": 0.0002777777777777778,
            "pseudo_tarantula_susp": 0.00016792611251049538,
            "pseudo_op2_susp": 0.0002777777777777778,
            "pseudo_barinel_susp": 0.00016792611251049538
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.add_table#1950",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.add_table(self, tab)",
        "snippet": "    def add_table(self, tab):\n        \"\"\"\n        Add a `~.Table` to the axes' tables; return the table.\n        \"\"\"\n        self._set_artist_props(tab)\n        self.tables.append(tab)\n        tab.set_clip_path(self.patch)\n        tab._remove_method = self.tables.remove\n        return tab",
        "begin_line": 1950,
        "end_line": 1958,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020222446916076846,
            "pseudo_dstar_susp": 0.00017319016279875303,
            "pseudo_tarantula_susp": 0.0003850596842510589,
            "pseudo_op2_susp": 0.00017319016279875303,
            "pseudo_barinel_susp": 0.00038491147036181676
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.add_container#1960",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.add_container(self, container)",
        "snippet": "    def add_container(self, container):\n        \"\"\"\n        Add a `~.Container` to the axes' containers; return the container.\n        \"\"\"\n        label = container.get_label()\n        if not label:\n            container.set_label('_container%d' % len(self.containers))\n        self.containers.append(container)\n        container._remove_method = self.containers.remove\n        return container",
        "begin_line": 1960,
        "end_line": 1969,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018053800324968405,
            "pseudo_dstar_susp": 0.0001529987760097919,
            "pseudo_tarantula_susp": 0.0003450655624568668,
            "pseudo_op2_susp": 0.0001529987760097919,
            "pseudo_barinel_susp": 0.00034494653328734045
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._on_units_changed#1971",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._on_units_changed(self, scalex=False, scaley=False)",
        "snippet": "    def _on_units_changed(self, scalex=False, scaley=False):\n        \"\"\"\n        Callback for processing changes to axis units.\n\n        Currently requests updates of data limits and view limits.\n        \"\"\"\n        self.relim()\n        self._request_autoscale_view(scalex=scalex, scaley=scaley)",
        "begin_line": 1971,
        "end_line": 1978,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016471750947125678,
            "pseudo_dstar_susp": 0.00019782393669634025,
            "pseudo_tarantula_susp": 0.00013243279035889287,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00013243279035889287
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.relim#1980",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.relim(self, visible_only=False)",
        "snippet": "    def relim(self, visible_only=False):\n        \"\"\"\n        Recompute the data limits based on current artists.\n\n        At present, `~.Collection` instances are not supported.\n\n        Parameters\n        ----------\n        visible_only : bool\n            Whether to exclude invisible artists.  Defaults to False.\n        \"\"\"\n        # Collections are deliberately not supported (yet); see\n        # the TODO note in artists.py.\n        self.dataLim.ignore(True)\n        self.dataLim.set_points(mtransforms.Bbox.null().get_points())\n        self.ignore_existing_data_limits = True\n\n        for line in self.lines:\n            if not visible_only or line.get_visible():\n                self._update_line_limits(line)\n\n        for p in self.patches:\n            if not visible_only or p.get_visible():\n                self._update_patch_limits(p)\n\n        for image in self.images:\n            if not visible_only or image.get_visible():\n                self._update_image_limits(image)",
        "begin_line": 1980,
        "end_line": 2007,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016363933889707084,
            "pseudo_dstar_susp": 0.00019758940920766647,
            "pseudo_tarantula_susp": 0.00013163090693694878,
            "pseudo_op2_susp": 0.00019758940920766647,
            "pseudo_barinel_susp": 0.00013163090693694878
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.update_datalim#2009",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.update_datalim(self, xys, updatex=True, updatey=True)",
        "snippet": "    def update_datalim(self, xys, updatex=True, updatey=True):\n        \"\"\"\n        Extend the `~.Axes.dataLim` Bbox to include the given points.\n\n        If no data is set currently, the Bbox will ignore its limits and set\n        the bound to be the bounds of the xydata (*xys*). Otherwise, it will\n        compute the bounds of the union of its current data and the data in\n        *xys*.\n\n        Parameters\n        ----------\n        xys : 2D array-like\n            The points to include in the data limits Bbox. This can be either\n            a list of (x, y) tuples or a Nx2 array.\n\n        updatex, updatey : bool, optional, default *True*\n            Whether to update the x/y limits.\n        \"\"\"\n        xys = np.asarray(xys)\n        if not len(xys):\n            return\n        self.dataLim.update_from_data_xy(xys, self.ignore_existing_data_limits,\n                                         updatex=updatex, updatey=updatey)\n        self.ignore_existing_data_limits = False",
        "begin_line": 2009,
        "end_line": 2032,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00025113008538422905,
            "pseudo_dstar_susp": 0.00032351989647363315,
            "pseudo_tarantula_susp": 0.00013178703215603585,
            "pseudo_op2_susp": 0.00032351989647363315,
            "pseudo_barinel_susp": 0.00013178703215603585
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._process_unit_info#2045",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._process_unit_info(self, xdata=None, ydata=None, kwargs=None)",
        "snippet": "    def _process_unit_info(self, xdata=None, ydata=None, kwargs=None):\n        \"\"\"Look for unit *kwargs* and update the axis instances as necessary\"\"\"\n\n        def _process_single_axis(data, axis, unit_name, kwargs):\n            # Return if there's no axis set\n            if axis is None:\n                return kwargs\n\n            if data is not None:\n                # We only need to update if there is nothing set yet.\n                if not axis.have_units():\n                    axis.update_units(data)\n\n            # Check for units in the kwargs, and if present update axis\n            if kwargs is not None:\n                units = kwargs.pop(unit_name, axis.units)\n                if self.name == 'polar':\n                    polar_units = {'xunits': 'thetaunits', 'yunits': 'runits'}\n                    units = kwargs.pop(polar_units[unit_name], units)\n\n                if units != axis.units:\n                    axis.set_units(units)\n                    # If the units being set imply a different converter,\n                    # we need to update.\n                    if data is not None:\n                        axis.update_units(data)\n            return kwargs\n\n        kwargs = _process_single_axis(xdata, self.xaxis, 'xunits', kwargs)\n        kwargs = _process_single_axis(ydata, self.yaxis, 'yunits', kwargs)\n        return kwargs",
        "begin_line": 2045,
        "end_line": 2075,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00044365572315882877,
            "pseudo_dstar_susp": 0.0005564830272676684,
            "pseudo_tarantula_susp": 0.0002844141069397042,
            "pseudo_op2_susp": 0.0005564830272676684,
            "pseudo_barinel_susp": 0.0002844141069397042
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._process_single_axis#2048",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._process_single_axis(data, axis, unit_name, kwargs)",
        "snippet": "        def _process_single_axis(data, axis, unit_name, kwargs):\n            # Return if there's no axis set\n            if axis is None:\n                return kwargs\n\n            if data is not None:\n                # We only need to update if there is nothing set yet.\n                if not axis.have_units():\n                    axis.update_units(data)\n\n            # Check for units in the kwargs, and if present update axis\n            if kwargs is not None:\n                units = kwargs.pop(unit_name, axis.units)\n                if self.name == 'polar':\n                    polar_units = {'xunits': 'thetaunits', 'yunits': 'runits'}\n                    units = kwargs.pop(polar_units[unit_name], units)\n\n                if units != axis.units:\n                    axis.set_units(units)\n                    # If the units being set imply a different converter,\n                    # we need to update.\n                    if data is not None:\n                        axis.update_units(data)\n            return kwargs",
        "begin_line": 2048,
        "end_line": 2071,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004017677782241864,
            "pseudo_dstar_susp": 0.0005561735261401557,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.0005561735261401557,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_autoscaley_on#2096",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_autoscaley_on(self)",
        "snippet": "    def get_autoscaley_on(self):\n        \"\"\"\n        Get whether autoscaling for the y-axis is applied on plot commands\n        \"\"\"\n        return self._autoscaleYon",
        "begin_line": 2096,
        "end_line": 2100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012454851164528583,
            "pseudo_dstar_susp": 0.00011988970147464332,
            "pseudo_tarantula_susp": 0.00017415534656913968,
            "pseudo_op2_susp": 0.00011988970147464332,
            "pseudo_barinel_susp": 0.0001742767514813524
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_autoscale_on#2102",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_autoscale_on(self, b)",
        "snippet": "    def set_autoscale_on(self, b):\n        \"\"\"\n        Set whether autoscaling is applied on plot commands\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        self._autoscaleXon = b\n        self._autoscaleYon = b",
        "begin_line": 2102,
        "end_line": 2111,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015992323684631377,
            "pseudo_dstar_susp": 0.0001405086412814388,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.0001405086412814388,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_autoscalex_on#2113",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_autoscalex_on(self, b)",
        "snippet": "    def set_autoscalex_on(self, b):\n        \"\"\"\n        Set whether autoscaling for the x-axis is applied on plot commands\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        self._autoscaleXon = b",
        "begin_line": 2113,
        "end_line": 2121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012454851164528583,
            "pseudo_dstar_susp": 0.00011988970147464332,
            "pseudo_tarantula_susp": 0.00017415534656913968,
            "pseudo_op2_susp": 0.00011988970147464332,
            "pseudo_barinel_susp": 0.0001742767514813524
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_autoscaley_on#2123",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_autoscaley_on(self, b)",
        "snippet": "    def set_autoscaley_on(self, b):\n        \"\"\"\n        Set whether autoscaling for the y-axis is applied on plot commands\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        self._autoscaleYon = b",
        "begin_line": 2123,
        "end_line": 2131,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.use_sticky_edges#2134",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.use_sticky_edges(self)",
        "snippet": "    def use_sticky_edges(self):\n        \"\"\"\n        When autoscaling, whether to obey all `Artist.sticky_edges`.\n\n        Default is ``True``.\n\n        Setting this to ``False`` ensures that the specified margins\n        will be applied, even if the plot includes an image, for\n        example, which would otherwise force a view limit to coincide\n        with its data limit.\n\n        The changing this property does not change the plot until\n        `autoscale` or `autoscale_view` is called.\n        \"\"\"\n        return self._use_sticky_edges",
        "begin_line": 2134,
        "end_line": 2148,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00031308703819661864,
            "pseudo_dstar_susp": 0.0003245699448231094,
            "pseudo_tarantula_susp": 0.0001836884643644379,
            "pseudo_op2_susp": 0.0003245699448231094,
            "pseudo_barinel_susp": 0.0001836884643644379
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_xmargin#2155",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_xmargin(self, m)",
        "snippet": "    def set_xmargin(self, m):\n        \"\"\"\n        Set padding of X data limits prior to autoscaling.\n\n        *m* times the data interval will be added to each\n        end of that interval before it is used in autoscaling.\n        For example, if your data is in the range [0, 2], a factor of\n        ``m = 0.1`` will result in a range [-0.2, 2.2].\n\n        Negative values -0.5 < m < 0 will result in clipping of the data range.\n        I.e. for a data range [0, 2], a factor of ``m = -0.1`` will result in\n        a range [0.2, 1.8].\n\n        Parameters\n        ----------\n        m : float greater than -0.5\n        \"\"\"\n        if m <= -0.5:\n            raise ValueError(\"margin must be greater than -0.5\")\n        self._xmargin = m\n        self.stale = True",
        "begin_line": 2155,
        "end_line": 2175,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00014255167498218105,
            "pseudo_dstar_susp": 0.0001781895937277263,
            "pseudo_tarantula_susp": 0.00013231013495633765,
            "pseudo_op2_susp": 0.0001781895937277263,
            "pseudo_barinel_susp": 0.00013231013495633765
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_ymargin#2177",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_ymargin(self, m)",
        "snippet": "    def set_ymargin(self, m):\n        \"\"\"\n        Set padding of Y data limits prior to autoscaling.\n\n        *m* times the data interval will be added to each\n        end of that interval before it is used in autoscaling.\n        For example, if your data is in the range [0, 2], a factor of\n        ``m = 0.1`` will result in a range [-0.2, 2.2].\n\n        Negative values -0.5 < m < 0 will result in clipping of the data range.\n        I.e. for a data range [0, 2], a factor of ``m = -0.1`` will result in\n        a range [0.2, 1.8].\n\n        Parameters\n        ----------\n        m : float greater than -0.5\n        \"\"\"\n        if m <= -0.5:\n            raise ValueError(\"margin must be greater than -0.5\")\n        self._ymargin = m\n        self.stale = True",
        "begin_line": 2177,
        "end_line": 2197,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001380071763731714,
            "pseudo_dstar_susp": 0.00013869625520110957,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00013869625520110957,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.margins#2199",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.margins(self, *margins, x=None, y=None, tight=True)",
        "snippet": "    def margins(self, *margins, x=None, y=None, tight=True):\n        \"\"\"\n        Set or retrieve autoscaling margins.\n\n        The padding added to each limit of the axes is the *margin*\n        times the data interval. All input parameters must be floats\n        within the range [0, 1]. Passing both positional and keyword\n        arguments is invalid and will raise a TypeError. If no\n        arguments (positional or otherwise) are provided, the current\n        margins will remain in place and simply be returned.\n\n        Specifying any margin changes only the autoscaling; for example,\n        if *xmargin* is not None, then *xmargin* times the X data\n        interval will be added to each end of that interval before\n        it is used in autoscaling.\n\n        Parameters\n        ----------\n        *margins : float, optional\n            If a single positional argument is provided, it specifies\n            both margins of the x-axis and y-axis limits. If two\n            positional arguments are provided, they will be interpreted\n            as *xmargin*, *ymargin*. If setting the margin on a single\n            axis is desired, use the keyword arguments described below.\n\n        x, y : float, optional\n            Specific margin values for the x-axis and y-axis,\n            respectively. These cannot be used with positional\n            arguments, but can be used individually to alter on e.g.,\n            only the y-axis.\n\n        tight : bool or None, default is True\n            The *tight* parameter is passed to :meth:`autoscale_view`,\n            which is executed after a margin is changed; the default\n            here is *True*, on the assumption that when margins are\n            specified, no additional padding to match tick marks is\n            usually desired.  Set *tight* to *None* will preserve\n            the previous setting.\n\n        Returns\n        -------\n        xmargin, ymargin : float\n\n        Notes\n        -----\n        If a previously used Axes method such as :meth:`pcolor` has set\n        :attr:`use_sticky_edges` to `True`, only the limits not set by\n        the \"sticky artists\" will be modified. To force all of the\n        margins to be set, set :attr:`use_sticky_edges` to `False`\n        before calling :meth:`margins`.\n        \"\"\"\n\n        if margins and x is not None and y is not None:\n            raise TypeError('Cannot pass both positional and keyword '\n                            'arguments for x and/or y.')\n        elif len(margins) == 1:\n            x = y = margins[0]\n        elif len(margins) == 2:\n            x, y = margins\n        elif margins:\n            raise TypeError('Must pass a single positional argument for all '\n                            'margins, or one for each margin (x, y).')\n\n        if x is None and y is None:\n            if tight is not True:\n                cbook._warn_external(f'ignoring tight={tight!r} in get mode')\n            return self._xmargin, self._ymargin\n\n        if x is not None:\n            self.set_xmargin(x)\n        if y is not None:\n            self.set_ymargin(y)\n\n        self._request_autoscale_view(\n            tight=tight, scalex=(x is not None), scaley=(y is not None)\n        )",
        "begin_line": 2199,
        "end_line": 2274,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.autoscale#2291",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.autoscale(self, enable=True, axis='both', tight=None)",
        "snippet": "    def autoscale(self, enable=True, axis='both', tight=None):\n        \"\"\"\n        Autoscale the axis view to the data (toggle).\n\n        Convenience method for simple axis view autoscaling.\n        It turns autoscaling on or off, and then,\n        if autoscaling for either axis is on, it performs\n        the autoscaling on the specified axis or axes.\n\n        Parameters\n        ----------\n        enable : bool or None, optional\n            True (default) turns autoscaling on, False turns it off.\n            None leaves the autoscaling state unchanged.\n\n        axis : {'both', 'x', 'y'}, optional\n            Which axis to operate on; default is 'both'.\n\n        tight : bool or None, optional\n            If True, first set the margins to zero.  Then, this argument is\n            forwarded to `autoscale_view` (regardless of its value); see the\n            description of its behavior there.\n        \"\"\"\n        if enable is None:\n            scalex = True\n            scaley = True\n        else:\n            scalex = False\n            scaley = False\n            if axis in ['x', 'both']:\n                self._autoscaleXon = bool(enable)\n                scalex = self._autoscaleXon\n            if axis in ['y', 'both']:\n                self._autoscaleYon = bool(enable)\n                scaley = self._autoscaleYon\n        if tight and scalex:\n            self._xmargin = 0\n        if tight and scaley:\n            self._ymargin = 0\n        self._request_autoscale_view(tight=tight, scalex=scalex, scaley=scaley)",
        "begin_line": 2291,
        "end_line": 2330,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.autoscale_view#2332",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.autoscale_view(self, tight=None, scalex=True, scaley=True)",
        "snippet": "    def autoscale_view(self, tight=None, scalex=True, scaley=True):\n        \"\"\"\n        Autoscale the view limits using the data limits.\n\n        Parameters\n        ----------\n        tight : bool or None\n            If *True*, only expand the axis limits using the margins.  Note\n            that unlike for `autoscale`, ``tight=True`` does *not* set the\n            margins to zero.\n\n            If *False* and :rc:`axes.autolimit_mode` is 'round_numbers', then\n            after expansion by the margins, further expand the axis limits\n            using the axis major locator.\n\n            If None (the default), reuse the value set in the previous call to\n            `autoscale_view` (the initial value is False, but the default style\n            sets :rc:`axes.autolimit_mode` to 'data', in which case this\n            behaves like True).\n\n        scalex : bool\n            Whether to autoscale the x axis (default is True).\n\n        scaley : bool\n            Whether to autoscale the x axis (default is True).\n\n        Notes\n        -----\n        The autoscaling preserves any preexisting axis direction reversal.\n\n        The data limits are not updated automatically when artist data are\n        changed after the artist has been added to an Axes instance.  In that\n        case, use :meth:`matplotlib.axes.Axes.relim` prior to calling\n        autoscale_view.\n\n        If the views of the axes are fixed, e.g. via `set_xlim`, they will\n        not be changed by autoscale_view().\n        See :meth:`matplotlib.axes.Axes.autoscale` for an alternative.\n        \"\"\"\n        if tight is not None:\n            self._tight = bool(tight)\n\n        if self.use_sticky_edges and (\n                (self._xmargin and scalex and self._autoscaleXon) or\n                (self._ymargin and scaley and self._autoscaleYon)):\n            stickies = [artist.sticky_edges for artist in self.get_children()]\n        else:  # Small optimization.\n            stickies = []\n        x_stickies = np.sort([x for sticky in stickies for x in sticky.x])\n        y_stickies = np.sort([y for sticky in stickies for y in sticky.y])\n        if self.get_xscale().lower() == 'log':\n            x_stickies = x_stickies[x_stickies > 0]\n        if self.get_yscale().lower() == 'log':\n            y_stickies = y_stickies[y_stickies > 0]\n\n        def handle_single_axis(scale, autoscaleon, shared_axes, interval,\n                               minpos, axis, margin, stickies, set_bound):\n\n            if not (scale and autoscaleon):\n                return  # nothing to do...\n\n            shared = shared_axes.get_siblings(self)\n            dl = [ax.dataLim for ax in shared]\n            # ignore non-finite data limits if good limits exist\n            finite_dl = [d for d in dl if np.isfinite(d).all()]\n            if len(finite_dl):\n                # if finite limits exist for atleast one axis (and the\n                # other is infinite), restore the finite limits\n                x_finite = [d for d in dl\n                            if (np.isfinite(d.intervalx).all() and\n                                (d not in finite_dl))]\n                y_finite = [d for d in dl\n                            if (np.isfinite(d.intervaly).all() and\n                                (d not in finite_dl))]\n\n                dl = finite_dl\n                dl.extend(x_finite)\n                dl.extend(y_finite)\n\n            bb = mtransforms.BboxBase.union(dl)\n            x0, x1 = getattr(bb, interval)\n            # If x0 and x1 are non finite, use the locator to figure out\n            # default limits.\n            locator = axis.get_major_locator()\n            x0, x1 = locator.nonsingular(x0, x1)\n\n            # Prevent margin addition from crossing a sticky value.  Small\n            # tolerances (whose values come from isclose()) must be used due to\n            # floating point issues with streamplot.\n            def tol(x): return 1e-5 * abs(x) + 1e-8\n            # Index of largest element < x0 + tol, if any.\n            i0 = stickies.searchsorted(x0 + tol(x0)) - 1\n            x0bound = stickies[i0] if i0 != -1 else None\n            # Index of smallest element > x1 - tol, if any.\n            i1 = stickies.searchsorted(x1 - tol(x1))\n            x1bound = stickies[i1] if i1 != len(stickies) else None\n\n            # Add the margin in figure space and then transform back, to handle\n            # non-linear scales.\n            minpos = getattr(bb, minpos)\n            transform = axis.get_transform()\n            inverse_trans = transform.inverted()\n            x0, x1 = axis._scale.limit_range_for_scale(x0, x1, minpos)\n            x0t, x1t = transform.transform([x0, x1])\n            delta = (x1t - x0t) * margin\n            if not np.isfinite(delta):\n                delta = 0  # If a bound isn't finite, set margin to zero.\n            x0, x1 = inverse_trans.transform([x0t - delta, x1t + delta])\n\n            # Apply sticky bounds.\n            if x0bound is not None:\n                x0 = max(x0, x0bound)\n            if x1bound is not None:\n                x1 = min(x1, x1bound)\n\n            if not self._tight:\n                x0, x1 = locator.view_limits(x0, x1)\n            set_bound(x0, x1)\n            # End of definition of internal function 'handle_single_axis'.\n\n        handle_single_axis(\n            scalex, self._autoscaleXon, self._shared_x_axes, 'intervalx',\n            'minposx', self.xaxis, self._xmargin, x_stickies, self.set_xbound)\n        handle_single_axis(\n            scaley, self._autoscaleYon, self._shared_y_axes, 'intervaly',\n            'minposy', self.yaxis, self._ymargin, y_stickies, self.set_ybound)",
        "begin_line": 2332,
        "end_line": 2457,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00045558086560364467,
            "pseudo_dstar_susp": 0.0003698224852071006,
            "pseudo_tarantula_susp": 0.00032393909944930353,
            "pseudo_op2_susp": 0.0003698224852071006,
            "pseudo_barinel_susp": 0.00032393909944930353
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.handle_single_axis#2387",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.handle_single_axis(scale, autoscaleon, shared_axes, interval, minpos, axis, margin, stickies, set_bound)",
        "snippet": "        def handle_single_axis(scale, autoscaleon, shared_axes, interval,\n                               minpos, axis, margin, stickies, set_bound):\n\n            if not (scale and autoscaleon):\n                return  # nothing to do...\n\n            shared = shared_axes.get_siblings(self)\n            dl = [ax.dataLim for ax in shared]\n            # ignore non-finite data limits if good limits exist\n            finite_dl = [d for d in dl if np.isfinite(d).all()]\n            if len(finite_dl):\n                # if finite limits exist for atleast one axis (and the\n                # other is infinite), restore the finite limits\n                x_finite = [d for d in dl\n                            if (np.isfinite(d.intervalx).all() and\n                                (d not in finite_dl))]\n                y_finite = [d for d in dl\n                            if (np.isfinite(d.intervaly).all() and\n                                (d not in finite_dl))]\n\n                dl = finite_dl\n                dl.extend(x_finite)\n                dl.extend(y_finite)\n\n            bb = mtransforms.BboxBase.union(dl)\n            x0, x1 = getattr(bb, interval)\n            # If x0 and x1 are non finite, use the locator to figure out\n            # default limits.\n            locator = axis.get_major_locator()\n            x0, x1 = locator.nonsingular(x0, x1)\n\n            # Prevent margin addition from crossing a sticky value.  Small\n            # tolerances (whose values come from isclose()) must be used due to\n            # floating point issues with streamplot.\n            def tol(x): return 1e-5 * abs(x) + 1e-8\n            # Index of largest element < x0 + tol, if any.\n            i0 = stickies.searchsorted(x0 + tol(x0)) - 1\n            x0bound = stickies[i0] if i0 != -1 else None\n            # Index of smallest element > x1 - tol, if any.\n            i1 = stickies.searchsorted(x1 - tol(x1))\n            x1bound = stickies[i1] if i1 != len(stickies) else None\n\n            # Add the margin in figure space and then transform back, to handle\n            # non-linear scales.\n            minpos = getattr(bb, minpos)\n            transform = axis.get_transform()\n            inverse_trans = transform.inverted()\n            x0, x1 = axis._scale.limit_range_for_scale(x0, x1, minpos)\n            x0t, x1t = transform.transform([x0, x1])\n            delta = (x1t - x0t) * margin\n            if not np.isfinite(delta):\n                delta = 0  # If a bound isn't finite, set margin to zero.\n            x0, x1 = inverse_trans.transform([x0t - delta, x1t + delta])\n\n            # Apply sticky bounds.\n            if x0bound is not None:\n                x0 = max(x0, x0bound)\n            if x1bound is not None:\n                x1 = min(x1, x1bound)\n\n            if not self._tight:\n                x0, x1 = locator.view_limits(x0, x1)\n            set_bound(x0, x1)",
        "begin_line": 2387,
        "end_line": 2449,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004710315591144607,
            "pseudo_dstar_susp": 0.00036913990402362494,
            "pseudo_tarantula_susp": 0.00035248501938667606,
            "pseudo_op2_susp": 0.00036913990402362494,
            "pseudo_barinel_susp": 0.00035248501938667606
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.tol#2421",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.tol(x)",
        "snippet": "            def tol(x): return 1e-5 * abs(x) + 1e-8",
        "begin_line": 2421,
        "end_line": 2421,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002151462994836489,
            "pseudo_dstar_susp": 0.00019630938358853554,
            "pseudo_tarantula_susp": 0.0002973535533749628,
            "pseudo_op2_susp": 0.00019630938358853554,
            "pseudo_barinel_susp": 0.0002973535533749628
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._get_axis_list#2459",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._get_axis_list(self)",
        "snippet": "    def _get_axis_list(self):\n        return (self.xaxis, self.yaxis)",
        "begin_line": 2459,
        "end_line": 2460,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022007042253521127,
            "pseudo_dstar_susp": 0.00021640337589266391,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00021640337589266391,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._update_title_position#2480",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._update_title_position(self, renderer)",
        "snippet": "    def _update_title_position(self, renderer):\n        \"\"\"\n        Update the title position based on the bounding box enclosing\n        all the ticklabels and x-axis spine and xlabel...\n        \"\"\"\n\n        if self._autotitlepos is not None and not self._autotitlepos:\n            _log.debug('title position was updated manually, not adjusting')\n            return\n\n        titles = (self.title, self._left_title, self._right_title)\n\n        if self._autotitlepos is None:\n            for title in titles:\n                x, y = title.get_position()\n                if not np.isclose(y, 1.0):\n                    self._autotitlepos = False\n                    _log.debug('not adjusting title pos because a title was'\n                             ' already placed manually: %f', y)\n                    return\n            self._autotitlepos = True\n\n        for title in titles:\n            x, _ = title.get_position()\n            # need to start again in case of window resizing\n            title.set_position((x, 1.0))\n            # need to check all our twins too...\n            axs = self._twinned_axes.get_siblings(self)\n            # and all the children\n            for ax in self.child_axes:\n                if ax is not None:\n                    locator = ax.get_axes_locator()\n                    if locator:\n                        pos = locator(self, renderer)\n                        ax.apply_aspect(pos)\n                    else:\n                        ax.apply_aspect()\n                    axs = axs + [ax]\n            top = 0\n            for ax in axs:\n                if (ax.xaxis.get_ticks_position() in ['top', 'unknown']\n                        or ax.xaxis.get_label_position() == 'top'):\n                    bb = ax.xaxis.get_tightbbox(renderer)\n                else:\n                    bb = ax.get_window_extent(renderer)\n                if bb is not None:\n                    top = max(top, bb.ymax)\n            if title.get_window_extent(renderer).ymin < top:\n                _, y = self.transAxes.inverted().transform((0, top))\n                title.set_position((x, y))\n                # empirically, this doesn't always get the min to top,\n                # so we need to adjust again.\n                if title.get_window_extent(renderer).ymin < top:\n                    _, y = self.transAxes.inverted().transform(\n                        (0., 2 * top - title.get_window_extent(renderer).ymin))\n                    title.set_position((x, y))\n\n        ymax = max(title.get_position()[1] for title in titles)\n        for title in titles:\n            # now line up all the titles at the highest baseline.\n            x, _ = title.get_position()\n            title.set_position((x, ymax))",
        "begin_line": 2480,
        "end_line": 2541,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005763688760806917,
            "pseudo_dstar_susp": 0.0004662004662004662,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0004662004662004662,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.draw#2545",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.draw(self, renderer=None, inframe=False)",
        "snippet": "    def draw(self, renderer=None, inframe=False):\n        \"\"\"Draw everything (plot lines, axes, labels)\"\"\"\n        if renderer is None:\n            renderer = self.figure._cachedRenderer\n        if renderer is None:\n            raise RuntimeError('No renderer defined')\n        if not self.get_visible():\n            return\n        self._unstale_viewLim()\n\n        renderer.open_group('axes', gid=self.get_gid())\n\n        # prevent triggering call backs during the draw process\n        self._stale = True\n\n        # loop over self and child axes...\n        locator = self.get_axes_locator()\n        if locator:\n            pos = locator(self, renderer)\n            self.apply_aspect(pos)\n        else:\n            self.apply_aspect()\n\n        artists = self.get_children()\n        artists.remove(self.patch)\n\n        # the frame draws the edges around the axes patch -- we\n        # decouple these so the patch can be in the background and the\n        # frame in the foreground. Do this before drawing the axis\n        # objects so that the spine has the opportunity to update them.\n        if not (self.axison and self._frameon):\n            for spine in self.spines.values():\n                artists.remove(spine)\n\n        self._update_title_position(renderer)\n\n        if not self.axison or inframe:\n            for _axis in self._get_axis_list():\n                artists.remove(_axis)\n\n        if inframe:\n            artists.remove(self.title)\n            artists.remove(self._left_title)\n            artists.remove(self._right_title)\n\n        if not self.figure.canvas.is_saving():\n            artists = [a for a in artists\n                       if not a.get_animated() or a in self.images]\n        artists = sorted(artists, key=attrgetter('zorder'))\n\n        # rasterize artists with negative zorder\n        # if the minimum zorder is negative, start rasterization\n        rasterization_zorder = self._rasterization_zorder\n\n        if (rasterization_zorder is not None and\n                artists and artists[0].zorder < rasterization_zorder):\n            renderer.start_rasterizing()\n            artists_rasterized = [a for a in artists\n                                  if a.zorder < rasterization_zorder]\n            artists = [a for a in artists\n                       if a.zorder >= rasterization_zorder]\n        else:\n            artists_rasterized = []\n\n        # the patch draws the background rectangle -- the frame below\n        # will draw the edges\n        if self.axison and self._frameon:\n            self.patch.draw(renderer)\n\n        if artists_rasterized:\n            for a in artists_rasterized:\n                a.draw(renderer)\n            renderer.stop_rasterizing()\n\n        mimage._draw_list_compositing_images(renderer, self, artists)\n\n        renderer.close_group('axes')\n        self.stale = False",
        "begin_line": 2545,
        "end_line": 2622,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005813953488372093,
            "pseudo_dstar_susp": 0.0004716981132075472,
            "pseudo_tarantula_susp": 0.00022507314877335134,
            "pseudo_op2_susp": 0.0004716981132075472,
            "pseudo_barinel_susp": 0.00022507314877335134
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_frame_on#2651",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_frame_on(self)",
        "snippet": "    def get_frame_on(self):\n        \"\"\"Get whether the axes rectangle patch is drawn.\"\"\"\n        return self._frameon",
        "begin_line": 2651,
        "end_line": 2653,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_frame_on#2655",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_frame_on(self, b)",
        "snippet": "    def set_frame_on(self, b):\n        \"\"\"\n        Set whether the axes rectangle patch is drawn.\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        self._frameon = b\n        self.stale = True",
        "begin_line": 2655,
        "end_line": 2664,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015785319652722967,
            "pseudo_dstar_susp": 0.00015179113539769278,
            "pseudo_tarantula_susp": 0.00022680880018144704,
            "pseudo_op2_susp": 0.00015179113539769278,
            "pseudo_barinel_susp": 0.00022686025408348456
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_axisbelow#2680",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_axisbelow(self, b)",
        "snippet": "    def set_axisbelow(self, b):\n        \"\"\"\n        Set whether axis ticks and gridlines are above or below most artists.\n\n        This controls the zorder of the ticks and gridlines. For more\n        information on the zorder see :doc:`/gallery/misc/zorder_demo`.\n\n        Parameters\n        ----------\n        b : bool or 'line'\n            Possible values:\n\n            - *True* (zorder = 0.5): Ticks and gridlines are below all Artists.\n            - 'line' (zorder = 1.5): Ticks and gridlines are above patches\n              (e.g. rectangles, with default zorder = 1) but still below lines\n              and markers (with their default zorder = 2).\n            - *False* (zorder = 2.5): Ticks and gridlines are above patches\n              and lines / markers.\n\n        See Also\n        --------\n        get_axisbelow\n        \"\"\"\n        self._axisbelow = axisbelow = validate_axisbelow(b)\n        if axisbelow is True:\n            zorder = 0.5\n        elif axisbelow is False:\n            zorder = 2.5\n        elif axisbelow == \"line\":\n            zorder = 1.5\n        else:\n            raise ValueError(\"Unexpected axisbelow value\")\n        for axis in self._get_axis_list():\n            axis.set_zorder(zorder)\n        self.stale = True",
        "begin_line": 2680,
        "end_line": 2714,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00042716787697565144,
            "pseudo_dstar_susp": 0.0006119951040391676,
            "pseudo_tarantula_susp": 0.0002966478789676654,
            "pseudo_op2_susp": 0.0006119951040391676,
            "pseudo_barinel_susp": 0.0002966478789676654
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.grid#2717",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.grid(self, b=None, which='major', axis='both', **kwargs)",
        "snippet": "    def grid(self, b=None, which='major', axis='both', **kwargs):\n        \"\"\"\n        Configure the grid lines.\n\n        Parameters\n        ----------\n        b : bool or None, optional\n            Whether to show the grid lines. If any *kwargs* are supplied,\n            it is assumed you want the grid on and *b* will be set to True.\n\n            If *b* is *None* and there are no *kwargs*, this toggles the\n            visibility of the lines.\n\n        which : {'major', 'minor', 'both'}, optional\n            The grid lines to apply the changes on.\n\n        axis : {'both', 'x', 'y'}, optional\n            The axis to apply the changes on.\n\n        **kwargs : `.Line2D` properties\n            Define the line properties of the grid, e.g.::\n\n                grid(color='r', linestyle='-', linewidth=2)\n\n            Valid keyword arguments are:\n\n            %(_Line2D_docstr)s\n\n        Notes\n        -----\n        The axis is drawn as a unit, so the effective zorder for drawing the\n        grid is determined by the zorder of each axis, not by the zorder of the\n        `.Line2D` objects comprising the grid.  Therefore, to set grid zorder,\n        use `.set_axisbelow` or, for more control, call the\n        `~matplotlib.axis.Axis.set_zorder` method of each axis.\n        \"\"\"\n        if len(kwargs):\n            b = True\n        cbook._check_in_list(['x', 'y', 'both'], axis=axis)\n        if axis in ['x', 'both']:\n            self.xaxis.grid(b, which=which, **kwargs)\n        if axis in ['y', 'both']:\n            self.yaxis.grid(b, which=which, **kwargs)",
        "begin_line": 2717,
        "end_line": 2759,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004329004329004329,
            "pseudo_dstar_susp": 0.0006207324643078833,
            "pseudo_tarantula_susp": 0.000149947518368571,
            "pseudo_op2_susp": 0.0006207324643078833,
            "pseudo_barinel_susp": 0.000149947518368571
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.locator_params#2832",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.locator_params(self, axis='both', tight=None, **kwargs)",
        "snippet": "    def locator_params(self, axis='both', tight=None, **kwargs):\n        \"\"\"\n        Control behavior of major tick locators.\n\n        Because the locator is involved in autoscaling, `~.Axes.autoscale_view`\n        is called automatically after the parameters are changed.\n\n        Parameters\n        ----------\n        axis : {'both', 'x', 'y'}, optional\n            The axis on which to operate.\n\n        tight : bool or None, optional\n            Parameter passed to `~.Axes.autoscale_view`.\n            Default is None, for no change.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Remaining keyword arguments are passed to directly to the\n            ``set_params()`` method of the locator. Supported keywords depend\n            on the type of the locator. See for example\n            `~.ticker.MaxNLocator.set_params` for the `.ticker.MaxNLocator`\n            used by default for linear axes.\n\n        Examples\n        --------\n        When plotting small subplots, one might want to reduce the maximum\n        number of ticks and use tight bounds, for example::\n\n            ax.locator_params(tight=True, nbins=4)\n\n        \"\"\"\n        _x = axis in ['x', 'both']\n        _y = axis in ['y', 'both']\n        if _x:\n            self.xaxis.get_major_locator().set_params(**kwargs)\n        if _y:\n            self.yaxis.get_major_locator().set_params(**kwargs)\n        self._request_autoscale_view(tight=tight, scalex=_x, scaley=_y)",
        "begin_line": 2832,
        "end_line": 2871,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00026343519494204424,
            "pseudo_dstar_susp": 0.0002269117313365101,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0002269117313365101,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.tick_params#2873",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.tick_params(self, axis='both', **kwargs)",
        "snippet": "    def tick_params(self, axis='both', **kwargs):\n        \"\"\"Change the appearance of ticks, tick labels, and gridlines.\n\n        Parameters\n        ----------\n        axis : {'x', 'y', 'both'}, optional\n            Which axis to apply the parameters to.\n\n        Other Parameters\n        ----------------\n        axis : {'x', 'y', 'both'}\n            Axis on which to operate; default is 'both'.\n        reset : bool, default: False\n            If *True*, set all parameters to defaults before processing other\n            keyword arguments.\n        which : {'major', 'minor', 'both'}\n            Default is 'major'; apply arguments to *which* ticks.\n        direction : {'in', 'out', 'inout'}\n            Puts ticks inside the axes, outside the axes, or both.\n        length : float\n            Tick length in points.\n        width : float\n            Tick width in points.\n        color : color\n            Tick color.\n        pad : float\n            Distance in points between tick and label.\n        labelsize : float or str\n            Tick label font size in points or as a string (e.g., 'large').\n        labelcolor : color\n            Tick label color.\n        colors : color\n            Tick color and label color.\n        zorder : float\n            Tick and label zorder.\n        bottom, top, left, right : bool\n            Whether to draw the respective ticks.\n        labelbottom, labeltop, labelleft, labelright : bool\n            Whether to draw the respective tick labels.\n        labelrotation : float\n            Tick label rotation\n        grid_color : color\n            Gridline color.\n        grid_alpha : float\n            Transparency of gridlines: 0 (transparent) to 1 (opaque).\n        grid_linewidth : float\n            Width of gridlines in points.\n        grid_linestyle : str\n            Any valid `.Line2D` line style spec.\n\n        Examples\n        --------\n        Usage ::\n\n            ax.tick_params(direction='out', length=6, width=2, colors='r',\n                           grid_color='r', grid_alpha=0.5)\n\n        This will make all major ticks be red, pointing out of the box,\n        and with dimensions 6 points by 2 points.  Tick labels will\n        also be red.  Gridlines will be red and translucent.\n\n        \"\"\"\n        cbook._check_in_list(['x', 'y', 'both'], axis=axis)\n        if axis in ['x', 'both']:\n            xkw = dict(kwargs)\n            xkw.pop('left', None)\n            xkw.pop('right', None)\n            xkw.pop('labelleft', None)\n            xkw.pop('labelright', None)\n            self.xaxis.set_tick_params(**xkw)\n        if axis in ['y', 'both']:\n            ykw = dict(kwargs)\n            ykw.pop('top', None)\n            ykw.pop('bottom', None)\n            ykw.pop('labeltop', None)\n            ykw.pop('labelbottom', None)\n            self.yaxis.set_tick_params(**ykw)",
        "begin_line": 2873,
        "end_line": 2949,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00042716787697565144,
            "pseudo_dstar_susp": 0.0006119951040391676,
            "pseudo_tarantula_susp": 0.0002860411899313501,
            "pseudo_op2_susp": 0.0006119951040391676,
            "pseudo_barinel_susp": 0.0002860411899313501
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_axis_off#2951",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_axis_off(self)",
        "snippet": "    def set_axis_off(self):\n        \"\"\"\n        Turn the x- and y-axis off.\n\n        This affects the axis lines, ticks, ticklabels, grid and axis labels.\n        \"\"\"\n        self.axison = False\n        self.stale = True",
        "begin_line": 2951,
        "end_line": 2958,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018115942028985507,
            "pseudo_dstar_susp": 0.0001703867779860283,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.0001703867779860283,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_axis_on#2960",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_axis_on(self)",
        "snippet": "    def set_axis_on(self):\n        \"\"\"\n        Turn the x- and y-axis on.\n\n        This affects the axis lines, ticks, ticklabels, grid and axis labels.\n        \"\"\"\n        self.axison = True\n        self.stale = True",
        "begin_line": 2960,
        "end_line": 2967,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004233700254022015,
            "pseudo_dstar_susp": 0.0005724098454493417,
            "pseudo_tarantula_susp": 0.0002891008962127783,
            "pseudo_op2_susp": 0.0005724098454493417,
            "pseudo_barinel_susp": 0.0002891008962127783
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.xaxis_inverted#2983",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.xaxis_inverted(self)",
        "snippet": "    def xaxis_inverted(self):\n        \"\"\"\n        Return whether the x-axis is inverted.\n\n        The axis is inverted if the left value is larger than the right value.\n\n        See Also\n        --------\n        invert_xaxis\n        get_xlim, set_xlim\n        get_xbound, set_xbound\n        \"\"\"\n        return self.xaxis.get_inverted()",
        "begin_line": 2983,
        "end_line": 2995,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00038955979742890534,
            "pseudo_dstar_susp": 0.00035842293906810036,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.00035842293906810036,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_xbound#2997",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_xbound(self)",
        "snippet": "    def get_xbound(self):\n        \"\"\"\n        Return the lower and upper x-axis bounds, in increasing order.\n\n        See Also\n        --------\n        set_xbound\n        get_xlim, set_xlim\n        invert_xaxis, xaxis_inverted\n        \"\"\"\n        left, right = self.get_xlim()\n        if left < right:\n            return left, right\n        else:\n            return right, left",
        "begin_line": 2997,
        "end_line": 3011,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004012841091492777,
            "pseudo_dstar_susp": 0.00036683785766691124,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.00036683785766691124,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_xbound#3013",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_xbound(self, lower=None, upper=None)",
        "snippet": "    def set_xbound(self, lower=None, upper=None):\n        \"\"\"\n        Set the lower and upper numerical bounds of the x-axis.\n\n        This method will honor axes inversion regardless of parameter order.\n        It will not change the autoscaling setting (``Axes._autoscaleXon``).\n\n        Parameters\n        ----------\n        lower, upper : float or None\n            The lower and upper bounds. If *None*, the respective axis bound\n            is not modified.\n\n        See Also\n        --------\n        get_xbound\n        get_xlim, set_xlim\n        invert_xaxis, xaxis_inverted\n        \"\"\"\n        if upper is None and np.iterable(lower):\n            lower, upper = lower\n\n        old_lower, old_upper = self.get_xbound()\n\n        if lower is None:\n            lower = old_lower\n        if upper is None:\n            upper = old_upper\n\n        if self.xaxis_inverted():\n            if lower < upper:\n                self.set_xlim(upper, lower, auto=None)\n            else:\n                self.set_xlim(lower, upper, auto=None)\n        else:\n            if lower < upper:\n                self.set_xlim(lower, upper, auto=None)\n            else:\n                self.set_xlim(upper, lower, auto=None)",
        "begin_line": 3013,
        "end_line": 3051,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003977724741447892,
            "pseudo_dstar_susp": 0.0003589375448671931,
            "pseudo_tarantula_susp": 0.00031377470975839345,
            "pseudo_op2_susp": 0.0003589375448671931,
            "pseudo_barinel_susp": 0.00031377470975839345
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_xlim#3053",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_xlim(self)",
        "snippet": "    def get_xlim(self):\n        \"\"\"\n        Return the x-axis view limits.\n\n        Returns\n        -------\n        left, right : (float, float)\n            The current x-axis limits in data coordinates.\n\n        See Also\n        --------\n        set_xlim\n        set_xbound, get_xbound\n        invert_xaxis, xaxis_inverted\n\n        Notes\n        -----\n        The x-axis may be inverted, in which case the *left* value will\n        be greater than the *right* value.\n\n        \"\"\"\n        return tuple(self.viewLim.intervalx)",
        "begin_line": 3053,
        "end_line": 3074,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00039761431411530816,
            "pseudo_dstar_susp": 0.000368052999631947,
            "pseudo_tarantula_susp": 0.00030211480362537764,
            "pseudo_op2_susp": 0.000368052999631947,
            "pseudo_barinel_susp": 0.00030211480362537764
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._validate_converted_limits#3076",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._validate_converted_limits(self, limit, convert)",
        "snippet": "    def _validate_converted_limits(self, limit, convert):\n        \"\"\"\n        Raise ValueError if converted limits are non-finite.\n\n        Note that this function also accepts None as a limit argument.\n\n        Returns\n        -------\n        The limit value after call to convert(), or None if limit is None.\n        \"\"\"\n        if limit is not None:\n            converted_limit = convert(limit)\n            if (isinstance(converted_limit, Real)\n                    and not np.isfinite(converted_limit)):\n                raise ValueError(\"Axis limits cannot be NaN or Inf\")\n            return converted_limit",
        "begin_line": 3076,
        "end_line": 3091,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004033884630899556,
            "pseudo_dstar_susp": 0.0005820721769499418,
            "pseudo_tarantula_susp": 0.0002878526194588371,
            "pseudo_op2_susp": 0.0005820721769499418,
            "pseudo_barinel_susp": 0.0002878526194588371
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_xlim#3093",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_xlim(self, left=None, right=None, emit=True, auto=False, *, xmin=None, xmax=None)",
        "snippet": "    def set_xlim(self, left=None, right=None, emit=True, auto=False,\n                 *, xmin=None, xmax=None):\n        \"\"\"\n        Set the x-axis view limits.\n\n        Parameters\n        ----------\n        left : float, optional\n            The left xlim in data coordinates. Passing *None* leaves the\n            limit unchanged.\n\n            The left and right xlims may also be passed as the tuple\n            (*left*, *right*) as the first positional argument (or as\n            the *left* keyword argument).\n\n            .. ACCEPTS: (bottom: float, top: float)\n\n        right : float, optional\n            The right xlim in data coordinates. Passing *None* leaves the\n            limit unchanged.\n\n        emit : bool, optional\n            Whether to notify observers of limit change (default: True).\n\n        auto : bool or None, optional\n            Whether to turn on autoscaling of the x-axis. True turns on,\n            False turns off (default action), None leaves unchanged.\n\n        xmin, xmax : scalar, optional\n            They are equivalent to left and right respectively,\n            and it is an error to pass both *xmin* and *left* or\n            *xmax* and *right*.\n\n        Returns\n        -------\n        left, right : (float, float)\n            The new x-axis limits in data coordinates.\n\n        See Also\n        --------\n        get_xlim\n        set_xbound, get_xbound\n        invert_xaxis, xaxis_inverted\n\n        Notes\n        -----\n        The *left* value may be greater than the *right* value, in which\n        case the x-axis values will decrease from left to right.\n\n        Examples\n        --------\n        >>> set_xlim(left, right)\n        >>> set_xlim((left, right))\n        >>> left, right = set_xlim(left, right)\n\n        One limit may be left unchanged.\n\n        >>> set_xlim(right=right_lim)\n\n        Limits may be passed in reverse order to flip the direction of\n        the x-axis. For example, suppose *x* represents the number of\n        years before present. The x-axis limits might be set like the\n        following so 5000 years ago is on the left of the plot and the\n        present is on the right.\n\n        >>> set_xlim(5000, 0)\n\n        \"\"\"\n        if right is None and np.iterable(left):\n            left, right = left\n        if xmin is not None:\n            if left is not None:\n                raise TypeError('Cannot pass both `xmin` and `left`')\n            left = xmin\n        if xmax is not None:\n            if right is not None:\n                raise TypeError('Cannot pass both `xmax` and `right`')\n            right = xmax\n\n        self._process_unit_info(xdata=(left, right))\n        left = self._validate_converted_limits(left, self.convert_xunits)\n        right = self._validate_converted_limits(right, self.convert_xunits)\n\n        if left is None or right is None:\n            # Axes init calls set_xlim(0, 1) before get_xlim() can be called,\n            # so only grab the limits if we really need them.\n            old_left, old_right = self.get_xlim()\n            if left is None:\n                left = old_left\n            if right is None:\n                right = old_right\n\n        if self.get_xscale() == 'log' and (left <= 0 or right <= 0):\n            # Axes init calls set_xlim(0, 1) before get_xlim() can be called,\n            # so only grab the limits if we really need them.\n            old_left, old_right = self.get_xlim()\n            if left <= 0:\n                cbook._warn_external(\n                    'Attempted to set non-positive left xlim on a '\n                    'log-scaled axis.\\n'\n                    'Invalid limit will be ignored.')\n                left = old_left\n            if right <= 0:\n                cbook._warn_external(\n                    'Attempted to set non-positive right xlim on a '\n                    'log-scaled axis.\\n'\n                    'Invalid limit will be ignored.')\n                right = old_right\n        if left == right:\n            cbook._warn_external(\n                f\"Attempting to set identical left == right == {left} results \"\n                f\"in singular transformations; automatically expanding.\")\n        reverse = left > right\n        left, right = self.xaxis.get_major_locator().nonsingular(left, right)\n        left, right = self.xaxis.limit_range_for_scale(left, right)\n        # cast to bool to avoid bad interaction between python 3.8 and np.bool_\n        left, right = sorted([left, right], reverse=bool(reverse))\n\n        self._viewLim.intervalx = (left, right)\n        if auto is not None:\n            self._autoscaleXon = bool(auto)\n\n        if emit:\n            self.callbacks.process('xlim_changed', self)\n            # Call all of the other x-axes that are shared with this one\n            for other in self._shared_x_axes.get_siblings(self):\n                if other is not self:\n                    other.set_xlim(self.viewLim.intervalx,\n                                   emit=False, auto=auto)\n                    if other.figure != self.figure:\n                        other.figure.canvas.draw_idle()\n        self.stale = True\n        return left, right",
        "begin_line": 3093,
        "end_line": 3225,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004060089321965083,
            "pseudo_dstar_susp": 0.0005847953216374269,
            "pseudo_tarantula_susp": 0.0002891008962127783,
            "pseudo_op2_susp": 0.0005847953216374269,
            "pseudo_barinel_susp": 0.0002891008962127783
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_xscale#3227",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_xscale(self)",
        "snippet": "    def get_xscale(self):\n        \"\"\"\n        Return the x-axis scale as string.\n\n        See Also\n        --------\n        set_xscale\n        \"\"\"\n        return self.xaxis.get_scale()",
        "begin_line": 3227,
        "end_line": 3235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003495281370150297,
            "pseudo_dstar_susp": 0.0005336179295624333,
            "pseudo_tarantula_susp": 0.0002834467120181406,
            "pseudo_op2_susp": 0.0005336179295624333,
            "pseudo_barinel_susp": 0.0002834467120181406
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_xscale#3237",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_xscale(self, value, **kwargs)",
        "snippet": "    def set_xscale(self, value, **kwargs):\n        \"\"\"\n        Set the x-axis scale.\n\n        Parameters\n        ----------\n        value : {\"linear\", \"log\", \"symlog\", \"logit\", ...}\n            The axis scale type to apply.\n\n        **kwargs\n            Different keyword arguments are accepted, depending on the scale.\n            See the respective class keyword arguments:\n\n            - `matplotlib.scale.LinearScale`\n            - `matplotlib.scale.LogScale`\n            - `matplotlib.scale.SymmetricalLogScale`\n            - `matplotlib.scale.LogitScale`\n\n        Notes\n        -----\n        By default, Matplotlib supports the above mentioned scales.\n        Additionally, custom scales may be registered using\n        `matplotlib.scale.register_scale`. These scales can then also\n        be used here.\n        \"\"\"\n        old_default_lims = (self.xaxis.get_major_locator()\n                            .nonsingular(-np.inf, np.inf))\n        g = self.get_shared_x_axes()\n        for ax in g.get_siblings(self):\n            ax.xaxis._set_scale(value, **kwargs)\n            ax._update_transScale()\n            ax.stale = True\n        new_default_lims = (self.xaxis.get_major_locator()\n                            .nonsingular(-np.inf, np.inf))\n        if old_default_lims != new_default_lims:\n            # Force autoscaling now, to take advantage of the scale locator's\n            # nonsingular() before it possibly gets swapped out by the user.\n            self.autoscale_view(scaley=False)",
        "begin_line": 3237,
        "end_line": 3274,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020128824476650564,
            "pseudo_dstar_susp": 0.0002357934449422306,
            "pseudo_tarantula_susp": 0.0002109259649862898,
            "pseudo_op2_susp": 0.0002357934449422306,
            "pseudo_barinel_susp": 0.0002109259649862898
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_xticks#3282",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_xticks(self, ticks, minor=False)",
        "snippet": "    def set_xticks(self, ticks, minor=False):\n        \"\"\"\n        Set the x ticks with list of *ticks*\n\n        Parameters\n        ----------\n        ticks : list\n            List of x-axis tick locations.\n\n        minor : bool, optional\n            If ``False`` sets major ticks, if ``True`` sets minor ticks.\n            Default is ``False``.\n        \"\"\"\n        ret = self.xaxis.set_ticks(ticks, minor=minor)\n        self.stale = True\n        return ret",
        "begin_line": 3282,
        "end_line": 3297,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023089355806972986,
            "pseudo_dstar_susp": 0.0002316423442205235,
            "pseudo_tarantula_susp": 0.00022951572182694515,
            "pseudo_op2_susp": 0.0002316423442205235,
            "pseudo_barinel_susp": 0.00022951572182694515
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_xticklabels#3321",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_xticklabels(self, minor=False, which=None)",
        "snippet": "    def get_xticklabels(self, minor=False, which=None):\n        \"\"\"\n        Get the x tick labels as a list of `~matplotlib.text.Text` instances.\n\n        Parameters\n        ----------\n        minor : bool, optional\n           If True return the minor ticklabels,\n           else return the major ticklabels.\n\n        which : None, ('minor', 'major', 'both')\n           Overrides *minor*.\n\n           Selects which ticklabels to return\n\n        Returns\n        -------\n        ret : list\n           List of `~matplotlib.text.Text` instances.\n        \"\"\"\n        return self.xaxis.get_ticklabels(minor=minor, which=which)",
        "begin_line": 3321,
        "end_line": 3341,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021473051320592657,
            "pseudo_dstar_susp": 0.00020751193193608634,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00020751193193608634,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_xticklabels#3343",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_xticklabels(self, labels, fontdict=None, minor=False, **kwargs)",
        "snippet": "    def set_xticklabels(self, labels, fontdict=None, minor=False, **kwargs):\n        \"\"\"\n        Set the x-tick labels with list of string labels.\n\n        Parameters\n        ----------\n        labels : List[str]\n            List of string labels.\n\n        fontdict : dict, optional\n            A dictionary controlling the appearance of the ticklabels.\n            The default *fontdict* is::\n\n               {'fontsize': rcParams['axes.titlesize'],\n                'fontweight': rcParams['axes.titleweight'],\n                'verticalalignment': 'baseline',\n                'horizontalalignment': loc}\n\n        minor : bool, optional\n            Whether to set the minor ticklabels rather than the major ones.\n\n        Returns\n        -------\n        A list of `~.text.Text` instances.\n\n        Other Parameters\n        -----------------\n        **kwargs : `~.text.Text` properties.\n        \"\"\"\n        if fontdict is not None:\n            kwargs.update(fontdict)\n        ret = self.xaxis.set_ticklabels(labels,\n                                        minor=minor, **kwargs)\n        self.stale = True\n        return ret",
        "begin_line": 3343,
        "end_line": 3377,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.0001525320317266626,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0001525320317266626,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.invert_yaxis#3379",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.invert_yaxis(self)",
        "snippet": "    def invert_yaxis(self):\n        \"\"\"\n        Invert the y-axis.\n\n        See Also\n        --------\n        yaxis_inverted\n        get_ylim, set_ylim\n        get_ybound, set_ybound\n        \"\"\"\n        self.yaxis.set_inverted(not self.yaxis.get_inverted())",
        "begin_line": 3379,
        "end_line": 3389,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015992323684631377,
            "pseudo_dstar_susp": 0.0001405086412814388,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.0001405086412814388,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.yaxis_inverted#3391",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.yaxis_inverted(self)",
        "snippet": "    def yaxis_inverted(self):\n        \"\"\"\n        Return whether the y-axis is inverted.\n\n        The axis is inverted if the bottom value is larger than the top value.\n\n        See Also\n        --------\n        invert_yaxis\n        get_ylim, set_ylim\n        get_ybound, set_ybound\n        \"\"\"\n        return self.yaxis.get_inverted()",
        "begin_line": 3391,
        "end_line": 3403,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000429553264604811,
            "pseudo_dstar_susp": 0.00036258158085569254,
            "pseudo_tarantula_susp": 0.00029967036260113877,
            "pseudo_op2_susp": 0.00036258158085569254,
            "pseudo_barinel_susp": 0.00029967036260113877
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_ybound#3405",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_ybound(self)",
        "snippet": "    def get_ybound(self):\n        \"\"\"\n        Return the lower and upper y-axis bounds, in increasing order.\n\n        See Also\n        --------\n        set_ybound\n        get_ylim, set_ylim\n        invert_yaxis, yaxis_inverted\n        \"\"\"\n        bottom, top = self.get_ylim()\n        if bottom < top:\n            return bottom, top\n        else:\n            return top, bottom",
        "begin_line": 3405,
        "end_line": 3419,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00044464206313917296,
            "pseudo_dstar_susp": 0.00036886757654002215,
            "pseudo_tarantula_susp": 0.00030012004801920766,
            "pseudo_op2_susp": 0.00036886757654002215,
            "pseudo_barinel_susp": 0.00030012004801920766
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_ybound#3421",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_ybound(self, lower=None, upper=None)",
        "snippet": "    def set_ybound(self, lower=None, upper=None):\n        \"\"\"\n        Set the lower and upper numerical bounds of the y-axis.\n\n        This method will honor axes inversion regardless of parameter order.\n        It will not change the autoscaling setting (``Axes._autoscaleYon``).\n\n        Parameters\n        ----------\n        lower, upper : float or None\n            The lower and upper bounds. If *None*, the respective axis bound\n            is not modified.\n\n        See Also\n        --------\n        get_ybound\n        get_ylim, set_ylim\n        invert_yaxis, yaxis_inverted\n        \"\"\"\n        if upper is None and np.iterable(lower):\n            lower, upper = lower\n\n        old_lower, old_upper = self.get_ybound()\n\n        if lower is None:\n            lower = old_lower\n        if upper is None:\n            upper = old_upper\n\n        if self.yaxis_inverted():\n            if lower < upper:\n                self.set_ylim(upper, lower, auto=None)\n            else:\n                self.set_ylim(lower, upper, auto=None)\n        else:\n            if lower < upper:\n                self.set_ylim(lower, upper, auto=None)\n            else:\n                self.set_ylim(upper, lower, auto=None)",
        "begin_line": 3421,
        "end_line": 3459,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043308791684711995,
            "pseudo_dstar_susp": 0.0003629764065335753,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0003629764065335753,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_ylim#3461",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_ylim(self)",
        "snippet": "    def get_ylim(self):\n        \"\"\"\n        Return the y-axis view limits.\n\n        Returns\n        -------\n        bottom, top : (float, float)\n            The current y-axis limits in data coordinates.\n\n        See Also\n        --------\n        set_ylim\n        set_ybound, get_ybound\n        invert_yaxis, yaxis_inverted\n\n        Notes\n        -----\n        The y-axis may be inverted, in which case the *bottom* value\n        will be greater than the *top* value.\n\n        \"\"\"\n        return tuple(self.viewLim.intervaly)",
        "begin_line": 3461,
        "end_line": 3482,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00044682752457551384,
            "pseudo_dstar_susp": 0.0003711952487008166,
            "pseudo_tarantula_susp": 0.00030012004801920766,
            "pseudo_op2_susp": 0.0003711952487008166,
            "pseudo_barinel_susp": 0.00030012004801920766
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_ylim#3484",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_ylim(self, bottom=None, top=None, emit=True, auto=False, *, ymin=None, ymax=None)",
        "snippet": "    def set_ylim(self, bottom=None, top=None, emit=True, auto=False,\n                 *, ymin=None, ymax=None):\n        \"\"\"\n        Set the y-axis view limits.\n\n        Parameters\n        ----------\n        bottom : float, optional\n            The bottom ylim in data coordinates. Passing *None* leaves the\n            limit unchanged.\n\n            The bottom and top ylims may also be passed as the tuple\n            (*bottom*, *top*) as the first positional argument (or as\n            the *bottom* keyword argument).\n\n            .. ACCEPTS: (bottom: float, top: float)\n\n        top : float, optional\n            The top ylim in data coordinates. Passing *None* leaves the\n            limit unchanged.\n\n        emit : bool, optional\n            Whether to notify observers of limit change (default: ``True``).\n\n        auto : bool or None, optional\n            Whether to turn on autoscaling of the y-axis. *True* turns on,\n            *False* turns off (default action), *None* leaves unchanged.\n\n        ymin, ymax : scalar, optional\n            They are equivalent to bottom and top respectively,\n            and it is an error to pass both *ymin* and *bottom* or\n            *ymax* and *top*.\n\n        Returns\n        -------\n        bottom, top : (float, float)\n            The new y-axis limits in data coordinates.\n\n        See Also\n        --------\n        get_ylim\n        set_ybound, get_ybound\n        invert_yaxis, yaxis_inverted\n\n        Notes\n        -----\n        The *bottom* value may be greater than the *top* value, in which\n        case the y-axis values will decrease from *bottom* to *top*.\n\n        Examples\n        --------\n        >>> set_ylim(bottom, top)\n        >>> set_ylim((bottom, top))\n        >>> bottom, top = set_ylim(bottom, top)\n\n        One limit may be left unchanged.\n\n        >>> set_ylim(top=top_lim)\n\n        Limits may be passed in reverse order to flip the direction of\n        the y-axis. For example, suppose ``y`` represents depth of the\n        ocean in m. The y-axis limits might be set like the following\n        so 5000 m depth is at the bottom of the plot and the surface,\n        0 m, is at the top.\n\n        >>> set_ylim(5000, 0)\n        \"\"\"\n        if top is None and np.iterable(bottom):\n            bottom, top = bottom\n        if ymin is not None:\n            if bottom is not None:\n                raise TypeError('Cannot pass both `ymin` and `bottom`')\n            bottom = ymin\n        if ymax is not None:\n            if top is not None:\n                raise TypeError('Cannot pass both `ymax` and `top`')\n            top = ymax\n\n        self._process_unit_info(ydata=(bottom, top))\n        bottom = self._validate_converted_limits(bottom, self.convert_yunits)\n        top = self._validate_converted_limits(top, self.convert_yunits)\n\n        if bottom is None or top is None:\n            # Axes init calls set_ylim(0, 1) before get_ylim() can be called,\n            # so only grab the limits if we really need them.\n            old_bottom, old_top = self.get_ylim()\n            if bottom is None:\n                bottom = old_bottom\n            if top is None:\n                top = old_top\n\n        if self.get_yscale() == 'log' and (bottom <= 0 or top <= 0):\n            # Axes init calls set_xlim(0, 1) before get_xlim() can be called,\n            # so only grab the limits if we really need them.\n            old_bottom, old_top = self.get_ylim()\n            if bottom <= 0:\n                cbook._warn_external(\n                    'Attempted to set non-positive bottom ylim on a '\n                    'log-scaled axis.\\n'\n                    'Invalid limit will be ignored.')\n                bottom = old_bottom\n            if top <= 0:\n                cbook._warn_external(\n                    'Attempted to set non-positive top ylim on a '\n                    'log-scaled axis.\\n'\n                    'Invalid limit will be ignored.')\n                top = old_top\n        if bottom == top:\n            cbook._warn_external(\n                f\"Attempting to set identical bottom == top == {bottom} \"\n                f\"results in singular transformations; automatically \"\n                f\"expanding.\")\n        reverse = bottom > top\n        bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n        bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n        # cast to bool to avoid bad interaction between python 3.8 and np.bool_\n        bottom, top = sorted([bottom, top], reverse=bool(reverse))\n\n        self._viewLim.intervaly = (bottom, top)\n        if auto is not None:\n            self._autoscaleYon = bool(auto)\n\n        if emit:\n            self.callbacks.process('ylim_changed', self)\n            # Call all of the other y-axes that are shared with this one\n            for other in self._shared_y_axes.get_siblings(self):\n                if other is not self:\n                    other.set_ylim(self.viewLim.intervaly,\n                                   emit=False, auto=auto)\n                    if other.figure != self.figure:\n                        other.figure.canvas.draw_idle()\n        self.stale = True\n        return bottom, top",
        "begin_line": 3484,
        "end_line": 3616,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043122035360068997,
            "pseudo_dstar_susp": 0.0006180469715698393,
            "pseudo_tarantula_susp": 0.0002860411899313501,
            "pseudo_op2_susp": 0.0006180469715698393,
            "pseudo_barinel_susp": 0.0002860411899313501
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_yscale#3618",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_yscale(self)",
        "snippet": "    def get_yscale(self):\n        \"\"\"\n        Return the y-axis scale as string.\n\n        See Also\n        --------\n        set_yscale\n        \"\"\"\n        return self.yaxis.get_scale()",
        "begin_line": 3618,
        "end_line": 3626,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004033884630899556,
            "pseudo_dstar_susp": 0.0005820721769499418,
            "pseudo_tarantula_susp": 0.0002860411899313501,
            "pseudo_op2_susp": 0.0005820721769499418,
            "pseudo_barinel_susp": 0.0002860411899313501
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_yscale#3628",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_yscale(self, value, **kwargs)",
        "snippet": "    def set_yscale(self, value, **kwargs):\n        \"\"\"\n        Set the y-axis scale.\n\n        Parameters\n        ----------\n        value : {\"linear\", \"log\", \"symlog\", \"logit\", ...}\n            The axis scale type to apply.\n\n        **kwargs\n            Different keyword arguments are accepted, depending on the scale.\n            See the respective class keyword arguments:\n\n            - `matplotlib.scale.LinearScale`\n            - `matplotlib.scale.LogScale`\n            - `matplotlib.scale.SymmetricalLogScale`\n            - `matplotlib.scale.LogitScale`\n\n        Notes\n        -----\n        By default, Matplotlib supports the above mentioned scales.\n        Additionally, custom scales may be registered using\n        `matplotlib.scale.register_scale`. These scales can then also\n        be used here.\n        \"\"\"\n        old_default_lims = (self.yaxis.get_major_locator()\n                            .nonsingular(-np.inf, np.inf))\n        g = self.get_shared_y_axes()\n        for ax in g.get_siblings(self):\n            ax.yaxis._set_scale(value, **kwargs)\n            ax._update_transScale()\n            ax.stale = True\n        new_default_lims = (self.yaxis.get_major_locator()\n                            .nonsingular(-np.inf, np.inf))\n        if old_default_lims != new_default_lims:\n            # Force autoscaling now, to take advantage of the scale locator's\n            # nonsingular() before it possibly gets swapped out by the user.\n            self.autoscale_view(scalex=False)",
        "begin_line": 3628,
        "end_line": 3665,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000209819555182543,
            "pseudo_dstar_susp": 0.00024764735017335313,
            "pseudo_tarantula_susp": 0.0002314814814814815,
            "pseudo_op2_susp": 0.00024764735017335313,
            "pseudo_barinel_susp": 0.0002314814814814815
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_yticks#3673",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_yticks(self, ticks, minor=False)",
        "snippet": "    def set_yticks(self, ticks, minor=False):\n        \"\"\"\n        Set the y ticks with list of *ticks*\n\n        Parameters\n        ----------\n        ticks : list\n            List of y-axis tick locations\n\n        minor : bool, optional\n            If ``False`` sets major ticks, if ``True`` sets minor ticks.\n            Default is ``False``.\n        \"\"\"\n        ret = self.yaxis.set_ticks(ticks, minor=minor)\n        return ret",
        "begin_line": 3673,
        "end_line": 3687,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023775558725630053,
            "pseudo_dstar_susp": 0.00023191094619666049,
            "pseudo_tarantula_susp": 0.000250501002004008,
            "pseudo_op2_susp": 0.00023191094619666049,
            "pseudo_barinel_susp": 0.000250501002004008
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_yticklabels#3711",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_yticklabels(self, minor=False, which=None)",
        "snippet": "    def get_yticklabels(self, minor=False, which=None):\n        \"\"\"\n        Get the y tick labels as a list of `~matplotlib.text.Text` instances.\n\n        Parameters\n        ----------\n        minor : bool\n           If True return the minor ticklabels,\n           else return the major ticklabels\n\n        which : None, ('minor', 'major', 'both')\n           Overrides *minor*.\n\n           Selects which ticklabels to return\n\n        Returns\n        -------\n        ret : list\n           List of `~matplotlib.text.Text` instances.\n        \"\"\"\n        return self.yaxis.get_ticklabels(minor=minor, which=which)",
        "begin_line": 3711,
        "end_line": 3731,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00014076576576576576,
            "pseudo_dstar_susp": 0.0001508523155830442,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.0001508523155830442,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_yticklabels#3733",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_yticklabels(self, labels, fontdict=None, minor=False, **kwargs)",
        "snippet": "    def set_yticklabels(self, labels, fontdict=None, minor=False, **kwargs):\n        \"\"\"\n        Set the y-tick labels with list of strings labels.\n\n        Parameters\n        ----------\n        labels : List[str]\n            list of string labels\n\n        fontdict : dict, optional\n            A dictionary controlling the appearance of the ticklabels.\n            The default *fontdict* is::\n\n               {'fontsize': rcParams['axes.titlesize'],\n                'fontweight': rcParams['axes.titleweight'],\n                'verticalalignment': 'baseline',\n                'horizontalalignment': loc}\n\n        minor : bool, optional\n            Whether to set the minor ticklabels rather than the major ones.\n\n        Returns\n        -------\n        A list of `~.text.Text` instances.\n\n        Other Parameters\n        ----------------\n        **kwargs : `~.text.Text` properties.\n        \"\"\"\n        if fontdict is not None:\n            kwargs.update(fontdict)\n        return self.yaxis.set_ticklabels(labels,\n                                         minor=minor, **kwargs)",
        "begin_line": 3733,
        "end_line": 3765,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015992323684631377,
            "pseudo_dstar_susp": 0.0001405086412814388,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.0001405086412814388,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.xaxis_date#3767",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.xaxis_date(self, tz=None)",
        "snippet": "    def xaxis_date(self, tz=None):\n        \"\"\"\n        Sets up x-axis ticks and labels that treat the x data as dates.\n\n        Parameters\n        ----------\n        tz : str or `tzinfo` instance, optional\n            Timezone.  Defaults to :rc:`timezone`.\n        \"\"\"\n        # should be enough to inform the unit conversion interface\n        # dates are coming in\n        self.xaxis.axis_date(tz)",
        "begin_line": 3767,
        "end_line": 3778,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00016028209648982208,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.00016028209648982208,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.yaxis_date#3780",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.yaxis_date(self, tz=None)",
        "snippet": "    def yaxis_date(self, tz=None):\n        \"\"\"\n        Sets up y-axis ticks and labels that treat the y data as dates.\n\n        Parameters\n        ----------\n        tz : str or `tzinfo` instance, optional\n            Timezone.  Defaults to :rc:`timezone`.\n        \"\"\"\n        self.yaxis.axis_date(tz)",
        "begin_line": 3780,
        "end_line": 3789,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001380071763731714,
            "pseudo_dstar_susp": 0.00013869625520110957,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00013869625520110957,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.format_xdata#3791",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.format_xdata(self, x)",
        "snippet": "    def format_xdata(self, x):\n        \"\"\"\n        Return *x* formatted as an x-value.\n\n        This function will use the `.fmt_xdata` attribute if it is not None,\n        else will fall back on the xaxis major formatter.\n        \"\"\"\n        return (self.fmt_xdata if self.fmt_xdata is not None\n                else self.xaxis.get_major_formatter().format_data_short)(x)",
        "begin_line": 3791,
        "end_line": 3799,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.format_ydata#3801",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.format_ydata(self, y)",
        "snippet": "    def format_ydata(self, y):\n        \"\"\"\n        Return *y* formatted as an y-value.\n\n        This function will use the `.fmt_ydata` attribute if it is not None,\n        else will fall back on the yaxis major formatter.\n        \"\"\"\n        return (self.fmt_ydata if self.fmt_ydata is not None\n                else self.yaxis.get_major_formatter().format_data_short)(y)",
        "begin_line": 3801,
        "end_line": 3809,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.format_coord#3811",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.format_coord(self, x, y)",
        "snippet": "    def format_coord(self, x, y):\n        \"\"\"Return a format string formatting the *x*, *y* coordinates.\"\"\"\n        if x is None:\n            xs = '???'\n        else:\n            xs = self.format_xdata(x)\n        if y is None:\n            ys = '???'\n        else:\n            ys = self.format_ydata(y)\n        return 'x=%s y=%s' % (xs, ys)",
        "begin_line": 3811,
        "end_line": 3821,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.minorticks_on#3823",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.minorticks_on(self)",
        "snippet": "    def minorticks_on(self):\n        \"\"\"\n        Display minor ticks on the axes.\n\n        Displaying minor ticks may reduce performance; you may turn them off\n        using `minorticks_off()` if drawing speed is a problem.\n        \"\"\"\n        for ax in (self.xaxis, self.yaxis):\n            scale = ax.get_scale()\n            if scale == 'log':\n                s = ax._scale\n                ax.set_minor_locator(mticker.LogLocator(s.base, s.subs))\n            elif scale == 'symlog':\n                s = ax._scale\n                ax.set_minor_locator(\n                    mticker.SymmetricalLogLocator(s._transform, s.subs))\n            else:\n                ax.set_minor_locator(mticker.AutoMinorLocator())",
        "begin_line": 3823,
        "end_line": 3840,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_navigate#3867",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_navigate(self, b)",
        "snippet": "    def set_navigate(self, b):\n        \"\"\"\n        Set whether the axes responds to navigation toolbar commands\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        self._navigate = b",
        "begin_line": 3867,
        "end_line": 3875,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00042716787697565144,
            "pseudo_dstar_susp": 0.0006119951040391676,
            "pseudo_tarantula_susp": 0.0002860411899313501,
            "pseudo_op2_susp": 0.0006119951040391676,
            "pseudo_barinel_susp": 0.0002860411899313501
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_navigate_mode#3883",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_navigate_mode(self, b)",
        "snippet": "    def set_navigate_mode(self, b):\n        \"\"\"\n        Set the navigation toolbar button status;\n\n        .. warning::\n            this is not a user-API function.\n\n        \"\"\"\n        self._navigate_mode = b",
        "begin_line": 3883,
        "end_line": 3891,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00042716787697565144,
            "pseudo_dstar_susp": 0.0006119951040391676,
            "pseudo_tarantula_susp": 0.0002860411899313501,
            "pseudo_op2_susp": 0.0006119951040391676,
            "pseudo_barinel_susp": 0.0002860411899313501
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._set_view_from_bbox#3927",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._set_view_from_bbox(self, bbox, direction='in', mode=None, twinx=False, twiny=False)",
        "snippet": "    def _set_view_from_bbox(self, bbox, direction='in',\n                            mode=None, twinx=False, twiny=False):\n        \"\"\"\n        Update view from a selection bbox.\n\n        .. note::\n\n            Intended to be overridden by new projection types, but if not, the\n            default implementation sets the view limits to the bbox directly.\n\n        Parameters\n        ----------\n        bbox : 4-tuple or 3 tuple\n            * If bbox is a 4 tuple, it is the selected bounding box limits,\n              in *display* coordinates.\n            * If bbox is a 3 tuple, it is an (xp, yp, scl) triple, where\n              (xp, yp) is the center of zooming and scl the scale factor to\n              zoom by.\n\n        direction : str\n            The direction to apply the bounding box.\n                * `'in'` - The bounding box describes the view directly, i.e.,\n                           it zooms in.\n                * `'out'` - The bounding box describes the size to make the\n                            existing view, i.e., it zooms out.\n\n        mode : str or None\n            The selection mode, whether to apply the bounding box in only the\n            `'x'` direction, `'y'` direction or both (`None`).\n\n        twinx : bool\n            Whether this axis is twinned in the *x*-direction.\n\n        twiny : bool\n            Whether this axis is twinned in the *y*-direction.\n        \"\"\"\n        Xmin, Xmax = self.get_xlim()\n        Ymin, Ymax = self.get_ylim()\n\n        if len(bbox) == 3:\n            # Zooming code\n            xp, yp, scl = bbox\n\n            # Should not happen\n            if scl == 0:\n                scl = 1.\n\n            # direction = 'in'\n            if scl > 1:\n                direction = 'in'\n            else:\n                direction = 'out'\n                scl = 1/scl\n\n            # get the limits of the axes\n            tranD2C = self.transData.transform\n            xmin, ymin = tranD2C((Xmin, Ymin))\n            xmax, ymax = tranD2C((Xmax, Ymax))\n\n            # set the range\n            xwidth = xmax - xmin\n            ywidth = ymax - ymin\n            xcen = (xmax + xmin)*.5\n            ycen = (ymax + ymin)*.5\n            xzc = (xp*(scl - 1) + xcen)/scl\n            yzc = (yp*(scl - 1) + ycen)/scl\n\n            bbox = [xzc - xwidth/2./scl, yzc - ywidth/2./scl,\n                    xzc + xwidth/2./scl, yzc + ywidth/2./scl]\n        elif len(bbox) != 4:\n            # should be len 3 or 4 but nothing else\n            cbook._warn_external(\n                \"Warning in _set_view_from_bbox: bounding box is not a tuple \"\n                \"of length 3 or 4. Ignoring the view change.\")\n            return\n\n        # Just grab bounding box\n        lastx, lasty, x, y = bbox\n\n        # zoom to rect\n        inverse = self.transData.inverted()\n        (lastx, lasty), (x, y) = inverse.transform([(lastx, lasty), (x, y)])\n\n        if twinx:\n            x0, x1 = Xmin, Xmax\n        else:\n            if Xmin < Xmax:\n                if x < lastx:\n                    x0, x1 = x, lastx\n                else:\n                    x0, x1 = lastx, x\n                if x0 < Xmin:\n                    x0 = Xmin\n                if x1 > Xmax:\n                    x1 = Xmax\n            else:\n                if x > lastx:\n                    x0, x1 = x, lastx\n                else:\n                    x0, x1 = lastx, x\n                if x0 > Xmin:\n                    x0 = Xmin\n                if x1 < Xmax:\n                    x1 = Xmax\n\n        if twiny:\n            y0, y1 = Ymin, Ymax\n        else:\n            if Ymin < Ymax:\n                if y < lasty:\n                    y0, y1 = y, lasty\n                else:\n                    y0, y1 = lasty, y\n                if y0 < Ymin:\n                    y0 = Ymin\n                if y1 > Ymax:\n                    y1 = Ymax\n            else:\n                if y > lasty:\n                    y0, y1 = y, lasty\n                else:\n                    y0, y1 = lasty, y\n                if y0 > Ymin:\n                    y0 = Ymin\n                if y1 < Ymax:\n                    y1 = Ymax\n\n        if direction == 'in':\n            if mode == 'x':\n                self.set_xlim((x0, x1))\n            elif mode == 'y':\n                self.set_ylim((y0, y1))\n            else:\n                self.set_xlim((x0, x1))\n                self.set_ylim((y0, y1))\n        elif direction == 'out':\n            if self.get_xscale() == 'log':\n                alpha = np.log(Xmax / Xmin) / np.log(x1 / x0)\n                rx1 = pow(Xmin / x0, alpha) * Xmin\n                rx2 = pow(Xmax / x0, alpha) * Xmin\n            else:\n                alpha = (Xmax - Xmin) / (x1 - x0)\n                rx1 = alpha * (Xmin - x0) + Xmin\n                rx2 = alpha * (Xmax - x0) + Xmin\n            if self.get_yscale() == 'log':\n                alpha = np.log(Ymax / Ymin) / np.log(y1 / y0)\n                ry1 = pow(Ymin / y0, alpha) * Ymin\n                ry2 = pow(Ymax / y0, alpha) * Ymin\n            else:\n                alpha = (Ymax - Ymin) / (y1 - y0)\n                ry1 = alpha * (Ymin - y0) + Ymin\n                ry2 = alpha * (Ymax - y0) + Ymin\n\n            if mode == 'x':\n                self.set_xlim((rx1, rx2))\n            elif mode == 'y':\n                self.set_ylim((ry1, ry2))\n            else:\n                self.set_xlim((rx1, rx2))\n                self.set_ylim((ry1, ry2))",
        "begin_line": 3927,
        "end_line": 4086,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_children#4198",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_children(self)",
        "snippet": "    def get_children(self):\n        # docstring inherited.\n        return [\n            *self.collections,\n            *self.patches,\n            *self.lines,\n            *self.texts,\n            *self.artists,\n            *self.spines.values(),\n            *self._get_axis_list(),\n            self.title, self._left_title, self._right_title,\n            *self.tables,\n            *self.images,\n            *self.child_axes,\n            *([self.legend_] if self.legend_ is not None else []),\n            self.patch,\n        ]",
        "begin_line": 4198,
        "end_line": 4214,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005621135469364812,
            "pseudo_dstar_susp": 0.00048567265662943174,
            "pseudo_tarantula_susp": 0.00031625553447185326,
            "pseudo_op2_susp": 0.00048567265662943174,
            "pseudo_barinel_susp": 0.00031625553447185326
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.contains_point#4223",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.contains_point(self, point)",
        "snippet": "    def contains_point(self, point):\n        \"\"\"\n        Return whether *point* (pair of pixel coordinates) is inside the axes\n        patch.\n        \"\"\"\n        return self.patch.contains_point(point, radius=1.0)",
        "begin_line": 4223,
        "end_line": 4228,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015992323684631377,
            "pseudo_dstar_susp": 0.0001593879502709595,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.0001593879502709595,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_default_bbox_extra_artists#4230",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_default_bbox_extra_artists(self)",
        "snippet": "    def get_default_bbox_extra_artists(self):\n        \"\"\"\n        Return a default list of artists that are used for the bounding box\n        calculation.\n\n        Artists are excluded either by not being visible or\n        ``artist.set_in_layout(False)``.\n        \"\"\"\n\n        artists = self.get_children()\n\n        if not (self.axison and self._frameon):\n            # don't do bbox on spines if frame not on.\n            for spine in self.spines.values():\n                artists.remove(spine)\n\n        if not self.axison:\n            for _axis in self._get_axis_list():\n                artists.remove(_axis)\n\n        return [artist for artist in artists\n                if (artist.get_visible() and artist.get_in_layout())]",
        "begin_line": 4230,
        "end_line": 4251,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00030609121518212427,
            "pseudo_dstar_susp": 0.0002821670428893905,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0002821670428893905,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_tightbbox#4253",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_tightbbox(self, renderer, call_axes_locator=True, bbox_extra_artists=None)",
        "snippet": "    def get_tightbbox(self, renderer, call_axes_locator=True,\n                      bbox_extra_artists=None):\n        \"\"\"\n        Return the tight bounding box of the axes, including axis and their\n        decorators (xlabel, title, etc).\n\n        Artists that have ``artist.set_in_layout(False)`` are not included\n        in the bbox.\n\n        Parameters\n        ----------\n        renderer : `.RendererBase` instance\n            renderer that will be used to draw the figures (i.e.\n            ``fig.canvas.get_renderer()``)\n\n        bbox_extra_artists : list of `.Artist` or ``None``\n            List of artists to include in the tight bounding box.  If\n            ``None`` (default), then all artist children of the axes are\n            included in the tight bounding box.\n\n        call_axes_locator : boolean (default ``True``)\n            If *call_axes_locator* is ``False``, it does not call the\n            ``_axes_locator`` attribute, which is necessary to get the correct\n            bounding box. ``call_axes_locator=False`` can be used if the\n            caller is only interested in the relative size of the tightbbox\n            compared to the axes bbox.\n\n        Returns\n        -------\n        bbox : `.BboxBase`\n            bounding box in figure pixel coordinates.\n\n        See Also\n        --------\n        matplotlib.axes.Axes.get_window_extent\n        matplotlib.axis.Axis.get_tightbbox\n        matplotlib.spines.Spine.get_window_extent\n\n        \"\"\"\n\n        bb = []\n\n        if not self.get_visible():\n            return None\n\n        locator = self.get_axes_locator()\n        if locator and call_axes_locator:\n            pos = locator(self, renderer)\n            self.apply_aspect(pos)\n        else:\n            self.apply_aspect()\n\n        if self.axison:\n            bb_xaxis = self.xaxis.get_tightbbox(renderer)\n            if bb_xaxis:\n                bb.append(bb_xaxis)\n\n            bb_yaxis = self.yaxis.get_tightbbox(renderer)\n            if bb_yaxis:\n                bb.append(bb_yaxis)\n\n        self._update_title_position(renderer)\n        axbbox = self.get_window_extent(renderer)\n        bb.append(axbbox)\n\n        self._update_title_position(renderer)\n        if self.title.get_visible():\n            bb.append(self.title.get_window_extent(renderer))\n        if self._left_title.get_visible():\n            bb.append(self._left_title.get_window_extent(renderer))\n        if self._right_title.get_visible():\n            bb.append(self._right_title.get_window_extent(renderer))\n\n        bb.append(self.get_window_extent(renderer))\n\n        bbox_artists = bbox_extra_artists\n        if bbox_artists is None:\n            bbox_artists = self.get_default_bbox_extra_artists()\n\n        for a in bbox_artists:\n            # Extra check here to quickly see if clipping is on and\n            # contained in the axes.  If it is, don't get the tightbbox for\n            # this artist because this can be expensive:\n            clip_extent = a._get_clipping_extent_bbox()\n            if clip_extent is not None:\n                clip_extent = mtransforms.Bbox.intersection(clip_extent,\n                    axbbox)\n                if np.all(clip_extent.extents == axbbox.extents):\n                    # clip extent is inside the axes bbox so don't check\n                    # this artist\n                    continue\n            bbox = a.get_tightbbox(renderer)\n            if (bbox is not None\n                    and 0 < bbox.width < np.inf\n                    and 0 < bbox.height < np.inf):\n                bb.append(bbox)\n        _bbox = mtransforms.Bbox.union(\n            [b for b in bb if b.width != 0 or b.height != 0])\n\n        return _bbox",
        "begin_line": 4253,
        "end_line": 4352,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003117206982543641,
            "pseudo_dstar_susp": 0.0002821670428893905,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0002821670428893905,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._make_twin_axes#4354",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._make_twin_axes(self, *args, **kwargs)",
        "snippet": "    def _make_twin_axes(self, *args, **kwargs):\n        \"\"\"Make a twinx axes of self. This is used for twinx and twiny.\"\"\"\n        # Typically, SubplotBase._make_twin_axes is called instead of this.\n        if 'sharex' in kwargs and 'sharey' in kwargs:\n            raise ValueError(\"Twinned Axes may share only one axis\")\n        ax2 = self.figure.add_axes(self.get_position(True), *args, **kwargs)\n        self.set_adjustable('datalim')\n        ax2.set_adjustable('datalim')\n        self._twinned_axes.join(self, ax2)\n        return ax2",
        "begin_line": 4354,
        "end_line": 4363,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.twinx#4365",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.twinx(self)",
        "snippet": "    def twinx(self):\n        \"\"\"\n        Create a twin Axes sharing the xaxis.\n\n        Create a new Axes with an invisible x-axis and an independent\n        y-axis positioned opposite to the original one (i.e. at right). The\n        x-axis autoscale setting will be inherited from the original\n        Axes.  To ensure that the tick marks of both y-axes align, see\n        `~matplotlib.ticker.LinearLocator`.\n\n        Returns\n        -------\n        ax_twin : Axes\n            The newly created Axes instance\n\n        Notes\n        -----\n        For those who are 'picking' artists while using twinx, pick\n        events are only called for the artists in the top-most axes.\n        \"\"\"\n        ax2 = self._make_twin_axes(sharex=self)\n        ax2.yaxis.tick_right()\n        ax2.yaxis.set_label_position('right')\n        ax2.yaxis.set_offset_position('right')\n        ax2.set_autoscalex_on(self.get_autoscalex_on())\n        self.yaxis.tick_left()\n        ax2.xaxis.set_visible(False)\n        ax2.patch.set_visible(False)\n        return ax2",
        "begin_line": 4365,
        "end_line": 4393,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015992323684631377,
            "pseudo_dstar_susp": 0.0001405086412814388,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.0001405086412814388,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.twiny#4395",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.twiny(self)",
        "snippet": "    def twiny(self):\n        \"\"\"\n        Create a twin Axes sharing the yaxis.\n\n        Create a new Axes with an invisible y-axis and an independent\n        x-axis positioned opposite to the original one (i.e. at top). The\n        y-axis autoscale setting will be inherited from the original Axes.\n        To ensure that the tick marks of both x-axes align, see\n        `~matplotlib.ticker.LinearLocator`.\n\n        Returns\n        -------\n        ax_twin : Axes\n            The newly created Axes instance\n\n        Notes\n        -----\n        For those who are 'picking' artists while using twiny, pick\n        events are only called for the artists in the top-most axes.\n        \"\"\"\n        ax2 = self._make_twin_axes(sharey=self)\n        ax2.xaxis.tick_top()\n        ax2.xaxis.set_label_position('top')\n        ax2.set_autoscaley_on(self.get_autoscaley_on())\n        self.xaxis.tick_bottom()\n        ax2.yaxis.set_visible(False)\n        ax2.patch.set_visible(False)\n        return ax2",
        "begin_line": 4395,
        "end_line": 4422,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00013564839934888768,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00013564839934888768,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_shared_x_axes#4424",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_shared_x_axes(self)",
        "snippet": "    def get_shared_x_axes(self):\n        \"\"\"Return a reference to the shared axes Grouper object for x axes.\"\"\"\n        return self._shared_x_axes",
        "begin_line": 4424,
        "end_line": 4426,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019665683382497542,
            "pseudo_dstar_susp": 0.00023073373327180433,
            "pseudo_tarantula_susp": 0.00018914318138831096,
            "pseudo_op2_susp": 0.00023073373327180433,
            "pseudo_barinel_susp": 0.00018914318138831096
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_shared_y_axes#4428",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_shared_y_axes(self)",
        "snippet": "    def get_shared_y_axes(self):\n        \"\"\"Return a reference to the shared axes Grouper object for y axes.\"\"\"\n        return self._shared_y_axes",
        "begin_line": 4428,
        "end_line": 4430,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000209819555182543,
            "pseudo_dstar_susp": 0.00024764735017335313,
            "pseudo_tarantula_susp": 0.000230361667818475,
            "pseudo_op2_susp": 0.00024764735017335313,
            "pseudo_barinel_susp": 0.000230361667818475
        }
    },
    {
        "name": "lib.matplotlib.pyplot.switch_backend#182",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.switch_backend(newbackend)",
        "snippet": "def switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The argument is case-insensitive.  Switching to an interactive backend is\n    possible only if no event loop for another interactive backend has started.\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to use.\n    \"\"\"\n    close(\"all\")\n\n    if newbackend is rcsetup._auto_backend_sentinel:\n        # Don't try to fallback on the cairo-based backends as they each have\n        # an additional dependency (pycairo) over the agg-based backend, and\n        # are of worse quality.\n        for candidate in [\n                \"macosx\", \"qt5agg\", \"qt4agg\", \"gtk3agg\", \"tkagg\", \"wxagg\"]:\n            try:\n                switch_backend(candidate)\n            except ImportError:\n                continue\n            else:\n                rcParamsOrig['backend'] = candidate\n                return\n        else:\n            # Switching to Agg should always succeed; if it doesn't, let the\n            # exception propagate out.\n            switch_backend(\"agg\")\n            rcParamsOrig[\"backend\"] = \"agg\"\n            return\n\n    backend_name = (\n        newbackend[9:] if newbackend.startswith(\"module://\")\n        else \"matplotlib.backends.backend_{}\".format(newbackend.lower()))\n\n    backend_mod = importlib.import_module(backend_name)\n    Backend = type(\n        \"Backend\", (matplotlib.backends._Backend,), vars(backend_mod))\n    _log.debug(\"Loaded backend %s version %s.\",\n               newbackend, Backend.backend_version)\n\n    required_framework = getattr(\n        Backend.FigureCanvas, \"required_interactive_framework\", None)\n    if required_framework is not None:\n        current_framework = \\\n            matplotlib.backends._get_running_interactive_framework()\n        if (current_framework and required_framework\n                and current_framework != required_framework):\n            raise ImportError(\n                \"Cannot load backend {!r} which requires the {!r} interactive \"\n                \"framework, as {!r} is currently running\".format(\n                    newbackend, required_framework, current_framework))\n\n    rcParams['backend'] = rcParamsDefault['backend'] = newbackend\n\n    global _backend_mod, new_figure_manager, draw_if_interactive, _show\n    _backend_mod = backend_mod\n    new_figure_manager = Backend.new_figure_manager\n    draw_if_interactive = Backend.draw_if_interactive\n    _show = Backend.show\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    matplotlib.backends.backend = newbackend",
        "begin_line": 182,
        "end_line": 249,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.pyplot.show#252",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.show(*args, **kw)",
        "snippet": "def show(*args, **kw):\n    \"\"\"\n    Display all figures.\n\n    When running in ipython with its pylab mode, display all\n    figures and return to the ipython prompt.\n\n    In non-interactive mode, display all figures and block until\n    the figures have been closed; in interactive mode it has no\n    effect unless figures were created prior to a change from\n    non-interactive to interactive mode (not recommended).  In\n    that case it displays the figures but does not block.\n\n    Parameters\n    ----------\n    block : bool, optional\n        This is experimental, and may be set to ``True`` or ``False`` to\n        override the blocking behavior described above.\n    \"\"\"\n    global _show\n    return _show(*args, **kw)",
        "begin_line": 252,
        "end_line": 272,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.pyplot.rc_context#324",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.rc_context(rc=None, fname=None)",
        "snippet": "def rc_context(rc=None, fname=None):\n    return matplotlib.rc_context(rc, fname)",
        "begin_line": 324,
        "end_line": 325,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.pyplot.xkcd#366",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.xkcd(scale=1, length=100, randomness=2)",
        "snippet": "def xkcd(scale=1, length=100, randomness=2):\n    \"\"\"\n    Turn on `xkcd <https://xkcd.com/>`_ sketch-style drawing mode.\n    This will only have effect on things drawn after this function is\n    called.\n\n    For best results, the \"Humor Sans\" font should be installed: it is\n    not included with matplotlib.\n\n    Parameters\n    ----------\n    scale : float, optional\n        The amplitude of the wiggle perpendicular to the source line.\n    length : float, optional\n        The length of the wiggle along the line.\n    randomness : float, optional\n        The scale factor by which the length is shrunken or expanded.\n\n    Notes\n    -----\n    This function works by a number of rcParams, so it will probably\n    override others you have set before.\n\n    If you want the effects of this function to be temporary, it can\n    be used as a context manager, for example::\n\n        with plt.xkcd():\n            # This figure will be in XKCD-style\n            fig1 = plt.figure()\n            # ...\n\n        # This figure will be in regular style\n        fig2 = plt.figure()\n    \"\"\"\n    if rcParams['text.usetex']:\n        raise RuntimeError(\n            \"xkcd mode is not compatible with text.usetex = True\")\n\n    from matplotlib import patheffects\n    return rc_context({\n        'font.family': ['xkcd', 'xkcd Script', 'Humor Sans', 'Comic Neue',\n                        'Comic Sans MS'],\n        'font.size': 14.0,\n        'path.sketch': (scale, length, randomness),\n        'path.effects': [patheffects.withStroke(linewidth=4, foreground=\"w\")],\n        'axes.linewidth': 1.5,\n        'lines.linewidth': 2.0,\n        'figure.facecolor': 'white',\n        'grid.linewidth': 0.0,\n        'axes.grid': False,\n        'axes.unicode_minus': False,\n        'axes.edgecolor': 'black',\n        'xtick.major.size': 8,\n        'xtick.major.width': 3,\n        'ytick.major.size': 8,\n        'ytick.major.width': 3,\n    })",
        "begin_line": 366,
        "end_line": 422,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.pyplot.figure#427",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.figure(num=None, figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True, FigureClass=Figure, clear=False, **kwargs)",
        "snippet": "def figure(num=None,  # autoincrement if None, else integer from 1-N\n           figsize=None,  # defaults to rc figure.figsize\n           dpi=None,  # defaults to rc figure.dpi\n           facecolor=None,  # defaults to rc figure.facecolor\n           edgecolor=None,  # defaults to rc figure.edgecolor\n           frameon=True,\n           FigureClass=Figure,\n           clear=False,\n           **kwargs\n           ):\n    \"\"\"\n    Create a new figure.\n\n    Parameters\n    ----------\n    num : int or str, optional, default: None\n        If not provided, a new figure will be created, and the figure number\n        will be incremented. The figure objects holds this number in a `number`\n        attribute.\n        If num is provided, and a figure with this id already exists, make\n        it active, and returns a reference to it. If this figure does not\n        exists, create it and returns it.\n        If num is a string, the window title will be set to this figure's\n        *num*.\n\n    figsize : (float, float), optional, default: None\n        width, height in inches. If not provided, defaults to\n        :rc:`figure.figsize` = ``[6.4, 4.8]``.\n\n    dpi : integer, optional, default: None\n        resolution of the figure. If not provided, defaults to\n        :rc:`figure.dpi` = ``100``.\n\n    facecolor : color\n        the background color. If not provided, defaults to\n        :rc:`figure.facecolor` = ``'w'``.\n\n    edgecolor : color\n        the border color. If not provided, defaults to\n        :rc:`figure.edgecolor` = ``'w'``.\n\n    frameon : bool, optional, default: True\n        If False, suppress drawing the figure frame.\n\n    FigureClass : subclass of `~matplotlib.figure.Figure`\n        Optionally use a custom `.Figure` instance.\n\n    clear : bool, optional, default: False\n        If True and the figure already exists, then it is cleared.\n\n    Returns\n    -------\n    figure : `~matplotlib.figure.Figure`\n        The `.Figure` instance returned will also be passed to\n        new_figure_manager in the backends, which allows to hook custom\n        `.Figure` classes into the pyplot interface. Additional kwargs will be\n        passed to the `.Figure` init function.\n\n    Notes\n    -----\n    If you are creating many figures, make sure you explicitly call\n    `.pyplot.close` on the figures you are not using, because this will\n    enable pyplot to properly clean up the memory.\n\n    `~matplotlib.rcParams` defines the default values, which can be modified\n    in the matplotlibrc file.\n    \"\"\"\n\n    if figsize is None:\n        figsize = rcParams['figure.figsize']\n    if dpi is None:\n        dpi = rcParams['figure.dpi']\n    if facecolor is None:\n        facecolor = rcParams['figure.facecolor']\n    if edgecolor is None:\n        edgecolor = rcParams['figure.edgecolor']\n\n    allnums = get_fignums()\n    next_num = max(allnums) + 1 if allnums else 1\n    figLabel = ''\n    if num is None:\n        num = next_num\n    elif isinstance(num, str):\n        figLabel = num\n        allLabels = get_figlabels()\n        if figLabel not in allLabels:\n            if figLabel == 'all':\n                cbook._warn_external(\n                    \"close('all') closes all existing figures\")\n            num = next_num\n        else:\n            inum = allLabels.index(figLabel)\n            num = allnums[inum]\n    else:\n        num = int(num)  # crude validation of num argument\n\n    figManager = _pylab_helpers.Gcf.get_fig_manager(num)\n    if figManager is None:\n        max_open_warning = rcParams['figure.max_open_warning']\n\n        if len(allnums) >= max_open_warning >= 1:\n            cbook._warn_external(\n                \"More than %d figures have been opened. Figures \"\n                \"created through the pyplot interface \"\n                \"(`matplotlib.pyplot.figure`) are retained until \"\n                \"explicitly closed and may consume too much memory. \"\n                \"(To control this warning, see the rcParam \"\n                \"`figure.max_open_warning`).\" %\n                max_open_warning, RuntimeWarning)\n\n        if get_backend().lower() == 'ps':\n            dpi = 72\n\n        figManager = new_figure_manager(num, figsize=figsize,\n                                        dpi=dpi,\n                                        facecolor=facecolor,\n                                        edgecolor=edgecolor,\n                                        frameon=frameon,\n                                        FigureClass=FigureClass,\n                                        **kwargs)\n\n        if figLabel:\n            figManager.set_window_title(figLabel)\n            figManager.canvas.figure.set_label(figLabel)\n\n        # make this figure current on button press event\n        def make_active(event):\n            _pylab_helpers.Gcf.set_active(figManager)\n\n        cid = figManager.canvas.mpl_connect('button_press_event', make_active)\n        figManager._cidgcf = cid\n\n        _pylab_helpers.Gcf.set_active(figManager)\n        fig = figManager.canvas.figure\n        fig.number = num\n\n        # make sure backends (inline) that we don't ship that expect this\n        # to be called in plotting commands to make the figure call show\n        # still work.  There is probably a better way to do this in the\n        # FigureManager base class.\n        if matplotlib.is_interactive():\n            draw_if_interactive()\n\n        if _INSTALL_FIG_OBSERVER:\n            fig.stale_callback = _auto_draw_if_interactive\n\n    if clear:\n        figManager.canvas.figure.clear()\n\n    return figManager.canvas.figure",
        "begin_line": 427,
        "end_line": 576,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0027472527472527475,
            "pseudo_dstar_susp": 0.0036900369003690036,
            "pseudo_tarantula_susp": 0.0005512679162072767,
            "pseudo_op2_susp": 0.0036900369003690036,
            "pseudo_barinel_susp": 0.0005512679162072767
        }
    },
    {
        "name": "lib.matplotlib.pyplot.make_active#553",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.make_active(event)",
        "snippet": "        def make_active(event):\n            _pylab_helpers.Gcf.set_active(figManager)",
        "begin_line": 553,
        "end_line": 554,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012998830105290525,
            "pseudo_dstar_susp": 0.00015620118712902218,
            "pseudo_tarantula_susp": 0.00012236906510034264,
            "pseudo_op2_susp": 0.00015620118712902218,
            "pseudo_barinel_susp": 0.00012232415902140674
        }
    },
    {
        "name": "lib.matplotlib.pyplot._auto_draw_if_interactive#579",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot._auto_draw_if_interactive(fig, val)",
        "snippet": "def _auto_draw_if_interactive(fig, val):\n    \"\"\"\n    This is an internal helper function for making sure that auto-redrawing\n    works as intended in the plain python repl.\n\n    Parameters\n    ----------\n    fig : Figure\n        A figure object which is assumed to be associated with a canvas\n    \"\"\"\n    if val and matplotlib.is_interactive() and not fig.canvas.is_saving():\n        fig.canvas.draw_idle()",
        "begin_line": 579,
        "end_line": 590,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00015775358889414735,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00015775358889414735,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.pyplot.gcf#593",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.gcf()",
        "snippet": "def gcf():\n    \"\"\"\n    Get the current figure.\n\n    If no current figure exists, a new one is created using\n    `~.pyplot.figure()`.\n    \"\"\"\n    figManager = _pylab_helpers.Gcf.get_active()\n    if figManager is not None:\n        return figManager.canvas.figure\n    else:\n        return figure()",
        "begin_line": 593,
        "end_line": 604,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016714023065351831,
            "pseudo_dstar_susp": 0.00019508388607101054,
            "pseudo_tarantula_susp": 0.0001595150741745095,
            "pseudo_op2_susp": 0.00019508388607101054,
            "pseudo_barinel_susp": 0.0001595150741745095
        }
    },
    {
        "name": "lib.matplotlib.pyplot.get_fignums#612",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.get_fignums()",
        "snippet": "def get_fignums():\n    \"\"\"Return a list of existing figure numbers.\"\"\"\n    return sorted(_pylab_helpers.Gcf.figs)",
        "begin_line": 612,
        "end_line": 614,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015992323684631377,
            "pseudo_dstar_susp": 0.0001405086412814388,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.0001405086412814388,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.pyplot.get_figlabels#617",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.get_figlabels()",
        "snippet": "def get_figlabels():\n    \"\"\"Return a list of existing figure labels.\"\"\"\n    figManagers = _pylab_helpers.Gcf.get_all_fig_managers()\n    figManagers.sort(key=lambda m: m.num)\n    return [m.canvas.figure.get_label() for m in figManagers]",
        "begin_line": 617,
        "end_line": 621,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011604966925844261,
            "pseudo_dstar_susp": 0.0001147710317915758,
            "pseudo_tarantula_susp": 0.00012055455093429777,
            "pseudo_op2_susp": 0.0001147710317915758,
            "pseudo_barinel_susp": 0.00012055455093429777
        }
    },
    {
        "name": "lib.matplotlib.pyplot.close#651",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.close(fig=None)",
        "snippet": "def close(fig=None):\n    \"\"\"\n    Close a figure window.\n\n    Parameters\n    ----------\n    fig : None or int or str or `.Figure`\n        The figure to close. There are a number of ways to specify this:\n\n        - *None*: the current figure\n        - `.Figure`: the given `.Figure` instance\n        - ``int``: a figure number\n        - ``str``: a figure name\n        - 'all': all figures\n\n    \"\"\"\n    if fig is None:\n        figManager = _pylab_helpers.Gcf.get_active()\n        if figManager is None:\n            return\n        else:\n            _pylab_helpers.Gcf.destroy(figManager.num)\n    elif fig == 'all':\n        _pylab_helpers.Gcf.destroy_all()\n    elif isinstance(fig, int):\n        _pylab_helpers.Gcf.destroy(fig)\n    elif hasattr(fig, 'int'):\n        # if we are dealing with a type UUID, we\n        # can use its integer representation\n        _pylab_helpers.Gcf.destroy(fig.int)\n    elif isinstance(fig, str):\n        allLabels = get_figlabels()\n        if fig in allLabels:\n            num = get_fignums()[allLabels.index(fig)]\n            _pylab_helpers.Gcf.destroy(num)\n    elif isinstance(fig, Figure):\n        _pylab_helpers.Gcf.destroy_fig(fig)\n    else:\n        raise TypeError(\"close() argument must be a Figure, an int, a string, \"\n                        \"or None, not '%s'\")",
        "begin_line": 651,
        "end_line": 690,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001165365342034728,
            "pseudo_dstar_susp": 0.00017596339961288053,
            "pseudo_tarantula_susp": 0.00012236906510034264,
            "pseudo_op2_susp": 0.00017596339961288053,
            "pseudo_barinel_susp": 0.00012232415902140674
        }
    },
    {
        "name": "lib.matplotlib.pyplot.draw#698",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.draw()",
        "snippet": "def draw():\n    \"\"\"\n    Redraw the current figure.\n\n    This is used to update a figure that has been altered, but not\n    automatically re-drawn.  If interactive mode is on (via `.ion()`), this\n    should be only rarely needed, but there may be ways to modify the state of\n    a figure without marking it as \"stale\".  Please report these cases as bugs.\n\n    This is equivalent to calling ``fig.canvas.draw_idle()``, where ``fig`` is\n    the current figure.\n    \"\"\"\n    gcf().canvas.draw_idle()",
        "begin_line": 698,
        "end_line": 710,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.pyplot.subplot#878",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.subplot(*args, **kwargs)",
        "snippet": "def subplot(*args, **kwargs):\n    \"\"\"\n    Add a subplot to the current figure.\n\n    Wrapper of `.Figure.add_subplot` with a difference in behavior\n    explained in the notes section.\n\n    Call signatures::\n\n       subplot(nrows, ncols, index, **kwargs)\n       subplot(pos, **kwargs)\n       subplot(ax)\n\n    Parameters\n    ----------\n    *args\n        Either a 3-digit integer or three separate integers\n        describing the position of the subplot. If the three\n        integers are *nrows*, *ncols*, and *index* in order, the\n        subplot will take the *index* position on a grid with *nrows*\n        rows and *ncols* columns. *index* starts at 1 in the upper left\n        corner and increases to the right.\n\n        *pos* is a three digit integer, where the first digit is the\n        number of rows, the second the number of columns, and the third\n        the index of the subplot. i.e. fig.add_subplot(235) is the same as\n        fig.add_subplot(2, 3, 5). Note that all integers must be less than\n        10 for this form to work.\n\n    projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n'polar', 'rectilinear', str}, optional\n        The projection type of the subplot (`~.axes.Axes`). *str* is the name\n        of a custom projection, see `~matplotlib.projections`. The default\n        None results in a 'rectilinear' projection.\n\n    polar : boolean, optional\n        If True, equivalent to projection='polar'.\n\n    sharex, sharey : `~.axes.Axes`, optional\n        Share the x or y `~matplotlib.axis` with sharex and/or sharey. The\n        axis will have the same limits, ticks, and scale as the axis of the\n        shared axes.\n\n    label : str\n        A label for the returned axes.\n\n    Other Parameters\n    ----------------\n    **kwargs\n        This method also takes the keyword arguments for the returned axes\n        base class; except for the *figure* argument. The keyword arguments\n        for the rectilinear base class `~.axes.Axes` can be found in\n        the following table but there might also be other keyword\n        arguments if another projection is used.\n\n        %(Axes)s\n\n    Returns\n    -------\n    axes : an `.axes.SubplotBase` subclass of `~.axes.Axes` (or a subclass \\\n    of `~.axes.Axes`)\n\n        The axes of the subplot. The returned axes base class depends on\n        the projection used. It is `~.axes.Axes` if rectilinear projection\n        are used and `.projections.polar.PolarAxes` if polar projection\n        are used. The returned axes is then a subplot subclass of the\n        base class.\n\n    Notes\n    -----\n    Creating a subplot will delete any pre-existing subplot that overlaps\n    with it beyond sharing a boundary::\n\n        import matplotlib.pyplot as plt\n        # plot a line, implicitly creating a subplot(111)\n        plt.plot([1, 2, 3])\n        # now create a subplot which represents the top plot of a grid\n        # with 2 rows and 1 column. Since this subplot will overlap the\n        # first, the plot (and its axes) previously created, will be removed\n        plt.subplot(211)\n\n    If you do not want this behavior, use the `.Figure.add_subplot` method\n    or the `.pyplot.axes` function instead.\n\n    If the figure already has a subplot with key (*args*,\n    *kwargs*) then it will simply make that subplot current and\n    return it.  This behavior is deprecated. Meanwhile, if you do\n    not want this behavior (i.e., you want to force the creation of a\n    new subplot), you must use a unique set of args and kwargs.  The axes\n    *label* attribute has been exposed for this purpose: if you want\n    two subplots that are otherwise identical to be added to the figure,\n    make sure you give them unique labels.\n\n    In rare circumstances, `.add_subplot` may be called with a single\n    argument, a subplot axes instance already created in the\n    present figure but not in the figure's list of axes.\n\n    See Also\n    --------\n    .Figure.add_subplot\n    .pyplot.subplots\n    .pyplot.axes\n    .Figure.subplots\n\n    Examples\n    --------\n    ::\n\n        plt.subplot(221)\n\n        # equivalent but more general\n        ax1=plt.subplot(2, 2, 1)\n\n        # add a subplot with no frame\n        ax2=plt.subplot(222, frameon=False)\n\n        # add a polar subplot\n        plt.subplot(223, projection='polar')\n\n        # add a red subplot that shares the x-axis with ax1\n        plt.subplot(224, sharex=ax1, facecolor='red')\n\n        # delete ax2 from the figure\n        plt.delaxes(ax2)\n\n        # add ax2 to the figure again\n        plt.subplot(ax2)\n    \"\"\"\n\n    # if subplot called without arguments, create subplot(1, 1, 1)\n    if len(args) == 0:\n        args = (1, 1, 1)\n\n    # This check was added because it is very easy to type\n    # subplot(1, 2, False) when subplots(1, 2, False) was intended\n    # (sharex=False, that is). In most cases, no error will\n    # ever occur, but mysterious behavior can result because what was\n    # intended to be the sharex argument is instead treated as a\n    # subplot index for subplot()\n    if len(args) >= 3 and isinstance(args[2], bool):\n        cbook._warn_external(\"The subplot index argument to subplot() appears \"\n                             \"to be a boolean. Did you intend to use \"\n                             \"subplots()?\")\n\n    fig = gcf()\n    a = fig.add_subplot(*args, **kwargs)\n    bbox = a.bbox\n    byebye = []\n    for other in fig.axes:\n        if other == a:\n            continue\n        if bbox.fully_overlaps(other.bbox):\n            byebye.append(other)\n    for ax in byebye:\n        delaxes(ax)\n\n    return a",
        "begin_line": 878,
        "end_line": 1034,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021312872975277067,
            "pseudo_dstar_susp": 0.00021593608291945585,
            "pseudo_tarantula_susp": 0.0002203128442388191,
            "pseudo_op2_susp": 0.00021593608291945585,
            "pseudo_barinel_susp": 0.0002203128442388191
        }
    },
    {
        "name": "lib.matplotlib.pyplot.subplots#1037",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.subplots(nrows=1, ncols=1, sharex=False, sharey=False, squeeze=True, subplot_kw=None, gridspec_kw=None, **fig_kw)",
        "snippet": "def subplots(nrows=1, ncols=1, sharex=False, sharey=False, squeeze=True,\n             subplot_kw=None, gridspec_kw=None, **fig_kw):\n    \"\"\"\n    Create a figure and a set of subplots.\n\n    This utility wrapper makes it convenient to create common layouts of\n    subplots, including the enclosing figure object, in a single call.\n\n    Parameters\n    ----------\n    nrows, ncols : int, optional, default: 1\n        Number of rows/columns of the subplot grid.\n\n    sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False\n        Controls sharing of properties among x (`sharex`) or y (`sharey`)\n        axes:\n\n        - True or 'all': x- or y-axis will be shared among all subplots.\n        - False or 'none': each subplot x- or y-axis will be independent.\n        - 'row': each subplot row will share an x- or y-axis.\n        - 'col': each subplot column will share an x- or y-axis.\n\n        When subplots have a shared x-axis along a column, only the x tick\n        labels of the bottom subplot are created. Similarly, when subplots\n        have a shared y-axis along a row, only the y tick labels of the first\n        column subplot are created. To later turn other subplots' ticklabels\n        on, use `~matplotlib.axes.Axes.tick_params`.\n\n    squeeze : bool, optional, default: True\n        - If True, extra dimensions are squeezed out from the returned\n          array of `~matplotlib.axes.Axes`:\n\n          - if only one subplot is constructed (nrows=ncols=1), the\n            resulting single Axes object is returned as a scalar.\n          - for Nx1 or 1xM subplots, the returned object is a 1D numpy\n            object array of Axes objects.\n          - for NxM, subplots with N>1 and M>1 are returned as a 2D array.\n\n        - If False, no squeezing at all is done: the returned Axes object is\n          always a 2D array containing Axes instances, even if it ends up\n          being 1x1.\n\n    num : int or str, optional, default: None\n        A `.pyplot.figure` keyword that sets the figure number or label.\n\n    subplot_kw : dict, optional\n        Dict with keywords passed to the\n        `~matplotlib.figure.Figure.add_subplot` call used to create each\n        subplot.\n\n    gridspec_kw : dict, optional\n        Dict with keywords passed to the `~matplotlib.gridspec.GridSpec`\n        constructor used to create the grid the subplots are placed on.\n\n    **fig_kw\n        All additional keyword arguments are passed to the\n        `.pyplot.figure` call.\n\n    Returns\n    -------\n    fig : `~.figure.Figure`\n\n    ax : `.axes.Axes` object or array of Axes objects.\n        *ax* can be either a single `~matplotlib.axes.Axes` object or an\n        array of Axes objects if more than one subplot was created.  The\n        dimensions of the resulting array can be controlled with the squeeze\n        keyword, see above.\n\n        Typical idioms for handling the return value are::\n\n            # using the variable ax for single a Axes\n            fig, ax = plt.subplots()\n\n            # using the variable axs for multiple Axes\n            fig, axs = plt.subplots(2, 2)\n\n            # using tuple unpacking for multiple Axes\n            fig, (ax1, ax2) = plt.subplot(1, 2)\n            fig, ((ax1, ax2), (ax3, ax4)) = plt.subplot(2, 2)\n\n        The names ``ax`` and pluralized ``axs`` are preferred over ``axes``\n        because for the latter it's not clear if it refers to a single\n        `~.axes.Axes` instance or a collection of these.\n\n    Examples\n    --------\n    ::\n\n        # First create some toy data:\n        x = np.linspace(0, 2*np.pi, 400)\n        y = np.sin(x**2)\n\n        # Create just a figure and only one subplot\n        fig, ax = plt.subplots()\n        ax.plot(x, y)\n        ax.set_title('Simple plot')\n\n        # Create two subplots and unpack the output array immediately\n        f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)\n        ax1.plot(x, y)\n        ax1.set_title('Sharing Y axis')\n        ax2.scatter(x, y)\n\n        # Create four polar axes and access them through the returned array\n        fig, axs = plt.subplots(2, 2, subplot_kw=dict(polar=True))\n        axs[0, 0].plot(x, y)\n        axs[1, 1].scatter(x, y)\n\n        # Share a X axis with each column of subplots\n        plt.subplots(2, 2, sharex='col')\n\n        # Share a Y axis with each row of subplots\n        plt.subplots(2, 2, sharey='row')\n\n        # Share both X and Y axes with all subplots\n        plt.subplots(2, 2, sharex='all', sharey='all')\n\n        # Note that this is the same as\n        plt.subplots(2, 2, sharex=True, sharey=True)\n\n        # Create figure number 10 with a single subplot\n        # and clears it if it already exists.\n        fig, ax = plt.subplots(num=10, clear=True)\n\n    See Also\n    --------\n    .pyplot.figure\n    .pyplot.subplot\n    .pyplot.axes\n    .Figure.subplots\n    .Figure.add_subplot\n\n    \"\"\"\n    fig = figure(**fig_kw)\n    axs = fig.subplots(nrows=nrows, ncols=ncols, sharex=sharex, sharey=sharey,\n                       squeeze=squeeze, subplot_kw=subplot_kw,\n                       gridspec_kw=gridspec_kw)\n    return fig, axs",
        "begin_line": 1037,
        "end_line": 1174,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00025608194622279127,
            "pseudo_dstar_susp": 0.0003333333333333333,
            "pseudo_tarantula_susp": 0.00013092432573972245,
            "pseudo_op2_susp": 0.0003333333333333333,
            "pseudo_barinel_susp": 0.00013092432573972245
        }
    },
    {
        "name": "lib.matplotlib.pyplot.subplot2grid#1177",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.subplot2grid(shape, loc, rowspan=1, colspan=1, fig=None, **kwargs)",
        "snippet": "def subplot2grid(shape, loc, rowspan=1, colspan=1, fig=None, **kwargs):\n    \"\"\"\n    Create an axis at specific location inside a regular grid.\n\n    Parameters\n    ----------\n    shape : sequence of 2 ints\n        Shape of grid in which to place axis.\n        First entry is number of rows, second entry is number of columns.\n\n    loc : sequence of 2 ints\n        Location to place axis within grid.\n        First entry is row number, second entry is column number.\n\n    rowspan : int\n        Number of rows for the axis to span to the right.\n\n    colspan : int\n        Number of columns for the axis to span downwards.\n\n    fig : `Figure`, optional\n        Figure to place axis in. Defaults to current figure.\n\n    **kwargs\n        Additional keyword arguments are handed to `add_subplot`.\n\n\n    Notes\n    -----\n    The following call ::\n\n        subplot2grid(shape, loc, rowspan=1, colspan=1)\n\n    is identical to ::\n\n        gridspec=GridSpec(shape[0], shape[1])\n        subplotspec=gridspec.new_subplotspec(loc, rowspan, colspan)\n        subplot(subplotspec)\n    \"\"\"\n\n    if fig is None:\n        fig = gcf()\n\n    s1, s2 = shape\n    subplotspec = GridSpec(s1, s2).new_subplotspec(loc,\n                                                   rowspan=rowspan,\n                                                   colspan=colspan)\n    a = fig.add_subplot(subplotspec, **kwargs)\n    bbox = a.bbox\n    byebye = []\n    for other in fig.axes:\n        if other == a:\n            continue\n        if bbox.fully_overlaps(other.bbox):\n            byebye.append(other)\n    for ax in byebye:\n        delaxes(ax)\n\n    return a",
        "begin_line": 1177,
        "end_line": 1235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.pyplot.subplots_adjust#1270",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=None, hspace=None)",
        "snippet": "def subplots_adjust(left=None, bottom=None, right=None, top=None,\n                    wspace=None, hspace=None):\n    \"\"\"\n    Tune the subplot layout.\n\n    The parameter meanings (and suggested defaults) are::\n\n      left = 0.125  # the left side of the subplots of the figure\n      right = 0.9   # the right side of the subplots of the figure\n      bottom = 0.1  # the bottom of the subplots of the figure\n      top = 0.9     # the top of the subplots of the figure\n      wspace = 0.2  # the amount of width reserved for space between subplots,\n                    # expressed as a fraction of the average axis width\n      hspace = 0.2  # the amount of height reserved for space between subplots,\n                    # expressed as a fraction of the average axis height\n\n    The actual defaults are controlled by the rc file\n    \"\"\"\n    fig = gcf()\n    fig.subplots_adjust(left, bottom, right, top, wspace, hspace)",
        "begin_line": 1270,
        "end_line": 1289,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012717792191275595,
            "pseudo_dstar_susp": 0.0001210800339024095,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.0001210800339024095,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.pyplot.tight_layout#1313",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.tight_layout(pad=1.08, h_pad=None, w_pad=None, rect=None)",
        "snippet": "def tight_layout(pad=1.08, h_pad=None, w_pad=None, rect=None):\n    \"\"\"\n    Automatically adjust subplot parameters to give specified padding.\n\n    Parameters\n    ----------\n    pad : float\n        Padding between the figure edge and the edges of subplots,\n        as a fraction of the font size.\n    h_pad, w_pad : float, optional\n        Padding (height/width) between edges of adjacent subplots,\n        as a fraction of the font size.  Defaults to *pad*.\n    rect : tuple (left, bottom, right, top), optional\n        A rectangle (left, bottom, right, top) in the normalized\n        figure coordinate that the whole subplots area (including\n        labels) will fit into. Default is (0, 0, 1, 1).\n    \"\"\"\n    gcf().tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)",
        "begin_line": 1313,
        "end_line": 1330,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002257336343115124,
            "pseudo_dstar_susp": 0.00019661816751867872,
            "pseudo_tarantula_susp": 0.00037750094375235937,
            "pseudo_op2_susp": 0.00019661816751867872,
            "pseudo_barinel_susp": 0.00037750094375235937
        }
    },
    {
        "name": "lib.matplotlib.pyplot.box#1333",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.box(on=None)",
        "snippet": "def box(on=None):\n    \"\"\"\n    Turn the axes box on or off on the current axes.\n\n    Parameters\n    ----------\n    on : bool or None\n        The new `~matplotlib.axes.Axes` box state. If ``None``, toggle\n        the state.\n\n    See Also\n    --------\n    :meth:`matplotlib.axes.Axes.set_frame_on`\n    :meth:`matplotlib.axes.Axes.get_frame_on`\n    \"\"\"\n    ax = gca()\n    if on is None:\n        on = not ax.get_frame_on()\n    ax.set_frame_on(on)",
        "begin_line": 1333,
        "end_line": 1351,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.pyplot.xlim#1356",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.xlim(*args, **kwargs)",
        "snippet": "def xlim(*args, **kwargs):\n    \"\"\"\n    Get or set the x limits of the current axes.\n\n    Call signatures::\n\n        left, right = xlim()  # return the current xlim\n        xlim((left, right))   # set the xlim to left, right\n        xlim(left, right)     # set the xlim to left, right\n\n    If you do not specify args, you can pass *left* or *right* as kwargs,\n    i.e.::\n\n        xlim(right=3)  # adjust the right leaving left unchanged\n        xlim(left=1)  # adjust the left leaving right unchanged\n\n    Setting limits turns autoscaling off for the x-axis.\n\n    Returns\n    -------\n    left, right\n        A tuple of the new x-axis limits.\n\n    Notes\n    -----\n    Calling this function with no arguments (e.g. ``xlim()``) is the pyplot\n    equivalent of calling `~.Axes.get_xlim` on the current axes.\n    Calling this function with arguments is the pyplot equivalent of calling\n    `~.Axes.set_xlim` on the current axes. All arguments are passed though.\n    \"\"\"\n    ax = gca()\n    if not args and not kwargs:\n        return ax.get_xlim()\n    ret = ax.set_xlim(*args, **kwargs)\n    return ret",
        "begin_line": 1356,
        "end_line": 1390,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.pyplot.ylim#1393",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.ylim(*args, **kwargs)",
        "snippet": "def ylim(*args, **kwargs):\n    \"\"\"\n    Get or set the y-limits of the current axes.\n\n    Call signatures::\n\n        bottom, top = ylim()  # return the current ylim\n        ylim((bottom, top))   # set the ylim to bottom, top\n        ylim(bottom, top)     # set the ylim to bottom, top\n\n    If you do not specify args, you can alternatively pass *bottom* or\n    *top* as kwargs, i.e.::\n\n        ylim(top=3)  # adjust the top leaving bottom unchanged\n        ylim(bottom=1)  # adjust the bottom leaving top unchanged\n\n    Setting limits turns autoscaling off for the y-axis.\n\n    Returns\n    -------\n    bottom, top\n        A tuple of the new y-axis limits.\n\n    Notes\n    -----\n    Calling this function with no arguments (e.g. ``ylim()``) is the pyplot\n    equivalent of calling `~.Axes.get_ylim` on the current axes.\n    Calling this function with arguments is the pyplot equivalent of calling\n    `~.Axes.set_ylim` on the current axes. All arguments are passed though.\n    \"\"\"\n    ax = gca()\n    if not args and not kwargs:\n        return ax.get_ylim()\n    ret = ax.set_ylim(*args, **kwargs)\n    return ret",
        "begin_line": 1393,
        "end_line": 1427,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.pyplot.xticks#1430",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.xticks(ticks=None, labels=None, **kwargs)",
        "snippet": "def xticks(ticks=None, labels=None, **kwargs):\n    \"\"\"\n    Get or set the current tick locations and labels of the x-axis.\n\n    Pass no arguments to return the current values without modifying them.\n\n    Parameters\n    ----------\n    ticks : array-like, optional\n        The list of xtick locations.  Passing an empty list removes all xticks.\n    labels : array-like, optional\n        The labels to place at the given *ticks* locations.  This argument can\n        only be passed if *ticks* is passed as well.\n    **kwargs\n        `.Text` properties can be used to control the appearance of the labels.\n\n    Returns\n    -------\n    locs\n        The list of xtick locations.\n    labels\n        The list of xlabel `.Text` objects.\n\n    Notes\n    -----\n    Calling this function with no arguments (e.g. ``xticks()``) is the pyplot\n    equivalent of calling `~.Axes.get_xticks` and `~.Axes.get_xticklabels` on\n    the current axes.\n    Calling this function with arguments is the pyplot equivalent of calling\n    `~.Axes.set_xticks` and `~.Axes.set_xticklabels` on the current axes.\n\n    Examples\n    --------\n    >>> locs, labels = xticks()  # Get the current locations and labels.\n    >>> xticks(np.arange(0, 1, step=0.2))  # Set label locations.\n    >>> xticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.\n    >>> xticks([0, 1, 2], ['January', 'February', 'March'],\n    ...        rotation=20)  # Set text labels and properties.\n    >>> xticks([])  # Disable xticks.\n    \"\"\"\n    ax = gca()\n\n    if ticks is None and labels is None:\n        locs = ax.get_xticks()\n        labels = ax.get_xticklabels()\n    elif labels is None:\n        locs = ax.set_xticks(ticks)\n        labels = ax.get_xticklabels()\n    else:\n        locs = ax.set_xticks(ticks)\n        labels = ax.set_xticklabels(labels, **kwargs)\n    for l in labels:\n        l.update(kwargs)\n\n    return locs, labels",
        "begin_line": 1430,
        "end_line": 1484,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.pyplot.yticks#1487",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.yticks(ticks=None, labels=None, **kwargs)",
        "snippet": "def yticks(ticks=None, labels=None, **kwargs):\n    \"\"\"\n    Get or set the current tick locations and labels of the y-axis.\n\n    Pass no arguments to return the current values without modifying them.\n\n    Parameters\n    ----------\n    ticks : array-like, optional\n        The list of xtick locations.  Passing an empty list removes all xticks.\n    labels : array-like, optional\n        The labels to place at the given *ticks* locations.  This argument can\n        only be passed if *ticks* is passed as well.\n    **kwargs\n        `.Text` properties can be used to control the appearance of the labels.\n\n    Returns\n    -------\n    locs\n        The list of ytick locations.\n    labels\n        The list of ylabel `.Text` objects.\n\n    Notes\n    -----\n    Calling this function with no arguments (e.g. ``yticks()``) is the pyplot\n    equivalent of calling `~.Axes.get_yticks` and `~.Axes.get_yticklabels` on\n    the current axes.\n    Calling this function with arguments is the pyplot equivalent of calling\n    `~.Axes.set_yticks` and `~.Axes.set_yticklabels` on the current axes.\n\n    Examples\n    --------\n    >>> locs, labels = yticks()  # Get the current locations and labels.\n    >>> yticks(np.arange(0, 1, step=0.2))  # Set label locations.\n    >>> yticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.\n    >>> yticks([0, 1, 2], ['January', 'February', 'March'],\n    ...        rotation=45)  # Set text labels and properties.\n    >>> yticks([])  # Disable yticks.\n    \"\"\"\n    ax = gca()\n\n    if ticks is None and labels is None:\n        locs = ax.get_yticks()\n        labels = ax.get_yticklabels()\n    elif labels is None:\n        locs = ax.set_yticks(ticks)\n        labels = ax.get_yticklabels()\n    else:\n        locs = ax.set_yticks(ticks)\n        labels = ax.set_yticklabels(labels, **kwargs)\n    for l in labels:\n        l.update(kwargs)\n\n    return locs, labels",
        "begin_line": 1487,
        "end_line": 1541,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.pyplot.colorbar#1992",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.colorbar(mappable=None, cax=None, ax=None, **kw)",
        "snippet": "def colorbar(mappable=None, cax=None, ax=None, **kw):\n    if mappable is None:\n        mappable = gci()\n        if mappable is None:\n            raise RuntimeError('No mappable was found to use for colorbar '\n                               'creation. First define a mappable such as '\n                               'an image (with imshow) or a contour set ('\n                               'with contourf).')\n    if ax is None:\n        ax = gca()\n    ret = gcf().colorbar(mappable, cax=cax, ax=ax, **kw)\n    return ret",
        "begin_line": 1992,
        "end_line": 2003,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001380071763731714,
            "pseudo_dstar_susp": 0.00013869625520110957,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00013869625520110957,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.pyplot.polar#2114",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.polar(*args, **kwargs)",
        "snippet": "def polar(*args, **kwargs):\n    \"\"\"\n    Make a polar plot.\n\n    call signature::\n\n      polar(theta, r, **kwargs)\n\n    Multiple *theta*, *r* arguments are supported, with format strings, as in\n    `plot`.\n    \"\"\"\n    # If an axis already exists, check if it has a polar projection\n    if gcf().get_axes():\n        if not isinstance(gca(), PolarAxes):\n            cbook._warn_external('Trying to create polar plot on an axis '\n                                 'that does not have a polar projection.')\n    ax = gca(polar=True)\n    ret = ax.plot(*args, **kwargs)\n    return ret",
        "begin_line": 2114,
        "end_line": 2132,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.pyplot.suptitle#2320",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.suptitle(t, **kwargs)",
        "snippet": "def suptitle(t, **kwargs):\n    return gcf().suptitle(t, **kwargs)",
        "begin_line": 2320,
        "end_line": 2321,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.pyplot.contour#2479",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.contour(*args, data=None, **kwargs)",
        "snippet": "def contour(*args, data=None, **kwargs):\n    __ret = gca().contour(\n        *args, **({\"data\": data} if data is not None else {}),\n        **kwargs)\n    if __ret._A is not None: sci(__ret)  # noqa\n    return __ret",
        "begin_line": 2479,
        "end_line": 2484,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019179133103183735,
            "pseudo_dstar_susp": 0.00016220600162206002,
            "pseudo_tarantula_susp": 0.0003696857670979667,
            "pseudo_op2_susp": 0.00016220600162206002,
            "pseudo_barinel_susp": 0.0003696857670979667
        }
    },
    {
        "name": "lib.matplotlib.pyplot.contourf#2489",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.contourf(*args, data=None, **kwargs)",
        "snippet": "def contourf(*args, data=None, **kwargs):\n    __ret = gca().contourf(\n        *args, **({\"data\": data} if data is not None else {}),\n        **kwargs)\n    if __ret._A is not None: sci(__ret)  # noqa\n    return __ret",
        "begin_line": 2489,
        "end_line": 2494,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015659254619480113,
            "pseudo_dstar_susp": 0.00015158405335758679,
            "pseudo_tarantula_susp": 0.0002158894645941278,
            "pseudo_op2_susp": 0.00015158405335758679,
            "pseudo_barinel_susp": 0.00021598272138228941
        }
    },
    {
        "name": "lib.matplotlib.pyplot.errorbar#2512",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.errorbar(x, y, yerr=None, xerr=None, fmt='', ecolor=None, elinewidth=None, capsize=None, barsabove=False, lolims=False, uplims=False, xlolims=False, xuplims=False, errorevery=1, capthick=None, *, data=None, **kwargs)",
        "snippet": "def errorbar(\n        x, y, yerr=None, xerr=None, fmt='', ecolor=None,\n        elinewidth=None, capsize=None, barsabove=False, lolims=False,\n        uplims=False, xlolims=False, xuplims=False, errorevery=1,\n        capthick=None, *, data=None, **kwargs):\n    return gca().errorbar(\n        x, y, yerr=yerr, xerr=xerr, fmt=fmt, ecolor=ecolor,\n        elinewidth=elinewidth, capsize=capsize, barsabove=barsabove,\n        lolims=lolims, uplims=uplims, xlolims=xlolims,\n        xuplims=xuplims, errorevery=errorevery, capthick=capthick,\n        **({\"data\": data} if data is not None else {}), **kwargs)",
        "begin_line": 2512,
        "end_line": 2522,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.pyplot.hist#2593",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.hist(x, bins=None, range=None, density=False, weights=None, cumulative=False, bottom=None, histtype='bar', align='mid', orientation='vertical', rwidth=None, log=False, color=None, label=None, stacked=False, *, data=None, **kwargs)",
        "snippet": "def hist(\n        x, bins=None, range=None, density=False, weights=None,\n        cumulative=False, bottom=None, histtype='bar', align='mid',\n        orientation='vertical', rwidth=None, log=False, color=None,\n        label=None, stacked=False, *, data=None, **kwargs):\n    return gca().hist(\n        x, bins=bins, range=range, density=density, weights=weights,\n        cumulative=cumulative, bottom=bottom, histtype=histtype,\n        align=align, orientation=orientation, rwidth=rwidth, log=log,\n        color=color, label=label, stacked=stacked, **({\"data\": data}\n        if data is not None else {}), **kwargs)",
        "begin_line": 2593,
        "end_line": 2603,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011859582542694497,
            "pseudo_dstar_susp": 0.00011637379262190155,
            "pseudo_tarantula_susp": 0.000129315918789603,
            "pseudo_op2_susp": 0.00011637379262190155,
            "pseudo_barinel_susp": 0.000129315918789603
        }
    },
    {
        "name": "lib.matplotlib.pyplot.imshow#2632",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.imshow(X, cmap=None, norm=None, aspect=None, interpolation=None, alpha=None, vmin=None, vmax=None, origin=None, extent=None, shape=cbook.deprecation._deprecated_parameter, filternorm=1, filterrad=4.0, imlim=cbook.deprecation._deprecated_parameter, resample=None, url=None, *, data=None, **kwargs)",
        "snippet": "def imshow(\n        X, cmap=None, norm=None, aspect=None, interpolation=None,\n        alpha=None, vmin=None, vmax=None, origin=None, extent=None,\n        shape=cbook.deprecation._deprecated_parameter, filternorm=1,\n        filterrad=4.0, imlim=cbook.deprecation._deprecated_parameter,\n        resample=None, url=None, *, data=None, **kwargs):\n    __ret = gca().imshow(\n        X, cmap=cmap, norm=norm, aspect=aspect,\n        interpolation=interpolation, alpha=alpha, vmin=vmin,\n        vmax=vmax, origin=origin, extent=extent, shape=shape,\n        filternorm=filternorm, filterrad=filterrad, imlim=imlim,\n        resample=resample, url=url, **({\"data\": data} if data is not\n        None else {}), **kwargs)\n    sci(__ret)\n    return __ret",
        "begin_line": 2632,
        "end_line": 2646,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001380071763731714,
            "pseudo_dstar_susp": 0.00013869625520110957,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00013869625520110957,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.pyplot.legend#2651",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.legend(*args, **kwargs)",
        "snippet": "def legend(*args, **kwargs):\n    return gca().legend(*args, **kwargs)",
        "begin_line": 2651,
        "end_line": 2652,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001967729240456513,
            "pseudo_dstar_susp": 0.0001918649270913277,
            "pseudo_tarantula_susp": 0.00023239600278875203,
            "pseudo_op2_susp": 0.0001918649270913277,
            "pseudo_barinel_susp": 0.00023239600278875203
        }
    },
    {
        "name": "lib.matplotlib.pyplot.pcolormesh#2711",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.pcolormesh(*args, alpha=None, norm=None, cmap=None, vmin=None, vmax=None, shading='flat', antialiased=False, data=None, **kwargs)",
        "snippet": "def pcolormesh(\n        *args, alpha=None, norm=None, cmap=None, vmin=None,\n        vmax=None, shading='flat', antialiased=False, data=None,\n        **kwargs):\n    __ret = gca().pcolormesh(\n        *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,\n        vmax=vmax, shading=shading, antialiased=antialiased,\n        **({\"data\": data} if data is not None else {}), **kwargs)\n    sci(__ret)\n    return __ret",
        "begin_line": 2711,
        "end_line": 2720,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.pyplot.pie#2735",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.pie(x, explode=None, labels=None, colors=None, autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1, startangle=None, radius=None, counterclock=True, wedgeprops=None, textprops=None, center=(0, 0), frame=False, rotatelabels=False, *, data=None)",
        "snippet": "def pie(\n        x, explode=None, labels=None, colors=None, autopct=None,\n        pctdistance=0.6, shadow=False, labeldistance=1.1,\n        startangle=None, radius=None, counterclock=True,\n        wedgeprops=None, textprops=None, center=(0, 0), frame=False,\n        rotatelabels=False, *, data=None):\n    return gca().pie(\n        x, explode=explode, labels=labels, colors=colors,\n        autopct=autopct, pctdistance=pctdistance, shadow=shadow,\n        labeldistance=labeldistance, startangle=startangle,\n        radius=radius, counterclock=counterclock,\n        wedgeprops=wedgeprops, textprops=textprops, center=center,\n        frame=frame, rotatelabels=rotatelabels, **({\"data\": data} if\n        data is not None else {}))",
        "begin_line": 2735,
        "end_line": 2748,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022251891410769915,
            "pseudo_dstar_susp": 0.00018925056775170325,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00018925056775170325,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.pyplot.plot#2753",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.plot(*args, scalex=True, scaley=True, data=None, **kwargs)",
        "snippet": "def plot(*args, scalex=True, scaley=True, data=None, **kwargs):\n    return gca().plot(\n        *args, scalex=scalex, scaley=scaley, **({\"data\": data} if data\n        is not None else {}), **kwargs)",
        "begin_line": 2753,
        "end_line": 2756,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001839587932303164,
            "pseudo_dstar_susp": 0.00018604651162790697,
            "pseudo_tarantula_susp": 0.00021505376344086021,
            "pseudo_op2_susp": 0.00018604651162790697,
            "pseudo_barinel_susp": 0.00021496130696474635
        }
    },
    {
        "name": "lib.matplotlib.pyplot.plot_date#2761",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.plot_date(x, y, fmt='o', tz=None, xdate=True, ydate=False, *, data=None, **kwargs)",
        "snippet": "def plot_date(\n        x, y, fmt='o', tz=None, xdate=True, ydate=False, *,\n        data=None, **kwargs):\n    return gca().plot_date(\n        x, y, fmt=fmt, tz=tz, xdate=xdate, ydate=ydate, **({\"data\":\n        data} if data is not None else {}), **kwargs)",
        "begin_line": 2761,
        "end_line": 2766,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019916351324437363,
            "pseudo_dstar_susp": 0.00016353229762878168,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00016353229762878168,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.pyplot.quiver#2784",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.quiver(*args, data=None, **kw)",
        "snippet": "def quiver(*args, data=None, **kw):\n    __ret = gca().quiver(\n        *args, **({\"data\": data} if data is not None else {}), **kw)\n    sci(__ret)\n    return __ret",
        "begin_line": 2784,
        "end_line": 2788,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012717792191275595,
            "pseudo_dstar_susp": 0.0001210800339024095,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.0001210800339024095,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.pyplot.scatter#2799",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.scatter(x, y, s=None, c=None, marker=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, verts=cbook.deprecation._deprecated_parameter, edgecolors=None, *, plotnonfinite=False, data=None, **kwargs)",
        "snippet": "def scatter(\n        x, y, s=None, c=None, marker=None, cmap=None, norm=None,\n        vmin=None, vmax=None, alpha=None, linewidths=None,\n        verts=cbook.deprecation._deprecated_parameter,\n        edgecolors=None, *, plotnonfinite=False, data=None, **kwargs):\n    __ret = gca().scatter(\n        x, y, s=s, c=c, marker=marker, cmap=cmap, norm=norm,\n        vmin=vmin, vmax=vmax, alpha=alpha, linewidths=linewidths,\n        verts=verts, edgecolors=edgecolors,\n        plotnonfinite=plotnonfinite, **({\"data\": data} if data is not\n        None else {}), **kwargs)\n    sci(__ret)\n    return __ret",
        "begin_line": 2799,
        "end_line": 2811,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00016028209648982208,
            "pseudo_tarantula_susp": 0.00027210884353741496,
            "pseudo_op2_susp": 0.00016028209648982208,
            "pseudo_barinel_susp": 0.0002720348204570185
        }
    },
    {
        "name": "lib.matplotlib.pyplot.stackplot#2857",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.stackplot(x, *args, labels=(), colors=None, baseline='zero', data=None, **kwargs)",
        "snippet": "def stackplot(\n        x, *args, labels=(), colors=None, baseline='zero', data=None,\n        **kwargs):\n    return gca().stackplot(\n        x, *args, labels=labels, colors=colors, baseline=baseline,\n        **({\"data\": data} if data is not None else {}), **kwargs)",
        "begin_line": 2857,
        "end_line": 2862,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.pyplot.streamplot#2887",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.streamplot(x, y, u, v, density=1, linewidth=None, color=None, cmap=None, norm=None, arrowsize=1, arrowstyle='-|>', minlength=0.1, transform=None, zorder=None, start_points=None, maxlength=4.0, integration_direction='both', *, data=None)",
        "snippet": "def streamplot(\n        x, y, u, v, density=1, linewidth=None, color=None, cmap=None,\n        norm=None, arrowsize=1, arrowstyle='-|>', minlength=0.1,\n        transform=None, zorder=None, start_points=None, maxlength=4.0,\n        integration_direction='both', *, data=None):\n    __ret = gca().streamplot(\n        x, y, u, v, density=density, linewidth=linewidth, color=color,\n        cmap=cmap, norm=norm, arrowsize=arrowsize,\n        arrowstyle=arrowstyle, minlength=minlength,\n        transform=transform, zorder=zorder, start_points=start_points,\n        maxlength=maxlength,\n        integration_direction=integration_direction, **({\"data\": data}\n        if data is not None else {}))\n    sci(__ret.lines)\n    return __ret",
        "begin_line": 2887,
        "end_line": 2901,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012454851164528583,
            "pseudo_dstar_susp": 0.00011988970147464332,
            "pseudo_tarantula_susp": 0.00017415534656913968,
            "pseudo_op2_susp": 0.00011988970147464332,
            "pseudo_barinel_susp": 0.0001742767514813524
        }
    },
    {
        "name": "lib.matplotlib.pyplot.table#2906",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.table(cellText=None, cellColours=None, cellLoc='right', colWidths=None, rowLabels=None, rowColours=None, rowLoc='left', colLabels=None, colColours=None, colLoc='center', loc='bottom', bbox=None, edges='closed', **kwargs)",
        "snippet": "def table(\n        cellText=None, cellColours=None, cellLoc='right',\n        colWidths=None, rowLabels=None, rowColours=None,\n        rowLoc='left', colLabels=None, colColours=None,\n        colLoc='center', loc='bottom', bbox=None, edges='closed',\n        **kwargs):\n    return gca().table(\n        cellText=cellText, cellColours=cellColours, cellLoc=cellLoc,\n        colWidths=colWidths, rowLabels=rowLabels,\n        rowColours=rowColours, rowLoc=rowLoc, colLabels=colLabels,\n        colColours=colColours, colLoc=colLoc, loc=loc, bbox=bbox,\n        edges=edges, **kwargs)",
        "begin_line": 2906,
        "end_line": 2917,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015992323684631377,
            "pseudo_dstar_susp": 0.0001405086412814388,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.0001405086412814388,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.pyplot.tricontour#2947",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.tricontour(*args, **kwargs)",
        "snippet": "def tricontour(*args, **kwargs):\n    __ret = gca().tricontour(*args, **kwargs)\n    if __ret._A is not None: sci(__ret)  # noqa\n    return __ret",
        "begin_line": 2947,
        "end_line": 2950,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.pyplot.tricontourf#2955",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.tricontourf(*args, **kwargs)",
        "snippet": "def tricontourf(*args, **kwargs):\n    __ret = gca().tricontourf(*args, **kwargs)\n    if __ret._A is not None: sci(__ret)  # noqa\n    return __ret",
        "begin_line": 2955,
        "end_line": 2958,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.pyplot.tripcolor#2963",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.tripcolor(*args, alpha=1.0, norm=None, cmap=None, vmin=None, vmax=None, shading='flat', facecolors=None, **kwargs)",
        "snippet": "def tripcolor(\n        *args, alpha=1.0, norm=None, cmap=None, vmin=None, vmax=None,\n        shading='flat', facecolors=None, **kwargs):\n    __ret = gca().tripcolor(\n        *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,\n        vmax=vmax, shading=shading, facecolors=facecolors, **kwargs)\n    sci(__ret)\n    return __ret",
        "begin_line": 2963,
        "end_line": 2970,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.pyplot.triplot#2975",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.triplot(*args, **kwargs)",
        "snippet": "def triplot(*args, **kwargs):\n    return gca().triplot(*args, **kwargs)",
        "begin_line": 2975,
        "end_line": 2976,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.pyplot.sci#3017",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.sci(im)",
        "snippet": "def sci(im):\n    return gca()._sci(im)",
        "begin_line": 3017,
        "end_line": 3018,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021285653469561516,
            "pseudo_dstar_susp": 0.0002199736031676199,
            "pseudo_tarantula_susp": 0.00021172983273343214,
            "pseudo_op2_susp": 0.0002199736031676199,
            "pseudo_barinel_susp": 0.00021172983273343214
        }
    },
    {
        "name": "lib.matplotlib.pyplot.title#3023",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.title(label, fontdict=None, loc=None, pad=None, **kwargs)",
        "snippet": "def title(label, fontdict=None, loc=None, pad=None, **kwargs):\n    return gca().set_title(\n        label, fontdict=fontdict, loc=loc, pad=pad, **kwargs)",
        "begin_line": 3023,
        "end_line": 3025,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018846588767433095,
            "pseudo_dstar_susp": 0.0001541782300339192,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0001541782300339192,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.pyplot.xlabel#3030",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.xlabel(xlabel, fontdict=None, labelpad=None, **kwargs)",
        "snippet": "def xlabel(xlabel, fontdict=None, labelpad=None, **kwargs):\n    return gca().set_xlabel(\n        xlabel, fontdict=fontdict, labelpad=labelpad, **kwargs)",
        "begin_line": 3030,
        "end_line": 3032,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.tight_bbox.adjust_bbox#8",
        "src_path": "lib/matplotlib/tight_bbox.py",
        "class_name": "lib.matplotlib.tight_bbox",
        "signature": "lib.matplotlib.tight_bbox.adjust_bbox(fig, bbox_inches, fixed_dpi=None)",
        "snippet": "def adjust_bbox(fig, bbox_inches, fixed_dpi=None):\n    \"\"\"\n    Temporarily adjust the figure so that only the specified area\n    (bbox_inches) is saved.\n\n    It modifies fig.bbox, fig.bbox_inches,\n    fig.transFigure._boxout, and fig.patch.  While the figure size\n    changes, the scale of the original figure is conserved.  A\n    function which restores the original values are returned.\n    \"\"\"\n\n    origBbox = fig.bbox\n    origBboxInches = fig.bbox_inches\n    orig_tight_layout = fig.get_tight_layout()\n    _boxout = fig.transFigure._boxout\n\n    fig.set_tight_layout(False)\n\n    asp_list = []\n    locator_list = []\n    for ax in fig.axes:\n        pos = ax.get_position(original=False).frozen()\n        locator_list.append(ax.get_axes_locator())\n        asp_list.append(ax.get_aspect())\n\n        def _l(a, r, pos=pos):\n            return pos\n        ax.set_axes_locator(_l)\n        ax.set_aspect(\"auto\")\n\n    def restore_bbox():\n        for ax, asp, loc in zip(fig.axes, asp_list, locator_list):\n            ax.set_aspect(asp)\n            ax.set_axes_locator(loc)\n\n        fig.bbox = origBbox\n        fig.bbox_inches = origBboxInches\n        fig.set_tight_layout(orig_tight_layout)\n        fig.transFigure._boxout = _boxout\n        fig.transFigure.invalidate()\n        fig.patch.set_bounds(0, 0, 1, 1)\n\n    if fixed_dpi is not None:\n        tr = Affine2D().scale(fixed_dpi)\n        dpi_scale = fixed_dpi / fig.dpi\n    else:\n        tr = Affine2D().scale(fig.dpi)\n        dpi_scale = 1.\n\n    _bbox = TransformedBbox(bbox_inches, tr)\n\n    fig.bbox_inches = Bbox.from_bounds(0, 0,\n                                       bbox_inches.width, bbox_inches.height)\n    x0, y0 = _bbox.x0, _bbox.y0\n    w1, h1 = fig.bbox.width * dpi_scale, fig.bbox.height * dpi_scale\n    fig.transFigure._boxout = Bbox.from_bounds(-x0, -y0, w1, h1)\n    fig.transFigure.invalidate()\n\n    fig.bbox = TransformedBbox(fig.bbox_inches, tr)\n\n    fig.patch.set_bounds(x0 / w1, y0 / h1,\n                         fig.bbox.width / w1, fig.bbox.height / h1)\n\n    return restore_bbox",
        "begin_line": 8,
        "end_line": 71,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020056157240272763,
            "pseudo_dstar_susp": 0.00020682523267838676,
            "pseudo_tarantula_susp": 0.00021468441391155003,
            "pseudo_op2_susp": 0.00020682523267838676,
            "pseudo_barinel_susp": 0.00021468441391155003
        }
    },
    {
        "name": "lib.matplotlib.tight_bbox.restore_bbox#38",
        "src_path": "lib/matplotlib/tight_bbox.py",
        "class_name": "lib.matplotlib.tight_bbox",
        "signature": "lib.matplotlib.tight_bbox.restore_bbox()",
        "snippet": "    def restore_bbox():\n        for ax, asp, loc in zip(fig.axes, asp_list, locator_list):\n            ax.set_aspect(asp)\n            ax.set_axes_locator(loc)\n\n        fig.bbox = origBbox\n        fig.bbox_inches = origBboxInches\n        fig.set_tight_layout(orig_tight_layout)\n        fig.transFigure._boxout = _boxout\n        fig.transFigure.invalidate()\n        fig.patch.set_bounds(0, 0, 1, 1)",
        "begin_line": 38,
        "end_line": 48,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018463810930576072,
            "pseudo_dstar_susp": 0.00019109497420217848,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00019109497420217848,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.streamplot.streamplot#20",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot",
        "signature": "lib.matplotlib.streamplot.streamplot(axes, x, y, u, v, density=1, linewidth=None, color=None, cmap=None, norm=None, arrowsize=1, arrowstyle='-|>', minlength=0.1, transform=None, zorder=None, start_points=None, maxlength=4.0, integration_direction='both')",
        "snippet": "def streamplot(axes, x, y, u, v, density=1, linewidth=None, color=None,\n               cmap=None, norm=None, arrowsize=1, arrowstyle='-|>',\n               minlength=0.1, transform=None, zorder=None, start_points=None,\n               maxlength=4.0, integration_direction='both'):\n    \"\"\"\n    Draw streamlines of a vector flow.\n\n    Parameters\n    ----------\n    x, y : 1D arrays\n        An evenly spaced grid.\n    u, v : 2D arrays\n        *x* and *y*-velocities. The number of rows and columns must match\n        the length of *y* and *x*, respectively.\n    density : float or (float, float)\n        Controls the closeness of streamlines. When ``density = 1``, the domain\n        is divided into a 30x30 grid. *density* linearly scales this grid.\n        Each cell in the grid can have, at most, one traversing streamline.\n        For different densities in each direction, use a tuple\n        (density_x, density_y).\n    linewidth : float or 2D array\n        The width of the stream lines. With a 2D array the line width can be\n        varied across the grid. The array must have the same shape as *u*\n        and *v*.\n    color : matplotlib color code, or 2D array\n        The streamline color. If given an array, its values are converted to\n        colors using *cmap* and *norm*.  The array must have the same shape\n        as *u* and *v*.\n    cmap : `~matplotlib.colors.Colormap`\n        Colormap used to plot streamlines and arrows. This is only used if\n        *color* is an array.\n    norm : `~matplotlib.colors.Normalize`\n        Normalize object used to scale luminance data to 0, 1. If ``None``,\n        stretch (min, max) to (0, 1). This is only used if *color* is an array.\n    arrowsize : float\n        Scaling factor for the arrow size.\n    arrowstyle : str\n        Arrow style specification.\n        See `~matplotlib.patches.FancyArrowPatch`.\n    minlength : float\n        Minimum length of streamline in axes coordinates.\n    start_points : Nx2 array\n        Coordinates of starting points for the streamlines in data coordinates\n        (the same coordinates as the *x* and *y* arrays).\n    zorder : int\n        The zorder of the stream lines and arrows.\n        Artists with lower zorder values are drawn first.\n    maxlength : float\n        Maximum length of streamline in axes coordinates.\n    integration_direction : {'forward', 'backward', 'both'}\n        Integrate the streamline in forward, backward or both directions.\n        default is ``'both'``.\n\n    Returns\n    -------\n    stream_container : StreamplotSet\n        Container object with attributes\n\n        - ``lines``: `.LineCollection` of streamlines\n\n        - ``arrows``: `.PatchCollection` containing `.FancyArrowPatch`\n          objects representing the arrows half-way along stream lines.\n\n        This container will probably change in the future to allow changes\n        to the colormap, alpha, etc. for both lines and arrows, but these\n        changes should be backward compatible.\n    \"\"\"\n    grid = Grid(x, y)\n    mask = StreamMask(density)\n    dmap = DomainMap(grid, mask)\n\n    if zorder is None:\n        zorder = mlines.Line2D.zorder\n\n    # default to data coordinates\n    if transform is None:\n        transform = axes.transData\n\n    if color is None:\n        color = axes._get_lines.get_next_color()\n\n    if linewidth is None:\n        linewidth = matplotlib.rcParams['lines.linewidth']\n\n    line_kw = {}\n    arrow_kw = dict(arrowstyle=arrowstyle, mutation_scale=10 * arrowsize)\n\n    cbook._check_in_list(['both', 'forward', 'backward'],\n                         integration_direction=integration_direction)\n\n    if integration_direction == 'both':\n        maxlength /= 2.\n\n    use_multicolor_lines = isinstance(color, np.ndarray)\n    if use_multicolor_lines:\n        if color.shape != grid.shape:\n            raise ValueError(\"If 'color' is given, it must match the shape of \"\n                             \"'Grid(x, y)'\")\n        line_colors = []\n        color = np.ma.masked_invalid(color)\n    else:\n        line_kw['color'] = color\n        arrow_kw['color'] = color\n\n    if isinstance(linewidth, np.ndarray):\n        if linewidth.shape != grid.shape:\n            raise ValueError(\"If 'linewidth' is given, it must match the \"\n                             \"shape of 'Grid(x, y)'\")\n        line_kw['linewidth'] = []\n    else:\n        line_kw['linewidth'] = linewidth\n        arrow_kw['linewidth'] = linewidth\n\n    line_kw['zorder'] = zorder\n    arrow_kw['zorder'] = zorder\n\n    # Sanity checks.\n    if u.shape != grid.shape or v.shape != grid.shape:\n        raise ValueError(\"'u' and 'v' must match the shape of 'Grid(x, y)'\")\n\n    u = np.ma.masked_invalid(u)\n    v = np.ma.masked_invalid(v)\n\n    integrate = get_integrator(u, v, dmap, minlength, maxlength,\n                               integration_direction)\n\n    trajectories = []\n    if start_points is None:\n        for xm, ym in _gen_starting_points(mask.shape):\n            if mask[ym, xm] == 0:\n                xg, yg = dmap.mask2grid(xm, ym)\n                t = integrate(xg, yg)\n                if t is not None:\n                    trajectories.append(t)\n    else:\n        sp2 = np.asanyarray(start_points, dtype=float).copy()\n\n        # Check if start_points are outside the data boundaries\n        for xs, ys in sp2:\n            if not (grid.x_origin <= xs <= grid.x_origin + grid.width and\n                    grid.y_origin <= ys <= grid.y_origin + grid.height):\n                raise ValueError(\"Starting point ({}, {}) outside of data \"\n                                 \"boundaries\".format(xs, ys))\n\n        # Convert start_points from data to array coords\n        # Shift the seed points from the bottom left of the data so that\n        # data2grid works properly.\n        sp2[:, 0] -= grid.x_origin\n        sp2[:, 1] -= grid.y_origin\n\n        for xs, ys in sp2:\n            xg, yg = dmap.data2grid(xs, ys)\n            t = integrate(xg, yg)\n            if t is not None:\n                trajectories.append(t)\n\n    if use_multicolor_lines:\n        if norm is None:\n            norm = mcolors.Normalize(color.min(), color.max())\n        if cmap is None:\n            cmap = cm.get_cmap(matplotlib.rcParams['image.cmap'])\n        else:\n            cmap = cm.get_cmap(cmap)\n\n    streamlines = []\n    arrows = []\n    for t in trajectories:\n        tgx = np.array(t[0])\n        tgy = np.array(t[1])\n        # Rescale from grid-coordinates to data-coordinates.\n        tx, ty = dmap.grid2data(*np.array(t))\n        tx += grid.x_origin\n        ty += grid.y_origin\n\n        points = np.transpose([tx, ty]).reshape(-1, 1, 2)\n        streamlines.extend(np.hstack([points[:-1], points[1:]]))\n\n        # Add arrows half way along each trajectory.\n        s = np.cumsum(np.hypot(np.diff(tx), np.diff(ty)))\n        n = np.searchsorted(s, s[-1] / 2.)\n        arrow_tail = (tx[n], ty[n])\n        arrow_head = (np.mean(tx[n:n + 2]), np.mean(ty[n:n + 2]))\n\n        if isinstance(linewidth, np.ndarray):\n            line_widths = interpgrid(linewidth, tgx, tgy)[:-1]\n            line_kw['linewidth'].extend(line_widths)\n            arrow_kw['linewidth'] = line_widths[n]\n\n        if use_multicolor_lines:\n            color_values = interpgrid(color, tgx, tgy)[:-1]\n            line_colors.append(color_values)\n            arrow_kw['color'] = cmap(norm(color_values[n]))\n\n        p = patches.FancyArrowPatch(\n            arrow_tail, arrow_head, transform=transform, **arrow_kw)\n        axes.add_patch(p)\n        arrows.append(p)\n\n    lc = mcollections.LineCollection(\n        streamlines, transform=transform, **line_kw)\n    lc.sticky_edges.x[:] = [grid.x_origin, grid.x_origin + grid.width]\n    lc.sticky_edges.y[:] = [grid.y_origin, grid.y_origin + grid.height]\n    if use_multicolor_lines:\n        lc.set_array(np.ma.hstack(line_colors))\n        lc.set_cmap(cmap)\n        lc.set_norm(norm)\n    axes.add_collection(lc)\n    axes.autoscale_view()\n\n    ac = matplotlib.collections.PatchCollection(arrows)\n    stream_container = StreamplotSet(lc, ac)\n    return stream_container",
        "begin_line": 20,
        "end_line": 231,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001563721657544957,
            "pseudo_dstar_susp": 0.00020508613617719443,
            "pseudo_tarantula_susp": 0.00013066771200836272,
            "pseudo_op2_susp": 0.00020508613617719443,
            "pseudo_barinel_susp": 0.00013066771200836272
        }
    },
    {
        "name": "lib.matplotlib.streamplot.StreamplotSet.__init__#236",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.StreamplotSet",
        "signature": "lib.matplotlib.streamplot.StreamplotSet.__init__(self, lines, arrows, **kwargs)",
        "snippet": "    def __init__(self, lines, arrows, **kwargs):\n        self.lines = lines\n        self.arrows = arrows",
        "begin_line": 236,
        "end_line": 238,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00014025245441795232,
            "pseudo_dstar_susp": 0.0001895734597156398,
            "pseudo_tarantula_susp": 0.00012653422750854106,
            "pseudo_op2_susp": 0.0001895734597156398,
            "pseudo_barinel_susp": 0.00012653422750854106
        }
    },
    {
        "name": "lib.matplotlib.streamplot.DomainMap.__init__#262",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.DomainMap",
        "signature": "lib.matplotlib.streamplot.DomainMap.__init__(self, grid, mask)",
        "snippet": "    def __init__(self, grid, mask):\n        self.grid = grid\n        self.mask = mask\n        # Constants for conversion between grid- and mask-coordinates\n        self.x_grid2mask = (mask.nx - 1) / (grid.nx - 1)\n        self.y_grid2mask = (mask.ny - 1) / (grid.ny - 1)\n\n        self.x_mask2grid = 1. / self.x_grid2mask\n        self.y_mask2grid = 1. / self.y_grid2mask\n\n        self.x_data2grid = 1. / grid.dx\n        self.y_data2grid = 1. / grid.dy",
        "begin_line": 262,
        "end_line": 273,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011859582542694497,
            "pseudo_dstar_susp": 0.00011637379262190155,
            "pseudo_tarantula_susp": 0.000129315918789603,
            "pseudo_op2_susp": 0.00011637379262190155,
            "pseudo_barinel_susp": 0.000129315918789603
        }
    },
    {
        "name": "lib.matplotlib.streamplot.DomainMap.grid2mask#275",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.DomainMap",
        "signature": "lib.matplotlib.streamplot.DomainMap.grid2mask(self, xi, yi)",
        "snippet": "    def grid2mask(self, xi, yi):\n        \"\"\"Return nearest space in mask-coords from given grid-coords.\"\"\"\n        return (int(xi * self.x_grid2mask + 0.5),\n                int(yi * self.y_grid2mask + 0.5))",
        "begin_line": 275,
        "end_line": 278,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011859582542694497,
            "pseudo_dstar_susp": 0.00011637379262190155,
            "pseudo_tarantula_susp": 0.000129315918789603,
            "pseudo_op2_susp": 0.00011637379262190155,
            "pseudo_barinel_susp": 0.000129315918789603
        }
    },
    {
        "name": "lib.matplotlib.streamplot.DomainMap.mask2grid#280",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.DomainMap",
        "signature": "lib.matplotlib.streamplot.DomainMap.mask2grid(self, xm, ym)",
        "snippet": "    def mask2grid(self, xm, ym):\n        return xm * self.x_mask2grid, ym * self.y_mask2grid",
        "begin_line": 280,
        "end_line": 281,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.streamplot.DomainMap.data2grid#283",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.DomainMap",
        "signature": "lib.matplotlib.streamplot.DomainMap.data2grid(self, xd, yd)",
        "snippet": "    def data2grid(self, xd, yd):\n        return xd * self.x_data2grid, yd * self.y_data2grid",
        "begin_line": 283,
        "end_line": 284,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.streamplot.DomainMap.grid2data#286",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.DomainMap",
        "signature": "lib.matplotlib.streamplot.DomainMap.grid2data(self, xg, yg)",
        "snippet": "    def grid2data(self, xg, yg):\n        return xg / self.x_data2grid, yg / self.y_data2grid",
        "begin_line": 286,
        "end_line": 287,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.streamplot.DomainMap.undo_trajectory#303",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.DomainMap",
        "signature": "lib.matplotlib.streamplot.DomainMap.undo_trajectory(self)",
        "snippet": "    def undo_trajectory(self):\n        self.mask._undo_trajectory()",
        "begin_line": 303,
        "end_line": 304,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012195121951219512,
            "pseudo_dstar_susp": 0.00011855364552459988,
            "pseudo_tarantula_susp": 0.00015482272797646694,
            "pseudo_op2_susp": 0.00011855364552459988,
            "pseudo_barinel_susp": 0.00015446400988569664
        }
    },
    {
        "name": "lib.matplotlib.streamplot.Grid.__init__#309",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.Grid",
        "signature": "lib.matplotlib.streamplot.Grid.__init__(self, x, y)",
        "snippet": "    def __init__(self, x, y):\n\n        if x.ndim == 1:\n            pass\n        elif x.ndim == 2:\n            x_row = x[0, :]\n            if not np.allclose(x_row, x):\n                raise ValueError(\"The rows of 'x' must be equal\")\n            x = x_row\n        else:\n            raise ValueError(\"'x' can have at maximum 2 dimensions\")\n\n        if y.ndim == 1:\n            pass\n        elif y.ndim == 2:\n            y_col = y[:, 0]\n            if not np.allclose(y_col, y.T):\n                raise ValueError(\"The columns of 'y' must be equal\")\n            y = y_col\n        else:\n            raise ValueError(\"'y' can have at maximum 2 dimensions\")\n\n        self.nx = len(x)\n        self.ny = len(y)\n\n        self.dx = x[1] - x[0]\n        self.dy = y[1] - y[0]\n\n        self.x_origin = x[0]\n        self.y_origin = y[0]\n\n        self.width = x[-1] - x[0]\n        self.height = y[-1] - y[0]\n\n        if not np.allclose(np.diff(x), self.width / (self.nx - 1)):\n            raise ValueError(\"'x' values must be equally spaced\")\n        if not np.allclose(np.diff(y), self.height / (self.ny - 1)):\n            raise ValueError(\"'y' values must be equally spaced\")",
        "begin_line": 309,
        "end_line": 346,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.streamplot.Grid.shape#349",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.Grid",
        "signature": "lib.matplotlib.streamplot.Grid.shape(self)",
        "snippet": "    def shape(self):\n        return self.ny, self.nx",
        "begin_line": 349,
        "end_line": 350,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011859582542694497,
            "pseudo_dstar_susp": 0.00011637379262190155,
            "pseudo_tarantula_susp": 0.000129315918789603,
            "pseudo_op2_susp": 0.00011637379262190155,
            "pseudo_barinel_susp": 0.000129315918789603
        }
    },
    {
        "name": "lib.matplotlib.streamplot.Grid.within_grid#352",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.Grid",
        "signature": "lib.matplotlib.streamplot.Grid.within_grid(self, xi, yi)",
        "snippet": "    def within_grid(self, xi, yi):\n        \"\"\"Return True if point is a valid index of grid.\"\"\"\n        # Note that xi/yi can be floats; so, for example, we can't simply check\n        # `xi < self.nx` since *xi* can be `self.nx - 1 < xi < self.nx`\n        return xi >= 0 and xi <= self.nx - 1 and yi >= 0 and yi <= self.ny - 1",
        "begin_line": 352,
        "end_line": 356,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.streamplot.StreamMask.__init__#368",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.StreamMask",
        "signature": "lib.matplotlib.streamplot.StreamMask.__init__(self, density)",
        "snippet": "    def __init__(self, density):\n        try:\n            self.nx, self.ny = (30 * np.broadcast_to(density, 2)).astype(int)\n        except ValueError:\n            raise ValueError(\"'density' must be a scalar or be of length 2\")\n        if self.nx < 0 or self.ny < 0:\n            raise ValueError(\"'density' must be positive\")\n        self._mask = np.zeros((self.ny, self.nx))\n        self.shape = self._mask.shape\n\n        self._current_xy = None",
        "begin_line": 368,
        "end_line": 378,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011859582542694497,
            "pseudo_dstar_susp": 0.00011637379262190155,
            "pseudo_tarantula_susp": 0.000129315918789603,
            "pseudo_op2_susp": 0.00011637379262190155,
            "pseudo_barinel_susp": 0.000129315918789603
        }
    },
    {
        "name": "lib.matplotlib.streamplot.StreamMask.__getitem__#380",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.StreamMask",
        "signature": "lib.matplotlib.streamplot.StreamMask.__getitem__(self, *args)",
        "snippet": "    def __getitem__(self, *args):\n        return self._mask.__getitem__(*args)",
        "begin_line": 380,
        "end_line": 381,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011859582542694497,
            "pseudo_dstar_susp": 0.00011637379262190155,
            "pseudo_tarantula_susp": 0.000129315918789603,
            "pseudo_op2_susp": 0.00011637379262190155,
            "pseudo_barinel_susp": 0.000129315918789603
        }
    },
    {
        "name": "lib.matplotlib.streamplot.StreamMask._start_trajectory#383",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.StreamMask",
        "signature": "lib.matplotlib.streamplot.StreamMask._start_trajectory(self, xm, ym)",
        "snippet": "    def _start_trajectory(self, xm, ym):\n        \"\"\"Start recording streamline trajectory\"\"\"\n        self._traj = []\n        self._update_trajectory(xm, ym)",
        "begin_line": 383,
        "end_line": 386,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.streamplot.StreamMask._undo_trajectory#388",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.StreamMask",
        "signature": "lib.matplotlib.streamplot.StreamMask._undo_trajectory(self)",
        "snippet": "    def _undo_trajectory(self):\n        \"\"\"Remove current trajectory from mask\"\"\"\n        for t in self._traj:\n            self._mask.__setitem__(t, 0)",
        "begin_line": 388,
        "end_line": 391,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012195121951219512,
            "pseudo_dstar_susp": 0.00011855364552459988,
            "pseudo_tarantula_susp": 0.00015482272797646694,
            "pseudo_op2_susp": 0.00011855364552459988,
            "pseudo_barinel_susp": 0.00015446400988569664
        }
    },
    {
        "name": "lib.matplotlib.streamplot.StreamMask._update_trajectory#393",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.StreamMask",
        "signature": "lib.matplotlib.streamplot.StreamMask._update_trajectory(self, xm, ym)",
        "snippet": "    def _update_trajectory(self, xm, ym):\n        \"\"\"Update current trajectory position in mask.\n\n        If the new position has already been filled, raise `InvalidIndexError`.\n        \"\"\"\n        if self._current_xy != (xm, ym):\n            if self[ym, xm] == 0:\n                self._traj.append((ym, xm))\n                self._mask[ym, xm] = 1\n                self._current_xy = (xm, ym)\n            else:\n                raise InvalidIndexError",
        "begin_line": 393,
        "end_line": 404,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.streamplot.get_integrator#418",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot",
        "signature": "lib.matplotlib.streamplot.get_integrator(u, v, dmap, minlength, maxlength, integration_direction)",
        "snippet": "def get_integrator(u, v, dmap, minlength, maxlength, integration_direction):\n\n    # rescale velocity onto grid-coordinates for integrations.\n    u, v = dmap.data2grid(u, v)\n\n    # speed (path length) will be in axes-coordinates\n    u_ax = u / (dmap.grid.nx - 1)\n    v_ax = v / (dmap.grid.ny - 1)\n    speed = np.ma.sqrt(u_ax ** 2 + v_ax ** 2)\n\n    def forward_time(xi, yi):\n        if not dmap.grid.within_grid(xi, yi):\n            raise OutOfBounds\n        ds_dt = interpgrid(speed, xi, yi)\n        if ds_dt == 0:\n            raise TerminateTrajectory()\n        dt_ds = 1. / ds_dt\n        ui = interpgrid(u, xi, yi)\n        vi = interpgrid(v, xi, yi)\n        return ui * dt_ds, vi * dt_ds\n\n    def backward_time(xi, yi):\n        dxi, dyi = forward_time(xi, yi)\n        return -dxi, -dyi\n\n    def integrate(x0, y0):\n        \"\"\"Return x, y grid-coordinates of trajectory based on starting point.\n\n        Integrate both forward and backward in time from starting point in\n        grid coordinates.\n\n        Integration is terminated when a trajectory reaches a domain boundary\n        or when it crosses into an already occupied cell in the StreamMask. The\n        resulting trajectory is None if it is shorter than `minlength`.\n        \"\"\"\n\n        stotal, x_traj, y_traj = 0., [], []\n\n        try:\n            dmap.start_trajectory(x0, y0)\n        except InvalidIndexError:\n            return None\n        if integration_direction in ['both', 'backward']:\n            s, xt, yt = _integrate_rk12(x0, y0, dmap, backward_time, maxlength)\n            stotal += s\n            x_traj += xt[::-1]\n            y_traj += yt[::-1]\n\n        if integration_direction in ['both', 'forward']:\n            dmap.reset_start_point(x0, y0)\n            s, xt, yt = _integrate_rk12(x0, y0, dmap, forward_time, maxlength)\n            if len(x_traj) > 0:\n                xt = xt[1:]\n                yt = yt[1:]\n            stotal += s\n            x_traj += xt\n            y_traj += yt\n\n        if stotal > minlength:\n            return x_traj, y_traj\n        else:  # reject short trajectories\n            dmap.undo_trajectory()\n            return None\n\n    return integrate",
        "begin_line": 418,
        "end_line": 482,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.streamplot.forward_time#428",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot",
        "signature": "lib.matplotlib.streamplot.forward_time(xi, yi)",
        "snippet": "    def forward_time(xi, yi):\n        if not dmap.grid.within_grid(xi, yi):\n            raise OutOfBounds\n        ds_dt = interpgrid(speed, xi, yi)\n        if ds_dt == 0:\n            raise TerminateTrajectory()\n        dt_ds = 1. / ds_dt\n        ui = interpgrid(u, xi, yi)\n        vi = interpgrid(v, xi, yi)\n        return ui * dt_ds, vi * dt_ds",
        "begin_line": 428,
        "end_line": 437,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.streamplot.backward_time#439",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot",
        "signature": "lib.matplotlib.streamplot.backward_time(xi, yi)",
        "snippet": "    def backward_time(xi, yi):\n        dxi, dyi = forward_time(xi, yi)\n        return -dxi, -dyi",
        "begin_line": 439,
        "end_line": 441,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.streamplot.integrate#443",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot",
        "signature": "lib.matplotlib.streamplot.integrate(x0, y0)",
        "snippet": "    def integrate(x0, y0):\n        \"\"\"Return x, y grid-coordinates of trajectory based on starting point.\n\n        Integrate both forward and backward in time from starting point in\n        grid coordinates.\n\n        Integration is terminated when a trajectory reaches a domain boundary\n        or when it crosses into an already occupied cell in the StreamMask. The\n        resulting trajectory is None if it is shorter than `minlength`.\n        \"\"\"\n\n        stotal, x_traj, y_traj = 0., [], []\n\n        try:\n            dmap.start_trajectory(x0, y0)\n        except InvalidIndexError:\n            return None\n        if integration_direction in ['both', 'backward']:\n            s, xt, yt = _integrate_rk12(x0, y0, dmap, backward_time, maxlength)\n            stotal += s\n            x_traj += xt[::-1]\n            y_traj += yt[::-1]\n\n        if integration_direction in ['both', 'forward']:\n            dmap.reset_start_point(x0, y0)\n            s, xt, yt = _integrate_rk12(x0, y0, dmap, forward_time, maxlength)\n            if len(x_traj) > 0:\n                xt = xt[1:]\n                yt = yt[1:]\n            stotal += s\n            x_traj += xt\n            y_traj += yt\n\n        if stotal > minlength:\n            return x_traj, y_traj\n        else:  # reject short trajectories\n            dmap.undo_trajectory()\n            return None",
        "begin_line": 443,
        "end_line": 480,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.streamplot._integrate_rk12#489",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot",
        "signature": "lib.matplotlib.streamplot._integrate_rk12(x0, y0, dmap, f, maxlength)",
        "snippet": "def _integrate_rk12(x0, y0, dmap, f, maxlength):\n    \"\"\"2nd-order Runge-Kutta algorithm with adaptive step size.\n\n    This method is also referred to as the improved Euler's method, or Heun's\n    method. This method is favored over higher-order methods because:\n\n    1. To get decent looking trajectories and to sample every mask cell\n       on the trajectory we need a small timestep, so a lower order\n       solver doesn't hurt us unless the data is *very* high resolution.\n       In fact, for cases where the user inputs\n       data smaller or of similar grid size to the mask grid, the higher\n       order corrections are negligible because of the very fast linear\n       interpolation used in `interpgrid`.\n\n    2. For high resolution input data (i.e. beyond the mask\n       resolution), we must reduce the timestep. Therefore, an adaptive\n       timestep is more suited to the problem as this would be very hard\n       to judge automatically otherwise.\n\n    This integrator is about 1.5 - 2x as fast as both the RK4 and RK45\n    solvers in most setups on my machine. I would recommend removing the\n    other two to keep things simple.\n    \"\"\"\n    # This error is below that needed to match the RK4 integrator. It\n    # is set for visual reasons -- too low and corners start\n    # appearing ugly and jagged. Can be tuned.\n    maxerror = 0.003\n\n    # This limit is important (for all integrators) to avoid the\n    # trajectory skipping some mask cells. We could relax this\n    # condition if we use the code which is commented out below to\n    # increment the location gradually. However, due to the efficient\n    # nature of the interpolation, this doesn't boost speed by much\n    # for quite a bit of complexity.\n    maxds = min(1. / dmap.mask.nx, 1. / dmap.mask.ny, 0.1)\n\n    ds = maxds\n    stotal = 0\n    xi = x0\n    yi = y0\n    xf_traj = []\n    yf_traj = []\n\n    while True:\n        try:\n            if dmap.grid.within_grid(xi, yi):\n                xf_traj.append(xi)\n                yf_traj.append(yi)\n            else:\n                raise OutOfBounds\n\n            # Compute the two intermediate gradients.\n            # f should raise OutOfBounds if the locations given are\n            # outside the grid.\n            k1x, k1y = f(xi, yi)\n            k2x, k2y = f(xi + ds * k1x, yi + ds * k1y)\n\n        except OutOfBounds:\n            # Out of the domain during this step.\n            # Take an Euler step to the boundary to improve neatness\n            # unless the trajectory is currently empty.\n            if xf_traj:\n                ds, xf_traj, yf_traj = _euler_step(xf_traj, yf_traj,\n                                                   dmap, f)\n                stotal += ds\n            break\n        except TerminateTrajectory:\n            break\n\n        dx1 = ds * k1x\n        dy1 = ds * k1y\n        dx2 = ds * 0.5 * (k1x + k2x)\n        dy2 = ds * 0.5 * (k1y + k2y)\n\n        nx, ny = dmap.grid.shape\n        # Error is normalized to the axes coordinates\n        error = np.hypot((dx2 - dx1) / (nx - 1), (dy2 - dy1) / (ny - 1))\n\n        # Only save step if within error tolerance\n        if error < maxerror:\n            xi += dx2\n            yi += dy2\n            try:\n                dmap.update_trajectory(xi, yi)\n            except InvalidIndexError:\n                break\n            if stotal + ds > maxlength:\n                break\n            stotal += ds\n\n        # recalculate stepsize based on step error\n        if error == 0:\n            ds = maxds\n        else:\n            ds = min(maxds, 0.85 * ds * (maxerror / error) ** 0.5)\n\n    return stotal, xf_traj, yf_traj",
        "begin_line": 489,
        "end_line": 585,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012023566189731875,
            "pseudo_dstar_susp": 0.00011741223435481978,
            "pseudo_tarantula_susp": 0.00013345789403443215,
            "pseudo_op2_susp": 0.00011741223435481978,
            "pseudo_barinel_susp": 0.00013338668800853674
        }
    },
    {
        "name": "lib.matplotlib.streamplot._euler_step#588",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot",
        "signature": "lib.matplotlib.streamplot._euler_step(xf_traj, yf_traj, dmap, f)",
        "snippet": "def _euler_step(xf_traj, yf_traj, dmap, f):\n    \"\"\"Simple Euler integration step that extends streamline to boundary.\"\"\"\n    ny, nx = dmap.grid.shape\n    xi = xf_traj[-1]\n    yi = yf_traj[-1]\n    cx, cy = f(xi, yi)\n    if cx == 0:\n        dsx = np.inf\n    elif cx < 0:\n        dsx = xi / -cx\n    else:\n        dsx = (nx - 1 - xi) / cx\n    if cy == 0:\n        dsy = np.inf\n    elif cy < 0:\n        dsy = yi / -cy\n    else:\n        dsy = (ny - 1 - yi) / cy\n    ds = min(dsx, dsy)\n    xf_traj.append(xi + cx * ds)\n    yf_traj.append(yi + cy * ds)\n    return ds, xf_traj, yf_traj",
        "begin_line": 588,
        "end_line": 609,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.streamplot.interpgrid#615",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot",
        "signature": "lib.matplotlib.streamplot.interpgrid(a, xi, yi)",
        "snippet": "def interpgrid(a, xi, yi):\n    \"\"\"Fast 2D, linear interpolation on an integer grid\"\"\"\n\n    Ny, Nx = np.shape(a)\n    if isinstance(xi, np.ndarray):\n        x = xi.astype(int)\n        y = yi.astype(int)\n        # Check that xn, yn don't exceed max index\n        xn = np.clip(x + 1, 0, Nx - 1)\n        yn = np.clip(y + 1, 0, Ny - 1)\n    else:\n        x = int(xi)\n        y = int(yi)\n        # conditional is faster than clipping for integers\n        if x == (Nx - 1):\n            xn = x\n        else:\n            xn = x + 1\n        if y == (Ny - 1):\n            yn = y\n        else:\n            yn = y + 1\n\n    a00 = a[y, x]\n    a01 = a[y, xn]\n    a10 = a[yn, x]\n    a11 = a[yn, xn]\n    xt = xi - x\n    yt = yi - y\n    a0 = a00 * (1 - xt) + a01 * xt\n    a1 = a10 * (1 - xt) + a11 * xt\n    ai = a0 * (1 - yt) + a1 * yt\n\n    if not isinstance(xi, np.ndarray):\n        if np.ma.is_masked(ai):\n            raise TerminateTrajectory\n\n    return ai",
        "begin_line": 615,
        "end_line": 652,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.streamplot._gen_starting_points#655",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot",
        "signature": "lib.matplotlib.streamplot._gen_starting_points(shape)",
        "snippet": "def _gen_starting_points(shape):\n    \"\"\"Yield starting points for streamlines.\n\n    Trying points on the boundary first gives higher quality streamlines.\n    This algorithm starts with a point on the mask corner and spirals inward.\n    This algorithm is inefficient, but fast compared to rest of streamplot.\n    \"\"\"\n    ny, nx = shape\n    xfirst = 0\n    yfirst = 1\n    xlast = nx - 1\n    ylast = ny - 1\n    x, y = 0, 0\n    direction = 'right'\n    for i in range(nx * ny):\n        yield x, y\n\n        if direction == 'right':\n            x += 1\n            if x >= xlast:\n                xlast -= 1\n                direction = 'up'\n        elif direction == 'up':\n            y += 1\n            if y >= ylast:\n                ylast -= 1\n                direction = 'left'\n        elif direction == 'left':\n            x -= 1\n            if x <= xfirst:\n                xfirst += 1\n                direction = 'down'\n        elif direction == 'down':\n            y -= 1\n            if y <= yfirst:\n                yfirst += 1\n                direction = 'right'",
        "begin_line": 655,
        "end_line": 691,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.contour.ContourLabeler._add_label#422",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.ContourLabeler",
        "signature": "lib.matplotlib.contour.ContourLabeler._add_label(self, t, x, y, lev, cvalue)",
        "snippet": "    def _add_label(self, t, x, y, lev, cvalue):\n        color = self.labelMappable.to_rgba(cvalue, alpha=self.alpha)\n\n        _text = self.get_text(lev, self.labelFmt)\n        self.set_label_props(t, _text, color)\n        self.labelTexts.append(t)\n        self.labelCValues.append(cvalue)\n        self.labelXYs.append((x, y))\n\n        # Add label to plot here - useful for manual mode label selection\n        self.ax.add_artist(t)",
        "begin_line": 422,
        "end_line": 432,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.contour._find_closest_point_on_leg#607",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour",
        "signature": "lib.matplotlib.contour._find_closest_point_on_leg(p1, p2, p0)",
        "snippet": "def _find_closest_point_on_leg(p1, p2, p0):\n    \"\"\"Find the closest point to p0 on line segment connecting p1 and p2.\"\"\"\n\n    # handle degenerate case\n    if np.all(p2 == p1):\n        d = np.sum((p0 - p1)**2)\n        return d, p1\n\n    d21 = p2 - p1\n    d01 = p0 - p1\n\n    # project on to line segment to find closest point\n    proj = np.dot(d01, d21) / np.dot(d21, d21)\n    if proj < 0:\n        proj = 0\n    if proj > 1:\n        proj = 1\n    pc = p1 + proj * d21\n\n    # find squared distance\n    d = np.sum((pc-p0)**2)\n\n    return d, pc",
        "begin_line": 607,
        "end_line": 629,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018846588767433095,
            "pseudo_dstar_susp": 0.0001541782300339192,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0001541782300339192,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.contour.ContourSet.__init__#733",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.ContourSet",
        "signature": "lib.matplotlib.contour.ContourSet.__init__(self, ax, *args, levels=None, filled=False, linewidths=None, linestyles=None, alpha=None, origin=None, extent=None, cmap=None, colors=None, norm=None, vmin=None, vmax=None, extend='neither', antialiased=None, **kwargs)",
        "snippet": "    def __init__(self, ax, *args,\n                 levels=None, filled=False, linewidths=None, linestyles=None,\n                 alpha=None, origin=None, extent=None,\n                 cmap=None, colors=None, norm=None, vmin=None, vmax=None,\n                 extend='neither', antialiased=None,\n                 **kwargs):\n        \"\"\"\n        Draw contour lines or filled regions, depending on\n        whether keyword arg *filled* is ``False`` (default) or ``True``.\n\n        Call signature::\n\n            ContourSet(ax, levels, allsegs, [allkinds], **kwargs)\n\n        Parameters\n        ----------\n        ax : `~.axes.Axes`\n            The `~.axes.Axes` object to draw on.\n\n        levels : [level0, level1, ..., leveln]\n            A list of floating point numbers indicating the contour\n            levels.\n\n        allsegs : [level0segs, level1segs, ...]\n            List of all the polygon segments for all the *levels*.\n            For contour lines ``len(allsegs) == len(levels)``, and for\n            filled contour regions ``len(allsegs) = len(levels)-1``. The lists\n            should look like ::\n\n                level0segs = [polygon0, polygon1, ...]\n                polygon0 = [[x0, y0], [x1, y1], ...]\n\n        allkinds : [level0kinds, level1kinds, ...], optional\n            Optional list of all the polygon vertex kinds (code types), as\n            described and used in Path. This is used to allow multiply-\n            connected paths such as holes within filled polygons.\n            If not ``None``, ``len(allkinds) == len(allsegs)``. The lists\n            should look like ::\n\n                level0kinds = [polygon0kinds, ...]\n                polygon0kinds = [vertexcode0, vertexcode1, ...]\n\n            If *allkinds* is not ``None``, usually all polygons for a\n            particular contour level are grouped together so that\n            ``level0segs = [polygon0]`` and ``level0kinds = [polygon0kinds]``.\n\n        **kwargs\n            Keyword arguments are as described in the docstring of\n            `~axes.Axes.contour`.\n        \"\"\"\n        self.ax = ax\n        self.levels = levels\n        self.filled = filled\n        self.linewidths = linewidths\n        self.linestyles = linestyles\n        self.hatches = kwargs.pop('hatches', [None])\n        self.alpha = alpha\n        self.origin = origin\n        self.extent = extent\n        self.colors = colors\n        self.extend = extend\n        self.antialiased = antialiased\n        if self.antialiased is None and self.filled:\n            # Eliminate artifacts; we are not stroking the boundaries.\n            self.antialiased = False\n            # The default for line contours will be taken from the\n            # LineCollection default, which uses :rc:`lines.antialiased`.\n\n        self.nchunk = kwargs.pop('nchunk', 0)\n        self.locator = kwargs.pop('locator', None)\n        if (isinstance(norm, mcolors.LogNorm)\n                or isinstance(self.locator, ticker.LogLocator)):\n            self.logscale = True\n            if norm is None:\n                norm = mcolors.LogNorm()\n        else:\n            self.logscale = False\n\n        cbook._check_in_list([None, 'lower', 'upper', 'image'], origin=origin)\n        if self.extent is not None and len(self.extent) != 4:\n            raise ValueError(\n                \"If given, 'extent' must be None or (x0, x1, y0, y1)\")\n        if self.colors is not None and cmap is not None:\n            raise ValueError('Either colors or cmap must be None')\n        if self.origin == 'image':\n            self.origin = mpl.rcParams['image.origin']\n\n        self._transform = kwargs.pop('transform', None)\n\n        kwargs = self._process_args(*args, **kwargs)\n        self._process_levels()\n\n        if self.colors is not None:\n            ncolors = len(self.levels)\n            if self.filled:\n                ncolors -= 1\n            i0 = 0\n\n            # Handle the case where colors are given for the extended\n            # parts of the contour.\n            extend_min = self.extend in ['min', 'both']\n            extend_max = self.extend in ['max', 'both']\n            use_set_under_over = False\n            # if we are extending the lower end, and we've been given enough\n            # colors then skip the first color in the resulting cmap. For the\n            # extend_max case we don't need to worry about passing more colors\n            # than ncolors as ListedColormap will clip.\n            total_levels = ncolors + int(extend_min) + int(extend_max)\n            if len(self.colors) == total_levels and (extend_min or extend_max):\n                use_set_under_over = True\n                if extend_min:\n                    i0 = 1\n\n            cmap = mcolors.ListedColormap(self.colors[i0:None], N=ncolors)\n\n            if use_set_under_over:\n                if extend_min:\n                    cmap.set_under(self.colors[0])\n                if extend_max:\n                    cmap.set_over(self.colors[-1])\n\n        if self.filled:\n            self.collections = cbook.silent_list('mcoll.PathCollection')\n        else:\n            self.collections = cbook.silent_list('mcoll.LineCollection')\n        # label lists must be initialized here\n        self.labelTexts = []\n        self.labelCValues = []\n\n        kw = {'cmap': cmap}\n        if norm is not None:\n            kw['norm'] = norm\n        # sets self.cmap, norm if needed;\n        cm.ScalarMappable.__init__(self, **kw)\n        if vmin is not None:\n            self.norm.vmin = vmin\n        if vmax is not None:\n            self.norm.vmax = vmax\n        self._process_colors()\n\n        self.allsegs, self.allkinds = self._get_allsegs_and_allkinds()\n\n        if self.filled:\n            if self.linewidths is not None:\n                cbook._warn_external('linewidths is ignored by contourf')\n\n            # Lower and upper contour levels.\n            lowers, uppers = self._get_lowers_and_uppers()\n\n            # Ensure allkinds can be zipped below.\n            if self.allkinds is None:\n                self.allkinds = [None] * len(self.allsegs)\n\n            # Default zorder taken from Collection\n            zorder = kwargs.pop('zorder', 1)\n            for level, level_upper, segs, kinds in \\\n                    zip(lowers, uppers, self.allsegs, self.allkinds):\n                paths = self._make_paths(segs, kinds)\n\n                col = mcoll.PathCollection(\n                    paths,\n                    antialiaseds=(self.antialiased,),\n                    edgecolors='none',\n                    alpha=self.alpha,\n                    transform=self.get_transform(),\n                    zorder=zorder)\n                self.ax.add_collection(col, autolim=False)\n                self.collections.append(col)\n        else:\n            tlinewidths = self._process_linewidths()\n            self.tlinewidths = tlinewidths\n            tlinestyles = self._process_linestyles()\n            aa = self.antialiased\n            if aa is not None:\n                aa = (self.antialiased,)\n            # Default zorder taken from LineCollection\n            zorder = kwargs.pop('zorder', 2)\n            for level, width, lstyle, segs in \\\n                    zip(self.levels, tlinewidths, tlinestyles, self.allsegs):\n                col = mcoll.LineCollection(\n                    segs,\n                    antialiaseds=aa,\n                    linewidths=width,\n                    linestyles=[lstyle],\n                    alpha=self.alpha,\n                    transform=self.get_transform(),\n                    zorder=zorder)\n                col.set_label('_nolegend_')\n                self.ax.add_collection(col, autolim=False)\n                self.collections.append(col)\n\n        for col in self.collections:\n            col.sticky_edges.x[:] = [self._mins[0], self._maxs[0]]\n            col.sticky_edges.y[:] = [self._mins[1], self._maxs[1]]\n        self.ax.update_datalim([self._mins, self._maxs])\n        self.ax.autoscale_view(tight=True)\n\n        self.changed()  # set the colors\n\n        if kwargs:\n            s = \", \".join(map(repr, kwargs))\n            cbook._warn_external('The following kwargs were not used by '\n                                 'contour: ' + s)",
        "begin_line": 733,
        "end_line": 935,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018231540565177758,
            "pseudo_dstar_susp": 0.00019083969465648855,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00019083969465648855,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.contour.ContourSet._get_lowers_and_uppers#1062",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.ContourSet",
        "signature": "lib.matplotlib.contour.ContourSet._get_lowers_and_uppers(self)",
        "snippet": "    def _get_lowers_and_uppers(self):\n        \"\"\"\n        Return ``(lowers, uppers)`` for filled contours.\n        \"\"\"\n        lowers = self._levels[:-1]\n        if self.zmin == lowers[0]:\n            # Include minimum values in lowest interval\n            lowers = lowers.copy()  # so we don't change self._levels\n            if self.logscale:\n                lowers[0] = 0.99 * self.zmin\n            else:\n                lowers[0] -= 1\n        uppers = self._levels[1:]\n        return (lowers, uppers)",
        "begin_line": 1062,
        "end_line": 1075,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.0001353546291283162,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.0001353546291283162,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.contour.ContourSet._autolev#1103",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.ContourSet",
        "signature": "lib.matplotlib.contour.ContourSet._autolev(self, N)",
        "snippet": "    def _autolev(self, N):\n        \"\"\"\n        Select contour levels to span the data.\n\n        The target number of levels, *N*, is used only when the\n        scale is not log and default locator is used.\n\n        We need two more levels for filled contours than for\n        line contours, because for the latter we need to specify\n        the lower and upper boundary of each range. For example,\n        a single contour boundary, say at z = 0, requires only\n        one contour line, but two filled regions, and therefore\n        three levels to provide boundaries for both regions.\n        \"\"\"\n        if self.locator is None:\n            if self.logscale:\n                self.locator = ticker.LogLocator()\n            else:\n                self.locator = ticker.MaxNLocator(N + 1, min_n_ticks=1)\n\n        lev = self.locator.tick_values(self.zmin, self.zmax)\n\n        try:\n            if self.locator._symmetric:\n                return lev\n        except AttributeError:\n            pass\n\n        # Trim excess levels the locator may have supplied.\n        under = np.nonzero(lev < self.zmin)[0]\n        i0 = under[-1] if len(under) else 0\n        over = np.nonzero(lev > self.zmax)[0]\n        i1 = over[0] + 1 if len(over) else len(lev)\n        if self.extend in ('min', 'both'):\n            i0 += 1\n        if self.extend in ('max', 'both'):\n            i1 -= 1\n\n        if i1 - i0 < 3:\n            i0, i1 = 0, len(lev)\n\n        return lev[i0:i1]",
        "begin_line": 1103,
        "end_line": 1144,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001852537977028529,
            "pseudo_dstar_susp": 0.00018615040953090097,
            "pseudo_tarantula_susp": 0.0002188662727073758,
            "pseudo_op2_susp": 0.00018615040953090097,
            "pseudo_barinel_susp": 0.0002188662727073758
        }
    },
    {
        "name": "lib.matplotlib.contour.ContourSet._contour_level_args#1146",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.ContourSet",
        "signature": "lib.matplotlib.contour.ContourSet._contour_level_args(self, z, args)",
        "snippet": "    def _contour_level_args(self, z, args):\n        \"\"\"\n        Determine the contour levels and store in self.levels.\n        \"\"\"\n        if self.levels is None:\n            if len(args) == 0:\n                levels_arg = 7  # Default, hard-wired.\n            else:\n                levels_arg = args[0]\n        else:\n            levels_arg = self.levels\n        if isinstance(levels_arg, Integral):\n            self.levels = self._autolev(levels_arg)\n        else:\n            self.levels = np.asarray(levels_arg).astype(np.float64)\n\n        if not self.filled:\n            inside = (self.levels > self.zmin) & (self.levels < self.zmax)\n            levels_in = self.levels[inside]\n            if len(levels_in) == 0:\n                self.levels = [self.zmin]\n                cbook._warn_external(\n                    \"No contour levels were found within the data range.\")\n\n        if self.filled and len(self.levels) < 2:\n            raise ValueError(\"Filled contours require at least 2 levels.\")\n\n        if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:\n            raise ValueError(\"Contour levels must be increasing\")",
        "begin_line": 1146,
        "end_line": 1174,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018268176835951772,
            "pseudo_dstar_susp": 0.00019065776930409913,
            "pseudo_tarantula_susp": 0.0002072538860103627,
            "pseudo_op2_susp": 0.00019065776930409913,
            "pseudo_barinel_susp": 0.0002072538860103627
        }
    },
    {
        "name": "lib.matplotlib.contour.ContourSet._process_levels#1176",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.ContourSet",
        "signature": "lib.matplotlib.contour.ContourSet._process_levels(self)",
        "snippet": "    def _process_levels(self):\n        \"\"\"\n        Assign values to :attr:`layers` based on :attr:`levels`,\n        adding extended layers as needed if contours are filled.\n\n        For line contours, layers simply coincide with levels;\n        a line is a thin layer.  No extended levels are needed\n        with line contours.\n        \"\"\"\n        # Make a private _levels to include extended regions; we\n        # want to leave the original levels attribute unchanged.\n        # (Colorbar needs this even for line contours.)\n        self._levels = list(self.levels)\n\n        if self.logscale:\n            lower, upper = 1e-250, 1e250\n        else:\n            lower, upper = -1e250, 1e250\n\n        if self.extend in ('both', 'min'):\n            self._levels.insert(0, lower)\n        if self.extend in ('both', 'max'):\n            self._levels.append(upper)\n        self._levels = np.asarray(self._levels)\n\n        if not self.filled:\n            self.layers = self.levels\n            return\n\n        # Layer values are mid-way between levels in screen space.\n        if self.logscale:\n            # Avoid overflow by taking sqrt before multiplying.\n            self.layers = (np.sqrt(self._levels[:-1])\n                           * np.sqrt(self._levels[1:]))\n        else:\n            self.layers = 0.5 * (self._levels[:-1] + self._levels[1:])",
        "begin_line": 1176,
        "end_line": 1211,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016315875346712352,
            "pseudo_dstar_susp": 0.00017930787161556393,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00017930787161556393,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.contour.ContourSet._process_colors#1213",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.ContourSet",
        "signature": "lib.matplotlib.contour.ContourSet._process_colors(self)",
        "snippet": "    def _process_colors(self):\n        \"\"\"\n        Color argument processing for contouring.\n\n        Note that we base the color mapping on the contour levels\n        and layers, not on the actual range of the Z values.  This\n        means we don't have to worry about bad values in Z, and we\n        always have the full dynamic range available for the selected\n        levels.\n\n        The color is based on the midpoint of the layer, except for\n        extended end layers.  By default, the norm vmin and vmax\n        are the extreme values of the non-extended levels.  Hence,\n        the layer color extremes are not the extreme values of\n        the colormap itself, but approach those values as the number\n        of levels increases.  An advantage of this scheme is that\n        line contours, when added to filled contours, take on\n        colors that are consistent with those of the filled regions;\n        for example, a contour line on the boundary between two\n        regions will have a color intermediate between those\n        of the regions.\n\n        \"\"\"\n        self.monochrome = self.cmap.monochrome\n        if self.colors is not None:\n            # Generate integers for direct indexing.\n            i0, i1 = 0, len(self.levels)\n            if self.filled:\n                i1 -= 1\n                # Out of range indices for over and under:\n                if self.extend in ('both', 'min'):\n                    i0 -= 1\n                if self.extend in ('both', 'max'):\n                    i1 += 1\n            self.cvalues = list(range(i0, i1))\n            self.set_norm(mcolors.NoNorm())\n        else:\n            self.cvalues = self.layers\n        self.set_array(self.levels)\n        self.autoscale_None()\n        if self.extend in ('both', 'max', 'min'):\n            self.norm.clip = False",
        "begin_line": 1213,
        "end_line": 1254,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018463810930576072,
            "pseudo_dstar_susp": 0.0001905850962454736,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.0001905850962454736,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.contour.ContourSet._process_linewidths#1258",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.ContourSet",
        "signature": "lib.matplotlib.contour.ContourSet._process_linewidths(self)",
        "snippet": "    def _process_linewidths(self):\n        linewidths = self.linewidths\n        Nlev = len(self.levels)\n        if linewidths is None:\n            tlinewidths = [(mpl.rcParams['lines.linewidth'],)] * Nlev\n        else:\n            if not np.iterable(linewidths):\n                linewidths = [linewidths] * Nlev\n            else:\n                linewidths = list(linewidths)\n                if len(linewidths) < Nlev:\n                    nreps = int(np.ceil(Nlev / len(linewidths)))\n                    linewidths = linewidths * nreps\n                if len(linewidths) > Nlev:\n                    linewidths = linewidths[:Nlev]\n            tlinewidths = [(w,) for w in linewidths]\n        return tlinewidths",
        "begin_line": 1258,
        "end_line": 1274,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016276041666666666,
            "pseudo_dstar_susp": 0.00016969285593076533,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00016969285593076533,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.contour.ContourSet._process_linestyles#1276",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.ContourSet",
        "signature": "lib.matplotlib.contour.ContourSet._process_linestyles(self)",
        "snippet": "    def _process_linestyles(self):\n        linestyles = self.linestyles\n        Nlev = len(self.levels)\n        if linestyles is None:\n            tlinestyles = ['solid'] * Nlev\n            if self.monochrome:\n                neg_ls = mpl.rcParams['contour.negative_linestyle']\n                eps = - (self.zmax - self.zmin) * 1e-15\n                for i, lev in enumerate(self.levels):\n                    if lev < eps:\n                        tlinestyles[i] = neg_ls\n        else:\n            if isinstance(linestyles, str):\n                tlinestyles = [linestyles] * Nlev\n            elif np.iterable(linestyles):\n                tlinestyles = list(linestyles)\n                if len(tlinestyles) < Nlev:\n                    nreps = int(np.ceil(Nlev / len(linestyles)))\n                    tlinestyles = tlinestyles * nreps\n                if len(tlinestyles) > Nlev:\n                    tlinestyles = tlinestyles[:Nlev]\n            else:\n                raise ValueError(\"Unrecognized type for linestyles kwarg\")\n        return tlinestyles",
        "begin_line": 1276,
        "end_line": 1299,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001839587932303164,
            "pseudo_dstar_susp": 0.00018604651162790697,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00018604651162790697,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.contour.ContourSet.get_alpha#1301",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.ContourSet",
        "signature": "lib.matplotlib.contour.ContourSet.get_alpha(self)",
        "snippet": "    def get_alpha(self):\n        \"\"\"returns alpha to be applied to all ContourSet artists\"\"\"\n        return self.alpha",
        "begin_line": 1301,
        "end_line": 1303,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.contour.ContourSet.find_nearest_contour#1313",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.ContourSet",
        "signature": "lib.matplotlib.contour.ContourSet.find_nearest_contour(self, x, y, indices=None, pixel=True)",
        "snippet": "    def find_nearest_contour(self, x, y, indices=None, pixel=True):\n        \"\"\"\n        Finds contour that is closest to a point.  Defaults to\n        measuring distance in pixels (screen space - useful for manual\n        contour labeling), but this can be controlled via a keyword\n        argument.\n\n        Returns a tuple containing the contour, segment, index of\n        segment, x & y of segment point and distance to minimum point.\n\n        Optional keyword arguments:\n\n          *indices*:\n            Indexes of contour levels to consider when looking for\n            nearest point.  Defaults to using all levels.\n\n          *pixel*:\n            If *True*, measure distance in pixel space, if not, measure\n            distance in axes space.  Defaults to *True*.\n\n        \"\"\"\n\n        # This function uses a method that is probably quite\n        # inefficient based on converting each contour segment to\n        # pixel coordinates and then comparing the given point to\n        # those coordinates for each contour.  This will probably be\n        # quite slow for complex contours, but for normal use it works\n        # sufficiently well that the time is not noticeable.\n        # Nonetheless, improvements could probably be made.\n\n        if indices is None:\n            indices = list(range(len(self.levels)))\n\n        dmin = np.inf\n        conmin = None\n        segmin = None\n        xmin = None\n        ymin = None\n\n        point = np.array([x, y])\n\n        for icon in indices:\n            con = self.collections[icon]\n            trans = con.get_transform()\n            paths = con.get_paths()\n\n            for segNum, linepath in enumerate(paths):\n                lc = linepath.vertices\n                # transfer all data points to screen coordinates if desired\n                if pixel:\n                    lc = trans.transform(lc)\n\n                d, xc, leg = _find_closest_point_on_path(lc, point)\n                if d < dmin:\n                    dmin = d\n                    conmin = icon\n                    segmin = segNum\n                    imin = leg[1]\n                    xmin = xc[0]\n                    ymin = xc[1]\n\n        return (conmin, segmin, imin, xmin, ymin, dmin)",
        "begin_line": 1313,
        "end_line": 1374,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018846588767433095,
            "pseudo_dstar_susp": 0.0001541782300339192,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0001541782300339192,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.contour.QuadContourSet._process_args#1399",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.QuadContourSet",
        "signature": "lib.matplotlib.contour.QuadContourSet._process_args(self, *args, **kwargs)",
        "snippet": "    def _process_args(self, *args, **kwargs):\n        \"\"\"\n        Process args and kwargs.\n        \"\"\"\n        if isinstance(args[0], QuadContourSet):\n            if self.levels is None:\n                self.levels = args[0].levels\n            self.zmin = args[0].zmin\n            self.zmax = args[0].zmax\n            self._corner_mask = args[0]._corner_mask\n            contour_generator = args[0]._contour_generator\n            self._mins = args[0]._mins\n            self._maxs = args[0]._maxs\n        else:\n            import matplotlib._contour as _contour\n\n            self._corner_mask = kwargs.pop('corner_mask', None)\n            if self._corner_mask is None:\n                self._corner_mask = mpl.rcParams['contour.corner_mask']\n\n            x, y, z = self._contour_args(args, kwargs)\n\n            _mask = ma.getmask(z)\n            if _mask is ma.nomask or not _mask.any():\n                _mask = None\n\n            contour_generator = _contour.QuadContourGenerator(\n                x, y, z.filled(), _mask, self._corner_mask, self.nchunk)\n\n            t = self.get_transform()\n\n            # if the transform is not trans data, and some part of it\n            # contains transData, transform the xs and ys to data coordinates\n            if (t != self.ax.transData and\n                    any(t.contains_branch_seperately(self.ax.transData))):\n                trans_to_data = t - self.ax.transData\n                pts = (np.vstack([x.flat, y.flat]).T)\n                transformed_pts = trans_to_data.transform(pts)\n                x = transformed_pts[..., 0]\n                y = transformed_pts[..., 1]\n\n            self._mins = [ma.min(x), ma.min(y)]\n            self._maxs = [ma.max(x), ma.max(y)]\n\n        self._contour_generator = contour_generator\n\n        return kwargs",
        "begin_line": 1399,
        "end_line": 1445,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016561775422325274,
            "pseudo_dstar_susp": 0.00018518518518518518,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00018518518518518518,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.contour.QuadContourSet._get_allsegs_and_allkinds#1447",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.QuadContourSet",
        "signature": "lib.matplotlib.contour.QuadContourSet._get_allsegs_and_allkinds(self)",
        "snippet": "    def _get_allsegs_and_allkinds(self):\n        \"\"\"Compute ``allsegs`` and ``allkinds`` using C extension.\"\"\"\n        allsegs = []\n        if self.filled:\n            lowers, uppers = self._get_lowers_and_uppers()\n            allkinds = []\n            for level, level_upper in zip(lowers, uppers):\n                vertices, kinds = \\\n                    self._contour_generator.create_filled_contour(\n                        level, level_upper)\n                allsegs.append(vertices)\n                allkinds.append(kinds)\n        else:\n            allkinds = None\n            for level in self.levels:\n                vertices = self._contour_generator.create_contour(level)\n                allsegs.append(vertices)\n        return allsegs, allkinds",
        "begin_line": 1447,
        "end_line": 1464,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001839587932303164,
            "pseudo_dstar_susp": 0.00018604651162790697,
            "pseudo_tarantula_susp": 0.00021505376344086021,
            "pseudo_op2_susp": 0.00018604651162790697,
            "pseudo_barinel_susp": 0.00021496130696474635
        }
    },
    {
        "name": "lib.matplotlib.contour.QuadContourSet._contour_args#1466",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.QuadContourSet",
        "signature": "lib.matplotlib.contour.QuadContourSet._contour_args(self, args, kwargs)",
        "snippet": "    def _contour_args(self, args, kwargs):\n        if self.filled:\n            fn = 'contourf'\n        else:\n            fn = 'contour'\n        Nargs = len(args)\n        if Nargs <= 2:\n            z = ma.asarray(args[0], dtype=np.float64)\n            x, y = self._initialize_x_y(z)\n            args = args[1:]\n        elif Nargs <= 4:\n            x, y, z = self._check_xyz(args[:3], kwargs)\n            args = args[3:]\n        else:\n            raise TypeError(\"Too many arguments to %s; see help(%s)\" %\n                            (fn, fn))\n        z = ma.masked_invalid(z, copy=False)\n        self.zmax = float(z.max())\n        self.zmin = float(z.min())\n        if self.logscale and self.zmin <= 0:\n            z = ma.masked_where(z <= 0, z)\n            cbook._warn_external('Log scale: values of z <= 0 have been '\n                                 'masked')\n            self.zmin = float(z.min())\n        self._contour_level_args(z, args)\n        return (x, y, z)",
        "begin_line": 1466,
        "end_line": 1491,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018115942028985507,
            "pseudo_dstar_susp": 0.00019805902158843335,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00019805902158843335,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.contour.QuadContourSet._check_xyz#1493",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.QuadContourSet",
        "signature": "lib.matplotlib.contour.QuadContourSet._check_xyz(self, args, kwargs)",
        "snippet": "    def _check_xyz(self, args, kwargs):\n        \"\"\"\n        Check that the shapes of the input arrays match; if x and y are 1D,\n        convert them to 2D using meshgrid.\n        \"\"\"\n        x, y = args[:2]\n        kwargs = self.ax._process_unit_info(xdata=x, ydata=y, kwargs=kwargs)\n        x = self.ax.convert_xunits(x)\n        y = self.ax.convert_yunits(y)\n\n        x = np.asarray(x, dtype=np.float64)\n        y = np.asarray(y, dtype=np.float64)\n        z = ma.asarray(args[2], dtype=np.float64)\n\n        if z.ndim != 2:\n            raise TypeError(f\"Input z must be 2D, not {z.ndim}D\")\n        if z.shape[0] < 2 or z.shape[1] < 2:\n            raise TypeError(f\"Input z must be at least a (2, 2) shaped array, \"\n                            f\"but has shape {z.shape}\")\n        Ny, Nx = z.shape\n\n        if x.ndim != y.ndim:\n            raise TypeError(f\"Number of dimensions of x ({x.ndim}) and y \"\n                            f\"({y.ndim}) do not match\")\n        if x.ndim == 1:\n            nx, = x.shape\n            ny, = y.shape\n            if nx != Nx:\n                raise TypeError(f\"Length of x ({nx}) must match number of \"\n                                f\"columns in z ({Nx})\")\n            if ny != Ny:\n                raise TypeError(f\"Length of y ({ny}) must match number of \"\n                                f\"rows in z ({Ny})\")\n            x, y = np.meshgrid(x, y)\n        elif x.ndim == 2:\n            if x.shape != z.shape:\n                raise TypeError(\n                    f\"Shapes of x {x.shape} and z {z.shape} do not match\")\n            if y.shape != z.shape:\n                raise TypeError(\n                    f\"Shapes of y {y.shape} and z {z.shape} do not match\")\n        else:\n            raise TypeError(f\"Inputs x and y must be 1D or 2D, not {x.ndim}D\")\n\n        return x, y, z",
        "begin_line": 1493,
        "end_line": 1537,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016589250165892502,
            "pseudo_dstar_susp": 0.00015984654731457802,
            "pseudo_tarantula_susp": 0.000228675966155957,
            "pseudo_op2_susp": 0.00015984654731457802,
            "pseudo_barinel_susp": 0.000228675966155957
        }
    },
    {
        "name": "lib.matplotlib.contour.QuadContourSet._initialize_x_y#1539",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.QuadContourSet",
        "signature": "lib.matplotlib.contour.QuadContourSet._initialize_x_y(self, z)",
        "snippet": "    def _initialize_x_y(self, z):\n        \"\"\"\n        Return X, Y arrays such that contour(Z) will match imshow(Z)\n        if origin is not None.\n        The center of pixel Z[i, j] depends on origin:\n        if origin is None, x = j, y = i;\n        if origin is 'lower', x = j + 0.5, y = i + 0.5;\n        if origin is 'upper', x = j + 0.5, y = Nrows - i - 0.5\n        If extent is not None, x and y will be scaled to match,\n        as in imshow.\n        If origin is None and extent is not None, then extent\n        will give the minimum and maximum values of x and y.\n        \"\"\"\n        if z.ndim != 2:\n            raise TypeError(f\"Input z must be 2D, not {z.ndim}D\")\n        elif z.shape[0] < 2 or z.shape[1] < 2:\n            raise TypeError(f\"Input z must be at least a (2, 2) shaped array, \"\n                            f\"but has shape {z.shape}\")\n        else:\n            Ny, Nx = z.shape\n        if self.origin is None:  # Not for image-matching.\n            if self.extent is None:\n                return np.meshgrid(np.arange(Nx), np.arange(Ny))\n            else:\n                x0, x1, y0, y1 = self.extent\n                x = np.linspace(x0, x1, Nx)\n                y = np.linspace(y0, y1, Ny)\n                return np.meshgrid(x, y)\n        # Match image behavior:\n        if self.extent is None:\n            x0, x1, y0, y1 = (0, Nx, 0, Ny)\n        else:\n            x0, x1, y0, y1 = self.extent\n        dx = (x1 - x0) / Nx\n        dy = (y1 - y0) / Ny\n        x = x0 + (np.arange(Nx) + 0.5) * dx\n        y = y0 + (np.arange(Ny) + 0.5) * dy\n        if self.origin == 'upper':\n            y = y[::-1]\n        return np.meshgrid(x, y)",
        "begin_line": 1539,
        "end_line": 1578,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018165304268846503,
            "pseudo_dstar_susp": 0.0001608234158893535,
            "pseudo_tarantula_susp": 0.0003450655624568668,
            "pseudo_op2_susp": 0.0001608234158893535,
            "pseudo_barinel_susp": 0.00034494653328734045
        }
    },
    {
        "name": "lib.matplotlib.stackplot.stackplot#16",
        "src_path": "lib/matplotlib/stackplot.py",
        "class_name": "lib.matplotlib.stackplot",
        "signature": "lib.matplotlib.stackplot.stackplot(axes, x, *args, labels=(), colors=None, baseline='zero', **kwargs)",
        "snippet": "def stackplot(axes, x, *args,\n              labels=(), colors=None, baseline='zero',\n              **kwargs):\n    \"\"\"\n    Draw a stacked area plot.\n\n    Parameters\n    ----------\n    x : 1d array of dimension N\n\n    y : 2d array (dimension MxN), or sequence of 1d arrays (each dimension 1xN)\n\n        The data is assumed to be unstacked. Each of the following\n        calls is legal::\n\n            stackplot(x, y)               # where y is MxN\n            stackplot(x, y1, y2, y3, y4)  # where y1, y2, y3, y4, are all 1xNm\n\n    baseline : {'zero', 'sym', 'wiggle', 'weighted_wiggle'}\n        Method used to calculate the baseline:\n\n        - ``'zero'``: Constant zero baseline, i.e. a simple stacked plot.\n        - ``'sym'``:  Symmetric around zero and is sometimes called\n          'ThemeRiver'.\n        - ``'wiggle'``: Minimizes the sum of the squared slopes.\n        - ``'weighted_wiggle'``: Does the same but weights to account for\n          size of each layer. It is also called 'Streamgraph'-layout. More\n          details can be found at http://leebyron.com/streamgraph/.\n\n    labels : Length N sequence of strings\n        Labels to assign to each data series.\n\n    colors : Length N sequence of colors\n        A list or tuple of colors. These will be cycled through and used to\n        colour the stacked areas.\n\n    **kwargs\n        All other keyword arguments are passed to `Axes.fill_between()`.\n\n\n    Returns\n    -------\n    list : list of `.PolyCollection`\n        A list of `.PolyCollection` instances, one for each element in the\n        stacked area plot.\n    \"\"\"\n\n    y = np.row_stack(args)\n\n    labels = iter(labels)\n    if colors is not None:\n        axes.set_prop_cycle(color=colors)\n\n    # Assume data passed has not been 'stacked', so stack it here.\n    # We'll need a float buffer for the upcoming calculations.\n    stack = np.cumsum(y, axis=0, dtype=np.promote_types(y.dtype, np.float32))\n\n    cbook._check_in_list(['zero', 'sym', 'wiggle', 'weighted_wiggle'],\n                         baseline=baseline)\n    if baseline == 'zero':\n        first_line = 0.\n\n    elif baseline == 'sym':\n        first_line = -np.sum(y, 0) * 0.5\n        stack += first_line[None, :]\n\n    elif baseline == 'wiggle':\n        m = y.shape[0]\n        first_line = (y * (m - 0.5 - np.arange(m)[:, None])).sum(0)\n        first_line /= -m\n        stack += first_line\n\n    elif baseline == 'weighted_wiggle':\n        total = np.sum(y, 0)\n        # multiply by 1/total (or zero) to avoid infinities in the division:\n        inv_total = np.zeros_like(total)\n        mask = total > 0\n        inv_total[mask] = 1.0 / total[mask]\n        increase = np.hstack((y[:, 0:1], np.diff(y)))\n        below_size = total - stack\n        below_size += 0.5 * y\n        move_up = below_size * inv_total\n        move_up[:, 0] = 0.5\n        center = (move_up - 0.5) * increase\n        center = np.cumsum(center.sum(0))\n        first_line = center - 0.5 * total\n        stack += first_line\n\n    # Color between x = 0 and the first array.\n    color = axes._get_lines.get_next_color()\n    coll = axes.fill_between(x, first_line, stack[0, :],\n                             facecolor=color, label=next(labels, None),\n                             **kwargs)\n    coll.sticky_edges.y[:] = [0]\n    r = [coll]\n\n    # Color between array i-1 and array i\n    for i in range(len(y) - 1):\n        color = axes._get_lines.get_next_color()\n        r.append(axes.fill_between(x, stack[i, :], stack[i + 1, :],\n                                   facecolor=color, label=next(labels, None),\n                                   **kwargs))\n    return r",
        "begin_line": 16,
        "end_line": 118,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001380071763731714,
            "pseudo_dstar_susp": 0.00013869625520110957,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00013869625520110957,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.texmanager.TexManager.__new__#103",
        "src_path": "lib/matplotlib/texmanager.py",
        "class_name": "lib.matplotlib.texmanager.TexManager",
        "signature": "lib.matplotlib.texmanager.TexManager.__new__(cls)",
        "snippet": "    def __new__(cls):\n        self = object.__new__(cls)\n        self._reinit()\n        return self",
        "begin_line": 103,
        "end_line": 106,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.texmanager.TexManager._reinit#108",
        "src_path": "lib/matplotlib/texmanager.py",
        "class_name": "lib.matplotlib.texmanager.TexManager",
        "signature": "lib.matplotlib.texmanager.TexManager._reinit(self)",
        "snippet": "    def _reinit(self):\n        if self.texcache is None:\n            raise RuntimeError('Cannot create TexManager, as there is no '\n                               'cache directory available')\n\n        Path(self.texcache).mkdir(parents=True, exist_ok=True)\n        ff = rcParams['font.family']\n        if len(ff) == 1 and ff[0].lower() in self.font_families:\n            self.font_family = ff[0].lower()\n        elif isinstance(ff, str) and ff.lower() in self.font_families:\n            self.font_family = ff.lower()\n        else:\n            _log.info('font.family must be one of (%s) when text.usetex is '\n                      'True. serif will be used by default.',\n                      ', '.join(self.font_families))\n            self.font_family = 'serif'\n\n        fontconfig = [self.font_family]\n        for font_family in self.font_families:\n            font_family_attr = font_family.replace('-', '_')\n            for font in rcParams['font.' + font_family]:\n                if font.lower() in self.font_info:\n                    setattr(self, font_family_attr,\n                            self.font_info[font.lower()])\n                    _log.debug('family: %s, font: %s, info: %s',\n                               font_family, font, self.font_info[font.lower()])\n                    break\n                else:\n                    _log.debug('%s font is not compatible with usetex.',\n                               font_family)\n            else:\n                _log.info('No LaTeX-compatible font found for the %s font '\n                          'family in rcParams. Using default.', font_family)\n                setattr(self, font_family_attr, self.font_info[font_family])\n            fontconfig.append(getattr(self, font_family_attr)[0])\n        # Add a hash of the latex preamble to self._fontconfig so that the\n        # correct png is selected for strings rendered with same font and dpi\n        # even if the latex preamble changes within the session\n        preamble_bytes = self.get_custom_preamble().encode('utf-8')\n        fontconfig.append(hashlib.md5(preamble_bytes).hexdigest())\n        self._fontconfig = ''.join(fontconfig)\n\n        # The following packages and commands need to be included in the latex\n        # file's preamble:\n        cmd = [self.serif[1], self.sans_serif[1], self.monospace[1]]\n        if self.font_family == 'cursive':\n            cmd.append(self.cursive[1])\n        self._font_preamble = '\\n'.join(\n            [r'\\usepackage{type1cm}'] + cmd + [r'\\usepackage{textcomp}'])",
        "begin_line": 108,
        "end_line": 156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.texmanager.TexManager.get_font_config#167",
        "src_path": "lib/matplotlib/texmanager.py",
        "class_name": "lib.matplotlib.texmanager.TexManager",
        "signature": "lib.matplotlib.texmanager.TexManager.get_font_config(self)",
        "snippet": "    def get_font_config(self):\n        \"\"\"Reinitializes self if relevant rcParams on have changed.\"\"\"\n        if self._rc_cache is None:\n            self._rc_cache = dict.fromkeys(self._rc_cache_keys)\n        changed = [par for par in self._rc_cache_keys\n                   if rcParams[par] != self._rc_cache[par]]\n        if changed:\n            _log.debug('following keys changed: %s', changed)\n            for k in changed:\n                _log.debug('%-20s: %-10s -> %-10s',\n                           k, self._rc_cache[k], rcParams[k])\n                # deepcopy may not be necessary, but feels more future-proof\n                self._rc_cache[k] = copy.deepcopy(rcParams[k])\n            _log.debug('RE-INIT\\nold fontconfig: %s', self._fontconfig)\n            self._reinit()\n        _log.debug('fontconfig: %s', self._fontconfig)\n        return self._fontconfig",
        "begin_line": 167,
        "end_line": 183,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.texmanager.TexManager.get_custom_preamble#191",
        "src_path": "lib/matplotlib/texmanager.py",
        "class_name": "lib.matplotlib.texmanager.TexManager",
        "signature": "lib.matplotlib.texmanager.TexManager.get_custom_preamble(self)",
        "snippet": "    def get_custom_preamble(self):\n        \"\"\"Return a string containing user additions to the tex preamble.\"\"\"\n        return rcParams['text.latex.preamble']",
        "begin_line": 191,
        "end_line": 193,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpecBase.__init__#31",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpecBase",
        "signature": "lib.matplotlib.gridspec.GridSpecBase.__init__(self, nrows, ncols, height_ratios=None, width_ratios=None)",
        "snippet": "    def __init__(self, nrows, ncols, height_ratios=None, width_ratios=None):\n        \"\"\"\n        Parameters\n        ----------\n        nrows, ncols : int\n            The number of rows and columns of the grid.\n        width_ratios : array-like of length *ncols*, optional\n            Defines the relative widths of the columns. Each column gets a\n            relative width of ``width_ratios[i] / sum(width_ratios)``.\n            If not given, all columns will have the same width.\n        height_ratios : array-like of length *nrows*, optional\n            Defines the relative heights of the rows. Each column gets a\n            relative height of ``height_ratios[i] / sum(height_ratios)``.\n            If not given, all rows will have the same height.\n        \"\"\"\n        self._nrows, self._ncols = nrows, ncols\n        self.set_height_ratios(height_ratios)\n        self.set_width_ratios(width_ratios)",
        "begin_line": 31,
        "end_line": 48,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000689655172413793,
            "pseudo_dstar_susp": 0.0008718395815170009,
            "pseudo_tarantula_susp": 0.0001569612305760477,
            "pseudo_op2_susp": 0.0008718395815170009,
            "pseudo_barinel_susp": 0.0001569612305760477
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpecBase.get_geometry#67",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpecBase",
        "signature": "lib.matplotlib.gridspec.GridSpecBase.get_geometry(self)",
        "snippet": "    def get_geometry(self):\n        \"\"\"\n        Return a tuple containing the number of rows and columns in the grid.\n        \"\"\"\n        return self._nrows, self._ncols",
        "begin_line": 67,
        "end_line": 71,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006844626967830253,
            "pseudo_dstar_susp": 0.000846740050804403,
            "pseudo_tarantula_susp": 0.00015760441292356187,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.00015760441292356187
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpecBase.set_width_ratios#93",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpecBase",
        "signature": "lib.matplotlib.gridspec.GridSpecBase.set_width_ratios(self, width_ratios)",
        "snippet": "    def set_width_ratios(self, width_ratios):\n        \"\"\"\n        Set the relative widths of the columns.\n\n        *width_ratios* must be of length *ncols*. Each column gets a relative\n        width of ``width_ratios[i] / sum(width_ratios)``.\n        \"\"\"\n        if width_ratios is not None and len(width_ratios) != self._ncols:\n            raise ValueError('Expected the given number of width ratios to '\n                             'match the number of columns of the grid')\n        self._col_width_ratios = width_ratios",
        "begin_line": 93,
        "end_line": 103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000758150113722517,
            "pseudo_dstar_susp": 0.0020920502092050207,
            "pseudo_tarantula_susp": 0.00016046213093709883,
            "pseudo_op2_susp": 0.0020920502092050207,
            "pseudo_barinel_susp": 0.00016046213093709883
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpecBase.get_width_ratios#105",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpecBase",
        "signature": "lib.matplotlib.gridspec.GridSpecBase.get_width_ratios(self)",
        "snippet": "    def get_width_ratios(self):\n        \"\"\"\n        Return the width ratios.\n\n        This is *None* if no width ratios have been set explicitly.\n        \"\"\"\n        return self._col_width_ratios",
        "begin_line": 105,
        "end_line": 111,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005973715651135006,
            "pseudo_dstar_susp": 0.00036403349108117945,
            "pseudo_tarantula_susp": 0.000328515111695138,
            "pseudo_op2_susp": 0.00036403349108117945,
            "pseudo_barinel_susp": 0.000328515111695138
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpecBase.set_height_ratios#113",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpecBase",
        "signature": "lib.matplotlib.gridspec.GridSpecBase.set_height_ratios(self, height_ratios)",
        "snippet": "    def set_height_ratios(self, height_ratios):\n        \"\"\"\n        Set the relative heights of the rows.\n\n        *height_ratios* must be of length *nrows*. Each row gets a relative\n        height of ``height_ratios[i] / sum(height_ratios)``.\n        \"\"\"\n        if height_ratios is not None and len(height_ratios) != self._nrows:\n            raise ValueError('Expected the given number of height ratios to '\n                             'match the number of rows of the grid')\n        self._row_height_ratios = height_ratios",
        "begin_line": 113,
        "end_line": 123,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006944444444444445,
            "pseudo_dstar_susp": 0.0017006802721088435,
            "pseudo_tarantula_susp": 0.0001579778830963665,
            "pseudo_op2_susp": 0.0017035775127768314,
            "pseudo_barinel_susp": 0.0001579778830963665
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpecBase.get_height_ratios#125",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpecBase",
        "signature": "lib.matplotlib.gridspec.GridSpecBase.get_height_ratios(self)",
        "snippet": "    def get_height_ratios(self):\n        \"\"\"\n        Return the height ratios.\n\n        This is *None* if no height ratios have been set explicitly.\n        \"\"\"\n        return self._row_height_ratios",
        "begin_line": 125,
        "end_line": 131,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006150061500615006,
            "pseudo_dstar_susp": 0.00037243947858472997,
            "pseudo_tarantula_susp": 0.00034129692832764505,
            "pseudo_op2_susp": 0.00037243947858472997,
            "pseudo_barinel_susp": 0.00034129692832764505
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpecBase.get_grid_positions#133",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpecBase",
        "signature": "lib.matplotlib.gridspec.GridSpecBase.get_grid_positions(self, fig, raw=False)",
        "snippet": "    def get_grid_positions(self, fig, raw=False):\n        \"\"\"\n        Return the positions of the grid cells in figure coordinates.\n\n        Parameters\n        ----------\n        fig : `~matplotlib.figure.Figure`\n            The figure the grid should be applied to. The subplot parameters\n            (margins and spacing between subplots) are taken from *fig*.\n        raw : bool, default: False\n            If *True*, the subplot parameters of the figure are not taken\n            into account. The grid spans the range [0, 1] in both directions\n            without margins and there is no space between grid cells. This is\n            used for constrained_layout.\n\n        Returns\n        -------\n        bottoms, tops, lefts, rights : array\n            The bottom, top, left, right positions of the grid cells in\n            figure coordinates.\n        \"\"\"\n        nrows, ncols = self.get_geometry()\n\n        if raw:\n            left = 0.\n            right = 1.\n            bottom = 0.\n            top = 1.\n            wspace = 0.\n            hspace = 0.\n        else:\n            subplot_params = self.get_subplot_params(fig)\n            left = subplot_params.left\n            right = subplot_params.right\n            bottom = subplot_params.bottom\n            top = subplot_params.top\n            wspace = subplot_params.wspace\n            hspace = subplot_params.hspace\n        tot_width = right - left\n        tot_height = top - bottom\n\n        # calculate accumulated heights of columns\n        cell_h = tot_height / (nrows + hspace*(nrows-1))\n        sep_h = hspace * cell_h\n        if self._row_height_ratios is not None:\n            norm = cell_h * nrows / sum(self._row_height_ratios)\n            cell_heights = [r * norm for r in self._row_height_ratios]\n        else:\n            cell_heights = [cell_h] * nrows\n        sep_heights = [0] + ([sep_h] * (nrows-1))\n        cell_hs = np.cumsum(np.column_stack([sep_heights, cell_heights]).flat)\n\n        # calculate accumulated widths of rows\n        cell_w = tot_width / (ncols + wspace*(ncols-1))\n        sep_w = wspace * cell_w\n        if self._col_width_ratios is not None:\n            norm = cell_w * ncols / sum(self._col_width_ratios)\n            cell_widths = [r * norm for r in self._col_width_ratios]\n        else:\n            cell_widths = [cell_w] * ncols\n        sep_widths = [0] + ([sep_w] * (ncols-1))\n        cell_ws = np.cumsum(np.column_stack([sep_widths, cell_widths]).flat)\n\n        fig_tops, fig_bottoms = (top - cell_hs).reshape((-1, 2)).T\n        fig_lefts, fig_rights = (left + cell_ws).reshape((-1, 2)).T\n        return fig_bottoms, fig_tops, fig_lefts, fig_rights",
        "begin_line": 133,
        "end_line": 198,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009009009009009009,
            "pseudo_dstar_susp": 0.0047169811320754715,
            "pseudo_tarantula_susp": 0.00018825301204819278,
            "pseudo_op2_susp": 0.0047169811320754715,
            "pseudo_barinel_susp": 0.00018825301204819278
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpecBase.__getitem__#200",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpecBase",
        "signature": "lib.matplotlib.gridspec.GridSpecBase.__getitem__(self, key)",
        "snippet": "    def __getitem__(self, key):\n        \"\"\"Create and return a `.SubplotSpec` instance.\"\"\"\n        nrows, ncols = self.get_geometry()\n\n        def _normalize(key, size, axis):  # Includes last index.\n            orig_key = key\n            if isinstance(key, slice):\n                start, stop, _ = key.indices(size)\n                if stop > start:\n                    return start, stop - 1\n                raise IndexError(\"GridSpec slice would result in no space \"\n                                 \"allocated for subplot\")\n            else:\n                if key < 0:\n                    key = key + size\n                if 0 <= key < size:\n                    return key, key\n                elif axis is not None:\n                    raise IndexError(f\"index {orig_key} is out of bounds for \"\n                                     f\"axis {axis} with size {size}\")\n                else:  # flat index\n                    raise IndexError(f\"index {orig_key} is out of bounds for \"\n                                     f\"GridSpec with size {size}\")\n\n        if isinstance(key, tuple):\n            try:\n                k1, k2 = key\n            except ValueError:\n                raise ValueError(\"unrecognized subplot spec\")\n            num1, num2 = np.ravel_multi_index(\n                [_normalize(k1, nrows, 0), _normalize(k2, ncols, 1)],\n                (nrows, ncols))\n        else:  # Single key\n            num1, num2 = _normalize(key, nrows * ncols, None)\n\n        return SubplotSpec(self, num1, num2)",
        "begin_line": 200,
        "end_line": 235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007331378299120235,
            "pseudo_dstar_susp": 0.00186219739292365,
            "pseudo_tarantula_susp": 0.0001794043774668102,
            "pseudo_op2_susp": 0.0018656716417910447,
            "pseudo_barinel_susp": 0.0001794043774668102
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpecBase._normalize#204",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpecBase",
        "signature": "lib.matplotlib.gridspec.GridSpecBase._normalize(key, size, axis)",
        "snippet": "        def _normalize(key, size, axis):  # Includes last index.\n            orig_key = key\n            if isinstance(key, slice):\n                start, stop, _ = key.indices(size)\n                if stop > start:\n                    return start, stop - 1\n                raise IndexError(\"GridSpec slice would result in no space \"\n                                 \"allocated for subplot\")\n            else:\n                if key < 0:\n                    key = key + size\n                if 0 <= key < size:\n                    return key, key\n                elif axis is not None:\n                    raise IndexError(f\"index {orig_key} is out of bounds for \"\n                                     f\"axis {axis} with size {size}\")\n                else:  # flat index\n                    raise IndexError(f\"index {orig_key} is out of bounds for \"\n                                     f\"GridSpec with size {size}\")",
        "begin_line": 204,
        "end_line": 222,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00078125,
            "pseudo_dstar_susp": 0.001718213058419244,
            "pseudo_tarantula_susp": 0.000171939477303989,
            "pseudo_op2_susp": 0.001718213058419244,
            "pseudo_barinel_susp": 0.000171939477303989
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpec.__init__#246",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpec",
        "signature": "lib.matplotlib.gridspec.GridSpec.__init__(self, nrows, ncols, figure=None, left=None, bottom=None, right=None, top=None, wspace=None, hspace=None, width_ratios=None, height_ratios=None)",
        "snippet": "    def __init__(self, nrows, ncols, figure=None,\n                 left=None, bottom=None, right=None, top=None,\n                 wspace=None, hspace=None,\n                 width_ratios=None, height_ratios=None):\n        \"\"\"\n        Parameters\n        ----------\n        nrows, ncols : int\n            The number of rows and columns of the grid.\n\n        figure : `~.figure.Figure`, optional\n            Only used for constrained layout to create a proper layoutbox.\n\n        left, right, top, bottom : float, optional\n            Extent of the subplots as a fraction of figure width or height.\n            Left cannot be larger than right, and bottom cannot be larger than\n            top. If not given, the values will be inferred from a figure or\n            rcParams at draw time. See also `GridSpec.get_subplot_params`.\n\n        wspace : float, optional\n            The amount of width reserved for space between subplots,\n            expressed as a fraction of the average axis width.\n            If not given, the values will be inferred from a figure or\n            rcParams when necessary. See also `GridSpec.get_subplot_params`.\n\n        hspace : float, optional\n            The amount of height reserved for space between subplots,\n            expressed as a fraction of the average axis height.\n            If not given, the values will be inferred from a figure or\n            rcParams when necessary. See also `GridSpec.get_subplot_params`.\n\n        width_ratios : array-like of length *ncols*, optional\n            Defines the relative widths of the columns. Each column gets a\n            relative width of ``width_ratios[i] / sum(width_ratios)``.\n            If not given, all columns will have the same width.\n\n        height_ratios : array-like of length *nrows*, optional\n            Defines the relative heights of the rows. Each column gets a\n            relative height of ``height_ratios[i] / sum(height_ratios)``.\n            If not given, all rows will have the same height.\n\n        \"\"\"\n        self.left = left\n        self.bottom = bottom\n        self.right = right\n        self.top = top\n        self.wspace = wspace\n        self.hspace = hspace\n        self.figure = figure\n\n        GridSpecBase.__init__(self, nrows, ncols,\n                              width_ratios=width_ratios,\n                              height_ratios=height_ratios)\n\n        if self.figure is None or not self.figure.get_constrained_layout():\n            self._layoutbox = None\n        else:\n            self.figure.init_layoutbox()\n            self._layoutbox = layoutbox.LayoutBox(\n                parent=self.figure._layoutbox,\n                name='gridspec' + layoutbox.seq_id(),\n                artist=self)",
        "begin_line": 246,
        "end_line": 307,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006293266205160479,
            "pseudo_dstar_susp": 0.0007974481658692185,
            "pseudo_tarantula_susp": 0.0003450655624568668,
            "pseudo_op2_susp": 0.0007974481658692185,
            "pseudo_barinel_susp": 0.00034494653328734045
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpec.__getstate__#314",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpec",
        "signature": "lib.matplotlib.gridspec.GridSpec.__getstate__(self)",
        "snippet": "    def __getstate__(self):\n        state = self.__dict__\n        try:\n            state.pop('_layoutbox')\n        except KeyError:\n            pass\n        return state",
        "begin_line": 314,
        "end_line": 320,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpec.__setstate__#322",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpec",
        "signature": "lib.matplotlib.gridspec.GridSpec.__setstate__(self, state)",
        "snippet": "    def __setstate__(self, state):\n        self.__dict__ = state\n        # layoutboxes don't survive pickling...\n        self._layoutbox = None",
        "begin_line": 322,
        "end_line": 325,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpec.get_subplot_params#366",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpec",
        "signature": "lib.matplotlib.gridspec.GridSpec.get_subplot_params(self, figure=None)",
        "snippet": "    def get_subplot_params(self, figure=None):\n        \"\"\"\n        Return the `~.SubplotParams` for the GridSpec.\n\n        In order of precedence the values are taken from\n\n        - non-*None* attributes of the GridSpec\n        - the provided *figure*\n        - :rc:`figure.subplot.*`\n        \"\"\"\n        if figure is None:\n            kw = {k: rcParams[\"figure.subplot.\"+k] for k in self._AllowedKeys}\n            subplotpars = mpl.figure.SubplotParams(**kw)\n        else:\n            subplotpars = copy.copy(figure.subplotpars)\n\n        subplotpars.update(**{k: getattr(self, k) for k in self._AllowedKeys})\n\n        return subplotpars",
        "begin_line": 366,
        "end_line": 384,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00044014084507042255,
            "pseudo_dstar_susp": 0.0004426737494466578,
            "pseudo_tarantula_susp": 0.00032690421706440013,
            "pseudo_op2_susp": 0.0004426737494466578,
            "pseudo_barinel_susp": 0.00032690421706440013
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpec.locally_modified_subplot_params#386",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpec",
        "signature": "lib.matplotlib.gridspec.GridSpec.locally_modified_subplot_params(self)",
        "snippet": "    def locally_modified_subplot_params(self):\n        \"\"\"\n        Return a list of the names of the subplot parameters explicitly set\n        in the GridSpec.\n\n        This is a subset of the attributes of `.SubplotParams`.\n        \"\"\"\n        return [k for k in self._AllowedKeys if getattr(self, k)]",
        "begin_line": 386,
        "end_line": 393,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpecFromSubplotSpec.__init__#436",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpecFromSubplotSpec",
        "signature": "lib.matplotlib.gridspec.GridSpecFromSubplotSpec.__init__(self, nrows, ncols, subplot_spec, wspace=None, hspace=None, height_ratios=None, width_ratios=None)",
        "snippet": "    def __init__(self, nrows, ncols,\n                 subplot_spec,\n                 wspace=None, hspace=None,\n                 height_ratios=None, width_ratios=None):\n        \"\"\"\n        The number of rows and number of columns of the grid need to\n        be set. An instance of SubplotSpec is also needed to be set\n        from which the layout parameters will be inherited. The wspace\n        and hspace of the layout can be optionally specified or the\n        default values (from the figure or rcParams) will be used.\n        \"\"\"\n        self._wspace = wspace\n        self._hspace = hspace\n        self._subplot_spec = subplot_spec\n        GridSpecBase.__init__(self, nrows, ncols,\n                              width_ratios=width_ratios,\n                              height_ratios=height_ratios)\n        # do the layoutboxes\n        subspeclb = subplot_spec._layoutbox\n        if subspeclb is None:\n            self._layoutbox = None\n        else:\n            # OK, this is needed to divide the figure.\n            self._layoutbox = subspeclb.layout_from_subplotspec(\n                    subplot_spec,\n                    name=subspeclb.name + '.gridspec' + layoutbox.seq_id(),\n                    artist=self)",
        "begin_line": 436,
        "end_line": 462,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpecFromSubplotSpec.get_subplot_params#464",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpecFromSubplotSpec",
        "signature": "lib.matplotlib.gridspec.GridSpecFromSubplotSpec.get_subplot_params(self, figure=None)",
        "snippet": "    def get_subplot_params(self, figure=None):\n        \"\"\"Return a dictionary of subplot layout parameters.\n        \"\"\"\n        hspace = (self._hspace if self._hspace is not None\n                  else figure.subplotpars.hspace if figure is not None\n                  else rcParams[\"figure.subplot.hspace\"])\n        wspace = (self._wspace if self._wspace is not None\n                  else figure.subplotpars.wspace if figure is not None\n                  else rcParams[\"figure.subplot.wspace\"])\n\n        figbox = self._subplot_spec.get_position(figure)\n        left, bottom, right, top = figbox.extents\n\n        return mpl.figure.SubplotParams(left=left, right=right,\n                                        bottom=bottom, top=top,\n                                        wspace=wspace, hspace=hspace)",
        "begin_line": 464,
        "end_line": 479,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.__init__#508",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.__init__(self, gridspec, num1, num2=None)",
        "snippet": "    def __init__(self, gridspec, num1, num2=None):\n        self._gridspec = gridspec\n        self.num1 = num1\n        self.num2 = num2\n        if gridspec._layoutbox is not None:\n            glb = gridspec._layoutbox\n            # So note that here we don't assign any layout yet,\n            # just make the layoutbox that will contain all items\n            # associated w/ this axis.  This can include other axes like\n            # a colorbar or a legend.\n            self._layoutbox = layoutbox.LayoutBox(\n                    parent=glb,\n                    name=glb.name + '.ss' + layoutbox.seq_id(),\n                    artist=self)\n        else:\n            self._layoutbox = None",
        "begin_line": 508,
        "end_line": 523,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004426737494466578,
            "pseudo_dstar_susp": 0.0004422821760283061,
            "pseudo_tarantula_susp": 0.0003450655624568668,
            "pseudo_op2_susp": 0.0004422821760283061,
            "pseudo_barinel_susp": 0.00034494653328734045
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.num2#529",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.num2(self)",
        "snippet": "    def num2(self):\n        return self.num1 if self._num2 is None else self._num2",
        "begin_line": 529,
        "end_line": 530,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003477051460361613,
            "pseudo_dstar_susp": 0.0004422821760283061,
            "pseudo_tarantula_susp": 0.00014245014245014244,
            "pseudo_op2_susp": 0.0004422821760283061,
            "pseudo_barinel_susp": 0.00014245014245014244
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.num2#533",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.num2(self, value)",
        "snippet": "    def num2(self, value):\n        self._num2 = value",
        "begin_line": 533,
        "end_line": 534,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00034928396786587494,
            "pseudo_dstar_susp": 0.0004432624113475177,
            "pseudo_tarantula_susp": 0.00014438348252959862,
            "pseudo_op2_susp": 0.0004432624113475177,
            "pseudo_barinel_susp": 0.00014438348252959862
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.__getstate__#536",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.__getstate__(self)",
        "snippet": "    def __getstate__(self):\n        state = self.__dict__\n        try:\n            state.pop('_layoutbox')\n        except KeyError:\n            pass\n        return state",
        "begin_line": 536,
        "end_line": 542,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.__setstate__#544",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.__setstate__(self, state)",
        "snippet": "    def __setstate__(self, state):\n        self.__dict__ = state\n        # layoutboxes don't survive pickling...\n        self._layoutbox = None",
        "begin_line": 544,
        "end_line": 547,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.get_gridspec#549",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.get_gridspec(self)",
        "snippet": "    def get_gridspec(self):\n        return self._gridspec",
        "begin_line": 549,
        "end_line": 550,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00034317089910775565,
            "pseudo_dstar_susp": 0.00042826552462526765,
            "pseudo_tarantula_susp": 0.0002860411899313501,
            "pseudo_op2_susp": 0.00042826552462526765,
            "pseudo_barinel_susp": 0.0002860411899313501
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.get_geometry#552",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.get_geometry(self)",
        "snippet": "    def get_geometry(self):\n        \"\"\"\n        Return the subplot geometry as tuple ``(n_rows, n_cols, start, stop)``.\n\n        The indices *start* and *stop* define the range of the subplot within\n        the `GridSpec`. *stop* is inclusive (i.e. for a single cell\n        ``start == stop``).\n        \"\"\"\n        rows, cols = self.get_gridspec().get_geometry()\n        return rows, cols, self.num1, self.num2",
        "begin_line": 552,
        "end_line": 561,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022119000221190003,
            "pseudo_dstar_susp": 0.00020815986677768527,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00020815986677768527,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.get_rows_columns#563",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.get_rows_columns(self)",
        "snippet": "    def get_rows_columns(self):\n        \"\"\"\n        Return the subplot row and column numbers as a tuple\n        ``(n_rows, n_cols, row_start, row_stop, col_start, col_stop)``.\n        \"\"\"\n        gridspec = self.get_gridspec()\n        nrows, ncols = gridspec.get_geometry()\n        row_start, col_start = divmod(self.num1, ncols)\n        row_stop, col_stop = divmod(self.num2, ncols)\n        return nrows, ncols, row_start, row_stop, col_start, col_stop",
        "begin_line": 563,
        "end_line": 572,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022396416573348266,
            "pseudo_dstar_susp": 0.00019319938176197836,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00019319938176197836,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.get_position#586",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.get_position(self, figure, return_all=False)",
        "snippet": "    def get_position(self, figure, return_all=False):\n        \"\"\"\n        Update the subplot position from ``figure.subplotpars``.\n        \"\"\"\n        gridspec = self.get_gridspec()\n        nrows, ncols = gridspec.get_geometry()\n        rows, cols = np.unravel_index([self.num1, self.num2], (nrows, ncols))\n        fig_bottoms, fig_tops, fig_lefts, fig_rights = \\\n            gridspec.get_grid_positions(figure)\n\n        fig_bottom = fig_bottoms[rows].min()\n        fig_top = fig_tops[rows].max()\n        fig_left = fig_lefts[cols].min()\n        fig_right = fig_rights[cols].max()\n        figbox = Bbox.from_extents(fig_left, fig_bottom, fig_right, fig_top)\n\n        if return_all:\n            return figbox, rows[0], cols[0], nrows, ncols\n        else:\n            return figbox",
        "begin_line": 586,
        "end_line": 605,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00039231071008238524,
            "pseudo_dstar_susp": 0.0005534034311012728,
            "pseudo_tarantula_susp": 0.0003151591553734636,
            "pseudo_op2_susp": 0.0005534034311012728,
            "pseudo_barinel_susp": 0.0003151591553734636
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.get_topmost_subplotspec#607",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.get_topmost_subplotspec(self)",
        "snippet": "    def get_topmost_subplotspec(self):\n        \"\"\"\n        Return the topmost `SubplotSpec` instance associated with the subplot.\n        \"\"\"\n        gridspec = self.get_gridspec()\n        if hasattr(gridspec, \"get_topmost_subplotspec\"):\n            return gridspec.get_topmost_subplotspec()\n        else:\n            return self",
        "begin_line": 607,
        "end_line": 615,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022471910112359551,
            "pseudo_dstar_susp": 0.00020855057351407716,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00020855057351407716,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.__eq__#617",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.__eq__(self, other)",
        "snippet": "    def __eq__(self, other):\n        \"\"\"\n        Two SubplotSpecs are considered equal if they refer to the same\n        position(s) in the same `GridSpec`.\n        \"\"\"\n        # other may not even have the attributes we are checking.\n        return ((self._gridspec, self.num1, self.num2)\n                == (getattr(other, \"_gridspec\", object()),\n                    getattr(other, \"num1\", object()),\n                    getattr(other, \"num2\", object())))",
        "begin_line": 617,
        "end_line": 626,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023446658851113716,
            "pseudo_dstar_susp": 0.0002317497103128621,
            "pseudo_tarantula_susp": 0.00029859659599880563,
            "pseudo_op2_susp": 0.0002317497103128621,
            "pseudo_barinel_susp": 0.00029850746268656717
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.__hash__#628",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.__hash__(self)",
        "snippet": "    def __hash__(self):\n        return hash((self._gridspec, self.num1, self.num2))",
        "begin_line": 628,
        "end_line": 629,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00024588148512417015,
            "pseudo_dstar_susp": 0.00032310177705977385,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.00032310177705977385,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.tight_layout._get_left#17",
        "src_path": "lib/matplotlib/tight_layout.py",
        "class_name": "lib.matplotlib.tight_layout",
        "signature": "lib.matplotlib.tight_layout._get_left(tight_bbox, axes_bbox)",
        "snippet": "def _get_left(tight_bbox, axes_bbox):\n    return axes_bbox.xmin - tight_bbox.xmin",
        "begin_line": 17,
        "end_line": 18,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002699784017278618,
            "pseudo_dstar_susp": 0.00026497085320614734,
            "pseudo_tarantula_susp": 0.0003176620076238882,
            "pseudo_op2_susp": 0.00026497085320614734,
            "pseudo_barinel_susp": 0.0003176620076238882
        }
    },
    {
        "name": "lib.matplotlib.tight_layout._get_right#21",
        "src_path": "lib/matplotlib/tight_layout.py",
        "class_name": "lib.matplotlib.tight_layout",
        "signature": "lib.matplotlib.tight_layout._get_right(tight_bbox, axes_bbox)",
        "snippet": "def _get_right(tight_bbox, axes_bbox):\n    return tight_bbox.xmax - axes_bbox.xmax",
        "begin_line": 21,
        "end_line": 22,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00032299741602067185,
            "pseudo_dstar_susp": 0.0002905287623474724,
            "pseudo_tarantula_susp": 0.00031655587211142766,
            "pseudo_op2_susp": 0.0002905287623474724,
            "pseudo_barinel_susp": 0.00031655587211142766
        }
    },
    {
        "name": "lib.matplotlib.tight_layout._get_bottom#25",
        "src_path": "lib/matplotlib/tight_layout.py",
        "class_name": "lib.matplotlib.tight_layout",
        "signature": "lib.matplotlib.tight_layout._get_bottom(tight_bbox, axes_bbox)",
        "snippet": "def _get_bottom(tight_bbox, axes_bbox):\n    return axes_bbox.ymin - tight_bbox.ymin",
        "begin_line": 25,
        "end_line": 26,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003641660597232338,
            "pseudo_dstar_susp": 0.00031426775612822125,
            "pseudo_tarantula_susp": 0.00031746031746031746,
            "pseudo_op2_susp": 0.00031426775612822125,
            "pseudo_barinel_susp": 0.00031746031746031746
        }
    },
    {
        "name": "lib.matplotlib.tight_layout._get_top#29",
        "src_path": "lib/matplotlib/tight_layout.py",
        "class_name": "lib.matplotlib.tight_layout",
        "signature": "lib.matplotlib.tight_layout._get_top(tight_bbox, axes_bbox)",
        "snippet": "def _get_top(tight_bbox, axes_bbox):\n    return tight_bbox.ymax - axes_bbox.ymax",
        "begin_line": 29,
        "end_line": 30,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003341129301703976,
            "pseudo_dstar_susp": 0.00030553009471432935,
            "pseudo_tarantula_susp": 0.00032829940906106366,
            "pseudo_op2_susp": 0.00030553009471432935,
            "pseudo_barinel_susp": 0.00032829940906106366
        }
    },
    {
        "name": "lib.matplotlib.tight_layout.auto_adjust_subplotpars#33",
        "src_path": "lib/matplotlib/tight_layout.py",
        "class_name": "lib.matplotlib.tight_layout",
        "signature": "lib.matplotlib.tight_layout.auto_adjust_subplotpars(fig, renderer, nrows_ncols, num1num2_list, subplot_list, ax_bbox_list=None, pad=1.08, h_pad=None, w_pad=None, rect=None)",
        "snippet": "def auto_adjust_subplotpars(\n        fig, renderer, nrows_ncols, num1num2_list, subplot_list,\n        ax_bbox_list=None, pad=1.08, h_pad=None, w_pad=None, rect=None):\n    \"\"\"\n    Return a dict of subplot parameters to adjust spacing between subplots\n    or ``None`` if resulting axes would have zero height or width.\n\n    Note that this function ignores geometry information of subplot\n    itself, but uses what is given by the *nrows_ncols* and *num1num2_list*\n    parameters.  Also, the results could be incorrect if some subplots have\n    ``adjustable=datalim``.\n\n    Parameters\n    ----------\n    nrows_ncols : Tuple[int, int]\n        Number of rows and number of columns of the grid.\n    num1num2_list : List[int]\n        List of numbers specifying the area occupied by the subplot\n    subplot_list : list of subplots\n        List of subplots that will be used to calculate optimal subplot_params.\n    pad : float\n        Padding between the figure edge and the edges of subplots, as a\n        fraction of the font size.\n    h_pad, w_pad : float\n        Padding (height/width) between edges of adjacent subplots, as a\n        fraction of the font size.  Defaults to *pad*.\n    rect : Tuple[float, float, float, float]\n        [left, bottom, right, top] in normalized (0, 1) figure coordinates.\n    \"\"\"\n    rows, cols = nrows_ncols\n\n    font_size_inches = (\n        FontProperties(size=rcParams[\"font.size\"]).get_size_in_points() / 72)\n    pad_inches = pad * font_size_inches\n    if h_pad is not None:\n        vpad_inches = h_pad * font_size_inches\n    else:\n        vpad_inches = pad_inches\n\n    if w_pad is not None:\n        hpad_inches = w_pad * font_size_inches\n    else:\n        hpad_inches = pad_inches\n\n    if len(num1num2_list) != len(subplot_list) or len(subplot_list) == 0:\n        raise ValueError\n\n    if rect is None:\n        margin_left = margin_bottom = margin_right = margin_top = None\n    else:\n        margin_left, margin_bottom, _right, _top = rect\n        if _right:\n            margin_right = 1 - _right\n        else:\n            margin_right = None\n        if _top:\n            margin_top = 1 - _top\n        else:\n            margin_top = None\n\n    vspaces = [[] for i in range((rows + 1) * cols)]\n    hspaces = [[] for i in range(rows * (cols + 1))]\n\n    union = Bbox.union\n\n    if ax_bbox_list is None:\n        ax_bbox_list = [\n            union([ax.get_position(original=True) for ax in subplots])\n            for subplots in subplot_list]\n\n    for subplots, ax_bbox, (num1, num2) in zip(subplot_list,\n                                               ax_bbox_list,\n                                               num1num2_list):\n        if all(not ax.get_visible() for ax in subplots):\n            continue\n\n        tight_bbox_raw = union([ax.get_tightbbox(renderer) for ax in subplots\n                                if ax.get_visible()])\n        tight_bbox = TransformedBbox(tight_bbox_raw,\n                                     fig.transFigure.inverted())\n\n        row1, col1 = divmod(num1, cols)\n\n        if num2 is None:\n            # left\n            hspaces[row1 * (cols + 1) + col1].append(\n                                        _get_left(tight_bbox, ax_bbox))\n            # right\n            hspaces[row1 * (cols + 1) + (col1 + 1)].append(\n                                        _get_right(tight_bbox, ax_bbox))\n            # top\n            vspaces[row1 * cols + col1].append(\n                                        _get_top(tight_bbox, ax_bbox))\n            # bottom\n            vspaces[(row1 + 1) * cols + col1].append(\n                                        _get_bottom(tight_bbox, ax_bbox))\n\n        else:\n            row2, col2 = divmod(num2, cols)\n\n            for row_i in range(row1, row2 + 1):\n                # left\n                hspaces[row_i * (cols + 1) + col1].append(\n                                    _get_left(tight_bbox, ax_bbox))\n                # right\n                hspaces[row_i * (cols + 1) + (col2 + 1)].append(\n                                    _get_right(tight_bbox, ax_bbox))\n            for col_i in range(col1, col2 + 1):\n                # top\n                vspaces[row1 * cols + col_i].append(\n                                    _get_top(tight_bbox, ax_bbox))\n                # bottom\n                vspaces[(row2 + 1) * cols + col_i].append(\n                                    _get_bottom(tight_bbox, ax_bbox))\n\n    fig_width_inch, fig_height_inch = fig.get_size_inches()\n\n    # margins can be negative for axes with aspect applied. And we\n    # append + [0] to make minimum margins 0\n\n    if not margin_left:\n        margin_left = max([sum(s) for s in hspaces[::cols + 1]] + [0])\n        margin_left += pad_inches / fig_width_inch\n\n    if not margin_right:\n        margin_right = max([sum(s) for s in hspaces[cols::cols + 1]] + [0])\n        margin_right += pad_inches / fig_width_inch\n\n    if not margin_top:\n        margin_top = max([sum(s) for s in vspaces[:cols]] + [0])\n        margin_top += pad_inches / fig_height_inch\n\n    if not margin_bottom:\n        margin_bottom = max([sum(s) for s in vspaces[-cols:]] + [0])\n        margin_bottom += pad_inches / fig_height_inch\n\n    if margin_left + margin_right >= 1:\n        cbook._warn_external('Tight layout not applied. The left and right '\n                             'margins cannot be made large enough to '\n                             'accommodate all axes decorations. ')\n        return None\n    if margin_bottom + margin_top >= 1:\n        cbook._warn_external('Tight layout not applied. The bottom and top '\n                             'margins cannot be made large enough to '\n                             'accommodate all axes decorations. ')\n        return None\n\n    kwargs = dict(left=margin_left,\n                  right=1 - margin_right,\n                  bottom=margin_bottom,\n                  top=1 - margin_top)\n    if cols > 1:\n        hspace = (\n            max(sum(s)\n                for i in range(rows)\n                for s in hspaces[i * (cols + 1) + 1:(i + 1) * (cols + 1) - 1])\n            + hpad_inches / fig_width_inch)\n        # axes widths:\n        h_axes = (1 - margin_right - margin_left - hspace * (cols - 1)) / cols\n        if h_axes < 0:\n            cbook._warn_external('Tight layout not applied. tight_layout '\n                                 'cannot make axes width small enough to '\n                                 'accommodate all axes decorations')\n            return None\n        else:\n            kwargs[\"wspace\"] = hspace / h_axes\n\n    if rows > 1:\n        vspace = (max(sum(s) for s in vspaces[cols:-cols])\n                  + vpad_inches / fig_height_inch)\n        v_axes = (1 - margin_top - margin_bottom - vspace * (rows - 1)) / rows\n        if v_axes < 0:\n            cbook._warn_external('Tight layout not applied. tight_layout '\n                                 'cannot make axes height small enough to '\n                                 'accommodate all axes decorations')\n            return None\n        else:\n            kwargs[\"hspace\"] = vspace / v_axes\n\n    return kwargs",
        "begin_line": 33,
        "end_line": 212,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00032808398950131233,
            "pseudo_dstar_susp": 0.0003183699458771092,
            "pseudo_tarantula_susp": 0.00032393909944930353,
            "pseudo_op2_susp": 0.0003183699458771092,
            "pseudo_barinel_susp": 0.00032393909944930353
        }
    },
    {
        "name": "lib.matplotlib.tight_layout.get_subplotspec_list#232",
        "src_path": "lib/matplotlib/tight_layout.py",
        "class_name": "lib.matplotlib.tight_layout",
        "signature": "lib.matplotlib.tight_layout.get_subplotspec_list(axes_list, grid_spec=None)",
        "snippet": "def get_subplotspec_list(axes_list, grid_spec=None):\n    \"\"\"Return a list of subplotspec from the given list of axes.\n\n    For an instance of axes that does not support subplotspec, None is inserted\n    in the list.\n\n    If grid_spec is given, None is inserted for those not from the given\n    grid_spec.\n    \"\"\"\n    subplotspec_list = []\n    for ax in axes_list:\n        axes_or_locator = ax.get_axes_locator()\n        if axes_or_locator is None:\n            axes_or_locator = ax\n\n        if hasattr(axes_or_locator, \"get_subplotspec\"):\n            subplotspec = axes_or_locator.get_subplotspec()\n            subplotspec = subplotspec.get_topmost_subplotspec()\n            gs = subplotspec.get_gridspec()\n            if grid_spec is not None:\n                if gs != grid_spec:\n                    subplotspec = None\n            elif gs.locally_modified_subplot_params():\n                subplotspec = None\n        else:\n            subplotspec = None\n\n        subplotspec_list.append(subplotspec)\n\n    return subplotspec_list",
        "begin_line": 232,
        "end_line": 261,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003247807729782397,
            "pseudo_dstar_susp": 0.00030703101013202335,
            "pseudo_tarantula_susp": 0.0002789400278940028,
            "pseudo_op2_susp": 0.00030703101013202335,
            "pseudo_barinel_susp": 0.0002789400278940028
        }
    },
    {
        "name": "lib.matplotlib.tight_layout.get_tight_layout_figure#264",
        "src_path": "lib/matplotlib/tight_layout.py",
        "class_name": "lib.matplotlib.tight_layout",
        "signature": "lib.matplotlib.tight_layout.get_tight_layout_figure(fig, axes_list, subplotspec_list, renderer, pad=1.08, h_pad=None, w_pad=None, rect=None)",
        "snippet": "def get_tight_layout_figure(fig, axes_list, subplotspec_list, renderer,\n                            pad=1.08, h_pad=None, w_pad=None, rect=None):\n    \"\"\"\n    Return subplot parameters for tight-layouted-figure with specified padding.\n\n    Parameters\n    ----------\n    fig : Figure\n    axes_list : list of Axes\n    subplotspec_list : list of `.SubplotSpec`\n        The subplotspecs of each axes.\n    renderer : renderer\n    pad : float\n        Padding between the figure edge and the edges of subplots, as a\n        fraction of the font size.\n    h_pad, w_pad : float\n        Padding (height/width) between edges of adjacent subplots.  Defaults to\n        *pad*.\n    rect : Tuple[float, float, float, float], optional\n        (left, bottom, right, top) rectangle in normalized figure coordinates\n        that the whole subplots area (including labels) will fit into.\n        Defaults to using the entire figure.\n\n    Returns\n    -------\n    subplotspec or None\n        subplotspec kwargs to be passed to `.Figure.subplots_adjust` or\n        None if tight_layout could not be accomplished.\n\n    \"\"\"\n\n    subplot_list = []\n    nrows_list = []\n    ncols_list = []\n    ax_bbox_list = []\n\n    # Multiple axes can share same subplot_interface (e.g., axes_grid1); thus\n    # we need to join them together.\n    subplot_dict = {}\n\n    subplotspec_list2 = []\n\n    for ax, subplotspec in zip(axes_list, subplotspec_list):\n        if subplotspec is None:\n            continue\n\n        subplots = subplot_dict.setdefault(subplotspec, [])\n\n        if not subplots:\n            myrows, mycols, _, _ = subplotspec.get_geometry()\n            nrows_list.append(myrows)\n            ncols_list.append(mycols)\n            subplotspec_list2.append(subplotspec)\n            subplot_list.append(subplots)\n            ax_bbox_list.append(subplotspec.get_position(fig))\n\n        subplots.append(ax)\n\n    if len(nrows_list) == 0 or len(ncols_list) == 0:\n        return {}\n\n    max_nrows = max(nrows_list)\n    max_ncols = max(ncols_list)\n\n    num1num2_list = []\n    for subplotspec in subplotspec_list2:\n        rows, cols, num1, num2 = subplotspec.get_geometry()\n        div_row, mod_row = divmod(max_nrows, rows)\n        div_col, mod_col = divmod(max_ncols, cols)\n        if mod_row != 0:\n            cbook._warn_external('tight_layout not applied: number of rows '\n                                 'in subplot specifications must be '\n                                 'multiples of one another.')\n            return {}\n        if mod_col != 0:\n            cbook._warn_external('tight_layout not applied: number of '\n                                 'columns in subplot specifications must be '\n                                 'multiples of one another.')\n            return {}\n\n        rowNum1, colNum1 = divmod(num1, cols)\n        if num2 is None:\n            rowNum2, colNum2 = rowNum1, colNum1\n        else:\n            rowNum2, colNum2 = divmod(num2, cols)\n\n        num1num2_list.append((rowNum1 * div_row * max_ncols +\n                              colNum1 * div_col,\n                              ((rowNum2 + 1) * div_row - 1) * max_ncols +\n                              (colNum2 + 1) * div_col - 1))\n\n    kwargs = auto_adjust_subplotpars(fig, renderer,\n                                     nrows_ncols=(max_nrows, max_ncols),\n                                     num1num2_list=num1num2_list,\n                                     subplot_list=subplot_list,\n                                     ax_bbox_list=ax_bbox_list,\n                                     pad=pad, h_pad=h_pad, w_pad=w_pad)\n\n    # kwargs can be none if tight_layout fails...\n    if rect is not None and kwargs is not None:\n        # if rect is given, the whole subplots area (including\n        # labels) will fit into the rect instead of the\n        # figure. Note that the rect argument of\n        # *auto_adjust_subplotpars* specify the area that will be\n        # covered by the total area of axes.bbox. Thus we call\n        # auto_adjust_subplotpars twice, where the second run\n        # with adjusted rect parameters.\n\n        left, bottom, right, top = rect\n        if left is not None:\n            left += kwargs[\"left\"]\n        if bottom is not None:\n            bottom += kwargs[\"bottom\"]\n        if right is not None:\n            right -= (1 - kwargs[\"right\"])\n        if top is not None:\n            top -= (1 - kwargs[\"top\"])\n\n        kwargs = auto_adjust_subplotpars(fig, renderer,\n                                         nrows_ncols=(max_nrows, max_ncols),\n                                         num1num2_list=num1num2_list,\n                                         subplot_list=subplot_list,\n                                         ax_bbox_list=ax_bbox_list,\n                                         pad=pad, h_pad=h_pad, w_pad=w_pad,\n                                         rect=(left, bottom, right, top))\n\n    return kwargs",
        "begin_line": 264,
        "end_line": 390,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022624434389140272,
            "pseudo_dstar_susp": 0.00020868113522537563,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00020868113522537563,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__#15",
        "src_path": "lib/matplotlib/backends/backend_mixed.py",
        "class_name": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer",
        "signature": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__(self, figure, width, height, dpi, vector_renderer, raster_renderer_class=None, bbox_inches_restore=None)",
        "snippet": "    def __init__(self, figure, width, height, dpi, vector_renderer,\n                 raster_renderer_class=None,\n                 bbox_inches_restore=None):\n        \"\"\"\n        Parameters\n        ----------\n        figure : `matplotlib.figure.Figure`\n            The figure instance.\n\n        width : scalar\n            The width of the canvas in logical units\n\n        height : scalar\n            The height of the canvas in logical units\n\n        dpi : scalar\n            The dpi of the canvas\n\n        vector_renderer : `matplotlib.backend_bases.RendererBase`\n            An instance of a subclass of\n            `~matplotlib.backend_bases.RendererBase` that will be used for the\n            vector drawing.\n\n        raster_renderer_class : `matplotlib.backend_bases.RendererBase`\n            The renderer class to use for the raster drawing.  If not provided,\n            this will use the Agg backend (which is currently the only viable\n            option anyway.)\n\n        \"\"\"\n        if raster_renderer_class is None:\n            raster_renderer_class = RendererAgg\n\n        self._raster_renderer_class = raster_renderer_class\n        self._width = width\n        self._height = height\n        self.dpi = dpi\n\n        self._vector_renderer = vector_renderer\n\n        self._raster_renderer = None\n        self._rasterizing = 0\n\n        # A reference to the figure is needed as we need to change\n        # the figure dpi before and after the rasterization. Although\n        # this looks ugly, I couldn't find a better solution. -JJL\n        self.figure = figure\n        self._figdpi = figure.get_dpi()\n\n        self._bbox_inches_restore = bbox_inches_restore\n\n        self._renderer = vector_renderer",
        "begin_line": 15,
        "end_line": 65,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00014208581983518045,
            "pseudo_dstar_susp": 0.00019440124416796267,
            "pseudo_tarantula_susp": 0.00012373174956693887,
            "pseudo_op2_susp": 0.00019440124416796267,
            "pseudo_barinel_susp": 0.00012373174956693887
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.CallbackRegistry.__init__#118",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.CallbackRegistry",
        "signature": "lib.matplotlib.cbook.__init__.CallbackRegistry.__init__(self, exception_handler=_exception_printer)",
        "snippet": "    def __init__(self, exception_handler=_exception_printer):\n        self.exception_handler = exception_handler\n        self.callbacks = {}\n        self._cid_gen = itertools.count()\n        self._func_cid_map = {}",
        "begin_line": 118,
        "end_line": 122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012853470437017994,
            "pseudo_dstar_susp": 0.0018148820326678765,
            "pseudo_tarantula_susp": 0.0004268032437046522,
            "pseudo_op2_susp": 0.0018148820326678765,
            "pseudo_barinel_susp": 0.0004268032437046522
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.CallbackRegistry.connect#138",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.CallbackRegistry",
        "signature": "lib.matplotlib.cbook.__init__.CallbackRegistry.connect(self, s, func)",
        "snippet": "    def connect(self, s, func):\n        \"\"\"Register *func* to be called when signal *s* is generated.\n        \"\"\"\n        self._func_cid_map.setdefault(s, {})\n        try:\n            proxy = WeakMethod(func, self._remove_proxy)\n        except TypeError:\n            proxy = _StrongRef(func)\n        if proxy in self._func_cid_map[s]:\n            return self._func_cid_map[s][proxy]\n\n        cid = next(self._cid_gen)\n        self._func_cid_map[s][proxy] = cid\n        self.callbacks.setdefault(s, {})\n        self.callbacks[s][cid] = proxy\n        return cid",
        "begin_line": 138,
        "end_line": 153,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00684931506849315,
            "pseudo_dstar_susp": 0.005154639175257732,
            "pseudo_tarantula_susp": 0.0004424778761061947,
            "pseudo_op2_susp": 0.005154639175257732,
            "pseudo_barinel_susp": 0.0004424778761061947
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.CallbackRegistry._remove_proxy#157",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.CallbackRegistry",
        "signature": "lib.matplotlib.cbook.__init__.CallbackRegistry._remove_proxy(self, proxy, *, _is_finalizing=sys.is_finalizing)",
        "snippet": "    def _remove_proxy(self, proxy, *, _is_finalizing=sys.is_finalizing):\n        if _is_finalizing():\n            # Weakrefs can't be properly torn down at that point anymore.\n            return\n        for signal, proxies in list(self._func_cid_map.items()):\n            try:\n                del self.callbacks[signal][proxies[proxy]]\n            except KeyError:\n                pass\n            if len(self.callbacks[signal]) == 0:\n                del self.callbacks[signal]\n                del self._func_cid_map[signal]",
        "begin_line": 157,
        "end_line": 168,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.893905904641616e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.CallbackRegistry.disconnect#170",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.CallbackRegistry",
        "signature": "lib.matplotlib.cbook.__init__.CallbackRegistry.disconnect(self, cid)",
        "snippet": "    def disconnect(self, cid):\n        \"\"\"Disconnect the callback registered with callback id *cid*.\n        \"\"\"\n        for eventname, callbackd in list(self.callbacks.items()):\n            try:\n                del callbackd[cid]\n            except KeyError:\n                continue\n            else:\n                for signal, functions in list(self._func_cid_map.items()):\n                    for function, value in list(functions.items()):\n                        if value == cid:\n                            del functions[function]\n                return",
        "begin_line": 170,
        "end_line": 183,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.905138339920949e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.CallbackRegistry.process#185",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.CallbackRegistry",
        "signature": "lib.matplotlib.cbook.__init__.CallbackRegistry.process(self, s, *args, **kwargs)",
        "snippet": "    def process(self, s, *args, **kwargs):\n        \"\"\"\n        Process signal *s*.\n\n        All of the functions registered to receive callbacks on *s* will be\n        called with ``*args`` and ``**kwargs``.\n        \"\"\"\n        for cid, ref in list(self.callbacks.get(s, {}).items()):\n            func = ref()\n            if func is not None:\n                try:\n                    func(*args, **kwargs)\n                # this does not capture KeyboardInterrupt, SystemExit,\n                # and GeneratorExit\n                except Exception as exc:\n                    if self.exception_handler is not None:\n                        self.exception_handler(exc)\n                    else:\n                        raise",
        "begin_line": 185,
        "end_line": 203,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.is_hashable#332",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.is_hashable(obj)",
        "snippet": "def is_hashable(obj):\n    \"\"\"Returns true if *obj* can be hashed\"\"\"\n    try:\n        hash(obj)\n    except TypeError:\n        return False\n    return True",
        "begin_line": 332,
        "end_line": 338,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.to_filehandle#359",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.to_filehandle(fname, flag='r', return_opened=False, encoding=None)",
        "snippet": "def to_filehandle(fname, flag='r', return_opened=False, encoding=None):\n    \"\"\"\n    Convert a path to an open file handle or pass-through a file-like object.\n\n    Consider using `open_file_cm` instead, as it allows one to properly close\n    newly created file objects more easily.\n\n    Parameters\n    ----------\n    fname : str or path-like or file-like object\n        If `str` or `os.PathLike`, the file is opened using the flags specified\n        by *flag* and *encoding*.  If a file-like object, it is passed through.\n    flag : str, default 'r'\n        Passed as the *mode* argument to `open` when *fname* is `str` or\n        `os.PathLike`; ignored if *fname* is file-like.\n    return_opened : bool, default False\n        If True, return both the file object and a boolean indicating whether\n        this was a new file (that the caller needs to close).  If False, return\n        only the new file.\n    encoding : str or None, default None\n        Passed as the *mode* argument to `open` when *fname* is `str` or\n        `os.PathLike`; ignored if *fname* is file-like.\n\n    Returns\n    -------\n    fh : file-like\n    opened : bool\n        *opened* is only returned if *return_opened* is True.\n    \"\"\"\n    if isinstance(fname, os.PathLike):\n        fname = os.fspath(fname)\n    if isinstance(fname, str):\n        if fname.endswith('.gz'):\n            # get rid of 'U' in flag for gzipped files.\n            flag = flag.replace('U', '')\n            fh = gzip.open(fname, flag)\n        elif fname.endswith('.bz2'):\n            # python may not be complied with bz2 support,\n            # bury import until we need it\n            import bz2\n            # get rid of 'U' in flag for bz2 files\n            flag = flag.replace('U', '')\n            fh = bz2.BZ2File(fname, flag)\n        else:\n            fh = open(fname, flag, encoding=encoding)\n        opened = True\n    elif hasattr(fname, 'seek'):\n        fh = fname\n        opened = False\n    else:\n        raise ValueError('fname must be a PathLike or file handle')\n    if return_opened:\n        return fh, opened\n    return fh",
        "begin_line": 359,
        "end_line": 412,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018463810930576072,
            "pseudo_dstar_susp": 0.00016136840406648378,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.00016136840406648378,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.open_file_cm#416",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.open_file_cm(path_or_file, mode='r', encoding=None)",
        "snippet": "def open_file_cm(path_or_file, mode=\"r\", encoding=None):\n    r\"\"\"Pass through file objects and context-manage `.PathLike`\\s.\"\"\"\n    fh, opened = to_filehandle(path_or_file, mode, True, encoding)\n    if opened:\n        with fh:\n            yield fh\n    else:\n        yield fh",
        "begin_line": 416,
        "end_line": 423,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002061855670103093,
            "pseudo_dstar_susp": 0.002061855670103093,
            "pseudo_tarantula_susp": 0.0004154549231408392,
            "pseudo_op2_susp": 0.002061855670103093,
            "pseudo_barinel_susp": 0.0004154549231408392
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.is_scalar_or_string#426",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.is_scalar_or_string(val)",
        "snippet": "def is_scalar_or_string(val):\n    \"\"\"Return whether the given object is a scalar or string like.\"\"\"\n    return isinstance(val, str) or not np.iterable(val)",
        "begin_line": 426,
        "end_line": 428,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.maxdict.__setitem__#557",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.maxdict",
        "signature": "lib.matplotlib.cbook.__init__.maxdict.__setitem__(self, k, v)",
        "snippet": "    def __setitem__(self, k, v):\n        if k not in self:\n            if len(self) >= self.maxsize:\n                del self[self._killkeys[0]]\n                del self._killkeys[0]\n            self._killkeys.append(k)\n        dict.__setitem__(self, k, v)",
        "begin_line": 557,
        "end_line": 563,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002183406113537118,
            "pseudo_dstar_susp": 0.001326259946949602,
            "pseudo_tarantula_susp": 0.0005235602094240838,
            "pseudo_op2_susp": 0.001326259946949602,
            "pseudo_barinel_susp": 0.0005235602094240838
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.Stack.__init__#573",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.Stack",
        "signature": "lib.matplotlib.cbook.__init__.Stack.__init__(self, default=None)",
        "snippet": "    def __init__(self, default=None):\n        self.clear()\n        self._default = default",
        "begin_line": 573,
        "end_line": 575,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014388489208633094,
            "pseudo_dstar_susp": 0.0011574074074074073,
            "pseudo_tarantula_susp": 0.00045682960255824577,
            "pseudo_op2_susp": 0.0011574074074074073,
            "pseudo_barinel_susp": 0.00045682960255824577
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.Stack.clear#626",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.Stack",
        "signature": "lib.matplotlib.cbook.__init__.Stack.clear(self)",
        "snippet": "    def clear(self):\n        \"\"\"Empty the stack.\"\"\"\n        self._pos = -1\n        self._elements = []",
        "begin_line": 626,
        "end_line": 629,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001288659793814433,
            "pseudo_dstar_susp": 0.0018450184501845018,
            "pseudo_tarantula_susp": 0.00040749796251018743,
            "pseudo_op2_susp": 0.0018450184501845018,
            "pseudo_barinel_susp": 0.00040749796251018743
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.Stack.bubble#631",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.Stack",
        "signature": "lib.matplotlib.cbook.__init__.Stack.bubble(self, o)",
        "snippet": "    def bubble(self, o):\n        \"\"\"\n        Raise *o* to the top of the stack.  *o* must be present in the stack.\n\n        *o* is returned.\n        \"\"\"\n        if o not in self._elements:\n            raise ValueError('Unknown element o')\n        old = self._elements[:]\n        self.clear()\n        bubbles = []\n        for thiso in old:\n            if thiso == o:\n                bubbles.append(thiso)\n            else:\n                self.push(thiso)\n        for _ in bubbles:\n            self.push(o)\n        return o",
        "begin_line": 631,
        "end_line": 649,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.687576875768758e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.Grouper.__init__#827",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.Grouper",
        "signature": "lib.matplotlib.cbook.__init__.Grouper.__init__(self, init=())",
        "snippet": "    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}",
        "begin_line": 827,
        "end_line": 828,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.146639511201629e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.Grouper.clean#833",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.Grouper",
        "signature": "lib.matplotlib.cbook.__init__.Grouper.clean(self)",
        "snippet": "    def clean(self):\n        \"\"\"Clean dead weak references from the dictionary.\"\"\"\n        mapping = self._mapping\n        to_drop = [key for key in mapping if key() is None]\n        for key in to_drop:\n            val = mapping.pop(key)\n            val.remove(key)",
        "begin_line": 833,
        "end_line": 839,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.Grouper.join#841",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.Grouper",
        "signature": "lib.matplotlib.cbook.__init__.Grouper.join(self, a, *args)",
        "snippet": "    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()",
        "begin_line": 841,
        "end_line": 857,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.Grouper.joined#859",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.Grouper",
        "signature": "lib.matplotlib.cbook.__init__.Grouper.joined(self, a, b)",
        "snippet": "    def joined(self, a, b):\n        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n        self.clean()\n        return (self._mapping.get(weakref.ref(a), object())\n                is self._mapping.get(weakref.ref(b)))",
        "begin_line": 859,
        "end_line": 863,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.Grouper.remove#865",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.Grouper",
        "signature": "lib.matplotlib.cbook.__init__.Grouper.remove(self, a)",
        "snippet": "    def remove(self, a):\n        self.clean()\n        set_a = self._mapping.pop(weakref.ref(a), None)\n        if set_a:\n            set_a.remove(weakref.ref(a))",
        "begin_line": 865,
        "end_line": 869,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.Grouper.__iter__#871",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.Grouper",
        "signature": "lib.matplotlib.cbook.__init__.Grouper.__iter__(self)",
        "snippet": "    def __iter__(self):\n        \"\"\"\n        Iterate over each of the disjoint sets as a list.\n\n        The iterator is invalid if interleaved with calls to join().\n        \"\"\"\n        self.clean()\n        unique_groups = {id(group): group for group in self._mapping.values()}\n        for group in unique_groups.values():\n            yield [x() for x in group]",
        "begin_line": 871,
        "end_line": 880,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.Grouper.get_siblings#882",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.Grouper",
        "signature": "lib.matplotlib.cbook.__init__.Grouper.get_siblings(self, a)",
        "snippet": "    def get_siblings(self, a):\n        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n        self.clean()\n        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n        return [x() for x in siblings]",
        "begin_line": 882,
        "end_line": 886,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002637826431020839,
            "pseudo_dstar_susp": 0.00034153005464480874,
            "pseudo_tarantula_susp": 0.00013147515119642388,
            "pseudo_op2_susp": 0.00034153005464480874,
            "pseudo_barinel_susp": 0.00013147515119642388
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.delete_masked_points#913",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.delete_masked_points(*args)",
        "snippet": "def delete_masked_points(*args):\n    \"\"\"\n    Find all masked and/or non-finite points in a set of arguments,\n    and return the arguments with only the unmasked points remaining.\n\n    Arguments can be in any of 5 categories:\n\n    1) 1-D masked arrays\n    2) 1-D ndarrays\n    3) ndarrays with more than one dimension\n    4) other non-string iterables\n    5) anything else\n\n    The first argument must be in one of the first four categories;\n    any argument with a length differing from that of the first\n    argument (and hence anything in category 5) then will be\n    passed through unchanged.\n\n    Masks are obtained from all arguments of the correct length\n    in categories 1, 2, and 4; a point is bad if masked in a masked\n    array or if it is a nan or inf.  No attempt is made to\n    extract a mask from categories 2, 3, and 4 if :meth:`np.isfinite`\n    does not yield a Boolean array.\n\n    All input arguments that are not passed unchanged are returned\n    as ndarrays after removing the points or rows corresponding to\n    masks in any of the arguments.\n\n    A vastly simpler version of this function was originally\n    written as a helper for Axes.scatter().\n\n    \"\"\"\n    if not len(args):\n        return ()\n    if is_scalar_or_string(args[0]):\n        raise ValueError(\"First argument must be a sequence\")\n    nrecs = len(args[0])\n    margs = []\n    seqlist = [False] * len(args)\n    for i, x in enumerate(args):\n        if not isinstance(x, str) and np.iterable(x) and len(x) == nrecs:\n            seqlist[i] = True\n            if isinstance(x, np.ma.MaskedArray):\n                if x.ndim > 1:\n                    raise ValueError(\"Masked arrays must be 1-D\")\n            else:\n                x = np.asarray(x)\n        margs.append(x)\n    masks = []    # list of masks that are True where good\n    for i, x in enumerate(margs):\n        if seqlist[i]:\n            if x.ndim > 1:\n                continue  # Don't try to get nan locations unless 1-D.\n            if isinstance(x, np.ma.MaskedArray):\n                masks.append(~np.ma.getmaskarray(x))  # invert the mask\n                xd = x.data\n            else:\n                xd = x\n            try:\n                mask = np.isfinite(xd)\n                if isinstance(mask, np.ndarray):\n                    masks.append(mask)\n            except Exception:  # Fixme: put in tuple of possible exceptions?\n                pass\n    if len(masks):\n        mask = np.logical_and.reduce(masks)\n        igood = mask.nonzero()[0]\n        if len(igood) < nrecs:\n            for i, x in enumerate(margs):\n                if seqlist[i]:\n                    margs[i] = x[igood]\n    for i, x in enumerate(margs):\n        if seqlist[i] and isinstance(x, np.ma.MaskedArray):\n            margs[i] = x.filled()\n    return margs",
        "begin_line": 913,
        "end_line": 987,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018338529249954154,
            "pseudo_dstar_susp": 0.00022737608003638017,
            "pseudo_tarantula_susp": 0.00013087292239235702,
            "pseudo_op2_susp": 0.00022737608003638017,
            "pseudo_barinel_susp": 0.00013087292239235702
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._combine_masks#990",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._combine_masks(*args)",
        "snippet": "def _combine_masks(*args):\n    \"\"\"\n    Find all masked and/or non-finite points in a set of arguments,\n    and return the arguments as masked arrays with a common mask.\n\n    Arguments can be in any of 5 categories:\n\n    1) 1-D masked arrays\n    2) 1-D ndarrays\n    3) ndarrays with more than one dimension\n    4) other non-string iterables\n    5) anything else\n\n    The first argument must be in one of the first four categories;\n    any argument with a length differing from that of the first\n    argument (and hence anything in category 5) then will be\n    passed through unchanged.\n\n    Masks are obtained from all arguments of the correct length\n    in categories 1, 2, and 4; a point is bad if masked in a masked\n    array or if it is a nan or inf.  No attempt is made to\n    extract a mask from categories 2 and 4 if :meth:`np.isfinite`\n    does not yield a Boolean array.  Category 3 is included to\n    support RGB or RGBA ndarrays, which are assumed to have only\n    valid values and which are passed through unchanged.\n\n    All input arguments that are not passed unchanged are returned\n    as masked arrays if any masked points are found, otherwise as\n    ndarrays.\n\n    \"\"\"\n    if not len(args):\n        return ()\n    if is_scalar_or_string(args[0]):\n        raise ValueError(\"First argument must be a sequence\")\n    nrecs = len(args[0])\n    margs = []  # Output args; some may be modified.\n    seqlist = [False] * len(args)  # Flags: True if output will be masked.\n    masks = []    # List of masks.\n    for i, x in enumerate(args):\n        if is_scalar_or_string(x) or len(x) != nrecs:\n            margs.append(x)  # Leave it unmodified.\n        else:\n            if isinstance(x, np.ma.MaskedArray) and x.ndim > 1:\n                raise ValueError(\"Masked arrays must be 1-D\")\n            x = np.asanyarray(x)\n            if x.ndim == 1:\n                x = safe_masked_invalid(x)\n                seqlist[i] = True\n                if np.ma.is_masked(x):\n                    masks.append(np.ma.getmaskarray(x))\n            margs.append(x)  # Possibly modified.\n    if len(masks):\n        mask = np.logical_or.reduce(masks)\n        for i, x in enumerate(margs):\n            if seqlist[i]:\n                margs[i] = np.ma.array(x, mask=mask)\n    return margs",
        "begin_line": 990,
        "end_line": 1047,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.0001369487811558477,
            "pseudo_tarantula_susp": 0.00017415534656913968,
            "pseudo_op2_susp": 0.0001369487811558477,
            "pseudo_barinel_susp": 0.0001742767514813524
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.boxplot_stats#1050",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.boxplot_stats(X, whis=1.5, bootstrap=None, labels=None, autorange=False)",
        "snippet": "def boxplot_stats(X, whis=1.5, bootstrap=None, labels=None,\n                  autorange=False):\n    r\"\"\"\n    Returns list of dictionaries of statistics used to draw a series\n    of box and whisker plots. The `Returns` section enumerates the\n    required keys of the dictionary. Users can skip this function and\n    pass a user-defined set of dictionaries to the new `axes.bxp` method\n    instead of relying on Matplotlib to do the calculations.\n\n    Parameters\n    ----------\n    X : array-like\n        Data that will be represented in the boxplots. Should have 2 or\n        fewer dimensions.\n\n    whis : float or (float, float) (default = 1.5)\n        The position of the whiskers.\n\n        If a float, the lower whisker is at the lowest datum above\n        ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum below\n        ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and third\n        quartiles.  The default value of ``whis = 1.5`` corresponds to Tukey's\n        original definition of boxplots.\n\n        If a pair of floats, they indicate the percentiles at which to draw the\n        whiskers (e.g., (5, 95)).  In particular, setting this to (0, 100)\n        results in whiskers covering the whole range of the data.  \"range\" is\n        a deprecated synonym for (0, 100).\n\n        In the edge case where ``Q1 == Q3``, *whis* is automatically set to\n        (0, 100) (cover the whole range of the data) if *autorange* is True.\n\n        Beyond the whiskers, data are considered outliers and are plotted as\n        individual points.\n\n    bootstrap : int, optional\n        Number of times the confidence intervals around the median\n        should be bootstrapped (percentile method).\n\n    labels : array-like, optional\n        Labels for each dataset. Length must be compatible with\n        dimensions of *X*.\n\n    autorange : bool, optional (False)\n        When `True` and the data are distributed such that the 25th and 75th\n        percentiles are equal, ``whis`` is set to (0, 100) such that the\n        whisker ends are at the minimum and maximum of the data.\n\n    Returns\n    -------\n    bxpstats : list of dict\n        A list of dictionaries containing the results for each column\n        of data. Keys of each dictionary are the following:\n\n        ========   ===================================\n        Key        Value Description\n        ========   ===================================\n        label      tick label for the boxplot\n        mean       arithmetic mean value\n        med        50th percentile\n        q1         first quartile (25th percentile)\n        q3         third quartile (75th percentile)\n        cilo       lower notch around the median\n        cihi       upper notch around the median\n        whislo     end of the lower whisker\n        whishi     end of the upper whisker\n        fliers     outliers\n        ========   ===================================\n\n    Notes\n    -----\n    Non-bootstrapping approach to confidence interval uses Gaussian-\n    based asymptotic approximation:\n\n    .. math::\n\n        \\mathrm{med} \\pm 1.57 \\times \\frac{\\mathrm{iqr}}{\\sqrt{N}}\n\n    General approach from:\n    McGill, R., Tukey, J.W., and Larsen, W.A. (1978) \"Variations of\n    Boxplots\", The American Statistician, 32:12-16.\n\n    \"\"\"\n\n    def _bootstrap_median(data, N=5000):\n        # determine 95% confidence intervals of the median\n        M = len(data)\n        percentiles = [2.5, 97.5]\n\n        bs_index = np.random.randint(M, size=(N, M))\n        bsData = data[bs_index]\n        estimate = np.median(bsData, axis=1, overwrite_input=True)\n\n        CI = np.percentile(estimate, percentiles)\n        return CI\n\n    def _compute_conf_interval(data, med, iqr, bootstrap):\n        if bootstrap is not None:\n            # Do a bootstrap estimate of notch locations.\n            # get conf. intervals around median\n            CI = _bootstrap_median(data, N=bootstrap)\n            notch_min = CI[0]\n            notch_max = CI[1]\n        else:\n\n            N = len(data)\n            notch_min = med - 1.57 * iqr / np.sqrt(N)\n            notch_max = med + 1.57 * iqr / np.sqrt(N)\n\n        return notch_min, notch_max\n\n    # output is a list of dicts\n    bxpstats = []\n\n    # convert X to a list of lists\n    X = _reshape_2D(X, \"X\")\n\n    ncols = len(X)\n    if labels is None:\n        labels = itertools.repeat(None)\n    elif len(labels) != ncols:\n        raise ValueError(\"Dimensions of labels and X must be compatible\")\n\n    input_whis = whis\n    for ii, (x, label) in enumerate(zip(X, labels)):\n\n        # empty dict\n        stats = {}\n        if label is not None:\n            stats['label'] = label\n\n        # restore whis to the input values in case it got changed in the loop\n        whis = input_whis\n\n        # note tricksiness, append up here and then mutate below\n        bxpstats.append(stats)\n\n        # if empty, bail\n        if len(x) == 0:\n            stats['fliers'] = np.array([])\n            stats['mean'] = np.nan\n            stats['med'] = np.nan\n            stats['q1'] = np.nan\n            stats['q3'] = np.nan\n            stats['cilo'] = np.nan\n            stats['cihi'] = np.nan\n            stats['whislo'] = np.nan\n            stats['whishi'] = np.nan\n            stats['med'] = np.nan\n            continue\n\n        # up-convert to an array, just to be safe\n        x = np.asarray(x)\n\n        # arithmetic mean\n        stats['mean'] = np.mean(x)\n\n        # medians and quartiles\n        q1, med, q3 = np.percentile(x, [25, 50, 75])\n\n        # interquartile range\n        stats['iqr'] = q3 - q1\n        if stats['iqr'] == 0 and autorange:\n            whis = (0, 100)\n\n        # conf. interval around median\n        stats['cilo'], stats['cihi'] = _compute_conf_interval(\n            x, med, stats['iqr'], bootstrap\n        )\n\n        # lowest/highest non-outliers\n        if np.isscalar(whis):\n            if np.isreal(whis):\n                loval = q1 - whis * stats['iqr']\n                hival = q3 + whis * stats['iqr']\n            elif whis in ['range', 'limit', 'limits', 'min/max']:\n                warn_deprecated(\n                    \"3.2\", message=f\"Setting whis to {whis!r} is deprecated \"\n                    \"since %(since)s and support for it will be removed \"\n                    \"%(removal)s; set it to [0, 100] to achieve the same \"\n                    \"effect.\")\n                loval = np.min(x)\n                hival = np.max(x)\n            else:\n                raise ValueError('whis must be a float or list of percentiles')\n        else:\n            loval, hival = np.percentile(x, whis)\n\n        # get high extreme\n        wiskhi = x[x <= hival]\n        if len(wiskhi) == 0 or np.max(wiskhi) < q3:\n            stats['whishi'] = q3\n        else:\n            stats['whishi'] = np.max(wiskhi)\n\n        # get low extreme\n        wisklo = x[x >= loval]\n        if len(wisklo) == 0 or np.min(wisklo) > q1:\n            stats['whislo'] = q1\n        else:\n            stats['whislo'] = np.min(wisklo)\n\n        # compute a single array of outliers\n        stats['fliers'] = np.hstack([\n            x[x < stats['whislo']],\n            x[x > stats['whishi']],\n        ])\n\n        # add in the remaining stats\n        stats['q1'], stats['med'], stats['q3'] = q1, med, q3\n\n    return bxpstats",
        "begin_line": 1050,
        "end_line": 1261,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._bootstrap_median#1134",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._bootstrap_median(data, N=5000)",
        "snippet": "    def _bootstrap_median(data, N=5000):\n        # determine 95% confidence intervals of the median\n        M = len(data)\n        percentiles = [2.5, 97.5]\n\n        bs_index = np.random.randint(M, size=(N, M))\n        bsData = data[bs_index]\n        estimate = np.median(bsData, axis=1, overwrite_input=True)\n\n        CI = np.percentile(estimate, percentiles)\n        return CI",
        "begin_line": 1134,
        "end_line": 1144,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._compute_conf_interval#1146",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._compute_conf_interval(data, med, iqr, bootstrap)",
        "snippet": "    def _compute_conf_interval(data, med, iqr, bootstrap):\n        if bootstrap is not None:\n            # Do a bootstrap estimate of notch locations.\n            # get conf. intervals around median\n            CI = _bootstrap_median(data, N=bootstrap)\n            notch_min = CI[0]\n            notch_max = CI[1]\n        else:\n\n            N = len(data)\n            notch_min = med - 1.57 * iqr / np.sqrt(N)\n            notch_max = med + 1.57 * iqr / np.sqrt(N)\n\n        return notch_min, notch_max",
        "begin_line": 1146,
        "end_line": 1159,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001380071763731714,
            "pseudo_dstar_susp": 0.00013869625520110957,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00013869625520110957,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.contiguous_regions#1270",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.contiguous_regions(mask)",
        "snippet": "def contiguous_regions(mask):\n    \"\"\"\n    Return a list of (ind0, ind1) such that ``mask[ind0:ind1].all()`` is\n    True and we cover all such regions.\n    \"\"\"\n    mask = np.asarray(mask, dtype=bool)\n\n    if not mask.size:\n        return []\n\n    # Find the indices of region changes, and correct offset\n    idx, = np.nonzero(mask[:-1] != mask[1:])\n    idx += 1\n\n    # List operations are faster for moderately sized arrays\n    idx = idx.tolist()\n\n    # Add first and/or last index if needed\n    if mask[0]:\n        idx = [0] + idx\n    if mask[-1]:\n        idx.append(len(mask))\n\n    return list(zip(idx[::2], idx[1::2]))",
        "begin_line": 1270,
        "end_line": 1293,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002447381302006853,
            "pseudo_dstar_susp": 0.00023020257826887662,
            "pseudo_tarantula_susp": 0.00027739251040221914,
            "pseudo_op2_susp": 0.00023020257826887662,
            "pseudo_barinel_susp": 0.00027739251040221914
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.is_math_text#1296",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.is_math_text(s)",
        "snippet": "def is_math_text(s):\n    \"\"\"\n    Returns whether the string *s* contains math expressions.\n\n    This is done by checking whether *s* contains an even number of\n    non-escaped dollar signs.\n    \"\"\"\n    s = str(s)\n    dollar_count = s.count(r'$') - s.count(r'\\$')\n    even_dollars = (dollar_count > 0 and dollar_count % 2 == 0)\n    return even_dollars",
        "begin_line": 1296,
        "end_line": 1306,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010152284263959391,
            "pseudo_dstar_susp": 0.0034129692832764505,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0034129692832764505,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._to_unmasked_float_array#1309",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._to_unmasked_float_array(x)",
        "snippet": "def _to_unmasked_float_array(x):\n    \"\"\"\n    Convert a sequence to a float array; if input was a masked array, masked\n    values are converted to nans.\n    \"\"\"\n    if hasattr(x, 'mask'):\n        return np.ma.asarray(x, float).filled(np.nan)\n    else:\n        return np.asarray(x, float)",
        "begin_line": 1309,
        "end_line": 1317,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00034376074252320387,
            "pseudo_dstar_susp": 0.0005549389567147614,
            "pseudo_tarantula_susp": 0.00022187708009762592,
            "pseudo_op2_susp": 0.0005549389567147614,
            "pseudo_barinel_susp": 0.00022187708009762592
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._check_1d#1320",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._check_1d(x)",
        "snippet": "def _check_1d(x):\n    '''\n    Converts a sequence of less than 1 dimension, to an array of 1\n    dimension; leaves everything else untouched.\n    '''\n    if not hasattr(x, 'shape') or len(x.shape) < 1:\n        return np.atleast_1d(x)\n    else:\n        try:\n            ndim = x[:, None].ndim\n            # work around https://github.com/pandas-dev/pandas/issues/27775\n            # which mean the shape is not as expected. That this ever worked\n            # was an unintentional quirk of pandas the above line will raise\n            # an exception in the future.\n            if ndim < 2:\n                return np.atleast_1d(x)\n            return x\n        except (IndexError, TypeError):\n            return np.atleast_1d(x)",
        "begin_line": 1320,
        "end_line": 1338,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002388344877000239,
            "pseudo_dstar_susp": 0.0002300966405890474,
            "pseudo_tarantula_susp": 0.00026021337496747333,
            "pseudo_op2_susp": 0.0002300966405890474,
            "pseudo_barinel_susp": 0.00026021337496747333
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._reshape_2D#1341",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._reshape_2D(X, name)",
        "snippet": "def _reshape_2D(X, name):\n    \"\"\"\n    Use Fortran ordering to convert ndarrays and lists of iterables to lists of\n    1D arrays.\n\n    Lists of iterables are converted by applying `np.asarray` to each of their\n    elements.  1D ndarrays are returned in a singleton list containing them.\n    2D ndarrays are converted to the list of their *columns*.\n\n    *name* is used to generate the error message for invalid inputs.\n    \"\"\"\n    # Iterate over columns for ndarrays, over rows otherwise.\n    X = np.atleast_1d(X.T if isinstance(X, np.ndarray) else np.asarray(X))\n    if len(X) == 0:\n        return [[]]\n    elif X.ndim == 1 and np.ndim(X[0]) == 0:\n        # 1D array of scalars: directly return it.\n        return [X]\n    elif X.ndim in [1, 2]:\n        # 2D array, or 1D array of iterables: flatten them first.\n        return [np.reshape(x, -1) for x in X]\n    else:\n        raise ValueError(\"{} must have 2 or fewer dimensions\".format(name))",
        "begin_line": 1341,
        "end_line": 1363,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.pts_to_prestep#1463",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.pts_to_prestep(x, *args)",
        "snippet": "def pts_to_prestep(x, *args):\n    \"\"\"\n    Convert continuous line to pre-steps.\n\n    Given a set of ``N`` points, convert to ``2N - 1`` points, which when\n    connected linearly give a step function which changes values at the\n    beginning of the intervals.\n\n    Parameters\n    ----------\n    x : array\n        The x location of the steps. May be empty.\n\n    y1, ..., yp : array\n        y arrays to be turned into steps; all must be the same length as ``x``.\n\n    Returns\n    -------\n    out : array\n        The x and y values converted to steps in the same order as the input;\n        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n        length ``N``, each of these arrays will be length ``2N + 1``. For\n        ``N=0``, the length will be 0.\n\n    Examples\n    --------\n    >>> x_s, y1_s, y2_s = pts_to_prestep(x, y1, y2)\n    \"\"\"\n    steps = np.zeros((1 + len(args), max(2 * len(x) - 1, 0)))\n    # In all `pts_to_*step` functions, only assign once using *x* and *args*,\n    # as converting to an array may be expensive.\n    steps[0, 0::2] = x\n    steps[0, 1::2] = steps[0, 0:-2:2]\n    steps[1:, 0::2] = args\n    steps[1:, 1::2] = steps[1:, 2::2]\n    return steps",
        "begin_line": 1463,
        "end_line": 1498,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.pts_to_poststep#1501",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.pts_to_poststep(x, *args)",
        "snippet": "def pts_to_poststep(x, *args):\n    \"\"\"\n    Convert continuous line to post-steps.\n\n    Given a set of ``N`` points convert to ``2N + 1`` points, which when\n    connected linearly give a step function which changes values at the end of\n    the intervals.\n\n    Parameters\n    ----------\n    x : array\n        The x location of the steps. May be empty.\n\n    y1, ..., yp : array\n        y arrays to be turned into steps; all must be the same length as ``x``.\n\n    Returns\n    -------\n    out : array\n        The x and y values converted to steps in the same order as the input;\n        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n        length ``N``, each of these arrays will be length ``2N + 1``. For\n        ``N=0``, the length will be 0.\n\n    Examples\n    --------\n    >>> x_s, y1_s, y2_s = pts_to_poststep(x, y1, y2)\n    \"\"\"\n    steps = np.zeros((1 + len(args), max(2 * len(x) - 1, 0)))\n    steps[0, 0::2] = x\n    steps[0, 1::2] = steps[0, 2::2]\n    steps[1:, 0::2] = args\n    steps[1:, 1::2] = steps[1:, 0:-2:2]\n    return steps",
        "begin_line": 1501,
        "end_line": 1534,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.pts_to_midstep#1537",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.pts_to_midstep(x, *args)",
        "snippet": "def pts_to_midstep(x, *args):\n    \"\"\"\n    Convert continuous line to mid-steps.\n\n    Given a set of ``N`` points convert to ``2N`` points which when connected\n    linearly give a step function which changes values at the middle of the\n    intervals.\n\n    Parameters\n    ----------\n    x : array\n        The x location of the steps. May be empty.\n\n    y1, ..., yp : array\n        y arrays to be turned into steps; all must be the same length as\n        ``x``.\n\n    Returns\n    -------\n    out : array\n        The x and y values converted to steps in the same order as the input;\n        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n        length ``N``, each of these arrays will be length ``2N``.\n\n    Examples\n    --------\n    >>> x_s, y1_s, y2_s = pts_to_midstep(x, y1, y2)\n    \"\"\"\n    steps = np.zeros((1 + len(args), 2 * len(x)))\n    x = np.asanyarray(x)\n    steps[0, 1:-1:2] = steps[0, 2::2] = (x[:-1] + x[1:]) / 2\n    steps[0, :1] = x[:1]  # Also works for zero-sized input.\n    steps[0, -1:] = x[-1:]\n    steps[1:, 0::2] = args\n    steps[1:, 1::2] = steps[1:, 0::2]\n    return steps",
        "begin_line": 1537,
        "end_line": 1572,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.index_of#1582",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.index_of(y)",
        "snippet": "def index_of(y):\n    \"\"\"\n    A helper function to create reasonable x values for the given *y*.\n\n    This is used for plotting (x, y) if x values are not explicitly given.\n\n    First try ``y.index`` (assuming *y* is a `pandas.Series`), if that\n    fails, use ``range(len(y))``.\n\n    This will be extended in the future to deal with more types of\n    labeled data.\n\n    Parameters\n    ----------\n    y : scalar or array-like\n\n    Returns\n    -------\n    x, y : ndarray\n       The x and y values to plot.\n    \"\"\"\n    try:\n        return y.index.values, y.values\n    except AttributeError:\n        y = _check_1d(y)\n        return np.arange(y.shape[0], dtype=float), y",
        "begin_line": 1582,
        "end_line": 1607,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023837902264600716,
            "pseudo_dstar_susp": 0.0002767783005812344,
            "pseudo_tarantula_susp": 0.00021399529210357372,
            "pseudo_op2_susp": 0.0002767783005812344,
            "pseudo_barinel_susp": 0.00021399529210357372
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.safe_first_element#1610",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.safe_first_element(obj)",
        "snippet": "def safe_first_element(obj):\n    \"\"\"\n    Return the first element in *obj*.\n\n    This is an type-independent way of obtaining the first element, supporting\n    both index access and the iterator protocol.\n    \"\"\"\n    if isinstance(obj, collections.abc.Iterator):\n        # needed to accept `array.flat` as input.\n        # np.flatiter reports as an instance of collections.Iterator\n        # but can still be indexed via [].\n        # This has the side effect of re-setting the iterator, but\n        # that is acceptable.\n        try:\n            return obj[0]\n        except TypeError:\n            pass\n        raise RuntimeError(\"matplotlib does not support generators \"\n                           \"as input\")\n    return next(iter(obj))",
        "begin_line": 1610,
        "end_line": 1629,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.sanitize_sequence#1632",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.sanitize_sequence(data)",
        "snippet": "def sanitize_sequence(data):\n    \"\"\"\n    Convert dictview objects to list. Other inputs are returned unchanged.\n    \"\"\"\n    return (list(data) if isinstance(data, collections.abc.MappingView)\n            else data)",
        "begin_line": 1632,
        "end_line": 1637,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.normalize_kwargs#1640",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.normalize_kwargs(kw, alias_mapping=None, required=(), forbidden=(), allowed=None)",
        "snippet": "def normalize_kwargs(kw, alias_mapping=None, required=(), forbidden=(),\n                     allowed=None):\n    \"\"\"\n    Helper function to normalize kwarg inputs.\n\n    The order they are resolved are:\n\n    1. aliasing\n    2. required\n    3. forbidden\n    4. allowed\n\n    This order means that only the canonical names need appear in\n    *allowed*, *forbidden*, *required*.\n\n    Parameters\n    ----------\n    kw : dict\n        A dict of keyword arguments.\n\n    alias_mapping : dict or Artist subclass or Artist instance, optional\n        A mapping between a canonical name to a list of\n        aliases, in order of precedence from lowest to highest.\n\n        If the canonical value is not in the list it is assumed to have\n        the highest priority.\n\n        If an Artist subclass or instance is passed, use its properties alias\n        mapping.\n\n    required : list of str, optional\n        A list of keys that must be in *kws*.\n\n    forbidden : list of str, optional\n        A list of keys which may not be in *kw*.\n\n    allowed : list of str, optional\n        A list of allowed fields.  If this not None, then raise if\n        *kw* contains any keys not in the union of *required*\n        and *allowed*.  To allow only the required fields pass in\n        an empty tuple ``allowed=()``.\n\n    Raises\n    ------\n    TypeError\n        To match what python raises if invalid args/kwargs are passed to\n        a callable.\n    \"\"\"\n    from matplotlib.artist import Artist\n\n    # deal with default value of alias_mapping\n    if alias_mapping is None:\n        alias_mapping = dict()\n    elif (isinstance(alias_mapping, type) and issubclass(alias_mapping, Artist)\n          or isinstance(alias_mapping, Artist)):\n        alias_mapping = getattr(alias_mapping, \"_alias_map\", {})\n\n    # make a local so we can pop\n    kw = dict(kw)\n    # output dictionary\n    ret = dict()\n\n    # hit all alias mappings\n    for canonical, alias_list in alias_mapping.items():\n\n        # the alias lists are ordered from lowest to highest priority\n        # so we know to use the last value in this list\n        tmp = []\n        seen = []\n        for a in alias_list:\n            try:\n                tmp.append(kw.pop(a))\n                seen.append(a)\n            except KeyError:\n                pass\n        # if canonical is not in the alias_list assume highest priority\n        if canonical not in alias_list:\n            try:\n                tmp.append(kw.pop(canonical))\n                seen.append(canonical)\n            except KeyError:\n                pass\n        # if we found anything in this set of aliases put it in the return\n        # dict\n        if tmp:\n            ret[canonical] = tmp[-1]\n            if len(tmp) > 1:\n                warn_deprecated(\n                    \"3.1\", message=f\"Saw kwargs {seen!r} which are all \"\n                    f\"aliases for {canonical!r}.  Kept value from \"\n                    f\"{seen[-1]!r}.  Passing multiple aliases for the same \"\n                    f\"property will raise a TypeError %(removal)s.\")\n\n    # at this point we know that all keys which are aliased are removed, update\n    # the return dictionary from the cleaned local copy of the input\n    ret.update(kw)\n\n    fail_keys = [k for k in required if k not in ret]\n    if fail_keys:\n        raise TypeError(\"The required keys {keys!r} \"\n                        \"are not in kwargs\".format(keys=fail_keys))\n\n    fail_keys = [k for k in forbidden if k in ret]\n    if fail_keys:\n        raise TypeError(\"The forbidden keys {keys!r} \"\n                        \"are in kwargs\".format(keys=fail_keys))\n\n    if allowed is not None:\n        allowed_set = {*required, *allowed}\n        fail_keys = [k for k in ret if k not in allowed_set]\n        if fail_keys:\n            raise TypeError(\n                \"kwargs contains {keys!r} which are not in the required \"\n                \"{req!r} or allowed {allow!r} keys\".format(\n                    keys=fail_keys, req=required, allow=allowed))\n\n    return ret",
        "begin_line": 1640,
        "end_line": 1756,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004045307443365696,
            "pseudo_dstar_susp": 0.0005841121495327102,
            "pseudo_tarantula_susp": 0.0002644802962179318,
            "pseudo_op2_susp": 0.0005841121495327102,
            "pseudo_barinel_susp": 0.0002644802962179318
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._topmost_artist#1815",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._topmost_artist(artists, _cached_max=functools.partial(max, key=operator.attrgetter('zorder')))",
        "snippet": "def _topmost_artist(\n        artists,\n        _cached_max=functools.partial(max, key=operator.attrgetter(\"zorder\"))):\n    \"\"\"Get the topmost artist of a list.\n\n    In case of a tie, return the *last* of the tied artists, as it will be\n    drawn on top of the others. `max` returns the first maximum in case of\n    ties, so we need to iterate over the list in reverse order.\n    \"\"\"\n    return _cached_max(reversed(artists))",
        "begin_line": 1815,
        "end_line": 1824,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._str_equal#1827",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._str_equal(obj, s)",
        "snippet": "def _str_equal(obj, s):\n    \"\"\"Return whether *obj* is a string equal to string *s*.\n\n    This helper solely exists to handle the case where *obj* is a numpy array,\n    because in such cases, a naive ``obj == s`` would yield an array, which\n    cannot be used in a boolean context.\n    \"\"\"\n    return isinstance(obj, str) and obj == s",
        "begin_line": 1827,
        "end_line": 1834,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012970168612191958,
            "pseudo_dstar_susp": 0.002109704641350211,
            "pseudo_tarantula_susp": 0.000375234521575985,
            "pseudo_op2_susp": 0.002109704641350211,
            "pseudo_barinel_susp": 0.000375234521575985
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._str_lower_equal#1837",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._str_lower_equal(obj, s)",
        "snippet": "def _str_lower_equal(obj, s):\n    \"\"\"Return whether *obj* is a string equal, when lowercased, to string *s*.\n\n    This helper solely exists to handle the case where *obj* is a numpy array,\n    because in such cases, a naive ``obj == s`` would yield an array, which\n    cannot be used in a boolean context.\n    \"\"\"\n    return isinstance(obj, str) and obj.lower() == s",
        "begin_line": 1837,
        "end_line": 1844,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000271370420624152,
            "pseudo_dstar_susp": 0.0002536783358701167,
            "pseudo_tarantula_susp": 0.0002844141069397042,
            "pseudo_op2_susp": 0.0002536783358701167,
            "pseudo_barinel_susp": 0.0002844141069397042
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.make_alias#1867",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.make_alias(name)",
        "snippet": "    def make_alias(name):  # Enforce a closure over *name*.\n        @functools.wraps(getattr(cls, name))\n        def method(self, *args, **kwargs):\n            return getattr(self, name)(*args, **kwargs)\n        return method",
        "begin_line": 1867,
        "end_line": 1871,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.method#1869",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.method(self, *args, **kwargs)",
        "snippet": "        def method(self, *args, **kwargs):\n            return getattr(self, name)(*args, **kwargs)",
        "begin_line": 1869,
        "end_line": 1870,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003348961821835231,
            "pseudo_dstar_susp": 0.0003544842254519674,
            "pseudo_tarantula_susp": 0.00017917935853789643,
            "pseudo_op2_susp": 0.0003544842254519674,
            "pseudo_barinel_susp": 0.00017917935853789643
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._setattr_cm#1934",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._setattr_cm(obj, **kwargs)",
        "snippet": "def _setattr_cm(obj, **kwargs):\n    \"\"\"Temporarily set some attributes; restore original state at context exit.\n    \"\"\"\n    sentinel = object()\n    origs = [(attr, getattr(obj, attr, sentinel)) for attr in kwargs]\n    try:\n        for attr, val in kwargs.items():\n            setattr(obj, attr, val)\n        yield\n    finally:\n        for attr, orig in origs:\n            if orig is sentinel:\n                delattr(obj, attr)\n            else:\n                setattr(obj, attr, orig)",
        "begin_line": 1934,
        "end_line": 1948,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.016666666666666666,
            "pseudo_dstar_susp": 0.007633587786259542,
            "pseudo_tarantula_susp": 0.0005128205128205128,
            "pseudo_op2_susp": 0.007633587786259542,
            "pseudo_barinel_susp": 0.000513083632632119
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._warn_external#1951",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._warn_external(message, category=None)",
        "snippet": "def _warn_external(message, category=None):\n    \"\"\"\n    `warnings.warn` wrapper that sets *stacklevel* to \"outside Matplotlib\".\n\n    The original emitter of the warning can be obtained by patching this\n    function back to `warnings.warn`, i.e. ``cbook._warn_external =\n    warnings.warn`` (or ``functools.partial(warnings.warn, stacklevel=2)``,\n    etc.).\n    \"\"\"\n    frame = sys._getframe()\n    for stacklevel in itertools.count(1):  # lgtm[py/unused-loop-variable]\n        if frame is None:\n            # when called in embedded context may hit frame is None\n            break\n        if not re.match(r\"\\A(matplotlib|mpl_toolkits)(\\Z|\\.(?!tests\\.))\",\n                        # Work around sphinx-gallery not setting __name__.\n                        frame.f_globals.get(\"__name__\", \"\")):\n            break\n        frame = frame.f_back\n    warnings.warn(message, category, stacklevel)",
        "begin_line": 1951,
        "end_line": 1970,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008278145695364238,
            "pseudo_dstar_susp": 0.0020325203252032522,
            "pseudo_tarantula_susp": 0.00018573551263001485,
            "pseudo_op2_susp": 0.0020325203252032522,
            "pseudo_barinel_susp": 0.00018573551263001485
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._OrderedSet.__contains__#1977",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__._OrderedSet",
        "signature": "lib.matplotlib.cbook.__init__._OrderedSet.__contains__(self, key)",
        "snippet": "    def __contains__(self, key):\n        return key in self._od",
        "begin_line": 1977,
        "end_line": 1978,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._OrderedSet.discard#1990",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__._OrderedSet",
        "signature": "lib.matplotlib.cbook.__init__._OrderedSet.discard(self, key)",
        "snippet": "    def discard(self, key):\n        self._od.pop(key, None)",
        "begin_line": 1990,
        "end_line": 1991,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011559357299734135,
            "pseudo_dstar_susp": 0.00011440338634023568,
            "pseudo_tarantula_susp": 0.00011862396204033214,
            "pseudo_op2_susp": 0.00011440338634023568,
            "pseudo_barinel_susp": 0.00011862396204033214
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._pformat_subprocess#2036",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._pformat_subprocess(command)",
        "snippet": "def _pformat_subprocess(command):\n    \"\"\"Pretty-format a subprocess command for printing/logging purposes.\"\"\"\n    return (command if isinstance(command, str)\n            else \" \".join(shlex.quote(os.fspath(arg)) for arg in command))",
        "begin_line": 2036,
        "end_line": 2039,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._check_isinstance#2073",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._check_isinstance(_types, **kwargs)",
        "snippet": "def _check_isinstance(_types, **kwargs):\n    \"\"\"\n    For each *key, value* pair in *kwargs*, check that *value* is an instance\n    of one of *_types*; if not, raise an appropriate TypeError.\n\n    As a special case, a ``None`` entry in *_types* is treated as NoneType.\n\n    Examples\n    --------\n    >>> cbook._check_isinstance((SomeClass, None), arg=arg)\n    \"\"\"\n    types = _types\n    if isinstance(types, type) or types is None:\n        types = (types,)\n    none_allowed = None in types\n    types = tuple(tp for tp in types if tp is not None)\n\n    def type_name(tp):\n        return (tp.__qualname__ if tp.__module__ == \"builtins\"\n                else f\"{tp.__module__}.{tp.__qualname__}\")\n\n    names = [*map(type_name, types)]\n    if none_allowed:\n        types = (*types, type(None))\n        names.append(\"None\")\n    for k, v in kwargs.items():\n        if not isinstance(v, types):\n            raise TypeError(\n                \"{!r} must be an instance of {}, not a {}\".format(\n                    k,\n                    \", \".join(names[:-1]) + \" or \" + names[-1]\n                    if len(names) > 1 else names[0],\n                    type_name(type(v))))",
        "begin_line": 2073,
        "end_line": 2105,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003361344537815126,
            "pseudo_dstar_susp": 0.00047192071731949034,
            "pseudo_tarantula_susp": 0.00022187708009762592,
            "pseudo_op2_susp": 0.00047192071731949034,
            "pseudo_barinel_susp": 0.00022187708009762592
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.type_name#2090",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.type_name(tp)",
        "snippet": "    def type_name(tp):\n        return (tp.__qualname__ if tp.__module__ == \"builtins\"\n                else f\"{tp.__module__}.{tp.__qualname__}\")",
        "begin_line": 2090,
        "end_line": 2092,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._check_in_list#2108",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._check_in_list(_values, **kwargs)",
        "snippet": "def _check_in_list(_values, **kwargs):\n    \"\"\"\n    For each *key, value* pair in *kwargs*, check that *value* is in *_values*;\n    if not, raise an appropriate ValueError.\n\n    Examples\n    --------\n    >>> cbook._check_in_list([\"foo\", \"bar\"], arg=arg, other_arg=other_arg)\n    \"\"\"\n    values = _values\n    for k, v in kwargs.items():\n        if v not in values:\n            raise ValueError(\n                \"{!r} is not a valid value for {}; supported values are {}\"\n                .format(v, k, ', '.join(map(repr, values))))",
        "begin_line": 2108,
        "end_line": 2122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002457002457002457,
            "pseudo_dstar_susp": 0.0004576659038901602,
            "pseudo_tarantula_susp": 0.00016488046166529267,
            "pseudo_op2_susp": 0.0004576659038901602,
            "pseudo_barinel_susp": 0.00016482610845557937
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._check_getitem#2125",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._check_getitem(_mapping, **kwargs)",
        "snippet": "def _check_getitem(_mapping, **kwargs):\n    \"\"\"\n    *kwargs* must consist of a single *key, value* pair.  If *key* is in\n    *_mapping*, return ``_mapping[value]``; else, raise an appropriate\n    ValueError.\n\n    Examples\n    --------\n    >>> cbook._check_getitem({\"foo\": \"bar\"}, arg=arg)\n    \"\"\"\n    mapping = _mapping\n    if len(kwargs) != 1:\n        raise ValueError(\"_check_getitem takes a single keyword argument\")\n    (k, v), = kwargs.items()\n    try:\n        return mapping[v]\n    except KeyError:\n        raise ValueError(\n            \"{!r} is not a valid value for {}; supported values are {}\"\n            .format(v, k, ', '.join(map(repr, mapping)))) from None",
        "begin_line": 2125,
        "end_line": 2144,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00199203187250996,
            "pseudo_dstar_susp": 0.002004008016032064,
            "pseudo_tarantula_susp": 0.0005089058524173028,
            "pseudo_op2_susp": 0.002004008016032064,
            "pseudo_barinel_susp": 0.0005089058524173028
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._classproperty.__get__#2167",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__._classproperty",
        "signature": "lib.matplotlib.cbook.__init__._classproperty.__get__(self, instance, owner)",
        "snippet": "    def __get__(self, instance, owner):\n        return self._fget(owner)",
        "begin_line": 2167,
        "end_line": 2168,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.__init__#42",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.__init__(self, edgecolor=None, facecolor=None, color=None, linewidth=None, linestyle=None, antialiased=None, hatch=None, fill=True, capstyle=None, joinstyle=None, **kwargs)",
        "snippet": "    def __init__(self,\n                 edgecolor=None,\n                 facecolor=None,\n                 color=None,\n                 linewidth=None,\n                 linestyle=None,\n                 antialiased=None,\n                 hatch=None,\n                 fill=True,\n                 capstyle=None,\n                 joinstyle=None,\n                 **kwargs):\n        \"\"\"\n        The following kwarg properties are supported\n\n        %(Patch)s\n        \"\"\"\n        artist.Artist.__init__(self)\n\n        if linewidth is None:\n            linewidth = mpl.rcParams['patch.linewidth']\n        if linestyle is None:\n            linestyle = \"solid\"\n        if capstyle is None:\n            capstyle = 'butt'\n        if joinstyle is None:\n            joinstyle = 'miter'\n        if antialiased is None:\n            antialiased = mpl.rcParams['patch.antialiased']\n\n        self._hatch_color = colors.to_rgba(mpl.rcParams['hatch.color'])\n        self._fill = True  # needed for set_facecolor call\n        if color is not None:\n            if edgecolor is not None or facecolor is not None:\n                cbook._warn_external(\n                    \"Setting the 'color' property will override \"\n                    \"the edgecolor or facecolor properties.\")\n            self.set_color(color)\n        else:\n            self.set_edgecolor(edgecolor)\n            self.set_facecolor(facecolor)\n        # unscaled dashes.  Needed to scale dash patterns by lw\n        self._us_dashes = None\n        self._linewidth = 0\n\n        self.set_fill(fill)\n        self.set_linestyle(linestyle)\n        self.set_linewidth(linewidth)\n        self.set_antialiased(antialiased)\n        self.set_hatch(hatch)\n        self.set_capstyle(capstyle)\n        self.set_joinstyle(joinstyle)\n\n        if len(kwargs):\n            self.update(kwargs)",
        "begin_line": 42,
        "end_line": 96,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009174311926605505,
            "pseudo_dstar_susp": 0.010101010101010102,
            "pseudo_tarantula_susp": 0.00043554006968641115,
            "pseudo_op2_susp": 0.010101010101010102,
            "pseudo_barinel_susp": 0.00043554006968641115
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.contains_point#155",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.contains_point(self, point, radius=None)",
        "snippet": "    def contains_point(self, point, radius=None):\n        \"\"\"\n        Return whether the given point is inside the patch.\n\n        Parameters\n        ----------\n        point : (float, float)\n            The point (x, y) to check, in target coordinates of\n            ``self.get_transform()``. These are display coordinates for patches\n            that are added to a figure or axes.\n        radius : float, optional\n            Add an additional margin on the patch in target coordinates of\n            ``self.get_transform()``. See `.Path.contains_point` for further\n            details.\n\n        Returns\n        -------\n        bool\n\n        Notes\n        -----\n        The proper use of this method depends on the transform of the patch.\n        Isolated patches do not have a transform. In this case, the patch\n        creation coordinates and the point coordinates match. The following\n        example checks that the center of a circle is within the circle\n\n        >>> center = 0, 0\n        >>> c = Circle(center, radius=1)\n        >>> c.contains_point(center)\n        True\n\n        The convention of checking against the transformed patch stems from\n        the fact that this method is predominantly used to check if display\n        coordinates (e.g. from mouse events) are within the patch. If you want\n        to do the above check with data coordinates, you have to properly\n        transform them first:\n\n        >>> center = 0, 0\n        >>> c = Circle(center, radius=1)\n        >>> plt.gca().add_patch(c)\n        >>> transformed_center = c.get_transform().transform(center)\n        >>> c.contains_point(transformed_center)\n        True\n\n        \"\"\"\n        radius = self._process_radius(radius)\n        return self.get_path().contains_point(point,\n                                              self.get_transform(),\n                                              radius)",
        "begin_line": 155,
        "end_line": 203,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.get_transform#260",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.get_transform(self)",
        "snippet": "    def get_transform(self):\n        \"\"\"Return the `~.transforms.Transform` applied to the `Patch`.\"\"\"\n        return self.get_patch_transform() + artist.Artist.get_transform(self)",
        "begin_line": 260,
        "end_line": 262,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011037527593818985,
            "pseudo_dstar_susp": 0.0018587360594795538,
            "pseudo_tarantula_susp": 0.000333555703802535,
            "pseudo_op2_susp": 0.0018587360594795538,
            "pseudo_barinel_susp": 0.000333555703802535
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.get_data_transform#264",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.get_data_transform(self)",
        "snippet": "    def get_data_transform(self):\n        \"\"\"\n        Return the :class:`~matplotlib.transforms.Transform` instance which\n        maps data coordinates to physical coordinates.\n        \"\"\"\n        return artist.Artist.get_transform(self)",
        "begin_line": 264,
        "end_line": 269,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.get_edgecolor#286",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.get_edgecolor(self)",
        "snippet": "    def get_edgecolor(self):\n        \"\"\"Return the edge color.\"\"\"\n        return self._edgecolor",
        "begin_line": 286,
        "end_line": 288,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022624434389140274,
            "pseudo_dstar_susp": 0.0013550135501355014,
            "pseudo_tarantula_susp": 0.0005279831045406547,
            "pseudo_op2_susp": 0.0013550135501355014,
            "pseudo_barinel_susp": 0.0005279831045406547
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.get_facecolor#290",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.get_facecolor(self)",
        "snippet": "    def get_facecolor(self):\n        \"\"\"Return the face color.\"\"\"\n        return self._facecolor",
        "begin_line": 290,
        "end_line": 292,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00228310502283105,
            "pseudo_dstar_susp": 0.0013623978201634877,
            "pseudo_tarantula_susp": 0.0005302226935312832,
            "pseudo_op2_susp": 0.0013623978201634877,
            "pseudo_barinel_susp": 0.0005302226935312832
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.set_antialiased#302",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.set_antialiased(self, aa)",
        "snippet": "    def set_antialiased(self, aa):\n        \"\"\"\n        Set whether to use antialiased rendering.\n\n        Parameters\n        ----------\n        b : bool or None\n        \"\"\"\n        if aa is None:\n            aa = mpl.rcParams['patch.antialiased']\n        self._antialiased = aa\n        self.stale = True",
        "begin_line": 302,
        "end_line": 313,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013568521031207597,
            "pseudo_dstar_susp": 0.0011098779134295228,
            "pseudo_tarantula_susp": 0.00044543429844097997,
            "pseudo_op2_susp": 0.0011098779134295228,
            "pseudo_barinel_susp": 0.00044543429844097997
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch._set_edgecolor#315",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch._set_edgecolor(self, color)",
        "snippet": "    def _set_edgecolor(self, color):\n        set_hatch_color = True\n        if color is None:\n            if (mpl.rcParams['patch.force_edgecolor'] or\n                    not self._fill or self._edge_default):\n                color = mpl.rcParams['patch.edgecolor']\n            else:\n                color = 'none'\n                set_hatch_color = False\n\n        self._edgecolor = colors.to_rgba(color, self._alpha)\n        if set_hatch_color:\n            self._hatch_color = self._edgecolor\n        self.stale = True",
        "begin_line": 315,
        "end_line": 328,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001388888888888889,
            "pseudo_dstar_susp": 0.0011248593925759281,
            "pseudo_tarantula_susp": 0.0004508566275924256,
            "pseudo_op2_susp": 0.0011248593925759281,
            "pseudo_barinel_susp": 0.0004508566275924256
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.set_edgecolor#330",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.set_edgecolor(self, color)",
        "snippet": "    def set_edgecolor(self, color):\n        \"\"\"\n        Set the patch edge color.\n\n        Parameters\n        ----------\n        color : color or None or 'auto'\n        \"\"\"\n        self._original_edgecolor = color\n        self._set_edgecolor(color)",
        "begin_line": 330,
        "end_line": 339,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013568521031207597,
            "pseudo_dstar_susp": 0.0011098779134295228,
            "pseudo_tarantula_susp": 0.00044543429844097997,
            "pseudo_op2_susp": 0.0011098779134295228,
            "pseudo_barinel_susp": 0.00044543429844097997
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch._set_facecolor#341",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch._set_facecolor(self, color)",
        "snippet": "    def _set_facecolor(self, color):\n        if color is None:\n            color = mpl.rcParams['patch.facecolor']\n        alpha = self._alpha if self._fill else 0\n        self._facecolor = colors.to_rgba(color, alpha)\n        self.stale = True",
        "begin_line": 341,
        "end_line": 346,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012919896640826874,
            "pseudo_dstar_susp": 0.0011025358324145535,
            "pseudo_tarantula_susp": 0.00043122035360068997,
            "pseudo_op2_susp": 0.0011025358324145535,
            "pseudo_barinel_susp": 0.00043122035360068997
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.set_facecolor#348",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.set_facecolor(self, color)",
        "snippet": "    def set_facecolor(self, color):\n        \"\"\"\n        Set the patch face color.\n\n        Parameters\n        ----------\n        color : color or None\n        \"\"\"\n        self._original_facecolor = color\n        self._set_facecolor(color)",
        "begin_line": 348,
        "end_line": 357,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013568521031207597,
            "pseudo_dstar_susp": 0.0011098779134295228,
            "pseudo_tarantula_susp": 0.00044543429844097997,
            "pseudo_op2_susp": 0.0011098779134295228,
            "pseudo_barinel_susp": 0.00044543429844097997
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.set_alpha#375",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.set_alpha(self, alpha)",
        "snippet": "    def set_alpha(self, alpha):\n        # docstring inherited\n        super().set_alpha(alpha)\n        self._set_facecolor(self._original_facecolor)\n        self._set_edgecolor(self._original_edgecolor)",
        "begin_line": 375,
        "end_line": 379,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.set_linewidth#382",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.set_linewidth(self, w)",
        "snippet": "    def set_linewidth(self, w):\n        \"\"\"\n        Set the patch linewidth in points.\n\n        Parameters\n        ----------\n        w : float or None\n        \"\"\"\n        if w is None:\n            w = mpl.rcParams['patch.linewidth']\n            if w is None:\n                w = mpl.rcParams['axes.linewidth']\n\n        self._linewidth = float(w)\n        # scale the dash pattern by the linewidth\n        offset, ls = self._us_dashes\n        self._dashoffset, self._dashes = mlines._scale_dashes(\n            offset, ls, self._linewidth)\n        self.stale = True",
        "begin_line": 382,
        "end_line": 400,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001388888888888889,
            "pseudo_dstar_susp": 0.0011248593925759281,
            "pseudo_tarantula_susp": 0.0004508566275924256,
            "pseudo_op2_susp": 0.0011248593925759281,
            "pseudo_barinel_susp": 0.0004508566275924256
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.set_linestyle#402",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.set_linestyle(self, ls)",
        "snippet": "    def set_linestyle(self, ls):\n        \"\"\"\n        Set the patch linestyle.\n\n        ===========================   =================\n        linestyle                     description\n        ===========================   =================\n        ``'-'`` or ``'solid'``        solid line\n        ``'--'`` or  ``'dashed'``     dashed line\n        ``'-.'`` or  ``'dashdot'``    dash-dotted line\n        ``':'`` or ``'dotted'``       dotted line\n        ===========================   =================\n\n        Alternatively a dash tuple of the following form can be provided::\n\n            (offset, onoffseq)\n\n        where ``onoffseq`` is an even length tuple of on and off ink in points.\n\n        Parameters\n        ----------\n        ls : {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}\n            The line style.\n        \"\"\"\n        if ls is None:\n            ls = \"solid\"\n        self._linestyle = ls\n        # get the unscaled dash pattern\n        offset, ls = self._us_dashes = mlines._get_dash_pattern(ls)\n        # scale the dash pattern by the linewidth\n        self._dashoffset, self._dashes = mlines._scale_dashes(\n            offset, ls, self._linewidth)\n        self.stale = True",
        "begin_line": 402,
        "end_line": 434,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001388888888888889,
            "pseudo_dstar_susp": 0.0011248593925759281,
            "pseudo_tarantula_susp": 0.0004508566275924256,
            "pseudo_op2_susp": 0.0011248593925759281,
            "pseudo_barinel_susp": 0.0004508566275924256
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.set_fill#436",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.set_fill(self, b)",
        "snippet": "    def set_fill(self, b):\n        \"\"\"\n        Set whether to fill the patch.\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        self._fill = bool(b)\n        self._set_facecolor(self._original_facecolor)\n        self._set_edgecolor(self._original_edgecolor)\n        self.stale = True",
        "begin_line": 436,
        "end_line": 447,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001388888888888889,
            "pseudo_dstar_susp": 0.002849002849002849,
            "pseudo_tarantula_susp": 0.0004508566275924256,
            "pseudo_op2_susp": 0.002849002849002849,
            "pseudo_barinel_susp": 0.0004508566275924256
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.set_capstyle#458",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.set_capstyle(self, s)",
        "snippet": "    def set_capstyle(self, s):\n        \"\"\"\n        Set the capstyle.\n\n        Parameters\n        ----------\n        s : {'butt', 'round', 'projecting'}\n        \"\"\"\n        s = s.lower()\n        cbook._check_in_list(self.validCap, capstyle=s)\n        self._capstyle = s\n        self.stale = True",
        "begin_line": 458,
        "end_line": 469,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011013215859030838,
            "pseudo_dstar_susp": 0.001941747572815534,
            "pseudo_tarantula_susp": 0.0003287310979618672,
            "pseudo_op2_susp": 0.001941747572815534,
            "pseudo_barinel_susp": 0.0003287310979618672
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.set_joinstyle#475",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.set_joinstyle(self, s)",
        "snippet": "    def set_joinstyle(self, s):\n        \"\"\"Set the joinstyle.\n\n        Parameters\n        ----------\n        s : {'miter', 'round', 'bevel'}\n        \"\"\"\n        s = s.lower()\n        cbook._check_in_list(self.validJoin, joinstyle=s)\n        self._joinstyle = s\n        self.stale = True",
        "begin_line": 475,
        "end_line": 485,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013568521031207597,
            "pseudo_dstar_susp": 0.0011098779134295228,
            "pseudo_tarantula_susp": 0.00044543429844097997,
            "pseudo_op2_susp": 0.0011098779134295228,
            "pseudo_barinel_susp": 0.00044543429844097997
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.set_hatch#491",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.set_hatch(self, hatch)",
        "snippet": "    def set_hatch(self, hatch):\n        r\"\"\"\n        Set the hatching pattern.\n\n        *hatch* can be one of::\n\n          /   - diagonal hatching\n          \\   - back diagonal\n          |   - vertical\n          -   - horizontal\n          +   - crossed\n          x   - crossed diagonal\n          o   - small circle\n          O   - large circle\n          .   - dots\n          *   - stars\n\n        Letters can be combined, in which case all the specified\n        hatchings are done.  If same letter repeats, it increases the\n        density of hatching of that pattern.\n\n        Hatching is supported in the PostScript, PDF, SVG and Agg\n        backends only.\n\n        Parameters\n        ----------\n        hatch : {'/', '\\\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}\n        \"\"\"\n        self._hatch = hatch\n        self.stale = True",
        "begin_line": 491,
        "end_line": 520,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013568521031207597,
            "pseudo_dstar_susp": 0.0011098779134295228,
            "pseudo_tarantula_susp": 0.00044543429844097997,
            "pseudo_op2_susp": 0.0011098779134295228,
            "pseudo_barinel_susp": 0.00044543429844097997
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch._bind_draw_path_function#527",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch._bind_draw_path_function(self, renderer)",
        "snippet": "    def _bind_draw_path_function(self, renderer):\n        \"\"\"\n        ``draw()`` helper factored out for sharing with `FancyArrowPatch`.\n\n        Yields a callable ``dp`` such that calling ``dp(*args, **kwargs)`` is\n        equivalent to calling ``renderer1.draw_path(gc, *args, **kwargs)``\n        where ``renderer1`` and ``gc`` have been suitably set from ``renderer``\n        and the artist's properties.\n        \"\"\"\n\n        renderer.open_group('patch', self.get_gid())\n        gc = renderer.new_gc()\n\n        gc.set_foreground(self._edgecolor, isRGBA=True)\n\n        lw = self._linewidth\n        if self._edgecolor[3] == 0:\n            lw = 0\n        gc.set_linewidth(lw)\n        gc.set_dashes(self._dashoffset, self._dashes)\n        gc.set_capstyle(self._capstyle)\n        gc.set_joinstyle(self._joinstyle)\n\n        gc.set_antialiased(self._antialiased)\n        self._set_gc_clip(gc)\n        gc.set_url(self._url)\n        gc.set_snap(self.get_snap())\n\n        gc.set_alpha(self._alpha)\n\n        if self._hatch:\n            gc.set_hatch(self._hatch)\n            try:\n                gc.set_hatch_color(self._hatch_color)\n            except AttributeError:\n                # if we end up with a GC that does not have this method\n                cbook.warn_deprecated(\n                    \"3.1\", message=\"Your backend does not support setting the \"\n                    \"hatch color; such backends will become unsupported in \"\n                    \"Matplotlib 3.3.\")\n\n        if self.get_sketch_params() is not None:\n            gc.set_sketch_params(*self.get_sketch_params())\n\n        if self.get_path_effects():\n            from matplotlib.patheffects import PathEffectRenderer\n            renderer = PathEffectRenderer(self.get_path_effects(), renderer)\n\n        # In `with _bind_draw_path_function(renderer) as draw_path: ...`\n        # (in the implementations of `draw()` below), calls to `draw_path(...)`\n        # will occur as if they took place here with `gc` inserted as\n        # additional first argument.\n        yield functools.partial(renderer.draw_path, gc)\n\n        gc.restore()\n        renderer.close_group('patch')\n        self.stale = False",
        "begin_line": 527,
        "end_line": 583,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016666666666666668,
            "pseudo_dstar_susp": 0.001272264631043257,
            "pseudo_tarantula_susp": 0.0004775549188156638,
            "pseudo_op2_susp": 0.001272264631043257,
            "pseudo_barinel_susp": 0.0004775549188156638
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.draw#586",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        \"\"\"Draw to the given *renderer*.\"\"\"\n        if not self.get_visible():\n            return\n\n        # Patch has traditionally ignored the dashoffset.\n        with cbook._setattr_cm(self, _dashoffset=0), \\\n                self._bind_draw_path_function(renderer) as draw_path:\n            path = self.get_path()\n            transform = self.get_transform()\n            tpath = transform.transform_path_non_affine(path)\n            affine = transform.get_affine()\n            draw_path(tpath, affine,\n                      # Work around a bug in the PDF and SVG renderers, which\n                      # do not draw the hatches if the facecolor is fully\n                      # transparent, but do if it is None.\n                      self._facecolor if self._facecolor[3] else None)",
        "begin_line": 586,
        "end_line": 602,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013392259274139549,
            "pseudo_dstar_susp": 0.00015728216420257942,
            "pseudo_tarantula_susp": 0.00012594458438287153,
            "pseudo_op2_susp": 0.00015728216420257942,
            "pseudo_barinel_susp": 0.00012594458438287153
        }
    },
    {
        "name": "lib.matplotlib.patches.Rectangle.__init__#705",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Rectangle",
        "signature": "lib.matplotlib.patches.Rectangle.__init__(self, xy, width, height, angle=0.0, **kwargs)",
        "snippet": "    def __init__(self, xy, width, height, angle=0.0, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        xy : (float, float)\n            The bottom and left rectangle coordinates\n        width : float\n            Rectangle width\n        height : float\n            Rectangle height\n        angle : float, optional\n          rotation in degrees anti-clockwise about *xy* (default is 0.0)\n        fill : bool, optional\n            Whether to fill the rectangle (default is ``True``)\n\n        Notes\n        -----\n        Valid keyword arguments are:\n\n        %(Patch)s\n        \"\"\"\n\n        Patch.__init__(self, **kwargs)\n\n        self._x0 = xy[0]\n        self._y0 = xy[1]\n\n        self._width = width\n        self._height = height\n\n        self._x1 = self._x0 + self._width\n        self._y1 = self._y0 + self._height\n\n        self.angle = float(angle)\n        # Note: This cannot be calculated until this is added to an Axes\n        self._rect_transform = transforms.IdentityTransform()",
        "begin_line": 705,
        "end_line": 740,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014771048744460858,
            "pseudo_dstar_susp": 0.0011806375442739079,
            "pseudo_tarantula_susp": 0.0004610419548178884,
            "pseudo_op2_susp": 0.0011806375442739079,
            "pseudo_barinel_susp": 0.0004610419548178884
        }
    },
    {
        "name": "lib.matplotlib.patches.Rectangle.get_path#742",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Rectangle",
        "signature": "lib.matplotlib.patches.Rectangle.get_path(self)",
        "snippet": "    def get_path(self):\n        \"\"\"Return the vertices of the rectangle.\"\"\"\n        return Path.unit_rectangle()",
        "begin_line": 742,
        "end_line": 744,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001567398119122257,
            "pseudo_dstar_susp": 0.001226993865030675,
            "pseudo_tarantula_susp": 0.00046904315196998124,
            "pseudo_op2_susp": 0.001226993865030675,
            "pseudo_barinel_susp": 0.00046904315196998124
        }
    },
    {
        "name": "lib.matplotlib.patches.Rectangle._update_patch_transform#746",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Rectangle",
        "signature": "lib.matplotlib.patches.Rectangle._update_patch_transform(self)",
        "snippet": "    def _update_patch_transform(self):\n        \"\"\"\n        Notes\n        -----\n        This cannot be called until after this has been added to an Axes,\n        otherwise unit conversion will fail. This makes it very important to\n        call the accessor method and not directly access the transformation\n        member variable.\n        \"\"\"\n        x0, y0, x1, y1 = self._convert_units()\n        bbox = transforms.Bbox.from_extents(x0, y0, x1, y1)\n        rot_trans = transforms.Affine2D()\n        rot_trans.rotate_deg_around(x0, y0, self.angle)\n        self._rect_transform = transforms.BboxTransformTo(bbox)\n        self._rect_transform += rot_trans",
        "begin_line": 746,
        "end_line": 760,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00205761316872428,
            "pseudo_dstar_susp": 0.001092896174863388,
            "pseudo_tarantula_susp": 0.0005112474437627812,
            "pseudo_op2_susp": 0.001092896174863388,
            "pseudo_barinel_susp": 0.0005112474437627812
        }
    },
    {
        "name": "lib.matplotlib.patches.Rectangle._convert_units#768",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Rectangle",
        "signature": "lib.matplotlib.patches.Rectangle._convert_units(self)",
        "snippet": "    def _convert_units(self):\n        \"\"\"Convert bounds of the rectangle.\"\"\"\n        x0 = self.convert_xunits(self._x0)\n        y0 = self.convert_yunits(self._y0)\n        x1 = self.convert_xunits(self._x1)\n        y1 = self.convert_yunits(self._y1)\n        return x0, y0, x1, y1",
        "begin_line": 768,
        "end_line": 774,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.34306691139663e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Rectangle.get_patch_transform#776",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Rectangle",
        "signature": "lib.matplotlib.patches.Rectangle.get_patch_transform(self)",
        "snippet": "    def get_patch_transform(self):\n        self._update_patch_transform()\n        return self._rect_transform",
        "begin_line": 776,
        "end_line": 778,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.PathPatch.__init__#969",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.PathPatch",
        "signature": "lib.matplotlib.patches.PathPatch.__init__(self, path, **kwargs)",
        "snippet": "    def __init__(self, path, **kwargs):\n        \"\"\"\n        *path* is a :class:`matplotlib.path.Path` object.\n\n        Valid keyword arguments are:\n\n        %(Patch)s\n        \"\"\"\n        Patch.__init__(self, **kwargs)\n        self._path = path",
        "begin_line": 969,
        "end_line": 978,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00014025245441795232,
            "pseudo_dstar_susp": 0.00015080681646810435,
            "pseudo_tarantula_susp": 0.00022187708009762592,
            "pseudo_op2_susp": 0.00015080681646810435,
            "pseudo_barinel_susp": 0.00022187708009762592
        }
    },
    {
        "name": "lib.matplotlib.patches.Polygon.__str__#991",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Polygon",
        "signature": "lib.matplotlib.patches.Polygon.__str__(self)",
        "snippet": "    def __str__(self):\n        s = \"Polygon%d((%g, %g) ...)\"\n        return s % (len(self._path.vertices), *tuple(self._path.vertices[0]))",
        "begin_line": 991,
        "end_line": 993,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Polygon.set_xy#1059",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Polygon",
        "signature": "lib.matplotlib.patches.Polygon.set_xy(self, xy)",
        "snippet": "    def set_xy(self, xy):\n        \"\"\"\n        Set the vertices of the polygon.\n\n        Parameters\n        ----------\n        xy : (N, 2) array-like\n            The coordinates of the vertices.\n        \"\"\"\n        xy = np.asarray(xy)\n        if self._closed:\n            if len(xy) and (xy[0] != xy[-1]).any():\n                xy = np.concatenate([xy, [xy[0]]])\n        else:\n            if len(xy) > 2 and (xy[0] == xy[-1]).all():\n                xy = xy[:-1]\n        self._path = Path(xy, closed=self._closed)\n        self.stale = True",
        "begin_line": 1059,
        "end_line": 1076,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002199736031676199,
            "pseudo_dstar_susp": 0.00024330900243309004,
            "pseudo_tarantula_susp": 0.00017966223499820338,
            "pseudo_op2_susp": 0.00024330900243309004,
            "pseudo_barinel_susp": 0.00017966223499820338
        }
    },
    {
        "name": "lib.matplotlib.patches.Wedge._recompute_path#1113",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Wedge",
        "signature": "lib.matplotlib.patches.Wedge._recompute_path(self)",
        "snippet": "    def _recompute_path(self):\n        # Inner and outer rings are connected unless the annulus is complete\n        if abs((self.theta2 - self.theta1) - 360) <= 1e-12:\n            theta1, theta2 = 0, 360\n            connector = Path.MOVETO\n        else:\n            theta1, theta2 = self.theta1, self.theta2\n            connector = Path.LINETO\n\n        # Form the outer ring\n        arc = Path.arc(theta1, theta2)\n\n        if self.width is not None:\n            # Partial annulus needs to draw the outer ring\n            # followed by a reversed and scaled inner ring\n            v1 = arc.vertices\n            v2 = arc.vertices[::-1] * (self.r - self.width) / self.r\n            v = np.vstack([v1, v2, v1[0, :], (0, 0)])\n            c = np.hstack([arc.codes, arc.codes, connector, Path.CLOSEPOLY])\n            c[len(arc.codes)] = connector\n        else:\n            # Wedge doesn't need an inner ring\n            v = np.vstack([arc.vertices, [(0, 0), arc.vertices[0, :], (0, 0)]])\n            c = np.hstack([arc.codes, [connector, connector, Path.CLOSEPOLY]])\n\n        # Shift and scale the wedge to the final location.\n        v *= self.r\n        v += np.asarray(self.center)\n        self._path = Path(v, c)",
        "begin_line": 1113,
        "end_line": 1141,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002477700693756194,
            "pseudo_dstar_susp": 0.00023752969121140142,
            "pseudo_tarantula_susp": 0.00026068821689259646,
            "pseudo_op2_susp": 0.00023752969121140142,
            "pseudo_barinel_susp": 0.0002615746795710175
        }
    },
    {
        "name": "lib.matplotlib.patches.Wedge.set_center#1143",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Wedge",
        "signature": "lib.matplotlib.patches.Wedge.set_center(self, center)",
        "snippet": "    def set_center(self, center):\n        self._path = None\n        self.center = center\n        self.stale = True",
        "begin_line": 1143,
        "end_line": 1146,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.patches.Wedge.set_radius#1148",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Wedge",
        "signature": "lib.matplotlib.patches.Wedge.set_radius(self, radius)",
        "snippet": "    def set_radius(self, radius):\n        self._path = None\n        self.r = radius\n        self.stale = True",
        "begin_line": 1148,
        "end_line": 1151,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021944261575597982,
            "pseudo_dstar_susp": 0.00020777062123415748,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00020777062123415748,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.Wedge.set_theta1#1153",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Wedge",
        "signature": "lib.matplotlib.patches.Wedge.set_theta1(self, theta1)",
        "snippet": "    def set_theta1(self, theta1):\n        self._path = None\n        self.theta1 = theta1\n        self.stale = True",
        "begin_line": 1153,
        "end_line": 1156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022522522522522523,
            "pseudo_dstar_susp": 0.00021417862497322766,
            "pseudo_tarantula_susp": 0.00027210884353741496,
            "pseudo_op2_susp": 0.00021417862497322766,
            "pseudo_barinel_susp": 0.0002720348204570185
        }
    },
    {
        "name": "lib.matplotlib.patches.Wedge.set_theta2#1158",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Wedge",
        "signature": "lib.matplotlib.patches.Wedge.set_theta2(self, theta2)",
        "snippet": "    def set_theta2(self, theta2):\n        self._path = None\n        self.theta2 = theta2\n        self.stale = True",
        "begin_line": 1158,
        "end_line": 1161,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Wedge.set_width#1163",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Wedge",
        "signature": "lib.matplotlib.patches.Wedge.set_width(self, width)",
        "snippet": "    def set_width(self, width):\n        self._path = None\n        self.width = width\n        self.stale = True",
        "begin_line": 1163,
        "end_line": 1166,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.Wedge.get_path#1168",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Wedge",
        "signature": "lib.matplotlib.patches.Wedge.get_path(self)",
        "snippet": "    def get_path(self):\n        if self._path is None:\n            self._recompute_path()\n        return self._path",
        "begin_line": 1168,
        "end_line": 1171,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrow.__init__#1244",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrow",
        "signature": "lib.matplotlib.patches.FancyArrow.__init__(self, x, y, dx, dy, width=0.001, length_includes_head=False, head_width=None, head_length=None, shape='full', overhang=0, head_starts_at_zero=False, **kwargs)",
        "snippet": "    def __init__(self, x, y, dx, dy, width=0.001, length_includes_head=False,\n                 head_width=None, head_length=None, shape='full', overhang=0,\n                 head_starts_at_zero=False, **kwargs):\n        \"\"\"\n        Constructor arguments\n          *width*: float (default: 0.001)\n            width of full arrow tail\n\n          *length_includes_head*: bool (default: False)\n            True if head is to be counted in calculating the length.\n\n          *head_width*: float or None (default: 3*width)\n            total width of the full arrow head\n\n          *head_length*: float or None (default: 1.5 * head_width)\n            length of arrow head\n\n          *shape*: ['full', 'left', 'right'] (default: 'full')\n            draw the left-half, right-half, or full arrow\n\n          *overhang*: float (default: 0)\n            fraction that the arrow is swept back (0 overhang means\n            triangular shape). Can be negative or greater than one.\n\n          *head_starts_at_zero*: bool (default: False)\n            if True, the head starts being drawn at coordinate 0\n            instead of ending at coordinate 0.\n\n        Other valid kwargs (inherited from :class:`Patch`) are:\n\n        %(Patch)s\n        \"\"\"\n        if head_width is None:\n            head_width = 3 * width\n        if head_length is None:\n            head_length = 1.5 * head_width\n\n        distance = np.hypot(dx, dy)\n\n        if length_includes_head:\n            length = distance\n        else:\n            length = distance + head_length\n        if not length:\n            verts = np.empty([0, 2])  # display nothing if empty\n        else:\n            # start by drawing horizontal arrow, point at (0, 0)\n            hw, hl, hs, lw = head_width, head_length, overhang, width\n            left_half_arrow = np.array([\n                [0.0, 0.0],                 # tip\n                [-hl, -hw / 2],             # leftmost\n                [-hl * (1 - hs), -lw / 2],  # meets stem\n                [-length, -lw / 2],         # bottom left\n                [-length, 0],\n            ])\n            # if we're not including the head, shift up by head length\n            if not length_includes_head:\n                left_half_arrow += [head_length, 0]\n            # if the head starts at 0, shift up by another head length\n            if head_starts_at_zero:\n                left_half_arrow += [head_length / 2, 0]\n            # figure out the shape, and complete accordingly\n            if shape == 'left':\n                coords = left_half_arrow\n            else:\n                right_half_arrow = left_half_arrow * [1, -1]\n                if shape == 'right':\n                    coords = right_half_arrow\n                elif shape == 'full':\n                    # The half-arrows contain the midpoint of the stem,\n                    # which we can omit from the full arrow. Including it\n                    # twice caused a problem with xpdf.\n                    coords = np.concatenate([left_half_arrow[:-1],\n                                             right_half_arrow[-2::-1]])\n                else:\n                    raise ValueError(\"Got unknown shape: %s\" % shape)\n            if distance != 0:\n                cx = dx / distance\n                sx = dy / distance\n            else:\n                # Account for division by zero\n                cx, sx = 0, 1\n            M = [[cx, sx], [-sx, cx]]\n            verts = np.dot(coords, M) + (x + dx, y + dy)\n\n        super().__init__(verts, closed=True, **kwargs)",
        "begin_line": 1244,
        "end_line": 1329,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.CirclePolygon.__init__#1344",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.CirclePolygon",
        "signature": "lib.matplotlib.patches.CirclePolygon.__init__(self, xy, radius=5, resolution=20, **kwargs)",
        "snippet": "    def __init__(self, xy, radius=5,\n                 resolution=20,  # the number of vertices\n                 ** kwargs):\n        \"\"\"\n        Create a circle at *xy* = (*x*, *y*) with given *radius*.\n        This circle is approximated by a regular polygon with\n        *resolution* sides.  For a smoother circle drawn with splines,\n        see :class:`~matplotlib.patches.Circle`.\n\n        Valid keyword arguments are:\n\n        %(Patch)s\n        \"\"\"\n        RegularPolygon.__init__(self, xy,\n                                resolution,\n                                radius,\n                                orientation=0,\n                                **kwargs)",
        "begin_line": 1344,
        "end_line": 1361,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Ellipse.__str__#1368",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Ellipse",
        "signature": "lib.matplotlib.patches.Ellipse.__str__(self)",
        "snippet": "    def __str__(self):\n        pars = (self._center[0], self._center[1],\n                self.width, self.height, self.angle)\n        fmt = \"Ellipse(xy=(%s, %s), width=%s, height=%s, angle=%s)\"\n        return fmt % pars",
        "begin_line": 1368,
        "end_line": 1372,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Ellipse.__init__#1375",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Ellipse",
        "signature": "lib.matplotlib.patches.Ellipse.__init__(self, xy, width, height, angle=0, **kwargs)",
        "snippet": "    def __init__(self, xy, width, height, angle=0, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        xy : (float, float)\n            xy coordinates of ellipse centre.\n        width : float\n            Total length (diameter) of horizontal axis.\n        height : float\n            Total length (diameter) of vertical axis.\n        angle : scalar, optional\n            Rotation in degrees anti-clockwise.\n\n        Notes\n        -----\n        Valid keyword arguments are:\n\n        %(Patch)s\n        \"\"\"\n        Patch.__init__(self, **kwargs)\n\n        self._center = xy\n        self.width, self.height = width, height\n        self.angle = angle\n        self._path = Path.unit_circle()\n        # Note: This cannot be calculated until this is added to an Axes\n        self._patch_transform = transforms.IdentityTransform()",
        "begin_line": 1375,
        "end_line": 1401,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013964530093562352,
            "pseudo_dstar_susp": 0.00015830299192654741,
            "pseudo_tarantula_susp": 0.00017415534656913968,
            "pseudo_op2_susp": 0.00015830299192654741,
            "pseudo_barinel_susp": 0.0001742767514813524
        }
    },
    {
        "name": "lib.matplotlib.patches.Ellipse._recompute_transform#1403",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Ellipse",
        "signature": "lib.matplotlib.patches.Ellipse._recompute_transform(self)",
        "snippet": "    def _recompute_transform(self):\n        \"\"\"\n        Notes\n        -----\n        This cannot be called until after this has been added to an Axes,\n        otherwise unit conversion will fail. This makes it very important to\n        call the accessor method and not directly access the transformation\n        member variable.\n        \"\"\"\n        center = (self.convert_xunits(self._center[0]),\n                  self.convert_yunits(self._center[1]))\n        width = self.convert_xunits(self.width)\n        height = self.convert_yunits(self.height)\n        self._patch_transform = transforms.Affine2D() \\\n            .scale(width * 0.5, height * 0.5) \\\n            .rotate_deg(self.angle) \\\n            .translate(*center)",
        "begin_line": 1403,
        "end_line": 1419,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00014158289678606824,
            "pseudo_dstar_susp": 0.00015855398763278897,
            "pseudo_tarantula_susp": 0.0001598976654940838,
            "pseudo_op2_susp": 0.00015855398763278897,
            "pseudo_barinel_susp": 0.0001598976654940838
        }
    },
    {
        "name": "lib.matplotlib.patches.Ellipse.get_center#1442",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Ellipse",
        "signature": "lib.matplotlib.patches.Ellipse.get_center(self)",
        "snippet": "    def get_center(self):\n        \"\"\"\n        Return the center of the ellipse\n        \"\"\"\n        return self._center",
        "begin_line": 1442,
        "end_line": 1446,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Circle.__str__#1455",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Circle",
        "signature": "lib.matplotlib.patches.Circle.__str__(self)",
        "snippet": "    def __str__(self):\n        pars = self.center[0], self.center[1], self.radius\n        fmt = \"Circle(xy=(%g, %g), radius=%g)\"\n        return fmt % pars",
        "begin_line": 1455,
        "end_line": 1458,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Circle.__init__#1461",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Circle",
        "signature": "lib.matplotlib.patches.Circle.__init__(self, xy, radius=5, **kwargs)",
        "snippet": "    def __init__(self, xy, radius=5, **kwargs):\n        \"\"\"\n        Create true circle at center *xy* = (*x*, *y*) with given\n        *radius*.  Unlike :class:`~matplotlib.patches.CirclePolygon`\n        which is a polygonal approximation, this uses Bezier splines\n        and is much closer to a scale-free circle.\n\n        Valid keyword arguments are:\n\n        %(Patch)s\n        \"\"\"\n        Ellipse.__init__(self, xy, radius * 2, radius * 2, **kwargs)\n        self.radius = radius",
        "begin_line": 1461,
        "end_line": 1473,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Circle.set_radius#1475",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Circle",
        "signature": "lib.matplotlib.patches.Circle.set_radius(self, radius)",
        "snippet": "    def set_radius(self, radius):\n        \"\"\"\n        Set the radius of the circle\n\n        Parameters\n        ----------\n        radius : float\n        \"\"\"\n        self.width = self.height = 2 * radius\n        self.stale = True",
        "begin_line": 1475,
        "end_line": 1484,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Circle.get_radius#1486",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Circle",
        "signature": "lib.matplotlib.patches.Circle.get_radius(self)",
        "snippet": "    def get_radius(self):\n        \"\"\"\n        Return the radius of the circle\n        \"\"\"\n        return self.width / 2.",
        "begin_line": 1486,
        "end_line": 1490,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Arc.__str__#1507",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Arc",
        "signature": "lib.matplotlib.patches.Arc.__str__(self)",
        "snippet": "    def __str__(self):\n        pars = (self.center[0], self.center[1], self.width,\n                self.height, self.angle, self.theta1, self.theta2)\n        fmt = (\"Arc(xy=(%g, %g), width=%g, \"\n               \"height=%g, angle=%g, theta1=%g, theta2=%g)\")\n        return fmt % pars",
        "begin_line": 1507,
        "end_line": 1512,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Arc.__init__#1515",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Arc",
        "signature": "lib.matplotlib.patches.Arc.__init__(self, xy, width, height, angle=0.0, theta1=0.0, theta2=360.0, **kwargs)",
        "snippet": "    def __init__(self, xy, width, height, angle=0.0,\n                 theta1=0.0, theta2=360.0, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        xy : (float, float)\n            The center of the ellipse.\n\n        width : float\n            The length of the horizontal axis.\n\n        height : float\n            The length of the vertical axis.\n\n        angle : float\n            Rotation of the ellipse in degrees (counterclockwise).\n\n        theta1, theta2 : float, optional\n            Starting and ending angles of the arc in degrees. These values\n            are relative to *angle*, e.g. if *angle* = 45 and *theta1* = 90\n            the absolute starting angle is 135.\n            Default *theta1* = 0, *theta2* = 360, i.e. a complete ellipse.\n            The arc is drawn in the counterclockwise direction.\n            Angles greater than or equal to 360, or smaller than 0, are\n            represented by an equivalent angle in the range [0, 360), by\n            taking the input value mod 360.\n\n        Other Parameters\n        ----------------\n        **kwargs : `.Patch` properties\n            Most `.Patch` properties are supported as keyword arguments,\n            with the exception of *fill* and *facecolor* because filling is\n            not supported.\n\n        %(Patch)s\n        \"\"\"\n        fill = kwargs.setdefault('fill', False)\n        if fill:\n            raise ValueError(\"Arc objects can not be filled\")\n\n        Ellipse.__init__(self, xy, width, height, angle, **kwargs)\n\n        self.theta1 = theta1\n        self.theta2 = theta2",
        "begin_line": 1515,
        "end_line": 1558,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Arc.draw#1561",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Arc",
        "signature": "lib.matplotlib.patches.Arc.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        \"\"\"\n        Draw the arc to the given *renderer*.\n\n        Notes\n        -----\n        Ellipses are normally drawn using an approximation that uses\n        eight cubic Bezier splines.  The error of this approximation\n        is 1.89818e-6, according to this unverified source:\n\n          Lancaster, Don.  *Approximating a Circle or an Ellipse Using\n          Four Bezier Cubic Splines.*\n\n          http://www.tinaja.com/glib/ellipse4.pdf\n\n        There is a use case where very large ellipses must be drawn\n        with very high accuracy, and it is too expensive to render the\n        entire ellipse with enough segments (either splines or line\n        segments).  Therefore, in the case where either radius of the\n        ellipse is large enough that the error of the spline\n        approximation will be visible (greater than one pixel offset\n        from the ideal), a different technique is used.\n\n        In that case, only the visible parts of the ellipse are drawn,\n        with each visible arc using a fixed number of spline segments\n        (8).  The algorithm proceeds as follows:\n\n        1. The points where the ellipse intersects the axes bounding\n           box are located.  (This is done be performing an inverse\n           transformation on the axes bbox such that it is relative\n           to the unit circle -- this makes the intersection\n           calculation much easier than doing rotated ellipse\n           intersection directly).\n\n           This uses the \"line intersecting a circle\" algorithm\n           from:\n\n               Vince, John.  *Geometry for Computer Graphics: Formulae,\n               Examples & Proofs.*  London: Springer-Verlag, 2005.\n\n        2. The angles of each of the intersection points are\n           calculated.\n\n        3. Proceeding counterclockwise starting in the positive\n           x-direction, each of the visible arc-segments between the\n           pairs of vertices are drawn using the Bezier arc\n           approximation technique implemented in\n           :meth:`matplotlib.path.Path.arc`.\n        \"\"\"\n        if not hasattr(self, 'axes'):\n            raise RuntimeError('Arcs can only be used in Axes instances')\n\n        self._recompute_transform()\n\n        width = self.convert_xunits(self.width)\n        height = self.convert_yunits(self.height)\n\n        # If the width and height of ellipse are not equal, take into account\n        # stretching when calculating angles to draw between\n        def theta_stretch(theta, scale):\n            theta = np.deg2rad(theta)\n            x = np.cos(theta)\n            y = np.sin(theta)\n            return np.rad2deg(np.arctan2(scale * y, x))\n        theta1 = theta_stretch(self.theta1, width / height)\n        theta2 = theta_stretch(self.theta2, width / height)\n\n        # Get width and height in pixels\n        width, height = self.get_transform().transform((width, height))\n        inv_error = (1.0 / 1.89818e-6) * 0.5\n        if width < inv_error and height < inv_error:\n            self._path = Path.arc(theta1, theta2)\n            return Patch.draw(self, renderer)\n\n        def iter_circle_intersect_on_line(x0, y0, x1, y1):\n            dx = x1 - x0\n            dy = y1 - y0\n            dr2 = dx * dx + dy * dy\n            D = x0 * y1 - x1 * y0\n            D2 = D * D\n            discrim = dr2 - D2\n\n            # Single (tangential) intersection\n            if discrim == 0.0:\n                x = (D * dy) / dr2\n                y = (-D * dx) / dr2\n                yield x, y\n            elif discrim > 0.0:\n                # The definition of \"sign\" here is different from\n                # np.sign: we never want to get 0.0\n                if dy < 0.0:\n                    sign_dy = -1.0\n                else:\n                    sign_dy = 1.0\n                sqrt_discrim = np.sqrt(discrim)\n                for sign in (1., -1.):\n                    x = (D * dy + sign * sign_dy * dx * sqrt_discrim) / dr2\n                    y = (-D * dx + sign * np.abs(dy) * sqrt_discrim) / dr2\n                    yield x, y\n\n        def iter_circle_intersect_on_line_seg(x0, y0, x1, y1):\n            epsilon = 1e-9\n            if x1 < x0:\n                x0e, x1e = x1, x0\n            else:\n                x0e, x1e = x0, x1\n            if y1 < y0:\n                y0e, y1e = y1, y0\n            else:\n                y0e, y1e = y0, y1\n            x0e -= epsilon\n            y0e -= epsilon\n            x1e += epsilon\n            y1e += epsilon\n            for x, y in iter_circle_intersect_on_line(x0, y0, x1, y1):\n                if x0e <= x <= x1e and y0e <= y <= y1e:\n                    yield x, y\n\n        # Transforms the axes box_path so that it is relative to the unit\n        # circle in the same way that it is relative to the desired ellipse.\n        box_path = Path.unit_rectangle()\n        box_path_transform = (transforms.BboxTransformTo(self.axes.bbox)\n                              - self.get_transform())\n        box_path = box_path.transformed(box_path_transform)\n\n        thetas = set()\n        # For each of the point pairs, there is a line segment\n        for p0, p1 in zip(box_path.vertices[:-1], box_path.vertices[1:]):\n            x0, y0 = p0\n            x1, y1 = p1\n            for x, y in iter_circle_intersect_on_line_seg(x0, y0, x1, y1):\n                theta = np.arccos(x)\n                if y < 0:\n                    theta = 2 * np.pi - theta\n                # Convert radians to angles\n                theta = np.rad2deg(theta)\n                if theta1 < theta < theta2:\n                    thetas.add(theta)\n        thetas = sorted(thetas) + [theta2]\n\n        last_theta = theta1\n        theta1_rad = np.deg2rad(theta1)\n        inside = box_path.contains_point((np.cos(theta1_rad),\n                                          np.sin(theta1_rad)))\n\n        # save original path\n        path_original = self._path\n        for theta in thetas:\n            if inside:\n                self._path = Path.arc(last_theta, theta, 8)\n                Patch.draw(self, renderer)\n                inside = False\n            else:\n                inside = True\n            last_theta = theta\n\n        # restore original path\n        self._path = path_original",
        "begin_line": 1561,
        "end_line": 1718,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Arc.iter_circle_intersect_on_line#1635",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Arc",
        "signature": "lib.matplotlib.patches.Arc.iter_circle_intersect_on_line(x0, y0, x1, y1)",
        "snippet": "        def iter_circle_intersect_on_line(x0, y0, x1, y1):\n            dx = x1 - x0\n            dy = y1 - y0\n            dr2 = dx * dx + dy * dy\n            D = x0 * y1 - x1 * y0\n            D2 = D * D\n            discrim = dr2 - D2\n\n            # Single (tangential) intersection\n            if discrim == 0.0:\n                x = (D * dy) / dr2\n                y = (-D * dx) / dr2\n                yield x, y\n            elif discrim > 0.0:\n                # The definition of \"sign\" here is different from\n                # np.sign: we never want to get 0.0\n                if dy < 0.0:\n                    sign_dy = -1.0\n                else:\n                    sign_dy = 1.0\n                sqrt_discrim = np.sqrt(discrim)\n                for sign in (1., -1.):\n                    x = (D * dy + sign * sign_dy * dx * sqrt_discrim) / dr2\n                    y = (-D * dx + sign * np.abs(dy) * sqrt_discrim) / dr2\n                    yield x, y",
        "begin_line": 1635,
        "end_line": 1659,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches._Style.__new__#1818",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Style",
        "signature": "lib.matplotlib.patches._Style.__new__(cls, stylename, **kw)",
        "snippet": "    def __new__(cls, stylename, **kw):\n        \"\"\"Return the instance of the subclass with the given style name.\"\"\"\n\n        # The \"class\" should have the _style_list attribute, which is a mapping\n        # of style names to style classes.\n\n        _list = stylename.replace(\" \", \"\").split(\",\")\n        _name = _list[0].lower()\n        try:\n            _cls = cls._style_list[_name]\n        except KeyError:\n            raise ValueError(\"Unknown style : %s\" % stylename)\n\n        try:\n            _args_pair = [cs.split(\"=\") for cs in _list[1:]]\n            _args = {k: float(v) for k, v in _args_pair}\n        except ValueError:\n            raise ValueError(\"Incorrect style argument : %s\" % stylename)\n        _args.update(kw)\n\n        return _cls(**_args)",
        "begin_line": 1818,
        "end_line": 1838,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00026867275658248256,
            "pseudo_dstar_susp": 0.0002977963073257892,
            "pseudo_tarantula_susp": 0.0003450655624568668,
            "pseudo_op2_susp": 0.0002977963073257892,
            "pseudo_barinel_susp": 0.00034494653328734045
        }
    },
    {
        "name": "lib.matplotlib.patches._Base.__call__#1932",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Base",
        "signature": "lib.matplotlib.patches._Base.__call__(self, x0, y0, width, height, mutation_size, aspect_ratio=1.0)",
        "snippet": "        def __call__(self, x0, y0, width, height, mutation_size,\n                     aspect_ratio=1.):\n            \"\"\"\n            Given the location and size of the box, return the path of\n            the box around it.\n\n            Parameters\n            ----------\n            x0, y0, width, height : float\n                Location and size of the box.\n            mutation_size : float\n                A reference scale for the mutation.\n            aspect_ratio : float, default: 1\n                Aspect-ratio for the mutation.\n\n            Returns\n            -------\n            path : `~matplotlib.path.Path`\n            \"\"\"\n            # The __call__ method is a thin wrapper around the transmute method\n            # and takes care of the aspect.\n\n            if aspect_ratio is not None:\n                # Squeeze the given height by the aspect_ratio\n                y0, height = y0 / aspect_ratio, height / aspect_ratio\n                # call transmute method with squeezed height.\n                path = self.transmute(x0, y0, width, height, mutation_size)\n                vertices, codes = path.vertices, path.codes\n                # Restore the height\n                vertices[:, 1] = vertices[:, 1] * aspect_ratio\n                return Path(vertices, codes)\n            else:\n                return self.transmute(x0, y0, width, height, mutation_size)",
        "begin_line": 1932,
        "end_line": 1964,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.Square.__init__#1976",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Square",
        "signature": "lib.matplotlib.patches.Square.__init__(self, pad=0.3)",
        "snippet": "        def __init__(self, pad=0.3):\n            self.pad = pad\n            super().__init__()",
        "begin_line": 1976,
        "end_line": 1978,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00025933609958506224,
            "pseudo_dstar_susp": 0.00026102845210127906,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00026102845210127906,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.Square.transmute#1980",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Square",
        "signature": "lib.matplotlib.patches.Square.transmute(self, x0, y0, width, height, mutation_size)",
        "snippet": "        def transmute(self, x0, y0, width, height, mutation_size):\n            pad = mutation_size * self.pad\n\n            # width and height with padding added.\n            width, height = width + 2*pad, height + 2*pad\n\n            # boundary of the padded box\n            x0, y0 = x0 - pad, y0 - pad,\n            x1, y1 = x0 + width, y0 + height\n\n            vertices = [(x0, y0), (x1, y0), (x1, y1), (x0, y1), (x0, y0)]\n            codes = [Path.MOVETO] + [Path.LINETO] * 3 + [Path.CLOSEPOLY]\n            return Path(vertices, codes)",
        "begin_line": 1980,
        "end_line": 1992,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003208213025344883,
            "pseudo_dstar_susp": 0.0002710761724044456,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0002710761724044456,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.Circle.__init__#2004",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Circle",
        "signature": "lib.matplotlib.patches.Circle.__init__(self, pad=0.3)",
        "snippet": "        def __init__(self, pad=0.3):\n            self.pad = pad\n            super().__init__()",
        "begin_line": 2004,
        "end_line": 2006,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.Circle.transmute#2008",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Circle",
        "signature": "lib.matplotlib.patches.Circle.transmute(self, x0, y0, width, height, mutation_size)",
        "snippet": "        def transmute(self, x0, y0, width, height, mutation_size):\n            pad = mutation_size * self.pad\n            width, height = width + 2 * pad, height + 2 * pad\n\n            # boundary of the padded box\n            x0, y0 = x0 - pad, y0 - pad,\n            return Path.circle((x0 + width / 2, y0 + height / 2),\n                               max(width, height) / 2)",
        "begin_line": 2008,
        "end_line": 2015,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018846588767433095,
            "pseudo_dstar_susp": 0.0001541782300339192,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0001541782300339192,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.LArrow.__init__#2027",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.LArrow",
        "signature": "lib.matplotlib.patches.LArrow.__init__(self, pad=0.3)",
        "snippet": "        def __init__(self, pad=0.3):\n            self.pad = pad\n            super().__init__()",
        "begin_line": 2027,
        "end_line": 2029,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.LArrow.transmute#2031",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.LArrow",
        "signature": "lib.matplotlib.patches.LArrow.transmute(self, x0, y0, width, height, mutation_size)",
        "snippet": "        def transmute(self, x0, y0, width, height, mutation_size):\n            # padding\n            pad = mutation_size * self.pad\n\n            # width and height with padding added.\n            width, height = width + 2. * pad, height + 2. * pad\n\n            # boundary of the padded box\n            x0, y0 = x0 - pad, y0 - pad,\n            x1, y1 = x0 + width, y0 + height\n\n            dx = (y1 - y0) / 2.\n            dxx = dx * .5\n            # adjust x0.  1.4 <- sqrt(2)\n            x0 = x0 + pad / 1.4\n\n            cp = [(x0 + dxx, y0), (x1, y0), (x1, y1), (x0 + dxx, y1),\n                  (x0 + dxx, y1 + dxx), (x0 - dx, y0 + dx),\n                  (x0 + dxx, y0 - dxx),  # arrow\n                  (x0 + dxx, y0), (x0 + dxx, y0)]\n\n            com = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO,\n                   Path.LINETO, Path.LINETO, Path.LINETO,\n                   Path.LINETO, Path.CLOSEPOLY]\n\n            path = Path(cp, com)\n\n            return path",
        "begin_line": 2031,
        "end_line": 2058,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.RArrow.__init__#2070",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.RArrow",
        "signature": "lib.matplotlib.patches.RArrow.__init__(self, pad=0.3)",
        "snippet": "        def __init__(self, pad=0.3):\n            super().__init__(pad)",
        "begin_line": 2070,
        "end_line": 2071,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.RArrow.transmute#2073",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.RArrow",
        "signature": "lib.matplotlib.patches.RArrow.transmute(self, x0, y0, width, height, mutation_size)",
        "snippet": "        def transmute(self, x0, y0, width, height, mutation_size):\n            p = BoxStyle.LArrow.transmute(self, x0, y0,\n                                          width, height, mutation_size)\n            p.vertices[:, 0] = 2 * x0 + width - p.vertices[:, 0]\n            return p",
        "begin_line": 2073,
        "end_line": 2077,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.DArrow.__init__#2092",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.DArrow",
        "signature": "lib.matplotlib.patches.DArrow.__init__(self, pad=0.3)",
        "snippet": "        def __init__(self, pad=0.3):\n            self.pad = pad\n            super().__init__()",
        "begin_line": 2092,
        "end_line": 2094,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.DArrow.transmute#2096",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.DArrow",
        "signature": "lib.matplotlib.patches.DArrow.transmute(self, x0, y0, width, height, mutation_size)",
        "snippet": "        def transmute(self, x0, y0, width, height, mutation_size):\n\n            # padding\n            pad = mutation_size * self.pad\n\n            # width and height with padding added.\n            # The width is padded by the arrows, so we don't need to pad it.\n            height = height + 2. * pad\n\n            # boundary of the padded box\n            x0, y0 = x0 - pad, y0 - pad\n            x1, y1 = x0 + width, y0 + height\n\n            dx = (y1 - y0) / 2\n            dxx = dx * .5\n            # adjust x0.  1.4 <- sqrt(2)\n            x0 = x0 + pad / 1.4\n\n            cp = [(x0 + dxx, y0), (x1, y0),  # bot-segment\n                  (x1, y0 - dxx), (x1 + dx + dxx, y0 + dx),\n                  (x1, y1 + dxx),  # right-arrow\n                  (x1, y1), (x0 + dxx, y1),  # top-segment\n                  (x0 + dxx, y1 + dxx), (x0 - dx, y0 + dx),\n                  (x0 + dxx, y0 - dxx),  # left-arrow\n                  (x0 + dxx, y0), (x0 + dxx, y0)]  # close-poly\n\n            com = [Path.MOVETO, Path.LINETO,\n                   Path.LINETO, Path.LINETO,\n                   Path.LINETO,\n                   Path.LINETO, Path.LINETO,\n                   Path.LINETO, Path.LINETO,\n                   Path.LINETO,\n                   Path.LINETO, Path.CLOSEPOLY]\n\n            path = Path(cp, com)\n\n            return path",
        "begin_line": 2096,
        "end_line": 2132,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.Round.__init__#2146",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Round",
        "signature": "lib.matplotlib.patches.Round.__init__(self, pad=0.3, rounding_size=None)",
        "snippet": "        def __init__(self, pad=0.3, rounding_size=None):\n            self.pad = pad\n            self.rounding_size = rounding_size\n            super().__init__()",
        "begin_line": 2146,
        "end_line": 2149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.Round.transmute#2151",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Round",
        "signature": "lib.matplotlib.patches.Round.transmute(self, x0, y0, width, height, mutation_size)",
        "snippet": "        def transmute(self, x0, y0, width, height, mutation_size):\n\n            # padding\n            pad = mutation_size * self.pad\n\n            # size of the rounding corner\n            if self.rounding_size:\n                dr = mutation_size * self.rounding_size\n            else:\n                dr = pad\n\n            width, height = width + 2. * pad, height + 2. * pad\n\n            x0, y0 = x0 - pad, y0 - pad,\n            x1, y1 = x0 + width, y0 + height\n\n            # Round corners are implemented as quadratic Bezier, e.g.,\n            # [(x0, y0-dr), (x0, y0), (x0+dr, y0)] for lower left corner.\n            cp = [(x0 + dr, y0),\n                  (x1 - dr, y0),\n                  (x1, y0), (x1, y0 + dr),\n                  (x1, y1 - dr),\n                  (x1, y1), (x1 - dr, y1),\n                  (x0 + dr, y1),\n                  (x0, y1), (x0, y1 - dr),\n                  (x0, y0 + dr),\n                  (x0, y0), (x0 + dr, y0),\n                  (x0 + dr, y0)]\n\n            com = [Path.MOVETO,\n                   Path.LINETO,\n                   Path.CURVE3, Path.CURVE3,\n                   Path.LINETO,\n                   Path.CURVE3, Path.CURVE3,\n                   Path.LINETO,\n                   Path.CURVE3, Path.CURVE3,\n                   Path.LINETO,\n                   Path.CURVE3, Path.CURVE3,\n                   Path.CLOSEPOLY]\n\n            path = Path(cp, com)\n\n            return path",
        "begin_line": 2151,
        "end_line": 2193,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021973192704900023,
            "pseudo_dstar_susp": 0.0001926782273603083,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0001926782273603083,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.Round4.__init__#2207",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Round4",
        "signature": "lib.matplotlib.patches.Round4.__init__(self, pad=0.3, rounding_size=None)",
        "snippet": "        def __init__(self, pad=0.3, rounding_size=None):\n            self.pad = pad\n            self.rounding_size = rounding_size\n            super().__init__()",
        "begin_line": 2207,
        "end_line": 2210,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.Round4.transmute#2212",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Round4",
        "signature": "lib.matplotlib.patches.Round4.transmute(self, x0, y0, width, height, mutation_size)",
        "snippet": "        def transmute(self, x0, y0, width, height, mutation_size):\n\n            # padding\n            pad = mutation_size * self.pad\n\n            # Rounding size; defaults to half of the padding.\n            if self.rounding_size:\n                dr = mutation_size * self.rounding_size\n            else:\n                dr = pad / 2.\n\n            width, height = (width + 2. * pad - 2 * dr,\n                             height + 2. * pad - 2 * dr)\n\n            x0, y0 = x0 - pad + dr, y0 - pad + dr,\n            x1, y1 = x0 + width, y0 + height\n\n            cp = [(x0, y0),\n                  (x0 + dr, y0 - dr), (x1 - dr, y0 - dr), (x1, y0),\n                  (x1 + dr, y0 + dr), (x1 + dr, y1 - dr), (x1, y1),\n                  (x1 - dr, y1 + dr), (x0 + dr, y1 + dr), (x0, y1),\n                  (x0 - dr, y1 - dr), (x0 - dr, y0 + dr), (x0, y0),\n                  (x0, y0)]\n\n            com = [Path.MOVETO,\n                   Path.CURVE4, Path.CURVE4, Path.CURVE4,\n                   Path.CURVE4, Path.CURVE4, Path.CURVE4,\n                   Path.CURVE4, Path.CURVE4, Path.CURVE4,\n                   Path.CURVE4, Path.CURVE4, Path.CURVE4,\n                   Path.CLOSEPOLY]\n\n            path = Path(cp, com)\n\n            return path",
        "begin_line": 2212,
        "end_line": 2245,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.Sawtooth.__init__#2259",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Sawtooth",
        "signature": "lib.matplotlib.patches.Sawtooth.__init__(self, pad=0.3, tooth_size=None)",
        "snippet": "        def __init__(self, pad=0.3, tooth_size=None):\n            self.pad = pad\n            self.tooth_size = tooth_size\n            super().__init__()",
        "begin_line": 2259,
        "end_line": 2262,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.Sawtooth._get_sawtooth_vertices#2264",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Sawtooth",
        "signature": "lib.matplotlib.patches.Sawtooth._get_sawtooth_vertices(self, x0, y0, width, height, mutation_size)",
        "snippet": "        def _get_sawtooth_vertices(self, x0, y0, width, height, mutation_size):\n\n            # padding\n            pad = mutation_size * self.pad\n\n            # size of sawtooth\n            if self.tooth_size is None:\n                tooth_size = self.pad * .5 * mutation_size\n            else:\n                tooth_size = self.tooth_size * mutation_size\n\n            tooth_size2 = tooth_size / 2.\n            width, height = (width + 2. * pad - tooth_size,\n                            height + 2. * pad - tooth_size)\n\n            # the sizes of the vertical and horizontal sawtooth are\n            # separately adjusted to fit the given box size.\n            dsx_n = int(round((width - tooth_size) / (tooth_size * 2))) * 2\n            dsx = (width - tooth_size) / dsx_n\n            dsy_n = int(round((height - tooth_size) / (tooth_size * 2))) * 2\n            dsy = (height - tooth_size) / dsy_n\n\n            x0, y0 = x0 - pad + tooth_size2, y0 - pad + tooth_size2\n            x1, y1 = x0 + width, y0 + height\n\n            bottom_saw_x = [\n                x0,\n                *(x0 + tooth_size2 + dsx * .5 * np.arange(dsx_n * 2)),\n                x1 - tooth_size2,\n            ]\n            bottom_saw_y = [\n                y0,\n                *([y0 - tooth_size2, y0, y0 + tooth_size2, y0] * dsx_n),\n                y0 - tooth_size2,\n            ]\n            right_saw_x = [\n                x1,\n                *([x1 + tooth_size2, x1, x1 - tooth_size2, x1] * dsx_n),\n                x1 + tooth_size2,\n            ]\n            right_saw_y = [\n                y0,\n                *(y0 + tooth_size2 + dsy * .5 * np.arange(dsy_n * 2)),\n                y1 - tooth_size2,\n            ]\n            top_saw_x = [\n                x1,\n                *(x1 - tooth_size2 - dsx * .5 * np.arange(dsx_n * 2)),\n                x0 + tooth_size2,\n            ]\n            top_saw_y = [\n                y1,\n                *([y1 + tooth_size2, y1, y1 - tooth_size2, y1] * dsx_n),\n                y1 + tooth_size2,\n            ]\n            left_saw_x = [\n                x0,\n                *([x0 - tooth_size2, x0, x0 + tooth_size2, x0] * dsy_n),\n                x0 - tooth_size2,\n            ]\n            left_saw_y = [\n                y1,\n                *(y1 - tooth_size2 - dsy * .5 * np.arange(dsy_n * 2)),\n                y0 + tooth_size2,\n            ]\n\n            saw_vertices = [*zip(bottom_saw_x, bottom_saw_y),\n                            *zip(right_saw_x, right_saw_y),\n                            *zip(top_saw_x, top_saw_y),\n                            *zip(left_saw_x, left_saw_y),\n                            (bottom_saw_x[0], bottom_saw_y[0])]\n\n            return saw_vertices",
        "begin_line": 2264,
        "end_line": 2336,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019916351324437363,
            "pseudo_dstar_susp": 0.00016353229762878168,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00016353229762878168,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.Sawtooth.transmute#2338",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Sawtooth",
        "signature": "lib.matplotlib.patches.Sawtooth.transmute(self, x0, y0, width, height, mutation_size)",
        "snippet": "        def transmute(self, x0, y0, width, height, mutation_size):\n            saw_vertices = self._get_sawtooth_vertices(x0, y0, width,\n                                                       height, mutation_size)\n            path = Path(saw_vertices, closed=True)\n            return path",
        "begin_line": 2338,
        "end_line": 2342,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.Roundtooth.__init__#2356",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Roundtooth",
        "signature": "lib.matplotlib.patches.Roundtooth.__init__(self, pad=0.3, tooth_size=None)",
        "snippet": "        def __init__(self, pad=0.3, tooth_size=None):\n            super().__init__(pad, tooth_size)",
        "begin_line": 2356,
        "end_line": 2357,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.Roundtooth.transmute#2359",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Roundtooth",
        "signature": "lib.matplotlib.patches.Roundtooth.transmute(self, x0, y0, width, height, mutation_size)",
        "snippet": "        def transmute(self, x0, y0, width, height, mutation_size):\n            saw_vertices = self._get_sawtooth_vertices(x0, y0,\n                                                       width, height,\n                                                       mutation_size)\n            # Add a trailing vertex to allow us to close the polygon correctly\n            saw_vertices = np.concatenate([np.array(saw_vertices),\n                                           [saw_vertices[0]]], axis=0)\n            codes = ([Path.MOVETO] +\n                     [Path.CURVE3, Path.CURVE3] * ((len(saw_vertices)-1)//2) +\n                     [Path.CLOSEPOLY])\n            return Path(saw_vertices, codes)",
        "begin_line": 2359,
        "end_line": 2369,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyBboxPatch.__str__#2392",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyBboxPatch",
        "signature": "lib.matplotlib.patches.FancyBboxPatch.__str__(self)",
        "snippet": "    def __str__(self):\n        s = self.__class__.__name__ + \"((%g, %g), width=%g, height=%g)\"\n        return s % (self._x, self._y, self._width, self._height)",
        "begin_line": 2392,
        "end_line": 2394,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyBboxPatch.__init__#2397",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyBboxPatch",
        "signature": "lib.matplotlib.patches.FancyBboxPatch.__init__(self, xy, width, height, boxstyle='round', bbox_transmuter=None, mutation_scale=1.0, mutation_aspect=None, **kwargs)",
        "snippet": "    def __init__(self, xy, width, height,\n                 boxstyle=\"round\",\n                 bbox_transmuter=None,\n                 mutation_scale=1.,\n                 mutation_aspect=None,\n                 **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        xy : float, float\n          The lower left corner of the box.\n\n        width : float\n            The width of the box.\n\n        height : float\n            The height of the box.\n\n        boxstyle : str or `matplotlib.patches.BoxStyle`\n            The style of the fancy box. This can either be a `.BoxStyle`\n            instance or a string of the style name and optionally comma\n            seprarated attributes (e.g. \"Round, pad=0.2\"). This string is\n            passed to `.BoxStyle` to construct a `.BoxStyle` object. See\n            there for a full documentation.\n\n            The following box styles are available:\n\n            %(AvailableBoxstyles)s\n\n        mutation_scale : float, optional, default: 1\n            Scaling factor applied to the attributes of the box style\n            (e.g. pad or rounding_size).\n\n        mutation_aspect : float, optional\n            The height of the rectangle will be squeezed by this value before\n            the mutation and the mutated box will be stretched by the inverse\n            of it. For example, this allows different horizontal and vertical\n            padding.\n\n        Other Parameters\n        ----------------\n        **kwargs : `.Patch` properties\n\n        %(Patch)s\n        \"\"\"\n\n        Patch.__init__(self, **kwargs)\n\n        self._x = xy[0]\n        self._y = xy[1]\n        self._width = width\n        self._height = height\n\n        if boxstyle == \"custom\":\n            if bbox_transmuter is None:\n                raise ValueError(\"bbox_transmuter argument is needed with \"\n                                 \"custom boxstyle\")\n            self._bbox_transmuter = bbox_transmuter\n        else:\n            self.set_boxstyle(boxstyle)\n\n        self._mutation_scale = mutation_scale\n        self._mutation_aspect = mutation_aspect\n\n        self.stale = True",
        "begin_line": 2397,
        "end_line": 2461,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002931691586045148,
            "pseudo_dstar_susp": 0.0002892681515765114,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.0002892681515765114,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyBboxPatch.set_boxstyle#2464",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyBboxPatch",
        "signature": "lib.matplotlib.patches.FancyBboxPatch.set_boxstyle(self, boxstyle=None, **kwargs)",
        "snippet": "    def set_boxstyle(self, boxstyle=None, **kwargs):\n        \"\"\"\n        Set the box style.\n\n        Most box styles can be further configured using attributes.\n        Attributes from the previous box style are not reused.\n\n        Without argument (or with ``boxstyle=None``), the available box styles\n        are returned as a human-readable string.\n\n        Parameters\n        ----------\n        boxstyle : str\n            The name of the box style. Optionally, followed by a comma and a\n            comma-separated list of attributes. The attributes may\n            alternatively be passed separately as keyword arguments.\n\n            The following box styles are available:\n\n            %(AvailableBoxstyles)s\n\n            .. ACCEPTS: %(ListBoxstyles)s\n\n        **kwargs\n            Additional attributes for the box style. See the table above for\n            supported parameters.\n\n        Examples\n        --------\n        ::\n\n            set_boxstyle(\"round,pad=0.2\")\n            set_boxstyle(\"round\", pad=0.2)\n\n        \"\"\"\n        if boxstyle is None:\n            return BoxStyle.pprint_styles()\n\n        if isinstance(boxstyle, BoxStyle._Base) or callable(boxstyle):\n            self._bbox_transmuter = boxstyle\n        else:\n            self._bbox_transmuter = BoxStyle(boxstyle, **kwargs)\n        self.stale = True",
        "begin_line": 2464,
        "end_line": 2506,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002876042565429968,
            "pseudo_dstar_susp": 0.0002883506343713956,
            "pseudo_tarantula_susp": 0.0002346866932644919,
            "pseudo_op2_susp": 0.0002883506343713956,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyBboxPatch.set_mutation_scale#2508",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyBboxPatch",
        "signature": "lib.matplotlib.patches.FancyBboxPatch.set_mutation_scale(self, scale)",
        "snippet": "    def set_mutation_scale(self, scale):\n        \"\"\"\n        Set the mutation scale.\n\n        Parameters\n        ----------\n        scale : float\n        \"\"\"\n        self._mutation_scale = scale\n        self.stale = True",
        "begin_line": 2508,
        "end_line": 2517,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003299241174529858,
            "pseudo_dstar_susp": 0.0002886002886002886,
            "pseudo_tarantula_susp": 0.0003992015968063872,
            "pseudo_op2_susp": 0.0002886002886002886,
            "pseudo_barinel_susp": 0.0003990422984836393
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyBboxPatch.get_mutation_scale#2519",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyBboxPatch",
        "signature": "lib.matplotlib.patches.FancyBboxPatch.get_mutation_scale(self)",
        "snippet": "    def get_mutation_scale(self):\n        \"\"\"Return the mutation scale.\"\"\"\n        return self._mutation_scale",
        "begin_line": 2519,
        "end_line": 2521,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyBboxPatch.get_mutation_aspect#2534",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyBboxPatch",
        "signature": "lib.matplotlib.patches.FancyBboxPatch.get_mutation_aspect(self)",
        "snippet": "    def get_mutation_aspect(self):\n        \"\"\"Return the aspect ratio of the bbox mutation.\"\"\"\n        return self._mutation_aspect",
        "begin_line": 2534,
        "end_line": 2536,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003240440699935191,
            "pseudo_dstar_susp": 0.0002731494127287626,
            "pseudo_tarantula_susp": 0.00040404040404040404,
            "pseudo_op2_susp": 0.0002731494127287626,
            "pseudo_barinel_susp": 0.00040404040404040404
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyBboxPatch.get_boxstyle#2538",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyBboxPatch",
        "signature": "lib.matplotlib.patches.FancyBboxPatch.get_boxstyle(self)",
        "snippet": "    def get_boxstyle(self):\n        \"\"\"Return the boxstyle object.\"\"\"\n        return self._bbox_transmuter",
        "begin_line": 2538,
        "end_line": 2540,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyBboxPatch.get_path#2542",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyBboxPatch",
        "signature": "lib.matplotlib.patches.FancyBboxPatch.get_path(self)",
        "snippet": "    def get_path(self):\n        \"\"\"Return the mutated path of the rectangle.\"\"\"\n        _path = self.get_boxstyle()(self._x, self._y,\n                                    self._width, self._height,\n                                    self.get_mutation_scale(),\n                                    self.get_mutation_aspect())\n        return _path",
        "begin_line": 2542,
        "end_line": 2548,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003240440699935191,
            "pseudo_dstar_susp": 0.0002731494127287626,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0002731494127287626,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyBboxPatch.set_bounds#2612",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyBboxPatch",
        "signature": "lib.matplotlib.patches.FancyBboxPatch.set_bounds(self, *args)",
        "snippet": "    def set_bounds(self, *args):\n        \"\"\"\n        Set the bounds of the rectangle.\n\n        Call signatures::\n\n            set_bounds(left, bottom, width, height)\n            set_bounds((left, bottom, width, height))\n\n        Parameters\n        ----------\n        left, bottom : float\n            The coordinates of the bottom left corner of the rectangle.\n        width, height : float\n            The width/height of the rectangle.\n        \"\"\"\n        if len(args) == 1:\n            l, b, w, h = args[0]\n        else:\n            l, b, w, h = args\n        self._x = l\n        self._y = b\n        self._width = w\n        self._height = h\n        self.stale = True",
        "begin_line": 2612,
        "end_line": 2636,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.SimpleEvent.__init__#2698",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.SimpleEvent",
        "signature": "lib.matplotlib.patches.SimpleEvent.__init__(self, xy)",
        "snippet": "            def __init__(self, xy):\n                self.x, self.y = xy",
        "begin_line": 2698,
        "end_line": 2699,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015992323684631377,
            "pseudo_dstar_susp": 0.0001405086412814388,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.0001405086412814388,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.patches._Base._clip#2701",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Base",
        "signature": "lib.matplotlib.patches._Base._clip(self, path, patchA, patchB)",
        "snippet": "        def _clip(self, path, patchA, patchB):\n            \"\"\"\n            Clip the path to the boundary of the patchA and patchB.\n            The starting point of the path needed to be inside of the\n            patchA and the end point inside the patch B. The *contains*\n            methods of each patch object is utilized to test if the point\n            is inside the path.\n            \"\"\"\n\n            if patchA:\n                def insideA(xy_display):\n                    xy_event = ConnectionStyle._Base.SimpleEvent(xy_display)\n                    return patchA.contains(xy_event)[0]\n\n                try:\n                    left, right = split_path_inout(path, insideA)\n                except ValueError:\n                    right = path\n\n                path = right\n\n            if patchB:\n                def insideB(xy_display):\n                    xy_event = ConnectionStyle._Base.SimpleEvent(xy_display)\n                    return patchB.contains(xy_event)[0]\n\n                try:\n                    left, right = split_path_inout(path, insideB)\n                except ValueError:\n                    left = path\n\n                path = left\n\n            return path",
        "begin_line": 2701,
        "end_line": 2734,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019179133103183735,
            "pseudo_dstar_susp": 0.00016812373907195696,
            "pseudo_tarantula_susp": 0.0003696857670979667,
            "pseudo_op2_susp": 0.00016812373907195696,
            "pseudo_barinel_susp": 0.0003696857670979667
        }
    },
    {
        "name": "lib.matplotlib.patches._Base.insideA#2711",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Base",
        "signature": "lib.matplotlib.patches._Base.insideA(xy_display)",
        "snippet": "                def insideA(xy_display):\n                    xy_event = ConnectionStyle._Base.SimpleEvent(xy_display)\n                    return patchA.contains(xy_event)[0]",
        "begin_line": 2711,
        "end_line": 2713,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches._Base._shrink#2736",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Base",
        "signature": "lib.matplotlib.patches._Base._shrink(self, path, shrinkA, shrinkB)",
        "snippet": "        def _shrink(self, path, shrinkA, shrinkB):\n            \"\"\"\n            Shrink the path by fixed size (in points) with shrinkA and shrinkB.\n            \"\"\"\n            if shrinkA:\n                insideA = inside_circle(*path.vertices[0], shrinkA)\n                try:\n                    left, path = split_path_inout(path, insideA)\n                except ValueError:\n                    pass\n            if shrinkB:\n                insideB = inside_circle(*path.vertices[-1], shrinkB)\n                try:\n                    path, right = split_path_inout(path, insideB)\n                except ValueError:\n                    pass\n            return path",
        "begin_line": 2736,
        "end_line": 2752,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001417635384179189,
            "pseudo_dstar_susp": 0.00016911889058007779,
            "pseudo_tarantula_susp": 0.0001353729524840937,
            "pseudo_op2_susp": 0.00016911889058007779,
            "pseudo_barinel_susp": 0.0001353729524840937
        }
    },
    {
        "name": "lib.matplotlib.patches._Base.__call__#2754",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Base",
        "signature": "lib.matplotlib.patches._Base.__call__(self, posA, posB, shrinkA=2.0, shrinkB=2.0, patchA=None, patchB=None)",
        "snippet": "        def __call__(self, posA, posB,\n                     shrinkA=2., shrinkB=2., patchA=None, patchB=None):\n            \"\"\"\n            Calls the *connect* method to create a path between *posA*\n             and *posB*. The path is clipped and shrunken.\n            \"\"\"\n\n            path = self.connect(posA, posB)\n\n            clipped_path = self._clip(path, patchA, patchB)\n            shrunk_path = self._shrink(clipped_path, shrinkA, shrinkB)\n\n            return shrunk_path",
        "begin_line": 2754,
        "end_line": 2766,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013846579894765993,
            "pseudo_dstar_susp": 0.00016784155756965425,
            "pseudo_tarantula_susp": 0.0001268713524486171,
            "pseudo_op2_susp": 0.00016784155756965425,
            "pseudo_barinel_susp": 0.0001268713524486171
        }
    },
    {
        "name": "lib.matplotlib.patches.Arc3.__init__#2778",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Arc3",
        "signature": "lib.matplotlib.patches.Arc3.__init__(self, rad=0.0)",
        "snippet": "        def __init__(self, rad=0.):\n            \"\"\"\n            *rad*\n              curvature of the curve.\n            \"\"\"\n            self.rad = rad",
        "begin_line": 2778,
        "end_line": 2783,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.0001485663348685188,
            "pseudo_tarantula_susp": 0.00017415534656913968,
            "pseudo_op2_susp": 0.0001485663348685188,
            "pseudo_barinel_susp": 0.0001742767514813524
        }
    },
    {
        "name": "lib.matplotlib.patches.Arc3.connect#2785",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Arc3",
        "signature": "lib.matplotlib.patches.Arc3.connect(self, posA, posB)",
        "snippet": "        def connect(self, posA, posB):\n            x1, y1 = posA\n            x2, y2 = posB\n            x12, y12 = (x1 + x2) / 2., (y1 + y2) / 2.\n            dx, dy = x2 - x1, y2 - y1\n\n            f = self.rad\n\n            cx, cy = x12 + f * dy, y12 - f * dx\n\n            vertices = [(x1, y1),\n                        (cx, cy),\n                        (x2, y2)]\n            codes = [Path.MOVETO,\n                     Path.CURVE3,\n                     Path.CURVE3]\n\n            return Path(vertices, codes)",
        "begin_line": 2785,
        "end_line": 2802,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00015683814303638644,
            "pseudo_tarantula_susp": 0.000129315918789603,
            "pseudo_op2_susp": 0.00015683814303638644,
            "pseudo_barinel_susp": 0.000129315918789603
        }
    },
    {
        "name": "lib.matplotlib.patches.Angle3.__init__#2813",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Angle3",
        "signature": "lib.matplotlib.patches.Angle3.__init__(self, angleA=90, angleB=0)",
        "snippet": "        def __init__(self, angleA=90, angleB=0):\n            \"\"\"\n            *angleA*\n              starting angle of the path\n\n            *angleB*\n              ending angle of the path\n            \"\"\"\n\n            self.angleA = angleA\n            self.angleB = angleB",
        "begin_line": 2813,
        "end_line": 2823,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011859582542694497,
            "pseudo_dstar_susp": 0.00011637379262190155,
            "pseudo_tarantula_susp": 0.000129315918789603,
            "pseudo_op2_susp": 0.00011637379262190155,
            "pseudo_barinel_susp": 0.000129315918789603
        }
    },
    {
        "name": "lib.matplotlib.patches.Angle3.connect#2825",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Angle3",
        "signature": "lib.matplotlib.patches.Angle3.connect(self, posA, posB)",
        "snippet": "        def connect(self, posA, posB):\n            x1, y1 = posA\n            x2, y2 = posB\n\n            cosA = math.cos(math.radians(self.angleA))\n            sinA = math.sin(math.radians(self.angleA))\n            cosB = math.cos(math.radians(self.angleB))\n            sinB = math.sin(math.radians(self.angleB))\n\n            cx, cy = get_intersection(x1, y1, cosA, sinA,\n                                      x2, y2, cosB, sinB)\n\n            vertices = [(x1, y1), (cx, cy), (x2, y2)]\n            codes = [Path.MOVETO, Path.CURVE3, Path.CURVE3]\n\n            return Path(vertices, codes)",
        "begin_line": 2825,
        "end_line": 2840,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012717792191275595,
            "pseudo_dstar_susp": 0.0001210800339024095,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.0001210800339024095,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.patches.Angle.__init__#2852",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Angle",
        "signature": "lib.matplotlib.patches.Angle.__init__(self, angleA=90, angleB=0, rad=0.0)",
        "snippet": "        def __init__(self, angleA=90, angleB=0, rad=0.):\n            \"\"\"\n            *angleA*\n              starting angle of the path\n\n            *angleB*\n              ending angle of the path\n\n            *rad*\n              rounding radius of the edge\n            \"\"\"\n\n            self.angleA = angleA\n            self.angleB = angleB\n\n            self.rad = rad",
        "begin_line": 2852,
        "end_line": 2867,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Angle.connect#2869",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Angle",
        "signature": "lib.matplotlib.patches.Angle.connect(self, posA, posB)",
        "snippet": "        def connect(self, posA, posB):\n            x1, y1 = posA\n            x2, y2 = posB\n\n            cosA = math.cos(math.radians(self.angleA))\n            sinA = math.sin(math.radians(self.angleA))\n            cosB = math.cos(math.radians(self.angleB))\n            sinB = math.sin(math.radians(self.angleB))\n\n            cx, cy = get_intersection(x1, y1, cosA, sinA,\n                                      x2, y2, cosB, sinB)\n\n            vertices = [(x1, y1)]\n            codes = [Path.MOVETO]\n\n            if self.rad == 0.:\n                vertices.append((cx, cy))\n                codes.append(Path.LINETO)\n            else:\n                dx1, dy1 = x1 - cx, y1 - cy\n                d1 = np.hypot(dx1, dy1)\n                f1 = self.rad / d1\n                dx2, dy2 = x2 - cx, y2 - cy\n                d2 = np.hypot(dx2, dy2)\n                f2 = self.rad / d2\n                vertices.extend([(cx + dx1 * f1, cy + dy1 * f1),\n                                 (cx, cy),\n                                 (cx + dx2 * f2, cy + dy2 * f2)])\n                codes.extend([Path.LINETO, Path.CURVE3, Path.CURVE3])\n\n            vertices.append((x2, y2))\n            codes.append(Path.LINETO)\n\n            return Path(vertices, codes)",
        "begin_line": 2869,
        "end_line": 2902,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Arc.__init__#2914",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Arc",
        "signature": "lib.matplotlib.patches.Arc.__init__(self, angleA=0, angleB=0, armA=None, armB=None, rad=0.0)",
        "snippet": "        def __init__(self, angleA=0, angleB=0, armA=None, armB=None, rad=0.):\n            \"\"\"\n            *angleA* :\n              starting angle of the path\n\n            *angleB* :\n              ending angle of the path\n\n            *armA* :\n              length of the starting arm\n\n            *armB* :\n              length of the ending arm\n\n            *rad* :\n              rounding radius of the edges\n            \"\"\"\n\n            self.angleA = angleA\n            self.angleB = angleB\n            self.armA = armA\n            self.armB = armB\n\n            self.rad = rad",
        "begin_line": 2914,
        "end_line": 2937,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Arc.connect#2939",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Arc",
        "signature": "lib.matplotlib.patches.Arc.connect(self, posA, posB)",
        "snippet": "        def connect(self, posA, posB):\n            x1, y1 = posA\n            x2, y2 = posB\n\n            vertices = [(x1, y1)]\n            rounded = []\n            codes = [Path.MOVETO]\n\n            if self.armA:\n                cosA = math.cos(math.radians(self.angleA))\n                sinA = math.sin(math.radians(self.angleA))\n                # x_armA, y_armB\n                d = self.armA - self.rad\n                rounded.append((x1 + d * cosA, y1 + d * sinA))\n                d = self.armA\n                rounded.append((x1 + d * cosA, y1 + d * sinA))\n\n            if self.armB:\n                cosB = math.cos(math.radians(self.angleB))\n                sinB = math.sin(math.radians(self.angleB))\n                x_armB, y_armB = x2 + self.armB * cosB, y2 + self.armB * sinB\n\n                if rounded:\n                    xp, yp = rounded[-1]\n                    dx, dy = x_armB - xp, y_armB - yp\n                    dd = (dx * dx + dy * dy) ** .5\n\n                    rounded.append((xp + self.rad * dx / dd,\n                                    yp + self.rad * dy / dd))\n                    vertices.extend(rounded)\n                    codes.extend([Path.LINETO,\n                                  Path.CURVE3,\n                                  Path.CURVE3])\n                else:\n                    xp, yp = vertices[-1]\n                    dx, dy = x_armB - xp, y_armB - yp\n                    dd = (dx * dx + dy * dy) ** .5\n\n                d = dd - self.rad\n                rounded = [(xp + d * dx / dd, yp + d * dy / dd),\n                           (x_armB, y_armB)]\n\n            if rounded:\n                xp, yp = rounded[-1]\n                dx, dy = x2 - xp, y2 - yp\n                dd = (dx * dx + dy * dy) ** .5\n\n                rounded.append((xp + self.rad * dx / dd,\n                                yp + self.rad * dy / dd))\n                vertices.extend(rounded)\n                codes.extend([Path.LINETO,\n                              Path.CURVE3,\n                              Path.CURVE3])\n\n            vertices.append((x2, y2))\n            codes.append(Path.LINETO)\n\n            return Path(vertices, codes)",
        "begin_line": 2939,
        "end_line": 2996,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Bar.__init__#3007",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Bar",
        "signature": "lib.matplotlib.patches.Bar.__init__(self, armA=0.0, armB=0.0, fraction=0.3, angle=None)",
        "snippet": "        def __init__(self, armA=0., armB=0., fraction=0.3, angle=None):\n            \"\"\"\n            Parameters\n            ----------\n            armA : float\n                minimum length of armA\n\n            armB : float\n                minimum length of armB\n\n            fraction : float\n                a fraction of the distance between two points that\n                will be added to armA and armB.\n\n            angle : float or None\n                angle of the connecting line (if None, parallel\n                to A and B)\n            \"\"\"\n            self.armA = armA\n            self.armB = armB\n            self.fraction = fraction\n            self.angle = angle",
        "begin_line": 3007,
        "end_line": 3028,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Bar.connect#3030",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Bar",
        "signature": "lib.matplotlib.patches.Bar.connect(self, posA, posB)",
        "snippet": "        def connect(self, posA, posB):\n            x1, y1 = posA\n            x20, y20 = x2, y2 = posB\n\n            theta1 = math.atan2(y2 - y1, x2 - x1)\n            dx, dy = x2 - x1, y2 - y1\n            dd = (dx * dx + dy * dy) ** .5\n            ddx, ddy = dx / dd, dy / dd\n\n            armA, armB = self.armA, self.armB\n\n            if self.angle is not None:\n                theta0 = np.deg2rad(self.angle)\n                dtheta = theta1 - theta0\n                dl = dd * math.sin(dtheta)\n                dL = dd * math.cos(dtheta)\n                x2, y2 = x1 + dL * math.cos(theta0), y1 + dL * math.sin(theta0)\n                armB = armB - dl\n\n                # update\n                dx, dy = x2 - x1, y2 - y1\n                dd2 = (dx * dx + dy * dy) ** .5\n                ddx, ddy = dx / dd2, dy / dd2\n\n            arm = max(armA, armB)\n            f = self.fraction * dd + arm\n\n            cx1, cy1 = x1 + f * ddy, y1 - f * ddx\n            cx2, cy2 = x2 + f * ddy, y2 - f * ddx\n\n            vertices = [(x1, y1),\n                        (cx1, cy1),\n                        (cx2, cy2),\n                        (x20, y20)]\n            codes = [Path.MOVETO,\n                     Path.LINETO,\n                     Path.LINETO,\n                     Path.LINETO]\n\n            return Path(vertices, codes)",
        "begin_line": 3030,
        "end_line": 3069,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches._point_along_a_line#3076",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches",
        "signature": "lib.matplotlib.patches._point_along_a_line(x0, y0, x1, y1, d)",
        "snippet": "def _point_along_a_line(x0, y0, x1, y1, d):\n    \"\"\"\n    Return the point on the line connecting (*x0*, *y0*) -- (*x1*, *y1*) whose\n    distance from (*x0*, *y0*) is *d*.\n    \"\"\"\n    dx, dy = x0 - x1, y0 - y1\n    ff = d / (dx * dx + dy * dy) ** .5\n    x2, y2 = x0 - ff * dx, y0 - ff * dy\n\n    return x2, y2",
        "begin_line": 3076,
        "end_line": 3085,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches._Base.ensure_quadratic_bezier#3144",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Base",
        "signature": "lib.matplotlib.patches._Base.ensure_quadratic_bezier(path)",
        "snippet": "        def ensure_quadratic_bezier(path):\n            \"\"\"\n            Some ArrowStyle class only works with a simple quadratic Bezier\n            curve (created with Arc3Connection or Angle3Connector). This static\n            method is to check if the provided path is a simple quadratic\n            Bezier curve and returns its control points if true.\n            \"\"\"\n            segments = list(path.iter_segments())\n            if (len(segments) != 2 or segments[0][1] != Path.MOVETO or\n                    segments[1][1] != Path.CURVE3):\n                raise ValueError(\n                    \"'path' is not a valid quadratic Bezier curve\")\n            return [*segments[0][0], *segments[1][0]]",
        "begin_line": 3144,
        "end_line": 3156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001290822253775655,
            "pseudo_dstar_susp": 0.0001359249694168819,
            "pseudo_tarantula_susp": 0.00015482272797646694,
            "pseudo_op2_susp": 0.0001359249694168819,
            "pseudo_barinel_susp": 0.00015446400988569664
        }
    },
    {
        "name": "lib.matplotlib.patches._Base.__call__#3172",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Base",
        "signature": "lib.matplotlib.patches._Base.__call__(self, path, mutation_size, linewidth, aspect_ratio=1.0)",
        "snippet": "        def __call__(self, path, mutation_size, linewidth,\n                     aspect_ratio=1.):\n            \"\"\"\n            The __call__ method is a thin wrapper around the transmute method\n            and takes care of the aspect ratio.\n            \"\"\"\n\n            path = make_path_regular(path)\n\n            if aspect_ratio is not None:\n                # Squeeze the given height by the aspect_ratio\n\n                vertices, codes = path.vertices[:], path.codes[:]\n                # Squeeze the height\n                vertices[:, 1] = vertices[:, 1] / aspect_ratio\n                path_shrunk = Path(vertices, codes)\n                # call transmute method with squeezed height.\n                path_mutated, fillable = self.transmute(path_shrunk,\n                                                        linewidth,\n                                                        mutation_size)\n                if np.iterable(fillable):\n                    path_list = []\n                    for p in zip(path_mutated):\n                        v, c = p.vertices, p.codes\n                        # Restore the height\n                        v[:, 1] = v[:, 1] * aspect_ratio\n                        path_list.append(Path(v, c))\n                    return path_list, fillable\n                else:\n                    return path_mutated, fillable\n            else:\n                return self.transmute(path, mutation_size, linewidth)",
        "begin_line": 3172,
        "end_line": 3203,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013904338153503893,
            "pseudo_dstar_susp": 0.00016803898504453034,
            "pseudo_tarantula_susp": 0.0001277139208173691,
            "pseudo_op2_susp": 0.00016803898504453034,
            "pseudo_barinel_susp": 0.0001277139208173691
        }
    },
    {
        "name": "lib.matplotlib.patches._Curve.__init__#3213",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Curve",
        "signature": "lib.matplotlib.patches._Curve.__init__(self, beginarrow=None, endarrow=None, fillbegin=False, fillend=False, head_length=0.2, head_width=0.1)",
        "snippet": "        def __init__(self, beginarrow=None, endarrow=None,\n                     fillbegin=False, fillend=False,\n                     head_length=.2, head_width=.1):\n            \"\"\"\n            The arrows are drawn if *beginarrow* and/or *endarrow* are\n            true. *head_length* and *head_width* determines the size\n            of the arrow relative to the *mutation scale*.  The\n            arrowhead at the begin (or end) is closed if fillbegin (or\n            fillend) is True.\n            \"\"\"\n            self.beginarrow, self.endarrow = beginarrow, endarrow\n            self.head_length, self.head_width = head_length, head_width\n            self.fillbegin, self.fillend = fillbegin, fillend\n            super().__init__()",
        "begin_line": 3213,
        "end_line": 3226,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012588116817724068,
            "pseudo_dstar_susp": 0.00014874312063067083,
            "pseudo_tarantula_susp": 0.0001211827435773146,
            "pseudo_op2_susp": 0.00014874312063067083,
            "pseudo_barinel_susp": 0.00012134449702705982
        }
    },
    {
        "name": "lib.matplotlib.patches._Curve._get_arrow_wedge#3228",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Curve",
        "signature": "lib.matplotlib.patches._Curve._get_arrow_wedge(self, x0, y0, x1, y1, head_dist, cos_t, sin_t, linewidth)",
        "snippet": "        def _get_arrow_wedge(self, x0, y0, x1, y1,\n                             head_dist, cos_t, sin_t, linewidth):\n            \"\"\"\n            Return the paths for arrow heads. Since arrow lines are\n            drawn with capstyle=projected, The arrow goes beyond the\n            desired point. This method also returns the amount of the path\n            to be shrunken so that it does not overshoot.\n            \"\"\"\n\n            # arrow from x0, y0 to x1, y1\n            dx, dy = x0 - x1, y0 - y1\n\n            cp_distance = np.hypot(dx, dy)\n\n            # pad_projected : amount of pad to account the\n            # overshooting of the projection of the wedge\n            pad_projected = (.5 * linewidth / sin_t)\n\n            # Account for division by zero\n            if cp_distance == 0:\n                cp_distance = 1\n\n            # apply pad for projected edge\n            ddx = pad_projected * dx / cp_distance\n            ddy = pad_projected * dy / cp_distance\n\n            # offset for arrow wedge\n            dx = dx / cp_distance * head_dist\n            dy = dy / cp_distance * head_dist\n\n            dx1, dy1 = cos_t * dx + sin_t * dy, -sin_t * dx + cos_t * dy\n            dx2, dy2 = cos_t * dx - sin_t * dy, sin_t * dx + cos_t * dy\n\n            vertices_arrow = [(x1 + ddx + dx1, y1 + ddy + dy1),\n                              (x1 + ddx, y1 + ddy),\n                              (x1 + ddx + dx2, y1 + ddy + dy2)]\n            codes_arrow = [Path.MOVETO,\n                           Path.LINETO,\n                           Path.LINETO]\n\n            return vertices_arrow, codes_arrow, ddx, ddy",
        "begin_line": 3228,
        "end_line": 3268,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015659254619480113,
            "pseudo_dstar_susp": 0.00015158405335758679,
            "pseudo_tarantula_susp": 0.0002158894645941278,
            "pseudo_op2_susp": 0.00015158405335758679,
            "pseudo_barinel_susp": 0.00021598272138228941
        }
    },
    {
        "name": "lib.matplotlib.patches._Curve.transmute#3270",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Curve",
        "signature": "lib.matplotlib.patches._Curve.transmute(self, path, mutation_size, linewidth)",
        "snippet": "        def transmute(self, path, mutation_size, linewidth):\n\n            head_length = self.head_length * mutation_size\n            head_width = self.head_width * mutation_size\n            head_dist = np.hypot(head_length, head_width)\n            cos_t, sin_t = head_length / head_dist, head_width / head_dist\n\n            # begin arrow\n            x0, y0 = path.vertices[0]\n            x1, y1 = path.vertices[1]\n\n            # If there is no room for an arrow and a line, then skip the arrow\n            has_begin_arrow = self.beginarrow and (x0, y0) != (x1, y1)\n            verticesA, codesA, ddxA, ddyA = (\n                self._get_arrow_wedge(x1, y1, x0, y0,\n                                      head_dist, cos_t, sin_t, linewidth)\n                if has_begin_arrow\n                else ([], [], 0, 0)\n            )\n\n            # end arrow\n            x2, y2 = path.vertices[-2]\n            x3, y3 = path.vertices[-1]\n\n            # If there is no room for an arrow and a line, then skip the arrow\n            has_end_arrow = self.endarrow and (x2, y2) != (x3, y3)\n            verticesB, codesB, ddxB, ddyB = (\n                self._get_arrow_wedge(x2, y2, x3, y3,\n                                      head_dist, cos_t, sin_t, linewidth)\n                if has_end_arrow\n                else ([], [], 0, 0)\n            )\n\n            # This simple code will not work if ddx, ddy is greater than the\n            # separation between vertices.\n            _path = [Path(np.concatenate([[(x0 + ddxA, y0 + ddyA)],\n                                          path.vertices[1:-1],\n                                          [(x3 + ddxB, y3 + ddyB)]]),\n                          path.codes)]\n            _fillable = [False]\n\n            if has_begin_arrow:\n                if self.fillbegin:\n                    p = np.concatenate([verticesA, [verticesA[0],\n                                                    verticesA[0]], ])\n                    c = np.concatenate([codesA, [Path.LINETO, Path.CLOSEPOLY]])\n                    _path.append(Path(p, c))\n                    _fillable.append(True)\n                else:\n                    _path.append(Path(verticesA, codesA))\n                    _fillable.append(False)\n\n            if has_end_arrow:\n                if self.fillend:\n                    _fillable.append(True)\n                    p = np.concatenate([verticesB, [verticesB[0],\n                                                    verticesB[0]], ])\n                    c = np.concatenate([codesB, [Path.LINETO, Path.CLOSEPOLY]])\n                    _path.append(Path(p, c))\n                else:\n                    _fillable.append(False)\n                    _path.append(Path(verticesB, codesB))\n\n            return _path, _fillable",
        "begin_line": 3270,
        "end_line": 3333,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00014880952380952382,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014880952380952382,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.patches.Curve.__init__#3341",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Curve",
        "signature": "lib.matplotlib.patches.Curve.__init__(self)",
        "snippet": "        def __init__(self):\n            super().__init__(beginarrow=False, endarrow=False)",
        "begin_line": 3341,
        "end_line": 3342,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.CurveA.__init__#3350",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.CurveA",
        "signature": "lib.matplotlib.patches.CurveA.__init__(self, head_length=0.4, head_width=0.2)",
        "snippet": "        def __init__(self, head_length=.4, head_width=.2):\n            \"\"\"\n            Parameters\n            ----------\n            head_length : float, optional, default : 0.4\n                Length of the arrow head\n\n            head_width : float, optional, default : 0.2\n                Width of the arrow head\n            \"\"\"\n            super().__init__(beginarrow=True, endarrow=False,\n                             head_length=head_length, head_width=head_width)",
        "begin_line": 3350,
        "end_line": 3361,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.CurveB.__init__#3369",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.CurveB",
        "signature": "lib.matplotlib.patches.CurveB.__init__(self, head_length=0.4, head_width=0.2)",
        "snippet": "        def __init__(self, head_length=.4, head_width=.2):\n            \"\"\"\n            Parameters\n            ----------\n            head_length : float, optional, default : 0.4\n                Length of the arrow head\n\n            head_width : float, optional, default : 0.2\n                Width of the arrow head\n            \"\"\"\n            super().__init__(beginarrow=False, endarrow=True,\n                             head_length=head_length, head_width=head_width)",
        "begin_line": 3369,
        "end_line": 3380,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012195121951219512,
            "pseudo_dstar_susp": 0.00011855364552459988,
            "pseudo_tarantula_susp": 0.00015482272797646694,
            "pseudo_op2_susp": 0.00011855364552459988,
            "pseudo_barinel_susp": 0.00015446400988569664
        }
    },
    {
        "name": "lib.matplotlib.patches.CurveAB.__init__#3388",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.CurveAB",
        "signature": "lib.matplotlib.patches.CurveAB.__init__(self, head_length=0.4, head_width=0.2)",
        "snippet": "        def __init__(self, head_length=.4, head_width=.2):\n            \"\"\"\n            Parameters\n            ----------\n            head_length : float, optional, default : 0.4\n                Length of the arrow head\n\n            head_width : float, optional, default : 0.2\n                Width of the arrow head\n            \"\"\"\n            super().__init__(beginarrow=True, endarrow=True,\n                             head_length=head_length, head_width=head_width)",
        "begin_line": 3388,
        "end_line": 3399,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.CurveFilledA.__init__#3407",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.CurveFilledA",
        "signature": "lib.matplotlib.patches.CurveFilledA.__init__(self, head_length=0.4, head_width=0.2)",
        "snippet": "        def __init__(self, head_length=.4, head_width=.2):\n            \"\"\"\n            Parameters\n            ----------\n            head_length : float, optional, default : 0.4\n                Length of the arrow head\n\n            head_width : float, optional, default : 0.2\n                Width of the arrow head\n            \"\"\"\n            super().__init__(beginarrow=True, endarrow=False,\n                             fillbegin=True, fillend=False,\n                             head_length=head_length, head_width=head_width)",
        "begin_line": 3407,
        "end_line": 3419,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.CurveFilledB.__init__#3427",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.CurveFilledB",
        "signature": "lib.matplotlib.patches.CurveFilledB.__init__(self, head_length=0.4, head_width=0.2)",
        "snippet": "        def __init__(self, head_length=.4, head_width=.2):\n            \"\"\"\n            Parameters\n            ----------\n            head_length : float, optional, default : 0.4\n                Length of the arrow head\n\n            head_width : float, optional, default : 0.2\n                Width of the arrow head\n            \"\"\"\n            super().__init__(beginarrow=False, endarrow=True,\n                             fillbegin=False, fillend=True,\n                             head_length=head_length, head_width=head_width)",
        "begin_line": 3427,
        "end_line": 3439,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011584800741427248,
            "pseudo_dstar_susp": 0.00011463945890175398,
            "pseudo_tarantula_susp": 0.00011973180076628352,
            "pseudo_op2_susp": 0.00011463945890175398,
            "pseudo_barinel_susp": 0.00011973180076628352
        }
    },
    {
        "name": "lib.matplotlib.patches.CurveFilledAB.__init__#3447",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.CurveFilledAB",
        "signature": "lib.matplotlib.patches.CurveFilledAB.__init__(self, head_length=0.4, head_width=0.2)",
        "snippet": "        def __init__(self, head_length=.4, head_width=.2):\n            \"\"\"\n            Parameters\n            ----------\n            head_length : float, optional, default : 0.4\n                Length of the arrow head\n\n            head_width : float, optional, default : 0.2\n                Width of the arrow head\n            \"\"\"\n            super().__init__(beginarrow=True, endarrow=True,\n                             fillbegin=True, fillend=True,\n                             head_length=head_length, head_width=head_width)",
        "begin_line": 3447,
        "end_line": 3459,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches._Bracket.__init__#3463",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Bracket",
        "signature": "lib.matplotlib.patches._Bracket.__init__(self, bracketA=None, bracketB=None, widthA=1.0, widthB=1.0, lengthA=0.2, lengthB=0.2, angleA=None, angleB=None, scaleA=None, scaleB=None)",
        "snippet": "        def __init__(self, bracketA=None, bracketB=None,\n                     widthA=1., widthB=1.,\n                     lengthA=0.2, lengthB=0.2,\n                     angleA=None, angleB=None,\n                     scaleA=None, scaleB=None):\n            self.bracketA, self.bracketB = bracketA, bracketB\n            self.widthA, self.widthB = widthA, widthB\n            self.lengthA, self.lengthB = lengthA, lengthB\n            self.angleA, self.angleB = angleA, angleB\n            self.scaleA, self.scaleB = scaleA, scaleB",
        "begin_line": 3463,
        "end_line": 3472,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches._Bracket._get_bracket#3474",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Bracket",
        "signature": "lib.matplotlib.patches._Bracket._get_bracket(self, x0, y0, cos_t, sin_t, width, length)",
        "snippet": "        def _get_bracket(self, x0, y0,\n                         cos_t, sin_t, width, length):\n\n            # arrow from x0, y0 to x1, y1\n            from matplotlib.bezier import get_normal_points\n            x1, y1, x2, y2 = get_normal_points(x0, y0, cos_t, sin_t, width)\n\n            dx, dy = length * cos_t, length * sin_t\n\n            vertices_arrow = [(x1 + dx, y1 + dy),\n                              (x1, y1),\n                              (x2, y2),\n                              (x2 + dx, y2 + dy)]\n            codes_arrow = [Path.MOVETO,\n                           Path.LINETO,\n                           Path.LINETO,\n                           Path.LINETO]\n\n            return vertices_arrow, codes_arrow",
        "begin_line": 3474,
        "end_line": 3492,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches._Bracket.transmute#3494",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Bracket",
        "signature": "lib.matplotlib.patches._Bracket.transmute(self, path, mutation_size, linewidth)",
        "snippet": "        def transmute(self, path, mutation_size, linewidth):\n\n            if self.scaleA is None:\n                scaleA = mutation_size\n            else:\n                scaleA = self.scaleA\n\n            if self.scaleB is None:\n                scaleB = mutation_size\n            else:\n                scaleB = self.scaleB\n\n            vertices_list, codes_list = [], []\n\n            if self.bracketA:\n                x0, y0 = path.vertices[0]\n                x1, y1 = path.vertices[1]\n                cos_t, sin_t = get_cos_sin(x1, y1, x0, y0)\n                verticesA, codesA = self._get_bracket(x0, y0, cos_t, sin_t,\n                                                      self.widthA * scaleA,\n                                                      self.lengthA * scaleA)\n                vertices_list.append(verticesA)\n                codes_list.append(codesA)\n\n            vertices_list.append(path.vertices)\n            codes_list.append(path.codes)\n\n            if self.bracketB:\n                x0, y0 = path.vertices[-1]\n                x1, y1 = path.vertices[-2]\n                cos_t, sin_t = get_cos_sin(x1, y1, x0, y0)\n                verticesB, codesB = self._get_bracket(x0, y0, cos_t, sin_t,\n                                                      self.widthB * scaleB,\n                                                      self.lengthB * scaleB)\n                vertices_list.append(verticesB)\n                codes_list.append(codesB)\n\n            vertices = np.concatenate(vertices_list)\n            codes = np.concatenate(codes_list)\n\n            p = Path(vertices, codes)\n\n            return p, False",
        "begin_line": 3494,
        "end_line": 3536,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.BracketAB.__init__#3544",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.BracketAB",
        "signature": "lib.matplotlib.patches.BracketAB.__init__(self, widthA=1.0, lengthA=0.2, angleA=None, widthB=1.0, lengthB=0.2, angleB=None)",
        "snippet": "        def __init__(self,\n                     widthA=1., lengthA=0.2, angleA=None,\n                     widthB=1., lengthB=0.2, angleB=None):\n            \"\"\"\n            Parameters\n            ----------\n            widthA : float, optional, default : 1.0\n                Width of the bracket\n\n            lengthA : float, optional, default : 0.2\n                Length of the bracket\n\n            angleA : float, optional, default : None\n                Angle between the bracket and the line\n\n            widthB : float, optional, default : 1.0\n                Width of the bracket\n\n            lengthB : float, optional, default : 0.2\n                Length of the bracket\n\n            angleB : float, optional, default : None\n                Angle between the bracket and the line\n            \"\"\"\n            super().__init__(True, True,\n                             widthA=widthA, lengthA=lengthA, angleA=angleA,\n                             widthB=widthB, lengthB=lengthB, angleB=angleB)",
        "begin_line": 3544,
        "end_line": 3570,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.BracketA.__init__#3578",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.BracketA",
        "signature": "lib.matplotlib.patches.BracketA.__init__(self, widthA=1.0, lengthA=0.2, angleA=None)",
        "snippet": "        def __init__(self, widthA=1., lengthA=0.2, angleA=None):\n            \"\"\"\n            Parameters\n            ----------\n            widthA : float, optional, default : 1.0\n                Width of the bracket\n\n            lengthA : float, optional, default : 0.2\n                Length of the bracket\n\n            angleA : float, optional, default : None\n                Angle between the bracket and the line\n            \"\"\"\n            super().__init__(True, None,\n                             widthA=widthA, lengthA=lengthA, angleA=angleA)",
        "begin_line": 3578,
        "end_line": 3592,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.BracketB.__init__#3600",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.BracketB",
        "signature": "lib.matplotlib.patches.BracketB.__init__(self, widthB=1.0, lengthB=0.2, angleB=None)",
        "snippet": "        def __init__(self, widthB=1., lengthB=0.2, angleB=None):\n            \"\"\"\n            Parameters\n            ----------\n            widthB : float, optional, default : 1.0\n                Width of the bracket\n\n            lengthB : float, optional, default : 0.2\n                Length of the bracket\n\n            angleB : float, optional, default : None\n                Angle between the bracket and the line\n            \"\"\"\n            super().__init__(None, True,\n                             widthB=widthB, lengthB=lengthB, angleB=angleB)",
        "begin_line": 3600,
        "end_line": 3614,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.BarAB.__init__#3622",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.BarAB",
        "signature": "lib.matplotlib.patches.BarAB.__init__(self, widthA=1.0, angleA=None, widthB=1.0, angleB=None)",
        "snippet": "        def __init__(self,\n                     widthA=1., angleA=None,\n                     widthB=1., angleB=None):\n            \"\"\"\n            Parameters\n            ----------\n            widthA : float, optional, default : 1.0\n                Width of the bracket\n\n            angleA : float, optional, default : None\n                Angle between the bracket and the line\n\n            widthB : float, optional, default : 1.0\n                Width of the bracket\n\n            angleB : float, optional, default : None\n                Angle between the bracket and the line\n            \"\"\"\n            super().__init__(True, True,\n                             widthA=widthA, lengthA=0, angleA=angleA,\n                             widthB=widthB, lengthB=0, angleB=angleB)",
        "begin_line": 3622,
        "end_line": 3642,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Simple.__init__#3650",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Simple",
        "signature": "lib.matplotlib.patches.Simple.__init__(self, head_length=0.5, head_width=0.5, tail_width=0.2)",
        "snippet": "        def __init__(self, head_length=.5, head_width=.5, tail_width=.2):\n            \"\"\"\n            Parameters\n            ----------\n            head_length : float, optional, default : 0.5\n                Length of the arrow head\n\n            head_width : float, optional, default : 0.5\n                Width of the arrow head\n\n            tail_width : float, optional, default : 0.2\n                Width of the arrow tail\n            \"\"\"\n            self.head_length, self.head_width, self.tail_width = \\\n                head_length, head_width, tail_width\n            super().__init__()",
        "begin_line": 3650,
        "end_line": 3665,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012856775520699409,
            "pseudo_dstar_susp": 0.00013564839934888768,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00013564839934888768,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.patches.Simple.transmute#3667",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Simple",
        "signature": "lib.matplotlib.patches.Simple.transmute(self, path, mutation_size, linewidth)",
        "snippet": "        def transmute(self, path, mutation_size, linewidth):\n\n            x0, y0, x1, y1, x2, y2 = self.ensure_quadratic_bezier(path)\n\n            # divide the path into a head and a tail\n            head_length = self.head_length * mutation_size\n            in_f = inside_circle(x2, y2, head_length)\n            arrow_path = [(x0, y0), (x1, y1), (x2, y2)]\n\n            try:\n                arrow_out, arrow_in = \\\n                    split_bezier_intersecting_with_closedpath(\n                        arrow_path, in_f, tolerance=0.01)\n            except NonIntersectingPathException:\n                # if this happens, make a straight line of the head_length\n                # long.\n                x0, y0 = _point_along_a_line(x2, y2, x1, y1, head_length)\n                x1n, y1n = 0.5 * (x0 + x2), 0.5 * (y0 + y2)\n                arrow_in = [(x0, y0), (x1n, y1n), (x2, y2)]\n                arrow_out = None\n\n            # head\n            head_width = self.head_width * mutation_size\n            head_left, head_right = make_wedged_bezier2(arrow_in,\n                                                        head_width / 2., wm=.5)\n\n            # tail\n            if arrow_out is not None:\n                tail_width = self.tail_width * mutation_size\n                tail_left, tail_right = get_parallels(arrow_out,\n                                                      tail_width / 2.)\n\n                patch_path = [(Path.MOVETO, tail_right[0]),\n                              (Path.CURVE3, tail_right[1]),\n                              (Path.CURVE3, tail_right[2]),\n                              (Path.LINETO, head_right[0]),\n                              (Path.CURVE3, head_right[1]),\n                              (Path.CURVE3, head_right[2]),\n                              (Path.CURVE3, head_left[1]),\n                              (Path.CURVE3, head_left[0]),\n                              (Path.LINETO, tail_left[2]),\n                              (Path.CURVE3, tail_left[1]),\n                              (Path.CURVE3, tail_left[0]),\n                              (Path.LINETO, tail_right[0]),\n                              (Path.CLOSEPOLY, tail_right[0]),\n                              ]\n            else:\n                patch_path = [(Path.MOVETO, head_right[0]),\n                              (Path.CURVE3, head_right[1]),\n                              (Path.CURVE3, head_right[2]),\n                              (Path.CURVE3, head_left[1]),\n                              (Path.CURVE3, head_left[0]),\n                              (Path.CLOSEPOLY, head_left[0]),\n                              ]\n\n            path = Path([p for c, p in patch_path], [c for c, p in patch_path])\n\n            return path, True",
        "begin_line": 3667,
        "end_line": 3724,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012998830105290525,
            "pseudo_dstar_susp": 0.0001364815067558346,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.0001364815067558346,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.patches.Fancy.__init__#3732",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Fancy",
        "signature": "lib.matplotlib.patches.Fancy.__init__(self, head_length=0.4, head_width=0.4, tail_width=0.4)",
        "snippet": "        def __init__(self, head_length=.4, head_width=.4, tail_width=.4):\n            \"\"\"\n            Parameters\n            ----------\n            head_length : float, optional, default : 0.4\n                Length of the arrow head\n\n            head_width : float, optional, default : 0.4\n                Width of the arrow head\n\n            tail_width : float, optional, default : 0.4\n                Width of the arrow tail\n            \"\"\"\n            self.head_length, self.head_width, self.tail_width = \\\n                head_length, head_width, tail_width\n            super().__init__()",
        "begin_line": 3732,
        "end_line": 3747,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Fancy.transmute#3749",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Fancy",
        "signature": "lib.matplotlib.patches.Fancy.transmute(self, path, mutation_size, linewidth)",
        "snippet": "        def transmute(self, path, mutation_size, linewidth):\n\n            x0, y0, x1, y1, x2, y2 = self.ensure_quadratic_bezier(path)\n\n            # divide the path into a head and a tail\n            head_length = self.head_length * mutation_size\n            arrow_path = [(x0, y0), (x1, y1), (x2, y2)]\n\n            # path for head\n            in_f = inside_circle(x2, y2, head_length)\n            try:\n                path_out, path_in = split_bezier_intersecting_with_closedpath(\n                    arrow_path, in_f, tolerance=0.01)\n            except NonIntersectingPathException:\n                # if this happens, make a straight line of the head_length\n                # long.\n                x0, y0 = _point_along_a_line(x2, y2, x1, y1, head_length)\n                x1n, y1n = 0.5 * (x0 + x2), 0.5 * (y0 + y2)\n                arrow_path = [(x0, y0), (x1n, y1n), (x2, y2)]\n                path_head = arrow_path\n            else:\n                path_head = path_in\n\n            # path for head\n            in_f = inside_circle(x2, y2, head_length * .8)\n            path_out, path_in = split_bezier_intersecting_with_closedpath(\n                arrow_path, in_f, tolerance=0.01)\n            path_tail = path_out\n\n            # head\n            head_width = self.head_width * mutation_size\n            head_l, head_r = make_wedged_bezier2(path_head,\n                                                 head_width / 2.,\n                                                 wm=.6)\n\n            # tail\n            tail_width = self.tail_width * mutation_size\n            tail_left, tail_right = make_wedged_bezier2(path_tail,\n                                                        tail_width * .5,\n                                                        w1=1., wm=0.6, w2=0.3)\n\n            # path for head\n            in_f = inside_circle(x0, y0, tail_width * .3)\n            path_in, path_out = split_bezier_intersecting_with_closedpath(\n                arrow_path, in_f, tolerance=0.01)\n            tail_start = path_in[-1]\n\n            head_right, head_left = head_r, head_l\n            patch_path = [(Path.MOVETO, tail_start),\n                          (Path.LINETO, tail_right[0]),\n                          (Path.CURVE3, tail_right[1]),\n                          (Path.CURVE3, tail_right[2]),\n                          (Path.LINETO, head_right[0]),\n                          (Path.CURVE3, head_right[1]),\n                          (Path.CURVE3, head_right[2]),\n                          (Path.CURVE3, head_left[1]),\n                          (Path.CURVE3, head_left[0]),\n                          (Path.LINETO, tail_left[2]),\n                          (Path.CURVE3, tail_left[1]),\n                          (Path.CURVE3, tail_left[0]),\n                          (Path.LINETO, tail_start),\n                          (Path.CLOSEPOLY, tail_start),\n                          ]\n            path = Path([p for c, p in patch_path], [c for c, p in patch_path])\n\n            return path, True",
        "begin_line": 3749,
        "end_line": 3814,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Wedge.__init__#3824",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Wedge",
        "signature": "lib.matplotlib.patches.Wedge.__init__(self, tail_width=0.3, shrink_factor=0.5)",
        "snippet": "        def __init__(self, tail_width=.3, shrink_factor=0.5):\n            \"\"\"\n            Parameters\n            ----------\n            tail_width : float, optional, default : 0.3\n                Width of the tail\n\n            shrink_factor : float, optional, default : 0.5\n                Fraction of the arrow width at the middle point\n            \"\"\"\n            self.tail_width = tail_width\n            self.shrink_factor = shrink_factor\n            super().__init__()",
        "begin_line": 3824,
        "end_line": 3836,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.Wedge.transmute#3838",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Wedge",
        "signature": "lib.matplotlib.patches.Wedge.transmute(self, path, mutation_size, linewidth)",
        "snippet": "        def transmute(self, path, mutation_size, linewidth):\n\n            x0, y0, x1, y1, x2, y2 = self.ensure_quadratic_bezier(path)\n\n            arrow_path = [(x0, y0), (x1, y1), (x2, y2)]\n            b_plus, b_minus = make_wedged_bezier2(\n                                    arrow_path,\n                                    self.tail_width * mutation_size / 2.,\n                                    wm=self.shrink_factor)\n\n            patch_path = [(Path.MOVETO, b_plus[0]),\n                          (Path.CURVE3, b_plus[1]),\n                          (Path.CURVE3, b_plus[2]),\n                          (Path.LINETO, b_minus[2]),\n                          (Path.CURVE3, b_minus[1]),\n                          (Path.CURVE3, b_minus[0]),\n                          (Path.CLOSEPOLY, b_minus[0]),\n                          ]\n            path = Path([p for c, p in patch_path], [c for c, p in patch_path])\n\n            return path, True",
        "begin_line": 3838,
        "end_line": 3858,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.__str__#3881",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.__str__(self)",
        "snippet": "    def __str__(self):\n\n        if self._posA_posB is not None:\n            (x1, y1), (x2, y2) = self._posA_posB\n            return self.__class__.__name__ \\\n                + \"((%g, %g)->(%g, %g))\" % (x1, y1, x2, y2)\n        else:\n            return self.__class__.__name__ \\\n                + \"(%s)\" % (str(self._path_original),)",
        "begin_line": 3881,
        "end_line": 3889,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.__init__#3892",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.__init__(self, posA=None, posB=None, path=None, arrowstyle='simple', arrow_transmuter=None, connectionstyle='arc3', connector=None, patchA=None, patchB=None, shrinkA=2, shrinkB=2, mutation_scale=1, mutation_aspect=None, dpi_cor=1, **kwargs)",
        "snippet": "    def __init__(self, posA=None, posB=None,\n                 path=None,\n                 arrowstyle=\"simple\",\n                 arrow_transmuter=None,\n                 connectionstyle=\"arc3\",\n                 connector=None,\n                 patchA=None,\n                 patchB=None,\n                 shrinkA=2,\n                 shrinkB=2,\n                 mutation_scale=1,\n                 mutation_aspect=None,\n                 dpi_cor=1,\n                 **kwargs):\n        \"\"\"\n        There are two ways for defining an arrow:\n\n        - If *posA* and *posB* are given, a path connecting two points is\n          created according to *connectionstyle*. The path will be\n          clipped with *patchA* and *patchB* and further shrunken by\n          *shrinkA* and *shrinkB*. An arrow is drawn along this\n          resulting path using the *arrowstyle* parameter.\n\n        - Alternatively if *path* is provided, an arrow is drawn along this\n          path and *patchA*, *patchB*, *shrinkA*, and *shrinkB* are ignored.\n\n        Parameters\n        ----------\n        posA, posB : (float, float), optional (default: None)\n            (x, y) coordinates of arrow tail and arrow head respectively.\n\n        path : `~matplotlib.path.Path`, optional (default: None)\n            If provided, an arrow is drawn along this path and *patchA*,\n            *patchB*, *shrinkA*, and *shrinkB* are ignored.\n\n        arrowstyle : str or `.ArrowStyle`, optional (default: 'simple')\n            Describes how the fancy arrow will be\n            drawn. It can be string of the available arrowstyle names,\n            with optional comma-separated attributes, or an\n            :class:`ArrowStyle` instance. The optional attributes are meant to\n            be scaled with the *mutation_scale*. The following arrow styles are\n            available:\n\n            %(AvailableArrowstyles)s\n\n        arrow_transmuter\n            Ignored.\n\n        connectionstyle : str or `.ConnectionStyle` or None, optional \\\n(default: 'arc3')\n            Describes how *posA* and *posB* are connected. It can be an\n            instance of the :class:`ConnectionStyle` class or a string of the\n            connectionstyle name, with optional comma-separated attributes. The\n            following connection styles are available:\n\n            %(AvailableConnectorstyles)s\n\n        connector\n            Ignored.\n\n        patchA, patchB : `.Patch`, optional (default: None)\n            Head and tail patch respectively. :class:`matplotlib.patch.Patch`\n            instance.\n\n        shrinkA, shrinkB : float, optional (default: 2)\n            Shrinking factor of the tail and head of the arrow respectively.\n\n        mutation_scale : float, optional (default: 1)\n            Value with which attributes of *arrowstyle* (e.g., *head_length*)\n            will be scaled.\n\n        mutation_aspect : None or float, optional (default: None)\n            The height of the rectangle will be squeezed by this value before\n            the mutation and the mutated box will be stretched by the inverse\n            of it.\n\n        dpi_cor : float, optional (default: 1)\n            dpi_cor is currently used for linewidth-related things and shrink\n            factor. Mutation scale is affected by this.\n\n        Other Parameters\n        ----------------\n        **kwargs : `.Patch` properties, optional\n            Here is a list of available `.Patch` properties:\n\n        %(Patch)s\n\n            In contrast to other patches, the default ``capstyle`` and\n            ``joinstyle`` for `FancyArrowPatch` are set to ``\"round\"``.\n        \"\"\"\n        if arrow_transmuter is not None:\n            cbook.warn_deprecated(\n                3.0,\n                message=('The \"arrow_transmuter\" keyword argument is not used,'\n                         ' and will be removed in Matplotlib 3.1'),\n                name='arrow_transmuter',\n                obj_type='keyword argument')\n        if connector is not None:\n            cbook.warn_deprecated(\n                3.0,\n                message=('The \"connector\" keyword argument is not used,'\n                         ' and will be removed in Matplotlib 3.1'),\n                name='connector',\n                obj_type='keyword argument')\n        # Traditionally, the cap- and joinstyle for FancyArrowPatch are round\n        kwargs.setdefault(\"joinstyle\", \"round\")\n        kwargs.setdefault(\"capstyle\", \"round\")\n\n        Patch.__init__(self, **kwargs)\n\n        if posA is not None and posB is not None and path is None:\n            self._posA_posB = [posA, posB]\n\n            if connectionstyle is None:\n                connectionstyle = \"arc3\"\n            self.set_connectionstyle(connectionstyle)\n\n        elif posA is None and posB is None and path is not None:\n            self._posA_posB = None\n        else:\n            raise ValueError(\"either posA and posB, or path need to provided\")\n\n        self.patchA = patchA\n        self.patchB = patchB\n        self.shrinkA = shrinkA\n        self.shrinkB = shrinkB\n\n        self._path_original = path\n\n        self.set_arrowstyle(arrowstyle)\n\n        self._mutation_scale = mutation_scale\n        self._mutation_aspect = mutation_aspect\n\n        self.set_dpi_cor(dpi_cor)",
        "begin_line": 3892,
        "end_line": 4026,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013702384214853386,
            "pseudo_dstar_susp": 0.00016733601070950468,
            "pseudo_tarantula_susp": 0.00012553351744915893,
            "pseudo_op2_susp": 0.00016733601070950468,
            "pseudo_barinel_susp": 0.00012553351744915893
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.set_dpi_cor#4028",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.set_dpi_cor(self, dpi_cor)",
        "snippet": "    def set_dpi_cor(self, dpi_cor):\n        \"\"\"\n        dpi_cor is currently used for linewidth-related things and\n        shrink factor. Mutation scale is affected by this.\n\n        Parameters\n        ----------\n        dpi_cor : scalar\n        \"\"\"\n        self._dpi_cor = dpi_cor\n        self.stale = True",
        "begin_line": 4028,
        "end_line": 4038,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00016733601070950468,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00016733601070950468,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.get_dpi_cor#4040",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.get_dpi_cor(self)",
        "snippet": "    def get_dpi_cor(self):\n        \"\"\"\n        dpi_cor is currently used for linewidth-related things and\n        shrink factor. Mutation scale is affected by this.\n\n        Returns\n        -------\n        dpi_cor : scalar\n        \"\"\"\n        return self._dpi_cor",
        "begin_line": 4040,
        "end_line": 4049,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00016784155756965425,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00016784155756965425,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.set_positions#4051",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.set_positions(self, posA, posB)",
        "snippet": "    def set_positions(self, posA, posB):\n        \"\"\"\n        Set the begin and end positions of the connecting path.\n\n        Parameters\n        ----------\n        posA, posB : None, tuple\n            (x, y) coordinates of arrow tail and arrow head respectively. If\n            `None` use current value.\n        \"\"\"\n        if posA is not None:\n            self._posA_posB[0] = posA\n        if posB is not None:\n            self._posA_posB[1] = posB\n        self.stale = True",
        "begin_line": 4051,
        "end_line": 4065,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00016028209648982208,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00016028209648982208,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.set_patchA#4067",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.set_patchA(self, patchA)",
        "snippet": "    def set_patchA(self, patchA):\n        \"\"\"\n        Set the tail patch.\n\n        Parameters\n        ----------\n        patchA : Patch\n            :class:`matplotlib.patch.Patch` instance.\n        \"\"\"\n        self.patchA = patchA\n        self.stale = True",
        "begin_line": 4067,
        "end_line": 4077,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00016028209648982208,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00016028209648982208,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.set_connectionstyle#4091",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.set_connectionstyle(self, connectionstyle, **kw)",
        "snippet": "    def set_connectionstyle(self, connectionstyle, **kw):\n        \"\"\"\n        Set the connection style. Old attributes are forgotten.\n\n        Parameters\n        ----------\n        connectionstyle : str or `.ConnectionStyle` or None, optional\n            Can be a string with connectionstyle name with\n            optional comma-separated attributes, e.g.::\n\n                set_connectionstyle(\"arc,angleA=0,armA=30,rad=10\")\n\n            Alternatively, the attributes can be provided as keywords, e.g.::\n\n                set_connectionstyle(\"arc\", angleA=0,armA=30,rad=10)\n\n            Without any arguments (or with ``connectionstyle=None``), return\n            available styles as a list of strings.\n        \"\"\"\n\n        if connectionstyle is None:\n            return ConnectionStyle.pprint_styles()\n\n        if (isinstance(connectionstyle, ConnectionStyle._Base) or\n                callable(connectionstyle)):\n            self._connector = connectionstyle\n        else:\n            self._connector = ConnectionStyle(connectionstyle, **kw)\n        self.stale = True",
        "begin_line": 4091,
        "end_line": 4119,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00016784155756965425,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00016784155756965425,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.get_connectionstyle#4121",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.get_connectionstyle(self)",
        "snippet": "    def get_connectionstyle(self):\n        \"\"\"\n        Return the :class:`ConnectionStyle` instance.\n        \"\"\"\n        return self._connector",
        "begin_line": 4121,
        "end_line": 4125,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00016784155756965425,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00016784155756965425,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.set_arrowstyle#4127",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.set_arrowstyle(self, arrowstyle=None, **kw)",
        "snippet": "    def set_arrowstyle(self, arrowstyle=None, **kw):\n        \"\"\"\n        Set the arrow style. Old attributes are forgotten. Without arguments\n        (or with ``arrowstyle=None``) returns available box styles as a list of\n        strings.\n\n        Parameters\n        ----------\n        arrowstyle : None, ArrowStyle, str, optional (default: None)\n            Can be a string with arrowstyle name with optional comma-separated\n            attributes, e.g.::\n\n                set_arrowstyle(\"Fancy,head_length=0.2\")\n\n            Alternatively attributes can be provided as keywords, e.g.::\n\n                set_arrowstyle(\"fancy\", head_length=0.2)\n\n        \"\"\"\n\n        if arrowstyle is None:\n            return ArrowStyle.pprint_styles()\n\n        if isinstance(arrowstyle, ArrowStyle._Base):\n            self._arrow_transmuter = arrowstyle\n        else:\n            self._arrow_transmuter = ArrowStyle(arrowstyle, **kw)\n        self.stale = True",
        "begin_line": 4127,
        "end_line": 4154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00016733601070950468,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00016733601070950468,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.get_arrowstyle#4156",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.get_arrowstyle(self)",
        "snippet": "    def get_arrowstyle(self):\n        \"\"\"\n        Return the arrowstyle object.\n        \"\"\"\n        return self._arrow_transmuter",
        "begin_line": 4156,
        "end_line": 4160,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00016784155756965425,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00016784155756965425,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.set_mutation_scale#4162",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.set_mutation_scale(self, scale)",
        "snippet": "    def set_mutation_scale(self, scale):\n        \"\"\"\n        Set the mutation scale.\n\n        Parameters\n        ----------\n        scale : scalar\n        \"\"\"\n        self._mutation_scale = scale\n        self.stale = True",
        "begin_line": 4162,
        "end_line": 4171,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00016028209648982208,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00016028209648982208,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.get_mutation_scale#4173",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.get_mutation_scale(self)",
        "snippet": "    def get_mutation_scale(self):\n        \"\"\"\n        Return the mutation scale.\n\n        Returns\n        -------\n        scale : scalar\n        \"\"\"\n        return self._mutation_scale",
        "begin_line": 4173,
        "end_line": 4181,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00016784155756965425,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00016784155756965425,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.get_mutation_aspect#4194",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.get_mutation_aspect(self)",
        "snippet": "    def get_mutation_aspect(self):\n        \"\"\"\n        Return the aspect ratio of the bbox mutation.\n        \"\"\"\n        return self._mutation_aspect",
        "begin_line": 4194,
        "end_line": 4198,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001356300013563,
            "pseudo_dstar_susp": 0.00013766519823788548,
            "pseudo_tarantula_susp": 0.00018218254691200583,
            "pseudo_op2_susp": 0.00013766519823788548,
            "pseudo_barinel_susp": 0.00018218254691200583
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.get_path_in_displaycoord#4211",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.get_path_in_displaycoord(self)",
        "snippet": "    def get_path_in_displaycoord(self):\n        \"\"\"\n        Return the mutated path of the arrow in display coordinates.\n        \"\"\"\n\n        dpi_cor = self.get_dpi_cor()\n\n        if self._posA_posB is not None:\n            posA = self._convert_xy_units(self._posA_posB[0])\n            posB = self._convert_xy_units(self._posA_posB[1])\n            (posA, posB) = self.get_transform().transform((posA, posB))\n            _path = self.get_connectionstyle()(posA, posB,\n                                               patchA=self.patchA,\n                                               patchB=self.patchB,\n                                               shrinkA=self.shrinkA * dpi_cor,\n                                               shrinkB=self.shrinkB * dpi_cor\n                                               )\n        else:\n            _path = self.get_transform().transform_path(self._path_original)\n\n        _path, fillable = self.get_arrowstyle()(\n            _path,\n            self.get_mutation_scale() * dpi_cor,\n            self.get_linewidth() * dpi_cor,\n            self.get_mutation_aspect())\n\n        # if not fillable:\n        #    self._fill = False\n\n        return _path, fillable",
        "begin_line": 4211,
        "end_line": 4240,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00014104372355430183,
            "pseudo_dstar_susp": 0.00016871941960519654,
            "pseudo_tarantula_susp": 0.00013345789403443215,
            "pseudo_op2_susp": 0.00016871941960519654,
            "pseudo_barinel_susp": 0.00013338668800853674
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.draw#4242",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        if not self.get_visible():\n            return\n\n        with self._bind_draw_path_function(renderer) as draw_path:\n\n            # FIXME : dpi_cor is for the dpi-dependency of the linewidth. There\n            # could be room for improvement.\n            self.set_dpi_cor(renderer.points_to_pixels(1.))\n            path, fillable = self.get_path_in_displaycoord()\n\n            if not np.iterable(fillable):\n                path = [path]\n                fillable = [fillable]\n\n            affine = transforms.IdentityTransform()\n\n            for p, f in zip(path, fillable):\n                draw_path(\n                    p, affine,\n                    self._facecolor if f and self._facecolor[3] else None)",
        "begin_line": 4242,
        "end_line": 4262,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00016911889058007779,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00016911889058007779,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.patches.ConnectionPatch.__str__#4270",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.ConnectionPatch",
        "signature": "lib.matplotlib.patches.ConnectionPatch.__str__(self)",
        "snippet": "    def __str__(self):\n        return \"ConnectionPatch((%g, %g), (%g, %g))\" % \\\n               (self.xy1[0], self.xy1[1], self.xy2[0], self.xy2[1])",
        "begin_line": 4270,
        "end_line": 4272,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.ConnectionPatch.__init__#4275",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.ConnectionPatch",
        "signature": "lib.matplotlib.patches.ConnectionPatch.__init__(self, xyA, xyB, coordsA, coordsB=None, axesA=None, axesB=None, arrowstyle='-', arrow_transmuter=None, connectionstyle='arc3', connector=None, patchA=None, patchB=None, shrinkA=0.0, shrinkB=0.0, mutation_scale=10.0, mutation_aspect=None, clip_on=False, dpi_cor=1.0, **kwargs)",
        "snippet": "    def __init__(self, xyA, xyB, coordsA, coordsB=None,\n                 axesA=None, axesB=None,\n                 arrowstyle=\"-\",\n                 arrow_transmuter=None,\n                 connectionstyle=\"arc3\",\n                 connector=None,\n                 patchA=None,\n                 patchB=None,\n                 shrinkA=0.,\n                 shrinkB=0.,\n                 mutation_scale=10.,\n                 mutation_aspect=None,\n                 clip_on=False,\n                 dpi_cor=1.,\n                 **kwargs):\n        \"\"\"Connect point *xyA* in *coordsA* with point *xyB* in *coordsB*\n\n        Valid keys are\n\n        ===============  ======================================================\n        Key              Description\n        ===============  ======================================================\n        arrowstyle       the arrow style\n        connectionstyle  the connection style\n        relpos           default is (0.5, 0.5)\n        patchA           default is bounding box of the text\n        patchB           default is None\n        shrinkA          default is 2 points\n        shrinkB          default is 2 points\n        mutation_scale   default is text size (in points)\n        mutation_aspect  default is 1.\n        ?                any key for :class:`matplotlib.patches.PathPatch`\n        ===============  ======================================================\n\n        *coordsA* and *coordsB* are strings that indicate the\n        coordinates of *xyA* and *xyB*.\n\n        =================  ===================================================\n        Property           Description\n        =================  ===================================================\n        'figure points'    points from the lower left corner of the figure\n        'figure pixels'    pixels from the lower left corner of the figure\n        'figure fraction'  0, 0 is lower left of figure and 1, 1 is upper right\n        'axes points'      points from lower left corner of axes\n        'axes pixels'      pixels from lower left corner of axes\n        'axes fraction'    0, 1 is lower left of axes and 1, 1 is upper right\n        'data'             use the coordinate system of the object being\n                           annotated (default)\n        'offset points'    offset (in points) from the *xy* value\n        'polar'            you can specify *theta*, *r* for the annotation,\n                           even in cartesian plots.  Note that if you are using\n                           a polar axes, you do not need to specify polar for\n                           the coordinate system since that is the native\n                           \"data\" coordinate system.\n        =================  ===================================================\n\n        Alternatively they can be set to any valid\n        `~matplotlib.transforms.Transform`.\n\n        .. note::\n\n           Using :class:`~matplotlib.patches.ConnectionPatch` across\n           two :class:`~matplotlib.axes.Axes` instances is not\n           directly compatible with :doc:`constrained layout\n           </tutorials/intermediate/constrainedlayout_guide>`. Add the\n           artist directly to the :class:`~matplotlib.figure.Figure`\n           instead of adding it to a specific Axes.\n\n           .. code-block:: default\n\n              fig, ax = plt.subplots(1, 2, constrained_layout=True)\n              con = ConnectionPatch(..., axesA=ax[0], axesB=ax[1])\n              fig.add_artist(con)\n\n        \"\"\"\n        if coordsB is None:\n            coordsB = coordsA\n        # we'll draw ourself after the artist we annotate by default\n        self.xy1 = xyA\n        self.xy2 = xyB\n        self.coords1 = coordsA\n        self.coords2 = coordsB\n\n        self.axesA = axesA\n        self.axesB = axesB\n\n        FancyArrowPatch.__init__(self,\n                                 posA=(0, 0), posB=(1, 1),\n                                 arrowstyle=arrowstyle,\n                                 arrow_transmuter=arrow_transmuter,\n                                 connectionstyle=connectionstyle,\n                                 connector=connector,\n                                 patchA=patchA,\n                                 patchB=patchB,\n                                 shrinkA=shrinkA,\n                                 shrinkB=shrinkB,\n                                 mutation_scale=mutation_scale,\n                                 mutation_aspect=mutation_aspect,\n                                 clip_on=clip_on,\n                                 dpi_cor=dpi_cor,\n                                 **kwargs)\n\n        # if True, draw annotation only if self.xy is inside the axes\n        self._annotation_clip = None",
        "begin_line": 4275,
        "end_line": 4378,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.ConnectionPatch._get_xy#4380",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.ConnectionPatch",
        "signature": "lib.matplotlib.patches.ConnectionPatch._get_xy(self, x, y, s, axes=None)",
        "snippet": "    def _get_xy(self, x, y, s, axes=None):\n        \"\"\"Calculate the pixel position of given point.\"\"\"\n        if axes is None:\n            axes = self.axes\n\n        if s == 'data':\n            trans = axes.transData\n            x = float(self.convert_xunits(x))\n            y = float(self.convert_yunits(y))\n            return trans.transform((x, y))\n        elif s == 'offset points':\n            # convert the data point\n            dx, dy = self.xy\n\n            # prevent recursion\n            if self.xycoords == 'offset points':\n                return self._get_xy(dx, dy, 'data')\n\n            dx, dy = self._get_xy(dx, dy, self.xycoords)\n\n            # convert the offset\n            dpi = self.figure.get_dpi()\n            x *= dpi / 72.\n            y *= dpi / 72.\n\n            # add the offset to the data point\n            x += dx\n            y += dy\n\n            return x, y\n        elif s == 'polar':\n            theta, r = x, y\n            x = r * np.cos(theta)\n            y = r * np.sin(theta)\n            trans = axes.transData\n            return trans.transform((x, y))\n        elif s == 'figure points':\n            # points from the lower left corner of the figure\n            dpi = self.figure.dpi\n            l, b, w, h = self.figure.bbox.bounds\n            r = l + w\n            t = b + h\n\n            x *= dpi / 72.\n            y *= dpi / 72.\n            if x < 0:\n                x = r + x\n            if y < 0:\n                y = t + y\n            return x, y\n        elif s == 'figure pixels':\n            # pixels from the lower left corner of the figure\n            l, b, w, h = self.figure.bbox.bounds\n            r = l + w\n            t = b + h\n            if x < 0:\n                x = r + x\n            if y < 0:\n                y = t + y\n            return x, y\n        elif s == 'figure fraction':\n            # (0, 0) is lower left, (1, 1) is upper right of figure\n            trans = self.figure.transFigure\n            return trans.transform((x, y))\n        elif s == 'axes points':\n            # points from the lower left corner of the axes\n            dpi = self.figure.dpi\n            l, b, w, h = axes.bbox.bounds\n            r = l + w\n            t = b + h\n            if x < 0:\n                x = r + x * dpi / 72.\n            else:\n                x = l + x * dpi / 72.\n            if y < 0:\n                y = t + y * dpi / 72.\n            else:\n                y = b + y * dpi / 72.\n            return x, y\n        elif s == 'axes pixels':\n            # pixels from the lower left corner of the axes\n            l, b, w, h = axes.bbox.bounds\n            r = l + w\n            t = b + h\n            if x < 0:\n                x = r + x\n            else:\n                x = l + x\n            if y < 0:\n                y = t + y\n            else:\n                y = b + y\n            return x, y\n        elif s == 'axes fraction':\n            # (0, 0) is lower left, (1, 1) is upper right of axes\n            trans = axes.transAxes\n            return trans.transform((x, y))\n        elif isinstance(s, transforms.Transform):\n            return s.transform((x, y))\n        else:\n            raise ValueError(\"{} is not a valid coordinate \"\n                             \"transformation.\".format(s))",
        "begin_line": 4380,
        "end_line": 4481,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.ConnectionPatch.get_annotation_clip#4501",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.ConnectionPatch",
        "signature": "lib.matplotlib.patches.ConnectionPatch.get_annotation_clip(self)",
        "snippet": "    def get_annotation_clip(self):\n        \"\"\"\n        Return the clipping behavior.\n\n        See `.set_annotation_clip` for the meaning of the return value.\n        \"\"\"\n        return self._annotation_clip",
        "begin_line": 4501,
        "end_line": 4507,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.ConnectionPatch.get_path_in_displaycoord#4509",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.ConnectionPatch",
        "signature": "lib.matplotlib.patches.ConnectionPatch.get_path_in_displaycoord(self)",
        "snippet": "    def get_path_in_displaycoord(self):\n        \"\"\"Return the mutated path of the arrow in display coordinates.\"\"\"\n\n        dpi_cor = self.get_dpi_cor()\n\n        x, y = self.xy1\n        posA = self._get_xy(x, y, self.coords1, self.axesA)\n\n        x, y = self.xy2\n        posB = self._get_xy(x, y, self.coords2, self.axesB)\n\n        _path = self.get_connectionstyle()(posA, posB,\n                                           patchA=self.patchA,\n                                           patchB=self.patchB,\n                                           shrinkA=self.shrinkA * dpi_cor,\n                                           shrinkB=self.shrinkB * dpi_cor\n                                           )\n\n        _path, fillable = self.get_arrowstyle()(\n                                        _path,\n                                        self.get_mutation_scale() * dpi_cor,\n                                        self.get_linewidth() * dpi_cor,\n                                        self.get_mutation_aspect()\n                                        )\n\n        return _path, fillable",
        "begin_line": 4509,
        "end_line": 4534,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.ConnectionPatch._check_xy#4536",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.ConnectionPatch",
        "signature": "lib.matplotlib.patches.ConnectionPatch._check_xy(self, renderer)",
        "snippet": "    def _check_xy(self, renderer):\n        \"\"\"Check whether the annotation needs to be drawn.\"\"\"\n\n        b = self.get_annotation_clip()\n\n        if b or (b is None and self.coords1 == \"data\"):\n            x, y = self.xy1\n            xy_pixel = self._get_xy(x, y, self.coords1, self.axesA)\n            if self.axesA is None:\n                axes = self.axes\n            else:\n                axes = self.axesA\n            if not axes.contains_point(xy_pixel):\n                return False\n\n        if b or (b is None and self.coords2 == \"data\"):\n            x, y = self.xy2\n            xy_pixel = self._get_xy(x, y, self.coords2, self.axesB)\n            if self.axesB is None:\n                axes = self.axes\n            else:\n                axes = self.axesB\n            if not axes.contains_point(xy_pixel):\n                return False\n\n        return True",
        "begin_line": 4536,
        "end_line": 4561,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.patches.ConnectionPatch.draw#4563",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.ConnectionPatch",
        "signature": "lib.matplotlib.patches.ConnectionPatch.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        if renderer is not None:\n            self._renderer = renderer\n        if not self.get_visible() or not self._check_xy(renderer):\n            return\n        FancyArrowPatch.draw(self, renderer)",
        "begin_line": 4563,
        "end_line": 4568,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.category.StrCategoryConverter.convert#28",
        "src_path": "lib/matplotlib/category.py",
        "class_name": "lib.matplotlib.category.StrCategoryConverter",
        "signature": "lib.matplotlib.category.StrCategoryConverter.convert(value, unit, axis)",
        "snippet": "    def convert(value, unit, axis):\n        \"\"\"\n        Convert strings in *value* to floats using mapping information stored\n        in the *unit* object.\n\n        Parameters\n        ----------\n        value : str or iterable\n            Value or list of values to be converted.\n        unit : `.UnitData`\n            An object mapping strings to integers.\n        axis : `~matplotlib.axis.Axis`\n            The axis on which the converted value is plotted.\n\n            .. note:: *axis* is unused.\n\n        Returns\n        -------\n        mapped_value : float or ndarray[float]\n        \"\"\"\n        if unit is None:\n            raise ValueError(\n                'Missing category information for StrCategoryConverter; '\n                'this might be caused by unintendedly mixing categorical and '\n                'numeric data')\n        # dtype = object preserves numerical pass throughs\n        values = np.atleast_1d(np.array(value, dtype=object))\n        # pass through sequence of non binary numbers\n        if all(units.ConversionInterface.is_numlike(v)\n               and not isinstance(v, (str, bytes))\n               for v in values):\n            return np.asarray(values, dtype=float)\n        # force an update so it also does type checking\n        unit.update(values)\n        return np.vectorize(unit._mapping.__getitem__, otypes=[float])(values)",
        "begin_line": 28,
        "end_line": 62,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.605141075366947e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.category.StrCategoryConverter.axisinfo#65",
        "src_path": "lib/matplotlib/category.py",
        "class_name": "lib.matplotlib.category.StrCategoryConverter",
        "signature": "lib.matplotlib.category.StrCategoryConverter.axisinfo(unit, axis)",
        "snippet": "    def axisinfo(unit, axis):\n        \"\"\"\n        Set the default axis ticks and labels.\n\n        Parameters\n        ----------\n        unit : `.UnitData`\n            object string unit information for value\n        axis : `~matplotlib.axis.Axis`\n            axis for which information is being set\n\n        Returns\n        -------\n        axisinfo : `~matplotlib.units.AxisInfo`\n            Information to support default tick labeling\n\n        .. note: axis is not used\n        \"\"\"\n        # locator and formatter take mapping dict because\n        # args need to be pass by reference for updates\n        majloc = StrCategoryLocator(unit._mapping)\n        majfmt = StrCategoryFormatter(unit._mapping)\n        return units.AxisInfo(majloc=majloc, majfmt=majfmt)",
        "begin_line": 65,
        "end_line": 87,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.590708972218005e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.category.StrCategoryLocator.__init__#115",
        "src_path": "lib/matplotlib/category.py",
        "class_name": "lib.matplotlib.category.StrCategoryLocator",
        "signature": "lib.matplotlib.category.StrCategoryLocator.__init__(self, units_mapping)",
        "snippet": "    def __init__(self, units_mapping):\n        \"\"\"\n        Parameters\n        -----------\n        units_mapping : Dict[str, int]\n        \"\"\"\n        self._units = units_mapping",
        "begin_line": 115,
        "end_line": 121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.601672367920942e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.category.UnitData.__init__#158",
        "src_path": "lib/matplotlib/category.py",
        "class_name": "lib.matplotlib.category.UnitData",
        "signature": "lib.matplotlib.category.UnitData.__init__(self, data=None)",
        "snippet": "    def __init__(self, data=None):\n        \"\"\"\n        Create mapping between unique categorical values and integer ids.\n\n        Parameters\n        ----------\n        data : iterable\n            sequence of string values\n        \"\"\"\n        self._mapping = OrderedDict()\n        self._counter = itertools.count()\n        if data is not None:\n            self.update(data)",
        "begin_line": 158,
        "end_line": 170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.583801001061732e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.category.UnitData._str_is_convertible#173",
        "src_path": "lib/matplotlib/category.py",
        "class_name": "lib.matplotlib.category.UnitData",
        "signature": "lib.matplotlib.category.UnitData._str_is_convertible(val)",
        "snippet": "    def _str_is_convertible(val):\n        \"\"\"\n        Helper method to check whether a string can be parsed as float or date.\n        \"\"\"\n        try:\n            float(val)\n        except ValueError:\n            try:\n                dateutil.parser.parse(val)\n            except (ValueError, TypeError):\n                # TypeError if dateutil >= 2.8.1 else ValueError\n                return False\n        return True",
        "begin_line": 173,
        "end_line": 185,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.635336336565625e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.category.UnitData.update#187",
        "src_path": "lib/matplotlib/category.py",
        "class_name": "lib.matplotlib.category.UnitData",
        "signature": "lib.matplotlib.category.UnitData.update(self, data)",
        "snippet": "    def update(self, data):\n        \"\"\"\n        Map new values to integer identifiers.\n\n        Parameters\n        ----------\n        data : iterable\n            sequence of string values\n\n        Raises\n        ------\n        TypeError\n              If the value in data is not a string, unicode, bytes type\n        \"\"\"\n        data = np.atleast_1d(np.array(data, dtype=object))\n\n        # check if convertible to number:\n        convertible = True\n        for val in OrderedDict.fromkeys(data):\n            # OrderedDict just iterates over unique values in data.\n            cbook._check_isinstance((str, bytes), value=val)\n            if convertible:\n                # this will only be called so long as convertible is True.\n                convertible = self._str_is_convertible(val)\n            if val not in self._mapping:\n                self._mapping[val] = next(self._counter)\n        if convertible:\n            _log.info('Using categorical units to plot a list of strings '\n                      'that are all parsable as floats or dates. If these '\n                      'strings should be plotted as numbers, cast to the '\n                      'appropriate data type before plotting.')",
        "begin_line": 187,
        "end_line": 217,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.633587786259542e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.get_hinting_flag#55",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg",
        "signature": "lib.matplotlib.backends.backend_agg.get_hinting_flag()",
        "snippet": "def get_hinting_flag():\n    mapping = {\n        True: LOAD_FORCE_AUTOHINT,\n        False: LOAD_NO_HINTING,\n        'either': LOAD_DEFAULT,\n        'native': LOAD_NO_AUTOHINT,\n        'auto': LOAD_FORCE_AUTOHINT,\n        'none': LOAD_NO_HINTING\n        }\n    return mapping[rcParams['text.hinting']]",
        "begin_line": 55,
        "end_line": 64,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.021739130434782608,
            "pseudo_dstar_susp": 0.017241379310344827,
            "pseudo_tarantula_susp": 0.00035423308537017357,
            "pseudo_op2_susp": 0.017241379310344827,
            "pseudo_barinel_susp": 0.00035423308537017357
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.RendererAgg.__init__#86",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.RendererAgg",
        "signature": "lib.matplotlib.backends.backend_agg.RendererAgg.__init__(self, width, height, dpi)",
        "snippet": "    def __init__(self, width, height, dpi):\n        RendererBase.__init__(self)\n\n        self.dpi = dpi\n        self.width = width\n        self.height = height\n        self._renderer = _RendererAgg(int(width), int(height), dpi)\n        self._filter_renderers = []\n\n        self._update_methods()\n        self.mathtext_parser = MathTextParser('Agg')\n\n        self.bbox = Bbox.from_bounds(0, 0, self.width, self.height)",
        "begin_line": 86,
        "end_line": 98,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.058823529411764705,
            "pseudo_dstar_susp": 0.02631578947368421,
            "pseudo_tarantula_susp": 0.00043782837127845885,
            "pseudo_op2_susp": 0.02631578947368421,
            "pseudo_barinel_susp": 0.00043782837127845885
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.RendererAgg._update_methods#108",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.RendererAgg",
        "signature": "lib.matplotlib.backends.backend_agg.RendererAgg._update_methods(self)",
        "snippet": "    def _update_methods(self):\n        self.draw_gouraud_triangle = self._renderer.draw_gouraud_triangle\n        self.draw_gouraud_triangles = self._renderer.draw_gouraud_triangles\n        self.draw_image = self._renderer.draw_image\n        self.draw_markers = self._renderer.draw_markers\n        self.draw_path_collection = self._renderer.draw_path_collection\n        self.draw_quad_mesh = self._renderer.draw_quad_mesh\n        self.copy_from_bbox = self._renderer.copy_from_bbox\n        self.get_content_extents = self._renderer.get_content_extents",
        "begin_line": 108,
        "end_line": 116,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.013513513513513514,
            "pseudo_dstar_susp": 0.038461538461538464,
            "pseudo_tarantula_susp": 0.00040567951318458417,
            "pseudo_op2_susp": 0.038461538461538464,
            "pseudo_barinel_susp": 0.00040567951318458417
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.RendererAgg.tostring_rgba_minimized#118",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.RendererAgg",
        "signature": "lib.matplotlib.backends.backend_agg.RendererAgg.tostring_rgba_minimized(self)",
        "snippet": "    def tostring_rgba_minimized(self):\n        extents = self.get_content_extents()\n        bbox = [[extents[0], self.height - (extents[1] + extents[3])],\n                [extents[0] + extents[2], self.height - extents[1]]]\n        region = self.copy_from_bbox(bbox)\n        return np.array(region), extents",
        "begin_line": 118,
        "end_line": 123,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019916351324437363,
            "pseudo_dstar_susp": 0.00016353229762878168,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00016353229762878168,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path#125",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.RendererAgg",
        "signature": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path(self, gc, path, transform, rgbFace=None)",
        "snippet": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        nmax = rcParams['agg.path.chunksize']  # here at least for testing\n        npts = path.vertices.shape[0]\n\n        if (nmax > 100 and npts > nmax and path.should_simplify and\n                rgbFace is None and gc.get_hatch() is None):\n            nch = np.ceil(npts / nmax)\n            chsize = int(np.ceil(npts / nch))\n            i0 = np.arange(0, npts, chsize)\n            i1 = np.zeros_like(i0)\n            i1[:-1] = i0[1:] - 1\n            i1[-1] = npts\n            for ii0, ii1 in zip(i0, i1):\n                v = path.vertices[ii0:ii1, :]\n                c = path.codes\n                if c is not None:\n                    c = c[ii0:ii1]\n                    c[0] = Path.MOVETO  # move to end of last chunk\n                p = Path(v, c)\n                try:\n                    self._renderer.draw_path(gc, p, transform, rgbFace)\n                except OverflowError:\n                    raise OverflowError(\"Exceeded cell block limit (set \"\n                                        \"'agg.path.chunksize' rcparam)\")\n        else:\n            try:\n                self._renderer.draw_path(gc, path, transform, rgbFace)\n            except OverflowError:\n                raise OverflowError(\"Exceeded cell block limit (set \"\n                                    \"'agg.path.chunksize' rcparam)\")",
        "begin_line": 125,
        "end_line": 155,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.018518518518518517,
            "pseudo_dstar_susp": 0.022727272727272728,
            "pseudo_tarantula_susp": 0.0003289473684210526,
            "pseudo_op2_susp": 0.022727272727272728,
            "pseudo_barinel_susp": 0.0003289473684210526
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext#157",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.RendererAgg",
        "signature": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext(self, gc, x, y, s, prop, angle)",
        "snippet": "    def draw_mathtext(self, gc, x, y, s, prop, angle):\n        \"\"\"\n        Draw the math text using matplotlib.mathtext\n        \"\"\"\n        ox, oy, width, height, descent, font_image, used_characters = \\\n            self.mathtext_parser.parse(s, self.dpi, prop)\n\n        xd = descent * sin(radians(angle))\n        yd = descent * cos(radians(angle))\n        x = round(x + ox + xd)\n        y = round(y - oy + yd)\n        self._renderer.draw_text_image(font_image, x, y + 1, angle, gc)",
        "begin_line": 157,
        "end_line": 168,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.03225806451612903,
            "pseudo_dstar_susp": 0.013157894736842105,
            "pseudo_tarantula_susp": 0.0004873294346978557,
            "pseudo_op2_susp": 0.013157894736842105,
            "pseudo_barinel_susp": 0.0004873294346978557
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text#170",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.RendererAgg",
        "signature": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None)",
        "snippet": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        if ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        flags = get_hinting_flag()\n        font = self._get_agg_font(prop)\n\n        if font is None:\n            return None\n        # We pass '0' for angle here, since it will be rotated (in raster\n        # space) in the following call to draw_text_image).\n        font.set_text(s, 0, flags=flags)\n        font.draw_glyphs_to_bitmap(antialiased=rcParams['text.antialiased'])\n        d = font.get_descent() / 64.0\n        # The descent needs to be adjusted for the angle.\n        xo, yo = font.get_bitmap_offset()\n        xo /= 64.0\n        yo /= 64.0\n        xd = d * sin(radians(angle))\n        yd = d * cos(radians(angle))\n        x = round(x + xo + xd)\n        y = round(y + yo + yd)\n        self._renderer.draw_text_image(font, x, y + 1, angle, gc)",
        "begin_line": 170,
        "end_line": 194,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02857142857142857,
            "pseudo_dstar_susp": 0.016666666666666666,
            "pseudo_tarantula_susp": 0.0005167958656330749,
            "pseudo_op2_susp": 0.016666666666666666,
            "pseudo_barinel_susp": 0.0005167958656330749
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.RendererAgg.get_text_width_height_descent#196",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.RendererAgg",
        "signature": "lib.matplotlib.backends.backend_agg.RendererAgg.get_text_width_height_descent(self, s, prop, ismath)",
        "snippet": "    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n\n        if ismath in [\"TeX\", \"TeX!\"]:\n            # todo: handle props\n            texmanager = self.get_texmanager()\n            fontsize = prop.get_size_in_points()\n            w, h, d = texmanager.get_text_width_height_descent(\n                s, fontsize, renderer=self)\n            return w, h, d\n\n        if ismath:\n            ox, oy, width, height, descent, fonts, used_characters = \\\n                self.mathtext_parser.parse(s, self.dpi, prop)\n            return width, height, descent\n\n        flags = get_hinting_flag()\n        font = self._get_agg_font(prop)\n        font.set_text(s, 0.0, flags=flags)\n        w, h = font.get_width_height()  # width and height of unrotated string\n        d = font.get_descent()\n        w /= 64.0  # convert from subpixels\n        h /= 64.0\n        d /= 64.0\n        return w, h, d",
        "begin_line": 196,
        "end_line": 220,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.013888888888888888,
            "pseudo_dstar_susp": 0.012658227848101266,
            "pseudo_tarantula_susp": 0.0004748338081671415,
            "pseudo_op2_susp": 0.012658227848101266,
            "pseudo_barinel_susp": 0.0004748338081671415
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.RendererAgg.get_canvas_width_height#239",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.RendererAgg",
        "signature": "lib.matplotlib.backends.backend_agg.RendererAgg.get_canvas_width_height(self)",
        "snippet": "    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height",
        "begin_line": 239,
        "end_line": 241,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006711409395973154,
            "pseudo_dstar_susp": 0.006289308176100629,
            "pseudo_tarantula_susp": 0.0003397893306150187,
            "pseudo_op2_susp": 0.006289308176100629,
            "pseudo_barinel_susp": 0.0003397893306150187
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.RendererAgg._get_agg_font#243",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.RendererAgg",
        "signature": "lib.matplotlib.backends.backend_agg.RendererAgg._get_agg_font(self, prop)",
        "snippet": "    def _get_agg_font(self, prop):\n        \"\"\"\n        Get the font for text instance t, caching for efficiency\n        \"\"\"\n        fname = findfont(prop)\n        font = get_font(fname)\n\n        font.clear()\n        size = prop.get_size_in_points()\n        font.set_size(size, self.dpi)\n\n        return font",
        "begin_line": 243,
        "end_line": 254,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.022727272727272728,
            "pseudo_dstar_susp": 0.0196078431372549,
            "pseudo_tarantula_susp": 0.0003966679888932963,
            "pseudo_op2_susp": 0.0196078431372549,
            "pseudo_barinel_susp": 0.0003966679888932963
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.RendererAgg.points_to_pixels#256",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.RendererAgg",
        "signature": "lib.matplotlib.backends.backend_agg.RendererAgg.points_to_pixels(self, points)",
        "snippet": "    def points_to_pixels(self, points):\n        # docstring inherited\n        return points * self.dpi / 72",
        "begin_line": 256,
        "end_line": 258,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006414368184733803,
            "pseudo_dstar_susp": 0.0007830853563038371,
            "pseudo_tarantula_susp": 0.00021772262138036142,
            "pseudo_op2_susp": 0.0007830853563038371,
            "pseudo_barinel_susp": 0.00021772262138036142
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.RendererAgg.clear#269",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.RendererAgg",
        "signature": "lib.matplotlib.backends.backend_agg.RendererAgg.clear(self)",
        "snippet": "    def clear(self):\n        self._renderer.clear()",
        "begin_line": 269,
        "end_line": 270,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012023566189731875,
            "pseudo_dstar_susp": 0.00013415615776764153,
            "pseudo_tarantula_susp": 0.00011973180076628352,
            "pseudo_op2_susp": 0.00013415615776764153,
            "pseudo_barinel_susp": 0.00011973180076628352
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.RendererAgg.option_image_nocomposite#272",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.RendererAgg",
        "signature": "lib.matplotlib.backends.backend_agg.RendererAgg.option_image_nocomposite(self)",
        "snippet": "    def option_image_nocomposite(self):\n        # docstring inherited\n\n        # It is generally faster to composite each image directly to\n        # the Figure, and there's no file size benefit to compositing\n        # with the Agg backend\n        return True",
        "begin_line": 272,
        "end_line": 278,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001310615989515072,
            "pseudo_dstar_susp": 0.0022935779816513763,
            "pseudo_tarantula_susp": 0.00037678975131876413,
            "pseudo_op2_susp": 0.002288329519450801,
            "pseudo_barinel_susp": 0.00037678975131876413
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.RendererAgg.start_filter#319",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.RendererAgg",
        "signature": "lib.matplotlib.backends.backend_agg.RendererAgg.start_filter(self)",
        "snippet": "    def start_filter(self):\n        \"\"\"\n        Start filtering. It simply create a new canvas (the old one is saved).\n        \"\"\"\n        self._filter_renderers.append(self._renderer)\n        self._renderer = _RendererAgg(int(self.width), int(self.height),\n                                      self.dpi)\n        self._update_methods()",
        "begin_line": 319,
        "end_line": 326,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.RendererAgg.stop_filter#328",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.RendererAgg",
        "signature": "lib.matplotlib.backends.backend_agg.RendererAgg.stop_filter(self, post_processing)",
        "snippet": "    def stop_filter(self, post_processing):\n        \"\"\"\n        Save the plot in the current canvas as a image and apply\n        the *post_processing* function.\n\n           def post_processing(image, dpi):\n             # ny, nx, depth = image.shape\n             # image (numpy array) has RGBA channels and has a depth of 4.\n             ...\n             # create a new_image (numpy array of 4 channels, size can be\n             # different). The resulting image may have offsets from\n             # lower-left corner of the original image\n             return new_image, offset_x, offset_y\n\n        The saved renderer is restored and the returned image from\n        post_processing is plotted (using draw_image) on it.\n        \"\"\"\n\n        width, height = int(self.width), int(self.height)\n\n        buffer, (l, b, w, h) = self.tostring_rgba_minimized()\n\n        self._renderer = self._filter_renderers.pop()\n        self._update_methods()\n\n        if w > 0 and h > 0:\n            img = np.frombuffer(buffer, np.uint8)\n            img, ox, oy = post_processing(img.reshape((h, w, 4)) / 255.,\n                                          self.dpi)\n            gc = self.new_gc()\n            if img.dtype.kind == 'f':\n                img = np.asarray(img * 255., np.uint8)\n            img = img[::-1]\n            self._renderer.draw_image(gc, l + ox, height - b - h + oy, img)",
        "begin_line": 328,
        "end_line": 361,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.draw#384",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg",
        "signature": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.draw(self)",
        "snippet": "    def draw(self):\n        \"\"\"\n        Draw the figure using the renderer.\n        \"\"\"\n        self.renderer = self.get_renderer(cleared=True)\n        # Acquire a lock on the shared font cache.\n        with RendererAgg.lock, \\\n             (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar\n              else nullcontext()):\n            self.figure.draw(self.renderer)\n            # A GUI class may be need to update a window using this draw, so\n            # don't forget to call the superclass.\n            super().draw()",
        "begin_line": 384,
        "end_line": 396,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016666666666666668,
            "pseudo_dstar_susp": 0.0021645021645021645,
            "pseudo_tarantula_susp": 0.0004775549188156638,
            "pseudo_op2_susp": 0.0021645021645021645,
            "pseudo_barinel_susp": 0.0004775549188156638
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.get_renderer#398",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg",
        "signature": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.get_renderer(self, cleared=False)",
        "snippet": "    def get_renderer(self, cleared=False):\n        l, b, w, h = self.figure.bbox.bounds\n        key = w, h, self.figure.dpi\n        reuse_renderer = (hasattr(self, \"renderer\")\n                          and getattr(self, \"_lastKey\", None) == key)\n        if not reuse_renderer:\n            self.renderer = RendererAgg(w, h, self.figure.dpi)\n            self._lastKey = key\n        elif cleared:\n            self.renderer.clear()\n        return self.renderer",
        "begin_line": 398,
        "end_line": 408,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002183406113537118,
            "pseudo_dstar_susp": 0.0023094688221709007,
            "pseudo_tarantula_susp": 0.0005235602094240838,
            "pseudo_op2_susp": 0.0023094688221709007,
            "pseudo_barinel_susp": 0.0005235602094240838
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_png#454",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg",
        "signature": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_png(self, filename_or_obj, *args, metadata=None, pil_kwargs=None, **kwargs)",
        "snippet": "    def print_png(self, filename_or_obj, *args,\n                  metadata=None, pil_kwargs=None,\n                  **kwargs):\n        \"\"\"\n        Write the figure to a PNG file.\n\n        Parameters\n        ----------\n        filename_or_obj : str or PathLike or file-like object\n            The file to write to.\n\n        metadata : dict, optional\n            Metadata in the PNG file as key-value pairs of bytes or latin-1\n            encodable strings.\n            According to the PNG specification, keys must be shorter than 79\n            chars.\n\n            The `PNG specification`_ defines some common keywords that may be\n            used as appropriate:\n\n            - Title: Short (one line) title or caption for image.\n            - Author: Name of image's creator.\n            - Description: Description of image (possibly long).\n            - Copyright: Copyright notice.\n            - Creation Time: Time of original image creation\n              (usually RFC 1123 format).\n            - Software: Software used to create the image.\n            - Disclaimer: Legal disclaimer.\n            - Warning: Warning of nature of content.\n            - Source: Device used to create the image.\n            - Comment: Miscellaneous comment;\n              conversion from other image format.\n\n            Other keywords may be invented for other purposes.\n\n            If 'Software' is not given, an autogenerated value for matplotlib\n            will be used.\n\n            For more details see the `PNG specification`_.\n\n            .. _PNG specification: \\\n                https://www.w3.org/TR/2003/REC-PNG-20031110/#11keywords\n\n        pil_kwargs : dict, optional\n            If set to a non-None value, use Pillow to save the figure instead\n            of Matplotlib's builtin PNG support, and pass these keyword\n            arguments to `PIL.Image.save`.\n\n            If the 'pnginfo' key is present, it completely overrides\n            *metadata*, including the default 'Software' key.\n        \"\"\"\n        from matplotlib import _png\n\n        if metadata is None:\n            metadata = {}\n        default_metadata = {\n            \"Software\":\n                f\"matplotlib version{__version__}, http://matplotlib.org/\",\n        }\n\n        FigureCanvasAgg.draw(self)\n        if pil_kwargs is not None:\n            from PIL import Image\n            from PIL.PngImagePlugin import PngInfo\n            # Only use the metadata kwarg if pnginfo is not set, because the\n            # semantics of duplicate keys in pnginfo is unclear.\n            if \"pnginfo\" in pil_kwargs:\n                if metadata:\n                    cbook._warn_external(\"'metadata' is overridden by the \"\n                                         \"'pnginfo' entry in 'pil_kwargs'.\")\n            else:\n                pnginfo = PngInfo()\n                for k, v in {**default_metadata, **metadata}.items():\n                    pnginfo.add_text(k, v)\n                pil_kwargs[\"pnginfo\"] = pnginfo\n            pil_kwargs.setdefault(\"dpi\", (self.figure.dpi, self.figure.dpi))\n            (Image.fromarray(np.asarray(self.buffer_rgba()))\n             .save(filename_or_obj, format=\"png\", **pil_kwargs))\n\n        else:\n            renderer = self.get_renderer()\n            with cbook.open_file_cm(filename_or_obj, \"wb\") as fh:\n                _png.write_png(renderer._renderer, fh, self.figure.dpi,\n                               metadata={**default_metadata, **metadata})",
        "begin_line": 454,
        "end_line": 537,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0045662100456621,
            "pseudo_dstar_susp": 0.0021413276231263384,
            "pseudo_tarantula_susp": 0.0005417118093174431,
            "pseudo_op2_susp": 0.0021413276231263384,
            "pseudo_barinel_susp": 0.0005417118093174431
        }
    },
    {
        "name": "lib.matplotlib.backends._backend_pdf_ps._cached_get_afm_from_fname#14",
        "src_path": "lib/matplotlib/backends/_backend_pdf_ps.py",
        "class_name": "lib.matplotlib.backends._backend_pdf_ps",
        "signature": "lib.matplotlib.backends._backend_pdf_ps._cached_get_afm_from_fname(fname)",
        "snippet": "def _cached_get_afm_from_fname(fname):\n    with open(fname, \"rb\") as fh:\n        return AFM(fh)",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends._backend_pdf_ps.RendererPDFPSBase.flipy#24",
        "src_path": "lib/matplotlib/backends/_backend_pdf_ps.py",
        "class_name": "lib.matplotlib.backends._backend_pdf_ps.RendererPDFPSBase",
        "signature": "lib.matplotlib.backends._backend_pdf_ps.RendererPDFPSBase.flipy(self)",
        "snippet": "    def flipy(self):\n        # docstring inherited\n        return False  # y increases from bottom to top.",
        "begin_line": 24,
        "end_line": 26,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.893905904641616e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.backends._backend_pdf_ps.RendererPDFPSBase._get_font_ttf#79",
        "src_path": "lib/matplotlib/backends/_backend_pdf_ps.py",
        "class_name": "lib.matplotlib.backends._backend_pdf_ps.RendererPDFPSBase",
        "signature": "lib.matplotlib.backends._backend_pdf_ps.RendererPDFPSBase._get_font_ttf(self, prop)",
        "snippet": "    def _get_font_ttf(self, prop):\n        fname = font_manager.findfont(prop)\n        font = font_manager.get_font(fname)\n        font.clear()\n        font.set_size(prop.get_size_in_points(), 72)\n        return font",
        "begin_line": 79,
        "end_line": 84,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.791803023219573e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.spines.Spine.cla#238",
        "src_path": "lib/matplotlib/spines.py",
        "class_name": "lib.matplotlib.spines.Spine",
        "signature": "lib.matplotlib.spines.Spine.cla(self)",
        "snippet": "    def cla(self):\n        \"\"\"Clear the current spine.\"\"\"\n        self._position = None  # clear position\n        if self.axis is not None:\n            self.axis.cla()",
        "begin_line": 238,
        "end_line": 242,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.631840036632832e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.spines.Spine._adjust_location#266",
        "src_path": "lib/matplotlib/spines.py",
        "class_name": "lib.matplotlib.spines.Spine",
        "signature": "lib.matplotlib.spines.Spine._adjust_location(self)",
        "snippet": "    def _adjust_location(self):\n        \"\"\"Automatically set spine bounds to the view interval.\"\"\"\n\n        if self.spine_type == 'circle':\n            return\n\n        if self._bounds is None:\n            if self.spine_type in ('left', 'right'):\n                low, high = self.axes.viewLim.intervaly\n            elif self.spine_type in ('top', 'bottom'):\n                low, high = self.axes.viewLim.intervalx\n            else:\n                raise ValueError('unknown spine spine_type: %s' %\n                                 self.spine_type)\n\n            if self._smart_bounds:  # deprecated in 3.2\n                # attempt to set bounds in sophisticated way\n\n                # handle inverted limits\n                viewlim_low, viewlim_high = sorted([low, high])\n\n                if self.spine_type in ('left', 'right'):\n                    datalim_low, datalim_high = self.axes.dataLim.intervaly\n                    ticks = self.axes.get_yticks()\n                elif self.spine_type in ('top', 'bottom'):\n                    datalim_low, datalim_high = self.axes.dataLim.intervalx\n                    ticks = self.axes.get_xticks()\n                # handle inverted limits\n                ticks = np.sort(ticks)\n                datalim_low, datalim_high = sorted([datalim_low, datalim_high])\n\n                if datalim_low < viewlim_low:\n                    # Data extends past view. Clip line to view.\n                    low = viewlim_low\n                else:\n                    # Data ends before view ends.\n                    cond = (ticks <= datalim_low) & (ticks >= viewlim_low)\n                    tickvals = ticks[cond]\n                    if len(tickvals):\n                        # A tick is less than or equal to lowest data point.\n                        low = tickvals[-1]\n                    else:\n                        # No tick is available\n                        low = datalim_low\n                    low = max(low, viewlim_low)\n\n                if datalim_high > viewlim_high:\n                    # Data extends past view. Clip line to view.\n                    high = viewlim_high\n                else:\n                    # Data ends before view ends.\n                    cond = (ticks >= datalim_high) & (ticks <= viewlim_high)\n                    tickvals = ticks[cond]\n                    if len(tickvals):\n                        # A tick is greater than or equal to highest data\n                        # point.\n                        high = tickvals[0]\n                    else:\n                        # No tick is available\n                        high = datalim_high\n                    high = min(high, viewlim_high)\n\n        else:\n            low, high = self._bounds\n\n        if self._patch_type == 'arc':\n            if self.spine_type in ('bottom', 'top'):\n                try:\n                    direction = self.axes.get_theta_direction()\n                except AttributeError:\n                    direction = 1\n                try:\n                    offset = self.axes.get_theta_offset()\n                except AttributeError:\n                    offset = 0\n                low = low * direction + offset\n                high = high * direction + offset\n                if low > high:\n                    low, high = high, low\n\n                self._path = mpath.Path.arc(np.rad2deg(low), np.rad2deg(high))\n\n                if self.spine_type == 'bottom':\n                    rmin, rmax = self.axes.viewLim.intervaly\n                    try:\n                        rorigin = self.axes.get_rorigin()\n                    except AttributeError:\n                        rorigin = rmin\n                    scaled_diameter = (rmin - rorigin) / (rmax - rorigin)\n                    self._height = scaled_diameter\n                    self._width = scaled_diameter\n\n            else:\n                raise ValueError('unable to set bounds for spine \"%s\"' %\n                                 self.spine_type)\n        else:\n            v1 = self._path.vertices\n            assert v1.shape == (2, 2), 'unexpected vertices shape'\n            if self.spine_type in ['left', 'right']:\n                v1[0, 1] = low\n                v1[1, 1] = high\n            elif self.spine_type in ['bottom', 'top']:\n                v1[0, 0] = low\n                v1[1, 0] = high\n            else:\n                raise ValueError('unable to set bounds for spine \"%s\"' %\n                                 self.spine_type)",
        "begin_line": 266,
        "end_line": 372,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.legend_handler.HandlerBase._default_update_prop#69",
        "src_path": "lib/matplotlib/legend_handler.py",
        "class_name": "lib.matplotlib.legend_handler.HandlerBase",
        "signature": "lib.matplotlib.legend_handler.HandlerBase._default_update_prop(self, legend_handle, orig_handle)",
        "snippet": "    def _default_update_prop(self, legend_handle, orig_handle):\n        legend_handle.update_from(orig_handle)",
        "begin_line": 69,
        "end_line": 70,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002698327037236913,
            "pseudo_dstar_susp": 0.00025342118601115053,
            "pseudo_tarantula_susp": 0.00027570995312930797,
            "pseudo_op2_susp": 0.00025342118601115053,
            "pseudo_barinel_susp": 0.00027570995312930797
        }
    },
    {
        "name": "lib.matplotlib.legend_handler.HandlerBase.update_prop#72",
        "src_path": "lib/matplotlib/legend_handler.py",
        "class_name": "lib.matplotlib.legend_handler.HandlerBase",
        "signature": "lib.matplotlib.legend_handler.HandlerBase.update_prop(self, legend_handle, orig_handle, legend)",
        "snippet": "    def update_prop(self, legend_handle, orig_handle, legend):\n\n        self._update_prop(legend_handle, orig_handle)\n\n        legend._set_artist_props(legend_handle)\n        legend_handle.set_clip_box(None)\n        legend_handle.set_clip_path(None)",
        "begin_line": 72,
        "end_line": 78,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005291005291005291,
            "pseudo_dstar_susp": 0.000646830530401035,
            "pseudo_tarantula_susp": 0.00017583963425356076,
            "pseudo_op2_susp": 0.000646830530401035,
            "pseudo_barinel_susp": 0.00017583963425356076
        }
    },
    {
        "name": "lib.matplotlib.legend_handler.HandlerBase.adjust_drawing_area#80",
        "src_path": "lib/matplotlib/legend_handler.py",
        "class_name": "lib.matplotlib.legend_handler.HandlerBase",
        "signature": "lib.matplotlib.legend_handler.HandlerBase.adjust_drawing_area(self, legend, orig_handle, xdescent, ydescent, width, height, fontsize)",
        "snippet": "    def adjust_drawing_area(self, legend, orig_handle,\n                            xdescent, ydescent, width, height, fontsize,\n                            ):\n        xdescent = xdescent - self._xpad * fontsize\n        ydescent = ydescent - self._ypad * fontsize\n        width = width - self._xpad * fontsize\n        height = height - self._ypad * fontsize\n        return xdescent, ydescent, width, height",
        "begin_line": 80,
        "end_line": 87,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005959475566150178,
            "pseudo_dstar_susp": 0.0007057163020465773,
            "pseudo_tarantula_susp": 0.00016869095816464237,
            "pseudo_op2_susp": 0.0007057163020465773,
            "pseudo_barinel_susp": 0.00016869095816464237
        }
    },
    {
        "name": "lib.matplotlib.legend_handler.HandlerLine2D.create_artists#229",
        "src_path": "lib/matplotlib/legend_handler.py",
        "class_name": "lib.matplotlib.legend_handler.HandlerLine2D",
        "signature": "lib.matplotlib.legend_handler.HandlerLine2D.create_artists(self, legend, orig_handle, xdescent, ydescent, width, height, fontsize, trans)",
        "snippet": "    def create_artists(self, legend, orig_handle,\n                       xdescent, ydescent, width, height, fontsize,\n                       trans):\n\n        xdata, xdata_marker = self.get_xdata(legend, xdescent, ydescent,\n                                             width, height, fontsize)\n\n        ydata = np.full_like(xdata, ((height - ydescent) / 2))\n        legline = Line2D(xdata, ydata)\n\n        self.update_prop(legline, orig_handle, legend)\n        legline.set_drawstyle('default')\n        legline.set_marker(\"\")\n\n        legline_marker = Line2D(xdata_marker, ydata[:len(xdata_marker)])\n        self.update_prop(legline_marker, orig_handle, legend)\n        legline_marker.set_linestyle('None')\n        if legend.markerscale != 1:\n            newsz = legline_marker.get_markersize() * legend.markerscale\n            legline_marker.set_markersize(newsz)\n        # we don't want to add this to the return list because\n        # the texts and handles are assumed to be in one-to-one\n        # correspondence.\n        legline._legmarker = legline_marker\n\n        legline.set_transform(trans)\n        legline_marker.set_transform(trans)\n\n        return [legline, legline_marker]",
        "begin_line": 229,
        "end_line": 257,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00033211557622052476,
            "pseudo_dstar_susp": 0.0003278688524590164,
            "pseudo_tarantula_susp": 0.0002249212775528565,
            "pseudo_op2_susp": 0.0003278688524590164,
            "pseudo_barinel_susp": 0.0002249212775528565
        }
    },
    {
        "name": "lib.matplotlib.legend_handler.HandlerPathCollection.create_collection#417",
        "src_path": "lib/matplotlib/legend_handler.py",
        "class_name": "lib.matplotlib.legend_handler.HandlerPathCollection",
        "signature": "lib.matplotlib.legend_handler.HandlerPathCollection.create_collection(self, orig_handle, sizes, offsets, transOffset)",
        "snippet": "    def create_collection(self, orig_handle, sizes, offsets, transOffset):\n        p = type(orig_handle)([orig_handle.get_paths()[0]],\n                              sizes=sizes,\n                              offsets=offsets,\n                              transOffset=transOffset,\n                              )\n        return p",
        "begin_line": 417,
        "end_line": 423,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.legend_handler.HandlerErrorbar.create_artists#462",
        "src_path": "lib/matplotlib/legend_handler.py",
        "class_name": "lib.matplotlib.legend_handler.HandlerErrorbar",
        "signature": "lib.matplotlib.legend_handler.HandlerErrorbar.create_artists(self, legend, orig_handle, xdescent, ydescent, width, height, fontsize, trans)",
        "snippet": "    def create_artists(self, legend, orig_handle,\n                       xdescent, ydescent, width, height, fontsize,\n                       trans):\n\n        plotlines, caplines, barlinecols = orig_handle\n\n        xdata, xdata_marker = self.get_xdata(legend, xdescent, ydescent,\n                                             width, height, fontsize)\n\n        ydata = np.full_like(xdata, (height - ydescent) / 2)\n        legline = Line2D(xdata, ydata)\n\n        xdata_marker = np.asarray(xdata_marker)\n        ydata_marker = np.asarray(ydata[:len(xdata_marker)])\n\n        xerr_size, yerr_size = self.get_err_size(legend, xdescent, ydescent,\n                                                 width, height, fontsize)\n\n        legline_marker = Line2D(xdata_marker, ydata_marker)\n\n        # when plotlines are None (only errorbars are drawn), we just\n        # make legline invisible.\n        if plotlines is None:\n            legline.set_visible(False)\n            legline_marker.set_visible(False)\n        else:\n            self.update_prop(legline, plotlines, legend)\n\n            legline.set_drawstyle('default')\n            legline.set_marker('None')\n\n            self.update_prop(legline_marker, plotlines, legend)\n            legline_marker.set_linestyle('None')\n\n            if legend.markerscale != 1:\n                newsz = legline_marker.get_markersize() * legend.markerscale\n                legline_marker.set_markersize(newsz)\n\n        handle_barlinecols = []\n        handle_caplines = []\n\n        if orig_handle.has_xerr:\n            verts = [((x - xerr_size, y), (x + xerr_size, y))\n                     for x, y in zip(xdata_marker, ydata_marker)]\n            coll = mcoll.LineCollection(verts)\n            self.update_prop(coll, barlinecols[0], legend)\n            handle_barlinecols.append(coll)\n\n            if caplines:\n                capline_left = Line2D(xdata_marker - xerr_size, ydata_marker)\n                capline_right = Line2D(xdata_marker + xerr_size, ydata_marker)\n                self.update_prop(capline_left, caplines[0], legend)\n                self.update_prop(capline_right, caplines[0], legend)\n                capline_left.set_marker(\"|\")\n                capline_right.set_marker(\"|\")\n\n                handle_caplines.append(capline_left)\n                handle_caplines.append(capline_right)\n\n        if orig_handle.has_yerr:\n            verts = [((x, y - yerr_size), (x, y + yerr_size))\n                     for x, y in zip(xdata_marker, ydata_marker)]\n            coll = mcoll.LineCollection(verts)\n            self.update_prop(coll, barlinecols[0], legend)\n            handle_barlinecols.append(coll)\n\n            if caplines:\n                capline_left = Line2D(xdata_marker, ydata_marker - yerr_size)\n                capline_right = Line2D(xdata_marker, ydata_marker + yerr_size)\n                self.update_prop(capline_left, caplines[0], legend)\n                self.update_prop(capline_right, caplines[0], legend)\n                capline_left.set_marker(\"_\")\n                capline_right.set_marker(\"_\")\n\n                handle_caplines.append(capline_left)\n                handle_caplines.append(capline_right)\n\n        artists = [\n            *handle_barlinecols, *handle_caplines, legline, legline_marker,\n        ]\n        for artist in artists:\n            artist.set_transform(trans)\n        return artists",
        "begin_line": 462,
        "end_line": 544,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.legend_handler.HandlerTuple.create_artists#670",
        "src_path": "lib/matplotlib/legend_handler.py",
        "class_name": "lib.matplotlib.legend_handler.HandlerTuple",
        "signature": "lib.matplotlib.legend_handler.HandlerTuple.create_artists(self, legend, orig_handle, xdescent, ydescent, width, height, fontsize, trans)",
        "snippet": "    def create_artists(self, legend, orig_handle,\n                       xdescent, ydescent, width, height, fontsize,\n                       trans):\n\n        handler_map = legend.get_legend_handler_map()\n\n        if self._ndivide is None:\n            ndivide = len(orig_handle)\n        else:\n            ndivide = self._ndivide\n\n        if self._pad is None:\n            pad = legend.borderpad * fontsize\n        else:\n            pad = self._pad * fontsize\n\n        if ndivide > 1:\n            width = (width - pad * (ndivide - 1)) / ndivide\n\n        xds_cycle = cycle(xdescent - (width + pad) * np.arange(ndivide))\n\n        a_list = []\n        for handle1 in orig_handle:\n            handler = legend.get_legend_handler(handler_map, handle1)\n            _a_list = handler.create_artists(\n                legend, handle1,\n                next(xds_cycle), ydescent, width, height, fontsize, trans)\n            a_list.extend(_a_list)\n\n        return a_list",
        "begin_line": 670,
        "end_line": 699,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib._text_layout.layout#8",
        "src_path": "lib/matplotlib/_text_layout.py",
        "class_name": "lib.matplotlib._text_layout",
        "signature": "lib.matplotlib._text_layout.layout(string, font, *, kern_mode=KERNING_DEFAULT)",
        "snippet": "def layout(string, font, *, kern_mode=KERNING_DEFAULT):\n    \"\"\"\n    Render *string* with *font*.  For each character in *string*, yield a\n    (glyph-index, x-position) pair.  When such a pair is yielded, the font's\n    glyph is set to the corresponding character.\n\n    Parameters\n    ----------\n    string : str\n        The string to be rendered.\n    font : FT2Font\n        The font.\n    kern_mode : int\n        A FreeType kerning mode.\n\n    Yields\n    ------\n    glyph_index : int\n    x_position : float\n    \"\"\"\n    x = 0\n    last_glyph_idx = None\n    for char in string:\n        glyph_idx = font.get_char_index(ord(char))\n        kern = (font.get_kerning(last_glyph_idx, glyph_idx, kern_mode)\n                if last_glyph_idx is not None else 0) / 64\n        x += kern\n        glyph = font.load_glyph(glyph_idx, flags=LOAD_NO_HINTING)\n        yield glyph_idx, x\n        x += glyph.linearHoriAdvance / 65536\n        last_glyph_idx = glyph_idx",
        "begin_line": 8,
        "end_line": 38,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00025025025025025025,
            "pseudo_dstar_susp": 0.0002678093197643278,
            "pseudo_tarantula_susp": 0.0002208968411751712,
            "pseudo_op2_susp": 0.0002678093197643278,
            "pseudo_barinel_susp": 0.0002208968411751712
        }
    },
    {
        "name": "lib.matplotlib.dates._to_ordinalf#210",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates",
        "signature": "lib.matplotlib.dates._to_ordinalf(dt)",
        "snippet": "def _to_ordinalf(dt):\n    \"\"\"\n    Convert :mod:`datetime` or :mod:`date` to the Gregorian date as UTC float\n    days, preserving hours, minutes, seconds and microseconds.  Return value\n    is a :func:`float`.\n    \"\"\"\n    # Convert to UTC\n    tzi = getattr(dt, 'tzinfo', None)\n    if tzi is not None:\n        dt = dt.astimezone(UTC)\n        tzi = UTC\n\n    base = float(dt.toordinal())\n\n    # If it's sufficiently datetime-like, it will have a `date()` method\n    cdate = getattr(dt, 'date', lambda: None)()\n    if cdate is not None:\n        # Get a datetime object at midnight UTC\n        midnight_time = datetime.time(0, tzinfo=tzi)\n\n        rdt = datetime.datetime.combine(cdate, midnight_time)\n\n        # Append the seconds as a fraction of a day\n        base += (dt - rdt).total_seconds() / SEC_PER_DAY\n\n    return base",
        "begin_line": 210,
        "end_line": 235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00024715768660405336,
            "pseudo_dstar_susp": 0.00027166530834012495,
            "pseudo_tarantula_susp": 0.00020408163265306123,
            "pseudo_op2_susp": 0.00027166530834012495,
            "pseudo_barinel_susp": 0.00020408163265306123
        }
    },
    {
        "name": "lib.matplotlib.dates._from_ordinalf#269",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates",
        "signature": "lib.matplotlib.dates._from_ordinalf(x, tz=None)",
        "snippet": "def _from_ordinalf(x, tz=None):\n    \"\"\"\n    Convert Gregorian float of the date, preserving hours, minutes,\n    seconds and microseconds.  Return value is a `.datetime`.\n\n    The input date *x* is a float in ordinal days at UTC, and the output will\n    be the specified `.datetime` object corresponding to that time in\n    timezone *tz*, or if *tz* is ``None``, in the timezone specified in\n    :rc:`timezone`.\n    \"\"\"\n    if tz is None:\n        tz = _get_rc_timezone()\n\n    ix, remainder = divmod(x, 1)\n    ix = int(ix)\n    if ix < 1:\n        raise ValueError('Cannot convert {} to a date.  This often happens if '\n                         'non-datetime values are passed to an axis that '\n                         'expects datetime objects.'.format(ix))\n    dt = datetime.datetime.fromordinal(ix).replace(tzinfo=UTC)\n\n    # Since the input date *x* float is unable to preserve microsecond\n    # precision of time representation in non-antique years, the\n    # resulting datetime is rounded to the nearest multiple of\n    # `musec_prec`. A value of 20 is appropriate for current dates.\n    musec_prec = 20\n    remainder_musec = int(round(remainder * MUSECONDS_PER_DAY / musec_prec)\n                          * musec_prec)\n\n    # For people trying to plot with full microsecond precision, enable\n    # an early-year workaround\n    if x < 30 * 365:\n        remainder_musec = int(round(remainder * MUSECONDS_PER_DAY))\n\n    # add hours, minutes, seconds, microseconds\n    dt += datetime.timedelta(microseconds=remainder_musec)\n    return dt.astimezone(tz)",
        "begin_line": 269,
        "end_line": 305,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001868460388639761,
            "pseudo_dstar_susp": 0.00019124115509657678,
            "pseudo_tarantula_susp": 0.00021399529210357372,
            "pseudo_op2_susp": 0.00019124115509657678,
            "pseudo_barinel_susp": 0.00021399529210357372
        }
    },
    {
        "name": "lib.matplotlib.dates.date2num#401",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates",
        "signature": "lib.matplotlib.dates.date2num(d)",
        "snippet": "def date2num(d):\n    \"\"\"\n    Convert datetime objects to Matplotlib dates.\n\n    Parameters\n    ----------\n    d : `datetime.datetime` or `numpy.datetime64` or sequences of these\n\n    Returns\n    -------\n    float or sequence of floats\n        Number of days (fraction part represents hours, minutes, seconds, ms)\n        since 0001-01-01 00:00:00 UTC, plus one.\n\n    Notes\n    -----\n    The addition of one here is a historical artifact. Also, note that the\n    Gregorian calendar is assumed; this is not universal practice.\n    For details see the module docstring.\n    \"\"\"\n    if hasattr(d, \"values\"):\n        # this unpacks pandas series or dataframes...\n        d = d.values\n    if not np.iterable(d):\n        if (isinstance(d, np.datetime64) or\n                (isinstance(d, np.ndarray) and\n                 np.issubdtype(d.dtype, np.datetime64))):\n            return _dt64_to_ordinalf(d)\n        return _to_ordinalf(d)\n\n    else:\n        d = np.asarray(d)\n        if np.issubdtype(d.dtype, np.datetime64):\n            return _dt64_to_ordinalf(d)\n        if not d.size:\n            return d\n        return _to_ordinalf_np_vectorized(d)",
        "begin_line": 401,
        "end_line": 437,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017972681524083394,
            "pseudo_dstar_susp": 0.00019047619047619048,
            "pseudo_tarantula_susp": 0.00017739932588256165,
            "pseudo_op2_susp": 0.00019047619047619048,
            "pseudo_barinel_susp": 0.00017739932588256165
        }
    },
    {
        "name": "lib.matplotlib.dates.drange#544",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates",
        "signature": "lib.matplotlib.dates.drange(dstart, dend, delta)",
        "snippet": "def drange(dstart, dend, delta):\n    \"\"\"\n    Return a sequence of equally spaced Matplotlib dates.\n\n    The dates start at *dstart* and reach up to, but not including *dend*.\n    They are spaced by *delta*.\n\n    Parameters\n    ----------\n    dstart, dend : `~datetime.datetime`\n        The date limits.\n    delta : `datetime.timedelta`\n        Spacing of the dates.\n\n    Returns\n    -------\n    drange : `numpy.array`\n        A list floats representing Matplotlib dates.\n\n    \"\"\"\n    f1 = date2num(dstart)\n    f2 = date2num(dend)\n    step = delta.total_seconds() / SEC_PER_DAY\n\n    # calculate the difference between dend and dstart in times of delta\n    num = int(np.ceil((f2 - f1) / step))\n\n    # calculate end of the interval which will be generated\n    dinterval_end = dstart + num * delta\n\n    # ensure, that an half open interval will be generated [dstart, dend)\n    if dinterval_end >= dend:\n        # if the endpoint is greater than dend, just subtract one delta\n        dinterval_end -= delta\n        num -= 1\n\n    f2 = date2num(dinterval_end)  # new float-endpoint\n    return np.linspace(f1, f2, num + 1)",
        "begin_line": 544,
        "end_line": 581,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.dates.DateFormatter.__init__#594",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.DateFormatter",
        "signature": "lib.matplotlib.dates.DateFormatter.__init__(self, fmt, tz=None)",
        "snippet": "    def __init__(self, fmt, tz=None):\n        \"\"\"\n        Parameters\n        ----------\n        fmt : str\n            `~datetime.datetime.strftime` format string\n        tz : `tzinfo`, default: :rc:`timezone`\n            Ticks timezone.\n        \"\"\"\n        if tz is None:\n            tz = _get_rc_timezone()\n        self.fmt = fmt\n        self.tz = tz",
        "begin_line": 594,
        "end_line": 606,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020781379883624273,
            "pseudo_dstar_susp": 0.00019223375624759708,
            "pseudo_tarantula_susp": 0.0002617801047120419,
            "pseudo_op2_susp": 0.00019223375624759708,
            "pseudo_barinel_susp": 0.0002615746795710175
        }
    },
    {
        "name": "lib.matplotlib.dates.ConciseDateFormatter.format_ticks#770",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.ConciseDateFormatter",
        "signature": "lib.matplotlib.dates.ConciseDateFormatter.format_ticks(self, values)",
        "snippet": "    def format_ticks(self, values):\n        tickdatetime = [num2date(value, tz=self._tz) for value in values]\n        tickdate = np.array([tdt.timetuple()[:6] for tdt in tickdatetime])\n\n        # basic algorithm:\n        # 1) only display a part of the date if it changes over the ticks.\n        # 2) don't display the smaller part of the date if:\n        #    it is always the same or if it is the start of the\n        #    year, month, day etc.\n        # fmt for most ticks at this level\n        fmts = self.formats\n        # format beginnings of days, months, years, etc...\n        zerofmts = self.zero_formats\n        # offset fmt are for the offset in the upper left of the\n        # or lower right of the axis.\n        offsetfmts = self.offset_formats\n\n        # determine the level we will label at:\n        # mostly 0: years,  1: months,  2: days,\n        # 3: hours, 4: minutes, 5: seconds, 6: microseconds\n        for level in range(5, -1, -1):\n            if len(np.unique(tickdate[:, level])) > 1:\n                break\n\n        # level is the basic level we will label at.\n        # now loop through and decide the actual ticklabels\n        zerovals = [0, 1, 1, 0, 0, 0, 0]\n        labels = [''] * len(tickdate)\n        for nn in range(len(tickdate)):\n            if level < 5:\n                if tickdate[nn][level] == zerovals[level]:\n                    fmt = zerofmts[level]\n                else:\n                    fmt = fmts[level]\n            else:\n                # special handling for seconds + microseconds\n                if (tickdatetime[nn].second == tickdatetime[nn].microsecond\n                        == 0):\n                    fmt = zerofmts[level]\n                else:\n                    fmt = fmts[level]\n            labels[nn] = tickdatetime[nn].strftime(fmt)\n\n        # special handling of seconds and microseconds:\n        # strip extra zeros and decimal if possible.\n        # this is complicated by two factors.  1) we have some level-4 strings\n        # here (i.e. 03:00, '0.50000', '1.000') 2) we would like to have the\n        # same number of decimals for each string (i.e. 0.5 and 1.0).\n        if level >= 5:\n            trailing_zeros = min(\n                (len(s) - len(s.rstrip('0')) for s in labels if '.' in s),\n                default=None)\n            if trailing_zeros:\n                for nn in range(len(labels)):\n                    if '.' in labels[nn]:\n                        labels[nn] = labels[nn][:-trailing_zeros].rstrip('.')\n\n        if self.show_offset:\n            # set the offset string:\n            self.offset_string = tickdatetime[-1].strftime(offsetfmts[level])\n\n        return labels",
        "begin_line": 770,
        "end_line": 831,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.dates.AutoDateFormatter.__call__#922",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.AutoDateFormatter",
        "signature": "lib.matplotlib.dates.AutoDateFormatter.__call__(self, x, pos=None)",
        "snippet": "    def __call__(self, x, pos=None):\n        try:\n            locator_unit_scale = float(self._locator._get_unit())\n        except AttributeError:\n            locator_unit_scale = 1\n        # Pick the first scale which is greater than the locator unit.\n        fmt = next((fmt for scale, fmt in sorted(self.scaled.items())\n                    if scale >= locator_unit_scale),\n                   self.defaultfmt)\n\n        if isinstance(fmt, str):\n            self._formatter = DateFormatter(fmt, self._tz)\n            result = self._formatter(x, pos)\n        elif callable(fmt):\n            result = fmt(x, pos)\n        else:\n            raise TypeError('Unexpected type passed to {0!r}.'.format(self))\n\n        return result",
        "begin_line": 922,
        "end_line": 940,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021867483052700635,
            "pseudo_dstar_susp": 0.00020048115477145148,
            "pseudo_tarantula_susp": 0.00033090668431502316,
            "pseudo_op2_susp": 0.00020048115477145148,
            "pseudo_barinel_susp": 0.00033090668431502316
        }
    },
    {
        "name": "lib.matplotlib.dates.rrulewrapper._update_rrule#955",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.rrulewrapper",
        "signature": "lib.matplotlib.dates.rrulewrapper._update_rrule(self, **kwargs)",
        "snippet": "    def _update_rrule(self, **kwargs):\n        tzinfo = self._base_tzinfo\n\n        # rrule does not play nicely with time zones - especially pytz time\n        # zones, it's best to use naive zones and attach timezones once the\n        # datetimes are returned\n        if 'dtstart' in kwargs:\n            dtstart = kwargs['dtstart']\n            if dtstart.tzinfo is not None:\n                if tzinfo is None:\n                    tzinfo = dtstart.tzinfo\n                else:\n                    dtstart = dtstart.astimezone(tzinfo)\n\n                kwargs['dtstart'] = dtstart.replace(tzinfo=None)\n\n        if 'until' in kwargs:\n            until = kwargs['until']\n            if until.tzinfo is not None:\n                if tzinfo is not None:\n                    until = until.astimezone(tzinfo)\n                else:\n                    raise ValueError('until cannot be aware if dtstart '\n                                     'is naive and tzinfo is None')\n\n                kwargs['until'] = until.replace(tzinfo=None)\n\n        self._construct = kwargs.copy()\n        self._tzinfo = tzinfo\n        self._rrule = rrule(**self._construct)",
        "begin_line": 955,
        "end_line": 984,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016528925619834712,
            "pseudo_dstar_susp": 0.0001850481125092524,
            "pseudo_tarantula_susp": 0.00018691588785046728,
            "pseudo_op2_susp": 0.0001850481125092524,
            "pseudo_barinel_susp": 0.00018691588785046728
        }
    },
    {
        "name": "lib.matplotlib.dates.rrulewrapper._attach_tzinfo#986",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.rrulewrapper",
        "signature": "lib.matplotlib.dates.rrulewrapper._attach_tzinfo(self, dt, tzinfo)",
        "snippet": "    def _attach_tzinfo(self, dt, tzinfo):\n        # pytz zones are attached by \"localizing\" the datetime\n        if hasattr(tzinfo, 'localize'):\n            return tzinfo.localize(dt, is_dst=True)\n\n        return dt.replace(tzinfo=tzinfo)",
        "begin_line": 986,
        "end_line": 991,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017972681524083394,
            "pseudo_dstar_susp": 0.00019047619047619048,
            "pseudo_tarantula_susp": 0.00017739932588256165,
            "pseudo_op2_susp": 0.00019047619047619048,
            "pseudo_barinel_susp": 0.00017739932588256165
        }
    },
    {
        "name": "lib.matplotlib.dates.rrulewrapper.__getattr__#1031",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.rrulewrapper",
        "signature": "lib.matplotlib.dates.rrulewrapper.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        if name in self.__dict__:\n            return self.__dict__[name]\n\n        f = getattr(self._rrule, name)\n\n        if name in {'after', 'before'}:\n            return self._aware_return_wrapper(f)\n        elif name in {'xafter', 'xbefore', 'between'}:\n            return self._aware_return_wrapper(f, returns_list=True)\n        else:\n            return f",
        "begin_line": 1031,
        "end_line": 1042,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022722108611679165,
            "pseudo_dstar_susp": 0.00022972662531587412,
            "pseudo_tarantula_susp": 0.00022914757103574703,
            "pseudo_op2_susp": 0.00022972662531587412,
            "pseudo_barinel_susp": 0.00022914757103574703
        }
    },
    {
        "name": "lib.matplotlib.dates.DateLocator.__init__#1057",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.DateLocator",
        "signature": "lib.matplotlib.dates.DateLocator.__init__(self, tz=None)",
        "snippet": "    def __init__(self, tz=None):\n        \"\"\"\n        *tz* is a :class:`tzinfo` instance.\n        \"\"\"\n        if tz is None:\n            tz = _get_rc_timezone()\n        self.tz = tz",
        "begin_line": 1057,
        "end_line": 1063,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019527436047646945,
            "pseudo_dstar_susp": 0.00019833399444664816,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00019833399444664816,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.dates.DateLocator.viewlim_to_dt#1086",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.DateLocator",
        "signature": "lib.matplotlib.dates.DateLocator.viewlim_to_dt(self)",
        "snippet": "    def viewlim_to_dt(self):\n        \"\"\"\n        Converts the view interval to datetime objects.\n        \"\"\"\n        vmin, vmax = self.axis.get_view_interval()\n        if vmin > vmax:\n            vmin, vmax = vmax, vmin\n        if vmin < 1:\n            raise ValueError('view limit minimum {} is less than 1 and '\n                             'is an invalid Matplotlib date value. This '\n                             'often happens if you pass a non-datetime '\n                             'value to an axis that has datetime units'\n                             .format(vmin))\n        return num2date(vmin, self.tz), num2date(vmax, self.tz)",
        "begin_line": 1086,
        "end_line": 1099,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019179133103183735,
            "pseudo_dstar_susp": 0.00019164430816404754,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00019164430816404754,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.dates.DateLocator.nonsingular#1114",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.DateLocator",
        "signature": "lib.matplotlib.dates.DateLocator.nonsingular(self, vmin, vmax)",
        "snippet": "    def nonsingular(self, vmin, vmax):\n        \"\"\"\n        Given the proposed upper and lower extent, adjust the range\n        if it is too close to being singular (i.e. a range of ~0).\n        \"\"\"\n        if not np.isfinite(vmin) or not np.isfinite(vmax):\n            # Except if there is no data, then use 2000-2010 as default.\n            return (date2num(datetime.date(2000, 1, 1)),\n                    date2num(datetime.date(2010, 1, 1)))\n        if vmax < vmin:\n            vmin, vmax = vmax, vmin\n        unit = self._get_unit()\n        interval = self._get_interval()\n        if abs(vmax - vmin) < 1e-6:\n            vmin -= 2 * unit * interval\n            vmax += 2 * unit * interval\n        return vmin, vmax",
        "begin_line": 1114,
        "end_line": 1130,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012717792191275595,
            "pseudo_dstar_susp": 0.0001210800339024095,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.0001210800339024095,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.dates.RRuleLocator.__init__#1136",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.RRuleLocator",
        "signature": "lib.matplotlib.dates.RRuleLocator.__init__(self, o, tz=None)",
        "snippet": "    def __init__(self, o, tz=None):\n        DateLocator.__init__(self, tz)\n        self.rule = o",
        "begin_line": 1136,
        "end_line": 1138,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016680567139282736,
            "pseudo_dstar_susp": 0.00018528812303131369,
            "pseudo_tarantula_susp": 0.00017661603673613564,
            "pseudo_op2_susp": 0.00018528812303131369,
            "pseudo_barinel_susp": 0.00017661603673613564
        }
    },
    {
        "name": "lib.matplotlib.dates.RRuleLocator.__call__#1140",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.RRuleLocator",
        "signature": "lib.matplotlib.dates.RRuleLocator.__call__(self)",
        "snippet": "    def __call__(self):\n        # if no data have been set, this will tank with a ValueError\n        try:\n            dmin, dmax = self.viewlim_to_dt()\n        except ValueError:\n            return []\n\n        return self.tick_values(dmin, dmax)",
        "begin_line": 1140,
        "end_line": 1147,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018281535648994517,
            "pseudo_dstar_susp": 0.00019102196752626553,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00019102196752626553,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.dates.RRuleLocator.tick_values#1149",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.RRuleLocator",
        "signature": "lib.matplotlib.dates.RRuleLocator.tick_values(self, vmin, vmax)",
        "snippet": "    def tick_values(self, vmin, vmax):\n        delta = relativedelta(vmax, vmin)\n\n        # We need to cap at the endpoints of valid datetime\n        try:\n            start = vmin - delta\n        except (ValueError, OverflowError):\n            start = _from_ordinalf(1.0)\n\n        try:\n            stop = vmax + delta\n        except (ValueError, OverflowError):\n            # The magic number!\n            stop = _from_ordinalf(3652059.9999999)\n\n        self.rule.set(dtstart=start, until=stop)\n\n        dates = self.rule.between(vmin, vmax, True)\n        if len(dates) == 0:\n            return date2num([vmin, vmax])\n        return self.raise_if_exceeds(date2num(dates))",
        "begin_line": 1149,
        "end_line": 1169,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018001800180018,
            "pseudo_dstar_susp": 0.00018556318426424197,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00018556318426424197,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.dates.RRuleLocator._get_unit#1171",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.RRuleLocator",
        "signature": "lib.matplotlib.dates.RRuleLocator._get_unit(self)",
        "snippet": "    def _get_unit(self):\n        \"\"\"\n        Return how many days a unit of the locator is; used for\n        intelligent autoscaling.\n        \"\"\"\n        freq = self.rule._rrule._freq\n        return self.get_unit_generic(freq)",
        "begin_line": 1171,
        "end_line": 1177,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012717792191275595,
            "pseudo_dstar_susp": 0.0001210800339024095,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.0001210800339024095,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.dates.RRuleLocator.get_unit_generic#1180",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.RRuleLocator",
        "signature": "lib.matplotlib.dates.RRuleLocator.get_unit_generic(freq)",
        "snippet": "    def get_unit_generic(freq):\n        if freq == YEARLY:\n            return DAYS_PER_YEAR\n        elif freq == MONTHLY:\n            return DAYS_PER_MONTH\n        elif freq == WEEKLY:\n            return DAYS_PER_WEEK\n        elif freq == DAILY:\n            return 1.0\n        elif freq == HOURLY:\n            return 1.0 / HOURS_PER_DAY\n        elif freq == MINUTELY:\n            return 1.0 / MINUTES_PER_DAY\n        elif freq == SECONDLY:\n            return 1.0 / SEC_PER_DAY\n        else:\n            # error\n            return -1   # or should this just return '1'?",
        "begin_line": 1180,
        "end_line": 1197,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019712201852946975,
            "pseudo_dstar_susp": 0.0001868460388639761,
            "pseudo_tarantula_susp": 0.0002563445270443476,
            "pseudo_op2_susp": 0.0001868460388639761,
            "pseudo_barinel_susp": 0.0002563445270443476
        }
    },
    {
        "name": "lib.matplotlib.dates.AutoDateLocator.__init__#1273",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.AutoDateLocator",
        "signature": "lib.matplotlib.dates.AutoDateLocator.__init__(self, tz=None, minticks=5, maxticks=None, interval_multiples=True)",
        "snippet": "    def __init__(self, tz=None, minticks=5, maxticks=None,\n                 interval_multiples=True):\n        \"\"\"\n        Parameters\n        ----------\n        tz : `tzinfo`\n            Ticks timezone.\n        minticks : int\n            The minimum number of ticks desired; controls whether ticks occur\n            yearly, monthly, etc.\n        maxticks : int\n            The maximum number of ticks desired; controls the interval between\n            ticks (ticking every other, every 3, etc.).  For fine-grained\n            control, this can be a dictionary mapping individual rrule\n            frequency constants (YEARLY, MONTHLY, etc.) to their own maximum\n            number of ticks.  This can be used to keep the number of ticks\n            appropriate to the format chosen in `AutoDateFormatter`. Any\n            frequency not specified in this dictionary is given a default\n            value.\n        interval_multiples : bool, default: True\n            Whether ticks should be chosen to be multiple of the interval,\n            locking them to 'nicer' locations.  For example, this will force\n            the ticks to be at hours 0, 6, 12, 18 when hourly ticking is done\n            at 6 hour intervals.\n        \"\"\"\n        DateLocator.__init__(self, tz)\n        self._locator = YearLocator(tz=tz)\n        self._freq = YEARLY\n        self._freqs = [YEARLY, MONTHLY, DAILY, HOURLY, MINUTELY,\n                       SECONDLY, MICROSECONDLY]\n        self.minticks = minticks\n\n        self.maxticks = {YEARLY: 11, MONTHLY: 12, DAILY: 11, HOURLY: 12,\n                         MINUTELY: 11, SECONDLY: 11, MICROSECONDLY: 8}\n        if maxticks is not None:\n            try:\n                self.maxticks.update(maxticks)\n            except TypeError:\n                # Assume we were given an integer. Use this as the maximum\n                # number of ticks for every frequency and create a\n                # dictionary for this\n                self.maxticks = dict.fromkeys(self._freqs, maxticks)\n        self.interval_multiples = interval_multiples\n        self.intervald = {\n            YEARLY:   [1, 2, 4, 5, 10, 20, 40, 50, 100, 200, 400, 500,\n                       1000, 2000, 4000, 5000, 10000],\n            MONTHLY:  [1, 2, 3, 4, 6],\n            DAILY:    [1, 2, 3, 7, 14, 21],\n            HOURLY:   [1, 2, 3, 4, 6, 12],\n            MINUTELY: [1, 5, 10, 15, 30],\n            SECONDLY: [1, 5, 10, 15, 30],\n            MICROSECONDLY: [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000,\n                            5000, 10000, 20000, 50000, 100000, 200000, 500000,\n                            1000000]}\n        if interval_multiples:\n            # Swap \"3\" for \"4\" in the DAILY list; If we use 3 we get bad\n            # tick loc for months w/ 31 days: 1, 4, ..., 28, 31, 1\n            # If we use 4 then we get: 1, 5, ... 25, 29, 1\n            self.intervald[DAILY] = [1, 2, 4, 7, 14, 21]\n\n        self._byranges = [None, range(1, 13), range(1, 32),\n                          range(0, 24), range(0, 60), range(0, 60), None]",
        "begin_line": 1273,
        "end_line": 1334,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002289901534234028,
            "pseudo_dstar_susp": 0.00023986567522187575,
            "pseudo_tarantula_susp": 0.0003450655624568668,
            "pseudo_op2_susp": 0.00023986567522187575,
            "pseudo_barinel_susp": 0.00034494653328734045
        }
    },
    {
        "name": "lib.matplotlib.dates.AutoDateLocator.nonsingular#1344",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.AutoDateLocator",
        "signature": "lib.matplotlib.dates.AutoDateLocator.nonsingular(self, vmin, vmax)",
        "snippet": "    def nonsingular(self, vmin, vmax):\n        # whatever is thrown at us, we can scale the unit.\n        # But default nonsingular date plots at an ~4 year period.\n        if not np.isfinite(vmin) or not np.isfinite(vmax):\n            # Except if there is no data, then use 2000-2010 as default.\n            return (date2num(datetime.date(2000, 1, 1)),\n                    date2num(datetime.date(2010, 1, 1)))\n        if vmax < vmin:\n            vmin, vmax = vmax, vmin\n        if vmin == vmax:\n            vmin = vmin - DAYS_PER_YEAR * 2\n            vmax = vmax + DAYS_PER_YEAR * 2\n        return vmin, vmax",
        "begin_line": 1344,
        "end_line": 1356,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.dates.AutoDateLocator.set_axis#1358",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.AutoDateLocator",
        "signature": "lib.matplotlib.dates.AutoDateLocator.set_axis(self, axis)",
        "snippet": "    def set_axis(self, axis):\n        DateLocator.set_axis(self, axis)\n        self._locator.set_axis(axis)",
        "begin_line": 1358,
        "end_line": 1360,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000213857998289136,
            "pseudo_dstar_susp": 0.00019904458598726116,
            "pseudo_tarantula_susp": 0.000253613999492772,
            "pseudo_op2_susp": 0.00019904458598726116,
            "pseudo_barinel_susp": 0.000253613999492772
        }
    },
    {
        "name": "lib.matplotlib.dates.AutoDateLocator.refresh#1362",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.AutoDateLocator",
        "signature": "lib.matplotlib.dates.AutoDateLocator.refresh(self)",
        "snippet": "    def refresh(self):\n        # docstring inherited\n        dmin, dmax = self.viewlim_to_dt()\n        self._locator = self.get_locator(dmin, dmax)",
        "begin_line": 1362,
        "end_line": 1365,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019275250578257516,
            "pseudo_dstar_susp": 0.00019550342130987292,
            "pseudo_tarantula_susp": 0.0002126754572522331,
            "pseudo_op2_susp": 0.00019550342130987292,
            "pseudo_barinel_susp": 0.0002126754572522331
        }
    },
    {
        "name": "lib.matplotlib.dates.AutoDateLocator.get_locator#1380",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.AutoDateLocator",
        "signature": "lib.matplotlib.dates.AutoDateLocator.get_locator(self, dmin, dmax)",
        "snippet": "    def get_locator(self, dmin, dmax):\n        'Pick the best locator based on a distance.'\n        delta = relativedelta(dmax, dmin)\n        tdelta = dmax - dmin\n\n        # take absolute difference\n        if dmin > dmax:\n            delta = -delta\n            tdelta = -tdelta\n\n        # The following uses a mix of calls to relativedelta and timedelta\n        # methods because there is incomplete overlap in the functionality of\n        # these similar functions, and it's best to avoid doing our own math\n        # whenever possible.\n        numYears = float(delta.years)\n        numMonths = numYears * MONTHS_PER_YEAR + delta.months\n        numDays = tdelta.days   # Avoids estimates of days/month, days/year\n        numHours = numDays * HOURS_PER_DAY + delta.hours\n        numMinutes = numHours * MIN_PER_HOUR + delta.minutes\n        numSeconds = np.floor(tdelta.total_seconds())\n        numMicroseconds = np.floor(tdelta.total_seconds() * 1e6)\n\n        nums = [numYears, numMonths, numDays, numHours, numMinutes,\n                numSeconds, numMicroseconds]\n\n        use_rrule_locator = [True] * 6 + [False]\n\n        # Default setting of bymonth, etc. to pass to rrule\n        # [unused (for year), bymonth, bymonthday, byhour, byminute,\n        #  bysecond, unused (for microseconds)]\n        byranges = [None, 1, 1, 0, 0, 0, None]\n\n        # Loop over all the frequencies and try to find one that gives at\n        # least a minticks tick positions.  Once this is found, look for\n        # an interval from an list specific to that frequency that gives no\n        # more than maxticks tick positions. Also, set up some ranges\n        # (bymonth, etc.) as appropriate to be passed to rrulewrapper.\n        for i, (freq, num) in enumerate(zip(self._freqs, nums)):\n            # If this particular frequency doesn't give enough ticks, continue\n            if num < self.minticks:\n                # Since we're not using this particular frequency, set\n                # the corresponding by_ to None so the rrule can act as\n                # appropriate\n                byranges[i] = None\n                continue\n\n            # Find the first available interval that doesn't give too many\n            # ticks\n            for interval in self.intervald[freq]:\n                if num <= interval * (self.maxticks[freq] - 1):\n                    break\n            else:\n                # We went through the whole loop without breaking, default to\n                # the last interval in the list and raise a warning\n                cbook._warn_external(\n                    f\"AutoDateLocator was unable to pick an appropriate \"\n                    f\"interval for this date range. It may be necessary to \"\n                    f\"add an interval value to the AutoDateLocator's \"\n                    f\"intervald dictionary. Defaulting to {interval}.\")\n\n            # Set some parameters as appropriate\n            self._freq = freq\n\n            if self._byranges[i] and self.interval_multiples:\n                byranges[i] = self._byranges[i][::interval]\n                if i in (DAILY, WEEKLY):\n                    if interval == 14:\n                        # just make first and 15th.  Avoids 30th.\n                        byranges[i] = [1, 15]\n                    elif interval == 7:\n                        byranges[i] = [1, 8, 15, 22]\n\n                interval = 1\n            else:\n                byranges[i] = self._byranges[i]\n            break\n        else:\n            raise ValueError('No sensible date limit could be found in the '\n                             'AutoDateLocator.')\n\n        if (freq == YEARLY) and self.interval_multiples:\n            locator = YearLocator(interval, tz=self.tz)\n        elif use_rrule_locator[i]:\n            _, bymonth, bymonthday, byhour, byminute, bysecond, _ = byranges\n            rrule = rrulewrapper(self._freq, interval=interval,\n                                 dtstart=dmin, until=dmax,\n                                 bymonth=bymonth, bymonthday=bymonthday,\n                                 byhour=byhour, byminute=byminute,\n                                 bysecond=bysecond)\n\n            locator = RRuleLocator(rrule, self.tz)\n        else:\n            locator = MicrosecondLocator(interval, tz=self.tz)\n            if dmin.year > 20 and interval < 1000:\n                cbook._warn_external(\n                    'Plotting microsecond time intervals is not well '\n                    'supported; please see the MicrosecondLocator '\n                    'documentation for details.')\n\n        locator.set_axis(self.axis)\n\n        if self.axis is not None:\n            locator.set_view_interval(*self.axis.get_view_interval())\n            locator.set_data_interval(*self.axis.get_data_interval())\n        return locator",
        "begin_line": 1380,
        "end_line": 1484,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00024372410431391665,
            "pseudo_dstar_susp": 0.0002361275088547816,
            "pseudo_tarantula_susp": 0.0002617801047120419,
            "pseudo_op2_susp": 0.0002361275088547816,
            "pseudo_barinel_susp": 0.0002615746795710175
        }
    },
    {
        "name": "lib.matplotlib.dates.YearLocator.__init__#1499",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.YearLocator",
        "signature": "lib.matplotlib.dates.YearLocator.__init__(self, base=1, month=1, day=1, tz=None)",
        "snippet": "    def __init__(self, base=1, month=1, day=1, tz=None):\n        \"\"\"\n        Mark years that are multiple of base on a given month and day\n        (default jan 1).\n        \"\"\"\n        DateLocator.__init__(self, tz)\n        self.base = ticker._Edge_integer(base, 0)\n        self.replaced = {'month':  month,\n                         'day':    day,\n                         'hour':   0,\n                         'minute': 0,\n                         'second': 0,\n                         }\n        if not hasattr(tz, 'localize'):\n            # if tz is pytz, we need to do this w/ the localize fcn,\n            # otherwise datetime.replace works fine...\n            self.replaced['tzinfo'] = tz",
        "begin_line": 1499,
        "end_line": 1515,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022547914317925591,
            "pseudo_dstar_susp": 0.00023963575365444525,
            "pseudo_tarantula_susp": 0.00020807324178110696,
            "pseudo_op2_susp": 0.00023963575365444525,
            "pseudo_barinel_susp": 0.00020807324178110696
        }
    },
    {
        "name": "lib.matplotlib.dates.YearLocator.__call__#1517",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.YearLocator",
        "signature": "lib.matplotlib.dates.YearLocator.__call__(self)",
        "snippet": "    def __call__(self):\n        # if no data have been set, this will tank with a ValueError\n        try:\n            dmin, dmax = self.viewlim_to_dt()\n        except ValueError:\n            return []\n\n        return self.tick_values(dmin, dmax)",
        "begin_line": 1517,
        "end_line": 1524,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012998830105290525,
            "pseudo_dstar_susp": 0.0001364815067558346,
            "pseudo_tarantula_susp": 0.00016488046166529267,
            "pseudo_op2_susp": 0.0001364815067558346,
            "pseudo_barinel_susp": 0.00016482610845557937
        }
    },
    {
        "name": "lib.matplotlib.dates.YearLocator.tick_values#1526",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.YearLocator",
        "signature": "lib.matplotlib.dates.YearLocator.tick_values(self, vmin, vmax)",
        "snippet": "    def tick_values(self, vmin, vmax):\n        ymin = self.base.le(vmin.year) * self.base.step\n        ymax = self.base.ge(vmax.year) * self.base.step\n\n        vmin = vmin.replace(year=ymin, **self.replaced)\n        if hasattr(self.tz, 'localize'):\n            # look after pytz\n            if not vmin.tzinfo:\n                vmin = self.tz.localize(vmin, is_dst=True)\n\n        ticks = [vmin]\n\n        while True:\n            dt = ticks[-1]\n            if dt.year >= ymax:\n                return date2num(ticks)\n            year = dt.year + self.base.step\n            dt = dt.replace(year=year, **self.replaced)\n            if hasattr(self.tz, 'localize'):\n                # look after pytz\n                if not dt.tzinfo:\n                    dt = self.tz.localize(dt, is_dst=True)\n\n            ticks.append(dt)",
        "begin_line": 1526,
        "end_line": 1549,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.0001364815067558346,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0001364815067558346,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.dates.MinuteLocator.__init__#1673",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.MinuteLocator",
        "signature": "lib.matplotlib.dates.MinuteLocator.__init__(self, byminute=None, interval=1, tz=None)",
        "snippet": "    def __init__(self, byminute=None, interval=1, tz=None):\n        \"\"\"\n        Mark every minute in *byminute*; *byminute* can be an int or\n        sequence.  Default is to tick every minute: ``byminute=range(60)``\n\n        *interval* is the interval between each iteration.  For\n        example, if ``interval=2``, mark every second occurrence.\n        \"\"\"\n        if byminute is None:\n            byminute = range(60)\n\n        rule = rrulewrapper(MINUTELY, byminute=byminute, interval=interval,\n                            bysecond=0)\n        RRuleLocator.__init__(self, rule, tz)",
        "begin_line": 1673,
        "end_line": 1686,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.dates.MicrosecondLocator.set_axis#1738",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.MicrosecondLocator",
        "signature": "lib.matplotlib.dates.MicrosecondLocator.set_axis(self, axis)",
        "snippet": "    def set_axis(self, axis):\n        self._wrapped_locator.set_axis(axis)\n        return DateLocator.set_axis(self, axis)",
        "begin_line": 1738,
        "end_line": 1740,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011859582542694497,
            "pseudo_dstar_susp": 0.00011637379262190155,
            "pseudo_tarantula_susp": 0.000129315918789603,
            "pseudo_op2_susp": 0.00011637379262190155,
            "pseudo_barinel_susp": 0.000129315918789603
        }
    },
    {
        "name": "lib.matplotlib.dates.MicrosecondLocator.set_view_interval#1742",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.MicrosecondLocator",
        "signature": "lib.matplotlib.dates.MicrosecondLocator.set_view_interval(self, vmin, vmax)",
        "snippet": "    def set_view_interval(self, vmin, vmax):\n        self._wrapped_locator.set_view_interval(vmin, vmax)\n        return DateLocator.set_view_interval(self, vmin, vmax)",
        "begin_line": 1742,
        "end_line": 1744,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011859582542694497,
            "pseudo_dstar_susp": 0.00011637379262190155,
            "pseudo_tarantula_susp": 0.000129315918789603,
            "pseudo_op2_susp": 0.00011637379262190155,
            "pseudo_barinel_susp": 0.000129315918789603
        }
    },
    {
        "name": "lib.matplotlib.dates.MicrosecondLocator.set_data_interval#1746",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.MicrosecondLocator",
        "signature": "lib.matplotlib.dates.MicrosecondLocator.set_data_interval(self, vmin, vmax)",
        "snippet": "    def set_data_interval(self, vmin, vmax):\n        self._wrapped_locator.set_data_interval(vmin, vmax)\n        return DateLocator.set_data_interval(self, vmin, vmax)",
        "begin_line": 1746,
        "end_line": 1748,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.dates.MicrosecondLocator.__call__#1750",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.MicrosecondLocator",
        "signature": "lib.matplotlib.dates.MicrosecondLocator.__call__(self)",
        "snippet": "    def __call__(self):\n        # if no data have been set, this will tank with a ValueError\n        try:\n            dmin, dmax = self.viewlim_to_dt()\n        except ValueError:\n            return []\n\n        return self.tick_values(dmin, dmax)",
        "begin_line": 1750,
        "end_line": 1757,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.dates.MicrosecondLocator.tick_values#1759",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.MicrosecondLocator",
        "signature": "lib.matplotlib.dates.MicrosecondLocator.tick_values(self, vmin, vmax)",
        "snippet": "    def tick_values(self, vmin, vmax):\n        nmin, nmax = date2num((vmin, vmax))\n        nmin *= MUSECONDS_PER_DAY\n        nmax *= MUSECONDS_PER_DAY\n        ticks = self._wrapped_locator.tick_values(nmin, nmax)\n        ticks = [tick / MUSECONDS_PER_DAY for tick in ticks]\n        return ticks",
        "begin_line": 1759,
        "end_line": 1765,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.dates.DateConverter.axisinfo#1896",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.DateConverter",
        "signature": "lib.matplotlib.dates.DateConverter.axisinfo(unit, axis)",
        "snippet": "    def axisinfo(unit, axis):\n        \"\"\"\n        Return the `~matplotlib.units.AxisInfo` for *unit*.\n\n        *unit* is a tzinfo instance or None.\n        The *axis* argument is required but not used.\n        \"\"\"\n        tz = unit\n\n        majloc = AutoDateLocator(tz=tz)\n        majfmt = AutoDateFormatter(majloc, tz=tz)\n        datemin = datetime.date(2000, 1, 1)\n        datemax = datetime.date(2010, 1, 1)\n\n        return units.AxisInfo(majloc=majloc, majfmt=majfmt, label='',\n                              default_limits=(datemin, datemax))",
        "begin_line": 1896,
        "end_line": 1911,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021422450728363326,
            "pseudo_dstar_susp": 0.00019619383951343929,
            "pseudo_tarantula_susp": 0.00027210884353741496,
            "pseudo_op2_susp": 0.00019619383951343929,
            "pseudo_barinel_susp": 0.0002720348204570185
        }
    },
    {
        "name": "lib.matplotlib.dates.DateConverter.convert#1914",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.DateConverter",
        "signature": "lib.matplotlib.dates.DateConverter.convert(value, unit, axis)",
        "snippet": "    def convert(value, unit, axis):\n        \"\"\"\n        If *value* is not already a number or sequence of numbers, convert it\n        with `date2num`.\n\n        The *unit* and *axis* arguments are not used.\n        \"\"\"\n        return date2num(value)",
        "begin_line": 1914,
        "end_line": 1921,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.dates.DateConverter.default_units#1924",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.DateConverter",
        "signature": "lib.matplotlib.dates.DateConverter.default_units(x, axis)",
        "snippet": "    def default_units(x, axis):\n        \"\"\"\n        Return the tzinfo instance of *x* or of its first element, or None\n        \"\"\"\n        if isinstance(x, np.ndarray):\n            x = x.ravel()\n\n        try:\n            x = cbook.safe_first_element(x)\n        except (TypeError, StopIteration):\n            pass\n\n        try:\n            return x.tzinfo\n        except AttributeError:\n            pass\n        return None",
        "begin_line": 1924,
        "end_line": 1940,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019007793195210037,
            "pseudo_dstar_susp": 0.0001953506544246923,
            "pseudo_tarantula_susp": 0.00021701388888888888,
            "pseudo_op2_susp": 0.0001953506544246923,
            "pseudo_barinel_susp": 0.00021701388888888888
        }
    },
    {
        "name": "lib.matplotlib.scale.ScaleBase.__init__#43",
        "src_path": "lib/matplotlib/scale.py",
        "class_name": "lib.matplotlib.scale.ScaleBase",
        "signature": "lib.matplotlib.scale.ScaleBase.__init__(self, axis, **kwargs)",
        "snippet": "    def __init__(self, axis, **kwargs):\n        r\"\"\"\n        Construct a new scale.\n\n        Notes\n        -----\n        The following note is for scale implementors.\n\n        For back-compatibility reasons, scales take an `~matplotlib.axis.Axis`\n        object as first argument.  However, this argument should not\n        be used: a single scale object should be usable by multiple\n        `~matplotlib.axis.Axis`\\es at the same time.\n        \"\"\"\n        if kwargs:\n            warn_deprecated(\n                '3.2.0',\n                message=(\n                    f\"ScaleBase got an unexpected keyword \"\n                    f\"argument {next(iter(kwargs))!r}. \"\n                    'In the future this will raise TypeError')\n            )",
        "begin_line": 43,
        "end_line": 63,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004578754578754579,
            "pseudo_dstar_susp": 0.0006747638326585695,
            "pseudo_tarantula_susp": 0.00013114754098360657,
            "pseudo_op2_susp": 0.0006747638326585695,
            "pseudo_barinel_susp": 0.00013114754098360657
        }
    },
    {
        "name": "lib.matplotlib.scale.ScaleBase.limit_range_for_scale#79",
        "src_path": "lib/matplotlib/scale.py",
        "class_name": "lib.matplotlib.scale.ScaleBase",
        "signature": "lib.matplotlib.scale.ScaleBase.limit_range_for_scale(self, vmin, vmax, minpos)",
        "snippet": "    def limit_range_for_scale(self, vmin, vmax, minpos):\n        \"\"\"\n        Returns the range *vmin*, *vmax*, possibly limited to the\n        domain supported by this scale.\n\n        *minpos* should be the minimum positive value in the data.\n        This is used by log scales to determine a minimum value.\n        \"\"\"\n        return vmin, vmax",
        "begin_line": 79,
        "end_line": 87,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00036075036075036075,
            "pseudo_dstar_susp": 0.0005694760820045558,
            "pseudo_tarantula_susp": 0.00013570362328674176,
            "pseudo_op2_susp": 0.0005694760820045558,
            "pseudo_barinel_susp": 0.00013570362328674176
        }
    },
    {
        "name": "lib.matplotlib.scale.LinearScale.set_default_locators_and_formatters#105",
        "src_path": "lib/matplotlib/scale.py",
        "class_name": "lib.matplotlib.scale.LinearScale",
        "signature": "lib.matplotlib.scale.LinearScale.set_default_locators_and_formatters(self, axis)",
        "snippet": "    def set_default_locators_and_formatters(self, axis):\n        # docstring inherited\n        axis.set_major_locator(AutoLocator())\n        axis.set_major_formatter(ScalarFormatter())\n        axis.set_minor_formatter(NullFormatter())\n        # update the minor locator for x and y axis based on rcParams\n        if (axis.axis_name == 'x' and rcParams['xtick.minor.visible']\n            or axis.axis_name == 'y' and rcParams['ytick.minor.visible']):\n            axis.set_minor_locator(AutoMinorLocator())\n        else:\n            axis.set_minor_locator(NullLocator())",
        "begin_line": 105,
        "end_line": 115,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006238303181534623,
            "pseudo_dstar_susp": 0.0007942811755361397,
            "pseudo_tarantula_susp": 0.00015188335358444713,
            "pseudo_op2_susp": 0.0007942811755361397,
            "pseudo_barinel_susp": 0.00015188335358444713
        }
    },
    {
        "name": "lib.matplotlib.scale.LogTransform.__init__#281",
        "src_path": "lib/matplotlib/scale.py",
        "class_name": "lib.matplotlib.scale.LogTransform",
        "signature": "lib.matplotlib.scale.LogTransform.__init__(self, base, nonpos='clip')",
        "snippet": "    def __init__(self, base, nonpos='clip'):\n        Transform.__init__(self)\n        self.base = base\n        self._clip = {\"clip\": True, \"mask\": False}[nonpos]",
        "begin_line": 281,
        "end_line": 284,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001165365342034728,
            "pseudo_dstar_susp": 0.00011516756881262236,
            "pseudo_tarantula_susp": 0.00012236906510034264,
            "pseudo_op2_susp": 0.00011516756881262236,
            "pseudo_barinel_susp": 0.00012232415902140674
        }
    },
    {
        "name": "lib.matplotlib.scale.LogTransform.inverted#312",
        "src_path": "lib/matplotlib/scale.py",
        "class_name": "lib.matplotlib.scale.LogTransform",
        "signature": "lib.matplotlib.scale.LogTransform.inverted(self)",
        "snippet": "    def inverted(self):\n        return InvertedLogTransform(self.base)",
        "begin_line": 312,
        "end_line": 313,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001165365342034728,
            "pseudo_dstar_susp": 0.00011516756881262236,
            "pseudo_tarantula_susp": 0.00012236906510034264,
            "pseudo_op2_susp": 0.00011516756881262236,
            "pseudo_barinel_susp": 0.00012232415902140674
        }
    },
    {
        "name": "lib.matplotlib.scale.LogScale.__init__#350",
        "src_path": "lib/matplotlib/scale.py",
        "class_name": "lib.matplotlib.scale.LogScale",
        "signature": "lib.matplotlib.scale.LogScale.__init__(self, axis, **kwargs)",
        "snippet": "    def __init__(self, axis, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        axis : `~matplotlib.axis.Axis`\n            The axis for the scale.\n        basex, basey : float, default: 10\n            The base of the logarithm.\n        nonposx, nonposy : {'clip', 'mask'}, default: 'clip'\n            Determines the behavior for non-positive values. They can either\n            be masked as invalid, or clipped to a very small positive number.\n        subsx, subsy : sequence of int, default: None\n            Where to place the subticks between each major tick.\n            For example, in a log10 scale: ``[2, 3, 4, 5, 6, 7, 8, 9]``\n            will place 8 logarithmically spaced minor ticks between\n            each major tick.\n        \"\"\"\n        if axis.axis_name == 'x':\n            base = kwargs.pop('basex', 10.0)\n            subs = kwargs.pop('subsx', None)\n            nonpos = kwargs.pop('nonposx', 'clip')\n            cbook._check_in_list(['mask', 'clip'], nonposx=nonpos)\n        else:\n            base = kwargs.pop('basey', 10.0)\n            subs = kwargs.pop('subsy', None)\n            nonpos = kwargs.pop('nonposy', 'clip')\n            cbook._check_in_list(['mask', 'clip'], nonposy=nonpos)\n\n        if kwargs:\n            raise TypeError(f\"LogScale got an unexpected keyword \"\n                            f\"argument {next(iter(kwargs))!r}\")\n\n        if base <= 0 or base == 1:\n            raise ValueError('The log base cannot be <= 0 or == 1')\n\n        self._transform = LogTransform(base, nonpos)\n        self.subs = subs",
        "begin_line": 350,
        "end_line": 386,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.scale.SymmetricalLogTransform.__init__#456",
        "src_path": "lib/matplotlib/scale.py",
        "class_name": "lib.matplotlib.scale.SymmetricalLogTransform",
        "signature": "lib.matplotlib.scale.SymmetricalLogTransform.__init__(self, base, linthresh, linscale)",
        "snippet": "    def __init__(self, base, linthresh, linscale):\n        Transform.__init__(self)\n        self.base = base\n        self.linthresh = linthresh\n        self.linscale = linscale\n        self._linscale_adj = (linscale / (1.0 - self.base ** -1))\n        self._log_base = np.log(base)",
        "begin_line": 456,
        "end_line": 462,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.scale.SymmetricalLogTransform.transform_non_affine#464",
        "src_path": "lib/matplotlib/scale.py",
        "class_name": "lib.matplotlib.scale.SymmetricalLogTransform",
        "signature": "lib.matplotlib.scale.SymmetricalLogTransform.transform_non_affine(self, a)",
        "snippet": "    def transform_non_affine(self, a):\n        abs_a = np.abs(a)\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            out = np.sign(a) * self.linthresh * (\n                self._linscale_adj +\n                np.log(abs_a / self.linthresh) / self._log_base)\n            inside = abs_a <= self.linthresh\n        out[inside] = a[inside] * self._linscale_adj\n        return out",
        "begin_line": 464,
        "end_line": 472,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.scale.InvertedSymmetricalLogTransform.__init__#482",
        "src_path": "lib/matplotlib/scale.py",
        "class_name": "lib.matplotlib.scale.InvertedSymmetricalLogTransform",
        "signature": "lib.matplotlib.scale.InvertedSymmetricalLogTransform.__init__(self, base, linthresh, linscale)",
        "snippet": "    def __init__(self, base, linthresh, linscale):\n        Transform.__init__(self)\n        symlog = SymmetricalLogTransform(base, linthresh, linscale)\n        self.base = base\n        self.linthresh = linthresh\n        self.invlinthresh = symlog.transform(linthresh)\n        self.linscale = linscale\n        self._linscale_adj = (linscale / (1.0 - self.base ** -1))",
        "begin_line": 482,
        "end_line": 489,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.scale.InvertedSymmetricalLogTransform.transform_non_affine#491",
        "src_path": "lib/matplotlib/scale.py",
        "class_name": "lib.matplotlib.scale.InvertedSymmetricalLogTransform",
        "signature": "lib.matplotlib.scale.InvertedSymmetricalLogTransform.transform_non_affine(self, a)",
        "snippet": "    def transform_non_affine(self, a):\n        abs_a = np.abs(a)\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            out = np.sign(a) * self.linthresh * (\n                np.power(self.base,\n                         abs_a / self.linthresh - self._linscale_adj))\n            inside = abs_a <= self.invlinthresh\n        out[inside] = a[inside] / self._linscale_adj\n        return out",
        "begin_line": 491,
        "end_line": 499,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.scale.SymmetricalLogScale.__init__#543",
        "src_path": "lib/matplotlib/scale.py",
        "class_name": "lib.matplotlib.scale.SymmetricalLogScale",
        "signature": "lib.matplotlib.scale.SymmetricalLogScale.__init__(self, axis, **kwargs)",
        "snippet": "    def __init__(self, axis, **kwargs):\n        if axis.axis_name == 'x':\n            base = kwargs.pop('basex', 10.0)\n            linthresh = kwargs.pop('linthreshx', 2.0)\n            subs = kwargs.pop('subsx', None)\n            linscale = kwargs.pop('linscalex', 1.0)\n        else:\n            base = kwargs.pop('basey', 10.0)\n            linthresh = kwargs.pop('linthreshy', 2.0)\n            subs = kwargs.pop('subsy', None)\n            linscale = kwargs.pop('linscaley', 1.0)\n        if kwargs:\n            warn_deprecated(\n                '3.2.0',\n                message=(\n                    f\"SymmetricalLogScale got an unexpected keyword \"\n                    f\"argument {next(iter(kwargs))!r}. \"\n                    'In the future this will raise TypeError')\n            )\n            # raise TypeError(f\"SymmetricalLogScale got an unexpected keyword \"\n            #                 f\"argument {next(iter(kwargs))!r}\")\n\n        if base <= 1.0:\n            raise ValueError(\"'basex/basey' must be larger than 1\")\n        if linthresh <= 0.0:\n            raise ValueError(\"'linthreshx/linthreshy' must be positive\")\n        if linscale <= 0.0:\n            raise ValueError(\"'linscalex/linthreshy' must be positive\")\n\n        self._transform = SymmetricalLogTransform(base, linthresh, linscale)\n        self.base = base\n        self.linthresh = linthresh\n        self.linscale = linscale\n        self.subs = subs",
        "begin_line": 543,
        "end_line": 576,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.scale.LogitScale.set_default_locators_and_formatters#674",
        "src_path": "lib/matplotlib/scale.py",
        "class_name": "lib.matplotlib.scale.LogitScale",
        "signature": "lib.matplotlib.scale.LogitScale.set_default_locators_and_formatters(self, axis)",
        "snippet": "    def set_default_locators_and_formatters(self, axis):\n        # docstring inherited\n        # ..., 0.01, 0.1, 0.5, 0.9, 0.99, ...\n        axis.set_major_locator(LogitLocator())\n        axis.set_major_formatter(\n            LogitFormatter(\n                one_half=self._one_half,\n                use_overline=self._use_overline\n            )\n        )\n        axis.set_minor_locator(LogitLocator(minor=True))\n        axis.set_minor_formatter(\n            LogitFormatter(\n                minor=True,\n                one_half=self._one_half,\n                use_overline=self._use_overline\n            )\n        )",
        "begin_line": 674,
        "end_line": 691,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.scale.scale_factory#718",
        "src_path": "lib/matplotlib/scale.py",
        "class_name": "lib.matplotlib.scale",
        "signature": "lib.matplotlib.scale.scale_factory(scale, axis, **kwargs)",
        "snippet": "def scale_factory(scale, axis, **kwargs):\n    \"\"\"\n    Return a scale class by name.\n\n    Parameters\n    ----------\n    scale : {%(names)s}\n    axis : `matplotlib.axis.Axis`\n    \"\"\"\n    scale = scale.lower()\n    cbook._check_in_list(_scale_mapping, scale=scale)\n    return _scale_mapping[scale](axis, **kwargs)",
        "begin_line": 718,
        "end_line": 729,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018463810930576072,
            "pseudo_dstar_susp": 0.00019109497420217848,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00019109497420217848,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.path.Path.__init__#96",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.__init__(self, vertices, codes=None, _interpolation_steps=1, closed=False, readonly=False)",
        "snippet": "    def __init__(self, vertices, codes=None, _interpolation_steps=1,\n                 closed=False, readonly=False):\n        \"\"\"\n        Create a new path with the given vertices and codes.\n\n        Parameters\n        ----------\n        vertices : array-like\n            The ``(N, 2)`` float array, masked array or sequence of pairs\n            representing the vertices of the path.\n\n            If *vertices* contains masked values, they will be converted\n            to NaNs which are then handled correctly by the Agg\n            PathIterator and other consumers of path data, such as\n            :meth:`iter_segments`.\n        codes : array-like or None, optional\n            n-length array integers representing the codes of the path.\n            If not None, codes must be the same length as vertices.\n            If None, *vertices* will be treated as a series of line segments.\n        _interpolation_steps : int, optional\n            Used as a hint to certain projections, such as Polar, that this\n            path should be linearly interpolated immediately before drawing.\n            This attribute is primarily an implementation detail and is not\n            intended for public use.\n        closed : bool, optional\n            If *codes* is None and closed is True, vertices will be treated as\n            line segments of a closed polygon.\n        readonly : bool, optional\n            Makes the path behave in an immutable way and sets the vertices\n            and codes as read-only arrays.\n        \"\"\"\n        vertices = _to_unmasked_float_array(vertices)\n        if vertices.ndim != 2 or vertices.shape[1] != 2:\n            raise ValueError(\n                \"'vertices' must be a 2D list or array with shape Nx2\")\n\n        if codes is not None:\n            codes = np.asarray(codes, self.code_type)\n            if codes.ndim != 1 or len(codes) != len(vertices):\n                raise ValueError(\"'codes' must be a 1D list or array with the \"\n                                 \"same length of 'vertices'\")\n            if len(codes) and codes[0] != self.MOVETO:\n                raise ValueError(\"The first element of 'code' must be equal \"\n                                 \"to 'MOVETO' ({})\".format(self.MOVETO))\n        elif closed and len(vertices):\n            codes = np.empty(len(vertices), dtype=self.code_type)\n            codes[0] = self.MOVETO\n            codes[1:-1] = self.LINETO\n            codes[-1] = self.CLOSEPOLY\n\n        self._vertices = vertices\n        self._codes = codes\n        self._interpolation_steps = _interpolation_steps\n        self._update_values()\n\n        if readonly:\n            self._vertices.flags.writeable = False\n            if self._codes is not None:\n                self._codes.flags.writeable = False\n            self._readonly = True\n        else:\n            self._readonly = False",
        "begin_line": 96,
        "end_line": 157,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007507507507507507,
            "pseudo_dstar_susp": 0.0020491803278688526,
            "pseudo_tarantula_susp": 0.00021528525296017224,
            "pseudo_op2_susp": 0.0020491803278688526,
            "pseudo_barinel_susp": 0.00021528525296017224
        }
    },
    {
        "name": "lib.matplotlib.path.Path._fast_from_codes_and_verts#160",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path._fast_from_codes_and_verts(cls, verts, codes, internals_from=None)",
        "snippet": "    def _fast_from_codes_and_verts(cls, verts, codes, internals_from=None):\n        \"\"\"\n        Creates a Path instance without the expense of calling the constructor.\n\n        Parameters\n        ----------\n        verts : numpy array\n        codes : numpy array\n        internals_from : Path or None\n            If not None, another `Path` from which the attributes\n            ``should_simplify``, ``simplify_threshold``, and\n            ``interpolation_steps`` will be copied.  Note that ``readonly`` is\n            never copied, and always set to ``False`` by this constructor.\n        \"\"\"\n        pth = cls.__new__(cls)\n        pth._vertices = _to_unmasked_float_array(verts)\n        pth._codes = codes\n        pth._readonly = False\n        if internals_from is not None:\n            pth._should_simplify = internals_from._should_simplify\n            pth._simplify_threshold = internals_from._simplify_threshold\n            pth._interpolation_steps = internals_from._interpolation_steps\n        else:\n            pth._should_simplify = True\n            pth._simplify_threshold = rcParams['path.simplify_threshold']\n            pth._interpolation_steps = 1\n        return pth",
        "begin_line": 160,
        "end_line": 186,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007262164124909223,
            "pseudo_dstar_susp": 0.0017921146953405018,
            "pseudo_tarantula_susp": 0.00020933640360058616,
            "pseudo_op2_susp": 0.0017921146953405018,
            "pseudo_barinel_susp": 0.00020933640360058616
        }
    },
    {
        "name": "lib.matplotlib.path.Path._update_values#188",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path._update_values(self)",
        "snippet": "    def _update_values(self):\n        self._simplify_threshold = rcParams['path.simplify_threshold']\n        self._should_simplify = (\n            self._simplify_threshold > 0 and\n            rcParams['path.simplify'] and\n            len(self._vertices) >= 128 and\n            (self._codes is None or np.all(self._codes <= Path.LINETO))\n        )",
        "begin_line": 188,
        "end_line": 195,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019712201852946975,
            "pseudo_dstar_susp": 0.000297000297000297,
            "pseudo_tarantula_susp": 0.00012042389210019268,
            "pseudo_op2_susp": 0.000297000297000297,
            "pseudo_barinel_susp": 0.00012042389210019268
        }
    },
    {
        "name": "lib.matplotlib.path.Path.vertices#198",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.vertices(self)",
        "snippet": "    def vertices(self):\n        \"\"\"\n        The list of vertices in the `Path` as an Nx2 numpy array.\n        \"\"\"\n        return self._vertices",
        "begin_line": 198,
        "end_line": 202,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00014068655036578504,
            "pseudo_dstar_susp": 0.0002051702913418137,
            "pseudo_tarantula_susp": 0.0001188495364868077,
            "pseudo_op2_susp": 0.0002051702913418137,
            "pseudo_barinel_susp": 0.0001188495364868077
        }
    },
    {
        "name": "lib.matplotlib.path.Path.codes#212",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.codes(self)",
        "snippet": "    def codes(self):\n        \"\"\"\n        The list of codes in the `Path` as a 1-D numpy array.  Each\n        code is one of `STOP`, `MOVETO`, `LINETO`, `CURVE3`, `CURVE4`\n        or `CLOSEPOLY`.  For codes that correspond to more than one\n        vertex (`CURVE3` and `CURVE4`), that code will be repeated so\n        that the length of `self.vertices` and `self.codes` is always\n        the same.\n        \"\"\"\n        return self._codes",
        "begin_line": 212,
        "end_line": 221,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005681818181818182,
            "pseudo_dstar_susp": 0.007246376811594203,
            "pseudo_tarantula_susp": 0.00023430178069353328,
            "pseudo_op2_susp": 0.007246376811594203,
            "pseudo_barinel_susp": 0.00023430178069353328
        }
    },
    {
        "name": "lib.matplotlib.path.Path.simplify_threshold#231",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.simplify_threshold(self)",
        "snippet": "    def simplify_threshold(self):\n        \"\"\"\n        The fraction of a pixel difference below which vertices will\n        be simplified out.\n        \"\"\"\n        return self._simplify_threshold",
        "begin_line": 231,
        "end_line": 236,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.015384615384615385,
            "pseudo_dstar_susp": 0.023809523809523808,
            "pseudo_tarantula_susp": 0.0002641310089804543,
            "pseudo_op2_susp": 0.023809523809523808,
            "pseudo_barinel_susp": 0.0002641310089804543
        }
    },
    {
        "name": "lib.matplotlib.path.Path.should_simplify#252",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.should_simplify(self)",
        "snippet": "    def should_simplify(self):\n        \"\"\"\n        `True` if the vertices array should be simplified.\n        \"\"\"\n        return self._should_simplify",
        "begin_line": 252,
        "end_line": 256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001218026796589525,
            "pseudo_dstar_susp": 0.0016891891891891893,
            "pseudo_tarantula_susp": 0.00039761431411530816,
            "pseudo_op2_susp": 0.0016891891891891893,
            "pseudo_barinel_susp": 0.00039761431411530816
        }
    },
    {
        "name": "lib.matplotlib.path.Path.iter_segments#354",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.iter_segments(self, transform=None, remove_nans=True, clip=None, snap=False, stroke_width=1.0, simplify=None, curves=True, sketch=None)",
        "snippet": "    def iter_segments(self, transform=None, remove_nans=True, clip=None,\n                      snap=False, stroke_width=1.0, simplify=None,\n                      curves=True, sketch=None):\n        \"\"\"\n        Iterates over all of the curve segments in the path.  Each iteration\n        returns a 2-tuple ``(vertices, code)``, where ``vertices`` is a\n        sequence of 1-3 coordinate pairs, and ``code`` is a `Path` code.\n\n        Additionally, this method can provide a number of standard cleanups and\n        conversions to the path.\n\n        Parameters\n        ----------\n        transform : None or :class:`~matplotlib.transforms.Transform`\n            If not None, the given affine transformation will be applied to the\n            path.\n        remove_nans : bool, optional\n            Whether to remove all NaNs from the path and skip over them using\n            MOVETO commands.\n        clip : None or (float, float, float, float), optional\n            If not None, must be a four-tuple (x1, y1, x2, y2)\n            defining a rectangle in which to clip the path.\n        snap : None or bool, optional\n            If True, snap all nodes to pixels; if False, don't snap them.\n            If None, perform snapping if the path contains only segments\n            parallel to the x or y axes, and no more than 1024 of them.\n        stroke_width : float, optional\n            The width of the stroke being drawn (used for path snapping).\n        simplify : None or bool, optional\n            Whether to simplify the path by removing vertices\n            that do not affect its appearance.  If None, use the\n            :attr:`should_simplify` attribute.  See also :rc:`path.simplify`\n            and :rc:`path.simplify_threshold`.\n        curves : bool, optional\n            If True, curve segments will be returned as curve segments.\n            If False, all curves will be converted to line segments.\n        sketch : None or sequence, optional\n            If not None, must be a 3-tuple of the form\n            (scale, length, randomness), representing the sketch parameters.\n        \"\"\"\n        if not len(self):\n            return\n\n        cleaned = self.cleaned(transform=transform,\n                               remove_nans=remove_nans, clip=clip,\n                               snap=snap, stroke_width=stroke_width,\n                               simplify=simplify, curves=curves,\n                               sketch=sketch)\n\n        # Cache these object lookups for performance in the loop.\n        NUM_VERTICES_FOR_CODE = self.NUM_VERTICES_FOR_CODE\n        STOP = self.STOP\n\n        vertices = iter(cleaned.vertices)\n        codes = iter(cleaned.codes)\n        for curr_vertices, code in zip(vertices, codes):\n            if code == STOP:\n                break\n            extra_vertices = NUM_VERTICES_FOR_CODE[code] - 1\n            if extra_vertices:\n                for i in range(extra_vertices):\n                    next(codes)\n                    curr_vertices = np.append(curr_vertices, next(vertices))\n            yield curr_vertices, code",
        "begin_line": 354,
        "end_line": 417,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002192982456140351,
            "pseudo_dstar_susp": 0.0002203128442388191,
            "pseudo_tarantula_susp": 0.00022983222247759135,
            "pseudo_op2_susp": 0.0002203128442388191,
            "pseudo_barinel_susp": 0.00022983222247759135
        }
    },
    {
        "name": "lib.matplotlib.path.Path.cleaned#419",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.cleaned(self, transform=None, remove_nans=False, clip=None, quantize=False, simplify=False, curves=False, stroke_width=1.0, snap=False, sketch=None)",
        "snippet": "    def cleaned(self, transform=None, remove_nans=False, clip=None,\n                quantize=False, simplify=False, curves=False,\n                stroke_width=1.0, snap=False, sketch=None):\n        \"\"\"\n        Return a new Path with vertices and codes cleaned according to the\n        parameters.\n\n        See Also\n        --------\n        Path.iter_segments : for details of the keyword arguments.\n        \"\"\"\n        vertices, codes = _path.cleanup_path(\n            self, transform, remove_nans, clip, snap, stroke_width, simplify,\n            curves, sketch)\n        pth = Path._fast_from_codes_and_verts(vertices, codes, self)\n        if not simplify:\n            pth._should_simplify = False\n        return pth",
        "begin_line": 419,
        "end_line": 436,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022301516503122213,
            "pseudo_dstar_susp": 0.00021673168617251842,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.00021673168617251842,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.path.Path.transformed#438",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.transformed(self, transform)",
        "snippet": "    def transformed(self, transform):\n        \"\"\"\n        Return a transformed copy of the path.\n\n        See Also\n        --------\n        matplotlib.transforms.TransformedPath\n            A specialized path class that will cache the transformed result and\n            automatically update when the transform changes.\n        \"\"\"\n        return Path(transform.transform(self.vertices), self.codes,\n                    self._interpolation_steps)",
        "begin_line": 438,
        "end_line": 449,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.path.Path.contains_point#451",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.contains_point(self, point, transform=None, radius=0.0)",
        "snippet": "    def contains_point(self, point, transform=None, radius=0.0):\n        \"\"\"\n        Return whether the (closed) path contains the given point.\n\n        Parameters\n        ----------\n        point : (float, float)\n            The point (x, y) to check.\n        transform : `matplotlib.transforms.Transform`, optional\n            If not ``None``, *point* will be compared to ``self`` transformed\n            by *transform*; i.e. for a correct check, *transform* should\n            transform the path into the coordinate system of *point*.\n        radius : float, default: 0\n            Add an additional margin on the path in coordinates of *point*.\n            The path is extended tangentially by *radius/2*; i.e. if you would\n            draw the path with a linewidth of *radius*, all points on the line\n            would still be considered to be contained in the area. Conversely,\n            negative values shrink the area: Points on the imaginary line\n            will be considered outside the area.\n\n        Returns\n        -------\n        bool\n        \"\"\"\n        if transform is not None:\n            transform = transform.frozen()\n        # `point_in_path` does not handle nonlinear transforms, so we\n        # transform the path ourselves.  If *transform* is affine, letting\n        # `point_in_path` handle the transform avoids allocating an extra\n        # buffer.\n        if transform and not transform.is_affine:\n            self = transform.transform_path(self)\n            transform = None\n        return _path.point_in_path(point[0], point[1], radius, self, transform)",
        "begin_line": 451,
        "end_line": 484,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.path.Path.get_extents#526",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.get_extents(self, transform=None)",
        "snippet": "    def get_extents(self, transform=None):\n        \"\"\"\n        Returns the extents (*xmin*, *ymin*, *xmax*, *ymax*) of the path.\n\n        Unlike computing the extents on the *vertices* alone, this\n        algorithm will take into account the curves and deal with\n        control points appropriately.\n        \"\"\"\n        from .transforms import Bbox\n        path = self\n        if transform is not None:\n            transform = transform.frozen()\n            if not transform.is_affine:\n                path = self.transformed(transform)\n                transform = None\n        return Bbox(_path.get_path_extents(path, transform))",
        "begin_line": 526,
        "end_line": 541,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005399568034557236,
            "pseudo_dstar_susp": 0.00040048057669203043,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00040048057669203043,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.path.Path.intersects_bbox#553",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.intersects_bbox(self, bbox, filled=True)",
        "snippet": "    def intersects_bbox(self, bbox, filled=True):\n        \"\"\"\n        Returns whether this path intersects a given `~.transforms.Bbox`.\n\n        *filled*, when True, treats the path as if it was filled.\n        That is, if the path completely encloses the bounding box,\n        :meth:`intersects_bbox` will return True.\n\n        The bounding box is always considered filled.\n        \"\"\"\n        return _path.path_intersects_rectangle(self,\n            bbox.x0, bbox.y0, bbox.x1, bbox.y1, filled)",
        "begin_line": 553,
        "end_line": 564,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019916351324437363,
            "pseudo_dstar_susp": 0.00018040772145047808,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00018040772145047808,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.path.Path.interpolated#566",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.interpolated(self, steps)",
        "snippet": "    def interpolated(self, steps):\n        \"\"\"\n        Returns a new path resampled to length N x steps.  Does not\n        currently handle interpolating curves.\n        \"\"\"\n        if steps == 1:\n            return self\n\n        vertices = simple_linear_interpolation(self.vertices, steps)\n        codes = self.codes\n        if codes is not None:\n            new_codes = np.full((len(codes) - 1) * steps + 1, Path.LINETO,\n                                dtype=self.code_type)\n            new_codes[0::steps] = codes\n        else:\n            new_codes = None\n        return Path(vertices, new_codes)",
        "begin_line": 566,
        "end_line": 582,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.path.Path.unit_rectangle#631",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.unit_rectangle(cls)",
        "snippet": "    def unit_rectangle(cls):\n        \"\"\"\n        Return a `Path` instance of the unit rectangle from (0, 0) to (1, 1).\n        \"\"\"\n        if cls._unit_rectangle is None:\n            cls._unit_rectangle = \\\n                cls([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0],\n                     [0.0, 0.0]],\n                    [cls.MOVETO, cls.LINETO, cls.LINETO, cls.LINETO,\n                     cls.CLOSEPOLY],\n                    readonly=True)\n        return cls._unit_rectangle",
        "begin_line": 631,
        "end_line": 642,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013315579227696406,
            "pseudo_dstar_susp": 0.0018115942028985507,
            "pseudo_tarantula_susp": 0.00042918454935622315,
            "pseudo_op2_susp": 0.0018115942028985507,
            "pseudo_barinel_susp": 0.00042918454935622315
        }
    },
    {
        "name": "lib.matplotlib.path.Path.unit_regular_polygon#647",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.unit_regular_polygon(cls, numVertices)",
        "snippet": "    def unit_regular_polygon(cls, numVertices):\n        \"\"\"\n        Return a :class:`Path` instance for a unit regular polygon with the\n        given *numVertices* and radius of 1.0, centered at (0, 0).\n        \"\"\"\n        if numVertices <= 16:\n            path = cls._unit_regular_polygons.get(numVertices)\n        else:\n            path = None\n        if path is None:\n            theta = ((2 * np.pi / numVertices) * np.arange(numVertices + 1)\n                     # This initial rotation is to make sure the polygon always\n                     # \"points-up\".\n                     + np.pi / 2)\n            verts = np.column_stack((np.cos(theta), np.sin(theta)))\n            codes = np.empty(numVertices + 1)\n            codes[0] = cls.MOVETO\n            codes[1:-1] = cls.LINETO\n            codes[-1] = cls.CLOSEPOLY\n            path = cls(verts, codes, readonly=True)\n            if numVertices <= 16:\n                cls._unit_regular_polygons[numVertices] = path\n        return path",
        "begin_line": 647,
        "end_line": 669,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.path.Path.unit_regular_star#674",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.unit_regular_star(cls, numVertices, innerCircle=0.5)",
        "snippet": "    def unit_regular_star(cls, numVertices, innerCircle=0.5):\n        \"\"\"\n        Return a :class:`Path` for a unit regular star with the given\n        numVertices and radius of 1.0, centered at (0, 0).\n        \"\"\"\n        if numVertices <= 16:\n            path = cls._unit_regular_stars.get((numVertices, innerCircle))\n        else:\n            path = None\n        if path is None:\n            ns2 = numVertices * 2\n            theta = (2*np.pi/ns2 * np.arange(ns2 + 1))\n            # This initial rotation is to make sure the polygon always\n            # \"points-up\"\n            theta += np.pi / 2.0\n            r = np.ones(ns2 + 1)\n            r[1::2] = innerCircle\n            verts = np.vstack((r*np.cos(theta), r*np.sin(theta))).transpose()\n            codes = np.empty((ns2 + 1,))\n            codes[0] = cls.MOVETO\n            codes[1:-1] = cls.LINETO\n            codes[-1] = cls.CLOSEPOLY\n            path = cls(verts, codes, readonly=True)\n            if numVertices <= 16:\n                cls._unit_regular_stars[(numVertices, innerCircle)] = path\n        return path",
        "begin_line": 674,
        "end_line": 699,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.path.Path.unit_circle#712",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.unit_circle(cls)",
        "snippet": "    def unit_circle(cls):\n        \"\"\"\n        Return the readonly :class:`Path` of the unit circle.\n\n        For most cases, :func:`Path.circle` will be what you want.\n        \"\"\"\n        if cls._unit_circle is None:\n            cls._unit_circle = cls.circle(center=(0, 0), radius=1,\n                                          readonly=True)\n        return cls._unit_circle",
        "begin_line": 712,
        "end_line": 721,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021720243266724586,
            "pseudo_dstar_susp": 0.0002257336343115124,
            "pseudo_tarantula_susp": 0.00021542438604049978,
            "pseudo_op2_susp": 0.0002257336343115124,
            "pseudo_barinel_susp": 0.00021542438604049978
        }
    },
    {
        "name": "lib.matplotlib.path.Path.circle#724",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.circle(cls, center=(0.0, 0.0), radius=1.0, readonly=False)",
        "snippet": "    def circle(cls, center=(0., 0.), radius=1., readonly=False):\n        \"\"\"\n        Return a `Path` representing a circle of a given radius and center.\n\n        Parameters\n        ----------\n        center : pair of floats\n            The center of the circle. Default ``(0, 0)``.\n        radius : float\n            The radius of the circle. Default is 1.\n        readonly : bool\n            Whether the created path should have the \"readonly\" argument\n            set when creating the Path instance.\n\n        Notes\n        -----\n        The circle is approximated using 8 cubic Bezier curves, as described in\n\n          Lancaster, Don.  `Approximating a Circle or an Ellipse Using Four\n          Bezier Cubic Splines <http://www.tinaja.com/glib/ellipse4.pdf>`_.\n        \"\"\"\n        MAGIC = 0.2652031\n        SQRTHALF = np.sqrt(0.5)\n        MAGIC45 = SQRTHALF * MAGIC\n\n        vertices = np.array([[0.0, -1.0],\n\n                             [MAGIC, -1.0],\n                             [SQRTHALF-MAGIC45, -SQRTHALF-MAGIC45],\n                             [SQRTHALF, -SQRTHALF],\n\n                             [SQRTHALF+MAGIC45, -SQRTHALF+MAGIC45],\n                             [1.0, -MAGIC],\n                             [1.0, 0.0],\n\n                             [1.0, MAGIC],\n                             [SQRTHALF+MAGIC45, SQRTHALF-MAGIC45],\n                             [SQRTHALF, SQRTHALF],\n\n                             [SQRTHALF-MAGIC45, SQRTHALF+MAGIC45],\n                             [MAGIC, 1.0],\n                             [0.0, 1.0],\n\n                             [-MAGIC, 1.0],\n                             [-SQRTHALF+MAGIC45, SQRTHALF+MAGIC45],\n                             [-SQRTHALF, SQRTHALF],\n\n                             [-SQRTHALF-MAGIC45, SQRTHALF-MAGIC45],\n                             [-1.0, MAGIC],\n                             [-1.0, 0.0],\n\n                             [-1.0, -MAGIC],\n                             [-SQRTHALF-MAGIC45, -SQRTHALF+MAGIC45],\n                             [-SQRTHALF, -SQRTHALF],\n\n                             [-SQRTHALF+MAGIC45, -SQRTHALF-MAGIC45],\n                             [-MAGIC, -1.0],\n                             [0.0, -1.0],\n\n                             [0.0, -1.0]],\n                            dtype=float)\n\n        codes = [cls.CURVE4] * 26\n        codes[0] = cls.MOVETO\n        codes[-1] = cls.CLOSEPOLY\n        return Path(vertices * radius + center, codes, readonly=readonly)",
        "begin_line": 724,
        "end_line": 789,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.path.Path.arc#836",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.arc(cls, theta1, theta2, n=None, is_wedge=False)",
        "snippet": "    def arc(cls, theta1, theta2, n=None, is_wedge=False):\n        \"\"\"\n        Return the unit circle arc from angles *theta1* to *theta2* (in\n        degrees).\n\n        *theta2* is unwrapped to produce the shortest arc within 360 degrees.\n        That is, if *theta2* > *theta1* + 360, the arc will be from *theta1* to\n        *theta2* - 360 and not a full circle plus some extra overlap.\n\n        If *n* is provided, it is the number of spline segments to make.\n        If *n* is not provided, the number of spline segments is\n        determined based on the delta between *theta1* and *theta2*.\n\n           Masionobe, L.  2003.  `Drawing an elliptical arc using\n           polylines, quadratic or cubic Bezier curves\n           <http://www.spaceroots.org/documents/ellipse/index.html>`_.\n        \"\"\"\n        halfpi = np.pi * 0.5\n\n        eta1 = theta1\n        eta2 = theta2 - 360 * np.floor((theta2 - theta1) / 360)\n        # Ensure 2pi range is not flattened to 0 due to floating-point errors,\n        # but don't try to expand existing 0 range.\n        if theta2 != theta1 and eta2 <= eta1:\n            eta2 += 360\n        eta1, eta2 = np.deg2rad([eta1, eta2])\n\n        # number of curve segments to make\n        if n is None:\n            n = int(2 ** np.ceil((eta2 - eta1) / halfpi))\n        if n < 1:\n            raise ValueError(\"n must be >= 1 or None\")\n\n        deta = (eta2 - eta1) / n\n        t = np.tan(0.5 * deta)\n        alpha = np.sin(deta) * (np.sqrt(4.0 + 3.0 * t * t) - 1) / 3.0\n\n        steps = np.linspace(eta1, eta2, n + 1, True)\n        cos_eta = np.cos(steps)\n        sin_eta = np.sin(steps)\n\n        xA = cos_eta[:-1]\n        yA = sin_eta[:-1]\n        xA_dot = -yA\n        yA_dot = xA\n\n        xB = cos_eta[1:]\n        yB = sin_eta[1:]\n        xB_dot = -yB\n        yB_dot = xB\n\n        if is_wedge:\n            length = n * 3 + 4\n            vertices = np.zeros((length, 2), float)\n            codes = np.full(length, cls.CURVE4, dtype=cls.code_type)\n            vertices[1] = [xA[0], yA[0]]\n            codes[0:2] = [cls.MOVETO, cls.LINETO]\n            codes[-2:] = [cls.LINETO, cls.CLOSEPOLY]\n            vertex_offset = 2\n            end = length - 2\n        else:\n            length = n * 3 + 1\n            vertices = np.empty((length, 2), float)\n            codes = np.full(length, cls.CURVE4, dtype=cls.code_type)\n            vertices[0] = [xA[0], yA[0]]\n            codes[0] = cls.MOVETO\n            vertex_offset = 1\n            end = length\n\n        vertices[vertex_offset:end:3, 0] = xA + alpha * xA_dot\n        vertices[vertex_offset:end:3, 1] = yA + alpha * yA_dot\n        vertices[vertex_offset+1:end:3, 0] = xB - alpha * xB_dot\n        vertices[vertex_offset+1:end:3, 1] = yB - alpha * yB_dot\n        vertices[vertex_offset+2:end:3, 0] = xB\n        vertices[vertex_offset+2:end:3, 1] = yB\n\n        return cls(vertices, codes, readonly=True)",
        "begin_line": 836,
        "end_line": 912,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.path.Path.hatch#934",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.hatch(hatchpattern, density=6)",
        "snippet": "    def hatch(hatchpattern, density=6):\n        \"\"\"\n        Given a hatch specifier, *hatchpattern*, generates a Path that\n        can be used in a repeated hatching pattern.  *density* is the\n        number of lines per unit square.\n        \"\"\"\n        from matplotlib.hatch import get_path\n        return (get_path(hatchpattern, density)\n                if hatchpattern is not None else None)",
        "begin_line": 934,
        "end_line": 942,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.path.get_path_collection_extents#960",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path",
        "signature": "lib.matplotlib.path.get_path_collection_extents(master_transform, paths, transforms, offsets, offset_transform)",
        "snippet": "def get_path_collection_extents(\n        master_transform, paths, transforms, offsets, offset_transform):\n    r\"\"\"\n    Given a sequence of `Path`\\s, `~.Transform`\\s objects, and offsets, as\n    found in a `~.PathCollection`, returns the bounding box that encapsulates\n    all of them.\n\n    Parameters\n    ----------\n    master_transform : `~.Transform`\n        Global transformation applied to all paths.\n    paths : list of `Path`\n    transform : list of `~.Affine2D`\n    offsets : (N, 2) array-like\n    offset_transform : `~.Affine2D`\n        Transform applied to the offsets before offsetting the path.\n\n    Notes\n    -----\n    The way that *paths*, *transforms* and *offsets* are combined\n    follows the same method as for collections:  Each is iterated over\n    independently, so if you have 3 paths, 2 transforms and 1 offset,\n    their combinations are as follows:\n\n        (A, A, A), (B, B, A), (C, A, A)\n    \"\"\"\n    from .transforms import Bbox\n    if len(paths) == 0:\n        raise ValueError(\"No paths provided\")\n    return Bbox.from_extents(*_path.get_path_collection_extents(\n        master_transform, paths, np.atleast_3d(transforms),\n        offsets, offset_transform))",
        "begin_line": 960,
        "end_line": 991,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023169601482854495,
            "pseudo_dstar_susp": 0.00022634676324128565,
            "pseudo_tarantula_susp": 0.00027210884353741496,
            "pseudo_op2_susp": 0.00022634676324128565,
            "pseudo_barinel_susp": 0.0002720348204570185
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.LayoutBox.__init__#51",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox.LayoutBox",
        "signature": "lib.matplotlib._layoutbox.LayoutBox.__init__(self, parent=None, name='', tightwidth=False, tightheight=False, artist=None, lower_left=(0, 0), upper_right=(1, 1), pos=False, subplot=False, h_pad=None, w_pad=None)",
        "snippet": "    def __init__(self, parent=None, name='', tightwidth=False,\n                 tightheight=False, artist=None,\n                 lower_left=(0, 0), upper_right=(1, 1), pos=False,\n                 subplot=False, h_pad=None, w_pad=None):\n        Variable = kiwi.Variable\n        self.parent = parent\n        self.name = name\n        sn = self.name + '_'\n        if parent is None:\n            self.solver = kiwi.Solver()\n            self.constrained_layout_called = 0\n        else:\n            self.solver = parent.solver\n            self.constrained_layout_called = None\n            # parent wants to know about this child!\n            parent.add_child(self)\n        # keep track of artist associated w/ this layout.  Can be none\n        self.artist = artist\n        # keep track if this box is supposed to be a pos that is constrained\n        # by the parent.\n        self.pos = pos\n        # keep track of whether we need to match this subplot up with others.\n        self.subplot = subplot\n\n        # we need the str below for Py 2 which complains the string is unicode\n        self.top = Variable(str(sn + 'top'))\n        self.bottom = Variable(str(sn + 'bottom'))\n        self.left = Variable(str(sn + 'left'))\n        self.right = Variable(str(sn + 'right'))\n\n        self.width = Variable(str(sn + 'width'))\n        self.height = Variable(str(sn + 'height'))\n        self.h_center = Variable(str(sn + 'h_center'))\n        self.v_center = Variable(str(sn + 'v_center'))\n\n        self.min_width = Variable(str(sn + 'min_width'))\n        self.min_height = Variable(str(sn + 'min_height'))\n        self.pref_width = Variable(str(sn + 'pref_width'))\n        self.pref_height = Variable(str(sn + 'pref_height'))\n        # margins are only used for axes-position layout boxes.  maybe should\n        # be a separate subclass:\n        self.left_margin = Variable(str(sn + 'left_margin'))\n        self.right_margin = Variable(str(sn + 'right_margin'))\n        self.bottom_margin = Variable(str(sn + 'bottom_margin'))\n        self.top_margin = Variable(str(sn + 'top_margin'))\n        # mins\n        self.left_margin_min = Variable(str(sn + 'left_margin_min'))\n        self.right_margin_min = Variable(str(sn + 'right_margin_min'))\n        self.bottom_margin_min = Variable(str(sn + 'bottom_margin_min'))\n        self.top_margin_min = Variable(str(sn + 'top_margin_min'))\n\n        right, top = upper_right\n        left, bottom = lower_left\n        self.tightheight = tightheight\n        self.tightwidth = tightwidth\n        self.add_constraints()\n        self.children = []\n        self.subplotspec = None\n        if self.pos:\n            self.constrain_margins()\n        self.h_pad = h_pad\n        self.w_pad = w_pad",
        "begin_line": 51,
        "end_line": 112,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005208333333333333,
            "pseudo_dstar_susp": 0.0003402517863218782,
            "pseudo_tarantula_susp": 0.0003301419610432486,
            "pseudo_op2_susp": 0.0003402517863218782,
            "pseudo_barinel_susp": 0.0003301419610432486
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.LayoutBox.add_child#162",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox.LayoutBox",
        "signature": "lib.matplotlib._layoutbox.LayoutBox.add_child(self, child)",
        "snippet": "    def add_child(self, child):\n        self.children += [child]",
        "begin_line": 162,
        "end_line": 163,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004975124378109452,
            "pseudo_dstar_susp": 0.00032927230819888045,
            "pseudo_tarantula_susp": 0.00033444816053511704,
            "pseudo_op2_susp": 0.00032927230819888045,
            "pseudo_barinel_susp": 0.00033444816053511704
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.LayoutBox.constrain_geometry#230",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox.LayoutBox",
        "signature": "lib.matplotlib._layoutbox.LayoutBox.constrain_geometry(self, left, bottom, right, top, strength='strong')",
        "snippet": "    def constrain_geometry(self, left, bottom, right, top, strength='strong'):\n        hc = [self.left == left,\n              self.right == right,\n              self.bottom == bottom,\n              self.top == top]\n        for c in hc:\n            self.solver.addConstraint(c | strength)",
        "begin_line": 230,
        "end_line": 236,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004761904761904762,
            "pseudo_dstar_susp": 0.0003225806451612903,
            "pseudo_tarantula_susp": 0.0003332222592469177,
            "pseudo_op2_susp": 0.0003225806451612903,
            "pseudo_barinel_susp": 0.0003332222592469177
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.LayoutBox.edit_right_margin_min#261",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox.LayoutBox",
        "signature": "lib.matplotlib._layoutbox.LayoutBox.edit_right_margin_min(self, margin)",
        "snippet": "    def edit_right_margin_min(self, margin):\n        self.solver.suggestValue(self.right_margin_min, margin)",
        "begin_line": 261,
        "end_line": 262,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00026164311878597594,
            "pseudo_dstar_susp": 0.00023435669088352472,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00023435669088352472,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.LayoutBox.constrain_bottom_margin#264",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox.LayoutBox",
        "signature": "lib.matplotlib._layoutbox.LayoutBox.constrain_bottom_margin(self, margin, strength='strong')",
        "snippet": "    def constrain_bottom_margin(self, margin, strength='strong'):\n        c = (self.bottom == self.parent.bottom + margin)\n        self.solver.addConstraint(c | strength)",
        "begin_line": 264,
        "end_line": 266,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00026164311878597594,
            "pseudo_dstar_susp": 0.00023435669088352472,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00023435669088352472,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.LayoutBox.edit_bottom_margin_min#268",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox.LayoutBox",
        "signature": "lib.matplotlib._layoutbox.LayoutBox.edit_bottom_margin_min(self, margin)",
        "snippet": "    def edit_bottom_margin_min(self, margin):\n        self.solver.suggestValue(self.bottom_margin_min, margin)",
        "begin_line": 268,
        "end_line": 269,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.LayoutBox.layout_from_subplotspec#378",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox.LayoutBox",
        "signature": "lib.matplotlib._layoutbox.LayoutBox.layout_from_subplotspec(self, subspec, name='', artist=None, pos=False)",
        "snippet": "    def layout_from_subplotspec(self, subspec,\n                                name='', artist=None, pos=False):\n        \"\"\"\n        Make a layout box from a subplotspec. The layout box is\n        constrained to be a fraction of the width/height of the parent,\n        and be a fraction of the parent width/height from the left/bottom\n        of the parent.  Therefore the parent can move around and the\n        layout for the subplot spec should move with it.\n\n        The parent is *usually* the gridspec that made the subplotspec.??\n        \"\"\"\n        lb = LayoutBox(parent=self, name=name, artist=artist, pos=pos)\n        gs = subspec.get_gridspec()\n        nrows, ncols = gs.get_geometry()\n        parent = self.parent\n\n        # OK, now, we want to set the position of this subplotspec\n        # based on its subplotspec parameters.  The new gridspec will inherit\n        # from gridspec.  prob should be new method in gridspec\n        left = 0.0\n        right = 1.0\n        bottom = 0.0\n        top = 1.0\n        totWidth = right-left\n        totHeight = top-bottom\n        hspace = 0.\n        wspace = 0.\n\n        # calculate accumulated heights of columns\n        cellH = totHeight / (nrows + hspace * (nrows - 1))\n        sepH = hspace * cellH\n\n        if gs._row_height_ratios is not None:\n            netHeight = cellH * nrows\n            tr = sum(gs._row_height_ratios)\n            cellHeights = [netHeight * r / tr for r in gs._row_height_ratios]\n        else:\n            cellHeights = [cellH] * nrows\n\n        sepHeights = [0] + ([sepH] * (nrows - 1))\n        cellHs = np.cumsum(np.column_stack([sepHeights, cellHeights]).flat)\n\n        # calculate accumulated widths of rows\n        cellW = totWidth / (ncols + wspace * (ncols - 1))\n        sepW = wspace * cellW\n\n        if gs._col_width_ratios is not None:\n            netWidth = cellW * ncols\n            tr = sum(gs._col_width_ratios)\n            cellWidths = [netWidth * r / tr for r in gs._col_width_ratios]\n        else:\n            cellWidths = [cellW] * ncols\n\n        sepWidths = [0] + ([sepW] * (ncols - 1))\n        cellWs = np.cumsum(np.column_stack([sepWidths, cellWidths]).flat)\n\n        figTops = [top - cellHs[2 * rowNum] for rowNum in range(nrows)]\n        figBottoms = [top - cellHs[2 * rowNum + 1] for rowNum in range(nrows)]\n        figLefts = [left + cellWs[2 * colNum] for colNum in range(ncols)]\n        figRights = [left + cellWs[2 * colNum + 1] for colNum in range(ncols)]\n\n        rowNum1, colNum1 = divmod(subspec.num1, ncols)\n        rowNum2, colNum2 = divmod(subspec.num2, ncols)\n        figBottom = min(figBottoms[rowNum1], figBottoms[rowNum2])\n        figTop = max(figTops[rowNum1], figTops[rowNum2])\n        figLeft = min(figLefts[colNum1], figLefts[colNum2])\n        figRight = max(figRights[colNum1], figRights[colNum2])\n\n        # These are numbers relative to (0, 0, 1, 1).  Need to constrain\n        # relative to parent.\n\n        width = figRight - figLeft\n        height = figTop - figBottom\n        parent = self.parent\n        cs = [self.left == parent.left + parent.width * figLeft,\n              self.bottom == parent.bottom + parent.height * figBottom,\n              self.width == parent.width * width,\n              self.height == parent.height * height]\n        for c in cs:\n            self.solver.addConstraint(c | 'required')\n\n        return lb",
        "begin_line": 378,
        "end_line": 459,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018846588767433095,
            "pseudo_dstar_susp": 0.0001541782300339192,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0001541782300339192,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle.__init__#205",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle.__init__(self, marker=None, fillstyle=None)",
        "snippet": "    def __init__(self, marker=None, fillstyle=None):\n        \"\"\"\n        Attributes\n        ----------\n        markers : list of known marks\n\n        fillstyles : list of known fillstyles\n\n        filled_markers : list of known filled markers.\n\n        Parameters\n        ----------\n        marker : str or array-like, optional, default: None\n            See the descriptions of possible markers in the module docstring.\n\n        fillstyle : str, optional, default: 'full'\n            'full', 'left\", 'right', 'bottom', 'top', 'none'\n        \"\"\"\n        self._marker_function = None\n        self.set_fillstyle(fillstyle)\n        self.set_marker(marker)",
        "begin_line": 205,
        "end_line": 225,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._recache#227",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._recache(self)",
        "snippet": "    def _recache(self):\n        if self._marker_function is None:\n            return\n        self._path = _empty_path\n        self._transform = IdentityTransform()\n        self._alt_path = None\n        self._alt_transform = None\n        self._snap_threshold = None\n        self._joinstyle = 'round'\n        self._capstyle = 'butt'\n        self._filled = True\n        self._marker_function()",
        "begin_line": 227,
        "end_line": 238,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006176652254478073,
            "pseudo_dstar_susp": 0.00078064012490242,
            "pseudo_tarantula_susp": 0.00016020506247997436,
            "pseudo_op2_susp": 0.00078064012490242,
            "pseudo_barinel_susp": 0.00016020506247997436
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle.__bool__#240",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle.__bool__(self)",
        "snippet": "    def __bool__(self):\n        return bool(len(self._path.vertices))",
        "begin_line": 240,
        "end_line": 241,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001394700139470014,
            "pseudo_dstar_susp": 0.00018148820326678765,
            "pseudo_tarantula_susp": 0.00012174336498660823,
            "pseudo_op2_susp": 0.00018148820326678765,
            "pseudo_barinel_susp": 0.00012174336498660823
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle.is_filled#243",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle.is_filled(self)",
        "snippet": "    def is_filled(self):\n        return self._filled",
        "begin_line": 243,
        "end_line": 244,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.780284758422158e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle.set_fillstyle#249",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle.set_fillstyle(self, fillstyle)",
        "snippet": "    def set_fillstyle(self, fillstyle):\n        \"\"\"\n        Sets fillstyle\n\n        Parameters\n        ----------\n        fillstyle : string amongst known fillstyles\n        \"\"\"\n        if fillstyle is None:\n            fillstyle = rcParams['markers.fillstyle']\n        cbook._check_in_list(self.fillstyles, fillstyle=fillstyle)\n        self._fillstyle = fillstyle\n        self._recache()",
        "begin_line": 249,
        "end_line": 261,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003313452617627568,
            "pseudo_dstar_susp": 0.00041476565740356696,
            "pseudo_tarantula_susp": 0.0001325556733828208,
            "pseudo_op2_susp": 0.00041476565740356696,
            "pseudo_barinel_susp": 0.0001325556733828208
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle.get_joinstyle#263",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle.get_joinstyle(self)",
        "snippet": "    def get_joinstyle(self):\n        return self._joinstyle",
        "begin_line": 263,
        "end_line": 264,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.34306691139663e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle.get_capstyle#266",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle.get_capstyle(self)",
        "snippet": "    def get_capstyle(self):\n        return self._capstyle",
        "begin_line": 266,
        "end_line": 267,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005173305742369374,
            "pseudo_dstar_susp": 0.00039261876717707107,
            "pseudo_tarantula_susp": 0.0003401360544217687,
            "pseudo_op2_susp": 0.00039261876717707107,
            "pseudo_barinel_susp": 0.0003401360544217687
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle.get_marker#269",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle.get_marker(self)",
        "snippet": "    def get_marker(self):\n        return self._marker",
        "begin_line": 269,
        "end_line": 270,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00046816479400749064,
            "pseudo_dstar_susp": 0.0003755163349605708,
            "pseudo_tarantula_susp": 0.00018653236336504383,
            "pseudo_op2_susp": 0.0003755163349605708,
            "pseudo_barinel_susp": 0.00018653236336504383
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle.set_marker#272",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle.set_marker(self, marker)",
        "snippet": "    def set_marker(self, marker):\n        if (isinstance(marker, np.ndarray) and marker.ndim == 2 and\n                marker.shape[1] == 2):\n            self._marker_function = self._set_vertices\n        elif isinstance(marker, str) and cbook.is_math_text(marker):\n            self._marker_function = self._set_mathtext_path\n        elif isinstance(marker, Path):\n            self._marker_function = self._set_path_marker\n        elif (isinstance(marker, Sized) and len(marker) in (2, 3) and\n                marker[1] in (0, 1, 2)):\n            self._marker_function = self._set_tuple_marker\n        elif (not isinstance(marker, (np.ndarray, list)) and\n              marker in self.markers):\n            self._marker_function = getattr(\n                self, '_set_' + self.markers[marker])\n        else:\n            try:\n                Path(marker)\n                self._marker_function = self._set_vertices\n            except ValueError:\n                raise ValueError('Unrecognized marker style {!r}'\n                                 .format(marker))\n\n        self._marker = marker\n        self._recache()",
        "begin_line": 272,
        "end_line": 296,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003362474781439139,
            "pseudo_dstar_susp": 0.00044583147570218456,
            "pseudo_tarantula_susp": 0.0001368738023542294,
            "pseudo_op2_susp": 0.00044583147570218456,
            "pseudo_barinel_susp": 0.0001368738023542294
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_nothing#313",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_nothing(self)",
        "snippet": "    def _set_nothing(self):\n        self._filled = False",
        "begin_line": 313,
        "end_line": 314,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002509410288582183,
            "pseudo_dstar_susp": 0.00023758612497030174,
            "pseudo_tarantula_susp": 0.0002770850651149903,
            "pseudo_op2_susp": 0.00023758612497030174,
            "pseudo_barinel_susp": 0.0002770850651149903
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_custom_marker#316",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_custom_marker(self, path)",
        "snippet": "    def _set_custom_marker(self, path):\n        verts = path.vertices\n        rescale = max(np.max(np.abs(verts[:, 0])),\n                      np.max(np.abs(verts[:, 1])))\n        self._transform = Affine2D().scale(0.5 / rescale)\n        self._path = path",
        "begin_line": 316,
        "end_line": 321,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_path_marker#323",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_path_marker(self)",
        "snippet": "    def _set_path_marker(self):\n        self._set_custom_marker(self._marker)",
        "begin_line": 323,
        "end_line": 324,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_vertices#326",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_vertices(self)",
        "snippet": "    def _set_vertices(self):\n        verts = self._marker\n        marker = Path(verts)\n        self._set_custom_marker(marker)",
        "begin_line": 326,
        "end_line": 329,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._half_fill#378",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._half_fill(self)",
        "snippet": "    def _half_fill(self):\n        return self.get_fillstyle() in self._half_fillstyles",
        "begin_line": 378,
        "end_line": 379,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011966016513102789,
            "pseudo_dstar_susp": 0.0001339046598821639,
            "pseudo_tarantula_susp": 0.00011920371915603766,
            "pseudo_op2_susp": 0.0001339046598821639,
            "pseudo_barinel_susp": 0.00011917530687641521
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_star#568",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_star(self)",
        "snippet": "    def _set_star(self):\n        self._transform = Affine2D().scale(0.5)\n        self._snap_threshold = 5.0\n\n        fs = self.get_fillstyle()\n        polypath = Path.unit_regular_star(5, innerCircle=0.381966)\n\n        if not self._half_fill():\n            self._path = polypath\n        else:\n            verts = polypath.vertices\n\n            top = Path(np.vstack((verts[0:4, :], verts[7:10, :], verts[0])))\n            bottom = Path(np.vstack((verts[3:8, :], verts[3])))\n            left = Path(np.vstack((verts[0:6, :], verts[0])))\n            right = Path(np.vstack((verts[0], verts[5:10, :], verts[0])))\n\n            if fs == 'top':\n                mpath, mpath_alt = top, bottom\n            elif fs == 'bottom':\n                mpath, mpath_alt = bottom, top\n            elif fs == 'left':\n                mpath, mpath_alt = left, right\n            else:\n                mpath, mpath_alt = right, left\n            self._path = mpath\n            self._alt_path = mpath_alt\n            self._alt_transform = self._transform\n\n        self._joinstyle = 'bevel'",
        "begin_line": 568,
        "end_line": 597,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_hexagon1#599",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_hexagon1(self)",
        "snippet": "    def _set_hexagon1(self):\n        self._transform = Affine2D().scale(0.5)\n        self._snap_threshold = None\n\n        fs = self.get_fillstyle()\n        polypath = Path.unit_regular_polygon(6)\n\n        if not self._half_fill():\n            self._path = polypath\n        else:\n            verts = polypath.vertices\n\n            # not drawing inside lines\n            x = np.abs(np.cos(5 * np.pi / 6.))\n            top = Path(np.vstack(([-x, 0], verts[(1, 0, 5), :], [x, 0])))\n            bottom = Path(np.vstack(([-x, 0], verts[2:5, :], [x, 0])))\n            left = Path(verts[(0, 1, 2, 3), :])\n            right = Path(verts[(0, 5, 4, 3), :])\n\n            if fs == 'top':\n                mpath, mpath_alt = top, bottom\n            elif fs == 'bottom':\n                mpath, mpath_alt = bottom, top\n            elif fs == 'left':\n                mpath, mpath_alt = left, right\n            else:\n                mpath, mpath_alt = right, left\n\n            self._path = mpath\n            self._alt_path = mpath_alt\n            self._alt_transform = self._transform\n\n        self._joinstyle = 'miter'",
        "begin_line": 599,
        "end_line": 631,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_octagon#668",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_octagon(self)",
        "snippet": "    def _set_octagon(self):\n        self._transform = Affine2D().scale(0.5)\n        self._snap_threshold = 5.0\n\n        fs = self.get_fillstyle()\n        polypath = Path.unit_regular_polygon(8)\n\n        if not self._half_fill():\n            self._transform.rotate_deg(22.5)\n            self._path = polypath\n        else:\n            x = np.sqrt(2.) / 4.\n            half = Path([[0, -1], [0, 1], [-x, 1], [-1, x],\n                         [-1, -x], [-x, -1], [0, -1]])\n\n            if fs == 'bottom':\n                rotate = 90.\n            elif fs == 'top':\n                rotate = 270.\n            elif fs == 'right':\n                rotate = 180.\n            else:\n                rotate = 0.\n\n            self._transform.rotate_deg(rotate)\n            self._path = self._alt_path = half\n            self._alt_transform = self._transform.frozen().rotate_deg(180.0)\n\n        self._joinstyle = 'miter'",
        "begin_line": 668,
        "end_line": 696,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_tickleft#712",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_tickleft(self)",
        "snippet": "    def _set_tickleft(self):\n        self._transform = Affine2D().scale(-1.0, 1.0)\n        self._snap_threshold = 1.0\n        self._filled = False\n        self._path = self._tickhoriz_path",
        "begin_line": 712,
        "end_line": 716,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00033200531208499334,
            "pseudo_dstar_susp": 0.00039184952978056425,
            "pseudo_tarantula_susp": 0.0002673082063619353,
            "pseudo_op2_susp": 0.00039184952978056425,
            "pseudo_barinel_susp": 0.0002673082063619353
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_tickup#726",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_tickup(self)",
        "snippet": "    def _set_tickup(self):\n        self._transform = Affine2D().scale(1.0, 1.0)\n        self._snap_threshold = 1.0\n        self._filled = False\n        self._path = self._tickvert_path",
        "begin_line": 726,
        "end_line": 730,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00026910656620021526,
            "pseudo_dstar_susp": 0.000249003984063745,
            "pseudo_tarantula_susp": 0.000299311583358276,
            "pseudo_op2_susp": 0.000249003984063745,
            "pseudo_barinel_susp": 0.000299311583358276
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_tickdown#732",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_tickdown(self)",
        "snippet": "    def _set_tickdown(self):\n        self._transform = Affine2D().scale(1.0, -1.0)\n        self._snap_threshold = 1.0\n        self._filled = False\n        self._path = self._tickvert_path",
        "begin_line": 732,
        "end_line": 736,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002651113467656416,
            "pseudo_dstar_susp": 0.0003354579000335458,
            "pseudo_tarantula_susp": 0.0002969121140142518,
            "pseudo_op2_susp": 0.0003354579000335458,
            "pseudo_barinel_susp": 0.0002969121140142518
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_x#818",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_x(self)",
        "snippet": "    def _set_x(self):\n        self._transform = Affine2D().scale(0.5)\n        self._snap_threshold = 3.0\n        self._filled = False\n        self._path = self._x_path",
        "begin_line": 818,
        "end_line": 822,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018846588767433095,
            "pseudo_dstar_susp": 0.0001541782300339192,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0001541782300339192,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib._constrained_layout._axes_all_finite_sized#68",
        "src_path": "lib/matplotlib/_constrained_layout.py",
        "class_name": "lib.matplotlib._constrained_layout",
        "signature": "lib.matplotlib._constrained_layout._axes_all_finite_sized(fig)",
        "snippet": "def _axes_all_finite_sized(fig):\n    \"\"\"Return whether all axes in the figure have a finite width and height.\"\"\"\n    for ax in fig.axes:\n        if ax._layoutbox is not None:\n            newpos = ax._poslayoutbox.get_rect()\n            if newpos[2] <= 0 or newpos[3] <= 0:\n                return False\n    return True",
        "begin_line": 68,
        "end_line": 75,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006079027355623101,
            "pseudo_dstar_susp": 0.0003696857670979667,
            "pseudo_tarantula_susp": 0.00034094783498124785,
            "pseudo_op2_susp": 0.0003696857670979667,
            "pseudo_barinel_susp": 0.00034094783498124785
        }
    },
    {
        "name": "lib.matplotlib._constrained_layout.do_constrained_layout#79",
        "src_path": "lib/matplotlib/_constrained_layout.py",
        "class_name": "lib.matplotlib._constrained_layout",
        "signature": "lib.matplotlib._constrained_layout.do_constrained_layout(fig, renderer, h_pad, w_pad, hspace=None, wspace=None)",
        "snippet": "def do_constrained_layout(fig, renderer, h_pad, w_pad,\n        hspace=None, wspace=None):\n    \"\"\"\n    Do the constrained_layout.  Called at draw time in\n     ``figure.constrained_layout()``\n\n    Parameters\n    ----------\n    fig : Figure\n      is the ``figure`` instance to do the layout in.\n\n    renderer : Renderer\n      the renderer to use.\n\n     h_pad, w_pad : float\n       are in figure-normalized units, and are a padding around the axes\n       elements.\n\n     hspace, wspace : float\n        are in fractions of the subplot sizes.\n\n    \"\"\"\n\n    # Steps:\n    #\n    # 1. get a list of unique gridspecs in this figure.  Each gridspec will be\n    # constrained separately.\n    # 2. Check for gaps in the gridspecs.  i.e. if not every axes slot in the\n    # gridspec has been filled.  If empty, add a ghost axis that is made so\n    # that it cannot be seen (though visible=True).  This is needed to make\n    # a blank spot in the layout.\n    # 3. Compare the tight_bbox of each axes to its `position`, and assume that\n    # the difference is the space needed by the elements around the edge of\n    # the axes (decorations) like the title, ticklabels, x-labels, etc.  This\n    # can include legends who overspill the axes boundaries.\n    # 4. Constrain gridspec elements to line up:\n    #     a) if colnum0 != colnumC, the two subplotspecs are stacked next to\n    #     each other, with the appropriate order.\n    #     b) if colnum0 == colnumC, line up the left or right side of the\n    #     _poslayoutbox (depending if it is the min or max num that is equal).\n    #     c) do the same for rows...\n    # 5. The above doesn't constrain relative sizes of the _poslayoutboxes\n    # at all, and indeed zero-size is a solution that the solver often finds\n    # more convenient than expanding the sizes.  Right now the solution is to\n    # compare subplotspec sizes (i.e. drowsC and drows0) and constrain the\n    # larger _poslayoutbox to be larger than the ratio of the sizes. i.e. if\n    # drows0 > drowsC, then ax._poslayoutbox > axc._poslayoutbox*drowsC/drows0.\n    # This works fine *if* the decorations are similar between the axes.\n    # If the larger subplotspec has much larger axes decorations, then the\n    # constraint above is incorrect.\n    #\n    # We need the greater than in the above, in general, rather than an equals\n    # sign.  Consider the case of the left column having 2 rows, and the right\n    # column having 1 row.  We want the top and bottom of the _poslayoutboxes\n    # to line up. So that means if there are decorations on the left column\n    # axes they will be smaller than half as large as the right hand axis.\n    #\n    # This can break down if the decoration size for the right hand axis (the\n    # margins) is very large.  There must be a math way to check for this case.\n\n    invTransFig = fig.transFigure.inverted().transform_bbox\n\n    # list of unique gridspecs that contain child axes:\n    gss = set()\n    for ax in fig.axes:\n        if hasattr(ax, 'get_subplotspec'):\n            gs = ax.get_subplotspec().get_gridspec()\n            if gs._layoutbox is not None:\n                gss.add(gs)\n    if len(gss) == 0:\n        cbook._warn_external('There are no gridspecs with layoutboxes. '\n                             'Possibly did not call parent GridSpec with the'\n                             ' figure= keyword')\n\n    if fig._layoutbox.constrained_layout_called < 1:\n        for gs in gss:\n            # fill in any empty gridspec slots w/ ghost axes...\n            _make_ghost_gridspec_slots(fig, gs)\n\n    for nnn in range(2):\n        # do the algorithm twice.  This has to be done because decorators\n        # change size after the first re-position (i.e. x/yticklabels get\n        # larger/smaller).  This second reposition tends to be much milder,\n        # so doing twice makes things work OK.\n        for ax in fig.axes:\n            _log.debug(ax._layoutbox)\n            if ax._layoutbox is not None:\n                # make margins for each layout box based on the size of\n                # the decorators.\n                _make_layout_margins(ax, renderer, h_pad, w_pad)\n\n        # do layout for suptitle.\n        suptitle = fig._suptitle\n        do_suptitle = (suptitle is not None and\n                       suptitle._layoutbox is not None and\n                       suptitle.get_in_layout())\n        if do_suptitle:\n            bbox = invTransFig(\n                suptitle.get_window_extent(renderer=renderer))\n            height = bbox.y1 - bbox.y0\n            if np.isfinite(height):\n                # reserve at top of figure include an h_pad above and below\n                suptitle._layoutbox.edit_height(height + h_pad * 2)\n\n        # OK, the above lines up ax._poslayoutbox with ax._layoutbox\n        # now we need to\n        #   1) arrange the subplotspecs.  We do it at this level because\n        #      the subplotspecs are meant to contain other dependent axes\n        #      like colorbars or legends.\n        #   2) line up the right and left side of the ax._poslayoutbox\n        #      that have the same subplotspec maxes.\n\n        if fig._layoutbox.constrained_layout_called < 1:\n            # arrange the subplotspecs...  This is all done relative to each\n            # other.  Some subplotspecs contain axes, and others contain\n            # gridspecs the ones that contain gridspecs are a set proportion\n            # of their parent gridspec.  The ones that contain axes are\n            # not so constrained.\n            figlb = fig._layoutbox\n            for child in figlb.children:\n                if child._is_gridspec_layoutbox():\n                    # This routine makes all the subplot spec containers\n                    # have the correct arrangement.  It just stacks the\n                    # subplot layoutboxes in the correct order...\n                    _arrange_subplotspecs(child, hspace=hspace, wspace=wspace)\n\n            for gs in gss:\n                _align_spines(fig, gs)\n\n        fig._layoutbox.constrained_layout_called += 1\n        fig._layoutbox.update_variables()\n\n        # check if any axes collapsed to zero.  If not, don't change positions:\n        if _axes_all_finite_sized(fig):\n            # Now set the position of the axes...\n            for ax in fig.axes:\n                if ax._layoutbox is not None:\n                    newpos = ax._poslayoutbox.get_rect()\n                    # Now set the new position.\n                    # ax.set_position will zero out the layout for\n                    # this axis, allowing users to hard-code the position,\n                    # so this does the same w/o zeroing layout.\n                    ax._set_position(newpos, which='original')\n            if do_suptitle:\n                newpos = suptitle._layoutbox.get_rect()\n                suptitle.set_y(1.0 - h_pad)\n            else:\n                if suptitle is not None and suptitle._layoutbox is not None:\n                    suptitle._layoutbox.edit_height(0)\n        else:\n            cbook._warn_external('constrained_layout not applied.  At least '\n                                 'one axes collapsed to zero width or height.')",
        "begin_line": 79,
        "end_line": 230,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006142506142506142,
            "pseudo_dstar_susp": 0.00037257824143070045,
            "pseudo_tarantula_susp": 0.0003898635477582846,
            "pseudo_op2_susp": 0.00037257824143070045,
            "pseudo_barinel_susp": 0.0003898635477582846
        }
    },
    {
        "name": "lib.matplotlib._constrained_layout._make_ghost_gridspec_slots#233",
        "src_path": "lib/matplotlib/_constrained_layout.py",
        "class_name": "lib.matplotlib._constrained_layout",
        "signature": "lib.matplotlib._constrained_layout._make_ghost_gridspec_slots(fig, gs)",
        "snippet": "def _make_ghost_gridspec_slots(fig, gs):\n    \"\"\"\n    Check for unoccupied gridspec slots and make ghost axes for these\n    slots...  Do for each gs separately.  This is a pretty big kludge\n    but shouldn't have too much ill effect.  The worst is that\n    someone querying the figure will wonder why there are more\n    axes than they thought.\n    \"\"\"\n    nrows, ncols = gs.get_geometry()\n    hassubplotspec = np.zeros(nrows * ncols, dtype=bool)\n    axs = []\n    for ax in fig.axes:\n        if (hasattr(ax, 'get_subplotspec')\n                and ax._layoutbox is not None\n                and ax.get_subplotspec().get_gridspec() == gs):\n            axs += [ax]\n    for ax in axs:\n        ss0 = ax.get_subplotspec()\n        hassubplotspec[ss0.num1:(ss0.num2 + 1)] = True\n    for nn, hss in enumerate(hassubplotspec):\n        if not hss:\n            # this gridspec slot doesn't have an axis so we\n            # make a \"ghost\".\n            ax = fig.add_subplot(gs[nn])\n            ax.set_frame_on(False)\n            ax.set_xticks([])\n            ax.set_yticks([])\n            ax.set_facecolor((1, 0, 0, 0))",
        "begin_line": 233,
        "end_line": 260,
        "comment": "",
        "is_bug": true,
        "susp": {
            "pseudo_ochiai_susp": 0.000482392667631452,
            "pseudo_dstar_susp": 0.00032299741602067185,
            "pseudo_tarantula_susp": 0.0003629764065335753,
            "pseudo_op2_susp": 0.00032299741602067185,
            "pseudo_barinel_susp": 0.0003633720930232558
        }
    },
    {
        "name": "lib.matplotlib._constrained_layout._make_layout_margins#263",
        "src_path": "lib/matplotlib/_constrained_layout.py",
        "class_name": "lib.matplotlib._constrained_layout",
        "signature": "lib.matplotlib._constrained_layout._make_layout_margins(ax, renderer, h_pad, w_pad)",
        "snippet": "def _make_layout_margins(ax, renderer, h_pad, w_pad):\n    \"\"\"\n    For each axes, make a margin between the *pos* layoutbox and the\n    *axes* layoutbox be a minimum size that can accommodate the\n    decorations on the axis.\n    \"\"\"\n    fig = ax.figure\n    invTransFig = fig.transFigure.inverted().transform_bbox\n    pos = ax.get_position(original=True)\n    tightbbox = ax.get_tightbbox(renderer=renderer)\n    if tightbbox is None:\n        bbox = pos\n    else:\n        bbox = invTransFig(tightbbox)\n\n    # this can go wrong:\n    if not (np.isfinite(bbox.width) and np.isfinite(bbox.height)):\n        # just abort, this is likely a bad set of co-ordinates that\n        # is transitory...\n        return\n    # use stored h_pad if it exists\n    h_padt = ax._poslayoutbox.h_pad\n    if h_padt is None:\n        h_padt = h_pad\n    w_padt = ax._poslayoutbox.w_pad\n    if w_padt is None:\n        w_padt = w_pad\n    ax._poslayoutbox.edit_left_margin_min(-bbox.x0 +\n            pos.x0 + w_padt)\n    ax._poslayoutbox.edit_right_margin_min(bbox.x1 -\n            pos.x1 + w_padt)\n    ax._poslayoutbox.edit_bottom_margin_min(\n            -bbox.y0 + pos.y0 + h_padt)\n    ax._poslayoutbox.edit_top_margin_min(bbox.y1-pos.y1+h_padt)\n    _log.debug('left %f', (-bbox.x0 + pos.x0 + w_pad))\n    _log.debug('right %f', (bbox.x1 - pos.x1 + w_pad))\n    _log.debug('bottom %f', (-bbox.y0 + pos.y0 + h_padt))\n    _log.debug('bbox.y0 %f', bbox.y0)\n    _log.debug('pos.y0 %f', pos.y0)\n    # Sometimes its possible for the solver to collapse\n    # rather than expand axes, so they all have zero height\n    # or width.  This stops that...  It *should* have been\n    # taken into account w/ pref_width...\n    if fig._layoutbox.constrained_layout_called < 1:\n        ax._poslayoutbox.constrain_height_min(20, strength='weak')\n        ax._poslayoutbox.constrain_width_min(20, strength='weak')\n        ax._layoutbox.constrain_height_min(20, strength='weak')\n        ax._layoutbox.constrain_width_min(20, strength='weak')\n        ax._poslayoutbox.constrain_top_margin(0, strength='weak')\n        ax._poslayoutbox.constrain_bottom_margin(0,\n                strength='weak')\n        ax._poslayoutbox.constrain_right_margin(0, strength='weak')\n        ax._poslayoutbox.constrain_left_margin(0, strength='weak')",
        "begin_line": 263,
        "end_line": 315,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00026164311878597594,
            "pseudo_dstar_susp": 0.00023435669088352472,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00023435669088352472,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib._constrained_layout._align_spines#318",
        "src_path": "lib/matplotlib/_constrained_layout.py",
        "class_name": "lib.matplotlib._constrained_layout",
        "signature": "lib.matplotlib._constrained_layout._align_spines(fig, gs)",
        "snippet": "def _align_spines(fig, gs):\n    \"\"\"\n    - Align right/left and bottom/top spines of appropriate subplots.\n    - Compare size of subplotspec including height and width ratios\n       and make sure that the axes spines are at least as large\n       as they should be.\n    \"\"\"\n    # for each gridspec...\n    nrows, ncols = gs.get_geometry()\n    width_ratios = gs.get_width_ratios()\n    height_ratios = gs.get_height_ratios()\n    if width_ratios is None:\n        width_ratios = np.ones(ncols)\n    if height_ratios is None:\n        height_ratios = np.ones(nrows)\n\n    # get axes in this gridspec....\n    axs = []\n    for ax in fig.axes:\n        if (hasattr(ax, 'get_subplotspec')\n                and ax._layoutbox is not None):\n            if ax.get_subplotspec().get_gridspec() == gs:\n                axs += [ax]\n    rownummin = np.zeros(len(axs), dtype=np.int8)\n    rownummax = np.zeros(len(axs), dtype=np.int8)\n    colnummin = np.zeros(len(axs), dtype=np.int8)\n    colnummax = np.zeros(len(axs), dtype=np.int8)\n    width = np.zeros(len(axs))\n    height = np.zeros(len(axs))\n\n    for n, ax in enumerate(axs):\n        ss0 = ax.get_subplotspec()\n        rownummin[n], colnummin[n] = divmod(ss0.num1, ncols)\n        rownummax[n], colnummax[n] = divmod(ss0.num2, ncols)\n        width[n] = np.sum(\n                width_ratios[colnummin[n]:(colnummax[n] + 1)])\n        height[n] = np.sum(\n                height_ratios[rownummin[n]:(rownummax[n] + 1)])\n\n    for nn, ax in enumerate(axs[:-1]):\n        # now compare ax to all the axs:\n        #\n        # If the subplotspecs have the same colnumXmax, then line\n        # up their right sides.  If they have the same min, then\n        # line up their left sides (and vertical equivalents).\n        rownum0min, colnum0min = rownummin[nn], colnummin[nn]\n        rownum0max, colnum0max = rownummax[nn], colnummax[nn]\n        width0, height0 = width[nn], height[nn]\n        alignleft = False\n        alignright = False\n        alignbot = False\n        aligntop = False\n        alignheight = False\n        alignwidth = False\n        for mm in range(nn+1, len(axs)):\n            axc = axs[mm]\n            rownumCmin, colnumCmin = rownummin[mm], colnummin[mm]\n            rownumCmax, colnumCmax = rownummax[mm], colnummax[mm]\n            widthC, heightC = width[mm], height[mm]\n            # Horizontally align axes spines if they have the\n            # same min or max:\n            if not alignleft and colnum0min == colnumCmin:\n                # we want the _poslayoutboxes to line up on left\n                # side of the axes spines...\n                layoutbox.align([ax._poslayoutbox,\n                                 axc._poslayoutbox],\n                                'left')\n                alignleft = True\n\n            if not alignright and colnum0max == colnumCmax:\n                # line up right sides of _poslayoutbox\n                layoutbox.align([ax._poslayoutbox,\n                                 axc._poslayoutbox],\n                                'right')\n                alignright = True\n            # Vertically align axes spines if they have the\n            # same min or max:\n            if not aligntop and rownum0min == rownumCmin:\n                # line up top of _poslayoutbox\n                _log.debug('rownum0min == rownumCmin')\n                layoutbox.align([ax._poslayoutbox, axc._poslayoutbox],\n                                'top')\n                aligntop = True\n\n            if not alignbot and rownum0max == rownumCmax:\n                # line up bottom of _poslayoutbox\n                _log.debug('rownum0max == rownumCmax')\n                layoutbox.align([ax._poslayoutbox, axc._poslayoutbox],\n                                'bottom')\n                alignbot = True\n            ###########\n            # Now we make the widths and heights of position boxes\n            # similar. (i.e the spine locations)\n            # This allows vertically stacked subplots to have\n            # different sizes if they occupy different amounts\n            # of the gridspec:  i.e.\n            # gs = gridspec.GridSpec(3, 1)\n            # ax1 = gs[0,:]\n            # ax2 = gs[1:,:]\n            # then drows0 = 1, and drowsC = 2, and ax2\n            # should be at least twice as large as ax1.\n            # But it can be more than twice as large because\n            # it needs less room for the labeling.\n            #\n            # For height, this only needs to be done if the\n            # subplots share a column.  For width if they\n            # share a row.\n\n            drowsC = (rownumCmax - rownumCmin + 1)\n            drows0 = (rownum0max - rownum0min + 1)\n            dcolsC = (colnumCmax - colnumCmin + 1)\n            dcols0 = (colnum0max - colnum0min + 1)\n\n            if not alignheight and drows0 == drowsC:\n                ax._poslayoutbox.constrain_height(\n                        axc._poslayoutbox.height * height0 / heightC)\n                alignheight = True\n            elif _in_same_column(colnum0min, colnum0max,\n                    colnumCmin, colnumCmax):\n                if height0 > heightC:\n                    ax._poslayoutbox.constrain_height_min(\n                        axc._poslayoutbox.height * height0 / heightC)\n                    # these constraints stop the smaller axes from\n                    # being allowed to go to zero height...\n                    axc._poslayoutbox.constrain_height_min(\n                        ax._poslayoutbox.height * heightC /\n                        (height0*1.8))\n                elif height0 < heightC:\n                    axc._poslayoutbox.constrain_height_min(\n                        ax._poslayoutbox.height * heightC / height0)\n                    ax._poslayoutbox.constrain_height_min(\n                        ax._poslayoutbox.height * height0 /\n                        (heightC*1.8))\n            # widths...\n            if not alignwidth and dcols0 == dcolsC:\n                ax._poslayoutbox.constrain_width(\n                        axc._poslayoutbox.width * width0 / widthC)\n                alignwidth = True\n            elif _in_same_row(rownum0min, rownum0max,\n                    rownumCmin, rownumCmax):\n                if width0 > widthC:\n                    ax._poslayoutbox.constrain_width_min(\n                            axc._poslayoutbox.width * width0 / widthC)\n                    axc._poslayoutbox.constrain_width_min(\n                            ax._poslayoutbox.width * widthC /\n                            (width0*1.8))\n                elif width0 < widthC:\n                    axc._poslayoutbox.constrain_width_min(\n                            ax._poslayoutbox.width * widthC / width0)\n                    ax._poslayoutbox.constrain_width_min(\n                            axc._poslayoutbox.width * width0 /\n                            (widthC*1.8))",
        "begin_line": 318,
        "end_line": 469,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00026164311878597594,
            "pseudo_dstar_susp": 0.00023435669088352472,
            "pseudo_tarantula_susp": 0.00036010082823190496,
            "pseudo_op2_susp": 0.00023435669088352472,
            "pseudo_barinel_susp": 0.00036010082823190496
        }
    },
    {
        "name": "lib.matplotlib._constrained_layout._arrange_subplotspecs#472",
        "src_path": "lib/matplotlib/_constrained_layout.py",
        "class_name": "lib.matplotlib._constrained_layout",
        "signature": "lib.matplotlib._constrained_layout._arrange_subplotspecs(gs, hspace=0, wspace=0)",
        "snippet": "def _arrange_subplotspecs(gs, hspace=0, wspace=0):\n    \"\"\"Recursively arrange the subplotspec children of the given gridspec.\"\"\"\n    sschildren = []\n    for child in gs.children:\n        if child._is_subplotspec_layoutbox():\n            for child2 in child.children:\n                # check for gridspec children...\n                if child2._is_gridspec_layoutbox():\n                    _arrange_subplotspecs(child2, hspace=hspace, wspace=wspace)\n            sschildren += [child]\n    # now arrange the subplots...\n    for child0 in sschildren:\n        ss0 = child0.artist\n        nrows, ncols = ss0.get_gridspec().get_geometry()\n        rowNum0min, colNum0min = divmod(ss0.num1, ncols)\n        rowNum0max, colNum0max = divmod(ss0.num2, ncols)\n        sschildren = sschildren[1:]\n        for childc in sschildren:\n            ssc = childc.artist\n            rowNumCmin, colNumCmin = divmod(ssc.num1, ncols)\n            rowNumCmax, colNumCmax = divmod(ssc.num2, ncols)\n            # OK, this tells us the relative layout of ax\n            # with axc\n            thepad = wspace / ncols\n            if colNum0max < colNumCmin:\n                layoutbox.hstack([ss0._layoutbox, ssc._layoutbox],\n                        padding=thepad)\n            if colNumCmax < colNum0min:\n                layoutbox.hstack([ssc._layoutbox, ss0._layoutbox],\n                        padding=thepad)\n\n            ####\n            # vertical alignment\n            thepad = hspace / nrows\n            if rowNum0max < rowNumCmin:\n                layoutbox.vstack([ss0._layoutbox,\n                                 ssc._layoutbox],\n                                 padding=thepad)\n            if rowNumCmax < rowNum0min:\n                layoutbox.vstack([ssc._layoutbox,\n                                  ss0._layoutbox],\n                                  padding=thepad)",
        "begin_line": 472,
        "end_line": 513,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00026164311878597594,
            "pseudo_dstar_susp": 0.00023435669088352472,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00023435669088352472,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib._constrained_layout.layoutcolorbarsingle#516",
        "src_path": "lib/matplotlib/_constrained_layout.py",
        "class_name": "lib.matplotlib._constrained_layout",
        "signature": "lib.matplotlib._constrained_layout.layoutcolorbarsingle(ax, cax, shrink, aspect, location, pad=0.05)",
        "snippet": "def layoutcolorbarsingle(ax, cax, shrink, aspect, location, pad=0.05):\n    \"\"\"\n    Do the layout for a colorbar, to not overly pollute colorbar.py\n\n    *pad* is in fraction of the original axis size.\n    \"\"\"\n    axlb = ax._layoutbox\n    axpos = ax._poslayoutbox\n    axsslb = ax.get_subplotspec()._layoutbox\n    lb = layoutbox.LayoutBox(\n            parent=axsslb,\n            name=axsslb.name + '.cbar',\n            artist=cax)\n\n    if location in ('left', 'right'):\n        lbpos = layoutbox.LayoutBox(\n                parent=lb,\n                name=lb.name + '.pos',\n                tightwidth=False,\n                pos=True,\n                subplot=False,\n                artist=cax)\n\n        if location == 'right':\n            # arrange to right of parent axis\n            layoutbox.hstack([axlb, lb], padding=pad * axlb.width,\n                             strength='strong')\n        else:\n            layoutbox.hstack([lb, axlb], padding=pad * axlb.width)\n        # constrain the height and center...\n        layoutbox.match_heights([axpos, lbpos], [1, shrink])\n        layoutbox.align([axpos, lbpos], 'v_center')\n        # set the width of the pos box\n        lbpos.constrain_width(shrink * axpos.height * (1/aspect),\n                              strength='strong')\n    elif location in ('bottom', 'top'):\n        lbpos = layoutbox.LayoutBox(\n                parent=lb,\n                name=lb.name + '.pos',\n                tightheight=True,\n                pos=True,\n                subplot=False,\n                artist=cax)\n\n        if location == 'bottom':\n            layoutbox.vstack([axlb, lb], padding=pad * axlb.height)\n        else:\n            layoutbox.vstack([lb, axlb], padding=pad * axlb.height)\n        # constrain the height and center...\n        layoutbox.match_widths([axpos, lbpos],\n                               [1, shrink], strength='strong')\n        layoutbox.align([axpos, lbpos], 'h_center')\n        # set the height of the pos box\n        lbpos.constrain_height(axpos.width * aspect * shrink,\n                                strength='medium')\n\n    return lb, lbpos",
        "begin_line": 516,
        "end_line": 572,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib._constrained_layout.layoutcolorbargridspec#605",
        "src_path": "lib/matplotlib/_constrained_layout.py",
        "class_name": "lib.matplotlib._constrained_layout",
        "signature": "lib.matplotlib._constrained_layout.layoutcolorbargridspec(parents, cax, shrink, aspect, location, pad=0.05)",
        "snippet": "def layoutcolorbargridspec(parents, cax, shrink, aspect, location, pad=0.05):\n    \"\"\"\n    Do the layout for a colorbar, to not overly pollute colorbar.py\n\n    *pad* is in fraction of the original axis size.\n    \"\"\"\n\n    gs = parents[0].get_subplotspec().get_gridspec()\n    # parent layout box....\n    gslb = gs._layoutbox\n\n    lb = layoutbox.LayoutBox(parent=gslb.parent,\n                             name=gslb.parent.name + '.cbar',\n                             artist=cax)\n    # figure out the row and column extent of the parents.\n    (minrow, maxrow, minax_row, maxax_row,\n     mincol, maxcol, minax_col, maxax_col) = _getmaxminrowcolumn(parents)\n\n    if location in ('left', 'right'):\n        lbpos = layoutbox.LayoutBox(\n                parent=lb,\n                name=lb.name + '.pos',\n                tightwidth=False,\n                pos=True,\n                subplot=False,\n                artist=cax)\n        for ax in parents:\n            if location == 'right':\n                order = [ax._layoutbox, lb]\n            else:\n                order = [lb, ax._layoutbox]\n            layoutbox.hstack(order, padding=pad * gslb.width,\n                         strength='strong')\n        # constrain the height and center...\n        # This isn't quite right.  We'd like the colorbar\n        # pos to line up w/ the axes poss, not the size of the\n        # gs.\n\n        # Horizontal Layout: need to check all the axes in this gridspec\n        for ch in gslb.children:\n            subspec = ch.artist\n            nrows, ncols, row_start, row_stop, col_start, col_stop = \\\n                subspec.get_rows_columns()\n            if location == 'right':\n                if col_stop <= maxcol:\n                    order = [subspec._layoutbox, lb]\n                    # arrange to right of the parents\n                if col_start > maxcol:\n                    order = [lb, subspec._layoutbox]\n            elif location == 'left':\n                if col_start >= mincol:\n                    order = [lb, subspec._layoutbox]\n                if col_stop < mincol:\n                    order = [subspec._layoutbox, lb]\n            layoutbox.hstack(order, padding=pad * gslb.width,\n                             strength='strong')\n\n        # Vertical layout:\n        maxposlb = minax_row._poslayoutbox\n        minposlb = maxax_row._poslayoutbox\n        # now we want the height of the colorbar pos to be\n        # set by the top and bottom of the min/max axes...\n        # bottom            top\n        #     b             t\n        # h = (top-bottom)*shrink\n        # b = bottom + (top-bottom - h) / 2.\n        lbpos.constrain_height(\n                (maxposlb.top - minposlb.bottom) *\n                shrink, strength='strong')\n        lbpos.constrain_bottom(\n                (maxposlb.top - minposlb.bottom) *\n                (1 - shrink)/2 + minposlb.bottom,\n                strength='strong')\n\n        # set the width of the pos box\n        lbpos.constrain_width(lbpos.height * (shrink / aspect),\n                              strength='strong')\n    elif location in ('bottom', 'top'):\n        lbpos = layoutbox.LayoutBox(\n                parent=lb,\n                name=lb.name + '.pos',\n                tightheight=True,\n                pos=True,\n                subplot=False,\n                artist=cax)\n\n        for ax in parents:\n            if location == 'bottom':\n                order = [ax._layoutbox, lb]\n            else:\n                order = [lb, ax._layoutbox]\n            layoutbox.vstack(order, padding=pad * gslb.width,\n                         strength='strong')\n\n        # Vertical Layout: need to check all the axes in this gridspec\n        for ch in gslb.children:\n            subspec = ch.artist\n            nrows, ncols, row_start, row_stop, col_start, col_stop = \\\n                subspec.get_rows_columns()\n            if location == 'bottom':\n                if row_stop <= minrow:\n                    order = [subspec._layoutbox, lb]\n                if row_start > maxrow:\n                    order = [lb, subspec._layoutbox]\n            elif location == 'top':\n                if row_stop < minrow:\n                    order = [subspec._layoutbox, lb]\n                if row_start >= maxrow:\n                    order = [lb, subspec._layoutbox]\n            layoutbox.vstack(order, padding=pad * gslb.width,\n                             strength='strong')\n\n        # Do horizontal layout...\n        maxposlb = maxax_col._poslayoutbox\n        minposlb = minax_col._poslayoutbox\n        lbpos.constrain_width((maxposlb.right - minposlb.left) *\n                              shrink)\n        lbpos.constrain_left(\n                (maxposlb.right - minposlb.left) *\n                (1-shrink)/2 + minposlb.left)\n        # set the height of the pos box\n        lbpos.constrain_height(lbpos.width * shrink * aspect,\n                               strength='medium')\n\n    return lb, lbpos",
        "begin_line": 605,
        "end_line": 729,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020222446916076846,
            "pseudo_dstar_susp": 0.00017319016279875303,
            "pseudo_tarantula_susp": 0.0003850596842510589,
            "pseudo_op2_susp": 0.00017319016279875303,
            "pseudo_barinel_susp": 0.00038491147036181676
        }
    },
    {
        "name": "lib.matplotlib.table.Cell.__init__#65",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Cell",
        "signature": "lib.matplotlib.table.Cell.__init__(self, xy, width, height, edgecolor='k', facecolor='w', fill=True, text='', loc=None, fontproperties=None)",
        "snippet": "    def __init__(self, xy, width, height,\n                 edgecolor='k', facecolor='w',\n                 fill=True,\n                 text='',\n                 loc=None,\n                 fontproperties=None\n                 ):\n\n        # Call base\n        Rectangle.__init__(self, xy, width=width, height=height, fill=fill,\n                           edgecolor=edgecolor, facecolor=facecolor)\n        self.set_clip_on(False)\n\n        # Create text object\n        if loc is None:\n            loc = 'right'\n        self._loc = loc\n        self._text = Text(x=xy[0], y=xy[1], text=text,\n                          fontproperties=fontproperties)\n        self._text.set_clip_on(False)",
        "begin_line": 65,
        "end_line": 84,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003259452411994785,
            "pseudo_dstar_susp": 0.0003132832080200501,
            "pseudo_tarantula_susp": 0.0002789400278940028,
            "pseudo_op2_susp": 0.0003132832080200501,
            "pseudo_barinel_susp": 0.0002789400278940028
        }
    },
    {
        "name": "lib.matplotlib.table.Cell.set_transform#86",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Cell",
        "signature": "lib.matplotlib.table.Cell.set_transform(self, trans)",
        "snippet": "    def set_transform(self, trans):\n        Rectangle.set_transform(self, trans)\n        # the text does not get the transform!\n        self.stale = True",
        "begin_line": 86,
        "end_line": 89,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00029806259314456036,
            "pseudo_dstar_susp": 0.00028851702250432774,
            "pseudo_tarantula_susp": 0.0002603488674824265,
            "pseudo_op2_susp": 0.00028851702250432774,
            "pseudo_barinel_susp": 0.0002603488674824265
        }
    },
    {
        "name": "lib.matplotlib.table.Cell.set_figure#91",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Cell",
        "signature": "lib.matplotlib.table.Cell.set_figure(self, fig)",
        "snippet": "    def set_figure(self, fig):\n        Rectangle.set_figure(self, fig)\n        self._text.set_figure(fig)",
        "begin_line": 91,
        "end_line": 93,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00026881720430107527,
            "pseudo_dstar_susp": 0.00026483050847457627,
            "pseudo_tarantula_susp": 0.00025113008538422905,
            "pseudo_op2_susp": 0.00026483050847457627,
            "pseudo_barinel_susp": 0.00025113008538422905
        }
    },
    {
        "name": "lib.matplotlib.table.Cell.set_fontsize#99",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Cell",
        "signature": "lib.matplotlib.table.Cell.set_fontsize(self, size)",
        "snippet": "    def set_fontsize(self, size):\n        \"\"\"Set the text fontsize.\"\"\"\n        self._text.set_fontsize(size)\n        self.stale = True",
        "begin_line": 99,
        "end_line": 102,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002585983966899405,
            "pseudo_dstar_susp": 0.0002509410288582183,
            "pseudo_tarantula_susp": 0.00026281208935611036,
            "pseudo_op2_susp": 0.0002509410288582183,
            "pseudo_barinel_susp": 0.00026281208935611036
        }
    },
    {
        "name": "lib.matplotlib.table.Cell.get_fontsize#104",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Cell",
        "signature": "lib.matplotlib.table.Cell.get_fontsize(self)",
        "snippet": "    def get_fontsize(self):\n        \"\"\"Return the cell fontsize.\"\"\"\n        return self._text.get_fontsize()",
        "begin_line": 104,
        "end_line": 106,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002644802962179318,
            "pseudo_dstar_susp": 0.00025581990278843696,
            "pseudo_tarantula_susp": 0.0002563445270443476,
            "pseudo_op2_susp": 0.00025581990278843696,
            "pseudo_barinel_susp": 0.0002563445270443476
        }
    },
    {
        "name": "lib.matplotlib.table.Cell.auto_set_font_size#108",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Cell",
        "signature": "lib.matplotlib.table.Cell.auto_set_font_size(self, renderer)",
        "snippet": "    def auto_set_font_size(self, renderer):\n        \"\"\"Shrink font size until the text fits into the cell width.\"\"\"\n        fontsize = self.get_fontsize()\n        required = self.get_required_width(renderer)\n        while fontsize > 1 and required > self.get_width():\n            fontsize -= 1\n            self.set_fontsize(fontsize)\n            required = self.get_required_width(renderer)\n\n        return fontsize",
        "begin_line": 108,
        "end_line": 117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003168567807351077,
            "pseudo_dstar_susp": 0.00030102347983142685,
            "pseudo_tarantula_susp": 0.00029069767441860465,
            "pseudo_op2_susp": 0.00030102347983142685,
            "pseudo_barinel_susp": 0.00029069767441860465
        }
    },
    {
        "name": "lib.matplotlib.table.Cell.draw#120",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Cell",
        "signature": "lib.matplotlib.table.Cell.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        if not self.get_visible():\n            return\n        # draw the rectangle\n        Rectangle.draw(self, renderer)\n\n        # position the text\n        self._set_text_position(renderer)\n        self._text.draw(renderer)\n        self.stale = False",
        "begin_line": 120,
        "end_line": 129,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003257328990228013,
            "pseudo_dstar_susp": 0.00031269543464665416,
            "pseudo_tarantula_susp": 0.0002767783005812344,
            "pseudo_op2_susp": 0.00031269543464665416,
            "pseudo_barinel_susp": 0.0002767783005812344
        }
    },
    {
        "name": "lib.matplotlib.table.Cell._set_text_position#131",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Cell",
        "signature": "lib.matplotlib.table.Cell._set_text_position(self, renderer)",
        "snippet": "    def _set_text_position(self, renderer):\n        \"\"\"Set text up so it draws in the right place.\n\n        Currently support 'left', 'center' and 'right'\n        \"\"\"\n        bbox = self.get_window_extent(renderer)\n        l, b, w, h = bbox.bounds\n\n        # draw in center vertically\n        self._text.set_verticalalignment('center')\n        y = b + (h / 2.0)\n\n        # now position horizontally\n        if self._loc == 'center':\n            self._text.set_horizontalalignment('center')\n            x = l + (w / 2.0)\n        elif self._loc == 'left':\n            self._text.set_horizontalalignment('left')\n            x = l + (w * self.PAD)\n        else:\n            self._text.set_horizontalalignment('right')\n            x = l + (w * (1.0 - self.PAD))\n\n        self._text.set_position((x, y))",
        "begin_line": 131,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000326477309826967,
            "pseudo_dstar_susp": 0.00030959752321981426,
            "pseudo_tarantula_susp": 0.000299311583358276,
            "pseudo_op2_susp": 0.00030959752321981426,
            "pseudo_barinel_susp": 0.000299311583358276
        }
    },
    {
        "name": "lib.matplotlib.table.Cell.get_text_bounds#156",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Cell",
        "signature": "lib.matplotlib.table.Cell.get_text_bounds(self, renderer)",
        "snippet": "    def get_text_bounds(self, renderer):\n        \"\"\"\n        Return the text bounds as *(x, y, width, height)* in table coordinates.\n        \"\"\"\n        bbox = self._text.get_window_extent(renderer)\n        bboxa = bbox.inverse_transformed(self.get_data_transform())\n        return bboxa.bounds",
        "begin_line": 156,
        "end_line": 162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003178639542275906,
            "pseudo_dstar_susp": 0.0002994011976047904,
            "pseudo_tarantula_susp": 0.00027533039647577095,
            "pseudo_op2_susp": 0.0002994011976047904,
            "pseudo_barinel_susp": 0.00027533039647577095
        }
    },
    {
        "name": "lib.matplotlib.table.CustomCell.__init__#194",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.CustomCell",
        "signature": "lib.matplotlib.table.CustomCell.__init__(self, *args, visible_edges, **kwargs)",
        "snippet": "    def __init__(self, *args, visible_edges, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.visible_edges = visible_edges",
        "begin_line": 194,
        "end_line": 196,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00025687130747495504,
            "pseudo_dstar_susp": 0.0002508780732563974,
            "pseudo_tarantula_susp": 0.0002532286654849329,
            "pseudo_op2_susp": 0.0002508780732563974,
            "pseudo_barinel_susp": 0.0002532286654849329
        }
    },
    {
        "name": "lib.matplotlib.table.CustomCell.visible_edges#212",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.CustomCell",
        "signature": "lib.matplotlib.table.CustomCell.visible_edges(self, value)",
        "snippet": "    def visible_edges(self, value):\n        if value is None:\n            self._visible_edges = self._edges\n        elif value in self._edge_aliases:\n            self._visible_edges = self._edge_aliases[value]\n        else:\n            if any(edge not in self._edges for edge in value):\n                raise ValueError('Invalid edge param {}, must only be one of '\n                                 '{} or string of {}'.format(\n                                     value,\n                                     \", \".join(self._edge_aliases),\n                                     \", \".join(self._edges)))\n            self._visible_edges = value\n        self.stale = True",
        "begin_line": 212,
        "end_line": 225,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023501762632197415,
            "pseudo_dstar_susp": 0.00022055580061755624,
            "pseudo_tarantula_susp": 0.0002946375957572186,
            "pseudo_op2_susp": 0.00022055580061755624,
            "pseudo_barinel_susp": 0.0002945508100147275
        }
    },
    {
        "name": "lib.matplotlib.table.CustomCell.get_path#227",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.CustomCell",
        "signature": "lib.matplotlib.table.CustomCell.get_path(self)",
        "snippet": "    def get_path(self):\n        \"\"\"Return a `.Path` for the `.visible_edges`.\"\"\"\n        codes = [Path.MOVETO]\n        codes.extend(\n            Path.LINETO if edge in self._visible_edges else Path.MOVETO\n            for edge in self._edges)\n        if Path.MOVETO not in codes[1:]:  # All sides are visible\n            codes[-1] = Path.CLOSEPOLY\n        return Path(\n            [[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0], [0.0, 0.0]],\n            codes,\n            readonly=True\n            )",
        "begin_line": 227,
        "end_line": 239,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00031938677738741617,
            "pseudo_dstar_susp": 0.0003003003003003003,
            "pseudo_tarantula_susp": 0.00035587188612099647,
            "pseudo_op2_susp": 0.0003003003003003003,
            "pseudo_barinel_susp": 0.00035587188612099647
        }
    },
    {
        "name": "lib.matplotlib.table.Table.__init__#283",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table.__init__(self, ax, loc=None, bbox=None, **kwargs)",
        "snippet": "    def __init__(self, ax, loc=None, bbox=None, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        ax : `matplotlib.axes.Axes`\n            The `~.axes.Axes` to plot the table into.\n        loc : str\n            The position of the cell with respect to *ax*. This must be one of\n            the `~.Table.codes`.\n        bbox : `.Bbox` or None\n            A bounding box to draw the table into. If this is not *None*, this\n            overrides *loc*.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            `.Artist` properties.\n        \"\"\"\n\n        Artist.__init__(self)\n\n        if isinstance(loc, str):\n            if loc not in self.codes:\n                cbook.warn_deprecated(\n                    \"3.1\", message=\"Unrecognized location {!r}. Falling back \"\n                    \"on 'bottom'; valid locations are\\n\\t{}\\n\"\n                    \"This will raise an exception %(removal)s.\"\n                    .format(loc, '\\n\\t'.join(self.codes)))\n                loc = 'bottom'\n            loc = self.codes[loc]\n        self.set_figure(ax.figure)\n        self._axes = ax\n        self._loc = loc\n        self._bbox = bbox\n\n        # use axes coords\n        ax._unstale_viewLim()\n        self.set_transform(ax.transAxes)\n\n        self._cells = {}\n        self._edges = None\n        self._autoColumns = []\n        self._autoFontsize = True\n        self.update(kwargs)\n\n        self.set_clip_on(False)",
        "begin_line": 283,
        "end_line": 328,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020222446916076846,
            "pseudo_dstar_susp": 0.00017319016279875303,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00017319016279875303,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.table.Table.add_cell#330",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table.add_cell(self, row, col, *args, **kwargs)",
        "snippet": "    def add_cell(self, row, col, *args, **kwargs):\n        \"\"\"\n        Create a cell and add it to the table.\n\n        Parameters\n        ----------\n        row : int\n            Row index.\n        col : int\n            Column index.\n        *args, **kwargs\n            All other parameters are passed on to `Cell`.\n\n        Returns\n        -------\n        cell : `.CustomCell`\n            The created cell.\n\n        \"\"\"\n        xy = (0, 0)\n        cell = CustomCell(xy, visible_edges=self.edges, *args, **kwargs)\n        self[row, col] = cell\n        return cell",
        "begin_line": 330,
        "end_line": 352,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019527436047646945,
            "pseudo_dstar_susp": 0.00017214666896195557,
            "pseudo_tarantula_susp": 0.00032393909944930353,
            "pseudo_op2_susp": 0.00017214666896195557,
            "pseudo_barinel_susp": 0.00032393909944930353
        }
    },
    {
        "name": "lib.matplotlib.table.Table.__setitem__#354",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table.__setitem__(self, position, cell)",
        "snippet": "    def __setitem__(self, position, cell):\n        \"\"\"\n        Set a custom cell in a given position.\n        \"\"\"\n        cbook._check_isinstance(CustomCell, cell=cell)\n        try:\n            row, col = position[0], position[1]\n        except Exception:\n            raise KeyError('Only tuples length 2 are accepted as coordinates')\n        cell.set_figure(self.figure)\n        cell.set_transform(self.get_transform())\n        cell.set_clip_on(False)\n        self._cells[row, col] = cell\n        self.stale = True",
        "begin_line": 354,
        "end_line": 367,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019527436047646945,
            "pseudo_dstar_susp": 0.00017214666896195557,
            "pseudo_tarantula_susp": 0.00032393909944930353,
            "pseudo_op2_susp": 0.00017214666896195557,
            "pseudo_barinel_susp": 0.00032393909944930353
        }
    },
    {
        "name": "lib.matplotlib.table.Table._approx_text_height#397",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table._approx_text_height(self)",
        "snippet": "    def _approx_text_height(self):\n        return (self.FONTSIZE / 72.0 * self.figure.dpi /\n                self._axes.bbox.height * 1.2)",
        "begin_line": 397,
        "end_line": 399,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020222446916076846,
            "pseudo_dstar_susp": 0.00017319016279875303,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00017319016279875303,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.table.Table.draw#402",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        # docstring inherited\n\n        # Need a renderer to do hit tests on mouseevent; assume the last one\n        # will do\n        if renderer is None:\n            renderer = self.figure._cachedRenderer\n        if renderer is None:\n            raise RuntimeError('No renderer defined')\n\n        if not self.get_visible():\n            return\n        renderer.open_group('table', gid=self.get_gid())\n        self._update_positions(renderer)\n\n        for key in sorted(self._cells):\n            self._cells[key].draw(renderer)\n\n        renderer.close_group('table')\n        self.stale = False",
        "begin_line": 402,
        "end_line": 421,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021150592216582064,
            "pseudo_dstar_susp": 0.00017458100558659218,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00017458100558659218,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.table.Table._get_grid_bbox#423",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table._get_grid_bbox(self, renderer)",
        "snippet": "    def _get_grid_bbox(self, renderer):\n        \"\"\"\n        Get a bbox, in axes co-ordinates for the cells.\n\n        Only include those in the range (0, 0) to (maxRow, maxCol).\n        \"\"\"\n        boxes = [cell.get_window_extent(renderer)\n                 for (row, col), cell in self._cells.items()\n                 if row >= 0 and col >= 0]\n        bbox = Bbox.union(boxes)\n        return bbox.inverse_transformed(self.get_transform())",
        "begin_line": 423,
        "end_line": 433,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021150592216582064,
            "pseudo_dstar_susp": 0.00017458100558659218,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00017458100558659218,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.table.Table.get_window_extent#456",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table.get_window_extent(self, renderer)",
        "snippet": "    def get_window_extent(self, renderer):\n        \"\"\"Return the bounding box of the table in window coords.\"\"\"\n        self._update_positions(renderer)\n        boxes = [cell.get_window_extent(renderer)\n                 for cell in self._cells.values()]\n        return Bbox.union(boxes)",
        "begin_line": 456,
        "end_line": 461,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.table.Table._do_cell_alignment#463",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table._do_cell_alignment(self)",
        "snippet": "    def _do_cell_alignment(self):\n        \"\"\"\n        Calculate row heights and column widths; position cells accordingly.\n        \"\"\"\n        # Calculate row/column widths\n        widths = {}\n        heights = {}\n        for (row, col), cell in self._cells.items():\n            height = heights.setdefault(row, 0.0)\n            heights[row] = max(height, cell.get_height())\n            width = widths.setdefault(col, 0.0)\n            widths[col] = max(width, cell.get_width())\n\n        # work out left position for each column\n        xpos = 0\n        lefts = {}\n        for col in sorted(widths):\n            lefts[col] = xpos\n            xpos += widths[col]\n\n        ypos = 0\n        bottoms = {}\n        for row in sorted(heights, reverse=True):\n            bottoms[row] = ypos\n            ypos += heights[row]\n\n        # set cell positions\n        for (row, col), cell in self._cells.items():\n            cell.set_x(lefts[col])\n            cell.set_y(bottoms[row])",
        "begin_line": 463,
        "end_line": 492,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021150592216582064,
            "pseudo_dstar_susp": 0.00017458100558659218,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00017458100558659218,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.table.Table.auto_set_column_width#494",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table.auto_set_column_width(self, col)",
        "snippet": "    def auto_set_column_width(self, col):\n        \"\"\"\n        Automatically set the widths of given columns to optimal sizes.\n\n        Parameters\n        ----------\n        col : int or sequence of ints\n            The indices of the columns to auto-scale.\n        \"\"\"\n        # check for col possibility on iteration\n        try:\n            iter(col)\n        except (TypeError, AttributeError):\n            self._autoColumns.append(col)\n        else:\n            for cell in col:\n                self._autoColumns.append(cell)\n\n        self.stale = True",
        "begin_line": 494,
        "end_line": 512,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019916351324437363,
            "pseudo_dstar_susp": 0.00016353229762878168,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00016353229762878168,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.table.Table._auto_set_column_width#514",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table._auto_set_column_width(self, col, renderer)",
        "snippet": "    def _auto_set_column_width(self, col, renderer):\n        \"\"\"Automatically set width for column.\"\"\"\n        cells = [cell for key, cell in self._cells.items() if key[1] == col]\n        max_width = max((cell.get_required_width(renderer) for cell in cells),\n                        default=0)\n        for cell in cells:\n            cell.set_width(max_width)",
        "begin_line": 514,
        "end_line": 520,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019916351324437363,
            "pseudo_dstar_susp": 0.00016353229762878168,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00016353229762878168,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.table.Table._auto_set_font_size#527",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table._auto_set_font_size(self, renderer)",
        "snippet": "    def _auto_set_font_size(self, renderer):\n\n        if len(self._cells) == 0:\n            return\n        fontsize = next(iter(self._cells.values())).get_fontsize()\n        cells = []\n        for key, cell in self._cells.items():\n            # ignore auto-sized columns\n            if key[1] in self._autoColumns:\n                continue\n            size = cell.auto_set_font_size(renderer)\n            fontsize = min(fontsize, size)\n            cells.append(cell)\n\n        # now set all fontsizes equal\n        for cell in self._cells.values():\n            cell.set_fontsize(fontsize)",
        "begin_line": 527,
        "end_line": 543,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019916351324437363,
            "pseudo_dstar_susp": 0.00016353229762878168,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00016353229762878168,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.table.Table._offset#576",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table._offset(self, ox, oy)",
        "snippet": "    def _offset(self, ox, oy):\n        \"\"\"Move all the artists by ox, oy (axes coords).\"\"\"\n        for c in self._cells.values():\n            x, y = c.get_x(), c.get_y()\n            c.set_x(x + ox)\n            c.set_y(y + oy)",
        "begin_line": 576,
        "end_line": 581,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021150592216582064,
            "pseudo_dstar_susp": 0.00017458100558659218,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00017458100558659218,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.table.Table._update_positions#583",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table._update_positions(self, renderer)",
        "snippet": "    def _update_positions(self, renderer):\n        # called from renderer to allow more precise estimates of\n        # widths and heights with get_window_extent\n\n        # Do any auto width setting\n        for col in self._autoColumns:\n            self._auto_set_column_width(col, renderer)\n\n        if self._autoFontsize:\n            self._auto_set_font_size(renderer)\n\n        # Align all the cells\n        self._do_cell_alignment()\n\n        bbox = self._get_grid_bbox(renderer)\n        l, b, w, h = bbox.bounds\n\n        if self._bbox is not None:\n            # Position according to bbox\n            rl, rb, rw, rh = self._bbox\n            self.scale(rw / w, rh / h)\n            ox = rl - l\n            oy = rb - b\n            self._do_cell_alignment()\n        else:\n            # Position using loc\n            (BEST, UR, UL, LL, LR, CL, CR, LC, UC, C,\n             TR, TL, BL, BR, R, L, T, B) = range(len(self.codes))\n            # defaults for center\n            ox = (0.5 - w / 2) - l\n            oy = (0.5 - h / 2) - b\n            if self._loc in (UL, LL, CL):   # left\n                ox = self.AXESPAD - l\n            if self._loc in (BEST, UR, LR, R, CR):  # right\n                ox = 1 - (l + w + self.AXESPAD)\n            if self._loc in (BEST, UR, UL, UC):     # upper\n                oy = 1 - (b + h + self.AXESPAD)\n            if self._loc in (LL, LR, LC):           # lower\n                oy = self.AXESPAD - b\n            if self._loc in (LC, UC, C):            # center x\n                ox = (0.5 - w / 2) - l\n            if self._loc in (CL, CR, C):            # center y\n                oy = (0.5 - h / 2) - b\n\n            if self._loc in (TL, BL, L):            # out left\n                ox = - (l + w)\n            if self._loc in (TR, BR, R):            # out right\n                ox = 1.0 - l\n            if self._loc in (TR, TL, T):            # out top\n                oy = 1.0 - b\n            if self._loc in (BL, BR, B):           # out bottom\n                oy = - (b + h)\n\n        self._offset(ox, oy)",
        "begin_line": 583,
        "end_line": 636,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021150592216582064,
            "pseudo_dstar_susp": 0.00017458100558659218,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00017458100558659218,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.table.table#658",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table",
        "signature": "lib.matplotlib.table.table(ax, cellText=None, cellColours=None, cellLoc='right', colWidths=None, rowLabels=None, rowColours=None, rowLoc='left', colLabels=None, colColours=None, colLoc='center', loc='bottom', bbox=None, edges='closed', **kwargs)",
        "snippet": "def table(ax,\n          cellText=None, cellColours=None,\n          cellLoc='right', colWidths=None,\n          rowLabels=None, rowColours=None, rowLoc='left',\n          colLabels=None, colColours=None, colLoc='center',\n          loc='bottom', bbox=None, edges='closed',\n          **kwargs):\n    \"\"\"\n    Add a table to an `~.axes.Axes`.\n\n    At least one of *cellText* or *cellColours* must be specified. These\n    parameters must be 2D lists, in which the outer lists define the rows and\n    the inner list define the column values per row. Each row must have the\n    same number of elements.\n\n    The table can optionally have row and column headers, which are configured\n    using *rowLabels*, *rowColours*, *rowLoc* and *colLabels*, *colColours*,\n    *colLoc* respectively.\n\n    For finer grained control over tables, use the `.Table` class and add it to\n    the axes with `.Axes.add_table`.\n\n    Parameters\n    ----------\n    cellText : 2D list of str, optional\n        The texts to place into the table cells.\n\n        *Note*: Line breaks in the strings are currently not accounted for and\n        will result in the text exceeding the cell boundaries.\n\n    cellColours : 2D list of colors, optional\n        The background colors of the cells.\n\n    cellLoc : {'left', 'center', 'right'}, default: 'right'\n        The alignment of the text within the cells.\n\n    colWidths : list of float, optional\n        The column widths in units of the axes. If not given, all columns will\n        have a width of *1 / ncols*.\n\n    rowLabels : list of str, optional\n        The text of the row header cells.\n\n    rowColours : list of colors, optional\n        The colors of the row header cells.\n\n    rowLoc : {'left', 'center', 'right'}, optional, default: 'left'\n        The text alignment of the row header cells.\n\n    colLabels : list of str, optional\n        The text of the column header cells.\n\n    colColours : list of colors, optional\n        The colors of the column header cells.\n\n    colLoc : {'left', 'center', 'right'}, optional, default: 'left'\n        The text alignment of the column header cells.\n\n    loc : str, optional\n        The position of the cell with respect to *ax*. This must be one of\n        the `~.Table.codes`.\n\n    bbox : `.Bbox`, optional\n        A bounding box to draw the table into. If this is not *None*, this\n        overrides *loc*.\n\n    edges : substring of 'BRTL' or {'open', 'closed', 'horizontal', 'vertical'}\n        The cell edges to be drawn with a line. See also\n        `~.CustomCell.visible_edges`.\n\n    Other Parameters\n    ----------------\n    **kwargs\n        `.Table` properties.\n\n    %(Table)s\n\n    Returns\n    -------\n    table : `~matplotlib.table.Table`\n        The created table.\n    \"\"\"\n\n    if cellColours is None and cellText is None:\n        raise ValueError('At least one argument from \"cellColours\" or '\n                         '\"cellText\" must be provided to create a table.')\n\n    # Check we have some cellText\n    if cellText is None:\n        # assume just colours are needed\n        rows = len(cellColours)\n        cols = len(cellColours[0])\n        cellText = [[''] * cols] * rows\n\n    rows = len(cellText)\n    cols = len(cellText[0])\n    for row in cellText:\n        if len(row) != cols:\n            raise ValueError(\"Each row in 'cellText' must have {} columns\"\n                             .format(cols))\n\n    if cellColours is not None:\n        if len(cellColours) != rows:\n            raise ValueError(\"'cellColours' must have {} rows\".format(rows))\n        for row in cellColours:\n            if len(row) != cols:\n                raise ValueError(\"Each row in 'cellColours' must have {} \"\n                                 \"columns\".format(cols))\n    else:\n        cellColours = ['w' * cols] * rows\n\n    # Set colwidths if not given\n    if colWidths is None:\n        colWidths = [1.0 / cols] * cols\n\n    # Fill in missing information for column\n    # and row labels\n    rowLabelWidth = 0\n    if rowLabels is None:\n        if rowColours is not None:\n            rowLabels = [''] * rows\n            rowLabelWidth = colWidths[0]\n    elif rowColours is None:\n        rowColours = 'w' * rows\n\n    if rowLabels is not None:\n        if len(rowLabels) != rows:\n            raise ValueError(\"'rowLabels' must be of length {0}\".format(rows))\n\n    # If we have column labels, need to shift\n    # the text and colour arrays down 1 row\n    offset = 1\n    if colLabels is None:\n        if colColours is not None:\n            colLabels = [''] * cols\n        else:\n            offset = 0\n    elif colColours is None:\n        colColours = 'w' * cols\n\n    # Set up cell colours if not given\n    if cellColours is None:\n        cellColours = ['w' * cols] * rows\n\n    # Now create the table\n    table = Table(ax, loc, bbox, **kwargs)\n    table.edges = edges\n    height = table._approx_text_height()\n\n    # Add the cells\n    for row in range(rows):\n        for col in range(cols):\n            table.add_cell(row + offset, col,\n                           width=colWidths[col], height=height,\n                           text=cellText[row][col],\n                           facecolor=cellColours[row][col],\n                           loc=cellLoc)\n    # Do column labels\n    if colLabels is not None:\n        for col in range(cols):\n            table.add_cell(0, col,\n                           width=colWidths[col], height=height,\n                           text=colLabels[col], facecolor=colColours[col],\n                           loc=colLoc)\n\n    # Do row labels\n    if rowLabels is not None:\n        for row in range(rows):\n            table.add_cell(row + offset, -1,\n                           width=rowLabelWidth or 1e-15, height=height,\n                           text=rowLabels[row], facecolor=rowColours[row],\n                           loc=rowLoc)\n        if rowLabelWidth == 0:\n            table.auto_set_column_width(-1)\n\n    ax.add_table(table)\n    return table",
        "begin_line": 658,
        "end_line": 834,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021150592216582064,
            "pseudo_dstar_susp": 0.00017458100558659218,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00017458100558659218,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.ticker._DummyAxis.get_view_interval#201",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker._DummyAxis",
        "signature": "lib.matplotlib.ticker._DummyAxis.get_view_interval(self)",
        "snippet": "    def get_view_interval(self):\n        return self.viewLim.intervalx",
        "begin_line": 201,
        "end_line": 202,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013939224979091162,
            "pseudo_dstar_susp": 0.000194325689856199,
            "pseudo_tarantula_susp": 0.00011954572624028691,
            "pseudo_op2_susp": 0.000194325689856199,
            "pseudo_barinel_susp": 0.00011954572624028691
        }
    },
    {
        "name": "lib.matplotlib.ticker.TickHelper.set_axis#224",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.TickHelper",
        "signature": "lib.matplotlib.ticker.TickHelper.set_axis(self, axis)",
        "snippet": "    def set_axis(self, axis):\n        self.axis = axis",
        "begin_line": 224,
        "end_line": 225,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004816955684007707,
            "pseudo_dstar_susp": 0.0006349206349206349,
            "pseudo_tarantula_susp": 0.00016299918500407498,
            "pseudo_op2_susp": 0.0006349206349206349,
            "pseudo_barinel_susp": 0.00016299918500407498
        }
    },
    {
        "name": "lib.matplotlib.ticker.TickHelper.create_dummy_axis#227",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.TickHelper",
        "signature": "lib.matplotlib.ticker.TickHelper.create_dummy_axis(self, **kwargs)",
        "snippet": "    def create_dummy_axis(self, **kwargs):\n        if self.axis is None:\n            self.axis = _DummyAxis(**kwargs)",
        "begin_line": 227,
        "end_line": 229,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016273393002441008,
            "pseudo_dstar_susp": 0.0002151462994836489,
            "pseudo_tarantula_susp": 0.000122684333210649,
            "pseudo_op2_susp": 0.0002151462994836489,
            "pseudo_barinel_susp": 0.000122684333210649
        }
    },
    {
        "name": "lib.matplotlib.ticker.TickHelper.set_view_interval#231",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.TickHelper",
        "signature": "lib.matplotlib.ticker.TickHelper.set_view_interval(self, vmin, vmax)",
        "snippet": "    def set_view_interval(self, vmin, vmax):\n        self.axis.set_view_interval(vmin, vmax)",
        "begin_line": 231,
        "end_line": 232,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00024740227610094015,
            "pseudo_dstar_susp": 0.00030674846625766873,
            "pseudo_tarantula_susp": 0.00016149870801033592,
            "pseudo_op2_susp": 0.00030674846625766873,
            "pseudo_barinel_susp": 0.00016149870801033592
        }
    },
    {
        "name": "lib.matplotlib.ticker.TickHelper.set_data_interval#234",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.TickHelper",
        "signature": "lib.matplotlib.ticker.TickHelper.set_data_interval(self, vmin, vmax)",
        "snippet": "    def set_data_interval(self, vmin, vmax):\n        self.axis.set_data_interval(vmin, vmax)",
        "begin_line": 234,
        "end_line": 235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002461841457410143,
            "pseudo_dstar_susp": 0.00029886431560071725,
            "pseudo_tarantula_susp": 0.00017577781683951485,
            "pseudo_op2_susp": 0.00029886431560071725,
            "pseudo_barinel_susp": 0.00017577781683951485
        }
    },
    {
        "name": "lib.matplotlib.ticker.Formatter.format_ticks#257",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.Formatter",
        "signature": "lib.matplotlib.ticker.Formatter.format_ticks(self, values)",
        "snippet": "    def format_ticks(self, values):\n        \"\"\"Return the tick labels for all the ticks at once.\"\"\"\n        self.set_locs(values)\n        return [self(value, i) for i, value in enumerate(values)]",
        "begin_line": 257,
        "end_line": 260,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003303600925008259,
            "pseudo_dstar_susp": 0.0003444712366517396,
            "pseudo_tarantula_susp": 0.0003291639236339697,
            "pseudo_op2_susp": 0.0003444712366517396,
            "pseudo_barinel_susp": 0.0003291639236339697
        }
    },
    {
        "name": "lib.matplotlib.ticker.Formatter.get_offset#277",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.Formatter",
        "signature": "lib.matplotlib.ticker.Formatter.get_offset(self)",
        "snippet": "    def get_offset(self):\n        return ''",
        "begin_line": 277,
        "end_line": 278,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00023126734505087883,
            "pseudo_dstar_susp": 0.00022040996253030638,
            "pseudo_tarantula_susp": 0.0002644802962179318,
            "pseudo_op2_susp": 0.00022040996253030638,
            "pseudo_barinel_susp": 0.0002644802962179318
        }
    },
    {
        "name": "lib.matplotlib.ticker.Formatter.set_locs#280",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.Formatter",
        "signature": "lib.matplotlib.ticker.Formatter.set_locs(self, locs)",
        "snippet": "    def set_locs(self, locs):\n        self.locs = locs",
        "begin_line": 280,
        "end_line": 281,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005387931034482759,
            "pseudo_dstar_susp": 0.0004342162396873643,
            "pseudo_tarantula_susp": 0.00035398230088495576,
            "pseudo_op2_susp": 0.0004342162396873643,
            "pseudo_barinel_susp": 0.00035398230088495576
        }
    },
    {
        "name": "lib.matplotlib.ticker.Formatter._set_locator#299",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.Formatter",
        "signature": "lib.matplotlib.ticker.Formatter._set_locator(self, locator)",
        "snippet": "    def _set_locator(self, locator):\n        \"\"\"Subclasses may want to override this to set a locator.\"\"\"\n        pass",
        "begin_line": 299,
        "end_line": 301,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00025393600812595224,
            "pseudo_dstar_susp": 0.0002402691013935608,
            "pseudo_tarantula_susp": 0.0003170577045022194,
            "pseudo_op2_susp": 0.0002402691013935608,
            "pseudo_barinel_susp": 0.0003170577045022194
        }
    },
    {
        "name": "lib.matplotlib.ticker.FixedFormatter.__init__#347",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.FixedFormatter",
        "signature": "lib.matplotlib.ticker.FixedFormatter.__init__(self, seq)",
        "snippet": "    def __init__(self, seq):\n        \"\"\"\n        Set the sequence of strings that will be used for labels.\n        \"\"\"\n        self.seq = seq\n        self.offset_string = ''",
        "begin_line": 347,
        "end_line": 352,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.ticker.FixedFormatter.__call__#354",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.FixedFormatter",
        "signature": "lib.matplotlib.ticker.FixedFormatter.__call__(self, x, pos=None)",
        "snippet": "    def __call__(self, x, pos=None):\n        \"\"\"\n        Returns the label that matches the position regardless of the\n        value.\n\n        For positions ``pos < len(seq)``, return ``seq[i]`` regardless of\n        *x*. Otherwise return empty string. ``seq`` is the sequence of\n        strings that this object was initialized with.\n        \"\"\"\n        if pos is None or pos >= len(self.seq):\n            return ''\n        else:\n            return self.seq[pos]",
        "begin_line": 354,
        "end_line": 366,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.ticker.FixedFormatter.get_offset#368",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.FixedFormatter",
        "signature": "lib.matplotlib.ticker.FixedFormatter.get_offset(self)",
        "snippet": "    def get_offset(self):\n        return self.offset_string",
        "begin_line": 368,
        "end_line": 369,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.ticker.FixedFormatter.set_offset_string#371",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.FixedFormatter",
        "signature": "lib.matplotlib.ticker.FixedFormatter.set_offset_string(self, ofs)",
        "snippet": "    def set_offset_string(self, ofs):\n        self.offset_string = ofs",
        "begin_line": 371,
        "end_line": 372,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017325017325017325,
            "pseudo_dstar_susp": 0.00014448779078167894,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00014448779078167894,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.ticker.StrMethodFormatter.__init__#422",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.StrMethodFormatter",
        "signature": "lib.matplotlib.ticker.StrMethodFormatter.__init__(self, fmt)",
        "snippet": "    def __init__(self, fmt):\n        self.fmt = fmt",
        "begin_line": 422,
        "end_line": 423,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.ScalarFormatter.__init__#512",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.ScalarFormatter",
        "signature": "lib.matplotlib.ticker.ScalarFormatter.__init__(self, useOffset=None, useMathText=None, useLocale=None)",
        "snippet": "    def __init__(self, useOffset=None, useMathText=None, useLocale=None):\n        # useOffset allows plotting small data ranges with large offsets: for\n        # example: [1+1e-9, 1+2e-9, 1+3e-9] useMathText will render the offset\n        # and scientific notation in mathtext\n\n        if useOffset is None:\n            useOffset = rcParams['axes.formatter.useoffset']\n        self._offset_threshold = rcParams['axes.formatter.offset_threshold']\n        self.set_useOffset(useOffset)\n        self._usetex = rcParams['text.usetex']\n        if useMathText is None:\n            useMathText = rcParams['axes.formatter.use_mathtext']\n        self.set_useMathText(useMathText)\n        self.orderOfMagnitude = 0\n        self.format = ''\n        self._scientific = True\n        self._powerlimits = rcParams['axes.formatter.limits']\n        if useLocale is None:\n            useLocale = rcParams['axes.formatter.use_locale']\n        self._useLocale = useLocale",
        "begin_line": 512,
        "end_line": 531,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004332755632582322,
            "pseudo_dstar_susp": 0.0005659309564233164,
            "pseudo_tarantula_susp": 0.0003170577045022194,
            "pseudo_op2_susp": 0.0005659309564233164,
            "pseudo_barinel_susp": 0.0003170577045022194
        }
    },
    {
        "name": "lib.matplotlib.ticker.ScalarFormatter.set_useOffset#536",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.ScalarFormatter",
        "signature": "lib.matplotlib.ticker.ScalarFormatter.set_useOffset(self, val)",
        "snippet": "    def set_useOffset(self, val):\n        if val in [True, False]:\n            self.offset = 0\n            self._useOffset = val\n        else:\n            self._useOffset = False\n            self.offset = val",
        "begin_line": 536,
        "end_line": 542,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040257648953301127,
            "pseudo_dstar_susp": 0.0005509641873278236,
            "pseudo_tarantula_susp": 0.00014992503748125936,
            "pseudo_op2_susp": 0.0005509641873278236,
            "pseudo_barinel_susp": 0.00014992503748125936
        }
    },
    {
        "name": "lib.matplotlib.ticker.ScalarFormatter.set_useMathText#560",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.ScalarFormatter",
        "signature": "lib.matplotlib.ticker.ScalarFormatter.set_useMathText(self, val)",
        "snippet": "    def set_useMathText(self, val):\n        if val is None:\n            self._useMathText = rcParams['axes.formatter.use_mathtext']\n        else:\n            self._useMathText = val",
        "begin_line": 560,
        "end_line": 564,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00033715441672285906,
            "pseudo_dstar_susp": 0.0004149377593360996,
            "pseudo_tarantula_susp": 0.00029197080291970805,
            "pseudo_op2_susp": 0.0004149377593360996,
            "pseudo_barinel_susp": 0.00029197080291970805
        }
    },
    {
        "name": "lib.matplotlib.ticker.ScalarFormatter.fix_minus#568",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.ScalarFormatter",
        "signature": "lib.matplotlib.ticker.ScalarFormatter.fix_minus(self, s)",
        "snippet": "    def fix_minus(self, s):\n        \"\"\"\n        Replace hyphens with a unicode minus.\n        \"\"\"\n        if rcParams['text.usetex'] or not rcParams['axes.unicode_minus']:\n            return s\n        else:\n            return s.replace('-', '\\N{MINUS SIGN}')",
        "begin_line": 568,
        "end_line": 575,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004952947003467063,
            "pseudo_dstar_susp": 0.0003566333808844508,
            "pseudo_tarantula_susp": 0.00036010082823190496,
            "pseudo_op2_susp": 0.0003566333808844508,
            "pseudo_barinel_susp": 0.00036010082823190496
        }
    },
    {
        "name": "lib.matplotlib.ticker.ScalarFormatter.__call__#577",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.ScalarFormatter",
        "signature": "lib.matplotlib.ticker.ScalarFormatter.__call__(self, x, pos=None)",
        "snippet": "    def __call__(self, x, pos=None):\n        \"\"\"\n        Return the format for tick value *x* at position *pos*.\n        \"\"\"\n        if len(self.locs) == 0:\n            return ''\n        else:\n            xp = (x - self.offset) / (10. ** self.orderOfMagnitude)\n            if np.abs(xp) < 1e-8:\n                xp = 0\n            if self._useLocale:\n                s = locale.format_string(self.format, (xp,))\n            else:\n                s = self.format % xp\n            return self.fix_minus(s)",
        "begin_line": 577,
        "end_line": 591,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005125576627370579,
            "pseudo_dstar_susp": 0.0003604902667627974,
            "pseudo_tarantula_susp": 0.0003204101249599487,
            "pseudo_op2_susp": 0.0003604902667627974,
            "pseudo_barinel_susp": 0.0003204101249599487
        }
    },
    {
        "name": "lib.matplotlib.ticker.ScalarFormatter.get_offset#648",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.ScalarFormatter",
        "signature": "lib.matplotlib.ticker.ScalarFormatter.get_offset(self)",
        "snippet": "    def get_offset(self):\n        \"\"\"\n        Return scientific notation, plus offset.\n        \"\"\"\n        if len(self.locs) == 0:\n            return ''\n        s = ''\n        if self.orderOfMagnitude or self.offset:\n            offsetStr = ''\n            sciNotStr = ''\n            if self.offset:\n                offsetStr = self.format_data(self.offset)\n                if self.offset > 0:\n                    offsetStr = '+' + offsetStr\n            if self.orderOfMagnitude:\n                if self._usetex or self._useMathText:\n                    sciNotStr = self.format_data(10 ** self.orderOfMagnitude)\n                else:\n                    sciNotStr = '1e%d' % self.orderOfMagnitude\n            if self._useMathText:\n                if sciNotStr != '':\n                    sciNotStr = r'\\times%s' % _mathdefault(sciNotStr)\n                s = ''.join(('$', sciNotStr, _mathdefault(offsetStr), '$'))\n            elif self._usetex:\n                if sciNotStr != '':\n                    sciNotStr = r'\\times%s' % sciNotStr\n                s = ''.join(('$', sciNotStr, offsetStr, '$'))\n            else:\n                s = ''.join((sciNotStr, offsetStr))\n\n        return self.fix_minus(s)",
        "begin_line": 648,
        "end_line": 678,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005211047420531526,
            "pseudo_dstar_susp": 0.0003632401017072285,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0003632401017072285,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.ticker.ScalarFormatter.set_locs#680",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.ScalarFormatter",
        "signature": "lib.matplotlib.ticker.ScalarFormatter.set_locs(self, locs)",
        "snippet": "    def set_locs(self, locs):\n        \"\"\"\n        Set the locations of the ticks.\n        \"\"\"\n        self.locs = locs\n        if len(self.locs) > 0:\n            if self._useOffset:\n                self._compute_offset()\n            self._set_order_of_magnitude()\n            self._set_format()",
        "begin_line": 680,
        "end_line": 689,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005341880341880342,
            "pseudo_dstar_susp": 0.00036603221083455345,
            "pseudo_tarantula_susp": 0.00023326335432703523,
            "pseudo_op2_susp": 0.00036603221083455345,
            "pseudo_barinel_susp": 0.00023326335432703523
        }
    },
    {
        "name": "lib.matplotlib.ticker.ScalarFormatter._compute_offset#691",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.ScalarFormatter",
        "signature": "lib.matplotlib.ticker.ScalarFormatter._compute_offset(self)",
        "snippet": "    def _compute_offset(self):\n        locs = self.locs\n        # Restrict to visible ticks.\n        vmin, vmax = sorted(self.axis.get_view_interval())\n        locs = np.asarray(locs)\n        locs = locs[(vmin <= locs) & (locs <= vmax)]\n        if not len(locs):\n            self.offset = 0\n            return\n        lmin, lmax = locs.min(), locs.max()\n        # Only use offset if there are at least two ticks and every tick has\n        # the same sign.\n        if lmin == lmax or lmin <= 0 <= lmax:\n            self.offset = 0\n            return\n        # min, max comparing absolute values (we want division to round towards\n        # zero so we work on absolute values).\n        abs_min, abs_max = sorted([abs(float(lmin)), abs(float(lmax))])\n        sign = math.copysign(1, lmin)\n        # What is the smallest power of ten such that abs_min and abs_max are\n        # equal up to that precision?\n        # Note: Internally using oom instead of 10 ** oom avoids some numerical\n        # accuracy issues.\n        oom_max = np.ceil(math.log10(abs_max))\n        oom = 1 + next(oom for oom in itertools.count(oom_max, -1)\n                       if abs_min // 10 ** oom != abs_max // 10 ** oom)\n        if (abs_max - abs_min) / 10 ** oom <= 1e-2:\n            # Handle the case of straddling a multiple of a large power of ten\n            # (relative to the span).\n            # What is the smallest power of ten such that abs_min and abs_max\n            # are no more than 1 apart at that precision?\n            oom = 1 + next(oom for oom in itertools.count(oom_max, -1)\n                           if abs_max // 10 ** oom - abs_min // 10 ** oom > 1)\n        # Only use offset if it saves at least _offset_threshold digits.\n        n = self._offset_threshold - 1\n        self.offset = (sign * (abs_max // 10 ** oom) * 10 ** oom\n                       if abs_max // 10 ** oom >= 10**n\n                       else 0)",
        "begin_line": 691,
        "end_line": 728,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005224660397074191,
            "pseudo_dstar_susp": 0.00035829451809387314,
            "pseudo_tarantula_susp": 0.00032393909944930353,
            "pseudo_op2_susp": 0.00035829451809387314,
            "pseudo_barinel_susp": 0.00032393909944930353
        }
    },
    {
        "name": "lib.matplotlib.ticker.ScalarFormatter._set_order_of_magnitude#730",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.ScalarFormatter",
        "signature": "lib.matplotlib.ticker.ScalarFormatter._set_order_of_magnitude(self)",
        "snippet": "    def _set_order_of_magnitude(self):\n        # if scientific notation is to be used, find the appropriate exponent\n        # if using an numerical offset, find the exponent after applying the\n        # offset. When lower power limit = upper <> 0, use provided exponent.\n        if not self._scientific:\n            self.orderOfMagnitude = 0\n            return\n        if self._powerlimits[0] == self._powerlimits[1] != 0:\n            # fixed scaling when lower power limit = upper <> 0.\n            self.orderOfMagnitude = self._powerlimits[0]\n            return\n        # restrict to visible ticks\n        vmin, vmax = sorted(self.axis.get_view_interval())\n        locs = np.asarray(self.locs)\n        locs = locs[(vmin <= locs) & (locs <= vmax)]\n        locs = np.abs(locs)\n        if not len(locs):\n            self.orderOfMagnitude = 0\n            return\n        if self.offset:\n            oom = math.floor(math.log10(vmax - vmin))\n        else:\n            if locs[0] > locs[-1]:\n                val = locs[0]\n            else:\n                val = locs[-1]\n            if val == 0:\n                oom = 0\n            else:\n                oom = math.floor(math.log10(val))\n        if oom <= self._powerlimits[0]:\n            self.orderOfMagnitude = oom\n        elif oom >= self._powerlimits[1]:\n            self.orderOfMagnitude = oom\n        else:\n            self.orderOfMagnitude = 0",
        "begin_line": 730,
        "end_line": 765,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005293806246691371,
            "pseudo_dstar_susp": 0.000363901018922853,
            "pseudo_tarantula_susp": 0.0002314814814814815,
            "pseudo_op2_susp": 0.000363901018922853,
            "pseudo_barinel_susp": 0.0002314814814814815
        }
    },
    {
        "name": "lib.matplotlib.ticker.ScalarFormatter._set_format#767",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.ScalarFormatter",
        "signature": "lib.matplotlib.ticker.ScalarFormatter._set_format(self)",
        "snippet": "    def _set_format(self):\n        # set the format string to format all the ticklabels\n        if len(self.locs) < 2:\n            # Temporarily augment the locations with the axis end points.\n            _locs = [*self.locs, *self.axis.get_view_interval()]\n        else:\n            _locs = self.locs\n        locs = (np.asarray(_locs) - self.offset) / 10. ** self.orderOfMagnitude\n        loc_range = np.ptp(locs)\n        # Curvilinear coordinates can yield two identical points.\n        if loc_range == 0:\n            loc_range = np.max(np.abs(locs))\n        # Both points might be zero.\n        if loc_range == 0:\n            loc_range = 1\n        if len(self.locs) < 2:\n            # We needed the end points only for the loc_range calculation.\n            locs = locs[:-2]\n        loc_range_oom = int(math.floor(math.log10(loc_range)))\n        # first estimate:\n        sigfigs = max(0, 3 - loc_range_oom)\n        # refined estimate:\n        thresh = 1e-3 * 10 ** loc_range_oom\n        while sigfigs >= 0:\n            if np.abs(locs - np.round(locs, decimals=sigfigs)).max() < thresh:\n                sigfigs -= 1\n            else:\n                break\n        sigfigs += 1\n        self.format = '%1.' + str(sigfigs) + 'f'\n        if self._usetex:\n            self.format = '$%s$' % self.format\n        elif self._useMathText:\n            self.format = '$%s$' % _mathdefault(self.format)",
        "begin_line": 767,
        "end_line": 800,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00048567265662943174,
            "pseudo_dstar_susp": 0.0003637686431429611,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.0003637686431429611,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.ticker.ScalarFormatter._formatSciNotation#812",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.ScalarFormatter",
        "signature": "lib.matplotlib.ticker.ScalarFormatter._formatSciNotation(self, s)",
        "snippet": "    def _formatSciNotation(self, s):\n        # transform 1e+004 into 1e4, for example\n        if self._useLocale:\n            decimal_point = locale.localeconv()['decimal_point']\n            positive_sign = locale.localeconv()['positive_sign']\n        else:\n            decimal_point = '.'\n            positive_sign = '+'\n        tup = s.split('e')\n        try:\n            significand = tup[0].rstrip('0').rstrip(decimal_point)\n            sign = tup[1][0].replace(positive_sign, '')\n            exponent = tup[1][1:].lstrip('0')\n            if self._useMathText or self._usetex:\n                if significand == '1' and exponent != '':\n                    # reformat 1x10^y as 10^y\n                    significand = ''\n                if exponent:\n                    exponent = '10^{%s%s}' % (sign, exponent)\n                if significand and exponent:\n                    return r'%s{\\times}%s' % (significand, exponent)\n                else:\n                    return r'%s%s' % (significand, exponent)\n            else:\n                s = ('%se%s%s' % (significand, sign, exponent)).rstrip('e')\n                return s\n        except IndexError:\n            return s",
        "begin_line": 812,
        "end_line": 839,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogFormatter.__init__#900",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogFormatter",
        "signature": "lib.matplotlib.ticker.LogFormatter.__init__(self, base=10.0, labelOnlyBase=False, minor_thresholds=None, linthresh=None)",
        "snippet": "    def __init__(self, base=10.0, labelOnlyBase=False,\n                 minor_thresholds=None,\n                 linthresh=None):\n\n        self._base = float(base)\n        self.labelOnlyBase = labelOnlyBase\n        if minor_thresholds is None:\n            if rcParams['_internal.classic_mode']:\n                minor_thresholds = (0, 0)\n            else:\n                minor_thresholds = (1, 0.4)\n        self.minor_thresholds = minor_thresholds\n        self._sublabels = None\n        self._linthresh = linthresh",
        "begin_line": 900,
        "end_line": 913,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogFormatter.set_locs#937",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogFormatter",
        "signature": "lib.matplotlib.ticker.LogFormatter.set_locs(self, locs=None)",
        "snippet": "    def set_locs(self, locs=None):\n        \"\"\"\n        Use axis view limits to control which ticks are labeled.\n\n        The *locs* parameter is ignored in the present algorithm.\n\n        \"\"\"\n        if np.isinf(self.minor_thresholds[0]):\n            self._sublabels = None\n            return\n\n        # Handle symlog case:\n        linthresh = self._linthresh\n        if linthresh is None:\n            try:\n                linthresh = self.axis.get_transform().linthresh\n            except AttributeError:\n                pass\n\n        vmin, vmax = self.axis.get_view_interval()\n        if vmin > vmax:\n            vmin, vmax = vmax, vmin\n\n        if linthresh is None and vmin <= 0:\n            # It's probably a colorbar with\n            # a format kwarg setting a LogFormatter in the manner\n            # that worked with 1.5.x, but that doesn't work now.\n            self._sublabels = {1}  # label powers of base\n            return\n\n        b = self._base\n        if linthresh is not None:  # symlog\n            # Only compute the number of decades in the logarithmic part of the\n            # axis\n            numdec = 0\n            if vmin < -linthresh:\n                rhs = min(vmax, -linthresh)\n                numdec += math.log(vmin / rhs) / math.log(b)\n            if vmax > linthresh:\n                lhs = max(vmin, linthresh)\n                numdec += math.log(vmax / lhs) / math.log(b)\n        else:\n            vmin = math.log(vmin) / math.log(b)\n            vmax = math.log(vmax) / math.log(b)\n            numdec = abs(vmax - vmin)\n\n        if numdec > self.minor_thresholds[0]:\n            # Label only bases\n            self._sublabels = {1}\n        elif numdec > self.minor_thresholds[1]:\n            # Add labels between bases at log-spaced coefficients;\n            # include base powers in case the locations include\n            # \"major\" and \"minor\" points, as in colorbar.\n            c = np.logspace(0, 1, int(b)//2 + 1, base=b)\n            self._sublabels = set(np.round(c))\n            # For base 10, this yields (1, 2, 3, 4, 6, 10).\n        else:\n            # Label all integer multiples of base**n.\n            self._sublabels = set(np.arange(1, b + 1))",
        "begin_line": 937,
        "end_line": 995,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogFormatter._num_to_string#997",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogFormatter",
        "signature": "lib.matplotlib.ticker.LogFormatter._num_to_string(self, x, vmin, vmax)",
        "snippet": "    def _num_to_string(self, x, vmin, vmax):\n        if x > 10000:\n            s = '%1.0e' % x\n        elif x < 1:\n            s = '%1.0e' % x\n        else:\n            s = self._pprint_val(x, vmax - vmin)\n        return s",
        "begin_line": 997,
        "end_line": 1004,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.498342823149486e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogFormatter.__call__#1006",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogFormatter",
        "signature": "lib.matplotlib.ticker.LogFormatter.__call__(self, x, pos=None)",
        "snippet": "    def __call__(self, x, pos=None):\n        \"\"\"\n        Return the format for tick val *x*.\n        \"\"\"\n        if x == 0.0:  # Symlog\n            return '0'\n\n        x = abs(x)\n        b = self._base\n        # only label the decades\n        fx = math.log(x) / math.log(b)\n        is_x_decade = is_close_to_int(fx)\n        exponent = round(fx) if is_x_decade else np.floor(fx)\n        coeff = round(x / b ** exponent)\n\n        if self.labelOnlyBase and not is_x_decade:\n            return ''\n        if self._sublabels is not None and coeff not in self._sublabels:\n            return ''\n\n        vmin, vmax = self.axis.get_view_interval()\n        vmin, vmax = mtransforms.nonsingular(vmin, vmax, expander=0.05)\n        s = self._num_to_string(x, vmin, vmax)\n        return self.fix_minus(s)",
        "begin_line": 1006,
        "end_line": 1029,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.79423226812159e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogFormatter._pprint_val#1048",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogFormatter",
        "signature": "lib.matplotlib.ticker.LogFormatter._pprint_val(self, x, d)",
        "snippet": "    def _pprint_val(self, x, d):\n        # If the number is not too big and it's an int, format it as an int.\n        if abs(x) < 1e4 and x == int(x):\n            return '%d' % x\n        fmt = ('%1.3e' if d < 1e-2 else\n               '%1.3f' if d <= 1 else\n               '%1.2f' if d <= 10 else\n               '%1.1f' if d <= 1e5 else\n               '%1.1e')\n        s = fmt % x\n        tup = s.split('e')\n        if len(tup) == 2:\n            mantissa = tup[0].rstrip('0').rstrip('.')\n            exponent = int(tup[1])\n            if exponent:\n                s = '%se%d' % (mantissa, exponent)\n            else:\n                s = mantissa\n        else:\n            s = s.rstrip('0').rstrip('.')\n        return s",
        "begin_line": 1048,
        "end_line": 1068,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.833307222309259e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogFormatterMathtext.__call__#1100",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogFormatterMathtext",
        "signature": "lib.matplotlib.ticker.LogFormatterMathtext.__call__(self, x, pos=None)",
        "snippet": "    def __call__(self, x, pos=None):\n        \"\"\"\n        Return the format for tick value *x*.\n\n        The position *pos* is ignored.\n        \"\"\"\n        usetex = rcParams['text.usetex']\n        min_exp = rcParams['axes.formatter.min_exponent']\n\n        if x == 0:  # Symlog\n            if usetex:\n                return '$0$'\n            else:\n                return '$%s$' % _mathdefault('0')\n\n        sign_string = '-' if x < 0 else ''\n        x = abs(x)\n        b = self._base\n\n        # only label the decades\n        fx = math.log(x) / math.log(b)\n        is_x_decade = is_close_to_int(fx)\n        exponent = round(fx) if is_x_decade else np.floor(fx)\n        coeff = round(x / b ** exponent)\n        if is_x_decade:\n            fx = round(fx)\n\n        if self.labelOnlyBase and not is_x_decade:\n            return ''\n        if self._sublabels is not None and coeff not in self._sublabels:\n            return ''\n\n        # use string formatting of the base if it is not an integer\n        if b % 1 == 0.0:\n            base = '%d' % b\n        else:\n            base = '%s' % b\n\n        if np.abs(fx) < min_exp:\n            if usetex:\n                return r'${0}{1:g}$'.format(sign_string, x)\n            else:\n                return '${0}$'.format(_mathdefault(\n                    '{0}{1:g}'.format(sign_string, x)))\n        elif not is_x_decade:\n            return self._non_decade_format(sign_string, base, fx, usetex)\n        elif usetex:\n            return r'$%s%s^{%d}$' % (sign_string, base, fx)\n        else:\n            return '$%s$' % _mathdefault('%s%s^{%d}' % (sign_string, base, fx))",
        "begin_line": 1100,
        "end_line": 1149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00017914725904693657,
            "pseudo_dstar_susp": 0.000195160031225605,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.000195160031225605,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogFormatterSciNotation._non_decade_format#1157",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogFormatterSciNotation",
        "signature": "lib.matplotlib.ticker.LogFormatterSciNotation._non_decade_format(self, sign_string, base, fx, usetex)",
        "snippet": "    def _non_decade_format(self, sign_string, base, fx, usetex):\n        'Return string for non-decade locations'\n        b = float(base)\n        exponent = math.floor(fx)\n        coeff = b ** fx / b ** exponent\n        if is_close_to_int(coeff):\n            coeff = round(coeff)\n        if usetex:\n            return (r'$%s%g\\times%s^{%d}$') % \\\n                                        (sign_string, coeff, base, exponent)\n        else:\n            return ('$%s$' % _mathdefault(r'%s%g\\times%s^{%d}' %\n                                        (sign_string, coeff, base, exponent)))",
        "begin_line": 1157,
        "end_line": 1169,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.03793907242183e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitFormatter.__init__#1177",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitFormatter",
        "signature": "lib.matplotlib.ticker.LogitFormatter.__init__(self, *, use_overline=False, one_half='\\\\frac{1}{2}', minor=False, minor_threshold=25, minor_number=6)",
        "snippet": "    def __init__(\n        self,\n        *,\n        use_overline=False,\n        one_half=r\"\\frac{1}{2}\",\n        minor=False,\n        minor_threshold=25,\n        minor_number=6,\n    ):\n        r\"\"\"\n        Parameters\n        ----------\n        use_overline : bool, default: False\n            If x > 1/2, with x = 1-v, indicate if x should be displayed as\n            $\\overline{v}$. The default is to display $1-v$.\n\n        one_half : str, default: r\"\\frac{1}{2}\"\n            The string used to represent 1/2.\n\n        minor : bool, default: False\n            Indicate if the formatter is formatting minor ticks or not.\n            Basically minor ticks are not labelled, except when only few ticks\n            are provided, ticks with most space with neighbor ticks are\n            labelled. See other parameters to change the default behavior.\n\n        minor_threshold : int, default: 25\n            Maximum number of locs for labelling some minor ticks. This\n            parameter have no effect if minor is False.\n\n        minor_number : int, default: 6\n            Number of ticks which are labelled when the number of ticks is\n            below the threshold.\n        \"\"\"\n        self._use_overline = use_overline\n        self._one_half = one_half\n        self._minor = minor\n        self._labelled = set()\n        self._minor_threshold = minor_threshold\n        self._minor_number = minor_number",
        "begin_line": 1177,
        "end_line": 1215,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitFormatter.use_overline#1217",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitFormatter",
        "signature": "lib.matplotlib.ticker.LogitFormatter.use_overline(self, use_overline)",
        "snippet": "    def use_overline(self, use_overline):\n        r\"\"\"\n        Switch display mode with overline for labelling p>1/2.\n\n        Parameters\n        ----------\n        use_overline : bool, default: False\n            If x > 1/2, with x = 1-v, indicate if x should be displayed as\n            $\\overline{v}$. The default is to display $1-v$.\n        \"\"\"\n        self._use_overline = use_overline",
        "begin_line": 1217,
        "end_line": 1227,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitFormatter.set_minor_threshold#1238",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitFormatter",
        "signature": "lib.matplotlib.ticker.LogitFormatter.set_minor_threshold(self, minor_threshold)",
        "snippet": "    def set_minor_threshold(self, minor_threshold):\n        \"\"\"\n        Set the threshold for labelling minors ticks.\n\n        Parameters\n        ----------\n        minor_threshold : int\n            Maximum number of locations for labelling some minor ticks. This\n            parameter have no effect if minor is False.\n        \"\"\"\n        self._minor_threshold = minor_threshold",
        "begin_line": 1238,
        "end_line": 1248,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitFormatter.set_minor_number#1250",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitFormatter",
        "signature": "lib.matplotlib.ticker.LogitFormatter.set_minor_number(self, minor_number)",
        "snippet": "    def set_minor_number(self, minor_number):\n        \"\"\"\n        Set the number of minor ticks to label when some minor ticks are\n        labelled.\n\n        Parameters\n        ----------\n        minor_number : int\n            Number of ticks which are labelled when the number of ticks is\n            below the threshold.\n        \"\"\"\n        self._minor_number = minor_number",
        "begin_line": 1250,
        "end_line": 1261,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitFormatter.set_locs#1263",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitFormatter",
        "signature": "lib.matplotlib.ticker.LogitFormatter.set_locs(self, locs)",
        "snippet": "    def set_locs(self, locs):\n        self.locs = np.array(locs)\n        self._labelled.clear()\n\n        if not self._minor:\n            return None\n        if all(\n            is_decade(x, rtol=1e-7)\n            or is_decade(1 - x, rtol=1e-7)\n            or (is_close_to_int(2 * x) and int(np.round(2 * x)) == 1)\n            for x in locs\n        ):\n            # minor ticks are subsample from ideal, so no label\n            return None\n        if len(locs) < self._minor_threshold:\n            if len(locs) < self._minor_number:\n                self._labelled.update(locs)\n            else:\n                # we do not have a lot of minor ticks, so only few decades are\n                # displayed, then we choose some (spaced) minor ticks to label.\n                # Only minor ticks are known, we assume it is sufficient to\n                # choice which ticks are displayed.\n                # For each ticks we compute the distance between the ticks and\n                # the previous, and between the ticks and the next one. Ticks\n                # with smallest minimum are chosen. As tiebreak, the ticks\n                # with smallest sum is chosen.\n                diff = np.diff(-np.log(1 / self.locs - 1))\n                space_pessimistic = np.minimum(\n                    np.concatenate(((np.inf,), diff)),\n                    np.concatenate((diff, (np.inf,))),\n                )\n                space_sum = (\n                    np.concatenate(((0,), diff))\n                    + np.concatenate((diff, (0,)))\n                )\n                good_minor = sorted(\n                    range(len(self.locs)),\n                    key=lambda i: (space_pessimistic[i], space_sum[i]),\n                )[-self._minor_number:]\n                self._labelled.update(locs[i] for i in good_minor)",
        "begin_line": 1263,
        "end_line": 1302,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitFormatter._format_value#1304",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitFormatter",
        "signature": "lib.matplotlib.ticker.LogitFormatter._format_value(self, x, locs, sci_notation=True)",
        "snippet": "    def _format_value(self, x, locs, sci_notation=True):\n        if sci_notation:\n            exponent = math.floor(np.log10(x))\n            min_precision = 0\n        else:\n            exponent = 0\n            min_precision = 1\n        value = x * 10 ** (-exponent)\n        if len(locs) < 2:\n            precision = min_precision\n        else:\n            diff = np.sort(np.abs(locs - x))[1]\n            precision = -np.log10(diff) + exponent\n            precision = (\n                int(np.round(precision))\n                if is_close_to_int(precision)\n                else math.ceil(precision)\n            )\n            if precision < min_precision:\n                precision = min_precision\n        mantissa = r\"%.*f\" % (precision, value)\n        if not sci_notation:\n            return mantissa\n        s = r\"%s\\cdot10^{%d}\" % (mantissa, exponent)\n        return s",
        "begin_line": 1304,
        "end_line": 1328,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.498342823149486e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitFormatter._one_minus#1330",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitFormatter",
        "signature": "lib.matplotlib.ticker.LogitFormatter._one_minus(self, s)",
        "snippet": "    def _one_minus(self, s):\n        if self._use_overline:\n            return r\"\\overline{%s}\" % s\n        else:\n            return \"1-{}\".format(s)",
        "begin_line": 1330,
        "end_line": 1334,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitFormatter.__call__#1336",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitFormatter",
        "signature": "lib.matplotlib.ticker.LogitFormatter.__call__(self, x, pos=None)",
        "snippet": "    def __call__(self, x, pos=None):\n        if self._minor and x not in self._labelled:\n            return \"\"\n        if x <= 0 or x >= 1:\n            return \"\"\n        usetex = rcParams[\"text.usetex\"]\n\n        if is_close_to_int(2 * x) and round(2 * x) == 1:\n            s = self._one_half\n        elif x < 0.5 and is_decade(x, rtol=1e-7):\n            exponent = round(np.log10(x))\n            s = \"10^{%d}\" % exponent\n        elif x > 0.5 and is_decade(1 - x, rtol=1e-7):\n            exponent = round(np.log10(1 - x))\n            s = self._one_minus(\"10^{%d}\" % exponent)\n        elif x < 0.1:\n            s = self._format_value(x, self.locs)\n        elif x > 0.9:\n            s = self._one_minus(self._format_value(1-x, 1-self.locs))\n        else:\n            s = self._format_value(x, self.locs, sci_notation=False)\n        if usetex:\n            return \"$%s$\" % s\n        return \"$%s$\" % _mathdefault(s)",
        "begin_line": 1336,
        "end_line": 1359,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.498342823149486e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.EngFormatter.__init__#1401",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.EngFormatter",
        "signature": "lib.matplotlib.ticker.EngFormatter.__init__(self, unit='', places=None, sep=' ', *, usetex=None, useMathText=None)",
        "snippet": "    def __init__(self, unit=\"\", places=None, sep=\" \", *, usetex=None,\n                 useMathText=None):\n        r\"\"\"\n        Parameters\n        ----------\n        unit : str (default: \"\")\n            Unit symbol to use, suitable for use with single-letter\n            representations of powers of 1000. For example, 'Hz' or 'm'.\n\n        places : int (default: None)\n            Precision with which to display the number, specified in\n            digits after the decimal point (there will be between one\n            and three digits before the decimal point). If it is None,\n            the formatting falls back to the floating point format '%g',\n            which displays up to 6 *significant* digits, i.e. the equivalent\n            value for *places* varies between 0 and 5 (inclusive).\n\n        sep : str (default: \" \")\n            Separator used between the value and the prefix/unit. For\n            example, one get '3.14 mV' if ``sep`` is \" \" (default) and\n            '3.14mV' if ``sep`` is \"\". Besides the default behavior, some\n            other useful options may be:\n\n            * ``sep=\"\"`` to append directly the prefix/unit to the value;\n            * ``sep=\"\\N{THIN SPACE}\"`` (``U+2009``);\n            * ``sep=\"\\N{NARROW NO-BREAK SPACE}\"`` (``U+202F``);\n            * ``sep=\"\\N{NO-BREAK SPACE}\"`` (``U+00A0``).\n\n        usetex : bool (default: None)\n            To enable/disable the use of TeX's math mode for rendering the\n            numbers in the formatter.\n\n        useMathText : bool (default: None)\n            To enable/disable the use mathtext for rendering the numbers in\n            the formatter.\n        \"\"\"\n        self.unit = unit\n        self.places = places\n        self.sep = sep\n        self.set_usetex(usetex)\n        self.set_useMathText(useMathText)",
        "begin_line": 1401,
        "end_line": 1441,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 7.771215418091389e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.EngFormatter.set_usetex#1446",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.EngFormatter",
        "signature": "lib.matplotlib.ticker.EngFormatter.set_usetex(self, val)",
        "snippet": "    def set_usetex(self, val):\n        if val is None:\n            self._usetex = rcParams['text.usetex']\n        else:\n            self._usetex = val",
        "begin_line": 1446,
        "end_line": 1450,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.EngFormatter.set_useMathText#1457",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.EngFormatter",
        "signature": "lib.matplotlib.ticker.EngFormatter.set_useMathText(self, val)",
        "snippet": "    def set_useMathText(self, val):\n        if val is None:\n            self._useMathText = rcParams['axes.formatter.use_mathtext']\n        else:\n            self._useMathText = val",
        "begin_line": 1457,
        "end_line": 1461,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.EngFormatter.fix_minus#1465",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.EngFormatter",
        "signature": "lib.matplotlib.ticker.EngFormatter.fix_minus(self, s)",
        "snippet": "    def fix_minus(self, s):\n        \"\"\"\n        Replace hyphens with a unicode minus.\n        \"\"\"\n        return ScalarFormatter.fix_minus(self, s)",
        "begin_line": 1465,
        "end_line": 1469,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.EngFormatter.__call__#1471",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.EngFormatter",
        "signature": "lib.matplotlib.ticker.EngFormatter.__call__(self, x, pos=None)",
        "snippet": "    def __call__(self, x, pos=None):\n        s = \"%s%s\" % (self.format_eng(x), self.unit)\n        # Remove the trailing separator when there is neither prefix nor unit\n        if self.sep and s.endswith(self.sep):\n            s = s[:-len(self.sep)]\n        return self.fix_minus(s)",
        "begin_line": 1471,
        "end_line": 1476,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.EngFormatter.format_eng#1478",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.EngFormatter",
        "signature": "lib.matplotlib.ticker.EngFormatter.format_eng(self, num)",
        "snippet": "    def format_eng(self, num):\n        \"\"\"\n        Formats a number in engineering notation, appending a letter\n        representing the power of 1000 of the original number.\n        Some examples:\n\n        >>> format_eng(0)       # for self.places = 0\n        '0'\n\n        >>> format_eng(1000000) # for self.places = 1\n        '1.0 M'\n\n        >>> format_eng(\"-1e-6\") # for self.places = 2\n        '-1.00 \\N{MICRO SIGN}'\n        \"\"\"\n        sign = 1\n        fmt = \"g\" if self.places is None else \".{:d}f\".format(self.places)\n\n        if num < 0:\n            sign = -1\n            num = -num\n\n        if num != 0:\n            pow10 = int(math.floor(math.log10(num) / 3) * 3)\n        else:\n            pow10 = 0\n            # Force num to zero, to avoid inconsistencies like\n            # format_eng(-0) = \"0\" and format_eng(0.0) = \"0\"\n            # but format_eng(-0.0) = \"-0.0\"\n            num = 0.0\n\n        pow10 = np.clip(pow10, min(self.ENG_PREFIXES), max(self.ENG_PREFIXES))\n\n        mant = sign * num / (10.0 ** pow10)\n        # Taking care of the cases like 999.9..., which may be rounded to 1000\n        # instead of 1 k.  Beware of the corner case of values that are beyond\n        # the range of SI prefixes (i.e. > 'Y').\n        if (abs(float(format(mant, fmt))) >= 1000\n                   and pow10 < max(self.ENG_PREFIXES)):\n            mant /= 1000\n            pow10 += 3\n\n        prefix = self.ENG_PREFIXES[int(pow10)]\n        if self._usetex or self._useMathText:\n            formatted = \"${mant:{fmt}}${sep}{prefix}\".format(\n                mant=mant, sep=self.sep, prefix=prefix, fmt=fmt)\n        else:\n            formatted = \"{mant:{fmt}}{sep}{prefix}\".format(\n                mant=mant, sep=self.sep, prefix=prefix, fmt=fmt)\n\n        return formatted",
        "begin_line": 1478,
        "end_line": 1528,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.PercentFormatter.__init__#1557",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.PercentFormatter",
        "signature": "lib.matplotlib.ticker.PercentFormatter.__init__(self, xmax=100, decimals=None, symbol='%', is_latex=False)",
        "snippet": "    def __init__(self, xmax=100, decimals=None, symbol='%', is_latex=False):\n        self.xmax = xmax + 0.0\n        self.decimals = decimals\n        self._symbol = symbol\n        self._is_latex = is_latex",
        "begin_line": 1557,
        "end_line": 1561,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.PercentFormatter.format_pct#1572",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.PercentFormatter",
        "signature": "lib.matplotlib.ticker.PercentFormatter.format_pct(self, x, display_range)",
        "snippet": "    def format_pct(self, x, display_range):\n        \"\"\"\n        Formats the number as a percentage number with the correct\n        number of decimals and adds the percent symbol, if any.\n\n        If `self.decimals` is `None`, the number of digits after the\n        decimal point is set based on the `display_range` of the axis\n        as follows:\n\n        +---------------+----------+------------------------+\n        | display_range | decimals |          sample        |\n        +---------------+----------+------------------------+\n        | >50           |     0    | ``x = 34.5`` => 35%    |\n        +---------------+----------+------------------------+\n        | >5            |     1    | ``x = 34.5`` => 34.5%  |\n        +---------------+----------+------------------------+\n        | >0.5          |     2    | ``x = 34.5`` => 34.50% |\n        +---------------+----------+------------------------+\n        |      ...      |    ...   |          ...           |\n        +---------------+----------+------------------------+\n\n        This method will not be very good for tiny axis ranges or\n        extremely large ones. It assumes that the values on the chart\n        are percentages displayed on a reasonable scale.\n        \"\"\"\n        x = self.convert_to_pct(x)\n        if self.decimals is None:\n            # conversion works because display_range is a difference\n            scaled_range = self.convert_to_pct(display_range)\n            if scaled_range <= 0:\n                decimals = 0\n            else:\n                # Luckily Python's built-in ceil rounds to +inf, not away from\n                # zero. This is very important since the equation for decimals\n                # starts out as `scaled_range > 0.5 * 10**(2 - decimals)`\n                # and ends up with `decimals > 2 - log10(2 * scaled_range)`.\n                decimals = math.ceil(2.0 - math.log10(2.0 * scaled_range))\n                if decimals > 5:\n                    decimals = 5\n                elif decimals < 0:\n                    decimals = 0\n        else:\n            decimals = self.decimals\n        s = '{x:0.{decimals}f}'.format(x=x, decimals=int(decimals))\n\n        return s + self.symbol",
        "begin_line": 1572,
        "end_line": 1617,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.03793907242183e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.PercentFormatter.symbol#1623",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.PercentFormatter",
        "signature": "lib.matplotlib.ticker.PercentFormatter.symbol(self)",
        "snippet": "    def symbol(self):\n        r\"\"\"\n        The configured percent symbol as a string.\n\n        If LaTeX is enabled via :rc:`text.usetex`, the special characters\n        ``{'#', '$', '%', '&', '~', '_', '^', '\\', '{', '}'}`` are\n        automatically escaped in the string.\n        \"\"\"\n        symbol = self._symbol\n        if not symbol:\n            symbol = ''\n        elif rcParams['text.usetex'] and not self._is_latex:\n            # Source: http://www.personal.ceu.hu/tex/specchar.htm\n            # Backslash must be first for this to work correctly since\n            # it keeps getting added in\n            for spec in r'\\#$%&~_^{}':\n                symbol = symbol.replace(spec, '\\\\' + spec)\n        return symbol",
        "begin_line": 1623,
        "end_line": 1640,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.Locator.set_params#1679",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.Locator",
        "signature": "lib.matplotlib.ticker.Locator.set_params(self, **kwargs)",
        "snippet": "    def set_params(self, **kwargs):\n        \"\"\"\n        Do nothing, and raise a warning. Any locator class not supporting the\n        set_params() function will call this.\n        \"\"\"\n        cbook._warn_external(\n            \"'set_params()' not defined for locator of type \" +\n            str(type(self)))",
        "begin_line": 1679,
        "end_line": 1686,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.Locator.raise_if_exceeds#1694",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.Locator",
        "signature": "lib.matplotlib.ticker.Locator.raise_if_exceeds(self, locs)",
        "snippet": "    def raise_if_exceeds(self, locs):\n        \"\"\"\n        Log at WARNING level if *locs* is longer than `Locator.MAXTICKS`.\n\n        This is intended to be called immediately before returning *locs* from\n        ``__call__`` to inform users in case their Locator returns a huge\n        number of ticks, causing Matplotlib to run out of memory.\n\n        The \"strange\" name of this method dates back to when it would raise an\n        exception instead of emitting a log.\n        \"\"\"\n        if len(locs) >= self.MAXTICKS:\n            _log.warning(\n                \"Locator attempting to generate %s ticks ([%s, ..., %s]), \"\n                \"which exceeds Locator.MAXTICKS (%s).\",\n                len(locs), locs[0], locs[-1], self.MAXTICKS)\n        return locs",
        "begin_line": 1694,
        "end_line": 1710,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000468384074941452,
            "pseudo_dstar_susp": 0.00039856516540454366,
            "pseudo_tarantula_susp": 0.00035248501938667606,
            "pseudo_op2_susp": 0.00039856516540454366,
            "pseudo_barinel_susp": 0.00035248501938667606
        }
    },
    {
        "name": "lib.matplotlib.ticker.Locator.nonsingular#1712",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.Locator",
        "signature": "lib.matplotlib.ticker.Locator.nonsingular(self, v0, v1)",
        "snippet": "    def nonsingular(self, v0, v1):\n        \"\"\"\n        Adjust a range as needed to avoid singularities.\n\n        This method gets called during autoscaling, with ``(v0, v1)`` set to\n        the data limits on the axes if the axes contains any data, or\n        ``(-inf, +inf)`` if not.\n\n        - If ``v0 == v1`` (possibly up to some floating point slop), this\n          method returns an expanded interval around this value.\n        - If ``(v0, v1) == (-inf, +inf)``, this method returns appropriate\n          default view limits.\n        - Otherwise, ``(v0, v1)`` is returned without modification.\n        \"\"\"\n        return mtransforms.nonsingular(v0, v1, expander=.05)",
        "begin_line": 1712,
        "end_line": 1726,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004033884630899556,
            "pseudo_dstar_susp": 0.0005820721769499418,
            "pseudo_tarantula_susp": 0.0002860411899313501,
            "pseudo_op2_susp": 0.0005820721769499418,
            "pseudo_barinel_susp": 0.0002860411899313501
        }
    },
    {
        "name": "lib.matplotlib.ticker.Locator.view_limits#1728",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.Locator",
        "signature": "lib.matplotlib.ticker.Locator.view_limits(self, vmin, vmax)",
        "snippet": "    def view_limits(self, vmin, vmax):\n        \"\"\"\n        Select a scale for the range from vmin to vmax.\n\n        Subclasses should override this method to change locator behaviour.\n        \"\"\"\n        return mtransforms.nonsingular(vmin, vmax)",
        "begin_line": 1728,
        "end_line": 1734,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015785319652722967,
            "pseudo_dstar_susp": 0.00015179113539769278,
            "pseudo_tarantula_susp": 0.00022680880018144704,
            "pseudo_op2_susp": 0.00015179113539769278,
            "pseudo_barinel_susp": 0.00022686025408348456
        }
    },
    {
        "name": "lib.matplotlib.ticker.IndexLocator.__init__#1779",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.IndexLocator",
        "signature": "lib.matplotlib.ticker.IndexLocator.__init__(self, base, offset)",
        "snippet": "    def __init__(self, base, offset):\n        \"\"\"Place ticks every *base* data point, starting at *offset*.\"\"\"\n        self._base = base\n        self.offset = offset",
        "begin_line": 1779,
        "end_line": 1782,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.IndexLocator.set_params#1784",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.IndexLocator",
        "signature": "lib.matplotlib.ticker.IndexLocator.set_params(self, base=None, offset=None)",
        "snippet": "    def set_params(self, base=None, offset=None):\n        \"\"\"Set parameters within this locator\"\"\"\n        if base is not None:\n            self._base = base\n        if offset is not None:\n            self.offset = offset",
        "begin_line": 1784,
        "end_line": 1789,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.FixedLocator.__init__#1812",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.FixedLocator",
        "signature": "lib.matplotlib.ticker.FixedLocator.__init__(self, locs, nbins=None)",
        "snippet": "    def __init__(self, locs, nbins=None):\n        self.locs = np.asarray(locs)\n        self.nbins = max(nbins, 2) if nbins is not None else None",
        "begin_line": 1812,
        "end_line": 1814,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002488181139586962,
            "pseudo_dstar_susp": 0.0002900232018561485,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.0002900232018561485,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.ticker.FixedLocator.set_params#1816",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.FixedLocator",
        "signature": "lib.matplotlib.ticker.FixedLocator.set_params(self, nbins=None)",
        "snippet": "    def set_params(self, nbins=None):\n        \"\"\"Set parameters within this locator.\"\"\"\n        if nbins is not None:\n            self.nbins = nbins",
        "begin_line": 1816,
        "end_line": 1819,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.FixedLocator.__call__#1821",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.FixedLocator",
        "signature": "lib.matplotlib.ticker.FixedLocator.__call__(self)",
        "snippet": "    def __call__(self):\n        return self.tick_values(None, None)",
        "begin_line": 1821,
        "end_line": 1822,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020889910173386254,
            "pseudo_dstar_susp": 0.00020576131687242798,
            "pseudo_tarantula_susp": 0.0003184713375796178,
            "pseudo_op2_susp": 0.00020576131687242798,
            "pseudo_barinel_susp": 0.0003184713375796178
        }
    },
    {
        "name": "lib.matplotlib.ticker.FixedLocator.tick_values#1824",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.FixedLocator",
        "signature": "lib.matplotlib.ticker.FixedLocator.tick_values(self, vmin, vmax)",
        "snippet": "    def tick_values(self, vmin, vmax):\n        \"\"\"\"\n        Return the locations of the ticks.\n\n        .. note::\n\n            Because the values are fixed, vmin and vmax are not used in this\n            method.\n\n        \"\"\"\n        if self.nbins is None:\n            return self.locs\n        step = max(int(np.ceil(len(self.locs) / self.nbins)), 1)\n        ticks = self.locs[::step]\n        for i in range(1, step):\n            ticks1 = self.locs[i::step]\n            if np.abs(ticks1).min() < np.abs(ticks).min():\n                ticks = ticks1\n        return self.raise_if_exceeds(ticks)",
        "begin_line": 1824,
        "end_line": 1842,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022163120567375886,
            "pseudo_dstar_susp": 0.00023702299123014932,
            "pseudo_tarantula_susp": 0.0003450655624568668,
            "pseudo_op2_susp": 0.00023702299123014932,
            "pseudo_barinel_susp": 0.00034494653328734045
        }
    },
    {
        "name": "lib.matplotlib.ticker.NullLocator.__call__#1850",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.NullLocator",
        "signature": "lib.matplotlib.ticker.NullLocator.__call__(self)",
        "snippet": "    def __call__(self):\n        return self.tick_values(None, None)",
        "begin_line": 1850,
        "end_line": 1851,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005257623554153522,
            "pseudo_dstar_susp": 0.00040966816878328555,
            "pseudo_tarantula_susp": 0.00033277870216306157,
            "pseudo_op2_susp": 0.00040966816878328555,
            "pseudo_barinel_susp": 0.00033277870216306157
        }
    },
    {
        "name": "lib.matplotlib.ticker.NullLocator.tick_values#1853",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.NullLocator",
        "signature": "lib.matplotlib.ticker.NullLocator.tick_values(self, vmin, vmax)",
        "snippet": "    def tick_values(self, vmin, vmax):\n        \"\"\"\"\n        Return the locations of the ticks.\n\n        .. note::\n\n            Because the values are Null, vmin and vmax are not used in this\n            method.\n        \"\"\"\n        return []",
        "begin_line": 1853,
        "end_line": 1862,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005417118093174431,
            "pseudo_dstar_susp": 0.00044365572315882877,
            "pseudo_tarantula_susp": 0.00033277870216306157,
            "pseudo_op2_susp": 0.00044365572315882877,
            "pseudo_barinel_susp": 0.00033277870216306157
        }
    },
    {
        "name": "lib.matplotlib.ticker.LinearLocator.__init__#1875",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LinearLocator",
        "signature": "lib.matplotlib.ticker.LinearLocator.__init__(self, numticks=None, presets=None)",
        "snippet": "    def __init__(self, numticks=None, presets=None):\n        \"\"\"\n        Use presets to set locs based on lom.  A dict mapping vmin, vmax->locs\n        \"\"\"\n        self.numticks = numticks\n        if presets is None:\n            self.presets = {}\n        else:\n            self.presets = presets",
        "begin_line": 1875,
        "end_line": 1883,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.ticker.LinearLocator.numticks#1886",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LinearLocator",
        "signature": "lib.matplotlib.ticker.LinearLocator.numticks(self)",
        "snippet": "    def numticks(self):\n        # Old hard-coded default.\n        return self._numticks if self._numticks is not None else 11",
        "begin_line": 1886,
        "end_line": 1888,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012717792191275595,
            "pseudo_dstar_susp": 0.0001210800339024095,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.0001210800339024095,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.ticker.LinearLocator.numticks#1891",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LinearLocator",
        "signature": "lib.matplotlib.ticker.LinearLocator.numticks(self, numticks)",
        "snippet": "    def numticks(self, numticks):\n        self._numticks = numticks",
        "begin_line": 1891,
        "end_line": 1892,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.LinearLocator.set_params#1894",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LinearLocator",
        "signature": "lib.matplotlib.ticker.LinearLocator.set_params(self, numticks=None, presets=None)",
        "snippet": "    def set_params(self, numticks=None, presets=None):\n        \"\"\"Set parameters within this locator.\"\"\"\n        if presets is not None:\n            self.presets = presets\n        if numticks is not None:\n            self.numticks = numticks",
        "begin_line": 1894,
        "end_line": 1899,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.LinearLocator.tick_values#1906",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LinearLocator",
        "signature": "lib.matplotlib.ticker.LinearLocator.tick_values(self, vmin, vmax)",
        "snippet": "    def tick_values(self, vmin, vmax):\n        vmin, vmax = mtransforms.nonsingular(vmin, vmax, expander=0.05)\n        if vmax < vmin:\n            vmin, vmax = vmax, vmin\n\n        if (vmin, vmax) in self.presets:\n            return self.presets[(vmin, vmax)]\n\n        if self.numticks == 0:\n            return []\n        ticklocs = np.linspace(vmin, vmax, self.numticks)\n\n        return self.raise_if_exceeds(ticklocs)",
        "begin_line": 1906,
        "end_line": 1918,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.ticker.LinearLocator.view_limits#1920",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LinearLocator",
        "signature": "lib.matplotlib.ticker.LinearLocator.view_limits(self, vmin, vmax)",
        "snippet": "    def view_limits(self, vmin, vmax):\n        'Try to choose the view limits intelligently'\n\n        if vmax < vmin:\n            vmin, vmax = vmax, vmin\n\n        if vmin == vmax:\n            vmin -= 1\n            vmax += 1\n\n        if rcParams['axes.autolimit_mode'] == 'round_numbers':\n            exponent, remainder = divmod(\n                math.log10(vmax - vmin), math.log10(max(self.numticks - 1, 1)))\n            exponent -= (remainder < .5)\n            scale = max(self.numticks - 1, 1) ** (-exponent)\n            vmin = math.floor(scale * vmin) / scale\n            vmax = math.ceil(scale * vmax) / scale\n\n        return mtransforms.nonsingular(vmin, vmax)",
        "begin_line": 1920,
        "end_line": 1938,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.ticker.MultipleLocator.__init__#1946",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MultipleLocator",
        "signature": "lib.matplotlib.ticker.MultipleLocator.__init__(self, base=1.0)",
        "snippet": "    def __init__(self, base=1.0):\n        self._edge = _Edge_integer(base, 0)",
        "begin_line": 1946,
        "end_line": 1947,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.MultipleLocator.set_params#1949",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MultipleLocator",
        "signature": "lib.matplotlib.ticker.MultipleLocator.set_params(self, base)",
        "snippet": "    def set_params(self, base):\n        \"\"\"Set parameters within this locator.\"\"\"\n        if base is not None:\n            self._edge = _Edge_integer(base, 0)",
        "begin_line": 1949,
        "end_line": 1952,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.MultipleLocator.tick_values#1959",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MultipleLocator",
        "signature": "lib.matplotlib.ticker.MultipleLocator.tick_values(self, vmin, vmax)",
        "snippet": "    def tick_values(self, vmin, vmax):\n        if vmax < vmin:\n            vmin, vmax = vmax, vmin\n        step = self._edge.step\n        vmin = self._edge.ge(vmin) * step\n        n = (vmax - vmin + 0.001 * step) // step\n        locs = vmin - step + np.arange(n + 3) * step\n        return self.raise_if_exceeds(locs)",
        "begin_line": 1959,
        "end_line": 1966,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.MultipleLocator.view_limits#1968",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MultipleLocator",
        "signature": "lib.matplotlib.ticker.MultipleLocator.view_limits(self, dmin, dmax)",
        "snippet": "    def view_limits(self, dmin, dmax):\n        \"\"\"\n        Set the view limits to the nearest multiples of base that\n        contain the data.\n        \"\"\"\n        if rcParams['axes.autolimit_mode'] == 'round_numbers':\n            vmin = self._edge.le(dmin) * self._edge.step\n            vmax = self._edge.ge(dmax) * self._edge.step\n            if vmin == vmax:\n                vmin -= 1\n                vmax += 1\n        else:\n            vmin = dmin\n            vmax = dmax\n\n        return mtransforms.nonsingular(vmin, vmax)",
        "begin_line": 1968,
        "end_line": 1983,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.scale_range#1986",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker",
        "signature": "lib.matplotlib.ticker.scale_range(vmin, vmax, n=1, threshold=100)",
        "snippet": "def scale_range(vmin, vmax, n=1, threshold=100):\n    dv = abs(vmax - vmin)  # > 0 as nonsingular is called before.\n    meanv = (vmax + vmin) / 2\n    if abs(meanv) / dv < threshold:\n        offset = 0\n    else:\n        offset = math.copysign(10 ** (math.log10(abs(meanv)) // 1), meanv)\n    scale = 10 ** (math.log10(dv / n) // 1)\n    return scale, offset",
        "begin_line": 1986,
        "end_line": 1994,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004805382027871216,
            "pseudo_dstar_susp": 0.00040192926045016077,
            "pseudo_tarantula_susp": 0.00035211267605633805,
            "pseudo_op2_susp": 0.00040192926045016077,
            "pseudo_barinel_susp": 0.00035211267605633805
        }
    },
    {
        "name": "lib.matplotlib.ticker._Edge_integer.__init__#2004",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker._Edge_integer",
        "signature": "lib.matplotlib.ticker._Edge_integer.__init__(self, step, offset)",
        "snippet": "    def __init__(self, step, offset):\n        \"\"\"\n        *step* is a positive floating-point interval between ticks.\n        *offset* is the offset subtracted from the data limits\n        prior to calculating tick locations.\n        \"\"\"\n        if step <= 0:\n            raise ValueError(\"'step' must be positive\")\n        self.step = step\n        self._offset = abs(offset)",
        "begin_line": 2004,
        "end_line": 2013,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00047192071731949034,
            "pseudo_dstar_susp": 0.0004012841091492777,
            "pseudo_tarantula_susp": 0.0003297065611605671,
            "pseudo_op2_susp": 0.0004012841091492777,
            "pseudo_barinel_susp": 0.0003297065611605671
        }
    },
    {
        "name": "lib.matplotlib.ticker._Edge_integer.closeto#2015",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker._Edge_integer",
        "signature": "lib.matplotlib.ticker._Edge_integer.closeto(self, ms, edge)",
        "snippet": "    def closeto(self, ms, edge):\n        # Allow more slop when the offset is large compared to the step.\n        if self._offset > 0:\n            digits = np.log10(self._offset / self.step)\n            tol = max(1e-10, 10 ** (digits - 12))\n            tol = min(0.4999, tol)\n        else:\n            tol = 1e-10\n        return abs(ms - edge) < tol",
        "begin_line": 2015,
        "end_line": 2023,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004764173415912339,
            "pseudo_dstar_susp": 0.00040112314480545525,
            "pseudo_tarantula_susp": 0.0003297065611605671,
            "pseudo_op2_susp": 0.00040112314480545525,
            "pseudo_barinel_susp": 0.0003297065611605671
        }
    },
    {
        "name": "lib.matplotlib.ticker._Edge_integer.le#2025",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker._Edge_integer",
        "signature": "lib.matplotlib.ticker._Edge_integer.le(self, x)",
        "snippet": "    def le(self, x):\n        'Return the largest n: n*step <= x.'\n        d, m = divmod(x, self.step)\n        if self.closeto(m / self.step, 1):\n            return (d + 1)\n        return d",
        "begin_line": 2025,
        "end_line": 2030,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004714757190004715,
            "pseudo_dstar_susp": 0.0003850596842510589,
            "pseudo_tarantula_susp": 0.0003450655624568668,
            "pseudo_op2_susp": 0.0003850596842510589,
            "pseudo_barinel_susp": 0.00034494653328734045
        }
    },
    {
        "name": "lib.matplotlib.ticker._Edge_integer.ge#2032",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker._Edge_integer",
        "signature": "lib.matplotlib.ticker._Edge_integer.ge(self, x)",
        "snippet": "    def ge(self, x):\n        'Return the smallest n: n*step >= x.'\n        d, m = divmod(x, self.step)\n        if self.closeto(m / self.step, 0):\n            return d\n        return (d + 1)",
        "begin_line": 2032,
        "end_line": 2037,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004679457182966776,
            "pseudo_dstar_susp": 0.0003885003885003885,
            "pseudo_tarantula_susp": 0.000333889816360601,
            "pseudo_op2_susp": 0.0003885003885003885,
            "pseudo_barinel_susp": 0.000333889816360601
        }
    },
    {
        "name": "lib.matplotlib.ticker.MaxNLocator.__init__#2051",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MaxNLocator",
        "signature": "lib.matplotlib.ticker.MaxNLocator.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        nbins : int or 'auto', optional, default: 10\n            Maximum number of intervals; one less than max number of\n            ticks.  If the string `'auto'`, the number of bins will be\n            automatically determined based on the length of the axis.\n\n        steps : array-like, optional\n            Sequence of nice numbers starting with 1 and ending with 10;\n            e.g., [1, 2, 4, 5, 10], where the values are acceptable\n            tick multiples.  i.e. for the example, 20, 40, 60 would be\n            an acceptable set of ticks, as would 0.4, 0.6, 0.8, because\n            they are multiples of 2.  However, 30, 60, 90 would not\n            be allowed because 3 does not appear in the list of steps.\n\n        integer : bool, optional, default: False\n            If True, ticks will take only integer values, provided\n            at least `min_n_ticks` integers are found within the\n            view limits.\n\n        symmetric : bool, optional, default: False\n            If True, autoscaling will result in a range symmetric about zero.\n\n        prune : {'lower', 'upper', 'both', None}, optional, default: None\n            Remove edge ticks -- useful for stacked or ganged plots where\n            the upper tick of one axes overlaps with the lower tick of the\n            axes above it, primarily when :rc:`axes.autolimit_mode` is\n            ``'round_numbers'``.  If ``prune=='lower'``, the smallest tick will\n            be removed.  If ``prune == 'upper'``, the largest tick will be\n            removed.  If ``prune == 'both'``, the largest and smallest ticks\n            will be removed.  If ``prune == None``, no ticks will be removed.\n\n        min_n_ticks : int, optional, default: 2\n            Relax *nbins* and *integer* constraints if necessary to obtain\n            this minimum number of ticks.\n\n        \"\"\"\n        if args:\n            if 'nbins' in kwargs:\n                cbook.deprecated(\"3.1\",\n                                 message='Calling MaxNLocator with positional '\n                                         'and keyword parameter *nbins* is '\n                                         'considered an error and will fail '\n                                         'in future versions of matplotlib.')\n            kwargs['nbins'] = args[0]\n            if len(args) > 1:\n                raise ValueError(\n                    \"Keywords are required for all arguments except 'nbins'\")\n        self.set_params(**{**self.default_params, **kwargs})",
        "begin_line": 2051,
        "end_line": 2101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00038402457757296467,
            "pseudo_dstar_susp": 0.0005200208008320333,
            "pseudo_tarantula_susp": 0.0002977963073257892,
            "pseudo_op2_susp": 0.0005200208008320333,
            "pseudo_barinel_susp": 0.0002977963073257892
        }
    },
    {
        "name": "lib.matplotlib.ticker.MaxNLocator._validate_steps#2104",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MaxNLocator",
        "signature": "lib.matplotlib.ticker.MaxNLocator._validate_steps(steps)",
        "snippet": "    def _validate_steps(steps):\n        if not np.iterable(steps):\n            raise ValueError('steps argument must be an increasing sequence '\n                             'of numbers between 1 and 10 inclusive')\n        steps = np.asarray(steps)\n        if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:\n            raise ValueError('steps argument must be an increasing sequence '\n                             'of numbers between 1 and 10 inclusive')\n        if steps[0] != 1:\n            steps = np.hstack((1, steps))\n        if steps[-1] != 10:\n            steps = np.hstack((steps, 10))\n        return steps",
        "begin_line": 2104,
        "end_line": 2116,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00042265426880811494,
            "pseudo_dstar_susp": 0.0006060606060606061,
            "pseudo_tarantula_susp": 0.00015867978419549348,
            "pseudo_op2_susp": 0.0006060606060606061,
            "pseudo_barinel_susp": 0.00015867978419549348
        }
    },
    {
        "name": "lib.matplotlib.ticker.MaxNLocator._staircase#2119",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MaxNLocator",
        "signature": "lib.matplotlib.ticker.MaxNLocator._staircase(steps)",
        "snippet": "    def _staircase(steps):\n        # Make an extended staircase within which the needed\n        # step will be found.  This is probably much larger\n        # than necessary.\n        flights = (0.1 * steps[:-1], steps, 10 * steps[1])\n        return np.hstack(flights)",
        "begin_line": 2119,
        "end_line": 2124,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00034071550255536625,
            "pseudo_dstar_susp": 0.00047281323877068556,
            "pseudo_tarantula_susp": 0.0001371553970648745,
            "pseudo_op2_susp": 0.00047281323877068556,
            "pseudo_barinel_susp": 0.0001371553970648745
        }
    },
    {
        "name": "lib.matplotlib.ticker.MaxNLocator.set_params#2126",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MaxNLocator",
        "signature": "lib.matplotlib.ticker.MaxNLocator.set_params(self, **kwargs)",
        "snippet": "    def set_params(self, **kwargs):\n        \"\"\"\n        Set parameters for this locator.\n\n        Parameters\n        ----------\n        nbins : int or 'auto', optional\n            see `.MaxNLocator`\n        steps : array-like, optional\n            see `.MaxNLocator`\n        integer : bool, optional\n            see `.MaxNLocator`\n        symmetric : bool, optional\n            see `.MaxNLocator`\n        prune : {'lower', 'upper', 'both', None}, optional\n            see `.MaxNLocator`\n        min_n_ticks : int, optional\n            see `.MaxNLocator`\n        \"\"\"\n        if 'nbins' in kwargs:\n            self._nbins = kwargs.pop('nbins')\n            if self._nbins != 'auto':\n                self._nbins = int(self._nbins)\n        if 'symmetric' in kwargs:\n            self._symmetric = kwargs.pop('symmetric')\n        if 'prune' in kwargs:\n            prune = kwargs.pop('prune')\n            cbook._check_in_list(['upper', 'lower', 'both', None], prune=prune)\n            self._prune = prune\n        if 'min_n_ticks' in kwargs:\n            self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))\n        if 'steps' in kwargs:\n            steps = kwargs.pop('steps')\n            if steps is None:\n                self._steps = np.array([1, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10])\n            else:\n                self._steps = self._validate_steps(steps)\n            self._extended_steps = self._staircase(self._steps)\n        if 'integer' in kwargs:\n            self._integer = kwargs.pop('integer')\n        if kwargs:\n            key, _ = kwargs.popitem()\n            cbook.warn_deprecated(\"3.1\",\n                                  message=\"MaxNLocator.set_params got an \"\n                                          f\"unexpected parameter: {key}\")",
        "begin_line": 2126,
        "end_line": 2170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003920031360250882,
            "pseudo_dstar_susp": 0.000564334085778781,
            "pseudo_tarantula_susp": 0.0002878526194588371,
            "pseudo_op2_susp": 0.000564334085778781,
            "pseudo_barinel_susp": 0.0002878526194588371
        }
    },
    {
        "name": "lib.matplotlib.ticker.MaxNLocator._raw_ticks#2172",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MaxNLocator",
        "signature": "lib.matplotlib.ticker.MaxNLocator._raw_ticks(self, vmin, vmax)",
        "snippet": "    def _raw_ticks(self, vmin, vmax):\n        \"\"\"\n        Generate a list of tick locations including the range *vmin* to\n        *vmax*.  In some applications, one or both of the end locations\n        will not be needed, in which case they are trimmed off\n        elsewhere.\n        \"\"\"\n        if self._nbins == 'auto':\n            if self.axis is not None:\n                nbins = np.clip(self.axis.get_tick_space(),\n                                max(1, self._min_n_ticks - 1), 9)\n            else:\n                nbins = 9\n        else:\n            nbins = self._nbins\n\n        scale, offset = scale_range(vmin, vmax, nbins)\n        _vmin = vmin - offset\n        _vmax = vmax - offset\n        raw_step = (_vmax - _vmin) / nbins\n        steps = self._extended_steps * scale\n        if self._integer:\n            # For steps > 1, keep only integer values.\n            igood = (steps < 1) | (np.abs(steps - np.round(steps)) < 0.001)\n            steps = steps[igood]\n\n        istep = np.nonzero(steps >= raw_step)[0][0]\n\n        # Classic round_numbers mode may require a larger step.\n        if rcParams['axes.autolimit_mode'] == 'round_numbers':\n            for istep in range(istep, len(steps)):\n                step = steps[istep]\n                best_vmin = (_vmin // step) * step\n                best_vmax = best_vmin + step * nbins\n                if best_vmax >= _vmax:\n                    break\n\n        # This is an upper limit; move to smaller steps if necessary.\n        for istep in reversed(range(istep + 1)):\n            step = steps[istep]\n\n            if (self._integer and\n                    np.floor(_vmax) - np.ceil(_vmin) >= self._min_n_ticks - 1):\n                step = max(1, step)\n            best_vmin = (_vmin // step) * step\n\n            # Find tick locations spanning the vmin-vmax range, taking into\n            # account degradation of precision when there is a large offset.\n            # The edge ticks beyond vmin and/or vmax are needed for the\n            # \"round_numbers\" autolimit mode.\n            edge = _Edge_integer(step, offset)\n            low = edge.le(_vmin - best_vmin)\n            high = edge.ge(_vmax - best_vmin)\n            ticks = np.arange(low, high + 1) * step + best_vmin\n            # Count only the ticks that will be displayed.\n            nticks = ((ticks <= _vmax) & (ticks >= _vmin)).sum()\n            if nticks >= self._min_n_ticks:\n                break\n        return ticks + offset",
        "begin_line": 2172,
        "end_line": 2230,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00047551117451260106,
            "pseudo_dstar_susp": 0.00040192926045016077,
            "pseudo_tarantula_susp": 0.00034048348655090226,
            "pseudo_op2_susp": 0.00040192926045016077,
            "pseudo_barinel_susp": 0.00034048348655090226
        }
    },
    {
        "name": "lib.matplotlib.ticker.MaxNLocator.__call__#2232",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MaxNLocator",
        "signature": "lib.matplotlib.ticker.MaxNLocator.__call__(self)",
        "snippet": "    def __call__(self):\n        vmin, vmax = self.axis.get_view_interval()\n        return self.tick_values(vmin, vmax)",
        "begin_line": 2232,
        "end_line": 2234,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00048590864917395527,
            "pseudo_dstar_susp": 0.0003933910306845004,
            "pseudo_tarantula_susp": 0.0003297065611605671,
            "pseudo_op2_susp": 0.0003933910306845004,
            "pseudo_barinel_susp": 0.0003297065611605671
        }
    },
    {
        "name": "lib.matplotlib.ticker.MaxNLocator.tick_values#2236",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MaxNLocator",
        "signature": "lib.matplotlib.ticker.MaxNLocator.tick_values(self, vmin, vmax)",
        "snippet": "    def tick_values(self, vmin, vmax):\n        if self._symmetric:\n            vmax = max(abs(vmin), abs(vmax))\n            vmin = -vmax\n        vmin, vmax = mtransforms.nonsingular(\n            vmin, vmax, expander=1e-13, tiny=1e-14)\n        locs = self._raw_ticks(vmin, vmax)\n\n        prune = self._prune\n        if prune == 'lower':\n            locs = locs[1:]\n        elif prune == 'upper':\n            locs = locs[:-1]\n        elif prune == 'both':\n            locs = locs[1:-1]\n        return self.raise_if_exceeds(locs)",
        "begin_line": 2236,
        "end_line": 2251,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00048123195380173246,
            "pseudo_dstar_susp": 0.00038774718883288094,
            "pseudo_tarantula_susp": 0.0003297065611605671,
            "pseudo_op2_susp": 0.00038774718883288094,
            "pseudo_barinel_susp": 0.0003297065611605671
        }
    },
    {
        "name": "lib.matplotlib.ticker.MaxNLocator.view_limits#2253",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MaxNLocator",
        "signature": "lib.matplotlib.ticker.MaxNLocator.view_limits(self, dmin, dmax)",
        "snippet": "    def view_limits(self, dmin, dmax):\n        if self._symmetric:\n            dmax = max(abs(dmin), abs(dmax))\n            dmin = -dmax\n\n        dmin, dmax = mtransforms.nonsingular(\n            dmin, dmax, expander=1e-12, tiny=1e-13)\n\n        if rcParams['axes.autolimit_mode'] == 'round_numbers':\n            return self._raw_ticks(dmin, dmax)[[0, -1]]\n        else:\n            return dmin, dmax",
        "begin_line": 2253,
        "end_line": 2264,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004008016032064128,
            "pseudo_dstar_susp": 0.0003497726477789437,
            "pseudo_tarantula_susp": 0.000351493848857645,
            "pseudo_op2_susp": 0.0003497726477789437,
            "pseudo_barinel_susp": 0.00035161744022503517
        }
    },
    {
        "name": "lib.matplotlib.ticker.is_decade#2285",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker",
        "signature": "lib.matplotlib.ticker.is_decade(x, base=10, *, rtol=1e-10)",
        "snippet": "def is_decade(x, base=10, *, rtol=1e-10):\n    if not np.isfinite(x):\n        return False\n    if x == 0.0:\n        return True\n    lx = np.log(np.abs(x)) / np.log(base)\n    return is_close_to_int(lx, atol=rtol)",
        "begin_line": 2285,
        "end_line": 2291,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker._decade_less_equal#2294",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker",
        "signature": "lib.matplotlib.ticker._decade_less_equal(x, base)",
        "snippet": "def _decade_less_equal(x, base):\n    \"\"\"\n    Return the largest integer power of *base* that's less or equal to *x*.\n\n    If *x* is negative, the exponent will be *greater*.\n    \"\"\"\n    return (x if x == 0 else\n            -_decade_greater_equal(-x, base) if x < 0 else\n            base ** np.floor(np.log(x) / np.log(base)))",
        "begin_line": 2294,
        "end_line": 2302,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker._decade_greater_equal#2305",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker",
        "signature": "lib.matplotlib.ticker._decade_greater_equal(x, base)",
        "snippet": "def _decade_greater_equal(x, base):\n    \"\"\"\n    Return the smallest integer power of *base* that's greater or equal to *x*.\n\n    If *x* is negative, the exponent will be *smaller*.\n    \"\"\"\n    return (x if x == 0 else\n            -_decade_less_equal(-x, base) if x < 0 else\n            base ** np.ceil(np.log(x) / np.log(base)))",
        "begin_line": 2305,
        "end_line": 2313,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker._decade_less#2316",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker",
        "signature": "lib.matplotlib.ticker._decade_less(x, base)",
        "snippet": "def _decade_less(x, base):\n    \"\"\"\n    Return the largest integer power of *base* that's less than *x*.\n\n    If *x* is negative, the exponent will be *greater*.\n    \"\"\"\n    if x < 0:\n        return -_decade_greater(-x, base)\n    less = _decade_less_equal(x, base)\n    if less == x:\n        less /= base\n    return less",
        "begin_line": 2316,
        "end_line": 2327,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker._decade_greater#2330",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker",
        "signature": "lib.matplotlib.ticker._decade_greater(x, base)",
        "snippet": "def _decade_greater(x, base):\n    \"\"\"\n    Return the smallest integer power of *base* that's greater than *x*.\n\n    If *x* is negative, the exponent will be *smaller*.\n    \"\"\"\n    if x < 0:\n        return -_decade_less(-x, base)\n    greater = _decade_greater_equal(x, base)\n    if greater == x:\n        greater *= base\n    return greater",
        "begin_line": 2330,
        "end_line": 2341,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.is_close_to_int#2344",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker",
        "signature": "lib.matplotlib.ticker.is_close_to_int(x, *, atol=1e-10)",
        "snippet": "def is_close_to_int(x, *, atol=1e-10):\n    return abs(x - np.round(x)) < atol",
        "begin_line": 2344,
        "end_line": 2345,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012454851164528583,
            "pseudo_dstar_susp": 0.00011988970147464332,
            "pseudo_tarantula_susp": 0.00017415534656913968,
            "pseudo_op2_susp": 0.00011988970147464332,
            "pseudo_barinel_susp": 0.0001742767514813524
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogLocator.__init__#2353",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogLocator",
        "signature": "lib.matplotlib.ticker.LogLocator.__init__(self, base=10.0, subs=(1.0,), numdecs=4, numticks=None)",
        "snippet": "    def __init__(self, base=10.0, subs=(1.0,), numdecs=4, numticks=None):\n        \"\"\"\n        Place ticks on the locations : subs[j] * base**i\n\n        Parameters\n        ----------\n        subs : None, str, or sequence of float, optional, default (1.0,)\n            Gives the multiples of integer powers of the base at which\n            to place ticks.  The default places ticks only at\n            integer powers of the base.\n            The permitted string values are ``'auto'`` and ``'all'``,\n            both of which use an algorithm based on the axis view\n            limits to determine whether and how to put ticks between\n            integer powers of the base.  With ``'auto'``, ticks are\n            placed only between integer powers; with ``'all'``, the\n            integer powers are included.  A value of None is\n            equivalent to ``'auto'``.\n\n        \"\"\"\n        if numticks is None:\n            if rcParams['_internal.classic_mode']:\n                numticks = 15\n            else:\n                numticks = 'auto'\n        self.base(base)\n        self.subs(subs)\n        self.numdecs = numdecs\n        self.numticks = numticks",
        "begin_line": 2353,
        "end_line": 2380,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015743073047858942,
            "pseudo_dstar_susp": 0.00019743336623889436,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00019743336623889436,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogLocator.set_params#2382",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogLocator",
        "signature": "lib.matplotlib.ticker.LogLocator.set_params(self, base=None, subs=None, numdecs=None, numticks=None)",
        "snippet": "    def set_params(self, base=None, subs=None, numdecs=None, numticks=None):\n        \"\"\"Set parameters within this locator.\"\"\"\n        if base is not None:\n            self.base(base)\n        if subs is not None:\n            self.subs(subs)\n        if numdecs is not None:\n            self.numdecs = numdecs\n        if numticks is not None:\n            self.numticks = numticks",
        "begin_line": 2382,
        "end_line": 2391,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogLocator.base#2396",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogLocator",
        "signature": "lib.matplotlib.ticker.LogLocator.base(self, base)",
        "snippet": "    def base(self, base):\n        \"\"\"Set the log base (major tick every ``base**i``, i integer).\"\"\"\n        self._base = float(base)",
        "begin_line": 2396,
        "end_line": 2398,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012717792191275595,
            "pseudo_dstar_susp": 0.0001210800339024095,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.0001210800339024095,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogLocator.subs#2400",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogLocator",
        "signature": "lib.matplotlib.ticker.LogLocator.subs(self, subs)",
        "snippet": "    def subs(self, subs):\n        \"\"\"\n        Set the minor ticks for the log scaling every ``base**i*subs[j]``.\n        \"\"\"\n        if subs is None:  # consistency with previous bad API\n            self._subs = 'auto'\n        elif isinstance(subs, str):\n            cbook._check_in_list(('all', 'auto'), subs=subs)\n            self._subs = subs\n        else:\n            try:\n                self._subs = np.asarray(subs, dtype=float)\n            except ValueError as e:\n                raise ValueError(\"subs must be None, 'all', 'auto' or \"\n                                 \"a sequence of floats, not \"\n                                 \"{}.\".format(subs)) from e\n            if self._subs.ndim != 1:\n                raise ValueError(\"A sequence passed to subs must be \"\n                                 \"1-dimensional, not \"\n                                 \"{}-dimensional.\".format(self._subs.ndim))",
        "begin_line": 2400,
        "end_line": 2419,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015718327569946557,
            "pseudo_dstar_susp": 0.00019735543714229328,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.00019735543714229328,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogLocator.__call__#2421",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogLocator",
        "signature": "lib.matplotlib.ticker.LogLocator.__call__(self)",
        "snippet": "    def __call__(self):\n        'Return the locations of the ticks'\n        vmin, vmax = self.axis.get_view_interval()\n        return self.tick_values(vmin, vmax)",
        "begin_line": 2421,
        "end_line": 2424,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012717792191275595,
            "pseudo_dstar_susp": 0.0001210800339024095,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.0001210800339024095,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogLocator.tick_values#2426",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogLocator",
        "signature": "lib.matplotlib.ticker.LogLocator.tick_values(self, vmin, vmax)",
        "snippet": "    def tick_values(self, vmin, vmax):\n        if self.numticks == 'auto':\n            if self.axis is not None:\n                numticks = np.clip(self.axis.get_tick_space(), 2, 9)\n            else:\n                numticks = 9\n        else:\n            numticks = self.numticks\n\n        b = self._base\n        # dummy axis has no axes attribute\n        if hasattr(self.axis, 'axes') and self.axis.axes.name == 'polar':\n            vmax = math.ceil(math.log(vmax) / math.log(b))\n            decades = np.arange(vmax - self.numdecs, vmax)\n            ticklocs = b ** decades\n\n            return ticklocs\n\n        if vmin <= 0.0:\n            if self.axis is not None:\n                vmin = self.axis.get_minpos()\n\n            if vmin <= 0.0 or not np.isfinite(vmin):\n                raise ValueError(\n                    \"Data has no positive values, and therefore can not be \"\n                    \"log-scaled.\")\n\n        _log.debug('vmin %s vmax %s', vmin, vmax)\n\n        if vmax < vmin:\n            vmin, vmax = vmax, vmin\n        log_vmin = math.log(vmin) / math.log(b)\n        log_vmax = math.log(vmax) / math.log(b)\n\n        numdec = math.floor(log_vmax) - math.ceil(log_vmin)\n\n        if isinstance(self._subs, str):\n            _first = 2.0 if self._subs == 'auto' else 1.0\n            if numdec > 10 or b < 3:\n                if self._subs == 'auto':\n                    return np.array([])  # no minor or major ticks\n                else:\n                    subs = np.array([1.0])  # major ticks\n            else:\n                subs = np.arange(_first, b)\n        else:\n            subs = self._subs\n\n        # Get decades between major ticks.\n        stride = (max(math.ceil(numdec / (numticks - 1)), 1)\n                  if rcParams['_internal.classic_mode'] else\n                  (numdec + 1) // numticks + 1)\n\n        # Does subs include anything other than 1?  Essentially a hack to know\n        # whether we're a major or a minor locator.\n        have_subs = len(subs) > 1 or (len(subs) == 1 and subs[0] != 1.0)\n\n        decades = np.arange(math.floor(log_vmin) - stride,\n                            math.ceil(log_vmax) + 2 * stride, stride)\n\n        if hasattr(self, '_transform'):\n            ticklocs = self._transform.inverted().transform(decades)\n            if have_subs:\n                if stride == 1:\n                    ticklocs = np.ravel(np.outer(subs, ticklocs))\n                else:\n                    # No ticklocs if we have >1 decade between major ticks.\n                    ticklocs = np.array([])\n        else:\n            if have_subs:\n                if stride == 1:\n                    ticklocs = np.concatenate(\n                        [subs * decade_start for decade_start in b ** decades])\n                else:\n                    ticklocs = np.array([])\n            else:\n                ticklocs = b ** decades\n\n        _log.debug('ticklocs %r', ticklocs)\n        if (len(subs) > 1\n                and stride == 1\n                and ((vmin <= ticklocs) & (ticklocs <= vmax)).sum() <= 1):\n            # If we're a minor locator *that expects at least two ticks per\n            # decade* and the major locator stride is 1 and there's no more\n            # than one minor tick, switch to AutoLocator.\n            return AutoLocator().tick_values(vmin, vmax)\n        else:\n            return self.raise_if_exceeds(ticklocs)",
        "begin_line": 2426,
        "end_line": 2513,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016520733520568312,
            "pseudo_dstar_susp": 0.0001950458357714063,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.0001950458357714063,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogLocator.view_limits#2515",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogLocator",
        "signature": "lib.matplotlib.ticker.LogLocator.view_limits(self, vmin, vmax)",
        "snippet": "    def view_limits(self, vmin, vmax):\n        'Try to choose the view limits intelligently'\n        b = self._base\n\n        vmin, vmax = self.nonsingular(vmin, vmax)\n\n        if self.axis.axes.name == 'polar':\n            vmax = math.ceil(math.log(vmax) / math.log(b))\n            vmin = b ** (vmax - self.numdecs)\n\n        if rcParams['axes.autolimit_mode'] == 'round_numbers':\n            vmin = _decade_less_equal(vmin, self._base)\n            vmax = _decade_greater_equal(vmax, self._base)\n\n        return vmin, vmax",
        "begin_line": 2515,
        "end_line": 2529,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012717792191275595,
            "pseudo_dstar_susp": 0.0001353546291283162,
            "pseudo_tarantula_susp": 0.00013345789403443215,
            "pseudo_op2_susp": 0.0001353546291283162,
            "pseudo_barinel_susp": 0.00013338668800853674
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogLocator.nonsingular#2531",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogLocator",
        "signature": "lib.matplotlib.ticker.LogLocator.nonsingular(self, vmin, vmax)",
        "snippet": "    def nonsingular(self, vmin, vmax):\n        if vmin > vmax:\n            vmin, vmax = vmax, vmin\n        if not np.isfinite(vmin) or not np.isfinite(vmax):\n            vmin, vmax = 1, 10  # Initial range, no data plotted yet.\n        elif vmax <= 0:\n            cbook._warn_external(\n                \"Data has no positive values, and therefore cannot be \"\n                \"log-scaled.\")\n            vmin, vmax = 1, 10\n        else:\n            minpos = self.axis.get_minpos()\n            if not np.isfinite(minpos):\n                minpos = 1e-300  # This should never take effect.\n            if vmin <= 0:\n                vmin = minpos\n            if vmin == vmax:\n                vmin = _decade_less(vmin, self._base)\n                vmax = _decade_greater(vmax, self._base)\n        return vmin, vmax",
        "begin_line": 2531,
        "end_line": 2550,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016087516087516087,
            "pseudo_dstar_susp": 0.00019747235387045813,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00019747235387045813,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.ticker.SymmetricalLogLocator.__init__#2558",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.SymmetricalLogLocator",
        "signature": "lib.matplotlib.ticker.SymmetricalLogLocator.__init__(self, transform=None, subs=None, linthresh=None, base=None)",
        "snippet": "    def __init__(self, transform=None, subs=None, linthresh=None, base=None):\n        \"\"\"Place ticks on the locations ``base**i*subs[j]``.\"\"\"\n        if transform is not None:\n            self._base = transform.base\n            self._linthresh = transform.linthresh\n        elif linthresh is not None and base is not None:\n            self._base = base\n            self._linthresh = linthresh\n        else:\n            raise ValueError(\"Either transform, or both linthresh \"\n                             \"and base, must be provided.\")\n        if subs is None:\n            self._subs = [1.0]\n        else:\n            self._subs = subs\n        self.numticks = 15",
        "begin_line": 2558,
        "end_line": 2573,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.SymmetricalLogLocator.set_params#2575",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.SymmetricalLogLocator",
        "signature": "lib.matplotlib.ticker.SymmetricalLogLocator.set_params(self, subs=None, numticks=None)",
        "snippet": "    def set_params(self, subs=None, numticks=None):\n        \"\"\"Set parameters within this locator.\"\"\"\n        if numticks is not None:\n            self.numticks = numticks\n        if subs is not None:\n            self._subs = subs",
        "begin_line": 2575,
        "end_line": 2580,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.SymmetricalLogLocator.__call__#2582",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.SymmetricalLogLocator",
        "signature": "lib.matplotlib.ticker.SymmetricalLogLocator.__call__(self)",
        "snippet": "    def __call__(self):\n        \"\"\"Return the locations of the ticks.\"\"\"\n        # Note, these are untransformed coordinates\n        vmin, vmax = self.axis.get_view_interval()\n        return self.tick_values(vmin, vmax)",
        "begin_line": 2582,
        "end_line": 2586,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.SymmetricalLogLocator.tick_values#2588",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.SymmetricalLogLocator",
        "signature": "lib.matplotlib.ticker.SymmetricalLogLocator.tick_values(self, vmin, vmax)",
        "snippet": "    def tick_values(self, vmin, vmax):\n        base = self._base\n        linthresh = self._linthresh\n\n        if vmax < vmin:\n            vmin, vmax = vmax, vmin\n\n        # The domain is divided into three sections, only some of\n        # which may actually be present.\n        #\n        # <======== -t ==0== t ========>\n        # aaaaaaaaa    bbbbb   ccccccccc\n        #\n        # a) and c) will have ticks at integral log positions.  The\n        # number of ticks needs to be reduced if there are more\n        # than self.numticks of them.\n        #\n        # b) has a tick at 0 and only 0 (we assume t is a small\n        # number, and the linear segment is just an implementation\n        # detail and not interesting.)\n        #\n        # We could also add ticks at t, but that seems to usually be\n        # uninteresting.\n        #\n        # \"simple\" mode is when the range falls entirely within (-t,\n        # t) -- it should just display (vmin, 0, vmax)\n        if -linthresh < vmin < vmax < linthresh:\n            # only the linear range is present\n            return [vmin, vmax]\n\n        # Lower log range is present\n        has_a = (vmin < -linthresh)\n        # Upper log range is present\n        has_c = (vmax > linthresh)\n\n        # Check if linear range is present\n        has_b = (has_a and vmax > -linthresh) or (has_c and vmin < linthresh)\n\n        def get_log_range(lo, hi):\n            lo = np.floor(np.log(lo) / np.log(base))\n            hi = np.ceil(np.log(hi) / np.log(base))\n            return lo, hi\n\n        # Calculate all the ranges, so we can determine striding\n        a_lo, a_hi = (0, 0)\n        if has_a:\n            a_upper_lim = min(-linthresh, vmax)\n            a_lo, a_hi = get_log_range(np.abs(a_upper_lim), np.abs(vmin) + 1)\n\n        c_lo, c_hi = (0, 0)\n        if has_c:\n            c_lower_lim = max(linthresh, vmin)\n            c_lo, c_hi = get_log_range(c_lower_lim, vmax + 1)\n\n        # Calculate the total number of integer exponents in a and c ranges\n        total_ticks = (a_hi - a_lo) + (c_hi - c_lo)\n        if has_b:\n            total_ticks += 1\n        stride = max(total_ticks // (self.numticks - 1), 1)\n\n        decades = []\n        if has_a:\n            decades.extend(-1 * (base ** (np.arange(a_lo, a_hi,\n                                                    stride)[::-1])))\n\n        if has_b:\n            decades.append(0.0)\n\n        if has_c:\n            decades.extend(base ** (np.arange(c_lo, c_hi, stride)))\n\n        # Add the subticks if requested\n        if self._subs is None:\n            subs = np.arange(2.0, base)\n        else:\n            subs = np.asarray(self._subs)\n\n        if len(subs) > 1 or subs[0] != 1.0:\n            ticklocs = []\n            for decade in decades:\n                if decade == 0:\n                    ticklocs.append(decade)\n                else:\n                    ticklocs.extend(subs * decade)\n        else:\n            ticklocs = decades\n\n        return self.raise_if_exceeds(np.array(ticklocs))",
        "begin_line": 2588,
        "end_line": 2675,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.SymmetricalLogLocator.get_log_range#2626",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.SymmetricalLogLocator",
        "signature": "lib.matplotlib.ticker.SymmetricalLogLocator.get_log_range(lo, hi)",
        "snippet": "        def get_log_range(lo, hi):\n            lo = np.floor(np.log(lo) / np.log(base))\n            hi = np.ceil(np.log(hi) / np.log(base))\n            return lo, hi",
        "begin_line": 2626,
        "end_line": 2629,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.SymmetricalLogLocator.view_limits#2677",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.SymmetricalLogLocator",
        "signature": "lib.matplotlib.ticker.SymmetricalLogLocator.view_limits(self, vmin, vmax)",
        "snippet": "    def view_limits(self, vmin, vmax):\n        'Try to choose the view limits intelligently'\n        b = self._base\n        if vmax < vmin:\n            vmin, vmax = vmax, vmin\n\n        if rcParams['axes.autolimit_mode'] == 'round_numbers':\n            vmin = _decade_less_equal(vmin, b)\n            vmax = _decade_greater_equal(vmax, b)\n            if vmin == vmax:\n                vmin = _decade_less(vmin, b)\n                vmax = _decade_greater(vmax, b)\n\n        result = mtransforms.nonsingular(vmin, vmax)\n        return result",
        "begin_line": 2677,
        "end_line": 2691,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitLocator.__init__#2699",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitLocator",
        "signature": "lib.matplotlib.ticker.LogitLocator.__init__(self, minor=False, *, nbins='auto')",
        "snippet": "    def __init__(self, minor=False, *, nbins=\"auto\"):\n        \"\"\"\n        Place ticks on the logit locations\n\n        Parameters\n        ----------\n        nbins : int or 'auto', optional\n            Number of ticks. Only used if minor is False.\n        minor : bool, default: False\n            Indicate if this locator is for minor ticks or not.\n        \"\"\"\n\n        self._minor = minor\n        MaxNLocator.__init__(self, nbins=nbins, steps=[1, 2, 5, 10])",
        "begin_line": 2699,
        "end_line": 2712,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitLocator.set_params#2714",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitLocator",
        "signature": "lib.matplotlib.ticker.LogitLocator.set_params(self, minor=None, **kwargs)",
        "snippet": "    def set_params(self, minor=None, **kwargs):\n        \"\"\"Set parameters within this locator.\"\"\"\n        if minor is not None:\n            self._minor = minor\n        MaxNLocator.set_params(self, **kwargs)",
        "begin_line": 2714,
        "end_line": 2718,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitLocator.minor#2721",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitLocator",
        "signature": "lib.matplotlib.ticker.LogitLocator.minor(self)",
        "snippet": "    def minor(self):\n        return self._minor",
        "begin_line": 2721,
        "end_line": 2722,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitLocator.minor#2725",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitLocator",
        "signature": "lib.matplotlib.ticker.LogitLocator.minor(self, value)",
        "snippet": "    def minor(self, value):\n        self.set_params(minor=value)",
        "begin_line": 2725,
        "end_line": 2726,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitLocator.tick_values#2728",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitLocator",
        "signature": "lib.matplotlib.ticker.LogitLocator.tick_values(self, vmin, vmax)",
        "snippet": "    def tick_values(self, vmin, vmax):\n        # dummy axis has no axes attribute\n        if hasattr(self.axis, \"axes\") and self.axis.axes.name == \"polar\":\n            raise NotImplementedError(\"Polar axis cannot be logit scaled yet\")\n\n        if self._nbins == \"auto\":\n            if self.axis is not None:\n                nbins = self.axis.get_tick_space()\n                if nbins < 2:\n                    nbins = 2\n            else:\n                nbins = 9\n        else:\n            nbins = self._nbins\n\n        # We define ideal ticks with their index:\n        # linscale: ... 1e-3 1e-2 1e-1 1/2 1-1e-1 1-1e-2 1-1e-3 ...\n        # b-scale : ... -3   -2   -1   0   1      2      3      ...\n        def ideal_ticks(x):\n            return 10 ** x if x < 0 else 1 - (10 ** (-x)) if x > 0 else 1 / 2\n\n        vmin, vmax = self.nonsingular(vmin, vmax)\n        binf = int(\n            np.floor(np.log10(vmin))\n            if vmin < 0.5\n            else 0\n            if vmin < 0.9\n            else -np.ceil(np.log10(1 - vmin))\n        )\n        bsup = int(\n            np.ceil(np.log10(vmax))\n            if vmax <= 0.5\n            else 1\n            if vmax <= 0.9\n            else -np.floor(np.log10(1 - vmax))\n        )\n        numideal = bsup - binf - 1\n        if numideal >= 2:\n            # have 2 or more wanted ideal ticks, so use them as major ticks\n            if numideal > nbins:\n                # to many ideal ticks, subsampling ideals for major ticks, and\n                # take others for minor ticks\n                subsampling_factor = math.ceil(numideal / nbins)\n                if self._minor:\n                    ticklocs = [\n                        ideal_ticks(b)\n                        for b in range(binf, bsup + 1)\n                        if (b % subsampling_factor) != 0\n                    ]\n                else:\n                    ticklocs = [\n                        ideal_ticks(b)\n                        for b in range(binf, bsup + 1)\n                        if (b % subsampling_factor) == 0\n                    ]\n                return self.raise_if_exceeds(np.array(ticklocs))\n            if self._minor:\n                ticklocs = []\n                for b in range(binf, bsup):\n                    if b < -1:\n                        ticklocs.extend(np.arange(2, 10) * 10 ** b)\n                    elif b == -1:\n                        ticklocs.extend(np.arange(2, 5) / 10)\n                    elif b == 0:\n                        ticklocs.extend(np.arange(6, 9) / 10)\n                    else:\n                        ticklocs.extend(\n                            1 - np.arange(2, 10)[::-1] * 10 ** (-b - 1)\n                        )\n                return self.raise_if_exceeds(np.array(ticklocs))\n            ticklocs = [ideal_ticks(b) for b in range(binf, bsup + 1)]\n            return self.raise_if_exceeds(np.array(ticklocs))\n        # the scale is zoomed so same ticks as linear scale can be used\n        if self._minor:\n            return []\n        return MaxNLocator.tick_values(self, vmin, vmax)",
        "begin_line": 2728,
        "end_line": 2803,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitLocator.ideal_ticks#2746",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitLocator",
        "signature": "lib.matplotlib.ticker.LogitLocator.ideal_ticks(x)",
        "snippet": "        def ideal_ticks(x):\n            return 10 ** x if x < 0 else 1 - (10 ** (-x)) if x > 0 else 1 / 2",
        "begin_line": 2746,
        "end_line": 2747,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitLocator.nonsingular#2805",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitLocator",
        "signature": "lib.matplotlib.ticker.LogitLocator.nonsingular(self, vmin, vmax)",
        "snippet": "    def nonsingular(self, vmin, vmax):\n        standard_minpos = 1e-7\n        initial_range = (standard_minpos, 1 - standard_minpos)\n        if vmin > vmax:\n            vmin, vmax = vmax, vmin\n        if not np.isfinite(vmin) or not np.isfinite(vmax):\n            vmin, vmax = initial_range  # Initial range, no data plotted yet.\n        elif vmax <= 0 or vmin >= 1:\n            # vmax <= 0 occurs when all values are negative\n            # vmin >= 1 occurs when all values are greater than one\n            cbook._warn_external(\n                \"Data has no values between 0 and 1, and therefore cannot be \"\n                \"logit-scaled.\"\n            )\n            vmin, vmax = initial_range\n        else:\n            minpos = (\n                self.axis.get_minpos()\n                if self.axis is not None\n                else standard_minpos\n            )\n            if not np.isfinite(minpos):\n                minpos = standard_minpos  # This should never take effect.\n            if vmin <= 0:\n                vmin = minpos\n            # NOTE: for vmax, we should query a property similar to get_minpos,\n            # but related to the maximal, less-than-one data point.\n            # Unfortunately, Bbox._minpos is defined very deep in the BBox and\n            # updated with data, so for now we use 1 - minpos as a substitute.\n            if vmax >= 1:\n                vmax = 1 - minpos\n            if vmin == vmax:\n                vmin, vmax = 0.1 * vmin, 1 - 0.1 * vmin\n\n        return vmin, vmax",
        "begin_line": 2805,
        "end_line": 2839,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.AutoLocator.__init__#2848",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.AutoLocator",
        "signature": "lib.matplotlib.ticker.AutoLocator.__init__(self)",
        "snippet": "    def __init__(self):\n        \"\"\"\n        To know the values of the non-public parameters, please have a\n        look to the defaults of `~matplotlib.ticker.MaxNLocator`.\n        \"\"\"\n        if rcParams['_internal.classic_mode']:\n            nbins = 9\n            steps = [1, 2, 5, 10]\n        else:\n            nbins = 'auto'\n            steps = [1, 2, 2.5, 5, 10]\n        MaxNLocator.__init__(self, nbins=nbins, steps=steps)",
        "begin_line": 2848,
        "end_line": 2859,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00038022813688212925,
            "pseudo_dstar_susp": 0.0005461496450027307,
            "pseudo_tarantula_susp": 0.0002860411899313501,
            "pseudo_op2_susp": 0.0005461496450027307,
            "pseudo_barinel_susp": 0.0002860411899313501
        }
    },
    {
        "name": "lib.matplotlib.ticker.AutoMinorLocator.__init__#2867",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.AutoMinorLocator",
        "signature": "lib.matplotlib.ticker.AutoMinorLocator.__init__(self, n=None)",
        "snippet": "    def __init__(self, n=None):\n        \"\"\"\n        *n* is the number of subdivisions of the interval between\n        major ticks; e.g., n=2 will place a single minor tick midway\n        between major ticks.\n\n        If *n* is omitted or None, it will be set to 5 or 4.\n        \"\"\"\n        self.ndivs = n",
        "begin_line": 2867,
        "end_line": 2875,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.ticker.AutoMinorLocator.__call__#2877",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.AutoMinorLocator",
        "signature": "lib.matplotlib.ticker.AutoMinorLocator.__call__(self)",
        "snippet": "    def __call__(self):\n        'Return the locations of the ticks'\n        if self.axis.get_scale() == 'log':\n            cbook._warn_external('AutoMinorLocator does not work with '\n                                 'logarithmic scale')\n            return []\n\n        majorlocs = self.axis.get_majorticklocs()\n        try:\n            majorstep = majorlocs[1] - majorlocs[0]\n        except IndexError:\n            # Need at least two major ticks to find minor tick locations\n            # TODO: Figure out a way to still be able to display minor\n            # ticks without two major ticks visible. For now, just display\n            # no ticks at all.\n            return []\n\n        if self.ndivs is None:\n\n            majorstep_no_exponent = 10 ** (np.log10(majorstep) % 1)\n\n            if np.isclose(majorstep_no_exponent, [1.0, 2.5, 5.0, 10.0]).any():\n                ndivs = 5\n            else:\n                ndivs = 4\n        else:\n            ndivs = self.ndivs\n\n        minorstep = majorstep / ndivs\n\n        vmin, vmax = self.axis.get_view_interval()\n        if vmin > vmax:\n            vmin, vmax = vmax, vmin\n\n        t0 = majorlocs[0]\n        tmin = ((vmin - t0) // minorstep + 1) * minorstep\n        tmax = ((vmax - t0) // minorstep + 1) * minorstep\n        locs = np.arange(tmin, tmax, minorstep) + t0\n\n        return self.raise_if_exceeds(locs)",
        "begin_line": 2877,
        "end_line": 2916,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 9.379983116030391e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.bbox_artist#36",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox",
        "signature": "lib.matplotlib.offsetbox.bbox_artist(*args, **kwargs)",
        "snippet": "def bbox_artist(*args, **kwargs):\n    if DEBUG:\n        mbbox_artist(*args, **kwargs)",
        "begin_line": 36,
        "end_line": 38,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006031363088057901,
            "pseudo_dstar_susp": 0.0006988120195667365,
            "pseudo_tarantula_susp": 0.0001762114537444934,
            "pseudo_op2_susp": 0.0006988120195667365,
            "pseudo_barinel_susp": 0.0001762114537444934
        }
    },
    {
        "name": "lib.matplotlib.offsetbox._get_packed_offsets#45",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox",
        "signature": "lib.matplotlib.offsetbox._get_packed_offsets(wd_list, total, sep, mode='fixed')",
        "snippet": "def _get_packed_offsets(wd_list, total, sep, mode=\"fixed\"):\n    \"\"\"\n    Given a list of (width, xdescent) of each boxes, calculate the\n    total width and the x-offset positions of each items according to\n    *mode*. xdescent is analogous to the usual descent, but along the\n    x-direction. xdescent values are currently ignored.\n\n    For simplicity of the description, the terminology used here assumes a\n    horizontal layout, but the function works equally for a vertical layout.\n\n    There are three packing modes:\n\n    - 'fixed': The elements are packed tight to the left with a spacing of\n      *sep* in between. If *total* is *None* the returned total will be the\n      right edge of the last box. A non-*None* total will be passed unchecked\n      to the output. In particular this means that right edge of the last\n      box may be further to the right than the returned total.\n\n    - 'expand': Distribute the boxes with equal spacing so that the left edge\n      of the first box is at 0, and the right edge of the last box is at\n      *total*. The parameter *sep* is ignored in this mode. A total of *None*\n      is accepted and considered equal to 1. The total is returned unchanged\n      (except for the conversion *None* to 1). If the total is smaller than\n      the sum of the widths, the laid out boxes will overlap.\n\n    - 'equal': If *total* is given, the total space is divided in N equal\n      ranges and each box is left-aligned within its subspace.\n      Otherwise (*total* is *None*), *sep* must be provided and each box is\n      left-aligned in its subspace of width ``(max(widths) + sep)``. The\n      total width is then calculated to be ``N * (max(widths) + sep)``.\n\n    Parameters\n    ----------\n    wd_list : list of (float, float)\n        (width, xdescent) of boxes to be packed.\n    total : float or None\n        Intended total length. *None* if not used.\n    sep : float\n        Spacing between boxes.\n    mode : {'fixed', 'expand', 'equal'}\n        The packing mode.\n\n    Returns\n    -------\n    total : float\n        The total width needed to accommodate the laid out boxes.\n    offsets : array of float\n        The left offsets of the boxes.\n    \"\"\"\n    w_list, d_list = zip(*wd_list)\n    # d_list is currently not used.\n\n    if mode == \"fixed\":\n        offsets_ = np.cumsum([0] + [w + sep for w in w_list])\n        offsets = offsets_[:-1]\n        if total is None:\n            total = offsets_[-1] - sep\n        return total, offsets\n\n    elif mode == \"expand\":\n        # This is a bit of a hack to avoid a TypeError when *total*\n        # is None and used in conjugation with tight layout.\n        if total is None:\n            total = 1\n        if len(w_list) > 1:\n            sep = (total - sum(w_list)) / (len(w_list) - 1)\n        else:\n            sep = 0\n        offsets_ = np.cumsum([0] + [w + sep for w in w_list])\n        offsets = offsets_[:-1]\n        return total, offsets\n\n    elif mode == \"equal\":\n        maxh = max(w_list)\n        if total is None:\n            if sep is None:\n                raise ValueError(\"total and sep cannot both be None when \"\n                                 \"using layout mode 'equal'.\")\n            total = (maxh + sep) * len(w_list)\n        else:\n            sep = total / len(w_list) - maxh\n        offsets = (maxh + sep) * np.arange(len(w_list))\n        return total, offsets\n\n    else:\n        raise ValueError(\"Unknown mode : %s\" % (mode,))",
        "begin_line": 45,
        "end_line": 130,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005824111822947001,
            "pseudo_dstar_susp": 0.0006738544474393531,
            "pseudo_tarantula_susp": 0.00025006251562890725,
            "pseudo_op2_susp": 0.0006738544474393531,
            "pseudo_barinel_susp": 0.00025006251562890725
        }
    },
    {
        "name": "lib.matplotlib.offsetbox._get_aligned_offsets#133",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox",
        "signature": "lib.matplotlib.offsetbox._get_aligned_offsets(hd_list, height, align='baseline')",
        "snippet": "def _get_aligned_offsets(hd_list, height, align=\"baseline\"):\n    \"\"\"\n    Given a list of (height, descent) of each boxes, align the boxes\n    with *align* and calculate the y-offsets of each boxes.\n    total width and the offset positions of each items according to\n    *mode*. xdescent is analogous to the usual descent, but along the\n    x-direction. xdescent values are currently ignored.\n\n    *hd_list* : list of (width, xdescent) of boxes to be aligned.\n    *sep* : spacing between boxes\n    *height* : Intended total length. None if not used.\n    *align* : align mode. 'baseline', 'top', 'bottom', or 'center'.\n    \"\"\"\n\n    if height is None:\n        height = max(h for h, d in hd_list)\n\n    if align == \"baseline\":\n        height_descent = max(h - d for h, d in hd_list)\n        descent = max(d for h, d in hd_list)\n        height = height_descent + descent\n        offsets = [0. for h, d in hd_list]\n    elif align in [\"left\", \"top\"]:\n        descent = 0.\n        offsets = [d for h, d in hd_list]\n    elif align in [\"right\", \"bottom\"]:\n        descent = 0.\n        offsets = [height - h + d for h, d in hd_list]\n    elif align == \"center\":\n        descent = 0.\n        offsets = [(height - h) * .5 + d for h, d in hd_list]\n    else:\n        raise ValueError(\"Unknown Align mode : %s\" % (align,))\n\n    return height, descent, offsets",
        "begin_line": 133,
        "end_line": 167,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006172839506172839,
            "pseudo_dstar_susp": 0.0007446016381236039,
            "pseudo_tarantula_susp": 0.00017787264318747776,
            "pseudo_op2_susp": 0.0007446016381236039,
            "pseudo_barinel_susp": 0.00017787264318747776
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.OffsetBox.__init__#175",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.OffsetBox",
        "signature": "lib.matplotlib.offsetbox.OffsetBox.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n\n        super().__init__(*args, **kwargs)\n\n        # Clipping has not been implemented in the OffesetBox family, so\n        # disable the clip flag for consistency. It can always be turned back\n        # on to zero effect.\n        self.set_clip_on(False)\n\n        self._children = []\n        self._offset = (0, 0)",
        "begin_line": 175,
        "end_line": 185,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00016342539630658605,
            "pseudo_dstar_susp": 0.00019751135690302193,
            "pseudo_tarantula_susp": 0.00013113034356150013,
            "pseudo_op2_susp": 0.00019751135690302193,
            "pseudo_barinel_susp": 0.00013113034356150013
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.OffsetBox.axes#200",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.OffsetBox",
        "signature": "lib.matplotlib.offsetbox.OffsetBox.axes(self, ax)",
        "snippet": "    def axes(self, ax):\n        # TODO deal with this better\n        martist.Artist.axes.fset(self, ax)\n        for c in self.get_children():\n            if c is not None:\n                c.axes = ax",
        "begin_line": 200,
        "end_line": 205,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004399472063352398,
            "pseudo_dstar_susp": 0.00036023054755043225,
            "pseudo_tarantula_susp": 0.00019168104274487253,
            "pseudo_op2_susp": 0.00036023054755043225,
            "pseudo_barinel_susp": 0.00019168104274487253
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.OffsetBox.set_offset#240",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.OffsetBox",
        "signature": "lib.matplotlib.offsetbox.OffsetBox.set_offset(self, xy)",
        "snippet": "    def set_offset(self, xy):\n        \"\"\"\n        Set the offset.\n\n        Parameters\n        ----------\n        xy : (float, float) or callable\n            The (x, y) coordinates of the offset in display units. These can\n            either be given explicitly as a tuple (x, y), or by providing a\n            function that converts the extent into the offset. This function\n            must have the signature::\n\n                def offset(width, height, xdescent, ydescent, renderer) \\\n-> (float, float)\n        \"\"\"\n        self._offset = xy\n        self.stale = True",
        "begin_line": 240,
        "end_line": 256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005991611743559018,
            "pseudo_dstar_susp": 0.0007396449704142012,
            "pseudo_tarantula_susp": 0.00021427040925648167,
            "pseudo_op2_susp": 0.0007396449704142012,
            "pseudo_barinel_susp": 0.00021427040925648167
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.OffsetBox.draw#337",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.OffsetBox",
        "signature": "lib.matplotlib.offsetbox.OffsetBox.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        \"\"\"\n        Update the location of children if necessary and draw them\n        to the given *renderer*.\n        \"\"\"\n        width, height, xdescent, ydescent, offsets = self.get_extent_offsets(\n                                                        renderer)\n\n        px, py = self.get_offset(width, height, xdescent, ydescent, renderer)\n\n        for c, (ox, oy) in zip(self.get_visible_children(), offsets):\n            c.set_offset((px + ox, py + oy))\n            c.draw(renderer)\n\n        bbox_artist(self, renderer, fill=False, props=dict(pad=0.))\n        self.stale = False",
        "begin_line": 337,
        "end_line": 352,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020733982998133942,
            "pseudo_dstar_susp": 0.000180635838150289,
            "pseudo_tarantula_susp": 0.0003450655624568668,
            "pseudo_op2_susp": 0.000180635838150289,
            "pseudo_barinel_susp": 0.00034494653328734045
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.VPacker.get_extent_offsets#449",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.VPacker",
        "signature": "lib.matplotlib.offsetbox.VPacker.get_extent_offsets(self, renderer)",
        "snippet": "    def get_extent_offsets(self, renderer):\n        # docstring inherited\n        dpicor = renderer.points_to_pixels(1.)\n        pad = self.pad * dpicor\n        sep = self.sep * dpicor\n\n        if self.width is not None:\n            for c in self.get_visible_children():\n                if isinstance(c, PackerBase) and c.mode == \"expand\":\n                    c.set_width(self.width)\n\n        whd_list = [c.get_extent(renderer)\n                    for c in self.get_visible_children()]\n        whd_list = [(w, h, xd, (h - yd)) for w, h, xd, yd in whd_list]\n\n        wd_list = [(w, xd) for w, h, xd, yd in whd_list]\n        width, xdescent, xoffsets = _get_aligned_offsets(wd_list,\n                                                         self.width,\n                                                         self.align)\n\n        pack_list = [(h, yd) for w, h, xd, yd in whd_list]\n        height, yoffsets_ = _get_packed_offsets(pack_list, self.height,\n                                                sep, self.mode)\n\n        yoffsets = yoffsets_ + [yd for w, h, xd, yd in whd_list]\n        ydescent = height - yoffsets[0]\n        yoffsets = height - yoffsets\n\n        yoffsets = yoffsets - ydescent\n\n        return (width + 2 * pad, height + 2 * pad,\n                xdescent + pad, ydescent + pad,\n                list(zip(xoffsets, yoffsets)))",
        "begin_line": 449,
        "end_line": 481,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019916351324437363,
            "pseudo_dstar_susp": 0.00016353229762878168,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00016353229762878168,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.HPacker.get_extent_offsets#528",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.HPacker",
        "signature": "lib.matplotlib.offsetbox.HPacker.get_extent_offsets(self, renderer)",
        "snippet": "    def get_extent_offsets(self, renderer):\n        # docstring inherited\n        dpicor = renderer.points_to_pixels(1.)\n        pad = self.pad * dpicor\n        sep = self.sep * dpicor\n\n        whd_list = [c.get_extent(renderer)\n                    for c in self.get_visible_children()]\n\n        if not whd_list:\n            return 2 * pad, 2 * pad, pad, pad, []\n\n        if self.height is None:\n            height_descent = max(h - yd for w, h, xd, yd in whd_list)\n            ydescent = max(yd for w, h, xd, yd in whd_list)\n            height = height_descent + ydescent\n        else:\n            height = self.height - 2 * pad  # width w/o pad\n\n        hd_list = [(h, yd) for w, h, xd, yd in whd_list]\n        height, ydescent, yoffsets = _get_aligned_offsets(hd_list,\n                                                          self.height,\n                                                          self.align)\n\n        pack_list = [(w, xd) for w, h, xd, yd in whd_list]\n\n        width, xoffsets_ = _get_packed_offsets(pack_list, self.width,\n                                               sep, self.mode)\n\n        xoffsets = xoffsets_ + [xd for w, h, xd, yd in whd_list]\n\n        xdescent = whd_list[0][2]\n        xoffsets = xoffsets - xdescent\n\n        return (width + 2 * pad, height + 2 * pad,\n                xdescent + pad, ydescent + pad,\n                list(zip(xoffsets, yoffsets)))",
        "begin_line": 528,
        "end_line": 564,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00031279324366593683,
            "pseudo_dstar_susp": 0.00026041666666666666,
            "pseudo_tarantula_susp": 0.0003786444528587656,
            "pseudo_op2_susp": 0.00026041666666666666,
            "pseudo_barinel_susp": 0.0003786444528587656
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.DrawingArea.__init__#661",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.DrawingArea",
        "signature": "lib.matplotlib.offsetbox.DrawingArea.__init__(self, width, height, xdescent=0.0, ydescent=0.0, clip=False)",
        "snippet": "    def __init__(self, width, height, xdescent=0.,\n                 ydescent=0., clip=False):\n        \"\"\"\n        *width*, *height* : width and height of the container box.\n        *xdescent*, *ydescent* : descent of the box in x- and y-direction.\n        *clip* : Whether to clip the children\n        \"\"\"\n        super().__init__()\n        self.width = width\n        self.height = height\n        self.xdescent = xdescent\n        self.ydescent = ydescent\n        self._clip_children = clip\n        self.offset_transform = mtransforms.Affine2D()\n        self.dpi_transform = mtransforms.Affine2D()",
        "begin_line": 661,
        "end_line": 675,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.03793907242183e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.DrawingArea.get_transform#690",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.DrawingArea",
        "signature": "lib.matplotlib.offsetbox.DrawingArea.get_transform(self)",
        "snippet": "    def get_transform(self):\n        \"\"\"\n        Return the `~matplotlib.transforms.Transform` applied to the children.\n        \"\"\"\n        return self.dpi_transform + self.offset_transform",
        "begin_line": 690,
        "end_line": 694,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019527436047646945,
            "pseudo_dstar_susp": 0.00017214666896195557,
            "pseudo_tarantula_susp": 0.00032393909944930353,
            "pseudo_op2_susp": 0.00017214666896195557,
            "pseudo_barinel_susp": 0.00032393909944930353
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.DrawingArea.set_offset#701",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.DrawingArea",
        "signature": "lib.matplotlib.offsetbox.DrawingArea.set_offset(self, xy)",
        "snippet": "    def set_offset(self, xy):\n        \"\"\"\n        Set the offset of the container.\n\n        Parameters\n        ----------\n        xy : (float, float)\n            The (x, y) coordinates of the offset in display units.\n        \"\"\"\n        self._offset = xy\n        self.offset_transform.clear()\n        self.offset_transform.translate(xy[0], xy[1])\n        self.stale = True",
        "begin_line": 701,
        "end_line": 713,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00031210986267166043,
            "pseudo_dstar_susp": 0.00026399155227032733,
            "pseudo_tarantula_susp": 0.0003627130939426913,
            "pseudo_op2_susp": 0.00026399155227032733,
            "pseudo_barinel_susp": 0.0003627130939426913
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.DrawingArea.get_extent#730",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.DrawingArea",
        "signature": "lib.matplotlib.offsetbox.DrawingArea.get_extent(self, renderer)",
        "snippet": "    def get_extent(self, renderer):\n        \"\"\"\n        Return with, height, xdescent, ydescent of box\n        \"\"\"\n\n        dpi_cor = renderer.points_to_pixels(1.)\n        return (self.width * dpi_cor, self.height * dpi_cor,\n                self.xdescent * dpi_cor, self.ydescent * dpi_cor)",
        "begin_line": 730,
        "end_line": 737,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00030432136335970786,
            "pseudo_dstar_susp": 0.0002635740643120717,
            "pseudo_tarantula_susp": 0.00034048348655090226,
            "pseudo_op2_susp": 0.0002635740643120717,
            "pseudo_barinel_susp": 0.00034048348655090226
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.DrawingArea.draw#750",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.DrawingArea",
        "signature": "lib.matplotlib.offsetbox.DrawingArea.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        \"\"\"\n        Draw the children\n        \"\"\"\n\n        dpi_cor = renderer.points_to_pixels(1.)\n        self.dpi_transform.clear()\n        self.dpi_transform.scale(dpi_cor)\n\n        # At this point the DrawingArea has a transform\n        # to the display space so the path created is\n        # good for clipping children\n        tpath = mtransforms.TransformedPath(\n            mpath.Path([[0, 0], [0, self.height],\n                        [self.width, self.height],\n                        [self.width, 0]]),\n            self.get_transform())\n        for c in self._children:\n            if self._clip_children and not (c.clipbox or c._clippath):\n                c.set_clip_path(tpath)\n            c.draw(renderer)\n\n        bbox_artist(self, renderer, fill=False, props=dict(pad=0.))\n        self.stale = False",
        "begin_line": 750,
        "end_line": 773,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020222446916076846,
            "pseudo_dstar_susp": 0.00017319016279875303,
            "pseudo_tarantula_susp": 0.0003850596842510589,
            "pseudo_op2_susp": 0.00017319016279875303,
            "pseudo_barinel_susp": 0.00038491147036181676
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.TextArea.__init__#783",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.TextArea",
        "signature": "lib.matplotlib.offsetbox.TextArea.__init__(self, s, textprops=None, multilinebaseline=None, minimumdescent=True)",
        "snippet": "    def __init__(self, s,\n                 textprops=None,\n                 multilinebaseline=None,\n                 minimumdescent=True,\n                 ):\n        \"\"\"\n        Parameters\n        ----------\n        s : str\n            a string to be displayed.\n\n        textprops : dictionary, optional, default: None\n            Dictionary of keyword parameters to be passed to the\n            `~matplotlib.text.Text` instance contained inside TextArea.\n\n        multilinebaseline : bool, optional\n            If `True`, baseline for multiline text is adjusted so that it is\n            (approximately) center-aligned with singleline text.\n\n        minimumdescent : bool, optional\n            If `True`, the box has a minimum descent of \"p\".\n        \"\"\"\n        if textprops is None:\n            textprops = {}\n        textprops.setdefault(\"va\", \"baseline\")\n        self._text = mtext.Text(0, 0, s, **textprops)\n        OffsetBox.__init__(self)\n        self._children = [self._text]\n        self.offset_transform = mtransforms.Affine2D()\n        self._baseline_transform = mtransforms.Affine2D()\n        self._text.set_transform(self.offset_transform +\n                                 self._baseline_transform)\n        self._multilinebaseline = multilinebaseline\n        self._minimumdescent = minimumdescent",
        "begin_line": 783,
        "end_line": 816,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.TextArea.draw#921",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.TextArea",
        "signature": "lib.matplotlib.offsetbox.TextArea.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        \"\"\"\n        Draw the children\n        \"\"\"\n\n        self._text.draw(renderer)\n\n        bbox_artist(self, renderer, fill=False, props=dict(pad=0.))\n        self.stale = False",
        "begin_line": 921,
        "end_line": 929,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021734405564007825,
            "pseudo_dstar_susp": 0.00018102824040550325,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00018102824040550325,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox.__init__#1052",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox.__init__(self, loc, pad=0.4, borderpad=0.5, child=None, prop=None, frameon=True, bbox_to_anchor=None, bbox_transform=None, **kwargs)",
        "snippet": "    def __init__(self, loc,\n                 pad=0.4, borderpad=0.5,\n                 child=None, prop=None, frameon=True,\n                 bbox_to_anchor=None,\n                 bbox_transform=None,\n                 **kwargs):\n        \"\"\"\n        loc is a string or an integer specifying the legend location.\n        The valid location codes are::\n\n        'upper right'  : 1,\n        'upper left'   : 2,\n        'lower left'   : 3,\n        'lower right'  : 4,\n        'right'        : 5, (same as 'center right', for back-compatibility)\n        'center left'  : 6,\n        'center right' : 7,\n        'lower center' : 8,\n        'upper center' : 9,\n        'center'       : 10,\n\n        pad : pad around the child for drawing a frame. given in\n          fraction of fontsize.\n\n        borderpad : pad between offsetbox frame and the bbox_to_anchor,\n\n        child : OffsetBox instance that will be anchored.\n\n        prop : font property. This is only used as a reference for paddings.\n\n        frameon : draw a frame box if True.\n\n        bbox_to_anchor : bbox to anchor. Use self.axes.bbox if None.\n\n        bbox_transform : with which the bbox_to_anchor will be transformed.\n\n        \"\"\"\n        super().__init__(**kwargs)\n\n        self.set_bbox_to_anchor(bbox_to_anchor, bbox_transform)\n        self.set_child(child)\n\n        if isinstance(loc, str):\n            loc = cbook._check_getitem(self.codes, loc=loc)\n\n        self.loc = loc\n        self.borderpad = borderpad\n        self.pad = pad\n\n        if prop is None:\n            self.prop = FontProperties(size=rcParams[\"legend.fontsize\"])\n        elif isinstance(prop, dict):\n            self.prop = FontProperties(**prop)\n            if \"size\" not in prop:\n                self.prop.set_size(rcParams[\"legend.fontsize\"])\n        else:\n            self.prop = prop\n\n        self.patch = FancyBboxPatch(\n            xy=(0.0, 0.0), width=1., height=1.,\n            facecolor='w', edgecolor='k',\n            mutation_scale=self.prop.get_size_in_points(),\n            snap=True\n            )\n        self.patch.set_boxstyle(\"square\", pad=0)\n        self._drawFrame = frameon",
        "begin_line": 1052,
        "end_line": 1117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox.get_child#1126",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox.get_child(self)",
        "snippet": "    def get_child(self):\n        \"return the child\"\n        return self._child",
        "begin_line": 1126,
        "end_line": 1128,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 8.905512512245079e-05,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox.get_children#1130",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox.get_children(self)",
        "snippet": "    def get_children(self):\n        \"return the list of children\"\n        return [self._child]",
        "begin_line": 1130,
        "end_line": 1132,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012454851164528583,
            "pseudo_dstar_susp": 0.00011988970147464332,
            "pseudo_tarantula_susp": 0.00017415534656913968,
            "pseudo_op2_susp": 0.00011988970147464332,
            "pseudo_barinel_susp": 0.0001742767514813524
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox.get_extent#1134",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox.get_extent(self, renderer)",
        "snippet": "    def get_extent(self, renderer):\n        \"\"\"\n        return the extent of the artist. The extent of the child\n        added with the pad is returned\n        \"\"\"\n        w, h, xd, yd = self.get_child().get_extent(renderer)\n        fontsize = renderer.points_to_pixels(self.prop.get_size_in_points())\n        pad = self.pad * fontsize\n\n        return w + 2 * pad, h + 2 * pad, xd + pad, yd + pad",
        "begin_line": 1134,
        "end_line": 1143,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox.get_bbox_to_anchor#1145",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox.get_bbox_to_anchor(self)",
        "snippet": "    def get_bbox_to_anchor(self):\n        \"\"\"\n        return the bbox that the legend will be anchored\n        \"\"\"\n        if self._bbox_to_anchor is None:\n            return self.axes.bbox\n        else:\n            transform = self._bbox_to_anchor_transform\n            if transform is None:\n                return self._bbox_to_anchor\n            else:\n                return TransformedBbox(self._bbox_to_anchor,\n                                       transform)",
        "begin_line": 1145,
        "end_line": 1157,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012717792191275595,
            "pseudo_dstar_susp": 0.0001210800339024095,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.0001210800339024095,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox.set_bbox_to_anchor#1159",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox.set_bbox_to_anchor(self, bbox, transform=None)",
        "snippet": "    def set_bbox_to_anchor(self, bbox, transform=None):\n        \"\"\"\n        set the bbox that the child will be anchored.\n\n        *bbox* can be a Bbox instance, a list of [left, bottom, width,\n        height], or a list of [left, bottom] where the width and\n        height will be assumed to be zero. The bbox will be\n        transformed to display coordinate by the given transform.\n        \"\"\"\n        if bbox is None or isinstance(bbox, BboxBase):\n            self._bbox_to_anchor = bbox\n        else:\n            try:\n                l = len(bbox)\n            except TypeError:\n                raise ValueError(\"Invalid argument for bbox : %s\" % str(bbox))\n\n            if l == 2:\n                bbox = [bbox[0], bbox[1], 0, 0]\n\n            self._bbox_to_anchor = Bbox.from_bounds(*bbox)\n\n        self._bbox_to_anchor_transform = transform\n        self.stale = True",
        "begin_line": 1159,
        "end_line": 1182,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012717792191275595,
            "pseudo_dstar_susp": 0.0001210800339024095,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.0001210800339024095,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox.get_window_extent#1184",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox.get_window_extent(self, renderer)",
        "snippet": "    def get_window_extent(self, renderer):\n        '''\n        get the bounding box in display space.\n        '''\n        self._update_offset_func(renderer)\n        w, h, xd, yd = self.get_extent(renderer)\n        ox, oy = self.get_offset(w, h, xd, yd, renderer)\n        return Bbox.from_bounds(ox - xd, oy - yd, w, h)",
        "begin_line": 1184,
        "end_line": 1191,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox._update_offset_func#1193",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox._update_offset_func(self, renderer, fontsize=None)",
        "snippet": "    def _update_offset_func(self, renderer, fontsize=None):\n        \"\"\"\n        Update the offset func which depends on the dpi of the\n        renderer (because of the padding).\n        \"\"\"\n        if fontsize is None:\n            fontsize = renderer.points_to_pixels(\n                            self.prop.get_size_in_points())\n\n        def _offset(w, h, xd, yd, renderer, fontsize=fontsize, self=self):\n            bbox = Bbox.from_bounds(0, 0, w, h)\n            borderpad = self.borderpad * fontsize\n            bbox_to_anchor = self.get_bbox_to_anchor()\n\n            x0, y0 = self._get_anchored_bbox(self.loc,\n                                             bbox,\n                                             bbox_to_anchor,\n                                             borderpad)\n            return x0 + xd, y0 + yd\n\n        self.set_offset(_offset)",
        "begin_line": 1193,
        "end_line": 1213,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox._offset#1202",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox._offset(w, h, xd, yd, renderer, fontsize=fontsize, self=self)",
        "snippet": "        def _offset(w, h, xd, yd, renderer, fontsize=fontsize, self=self):\n            bbox = Bbox.from_bounds(0, 0, w, h)\n            borderpad = self.borderpad * fontsize\n            bbox_to_anchor = self.get_bbox_to_anchor()\n\n            x0, y0 = self._get_anchored_bbox(self.loc,\n                                             bbox,\n                                             bbox_to_anchor,\n                                             borderpad)\n            return x0 + xd, y0 + yd",
        "begin_line": 1202,
        "end_line": 1211,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012454851164528583,
            "pseudo_dstar_susp": 0.00011988970147464332,
            "pseudo_tarantula_susp": 0.00017415534656913968,
            "pseudo_op2_susp": 0.00011988970147464332,
            "pseudo_barinel_susp": 0.0001742767514813524
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox.update_frame#1215",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox.update_frame(self, bbox, fontsize=None)",
        "snippet": "    def update_frame(self, bbox, fontsize=None):\n        self.patch.set_bounds(bbox.x0, bbox.y0,\n                              bbox.width, bbox.height)\n\n        if fontsize:\n            self.patch.set_mutation_scale(fontsize)",
        "begin_line": 1215,
        "end_line": 1220,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox.draw#1222",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        \"draw the artist\"\n\n        if not self.get_visible():\n            return\n\n        fontsize = renderer.points_to_pixels(self.prop.get_size_in_points())\n        self._update_offset_func(renderer, fontsize)\n\n        if self._drawFrame:\n            # update the location and size of the legend\n            bbox = self.get_window_extent(renderer)\n            self.update_frame(bbox, fontsize)\n            self.patch.draw(renderer)\n\n        width, height, xdescent, ydescent = self.get_extent(renderer)\n\n        px, py = self.get_offset(width, height, xdescent, ydescent, renderer)\n\n        self.get_child().set_offset((px, py))\n        self.get_child().draw(renderer)\n        self.stale = False",
        "begin_line": 1222,
        "end_line": 1243,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox._get_anchored_bbox#1245",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox._get_anchored_bbox(self, loc, bbox, parentbbox, borderpad)",
        "snippet": "    def _get_anchored_bbox(self, loc, bbox, parentbbox, borderpad):\n        \"\"\"\n        return the position of the bbox anchored at the parentbbox\n        with the loc code, with the borderpad.\n        \"\"\"\n        assert loc in range(1, 11)  # called only internally\n\n        BEST, UR, UL, LL, LR, R, CL, CR, LC, UC, C = range(11)\n\n        anchor_coefs = {UR: \"NE\",\n                        UL: \"NW\",\n                        LL: \"SW\",\n                        LR: \"SE\",\n                        R: \"E\",\n                        CL: \"W\",\n                        CR: \"E\",\n                        LC: \"S\",\n                        UC: \"N\",\n                        C: \"C\"}\n\n        c = anchor_coefs[loc]\n\n        container = parentbbox.padded(-borderpad)\n        anchored_box = bbox.anchored(c, container=container)\n        return anchored_box.x0, anchored_box.y0",
        "begin_line": 1245,
        "end_line": 1269,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012454851164528583,
            "pseudo_dstar_susp": 0.00011988970147464332,
            "pseudo_tarantula_susp": 0.00017415534656913968,
            "pseudo_op2_susp": 0.00011988970147464332,
            "pseudo_barinel_susp": 0.0001742767514813524
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.DraggableBase.disconnect#1767",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.DraggableBase",
        "signature": "lib.matplotlib.offsetbox.DraggableBase.disconnect(self)",
        "snippet": "    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)",
        "begin_line": 1767,
        "end_line": 1776,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.DraggableOffsetBox.__init__#1792",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.DraggableOffsetBox",
        "signature": "lib.matplotlib.offsetbox.DraggableOffsetBox.__init__(self, ref_artist, offsetbox, use_blit=False)",
        "snippet": "    def __init__(self, ref_artist, offsetbox, use_blit=False):\n        DraggableBase.__init__(self, ref_artist, use_blit=use_blit)\n        self.offsetbox = offsetbox",
        "begin_line": 1792,
        "end_line": 1794,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib._pylab_helpers.Gcf.destroy_all#66",
        "src_path": "lib/matplotlib/_pylab_helpers.py",
        "class_name": "lib.matplotlib._pylab_helpers.Gcf",
        "signature": "lib.matplotlib._pylab_helpers.Gcf.destroy_all(cls)",
        "snippet": "    def destroy_all(cls):\n        # this is need to ensure that gc is available in corner cases\n        # where modules are being torn down after install with easy_install\n        import gc  # noqa\n        for manager in list(cls.figs.values()):\n            manager.canvas.mpl_disconnect(manager._cidgcf)\n            manager.destroy()\n\n        cls._activeQue = []\n        cls.figs.clear()\n        gc.collect(1)",
        "begin_line": 66,
        "end_line": 76,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011370096645821489,
            "pseudo_dstar_susp": 0.0001939487975174554,
            "pseudo_tarantula_susp": 0.00011377858686995108,
            "pseudo_op2_susp": 0.0001939487975174554,
            "pseudo_barinel_susp": 0.00011377858686995108
        }
    },
    {
        "name": "lib.matplotlib._pylab_helpers.Gcf.set_active#110",
        "src_path": "lib/matplotlib/_pylab_helpers.py",
        "class_name": "lib.matplotlib._pylab_helpers.Gcf",
        "signature": "lib.matplotlib._pylab_helpers.Gcf.set_active(cls, manager)",
        "snippet": "    def set_active(cls, manager):\n        \"\"\"\n        Make the figure corresponding to *manager* the active one.\n        \"\"\"\n        oldQue = cls._activeQue[:]\n        cls._activeQue = [m for m in oldQue if m != manager]\n        cls._activeQue.append(manager)\n        cls.figs[manager.num] = manager",
        "begin_line": 110,
        "end_line": 117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012422360248447205,
            "pseudo_dstar_susp": 0.0018181818181818182,
            "pseudo_tarantula_susp": 0.0003946329913180742,
            "pseudo_op2_susp": 0.0018181818181818182,
            "pseudo_barinel_susp": 0.0003946329913180742
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.escape_cdata#68",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg",
        "signature": "lib.matplotlib.backends.backend_svg.escape_cdata(s)",
        "snippet": "def escape_cdata(s):\n    s = s.replace(\"&\", \"&amp;\")\n    s = s.replace(\"<\", \"&lt;\")\n    s = s.replace(\">\", \"&gt;\")\n    return s",
        "begin_line": 68,
        "end_line": 72,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001638001638001638,
            "pseudo_dstar_susp": 0.00017943656917279743,
            "pseudo_tarantula_susp": 0.00017683465959328028,
            "pseudo_op2_susp": 0.00017943656917279743,
            "pseudo_barinel_susp": 0.00017683465959328028
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.escape_comment#78",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg",
        "signature": "lib.matplotlib.backends.backend_svg.escape_comment(s)",
        "snippet": "def escape_comment(s):\n    s = escape_cdata(s)\n    return _escape_xml_comment.sub('- ', s)",
        "begin_line": 78,
        "end_line": 80,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00015728216420257942,
            "pseudo_dstar_susp": 0.0001591596371160274,
            "pseudo_tarantula_susp": 0.00018914318138831096,
            "pseudo_op2_susp": 0.0001591596371160274,
            "pseudo_barinel_susp": 0.00018914318138831096
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.escape_attrib#83",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg",
        "signature": "lib.matplotlib.backends.backend_svg.escape_attrib(s)",
        "snippet": "def escape_attrib(s):\n    s = s.replace(\"&\", \"&amp;\")\n    s = s.replace(\"'\", \"&apos;\")\n    s = s.replace('\"', \"&quot;\")\n    s = s.replace(\"<\", \"&lt;\")\n    s = s.replace(\">\", \"&gt;\")\n    return s",
        "begin_line": 83,
        "end_line": 89,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001792435920415845,
            "pseudo_dstar_susp": 0.00018542555164101615,
            "pseudo_tarantula_susp": 0.00019091256204658267,
            "pseudo_op2_susp": 0.00018542555164101615,
            "pseudo_barinel_susp": 0.00019091256204658267
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.XMLWriter.__flush#116",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.XMLWriter",
        "signature": "lib.matplotlib.backends.backend_svg.XMLWriter.__flush(self, indent=True)",
        "snippet": "    def __flush(self, indent=True):\n        # flush internal buffers\n        if self.__open:\n            if indent:\n                self.__write(\">\\n\")\n            else:\n                self.__write(\">\")\n            self.__open = 0\n        if self.__data:\n            data = ''.join(self.__data)\n            self.__write(escape_cdata(data))\n            self.__data = []",
        "begin_line": 116,
        "end_line": 127,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00014158289678606824,
            "pseudo_dstar_susp": 0.00015855398763278897,
            "pseudo_tarantula_susp": 0.0001598976654940838,
            "pseudo_op2_susp": 0.00015855398763278897,
            "pseudo_barinel_susp": 0.0001598976654940838
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.XMLWriter.end#186",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.XMLWriter",
        "signature": "lib.matplotlib.backends.backend_svg.XMLWriter.end(self, tag=None, indent=True)",
        "snippet": "    def end(self, tag=None, indent=True):\n        \"\"\"\n        Closes the current element (opened by the most recent call to\n        :meth:`start`).\n\n        Parameters\n        ----------\n        tag\n            Element tag.  If given, the tag must match the start tag.  If\n            omitted, the current element is closed.\n       \"\"\"\n        if tag:\n            assert self.__tags, \"unbalanced end(%s)\" % tag\n            assert escape_cdata(tag) == self.__tags[-1], \\\n                \"expected end(%s), got %s\" % (self.__tags[-1], tag)\n        else:\n            assert self.__tags, \"unbalanced end()\"\n        tag = self.__tags.pop()\n        if self.__data:\n            self.__flush(indent)\n        elif self.__open:\n            self.__open = 0\n            self.__write(\"/>\\n\")\n            return\n        if indent:\n            self.__write(self.__indentation[:len(self.__tags)])\n        self.__write(\"</%s>\\n\" % tag)",
        "begin_line": 186,
        "end_line": 212,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00014204545454545454,
            "pseudo_dstar_susp": 0.00015865460891638903,
            "pseudo_tarantula_susp": 0.00016488046166529267,
            "pseudo_op2_susp": 0.00015865460891638903,
            "pseudo_barinel_susp": 0.00016482610845557937
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.XMLWriter.element#227",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.XMLWriter",
        "signature": "lib.matplotlib.backends.backend_svg.XMLWriter.element(self, tag, text=None, attrib={}, **extra)",
        "snippet": "    def element(self, tag, text=None, attrib={}, **extra):\n        \"\"\"\n        Adds an entire element.  This is the same as calling :meth:`start`,\n        :meth:`data`, and :meth:`end` in sequence. The *text* argument can be\n        omitted.\n        \"\"\"\n        self.start(tag, attrib, **extra)\n        if text:\n            self.data(text)\n        self.end(indent=False)",
        "begin_line": 227,
        "end_line": 236,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001820830298616169,
            "pseudo_dstar_susp": 0.00018570102135561745,
            "pseudo_tarantula_susp": 0.00020008003201280514,
            "pseudo_op2_susp": 0.00018570102135561745,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.generate_css#259",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg",
        "signature": "lib.matplotlib.backends.backend_svg.generate_css(attrib={})",
        "snippet": "def generate_css(attrib={}):\n    if attrib:\n        output = io.StringIO()\n        attrib = sorted(attrib.items())\n        for k, v in attrib:\n            k = escape_attrib(k)\n            v = escape_attrib(v)\n            output.write(\"%s:%s;\" % (k, v))\n        return output.getvalue()\n    return ''",
        "begin_line": 259,
        "end_line": 268,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012717792191275595,
            "pseudo_dstar_susp": 0.0001210800339024095,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.0001210800339024095,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__#275",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__(self, width, height, svgwriter, basename=None, image_dpi=72)",
        "snippet": "    def __init__(self, width, height, svgwriter, basename=None, image_dpi=72):\n        self.width = width\n        self.height = height\n        self.writer = XMLWriter(svgwriter)\n        self.image_dpi = image_dpi  # actual dpi at which we rasterize stuff\n\n        self._groupd = {}\n        self.basename = basename\n        self._image_counter = itertools.count()\n        self._clipd = OrderedDict()\n        self._markers = {}\n        self._path_collection_id = 0\n        self._hatchd = OrderedDict()\n        self._has_gouraud = False\n        self._n_gradients = 0\n        self._fonts = OrderedDict()\n        self.mathtext_parser = MathTextParser('SVG')\n\n        RendererBase.__init__(self)\n        self._glyph_map = dict()\n        str_height = short_float_fmt(height)\n        str_width = short_float_fmt(width)\n        svgwriter.write(svgProlog)\n        self._start_id = self.writer.start(\n            'svg',\n            width='%spt' % str_width,\n            height='%spt' % str_height,\n            viewBox='0 0 %s %s' % (str_width, str_height),\n            xmlns=\"http://www.w3.org/2000/svg\",\n            version=\"1.1\",\n            attrib={'xmlns:xlink': \"http://www.w3.org/1999/xlink\"})\n        self._write_default_style()",
        "begin_line": 275,
        "end_line": 306,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012454851164528583,
            "pseudo_dstar_susp": 0.00011988970147464332,
            "pseudo_tarantula_susp": 0.00017415534656913968,
            "pseudo_op2_susp": 0.00011988970147464332,
            "pseudo_barinel_susp": 0.0001742767514813524
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG._get_style_dict#407",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG._get_style_dict(self, gc, rgbFace)",
        "snippet": "    def _get_style_dict(self, gc, rgbFace):\n        \"\"\"Generate a style string from the GraphicsContext and rgbFace.\"\"\"\n        attrib = {}\n\n        forced_alpha = gc.get_forced_alpha()\n\n        if gc.get_hatch() is not None:\n            attrib['fill'] = \"url(#%s)\" % self._get_hatch(gc, rgbFace)\n            if (rgbFace is not None and len(rgbFace) == 4 and rgbFace[3] != 1.0\n                    and not forced_alpha):\n                attrib['fill-opacity'] = short_float_fmt(rgbFace[3])\n        else:\n            if rgbFace is None:\n                attrib['fill'] = 'none'\n            else:\n                if tuple(rgbFace[:3]) != (0, 0, 0):\n                    attrib['fill'] = rgb2hex(rgbFace)\n                if (len(rgbFace) == 4 and rgbFace[3] != 1.0\n                        and not forced_alpha):\n                    attrib['fill-opacity'] = short_float_fmt(rgbFace[3])\n\n        if forced_alpha and gc.get_alpha() != 1.0:\n            attrib['opacity'] = short_float_fmt(gc.get_alpha())\n\n        offset, seq = gc.get_dashes()\n        if seq is not None:\n            attrib['stroke-dasharray'] = ','.join(\n                short_float_fmt(val) for val in seq)\n            attrib['stroke-dashoffset'] = short_float_fmt(float(offset))\n\n        linewidth = gc.get_linewidth()\n        if linewidth:\n            rgb = gc.get_rgb()\n            attrib['stroke'] = rgb2hex(rgb)\n            if not forced_alpha and rgb[3] != 1.0:\n                attrib['stroke-opacity'] = short_float_fmt(rgb[3])\n            if linewidth != 1.0:\n                attrib['stroke-width'] = short_float_fmt(linewidth)\n            if gc.get_joinstyle() != 'round':\n                attrib['stroke-linejoin'] = gc.get_joinstyle()\n            if gc.get_capstyle() != 'butt':\n                attrib['stroke-linecap'] = _capstyle_d[gc.get_capstyle()]\n\n        return attrib",
        "begin_line": 407,
        "end_line": 450,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012717792191275595,
            "pseudo_dstar_susp": 0.0001210800339024095,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.0001210800339024095,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG.option_image_nocomposite#514",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG.option_image_nocomposite(self)",
        "snippet": "    def option_image_nocomposite(self):\n        # docstring inherited\n        return not rcParams['image.composite_image']",
        "begin_line": 514,
        "end_line": 516,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012454851164528583,
            "pseudo_dstar_susp": 0.00011988970147464332,
            "pseudo_tarantula_susp": 0.00017415534656913968,
            "pseudo_op2_susp": 0.00011988970147464332,
            "pseudo_barinel_susp": 0.0001742767514813524
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers#550",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers(self, gc, marker_path, marker_trans, path, trans, rgbFace=None)",
        "snippet": "    def draw_markers(\n            self, gc, marker_path, marker_trans, path, trans, rgbFace=None):\n        # docstring inherited\n\n        if not len(path.vertices):\n            return\n\n        writer = self.writer\n        path_data = self._convert_path(\n            marker_path,\n            marker_trans + Affine2D().scale(1.0, -1.0),\n            simplify=False)\n        style = self._get_style_dict(gc, rgbFace)\n        dictkey = (path_data, generate_css(style))\n        oid = self._markers.get(dictkey)\n        style = generate_css({k: v for k, v in style.items()\n                              if k.startswith('stroke')})\n\n        if oid is None:\n            oid = self._make_id('m', dictkey)\n            writer.start('defs')\n            writer.element('path', id=oid, d=path_data, style=style)\n            writer.end('defs')\n            self._markers[dictkey] = oid\n\n        attrib = {}\n        clipid = self._get_clip(gc)\n        if clipid is not None:\n            attrib['clip-path'] = 'url(#%s)' % clipid\n        writer.start('g', attrib=attrib)\n\n        trans_and_flip = self._make_flip_transform(trans)\n        attrib = {'xlink:href': '#%s' % oid}\n        clip = (0, 0, self.width*72, self.height*72)\n        for vertices, code in path.iter_segments(\n                trans_and_flip, clip=clip, simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                attrib['x'] = short_float_fmt(x)\n                attrib['y'] = short_float_fmt(y)\n                attrib['style'] = self._get_style(gc, rgbFace)\n                writer.element('use', attrib=attrib)\n        writer.end('g')",
        "begin_line": 550,
        "end_line": 592,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012454851164528583,
            "pseudo_dstar_susp": 0.00011988970147464332,
            "pseudo_tarantula_susp": 0.00017415534656913968,
            "pseudo_op2_susp": 0.00011988970147464332,
            "pseudo_barinel_susp": 0.0001742767514813524
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG._draw_text_as_path#883",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG._draw_text_as_path(self, gc, x, y, s, prop, angle, ismath, mtext=None)",
        "snippet": "    def _draw_text_as_path(self, gc, x, y, s, prop, angle, ismath, mtext=None):\n        \"\"\"\n        draw the text by converting them to paths using textpath module.\n\n        Parameters\n        ----------\n        prop : `matplotlib.font_manager.FontProperties`\n          font property\n\n        s : str\n          text to be converted\n\n        usetex : bool\n          If True, use matplotlib usetex mode.\n\n        ismath : bool\n          If True, use mathtext parser. If \"TeX\", use *usetex* mode.\n\n        \"\"\"\n        writer = self.writer\n\n        writer.comment(s)\n\n        glyph_map = self._glyph_map\n\n        text2path = self._text2path\n        color = rgb2hex(gc.get_rgb())\n        fontsize = prop.get_size_in_points()\n\n        style = {}\n        if color != '#000000':\n            style['fill'] = color\n\n        alpha = gc.get_alpha() if gc.get_forced_alpha() else gc.get_rgb()[3]\n        if alpha != 1:\n            style['opacity'] = short_float_fmt(alpha)\n\n        if not ismath:\n            font = text2path._get_font(prop)\n            _glyphs = text2path.get_glyphs_with_font(\n                font, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            glyph_info, glyph_map_new, rects = _glyphs\n\n            if glyph_map_new:\n                writer.start('defs')\n                for char_id, glyph_path in glyph_map_new.items():\n                    path = Path(*glyph_path)\n                    path_data = self._convert_path(path, simplify=False)\n                    writer.element('path', id=char_id, d=path_data)\n                writer.end('defs')\n\n                glyph_map.update(glyph_map_new)\n\n            attrib = {}\n            attrib['style'] = generate_css(style)\n            font_scale = fontsize / text2path.FONT_SCALE\n            attrib['transform'] = generate_transform([\n                ('translate', (x, y)),\n                ('rotate', (-angle,)),\n                ('scale', (font_scale, -font_scale))])\n\n            writer.start('g', attrib=attrib)\n            for glyph_id, xposition, yposition, scale in glyph_info:\n                attrib = {'xlink:href': '#%s' % glyph_id}\n                if xposition != 0.0:\n                    attrib['x'] = short_float_fmt(xposition)\n                if yposition != 0.0:\n                    attrib['y'] = short_float_fmt(yposition)\n                writer.element(\n                    'use',\n                    attrib=attrib)\n\n            writer.end('g')\n        else:\n            if ismath == \"TeX\":\n                _glyphs = text2path.get_glyphs_tex(\n                    prop, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            else:\n                _glyphs = text2path.get_glyphs_mathtext(\n                    prop, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n\n            glyph_info, glyph_map_new, rects = _glyphs\n\n            # We store the character glyphs w/o flipping.  Instead, the\n            # coordinate will be flipped when these characters are used.\n            if glyph_map_new:\n                writer.start('defs')\n                for char_id, glyph_path in glyph_map_new.items():\n                    char_id = self._adjust_char_id(char_id)\n                    # Some characters are blank\n                    if not len(glyph_path[0]):\n                        path_data = \"\"\n                    else:\n                        path = Path(*glyph_path)\n                        path_data = self._convert_path(path, simplify=False)\n                    writer.element('path', id=char_id, d=path_data)\n                writer.end('defs')\n\n                glyph_map.update(glyph_map_new)\n\n            attrib = {}\n            font_scale = fontsize / text2path.FONT_SCALE\n            attrib['style'] = generate_css(style)\n            attrib['transform'] = generate_transform([\n                ('translate', (x, y)),\n                ('rotate', (-angle,)),\n                ('scale', (font_scale, -font_scale))])\n\n            writer.start('g', attrib=attrib)\n            for char_id, xposition, yposition, scale in glyph_info:\n                char_id = self._adjust_char_id(char_id)\n\n                writer.element(\n                    'use',\n                    transform=generate_transform([\n                        ('translate', (xposition, yposition)),\n                        ('scale', (scale,)),\n                        ]),\n                    attrib={'xlink:href': '#%s' % char_id})\n\n            for verts, codes in rects:\n                path = Path(verts, codes)\n                path_data = self._convert_path(path, simplify=False)\n                writer.element('path', d=path_data)\n\n            writer.end('g')",
        "begin_line": 883,
        "end_line": 1008,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012717792191275595,
            "pseudo_dstar_susp": 0.0001210800339024095,
            "pseudo_tarantula_susp": 0.00019627085377821394,
            "pseudo_op2_susp": 0.0001210800339024095,
            "pseudo_barinel_susp": 0.00019657951641438963
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text#1140",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None)",
        "snippet": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        clipid = self._get_clip(gc)\n        if clipid is not None:\n            # Cannot apply clip-path directly to the text, because\n            # is has a transformation\n            self.writer.start(\n                'g', attrib={'clip-path': 'url(#%s)' % clipid})\n\n        if gc.get_url() is not None:\n            self.writer.start('a', {'xlink:href': gc.get_url()})\n\n        if rcParams['svg.fonttype'] == 'path':\n            self._draw_text_as_path(gc, x, y, s, prop, angle, ismath, mtext)\n        else:\n            self._draw_text_as_text(gc, x, y, s, prop, angle, ismath, mtext)\n\n        if gc.get_url() is not None:\n            self.writer.end('a')\n\n        if clipid is not None:\n            self.writer.end('g')",
        "begin_line": 1140,
        "end_line": 1162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00013225763787858748,
            "pseudo_dstar_susp": 0.00012283503255128362,
            "pseudo_tarantula_susp": 0.00024213075060532688,
            "pseudo_op2_susp": 0.00012283503255128362,
            "pseudo_barinel_susp": 0.0002420135527589545
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG.flipy#1164",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG.flipy(self)",
        "snippet": "    def flipy(self):\n        # docstring inherited\n        return True",
        "begin_line": 1164,
        "end_line": 1166,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012454851164528583,
            "pseudo_dstar_susp": 0.00011988970147464332,
            "pseudo_tarantula_susp": 0.00017415534656913968,
            "pseudo_op2_susp": 0.00011988970147464332,
            "pseudo_barinel_susp": 0.0001742767514813524
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG.get_canvas_width_height#1168",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG.get_canvas_width_height(self)",
        "snippet": "    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height",
        "begin_line": 1168,
        "end_line": 1170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012454851164528583,
            "pseudo_dstar_susp": 0.00011988970147464332,
            "pseudo_tarantula_susp": 0.00017415534656913968,
            "pseudo_op2_susp": 0.00011988970147464332,
            "pseudo_barinel_susp": 0.0001742767514813524
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG.get_text_width_height_descent#1172",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG.get_text_width_height_descent(self, s, prop, ismath)",
        "snippet": "    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n        return self._text2path.get_text_width_height_descent(s, prop, ismath)",
        "begin_line": 1172,
        "end_line": 1174,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svg#1183",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG",
        "signature": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svg(self, filename, *args, **kwargs)",
        "snippet": "    def print_svg(self, filename, *args, **kwargs):\n        with cbook.open_file_cm(filename, \"w\", encoding=\"utf-8\") as fh:\n\n            filename = getattr(fh, 'name', '')\n            if not isinstance(filename, str):\n                filename = ''\n\n            if cbook.file_requires_unicode(fh):\n                detach = False\n            else:\n                fh = io.TextIOWrapper(fh, 'utf-8')\n                detach = True\n\n            result = self._print_svg(filename, fh, **kwargs)\n\n            # Detach underlying stream from wrapper so that it remains open in\n            # the caller.\n            if detach:\n                fh.detach()\n\n        return result",
        "begin_line": 1183,
        "end_line": 1203,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00012454851164528583,
            "pseudo_dstar_susp": 0.00011988970147464332,
            "pseudo_tarantula_susp": 0.00017415534656913968,
            "pseudo_op2_susp": 0.00011988970147464332,
            "pseudo_barinel_susp": 0.0001742767514813524
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG._print_svg#1210",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG",
        "signature": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG._print_svg(self, filename, fh, *, dpi=72, bbox_inches_restore=None, **kwargs)",
        "snippet": "    def _print_svg(\n            self, filename, fh, *, dpi=72, bbox_inches_restore=None, **kwargs):\n        self.figure.set_dpi(72.0)\n        width, height = self.figure.get_size_inches()\n        w, h = width * 72, height * 72\n\n        renderer = MixedModeRenderer(\n            self.figure, width, height, dpi,\n            RendererSVG(w, h, fh, filename, dpi),\n            bbox_inches_restore=bbox_inches_restore)\n\n        self.figure.draw(renderer)\n        renderer.finalize()",
        "begin_line": 1210,
        "end_line": 1222,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0001487652484379649,
            "pseudo_dstar_susp": 0.00012812299807815503,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00012812299807815503,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend.__init__#307",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend.__init__(self, parent, handles, labels, loc=None, numpoints=None, markerscale=None, markerfirst=True, scatterpoints=None, scatteryoffsets=None, prop=None, fontsize=None, borderpad=None, labelspacing=None, handlelength=None, handleheight=None, handletextpad=None, borderaxespad=None, columnspacing=None, ncol=1, mode=None, fancybox=None, shadow=None, title=None, title_fontsize=None, framealpha=None, edgecolor=None, facecolor=None, bbox_to_anchor=None, bbox_transform=None, frameon=None, handler_map=None)",
        "snippet": "    def __init__(self, parent, handles, labels,\n                 loc=None,\n                 numpoints=None,    # the number of points in the legend line\n                 markerscale=None,  # the relative size of legend markers\n                                    # vs. original\n                 markerfirst=True,  # controls ordering (left-to-right) of\n                                    # legend marker and label\n                 scatterpoints=None,    # number of scatter points\n                 scatteryoffsets=None,\n                 prop=None,          # properties for the legend texts\n                 fontsize=None,        # keyword to set font size directly\n\n                 # spacing & pad defined as a fraction of the font-size\n                 borderpad=None,      # the whitespace inside the legend border\n                 labelspacing=None,   # the vertical space between the legend\n                                      # entries\n                 handlelength=None,   # the length of the legend handles\n                 handleheight=None,   # the height of the legend handles\n                 handletextpad=None,  # the pad between the legend handle\n                                      # and text\n                 borderaxespad=None,  # the pad between the axes and legend\n                                      # border\n                 columnspacing=None,  # spacing between columns\n\n                 ncol=1,     # number of columns\n                 mode=None,  # mode for horizontal distribution of columns.\n                             # None, \"expand\"\n\n                 fancybox=None,  # True use a fancy box, false use a rounded\n                                 # box, none use rc\n                 shadow=None,\n                 title=None,  # set a title for the legend\n                 title_fontsize=None,  # set to ax.fontsize if None\n                 framealpha=None,  # set frame alpha\n                 edgecolor=None,  # frame patch edgecolor\n                 facecolor=None,  # frame patch facecolor\n\n                 bbox_to_anchor=None,  # bbox that the legend will be anchored.\n                 bbox_transform=None,  # transform for the bbox\n                 frameon=None,  # draw frame\n                 handler_map=None,\n                 ):\n        \"\"\"\n        Parameters\n        ----------\n        parent : `~matplotlib.axes.Axes` or `.Figure`\n            The artist that contains the legend.\n\n        handles : list of `.Artist`\n            A list of Artists (lines, patches) to be added to the legend.\n\n        labels : list of str\n            A list of labels to show next to the artists. The length of handles\n            and labels should be the same. If they are not, they are truncated\n            to the smaller of both lengths.\n\n        Other Parameters\n        ----------------\n        %(_legend_kw_doc)s\n\n        Notes\n        -----\n        Users can specify any arbitrary location for the legend using the\n        *bbox_to_anchor* keyword argument. *bbox_to_anchor* can be a\n        `.BboxBase` (or derived therefrom) or a tuple of 2 or 4 floats.\n        See :meth:`set_bbox_to_anchor` for more detail.\n\n        The legend location can be specified by setting *loc* with a tuple of\n        2 floats, which is interpreted as the lower-left corner of the legend\n        in the normalized axes coordinate.\n        \"\"\"\n        # local import only to avoid circularity\n        from matplotlib.axes import Axes\n        from matplotlib.figure import Figure\n\n        Artist.__init__(self)\n\n        if prop is None:\n            if fontsize is not None:\n                self.prop = FontProperties(size=fontsize)\n            else:\n                self.prop = FontProperties(size=rcParams[\"legend.fontsize\"])\n        elif isinstance(prop, dict):\n            self.prop = FontProperties(**prop)\n            if \"size\" not in prop:\n                self.prop.set_size(rcParams[\"legend.fontsize\"])\n        else:\n            self.prop = prop\n\n        self._fontsize = self.prop.get_size_in_points()\n\n        self.texts = []\n        self.legendHandles = []\n        self._legend_title_box = None\n\n        #: A dictionary with the extra handler mappings for this Legend\n        #: instance.\n        self._custom_handler_map = handler_map\n\n        locals_view = locals()\n        for name in [\"numpoints\", \"markerscale\", \"shadow\", \"columnspacing\",\n                     \"scatterpoints\", \"handleheight\", 'borderpad',\n                     'labelspacing', 'handlelength', 'handletextpad',\n                     'borderaxespad']:\n            if locals_view[name] is None:\n                value = rcParams[\"legend.\" + name]\n            else:\n                value = locals_view[name]\n            setattr(self, name, value)\n        del locals_view\n        # trim handles and labels if illegal label...\n        _lab, _hand = [], []\n        for label, handle in zip(labels, handles):\n            if isinstance(label, str) and label.startswith('_'):\n                cbook._warn_external('The handle {!r} has a label of {!r} '\n                                     'which cannot be automatically added to'\n                                     ' the legend.'.format(handle, label))\n            else:\n                _lab.append(label)\n                _hand.append(handle)\n        labels, handles = _lab, _hand\n\n        handles = list(handles)\n        if len(handles) < 2:\n            ncol = 1\n        self._ncol = ncol\n\n        if self.numpoints <= 0:\n            raise ValueError(\"numpoints must be > 0; it was %d\" % numpoints)\n\n        # introduce y-offset for handles of the scatter plot\n        if scatteryoffsets is None:\n            self._scatteryoffsets = np.array([3. / 8., 4. / 8., 2.5 / 8.])\n        else:\n            self._scatteryoffsets = np.asarray(scatteryoffsets)\n        reps = self.scatterpoints // len(self._scatteryoffsets) + 1\n        self._scatteryoffsets = np.tile(self._scatteryoffsets,\n                                        reps)[:self.scatterpoints]\n\n        # _legend_box is an OffsetBox instance that contains all\n        # legend items and will be initialized from _init_legend_box()\n        # method.\n        self._legend_box = None\n\n        if isinstance(parent, Axes):\n            self.isaxes = True\n            self.axes = parent\n            self.set_figure(parent.figure)\n        elif isinstance(parent, Figure):\n            self.isaxes = False\n            self.set_figure(parent)\n        else:\n            raise TypeError(\"Legend needs either Axes or Figure as parent\")\n        self.parent = parent\n\n        self._loc_used_default = loc is None\n        if loc is None:\n            loc = rcParams[\"legend.loc\"]\n            if not self.isaxes and loc in [0, 'best']:\n                loc = 'upper right'\n        if isinstance(loc, str):\n            if loc not in self.codes:\n                if self.isaxes:\n                    cbook.warn_deprecated(\n                        \"3.1\", message=\"Unrecognized location {!r}. Falling \"\n                        \"back on 'best'; valid locations are\\n\\t{}\\n\"\n                        \"This will raise an exception %(removal)s.\"\n                        .format(loc, '\\n\\t'.join(self.codes)))\n                    loc = 0\n                else:\n                    cbook.warn_deprecated(\n                        \"3.1\", message=\"Unrecognized location {!r}. Falling \"\n                        \"back on 'upper right'; valid locations are\\n\\t{}\\n'\"\n                        \"This will raise an exception %(removal)s.\"\n                        .format(loc, '\\n\\t'.join(self.codes)))\n                    loc = 1\n            else:\n                loc = self.codes[loc]\n        if not self.isaxes and loc == 0:\n            cbook.warn_deprecated(\n                \"3.1\", message=\"Automatic legend placement (loc='best') not \"\n                \"implemented for figure legend. Falling back on 'upper \"\n                \"right'. This will raise an exception %(removal)s.\")\n            loc = 1\n\n        self._mode = mode\n        self.set_bbox_to_anchor(bbox_to_anchor, bbox_transform)\n\n        # We use FancyBboxPatch to draw a legend frame. The location\n        # and size of the box will be updated during the drawing time.\n\n        if facecolor is None:\n            facecolor = rcParams[\"legend.facecolor\"]\n        if facecolor == 'inherit':\n            facecolor = rcParams[\"axes.facecolor\"]\n\n        if edgecolor is None:\n            edgecolor = rcParams[\"legend.edgecolor\"]\n        if edgecolor == 'inherit':\n            edgecolor = rcParams[\"axes.edgecolor\"]\n\n        self.legendPatch = FancyBboxPatch(\n            xy=(0.0, 0.0), width=1., height=1.,\n            facecolor=facecolor,\n            edgecolor=edgecolor,\n            mutation_scale=self._fontsize,\n            snap=True\n            )\n\n        # The width and height of the legendPatch will be set (in the\n        # draw()) to the length that includes the padding. Thus we set\n        # pad=0 here.\n        if fancybox is None:\n            fancybox = rcParams[\"legend.fancybox\"]\n\n        if fancybox:\n            self.legendPatch.set_boxstyle(\"round\", pad=0,\n                                          rounding_size=0.2)\n        else:\n            self.legendPatch.set_boxstyle(\"square\", pad=0)\n\n        self._set_artist_props(self.legendPatch)\n\n        self._drawFrame = frameon\n        if frameon is None:\n            self._drawFrame = rcParams[\"legend.frameon\"]\n\n        # init with null renderer\n        self._init_legend_box(handles, labels, markerfirst)\n\n        # If shadow is activated use framealpha if not\n        # explicitly passed. See Issue 8943\n        if framealpha is None:\n            if shadow:\n                self.get_frame().set_alpha(1)\n            else:\n                self.get_frame().set_alpha(rcParams[\"legend.framealpha\"])\n        else:\n            self.get_frame().set_alpha(framealpha)\n\n        tmp = self._loc_used_default\n        self._set_loc(loc)\n        self._loc_used_default = tmp  # ignore changes done by _set_loc\n\n        # figure out title fontsize:\n        if title_fontsize is None:\n            title_fontsize = rcParams['legend.title_fontsize']\n        tprop = FontProperties(size=title_fontsize)\n        self.set_title(title, prop=tprop)\n        self._draggable = None",
        "begin_line": 307,
        "end_line": 556,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002584647195657793,
            "pseudo_dstar_susp": 0.00026096033402922753,
            "pseudo_tarantula_susp": 0.00023185717597959656,
            "pseudo_op2_susp": 0.00026096033402922753,
            "pseudo_barinel_susp": 0.00023185717597959656
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend._set_loc#569",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend._set_loc(self, loc)",
        "snippet": "    def _set_loc(self, loc):\n        # find_offset function will be provided to _legend_box and\n        # _legend_box will draw itself at the location of the return\n        # value of the find_offset.\n        self._loc_used_default = False\n        self._loc_real = loc\n        self.stale = True\n        self._legend_box.set_offset(self._findoffset)",
        "begin_line": 569,
        "end_line": 576,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002460024600246002,
            "pseudo_dstar_susp": 0.00024390243902439024,
            "pseudo_tarantula_susp": 0.00030826140567200987,
            "pseudo_op2_susp": 0.00024390243902439024,
            "pseudo_barinel_susp": 0.00030826140567200987
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend.draw#601",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        \"Draw everything that belongs to the legend.\"\n        if not self.get_visible():\n            return\n\n        renderer.open_group('legend', gid=self.get_gid())\n\n        fontsize = renderer.points_to_pixels(self._fontsize)\n\n        # if mode == fill, set the width of the legend_box to the\n        # width of the parent (minus pads)\n        if self._mode in [\"expand\"]:\n            pad = 2 * (self.borderaxespad + self.borderpad) * fontsize\n            self._legend_box.set_width(self.get_bbox_to_anchor().width - pad)\n\n        # update the location and size of the legend. This needs to\n        # be done in any case to clip the figure right.\n        bbox = self._legend_box.get_window_extent(renderer)\n        self.legendPatch.set_bounds(bbox.x0, bbox.y0,\n                                    bbox.width, bbox.height)\n        self.legendPatch.set_mutation_scale(fontsize)\n\n        if self._drawFrame:\n            if self.shadow:\n                shadow = Shadow(self.legendPatch, 2, -2)\n                shadow.draw(renderer)\n\n            self.legendPatch.draw(renderer)\n\n        self._legend_box.draw(renderer)\n\n        renderer.close_group('legend')\n        self.stale = False",
        "begin_line": 601,
        "end_line": 633,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00031436655139893113,
            "pseudo_dstar_susp": 0.0002605523710265763,
            "pseudo_tarantula_susp": 0.0003952569169960474,
            "pseudo_op2_susp": 0.0002605523710265763,
            "pseudo_barinel_susp": 0.0003952569169960474
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend.get_legend_handler#702",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend.get_legend_handler(legend_handler_map, orig_handle)",
        "snippet": "    def get_legend_handler(legend_handler_map, orig_handle):\n        \"\"\"\n        Return a legend handler from *legend_handler_map* that\n        corresponds to *orig_handler*.\n\n        *legend_handler_map* should be a dictionary object (that is\n        returned by the get_legend_handler_map method).\n\n        It first checks if the *orig_handle* itself is a key in the\n        *legend_handler_map* and return the associated value.\n        Otherwise, it checks for each of the classes in its\n        method-resolution-order. If no matching key is found, it\n        returns ``None``.\n        \"\"\"\n        try:\n            return legend_handler_map[orig_handle]\n        except (TypeError, KeyError):  # TypeError if unhashable.\n            pass\n        for handle_type in type(orig_handle).mro():\n            try:\n                return legend_handler_map[handle_type]\n            except KeyError:\n                pass\n        return None",
        "begin_line": 702,
        "end_line": 725,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002387774594078319,
            "pseudo_dstar_susp": 0.00024015369836695484,
            "pseudo_tarantula_susp": 0.00023089355806972986,
            "pseudo_op2_susp": 0.00024015369836695484,
            "pseudo_barinel_susp": 0.00023089355806972986
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend._init_legend_box#727",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend._init_legend_box(self, handles, labels, markerfirst=True)",
        "snippet": "    def _init_legend_box(self, handles, labels, markerfirst=True):\n        \"\"\"\n        Initialize the legend_box. The legend_box is an instance of\n        the OffsetBox, which is packed with legend handles and\n        texts. Once packed, their location is calculated during the\n        drawing time.\n        \"\"\"\n\n        fontsize = self._fontsize\n\n        # legend_box is a HPacker, horizontally packed with\n        # columns. Each column is a VPacker, vertically packed with\n        # legend items. Each legend item is HPacker packed with\n        # legend handleBox and labelBox. handleBox is an instance of\n        # offsetbox.DrawingArea which contains legend handle. labelBox\n        # is an instance of offsetbox.TextArea which contains legend\n        # text.\n\n        text_list = []  # the list of text instances\n        handle_list = []  # the list of text instances\n        handles_and_labels = []\n\n        label_prop = dict(verticalalignment='baseline',\n                          horizontalalignment='left',\n                          fontproperties=self.prop,\n                          )\n\n        # The approximate height and descent of text. These values are\n        # only used for plotting the legend handle.\n        descent = 0.35 * self._approx_text_height() * (self.handleheight - 0.7)\n        # 0.35 and 0.7 are just heuristic numbers and may need to be improved.\n        height = self._approx_text_height() * self.handleheight - descent\n        # each handle needs to be drawn inside a box of (x, y, w, h) =\n        # (0, -descent, width, height).  And their coordinates should\n        # be given in the display coordinates.\n\n        # The transformation of each handle will be automatically set\n        # to self.get_transform(). If the artist does not use its\n        # default transform (e.g., Collections), you need to\n        # manually set their transform to the self.get_transform().\n        legend_handler_map = self.get_legend_handler_map()\n\n        for orig_handle, lab in zip(handles, labels):\n            handler = self.get_legend_handler(legend_handler_map, orig_handle)\n            if handler is None:\n                cbook._warn_external(\n                    \"Legend does not support {!r} instances.\\nA proxy artist \"\n                    \"may be used instead.\\nSee: \"\n                    \"http://matplotlib.org/users/legend_guide.html\"\n                    \"#creating-artists-specifically-for-adding-to-the-legend-\"\n                    \"aka-proxy-artists\".format(orig_handle))\n                # We don't have a handle for this artist, so we just defer\n                # to None.\n                handle_list.append(None)\n            else:\n                textbox = TextArea(lab, textprops=label_prop,\n                                   multilinebaseline=True,\n                                   minimumdescent=True)\n                handlebox = DrawingArea(width=self.handlelength * fontsize,\n                                        height=height,\n                                        xdescent=0., ydescent=descent)\n\n                text_list.append(textbox._text)\n                # Create the artist for the legend which represents the\n                # original artist/handle.\n                handle_list.append(handler.legend_artist(self, orig_handle,\n                                                         fontsize, handlebox))\n                handles_and_labels.append((handlebox, textbox))\n\n        if handles_and_labels:\n            # We calculate number of rows in each column. The first\n            # (num_largecol) columns will have (nrows+1) rows, and remaining\n            # (num_smallcol) columns will have (nrows) rows.\n            ncol = min(self._ncol, len(handles_and_labels))\n            nrows, num_largecol = divmod(len(handles_and_labels), ncol)\n            num_smallcol = ncol - num_largecol\n            # starting index of each column and number of rows in it.\n            rows_per_col = [nrows + 1] * num_largecol + [nrows] * num_smallcol\n            start_idxs = np.concatenate([[0], np.cumsum(rows_per_col)[:-1]])\n            cols = zip(start_idxs, rows_per_col)\n        else:\n            cols = []\n\n        columnbox = []\n        for i0, di in cols:\n            # pack handleBox and labelBox into itemBox\n            itemBoxes = [HPacker(pad=0,\n                                 sep=self.handletextpad * fontsize,\n                                 children=[h, t] if markerfirst else [t, h],\n                                 align=\"baseline\")\n                         for h, t in handles_and_labels[i0:i0 + di]]\n            # minimumdescent=False for the text of the last row of the column\n            if markerfirst:\n                itemBoxes[-1].get_children()[1].set_minimumdescent(False)\n            else:\n                itemBoxes[-1].get_children()[0].set_minimumdescent(False)\n\n            # pack columnBox\n            alignment = \"baseline\" if markerfirst else \"right\"\n            columnbox.append(VPacker(pad=0,\n                                     sep=self.labelspacing * fontsize,\n                                     align=alignment,\n                                     children=itemBoxes))\n\n        mode = \"expand\" if self._mode == \"expand\" else \"fixed\"\n        sep = self.columnspacing * fontsize\n        self._legend_handle_box = HPacker(pad=0,\n                                          sep=sep, align=\"baseline\",\n                                          mode=mode,\n                                          children=columnbox)\n        self._legend_title_box = TextArea(\"\")\n        self._legend_box = VPacker(pad=self.borderpad * fontsize,\n                                   sep=self.labelspacing * fontsize,\n                                   align=\"center\",\n                                   children=[self._legend_title_box,\n                                             self._legend_handle_box])\n        self._legend_box.set_figure(self.figure)\n        self.texts = text_list\n        self.legendHandles = handle_list",
        "begin_line": 727,
        "end_line": 845,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002460024600246002,
            "pseudo_dstar_susp": 0.00024390243902439024,
            "pseudo_tarantula_susp": 0.00023380874444704232,
            "pseudo_op2_susp": 0.00024390243902439024,
            "pseudo_barinel_susp": 0.00023380874444704232
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend._auto_legend_data#847",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend._auto_legend_data(self)",
        "snippet": "    def _auto_legend_data(self):\n        \"\"\"\n        Returns list of vertices and extents covered by the plot.\n\n        Returns a two long list.\n\n        First element is a list of (x, y) vertices (in\n        display-coordinates) covered by all the lines and line\n        collections, in the legend's handles.\n\n        Second element is a list of bounding boxes for all the patches in\n        the legend's handles.\n        \"\"\"\n        # should always hold because function is only called internally\n        assert self.isaxes\n\n        ax = self.parent\n        bboxes = []\n        lines = []\n        offsets = []\n\n        for handle in ax.lines:\n            assert isinstance(handle, Line2D)\n            path = handle.get_path()\n            trans = handle.get_transform()\n            tpath = trans.transform_path(path)\n            lines.append(tpath)\n\n        for handle in ax.patches:\n            assert isinstance(handle, Patch)\n\n            if isinstance(handle, Rectangle):\n                transform = handle.get_data_transform()\n                bboxes.append(handle.get_bbox().transformed(transform))\n            else:\n                transform = handle.get_transform()\n                bboxes.append(handle.get_path().get_extents(transform))\n\n        for handle in ax.collections:\n            transform, transOffset, hoffsets, paths = handle._prepare_points()\n\n            if len(hoffsets):\n                for offset in transOffset.transform(hoffsets):\n                    offsets.append(offset)\n\n        try:\n            vertices = np.concatenate([l.vertices for l in lines])\n        except ValueError:\n            vertices = np.array([])\n\n        return [vertices, bboxes, lines, offsets]",
        "begin_line": 847,
        "end_line": 897,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022851919561243144,
            "pseudo_dstar_susp": 0.0002007628990162618,
            "pseudo_tarantula_susp": 0.00035323207347227127,
            "pseudo_op2_susp": 0.0002007628990162618,
            "pseudo_barinel_susp": 0.00035323207347227127
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend.get_frame#918",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend.get_frame(self)",
        "snippet": "    def get_frame(self):\n        '''\n        Return the `~.patches.Rectangle` instances used to frame the legend.\n        '''\n        return self.legendPatch",
        "begin_line": 918,
        "end_line": 922,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019916351324437363,
            "pseudo_dstar_susp": 0.00016353229762878168,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00016353229762878168,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend.get_bbox_to_anchor#999",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend.get_bbox_to_anchor(self)",
        "snippet": "    def get_bbox_to_anchor(self):\n        \"\"\"Return the bbox that the legend will be anchored to.\"\"\"\n        if self._bbox_to_anchor is None:\n            return self.parent.bbox\n        else:\n            return self._bbox_to_anchor",
        "begin_line": 999,
        "end_line": 1004,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00021734405564007825,
            "pseudo_dstar_susp": 0.00018102824040550325,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.00018102824040550325,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend.set_bbox_to_anchor#1006",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend.set_bbox_to_anchor(self, bbox, transform=None)",
        "snippet": "    def set_bbox_to_anchor(self, bbox, transform=None):\n        \"\"\"\n        Set the bbox that the legend will be anchored to.\n\n        *bbox* can be\n\n        - A `.BboxBase` instance\n        - A tuple of ``(left, bottom, width, height)`` in the given transform\n          (normalized axes coordinate if None)\n        - A tuple of ``(left, bottom)`` where the width and height will be\n          assumed to be zero.\n        \"\"\"\n        if bbox is None:\n            self._bbox_to_anchor = None\n            return\n        elif isinstance(bbox, BboxBase):\n            self._bbox_to_anchor = bbox\n        else:\n            try:\n                l = len(bbox)\n            except TypeError:\n                raise ValueError(\"Invalid argument for bbox : %s\" % str(bbox))\n\n            if l == 2:\n                bbox = [bbox[0], bbox[1], 0, 0]\n\n            self._bbox_to_anchor = Bbox.from_bounds(*bbox)\n\n        if transform is None:\n            transform = BboxTransformTo(self.parent.bbox)\n\n        self._bbox_to_anchor = TransformedBbox(self._bbox_to_anchor,\n                                               transform)\n        self.stale = True",
        "begin_line": 1006,
        "end_line": 1039,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00018053800324968405,
            "pseudo_dstar_susp": 0.0001529987760097919,
            "pseudo_tarantula_susp": 0.0003450655624568668,
            "pseudo_op2_susp": 0.0001529987760097919,
            "pseudo_barinel_susp": 0.00034494653328734045
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend._get_anchored_bbox#1041",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend._get_anchored_bbox(self, loc, bbox, parentbbox, renderer)",
        "snippet": "    def _get_anchored_bbox(self, loc, bbox, parentbbox, renderer):\n        \"\"\"\n        Place the *bbox* inside the *parentbbox* according to a given\n        location code. Return the (x, y) coordinate of the bbox.\n\n        - loc: a location code in range(1, 11).\n          This corresponds to the possible values for self._loc, excluding\n          \"best\".\n\n        - bbox: bbox to be placed, display coordinate units.\n        - parentbbox: a parent box which will contain the bbox. In\n            display coordinates.\n        \"\"\"\n        assert loc in range(1, 11)  # called only internally\n\n        BEST, UR, UL, LL, LR, R, CL, CR, LC, UC, C = range(11)\n\n        anchor_coefs = {UR: \"NE\",\n                        UL: \"NW\",\n                        LL: \"SW\",\n                        LR: \"SE\",\n                        R: \"E\",\n                        CL: \"W\",\n                        CR: \"E\",\n                        LC: \"S\",\n                        UC: \"N\",\n                        C: \"C\"}\n\n        c = anchor_coefs[loc]\n\n        fontsize = renderer.points_to_pixels(self._fontsize)\n        container = parentbbox.padded(-(self.borderaxespad) * fontsize)\n        anchored_box = bbox.anchored(c, container=container)\n        return anchored_box.x0, anchored_box.y0",
        "begin_line": 1041,
        "end_line": 1074,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003160556257901391,
            "pseudo_dstar_susp": 0.00027085590465872155,
            "pseudo_tarantula_susp": 0.00039635354736424893,
            "pseudo_op2_susp": 0.00027085590465872155,
            "pseudo_barinel_susp": 0.00039635354736424893
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend._find_best_position#1076",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend._find_best_position(self, width, height, renderer, consider=None)",
        "snippet": "    def _find_best_position(self, width, height, renderer, consider=None):\n        \"\"\"\n        Determine the best location to place the legend.\n\n        *consider* is a list of ``(x, y)`` pairs to consider as a potential\n        lower-left corner of the legend. All are display coords.\n        \"\"\"\n        # should always hold because function is only called internally\n        assert self.isaxes\n\n        start_time = time.perf_counter()\n\n        verts, bboxes, lines, offsets = self._auto_legend_data()\n\n        bbox = Bbox.from_bounds(0, 0, width, height)\n        if consider is None:\n            consider = [self._get_anchored_bbox(x, bbox,\n                                                self.get_bbox_to_anchor(),\n                                                renderer)\n                        for x in range(1, len(self.codes))]\n\n        candidates = []\n        for idx, (l, b) in enumerate(consider):\n            legendBox = Bbox.from_bounds(l, b, width, height)\n            badness = 0\n            # XXX TODO: If markers are present, it would be good to\n            # take them into account when checking vertex overlaps in\n            # the next line.\n            badness = (legendBox.count_contains(verts)\n                       + legendBox.count_contains(offsets)\n                       + legendBox.count_overlaps(bboxes)\n                       + sum(line.intersects_bbox(legendBox, filled=False)\n                             for line in lines))\n            if badness == 0:\n                return l, b\n            # Include the index to favor lower codes in case of a tie.\n            candidates.append((badness, idx, (l, b)))\n\n        _, _, (l, b) = min(candidates)\n\n        if self._loc_used_default and time.perf_counter() - start_time > 1:\n            cbook._warn_external(\n                'Creating legend with loc=\"best\" can be slow with large '\n                'amounts of data.')\n\n        return l, b",
        "begin_line": 1076,
        "end_line": 1121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00022851919561243144,
            "pseudo_dstar_susp": 0.0002007628990162618,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0002007628990162618,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend.set_draggable#1129",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend.set_draggable(self, state, use_blit=False, update='loc')",
        "snippet": "    def set_draggable(self, state, use_blit=False, update='loc'):\n        \"\"\"\n        Enable or disable mouse dragging support of the legend.\n\n        Parameters\n        ----------\n        state : bool\n            Whether mouse dragging is enabled.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            The legend parameter to be changed when dragged:\n\n            - 'loc': update the *loc* parameter of the legend\n            - 'bbox': update the *bbox_to_anchor* parameter of the legend\n\n        Returns\n        -------\n        If *state* is ``True`` this returns the `~.DraggableLegend` helper\n        instance. Otherwise this returns ``None``.\n        \"\"\"\n        if state:\n            if self._draggable is None:\n                self._draggable = DraggableLegend(self,\n                                                  use_blit,\n                                                  update=update)\n        else:\n            if self._draggable is not None:\n                self._draggable.disconnect()\n            self._draggable = None\n        return self._draggable",
        "begin_line": 1129,
        "end_line": 1160,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 9.058791557206268e-05,
            "pseudo_dstar_susp": 9.058791557206268e-05,
            "pseudo_tarantula_susp": 9.058791557206268e-05,
            "pseudo_op2_susp": 0.00010459156991946449,
            "pseudo_barinel_susp": 9.058791557206268e-05
        }
    },
    {
        "name": "lib.matplotlib.legend._get_legend_handles#1169",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend",
        "signature": "lib.matplotlib.legend._get_legend_handles(axs, legend_handler_map=None)",
        "snippet": "def _get_legend_handles(axs, legend_handler_map=None):\n    \"\"\"\n    Return a generator of artists that can be used as handles in\n    a legend.\n\n    \"\"\"\n    handles_original = []\n    for ax in axs:\n        handles_original += (ax.lines + ax.patches +\n                             ax.collections + ax.containers)\n        # support parasite axes:\n        if hasattr(ax, 'parasites'):\n            for axx in ax.parasites:\n                handles_original += (axx.lines + axx.patches +\n                                     axx.collections + axx.containers)\n\n    handler_map = Legend.get_default_handler_map()\n\n    if legend_handler_map is not None:\n        handler_map = handler_map.copy()\n        handler_map.update(legend_handler_map)\n\n    has_handler = Legend.get_legend_handler\n\n    for handle in handles_original:\n        label = handle.get_label()\n        if label != '_nolegend_' and has_handler(handler_map, handle):\n            yield handle",
        "begin_line": 1169,
        "end_line": 1196,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002537427048972342,
            "pseudo_dstar_susp": 0.00025799793601651185,
            "pseudo_tarantula_susp": 0.0002501250625312656,
            "pseudo_op2_susp": 0.00025799793601651185,
            "pseudo_barinel_susp": 0.0002501250625312656
        }
    },
    {
        "name": "lib.matplotlib.legend._get_legend_handles_labels#1199",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend",
        "signature": "lib.matplotlib.legend._get_legend_handles_labels(axs, legend_handler_map=None)",
        "snippet": "def _get_legend_handles_labels(axs, legend_handler_map=None):\n    \"\"\"\n    Return handles and labels for legend, internal method.\n\n    \"\"\"\n    handles = []\n    labels = []\n\n    for handle in _get_legend_handles(axs, legend_handler_map):\n        label = handle.get_label()\n        if label and not label.startswith('_'):\n            handles.append(handle)\n            labels.append(label)\n    return handles, labels",
        "begin_line": 1199,
        "end_line": 1212,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00024906600249066,
            "pseudo_dstar_susp": 0.00024826216484607745,
            "pseudo_tarantula_susp": 0.00023348120476301658,
            "pseudo_op2_susp": 0.00024826216484607745,
            "pseudo_barinel_susp": 0.00023348120476301658
        }
    },
    {
        "name": "lib.matplotlib.legend._parse_legend_args#1215",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend",
        "signature": "lib.matplotlib.legend._parse_legend_args(axs, *args, handles=None, labels=None, **kwargs)",
        "snippet": "def _parse_legend_args(axs, *args, handles=None, labels=None, **kwargs):\n    \"\"\"\n    Get the handles and labels from the calls to either ``figure.legend``\n    or ``axes.legend``.\n\n    ``axs`` is a list of axes (to get legend artists from)\n    \"\"\"\n    log = logging.getLogger(__name__)\n\n    handlers = kwargs.get('handler_map', {}) or {}\n    extra_args = ()\n\n    if (handles is not None or labels is not None) and args:\n        cbook._warn_external(\"You have mixed positional and keyword \"\n                             \"arguments, some input may be discarded.\")\n\n    # if got both handles and labels as kwargs, make same length\n    if handles and labels:\n        handles, labels = zip(*zip(handles, labels))\n\n    elif handles is not None and labels is None:\n        labels = [handle.get_label() for handle in handles]\n\n    elif labels is not None and handles is None:\n        # Get as many handles as there are labels.\n        handles = [handle for handle, label\n                   in zip(_get_legend_handles(axs, handlers), labels)]\n\n    # No arguments - automatically detect labels and handles.\n    elif len(args) == 0:\n        handles, labels = _get_legend_handles_labels(axs, handlers)\n        if not handles:\n            log.warning('No handles with labels found to put in legend.')\n\n    # One argument. User defined labels - automatic handle detection.\n    elif len(args) == 1:\n        labels, = args\n        # Get as many handles as there are labels.\n        handles = [handle for handle, label\n                   in zip(_get_legend_handles(axs, handlers), labels)]\n\n    # Two arguments:\n    #   * user defined handles and labels\n    elif len(args) >= 2:\n        handles, labels = args[:2]\n        extra_args = args[2:]\n\n    else:\n        raise TypeError('Invalid arguments to legend.')\n\n    return handles, labels, extra_args, kwargs",
        "begin_line": 1215,
        "end_line": 1265,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00025006251562890725,
            "pseudo_dstar_susp": 0.0002646202699126753,
            "pseudo_tarantula_susp": 0.0004280821917808219,
            "pseudo_op2_susp": 0.0002646202699126753,
            "pseudo_barinel_susp": 0.0004280821917808219
        }
    }
]