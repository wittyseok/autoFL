[
    {
        "name": "tests.keras.layers.convolutional_test.test_causal_dilated_conv#39",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_causal_dilated_conv(layer_kwargs, input_length, expected_output)",
        "snippet": "def test_causal_dilated_conv(layer_kwargs, input_length, expected_output):\n    input_data = np.reshape(np.arange(input_length, dtype='float32'),\n                            (1, input_length, 1))\n    layer_test(convolutional.Conv1D, input_data=input_data,\n               kwargs=layer_kwargs, expected_output=expected_output)",
        "begin_line": 39,
        "end_line": 43,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_conv_1d#54",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_conv_1d(padding, strides)",
        "snippet": "def test_conv_1d(padding, strides):\n    batch_size = 2\n    steps = 8\n    input_dim = 2\n    kernel_size = 3\n    filters = 3\n\n    layer_test(convolutional.Conv1D,\n               kwargs={'filters': filters,\n                       'kernel_size': kernel_size,\n                       'padding': padding,\n                       'strides': strides},\n               input_shape=(batch_size, steps, input_dim))\n\n    layer_test(convolutional.Conv1D,\n               kwargs={'filters': filters,\n                       'kernel_size': kernel_size,\n                       'padding': padding,\n                       'kernel_regularizer': 'l2',\n                       'bias_regularizer': 'l2',\n                       'activity_regularizer': 'l2',\n                       'kernel_constraint': 'max_norm',\n                       'bias_constraint': 'max_norm',\n                       'strides': strides},\n               input_shape=(batch_size, steps, input_dim))",
        "begin_line": 54,
        "end_line": 78,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_conv_1d_dilation#84",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_conv_1d_dilation()",
        "snippet": "def test_conv_1d_dilation():\n    batch_size = 2\n    steps = 8\n    input_dim = 2\n    kernel_size = 3\n    filters = 3\n    padding = _convolution_paddings[-1]\n\n    layer_test(convolutional.Conv1D,\n               kwargs={'filters': filters,\n                       'kernel_size': kernel_size,\n                       'padding': padding,\n                       'dilation_rate': 2},\n               input_shape=(batch_size, steps, input_dim))",
        "begin_line": 84,
        "end_line": 97,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_conv_1d_channels_first#101",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_conv_1d_channels_first()",
        "snippet": "def test_conv_1d_channels_first():\n    batch_size = 2\n    steps = 8\n    input_dim = 2\n    kernel_size = 3\n    filters = 3\n\n    layer_test(convolutional.Conv1D,\n               kwargs={'filters': filters,\n                       'kernel_size': kernel_size,\n                       'data_format': 'channels_first'},\n               input_shape=(batch_size, input_dim, steps))",
        "begin_line": 101,
        "end_line": 112,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_convolution_2d#123",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_convolution_2d(strides, padding)",
        "snippet": "def test_convolution_2d(strides, padding):\n    num_samples = 2\n    filters = 2\n    stack_size = 3\n    kernel_size = (3, 2)\n    num_row = 7\n    num_col = 6\n\n    layer_test(convolutional.Conv2D,\n               kwargs={'filters': filters,\n                       'kernel_size': kernel_size,\n                       'padding': padding,\n                       'strides': strides,\n                       'data_format': 'channels_first'},\n               input_shape=(num_samples, stack_size, num_row, num_col))",
        "begin_line": 123,
        "end_line": 137,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_convolution_2d_channels_last#141",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_convolution_2d_channels_last()",
        "snippet": "def test_convolution_2d_channels_last():\n    num_samples = 2\n    filters = 2\n    stack_size = 3\n    num_row = 7\n    num_col = 6\n    padding = 'valid'\n    strides = (2, 2)\n\n    layer_test(convolutional.Conv2D,\n               kwargs={'filters': filters,\n                       'kernel_size': 3,\n                       'padding': padding,\n                       'data_format': 'channels_last',\n                       'activation': None,\n                       'kernel_regularizer': 'l2',\n                       'bias_regularizer': 'l2',\n                       'activity_regularizer': 'l2',\n                       'kernel_constraint': 'max_norm',\n                       'bias_constraint': 'max_norm',\n                       'strides': strides},\n               input_shape=(num_samples, num_row, num_col, stack_size))",
        "begin_line": 141,
        "end_line": 162,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_convolution_2d_dilation#168",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_convolution_2d_dilation()",
        "snippet": "def test_convolution_2d_dilation():\n    num_samples = 2\n    filters = 2\n    stack_size = 3\n    kernel_size = (3, 2)\n    num_row = 7\n    num_col = 6\n    padding = 'valid'\n\n    # Test dilation\n    if K.backend() != 'cntk':\n        # cntk only support dilated conv on GPU\n        layer_test(convolutional.Conv2D,\n                   kwargs={'filters': filters,\n                           'kernel_size': kernel_size,\n                           'padding': padding,\n                           'dilation_rate': (2, 2)},\n                   input_shape=(num_samples, num_row, num_col, stack_size))",
        "begin_line": 168,
        "end_line": 185,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_convolution_2d_invalid#189",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_convolution_2d_invalid()",
        "snippet": "def test_convolution_2d_invalid():\n    filters = 2\n    padding = _convolution_paddings[-1]\n    kernel_size = (3, 2)\n\n    with pytest.raises(ValueError):\n        model = Sequential([convolutional.Conv2D(\n            filters=filters, kernel_size=kernel_size, padding=padding,\n            batch_input_shape=(None, None, 5, None))])",
        "begin_line": 189,
        "end_line": 197,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_conv2d_transpose#210",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_conv2d_transpose(padding, out_padding, strides)",
        "snippet": "def test_conv2d_transpose(padding, out_padding, strides):\n    num_samples = 2\n    filters = 2\n    stack_size = 3\n    num_row = 5\n    num_col = 6\n\n    layer_test(convolutional.Conv2DTranspose,\n               kwargs={'filters': filters,\n                       'kernel_size': 3,\n                       'padding': padding,\n                       'output_padding': out_padding,\n                       'strides': strides,\n                       'data_format': 'channels_last'},\n               input_shape=(num_samples, num_row, num_col, stack_size),\n               fixed_batch_size=True)",
        "begin_line": 210,
        "end_line": 225,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_conv2d_transpose_dilation#231",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_conv2d_transpose_dilation()",
        "snippet": "def test_conv2d_transpose_dilation():\n\n    layer_test(convolutional.Conv2DTranspose,\n               kwargs={'filters': 2,\n                       'kernel_size': 3,\n                       'padding': 'same',\n                       'data_format': 'channels_last',\n                       'dilation_rate': (2, 2)},\n               input_shape=(2, 5, 6, 3))\n\n    # Check dilated conv transpose returns expected output\n    input_data = np.arange(48).reshape((1, 4, 4, 3)).astype(np.float32)\n    expected_output = np.float32([[192, 228, 192, 228],\n                                  [336, 372, 336, 372],\n                                  [192, 228, 192, 228],\n                                  [336, 372, 336, 372]]).reshape((1, 4, 4, 1))\n\n    layer_test(convolutional.Conv2DTranspose,\n               input_data=input_data,\n               kwargs={'filters': 1,\n                       'kernel_size': 3,\n                       'padding': 'same',\n                       'data_format': 'channels_last',\n                       'dilation_rate': (2, 2),\n                       'kernel_initializer': 'ones'},\n               expected_output=expected_output)",
        "begin_line": 231,
        "end_line": 256,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_conv2d_transpose_channels_first#260",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_conv2d_transpose_channels_first()",
        "snippet": "def test_conv2d_transpose_channels_first():\n    num_samples = 2\n    filters = 2\n    stack_size = 3\n    num_row = 5\n    num_col = 6\n    padding = 'valid'\n    strides = (2, 2)\n\n    layer_test(convolutional.Conv2DTranspose,\n               kwargs={'filters': filters,\n                       'kernel_size': 3,\n                       'padding': padding,\n                       'data_format': 'channels_first',\n                       'activation': None,\n                       'kernel_regularizer': 'l2',\n                       'bias_regularizer': 'l2',\n                       'activity_regularizer': 'l2',\n                       'kernel_constraint': 'max_norm',\n                       'bias_constraint': 'max_norm',\n                       'strides': strides},\n               input_shape=(num_samples, stack_size, num_row, num_col),\n               fixed_batch_size=True)",
        "begin_line": 260,
        "end_line": 282,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_conv2d_transpose_invalid#286",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_conv2d_transpose_invalid()",
        "snippet": "def test_conv2d_transpose_invalid():\n    filters = 2\n    stack_size = 3\n    num_row = 5\n    num_col = 6\n    padding = 'valid'\n\n    with pytest.raises(ValueError):\n        model = Sequential([convolutional.Conv2DTranspose(\n            filters=filters,\n            kernel_size=3,\n            padding=padding,\n            use_bias=True,\n            batch_input_shape=(None, None, 5, None))])\n\n    # Test invalid output padding for given stride. Output padding equal to stride\n    with pytest.raises(ValueError):\n        model = Sequential([convolutional.Conv2DTranspose(\n            filters=filters,\n            kernel_size=3,\n            padding=padding,\n            output_padding=(0, 3),\n            strides=(1, 3),\n            batch_input_shape=(None, num_row, num_col, stack_size))])\n\n    # Output padding greater than stride\n    with pytest.raises(ValueError):\n        model = Sequential([convolutional.Conv2DTranspose(\n            filters=filters,\n            kernel_size=3,\n            padding=padding,\n            output_padding=(2, 2),\n            strides=(1, 3),\n            batch_input_shape=(None, num_row, num_col, stack_size))])",
        "begin_line": 286,
        "end_line": 319,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_separable_conv_1d#334",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_separable_conv_1d(padding, strides, multiplier, dilation_rate)",
        "snippet": "def test_separable_conv_1d(padding, strides, multiplier, dilation_rate):\n    num_samples = 2\n    filters = 6\n    stack_size = 3\n    num_step = 9\n\n    layer_test(convolutional.SeparableConv1D,\n               kwargs={'filters': filters,\n                       'kernel_size': 3,\n                       'padding': padding,\n                       'strides': strides,\n                       'depth_multiplier': multiplier,\n                       'dilation_rate': dilation_rate},\n               input_shape=(num_samples, num_step, stack_size))",
        "begin_line": 334,
        "end_line": 347,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_separable_conv_1d_additional_args#351",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_separable_conv_1d_additional_args()",
        "snippet": "def test_separable_conv_1d_additional_args():\n    num_samples = 2\n    filters = 6\n    stack_size = 3\n    num_step = 9\n    padding = 'valid'\n    multiplier = 2\n\n    layer_test(convolutional.SeparableConv1D,\n               kwargs={'filters': filters,\n                       'kernel_size': 3,\n                       'padding': padding,\n                       'data_format': 'channels_first',\n                       'activation': None,\n                       'depthwise_regularizer': 'l2',\n                       'pointwise_regularizer': 'l2',\n                       'bias_regularizer': 'l2',\n                       'activity_regularizer': 'l2',\n                       'pointwise_constraint': 'unit_norm',\n                       'depthwise_constraint': 'unit_norm',\n                       'strides': 1,\n                       'use_bias': True,\n                       'depth_multiplier': multiplier},\n               input_shape=(num_samples, stack_size, num_step))",
        "begin_line": 351,
        "end_line": 374,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_separable_conv_1d_invalid#378",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_separable_conv_1d_invalid()",
        "snippet": "def test_separable_conv_1d_invalid():\n    filters = 6\n    padding = 'valid'\n    with pytest.raises(ValueError):\n        model = Sequential([convolutional.SeparableConv1D(\n            filters=filters, kernel_size=3, padding=padding,\n            batch_input_shape=(None, 5, None))])",
        "begin_line": 378,
        "end_line": 384,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_separable_conv_2d#400",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_separable_conv_2d(padding, strides, multiplier, dilation_rate)",
        "snippet": "def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):\n    num_samples = 2\n    filters = 6\n    stack_size = 3\n    num_row = 7\n    num_col = 6\n\n    layer_test(\n        convolutional.SeparableConv2D,\n        kwargs={'filters': filters,\n                'kernel_size': (3, 3),\n                'padding': padding,\n                'strides': strides,\n                'depth_multiplier': multiplier,\n                'dilation_rate': dilation_rate},\n        input_shape=(num_samples, num_row, num_col, stack_size))",
        "begin_line": 400,
        "end_line": 415,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_separable_conv_2d_additional_args#419",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_separable_conv_2d_additional_args()",
        "snippet": "def test_separable_conv_2d_additional_args():\n    num_samples = 2\n    filters = 6\n    stack_size = 3\n    num_row = 7\n    num_col = 6\n    padding = 'valid'\n    strides = (2, 2)\n    multiplier = 2\n\n    layer_test(convolutional.SeparableConv2D,\n               kwargs={'filters': filters,\n                       'kernel_size': 3,\n                       'padding': padding,\n                       'data_format': 'channels_first',\n                       'activation': None,\n                       'depthwise_regularizer': 'l2',\n                       'pointwise_regularizer': 'l2',\n                       'bias_regularizer': 'l2',\n                       'activity_regularizer': 'l2',\n                       'pointwise_constraint': 'unit_norm',\n                       'depthwise_constraint': 'unit_norm',\n                       'strides': strides,\n                       'depth_multiplier': multiplier},\n               input_shape=(num_samples, stack_size, num_row, num_col))",
        "begin_line": 419,
        "end_line": 443,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_separable_conv_2d_invalid#447",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_separable_conv_2d_invalid()",
        "snippet": "def test_separable_conv_2d_invalid():\n    filters = 6\n    padding = 'valid'\n    with pytest.raises(ValueError):\n        model = Sequential([convolutional.SeparableConv2D(\n            filters=filters, kernel_size=3, padding=padding,\n            batch_input_shape=(None, None, 5, None))])",
        "begin_line": 447,
        "end_line": 453,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_depthwise_conv_2d#465",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_depthwise_conv_2d(padding, strides, multiplier)",
        "snippet": "def test_depthwise_conv_2d(padding, strides, multiplier):\n    num_samples = 2\n    stack_size = 3\n    num_row = 7\n    num_col = 6\n\n    layer_test(convolutional.DepthwiseConv2D,\n               kwargs={'kernel_size': (3, 3),\n                       'padding': padding,\n                       'strides': strides,\n                       'depth_multiplier': multiplier},\n               input_shape=(num_samples,\n                            num_row,\n                            num_col,\n                            stack_size))",
        "begin_line": 465,
        "end_line": 479,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_depthwise_conv_2d_additional_args#483",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_depthwise_conv_2d_additional_args()",
        "snippet": "def test_depthwise_conv_2d_additional_args():\n    num_samples = 2\n    stack_size = 3\n    num_row = 7\n    num_col = 6\n    padding = 'valid'\n    strides = (2, 2)\n    multiplier = 2\n\n    layer_test(convolutional.DepthwiseConv2D,\n               kwargs={'kernel_size': 3,\n                       'padding': padding,\n                       'data_format': 'channels_first',\n                       'activation': None,\n                       'depthwise_regularizer': 'l2',\n                       'bias_regularizer': 'l2',\n                       'activity_regularizer': 'l2',\n                       'depthwise_constraint': 'unit_norm',\n                       'use_bias': True,\n                       'strides': strides,\n                       'depth_multiplier': multiplier},\n               input_shape=(num_samples, stack_size, num_row, num_col))",
        "begin_line": 483,
        "end_line": 504,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_depthwise_conv_2d_invalid#508",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_depthwise_conv_2d_invalid()",
        "snippet": "def test_depthwise_conv_2d_invalid():\n    padding = 'valid'\n    with pytest.raises(ValueError):\n        Sequential([convolutional.DepthwiseConv2D(\n            kernel_size=3,\n            padding=padding,\n            batch_input_shape=(None, None, 5, None))])",
        "begin_line": 508,
        "end_line": 514,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_convolution_3d#525",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_convolution_3d(padding, strides)",
        "snippet": "def test_convolution_3d(padding, strides):\n    num_samples = 2\n    filters = 2\n    stack_size = 3\n\n    input_len_dim1 = 9\n    input_len_dim2 = 8\n    input_len_dim3 = 8\n\n    layer_test(convolutional.Convolution3D,\n               kwargs={'filters': filters,\n                       'kernel_size': 3,\n                       'padding': padding,\n                       'strides': strides},\n               input_shape=(num_samples,\n                            input_len_dim1, input_len_dim2, input_len_dim3,\n                            stack_size))",
        "begin_line": 525,
        "end_line": 541,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_convolution_3d_additional_args#545",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_convolution_3d_additional_args()",
        "snippet": "def test_convolution_3d_additional_args():\n    num_samples = 2\n    filters = 2\n    stack_size = 3\n    padding = 'valid'\n    strides = (2, 2, 2)\n\n    input_len_dim1 = 9\n    input_len_dim2 = 8\n    input_len_dim3 = 8\n\n    layer_test(convolutional.Convolution3D,\n               kwargs={'filters': filters,\n                       'kernel_size': (1, 2, 3),\n                       'padding': padding,\n                       'activation': None,\n                       'kernel_regularizer': 'l2',\n                       'bias_regularizer': 'l2',\n                       'activity_regularizer': 'l2',\n                       'kernel_constraint': 'max_norm',\n                       'bias_constraint': 'max_norm',\n                       'strides': strides},\n               input_shape=(num_samples,\n                            input_len_dim1, input_len_dim2, input_len_dim3,\n                            stack_size))",
        "begin_line": 545,
        "end_line": 569,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_conv3d_transpose#583",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_conv3d_transpose(padding, out_padding, strides, data_format)",
        "snippet": "def test_conv3d_transpose(padding, out_padding, strides, data_format):\n    filters = 2\n    stack_size = 3\n    num_depth = 7\n    num_row = 5\n    num_col = 6\n\n    layer_test(\n        convolutional.Conv3DTranspose,\n        kwargs={'filters': filters,\n                'kernel_size': 3,\n                'padding': padding,\n                'output_padding': out_padding,\n                'strides': strides,\n                'data_format': data_format},\n        input_shape=(None, num_depth, num_row, num_col, stack_size),\n        fixed_batch_size=True)",
        "begin_line": 583,
        "end_line": 599,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_conv3d_transpose_additional_args#603",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_conv3d_transpose_additional_args()",
        "snippet": "def test_conv3d_transpose_additional_args():\n    filters = 2\n    stack_size = 3\n    num_depth = 7\n    num_row = 5\n    num_col = 6\n    padding = 'valid'\n    strides = (2, 2, 2)\n\n    layer_test(convolutional.Conv3DTranspose,\n               kwargs={'filters': filters,\n                       'kernel_size': 3,\n                       'padding': padding,\n                       'data_format': 'channels_first',\n                       'activation': None,\n                       'kernel_regularizer': 'l2',\n                       'bias_regularizer': 'l2',\n                       'activity_regularizer': 'l2',\n                       'kernel_constraint': 'max_norm',\n                       'bias_constraint': 'max_norm',\n                       'use_bias': True,\n                       'strides': strides},\n               input_shape=(None, stack_size, num_depth, num_row, num_col),\n               fixed_batch_size=True)",
        "begin_line": 603,
        "end_line": 626,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_conv3d_transpose_invalid#630",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_conv3d_transpose_invalid()",
        "snippet": "def test_conv3d_transpose_invalid():\n    filters = 2\n    stack_size = 3\n    num_depth = 7\n    num_row = 5\n    num_col = 6\n    padding = 'valid'\n\n    # Test invalid use case\n    with pytest.raises(ValueError):\n        model = Sequential([convolutional.Conv3DTranspose(\n            filters=filters,\n            kernel_size=3,\n            padding=padding,\n            batch_input_shape=(None, None, 5, None, None))])\n\n    # Test invalid output padding for given stride. Output padding equal\n    # to stride\n    with pytest.raises(ValueError):\n        model = Sequential([convolutional.Conv3DTranspose(\n            filters=filters,\n            kernel_size=3,\n            padding=padding,\n            output_padding=(0, 3, 3),\n            strides=(1, 3, 4),\n            batch_input_shape=(None, num_depth, num_row, num_col, stack_size))])\n\n    # Output padding greater than stride\n    with pytest.raises(ValueError):\n        model = Sequential([convolutional.Conv3DTranspose(\n            filters=filters,\n            kernel_size=3,\n            padding=padding,\n            output_padding=(2, 2, 3),\n            strides=(1, 3, 4),\n            batch_input_shape=(None, num_depth, num_row, num_col, stack_size))])",
        "begin_line": 630,
        "end_line": 665,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_zero_padding_1d#669",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_zero_padding_1d()",
        "snippet": "def test_zero_padding_1d():\n    num_samples = 2\n    input_dim = 2\n    num_steps = 5\n    shape = (num_samples, num_steps, input_dim)\n    inputs = np.ones(shape)\n\n    # basic test\n    layer_test(convolutional.ZeroPadding1D,\n               kwargs={'padding': 2},\n               input_shape=inputs.shape)\n    layer_test(convolutional.ZeroPadding1D,\n               kwargs={'padding': (1, 2)},\n               input_shape=inputs.shape)\n\n    # correctness test\n    layer = convolutional.ZeroPadding1D(padding=2)\n    layer.build(shape)\n    outputs = layer(K.variable(inputs))\n    np_output = K.eval(outputs)\n    for offset in [0, 1, -1, -2]:\n        assert_allclose(np_output[:, offset, :], 0.)\n    assert_allclose(np_output[:, 2:-2, :], 1.)\n\n    layer = convolutional.ZeroPadding1D(padding=(1, 2))\n    layer.build(shape)\n    outputs = layer(K.variable(inputs))\n    np_output = K.eval(outputs)\n    for left_offset in [0]:\n        assert_allclose(np_output[:, left_offset, :], 0.)\n    for right_offset in [-1, -2]:\n        assert_allclose(np_output[:, right_offset, :], 0.)\n    assert_allclose(np_output[:, 1:-2, :], 1.)\n    layer.get_config()",
        "begin_line": 669,
        "end_line": 702,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_zero_padding_2d#712",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_zero_padding_2d(data_format, padding)",
        "snippet": "def test_zero_padding_2d(data_format, padding):\n    num_samples = 2\n    stack_size = 2\n    input_num_row = 4\n    input_num_col = 5\n\n    if data_format == 'channels_last':\n        inputs = np.ones((num_samples, input_num_row, input_num_col, stack_size))\n    else:\n        inputs = np.ones((num_samples, stack_size, input_num_row, input_num_col))\n\n    layer_test(convolutional.ZeroPadding2D,\n               kwargs={'padding': padding, 'data_format': data_format},\n               input_shape=inputs.shape)",
        "begin_line": 712,
        "end_line": 725,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_zero_padding_2d_correctness#729",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_zero_padding_2d_correctness()",
        "snippet": "def test_zero_padding_2d_correctness():\n    num_samples = 2\n    stack_size = 2\n    input_num_row = 4\n    input_num_col = 5\n    inputs = np.ones((num_samples, stack_size, input_num_row, input_num_col))\n\n    for data_format in ['channels_first', 'channels_last']:\n        layer = convolutional.ZeroPadding2D(padding=(2, 2),\n                                            data_format=data_format)\n        layer.build(inputs.shape)\n        outputs = layer(K.variable(inputs))\n        np_output = K.eval(outputs)\n        if data_format == 'channels_last':\n            for offset in [0, 1, -1, -2]:\n                assert_allclose(np_output[:, offset, :, :], 0.)\n                assert_allclose(np_output[:, :, offset, :], 0.)\n            assert_allclose(np_output[:, 2:-2, 2:-2, :], 1.)\n        elif data_format == 'channels_first':\n            for offset in [0, 1, -1, -2]:\n                assert_allclose(np_output[:, :, offset, :], 0.)\n                assert_allclose(np_output[:, :, :, offset], 0.)\n            assert_allclose(np_output[:, 2:-2, 2:-2, :], 1.)\n\n        layer = convolutional.ZeroPadding2D(padding=((1, 2), (3, 4)),\n                                            data_format=data_format)\n        layer.build(inputs.shape)\n        outputs = layer(K.variable(inputs))\n        np_output = K.eval(outputs)\n        if data_format == 'channels_last':\n            for top_offset in [0]:\n                assert_allclose(np_output[:, top_offset, :, :], 0.)\n            for bottom_offset in [-1, -2]:\n                assert_allclose(np_output[:, bottom_offset, :, :], 0.)\n            for left_offset in [0, 1, 2]:\n                assert_allclose(np_output[:, :, left_offset, :], 0.)\n            for right_offset in [-1, -2, -3, -4]:\n                assert_allclose(np_output[:, :, right_offset, :], 0.)\n            assert_allclose(np_output[:, 1:-2, 3:-4, :], 1.)\n        elif data_format == 'channels_first':\n            for top_offset in [0]:\n                assert_allclose(np_output[:, :, top_offset, :], 0.)\n            for bottom_offset in [-1, -2]:\n                assert_allclose(np_output[:, :, bottom_offset, :], 0.)\n            for left_offset in [0, 1, 2]:\n                assert_allclose(np_output[:, :, :, left_offset], 0.)\n            for right_offset in [-1, -2, -3, -4]:\n                assert_allclose(np_output[:, :, :, right_offset], 0.)\n            assert_allclose(np_output[:, :, 1:-2, 3:-4], 1.)",
        "begin_line": 729,
        "end_line": 777,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_zero_padding_3d#787",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_zero_padding_3d(data_format, padding)",
        "snippet": "def test_zero_padding_3d(data_format, padding):\n    num_samples = 2\n    stack_size = 2\n    input_len_dim1 = 4\n    input_len_dim2 = 5\n    input_len_dim3 = 3\n    inputs = np.ones((num_samples,\n                     input_len_dim1, input_len_dim2, input_len_dim3,\n                     stack_size))\n\n    layer_test(convolutional.ZeroPadding3D,\n               kwargs={'padding': padding, 'data_format': data_format},\n               input_shape=inputs.shape)",
        "begin_line": 787,
        "end_line": 799,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_zero_padding_3d_correctness#803",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_zero_padding_3d_correctness()",
        "snippet": "def test_zero_padding_3d_correctness():\n    num_samples = 2\n    stack_size = 2\n    input_len_dim1 = 4\n    input_len_dim2 = 5\n    input_len_dim3 = 3\n    inputs = np.ones((num_samples,\n                      input_len_dim1, input_len_dim2, input_len_dim3,\n                      stack_size))\n\n    for data_format in ['channels_first', 'channels_last']:\n        layer = convolutional.ZeroPadding3D(padding=(2, 2, 2),\n                                            data_format=data_format)\n        layer.build(inputs.shape)\n        outputs = layer(K.variable(inputs))\n        np_output = K.eval(outputs)\n        if data_format == 'channels_last':\n            for offset in [0, 1, -1, -2]:\n                assert_allclose(np_output[:, offset, :, :, :], 0.)\n                assert_allclose(np_output[:, :, offset, :, :], 0.)\n                assert_allclose(np_output[:, :, :, offset, :], 0.)\n            assert_allclose(np_output[:, 2:-2, 2:-2, 2:-2, :], 1.)\n        elif data_format == 'channels_first':\n            for offset in [0, 1, -1, -2]:\n                assert_allclose(np_output[:, :, offset, :, :], 0.)\n                assert_allclose(np_output[:, :, :, offset, :], 0.)\n                assert_allclose(np_output[:, :, :, :, offset], 0.)\n            assert_allclose(np_output[:, :, 2:-2, 2:-2, 2:-2], 1.)\n\n        layer = convolutional.ZeroPadding3D(padding=((1, 2), (3, 4), (0, 2)),\n                                            data_format=data_format)\n        layer.build(inputs.shape)\n        outputs = layer(K.variable(inputs))\n        np_output = K.eval(outputs)\n        if data_format == 'channels_last':\n            for dim1_offset in [0, -1, -2]:\n                assert_allclose(np_output[:, dim1_offset, :, :, :], 0.)\n            for dim2_offset in [0, 1, 2, -1, -2, -3, -4]:\n                assert_allclose(np_output[:, :, dim2_offset, :, :], 0.)\n            for dim3_offset in [-1, -2]:\n                assert_allclose(np_output[:, :, :, dim3_offset, :], 0.)\n            assert_allclose(np_output[:, 1:-2, 3:-4, 0:-2, :], 1.)\n        elif data_format == 'channels_first':\n            for dim1_offset in [0, -1, -2]:\n                assert_allclose(np_output[:, :, dim1_offset, :, :], 0.)\n            for dim2_offset in [0, 1, 2, -1, -2, -3, -4]:\n                assert_allclose(np_output[:, :, :, dim2_offset, :], 0.)\n            for dim3_offset in [-1, -2]:\n                assert_allclose(np_output[:, :, :, :, dim3_offset], 0.)\n            assert_allclose(np_output[:, :, 1:-2, 3:-4, 0:-2], 1.)",
        "begin_line": 803,
        "end_line": 852,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_upsampling_1d#856",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_upsampling_1d()",
        "snippet": "def test_upsampling_1d():\n    layer_test(convolutional.UpSampling1D,\n               kwargs={'size': 2},\n               input_shape=(3, 5, 4))",
        "begin_line": 856,
        "end_line": 859,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_upsampling_2d#863",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_upsampling_2d()",
        "snippet": "def test_upsampling_2d():\n    num_samples = 2\n    stack_size = 2\n    input_num_row = 11\n    input_num_col = 12\n\n    for data_format in ['channels_first', 'channels_last']:\n        if data_format == 'channels_first':\n            inputs = np.random.rand(num_samples, stack_size, input_num_row,\n                                    input_num_col)\n        else:  # tf\n            inputs = np.random.rand(num_samples, input_num_row, input_num_col,\n                                    stack_size)\n\n        # basic test\n        layer_test(convolutional.UpSampling2D,\n                   kwargs={'size': (2, 2), 'data_format': data_format},\n                   input_shape=inputs.shape)\n\n        for length_row in [2]:\n            for length_col in [2, 3]:\n                layer = convolutional.UpSampling2D(\n                    size=(length_row, length_col),\n                    data_format=data_format)\n                layer.build(inputs.shape)\n                outputs = layer(K.variable(inputs))\n                np_output = K.eval(outputs)\n                if data_format == 'channels_first':\n                    assert np_output.shape[2] == length_row * input_num_row\n                    assert np_output.shape[3] == length_col * input_num_col\n                else:  # tf\n                    assert np_output.shape[1] == length_row * input_num_row\n                    assert np_output.shape[2] == length_col * input_num_col\n\n                # compare with numpy\n                if data_format == 'channels_first':\n                    expected_out = np.repeat(inputs, length_row, axis=2)\n                    expected_out = np.repeat(expected_out, length_col, axis=3)\n                else:  # tf\n                    expected_out = np.repeat(inputs, length_row, axis=1)\n                    expected_out = np.repeat(expected_out, length_col, axis=2)\n\n                assert_allclose(np_output, expected_out)",
        "begin_line": 863,
        "end_line": 905,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_upsampling_2d_bilinear#912",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_upsampling_2d_bilinear(data_format)",
        "snippet": "def test_upsampling_2d_bilinear(data_format):\n    num_samples = 2\n    stack_size = 2\n    input_num_row = 11\n    input_num_col = 12\n\n    if data_format == 'channels_first':\n        inputs = np.random.rand(num_samples, stack_size, input_num_row,\n                                input_num_col)\n    else:  # tf\n        inputs = np.random.rand(num_samples, input_num_row, input_num_col,\n                                stack_size)\n\n    # basic test\n    layer_test(convolutional.UpSampling2D,\n               kwargs={'size': (2, 2),\n                       'data_format': data_format,\n                       'interpolation': 'bilinear'},\n               input_shape=inputs.shape)\n\n    for length_row in [2]:\n        for length_col in [2, 3]:\n            layer = convolutional.UpSampling2D(\n                size=(length_row, length_col),\n                data_format=data_format)\n            layer.build(inputs.shape)\n            outputs = layer(K.variable(inputs))\n            np_output = K.eval(outputs)\n            if data_format == 'channels_first':\n                assert np_output.shape[2] == length_row * input_num_row\n                assert np_output.shape[3] == length_col * input_num_col\n            else:  # tf\n                assert np_output.shape[1] == length_row * input_num_row\n                assert np_output.shape[2] == length_col * input_num_col",
        "begin_line": 912,
        "end_line": 945,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_upsampling_3d#950",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_upsampling_3d()",
        "snippet": "def test_upsampling_3d():\n    num_samples = 2\n    stack_size = 2\n    input_len_dim1 = 10\n    input_len_dim2 = 11\n    input_len_dim3 = 12\n\n    for data_format in ['channels_first', 'channels_last']:\n        if data_format == 'channels_first':\n            inputs = np.random.rand(num_samples,\n                                    stack_size,\n                                    input_len_dim1, input_len_dim2, input_len_dim3)\n        else:  # tf\n            inputs = np.random.rand(num_samples,\n                                    input_len_dim1, input_len_dim2, input_len_dim3,\n                                    stack_size)\n\n        # basic test\n        layer_test(convolutional.UpSampling3D,\n                   kwargs={'size': (2, 2, 2), 'data_format': data_format},\n                   input_shape=inputs.shape)\n\n        for length_dim1 in [2, 3]:\n            for length_dim2 in [2]:\n                for length_dim3 in [3]:\n                    layer = convolutional.UpSampling3D(\n                        size=(length_dim1, length_dim2, length_dim3),\n                        data_format=data_format)\n                    layer.build(inputs.shape)\n                    outputs = layer(K.variable(inputs))\n                    np_output = K.eval(outputs)\n                    if data_format == 'channels_first':\n                        assert np_output.shape[2] == length_dim1 * input_len_dim1\n                        assert np_output.shape[3] == length_dim2 * input_len_dim2\n                        assert np_output.shape[4] == length_dim3 * input_len_dim3\n                    else:  # tf\n                        assert np_output.shape[1] == length_dim1 * input_len_dim1\n                        assert np_output.shape[2] == length_dim2 * input_len_dim2\n                        assert np_output.shape[3] == length_dim3 * input_len_dim3\n\n                    # compare with numpy\n                    if data_format == 'channels_first':\n                        expected_out = np.repeat(inputs, length_dim1, axis=2)\n                        expected_out = np.repeat(expected_out, length_dim2, axis=3)\n                        expected_out = np.repeat(expected_out, length_dim3, axis=4)\n                    else:  # tf\n                        expected_out = np.repeat(inputs, length_dim1, axis=1)\n                        expected_out = np.repeat(expected_out, length_dim2, axis=2)\n                        expected_out = np.repeat(expected_out, length_dim3, axis=3)\n\n                    assert_allclose(np_output, expected_out)",
        "begin_line": 950,
        "end_line": 1000,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_cropping_1d#1006",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_cropping_1d()",
        "snippet": "def test_cropping_1d():\n    num_samples = 2\n    time_length = 4\n    input_len_dim1 = 2\n    inputs = np.random.rand(num_samples, time_length, input_len_dim1)\n\n    layer_test(convolutional.Cropping1D,\n               kwargs={'cropping': (2, 2)},\n               input_shape=inputs.shape)",
        "begin_line": 1006,
        "end_line": 1014,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_cropping_2d#1017",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_cropping_2d()",
        "snippet": "def test_cropping_2d():\n    num_samples = 2\n    stack_size = 2\n    input_len_dim1 = 9\n    input_len_dim2 = 9\n    cropping = ((2, 2), (3, 3))\n\n    for data_format in ['channels_first', 'channels_last']:\n        if data_format == 'channels_first':\n            inputs = np.random.rand(num_samples, stack_size,\n                                    input_len_dim1, input_len_dim2)\n        else:\n            inputs = np.random.rand(num_samples,\n                                    input_len_dim1, input_len_dim2,\n                                    stack_size)\n        # basic test\n        layer_test(convolutional.Cropping2D,\n                   kwargs={'cropping': cropping,\n                           'data_format': data_format},\n                   input_shape=inputs.shape)\n        # correctness test\n        layer = convolutional.Cropping2D(cropping=cropping,\n                                         data_format=data_format)\n        layer.build(inputs.shape)\n        outputs = layer(K.variable(inputs))\n        np_output = K.eval(outputs)\n        # compare with numpy\n        if data_format == 'channels_first':\n            expected_out = inputs[:,\n                                  :,\n                                  cropping[0][0]: -cropping[0][1],\n                                  cropping[1][0]: -cropping[1][1]]\n        else:\n            expected_out = inputs[:,\n                                  cropping[0][0]: -cropping[0][1],\n                                  cropping[1][0]: -cropping[1][1],\n                                  :]\n        assert_allclose(np_output, expected_out)\n\n    for data_format in ['channels_first', 'channels_last']:\n        if data_format == 'channels_first':\n            inputs = np.random.rand(num_samples, stack_size,\n                                    input_len_dim1, input_len_dim2)\n        else:\n            inputs = np.random.rand(num_samples,\n                                    input_len_dim1, input_len_dim2,\n                                    stack_size)\n        # another correctness test (no cropping)\n        cropping = ((0, 0), (0, 0))\n        layer = convolutional.Cropping2D(cropping=cropping,\n                                         data_format=data_format)\n        layer.build(inputs.shape)\n        outputs = layer(K.variable(inputs))\n        np_output = K.eval(outputs)\n        # compare with input\n        assert_allclose(np_output, inputs)\n\n    # Test invalid use cases\n    with pytest.raises(ValueError):\n        layer = convolutional.Cropping2D(cropping=((1, 1),))\n    with pytest.raises(ValueError):\n        layer = convolutional.Cropping2D(cropping=lambda x: x)",
        "begin_line": 1017,
        "end_line": 1078,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_cropping_3d#1081",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_cropping_3d()",
        "snippet": "def test_cropping_3d():\n    num_samples = 2\n    stack_size = 2\n    input_len_dim1 = 8\n    input_len_dim2 = 8\n    input_len_dim3 = 8\n    cropping = ((2, 2), (3, 3), (2, 3))\n\n    for data_format in ['channels_last', 'channels_first']:\n        if data_format == 'channels_first':\n            inputs = np.random.rand(num_samples, stack_size,\n                                    input_len_dim1, input_len_dim2, input_len_dim3)\n        else:\n            inputs = np.random.rand(num_samples,\n                                    input_len_dim1, input_len_dim2,\n                                    input_len_dim3, stack_size)\n        # basic test\n        layer_test(convolutional.Cropping3D,\n                   kwargs={'cropping': cropping,\n                           'data_format': data_format},\n                   input_shape=inputs.shape)\n        # correctness test\n        layer = convolutional.Cropping3D(cropping=cropping,\n                                         data_format=data_format)\n        layer.build(inputs.shape)\n        outputs = layer(K.variable(inputs))\n        np_output = K.eval(outputs)\n        # compare with numpy\n        if data_format == 'channels_first':\n            expected_out = inputs[:,\n                                  :,\n                                  cropping[0][0]: -cropping[0][1],\n                                  cropping[1][0]: -cropping[1][1],\n                                  cropping[2][0]: -cropping[2][1]]\n        else:\n            expected_out = inputs[:,\n                                  cropping[0][0]: -cropping[0][1],\n                                  cropping[1][0]: -cropping[1][1],\n                                  cropping[2][0]: -cropping[2][1],\n                                  :]\n        assert_allclose(np_output, expected_out)\n\n    for data_format in ['channels_last', 'channels_first']:\n        if data_format == 'channels_first':\n            inputs = np.random.rand(num_samples, stack_size,\n                                    input_len_dim1, input_len_dim2, input_len_dim3)\n        else:\n            inputs = np.random.rand(num_samples,\n                                    input_len_dim1, input_len_dim2,\n                                    input_len_dim3, stack_size)\n        # another correctness test (no cropping)\n        cropping = ((0, 0), (0, 0), (0, 0))\n        layer = convolutional.Cropping3D(cropping=cropping,\n                                         data_format=data_format)\n        layer.build(inputs.shape)\n        outputs = layer(K.variable(inputs))\n        np_output = K.eval(outputs)\n        # compare with input\n        assert_allclose(np_output, inputs)\n\n    # Test invalid use cases\n    with pytest.raises(ValueError):\n        layer = convolutional.Cropping3D(cropping=((1, 1),))\n    with pytest.raises(ValueError):\n        layer = convolutional.Cropping3D(cropping=lambda x: x)",
        "begin_line": 1081,
        "end_line": 1145,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_conv_float64#1157",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_conv_float64(input_shape, conv_class)",
        "snippet": "def test_conv_float64(input_shape, conv_class):\n    kernel_size = 3\n    strides = 1\n    filters = 3\n    K.set_floatx('float64')\n    layer_test(conv_class,\n               kwargs={'filters': filters,\n                       'kernel_size': kernel_size,\n                       'padding': 'valid',\n                       'strides': strides},\n               input_shape=input_shape)\n    K.set_floatx('float32')",
        "begin_line": 1157,
        "end_line": 1168,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.wrapper#11",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.wrapper(*args, **kwargs)",
        "snippet": "    def wrapper(*args, **kwargs):\n        x = args[0]\n        w = args[1]\n        if x.ndim == 3:\n            w = np.flipud(w)\n            w = np.transpose(w, (1, 2, 0))\n            if kwargs['data_format'] == 'channels_last':\n                x = np.transpose(x, (0, 2, 1))\n        elif x.ndim == 4:\n            w = np.fliplr(np.flipud(w))\n            w = np.transpose(w, (2, 3, 0, 1))\n            if kwargs['data_format'] == 'channels_last':\n                x = np.transpose(x, (0, 3, 1, 2))\n        else:\n            w = np.flip(np.fliplr(np.flipud(w)), axis=2)\n            w = np.transpose(w, (3, 4, 0, 1, 2))\n            if kwargs['data_format'] == 'channels_last':\n                x = np.transpose(x, (0, 4, 1, 2, 3))\n\n        y = func(x, w, **kwargs)\n\n        if kwargs['data_format'] == 'channels_last':\n            if y.ndim == 3:\n                y = np.transpose(y, (0, 2, 1))\n            elif y.ndim == 4:\n                y = np.transpose(y, (0, 2, 3, 1))\n            else:\n                y = np.transpose(y, (0, 2, 3, 4, 1))\n\n        return y",
        "begin_line": 11,
        "end_line": 40,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.conv#46",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.conv(x, w, padding, data_format)",
        "snippet": "def conv(x, w, padding, data_format):\n    y = []\n    for i in range(x.shape[0]):\n        _y = []\n        for j in range(w.shape[1]):\n            __y = []\n            for k in range(w.shape[0]):\n                __y.append(signal.convolve(x[i, k], w[k, j], mode=padding))\n            _y.append(np.sum(np.stack(__y, axis=-1), axis=-1))\n        y.append(_y)\n    y = np.array(y)\n    return y",
        "begin_line": 46,
        "end_line": 57,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.depthwise_conv#61",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.depthwise_conv(x, w, padding, data_format)",
        "snippet": "def depthwise_conv(x, w, padding, data_format):\n    y = []\n    for i in range(x.shape[0]):\n        _y = []\n        for j in range(w.shape[0]):\n            __y = []\n            for k in range(w.shape[1]):\n                __y.append(signal.convolve(x[i, j], w[j, k], mode=padding))\n            _y.append(np.stack(__y, axis=0))\n        y.append(np.concatenate(_y, axis=0))\n    y = np.array(y)\n    return y",
        "begin_line": 61,
        "end_line": 72,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.separable_conv#75",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.separable_conv(x, w1, w2, padding, data_format)",
        "snippet": "def separable_conv(x, w1, w2, padding, data_format):\n    x2 = depthwise_conv(x, w1, padding=padding, data_format=data_format)\n    return conv(x2, w2, padding=padding, data_format=data_format)",
        "begin_line": 75,
        "end_line": 77,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.pool#88",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.pool(x, pool_size, strides, padding, data_format, pool_mode)",
        "snippet": "def pool(x, pool_size, strides, padding, data_format, pool_mode):\n    if data_format == 'channels_last':\n        if x.ndim == 3:\n            x = np.transpose(x, (0, 2, 1))\n        elif x.ndim == 4:\n            x = np.transpose(x, (0, 3, 1, 2))\n        else:\n            x = np.transpose(x, (0, 4, 1, 2, 3))\n\n    if padding == 'same':\n        pad = [(0, 0), (0, 0)] + [(s // 2, s // 2) for s in pool_size]\n        x = np.pad(x, pad, 'constant', constant_values=-np.inf)\n\n    # indexing trick\n    x = np.pad(x, [(0, 0), (0, 0)] + [(0, 1) for _ in pool_size],\n               'constant', constant_values=0)\n\n    if x.ndim == 3:\n        y = [x[:, :, k:k1:strides[0]]\n             for (k, k1) in zip(range(pool_size[0]), range(-pool_size[0], 0))]\n    elif x.ndim == 4:\n        y = []\n        for (k, k1) in zip(range(pool_size[0]), range(-pool_size[0], 0)):\n            for (l, l1) in zip(range(pool_size[1]), range(-pool_size[1], 0)):\n                y.append(x[:, :, k:k1:strides[0], l:l1:strides[1]])\n    else:\n        y = []\n        for (k, k1) in zip(range(pool_size[0]), range(-pool_size[0], 0)):\n            for (l, l1) in zip(range(pool_size[1]), range(-pool_size[1], 0)):\n                for (m, m1) in zip(range(pool_size[2]), range(-pool_size[2], 0)):\n                    y.append(x[:,\n                               :,\n                               k:k1:strides[0],\n                               l:l1:strides[1],\n                               m:m1:strides[2]])\n    y = np.stack(y, axis=-1)\n    if pool_mode == 'avg':\n        y = np.mean(np.ma.masked_invalid(y), axis=-1).data\n    elif pool_mode == 'max':\n        y = np.max(y, axis=-1)\n\n    if data_format == 'channels_last':\n        if y.ndim == 3:\n            y = np.transpose(y, (0, 2, 1))\n        elif y.ndim == 4:\n            y = np.transpose(y, (0, 2, 3, 1))\n        else:\n            y = np.transpose(y, (0, 2, 3, 4, 1))\n\n    return y",
        "begin_line": 88,
        "end_line": 137,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.rnn#144",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.rnn(x, w, init, go_backwards=False, mask=None, unroll=False, input_length=None)",
        "snippet": "def rnn(x, w, init, go_backwards=False, mask=None, unroll=False, input_length=None):\n    w_i, w_h, w_o = w\n    h = []\n    o = []\n\n    if go_backwards:\n        t_list = range(x.shape[1] - 1, -1, -1)\n    else:\n        t_list = range(x.shape[1])\n\n    if mask is not None:\n        from keras import backend as K\n        np_mask = K.eval(mask)\n    else:\n        np_mask = None\n\n    for (i, t) in enumerate(t_list):\n        h_t = np.dot(x[:, t], w_i)\n\n        if w_h is not None:\n            prev = h[i - 1] if i > 0 else init\n            h_t1 = np.dot(prev, w_h)\n            if np_mask is not None:\n                h_t1[np_mask[:, t] == 0] = prev[np_mask[:, t] == 0]\n        else:\n            h_t1 = 0\n\n        o_t = h_t + h_t1\n        if w_o is not None:\n            o_t = np.dot(o_t, w_o)\n        o.append(o_t)\n\n        if np_mask is not None:\n            h_t = h_t * np_mask[:, t].reshape(-1, 1)\n        h.append(h_t + h_t1)\n\n    return o[-1], np.stack(o, axis=1), np.stack(h, axis=1)",
        "begin_line": 144,
        "end_line": 180,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.relu#183",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.relu(x, alpha=0.0, max_value=None)",
        "snippet": "def relu(x, alpha=0., max_value=None):\n    y = x * (x > 0) + alpha * x * (x < 0)\n    if max_value is not None:\n        y = np.minimum(y, max_value)\n    return y",
        "begin_line": 183,
        "end_line": 187,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.softplus#190",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.softplus(x)",
        "snippet": "def softplus(x):\n    return np.log(1. + np.exp(x))",
        "begin_line": 190,
        "end_line": 191,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.elu#194",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.elu(x, alpha=1.0)",
        "snippet": "def elu(x, alpha=1.):\n    return x * (x > 0) + alpha * (np.exp(x) - 1.) * (x < 0)",
        "begin_line": 194,
        "end_line": 195,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.sigmoid#198",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.sigmoid(x)",
        "snippet": "def sigmoid(x):\n    return 1. / (1. + np.exp(-x))",
        "begin_line": 198,
        "end_line": 199,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.hard_sigmoid#202",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.hard_sigmoid(x)",
        "snippet": "def hard_sigmoid(x):\n    y = 0.2 * x + 0.5\n    y = np.minimum(y, 1.)\n    y = np.maximum(y, 0.)\n    return y",
        "begin_line": 202,
        "end_line": 206,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.tanh#209",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.tanh(x)",
        "snippet": "def tanh(x):\n    return np.tanh(x)",
        "begin_line": 209,
        "end_line": 210,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.softmax#213",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.softmax(x, axis=-1)",
        "snippet": "def softmax(x, axis=-1):\n    y = np.exp(x - np.max(x, axis, keepdims=True))\n    return y / np.sum(y, axis, keepdims=True)",
        "begin_line": 213,
        "end_line": 215,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.l2_normalize#218",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.l2_normalize(x, axis=-1)",
        "snippet": "def l2_normalize(x, axis=-1):\n    y = np.max(np.sum(x ** 2, axis, keepdims=True), axis, keepdims=True)\n    return x / np.sqrt(y)",
        "begin_line": 218,
        "end_line": 220,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.binary_crossentropy#223",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.binary_crossentropy(target, output, from_logits=False)",
        "snippet": "def binary_crossentropy(target, output, from_logits=False):\n    if not from_logits:\n        output = np.clip(output, 1e-7, 1 - 1e-7)\n        output = np.log(output / (1 - output))\n    return (target * -np.log(sigmoid(output)) +\n            (1 - target) * -np.log(1 - sigmoid(output)))",
        "begin_line": 223,
        "end_line": 228,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.categorical_crossentropy#231",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.categorical_crossentropy(target, output, from_logits=False)",
        "snippet": "def categorical_crossentropy(target, output, from_logits=False):\n    if from_logits:\n        output = softmax(output)\n    else:\n        output /= output.sum(axis=-1, keepdims=True)\n    output = np.clip(output, 1e-7, 1 - 1e-7)\n    return np.sum(target * -np.log(output), axis=-1, keepdims=False)",
        "begin_line": 231,
        "end_line": 237,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.max#240",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.max(x, axis=None, keepdims=False)",
        "snippet": "def max(x, axis=None, keepdims=False):\n    if isinstance(axis, list):\n        for a in axis:\n            x = np.max(x, axis=a, keepdims=keepdims)\n        return x\n    else:\n        return np.max(x, axis=axis, keepdims=keepdims)",
        "begin_line": 240,
        "end_line": 246,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.min#249",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.min(x, axis=None, keepdims=False)",
        "snippet": "def min(x, axis=None, keepdims=False):\n    if isinstance(axis, list):\n        for a in axis:\n            x = np.min(x, axis=a, keepdims=keepdims)\n        return x\n    else:\n        return np.min(x, axis=axis, keepdims=keepdims)",
        "begin_line": 249,
        "end_line": 255,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.mean#258",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.mean(x, axis=None, keepdims=False)",
        "snippet": "def mean(x, axis=None, keepdims=False):\n    if isinstance(axis, list):\n        for a in axis:\n            x = np.mean(x, axis=a, keepdims=keepdims)\n        return x\n    else:\n        return np.mean(x, axis=axis, keepdims=keepdims)",
        "begin_line": 258,
        "end_line": 264,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.std#267",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.std(x, axis=None, keepdims=False)",
        "snippet": "def std(x, axis=None, keepdims=False):\n    if isinstance(axis, list):\n        for a in axis:\n            x = np.std(x, axis=a, keepdims=keepdims)\n        return x\n    else:\n        return np.std(x, axis=axis, keepdims=keepdims)",
        "begin_line": 267,
        "end_line": 273,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.prod#285",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.prod(x, axis=None, keepdims=False)",
        "snippet": "def prod(x, axis=None, keepdims=False):\n    if isinstance(axis, list):\n        for a in axis:\n            x = np.prod(x, axis=a, keepdims=keepdims)\n        return x\n    else:\n        return np.prod(x, axis=axis, keepdims=keepdims)",
        "begin_line": 285,
        "end_line": 291,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.cumsum#294",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.cumsum(x, axis=0)",
        "snippet": "def cumsum(x, axis=0):\n    return np.cumsum(x, axis=axis)",
        "begin_line": 294,
        "end_line": 295,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.cumprod#298",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.cumprod(x, axis=0)",
        "snippet": "def cumprod(x, axis=0):\n    return np.cumprod(x, axis=axis)",
        "begin_line": 298,
        "end_line": 299,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.any#302",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.any(x, axis=None, keepdims=False)",
        "snippet": "def any(x, axis=None, keepdims=False):\n    return np.any(x, axis=axis, keepdims=keepdims)",
        "begin_line": 302,
        "end_line": 303,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.all#306",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.all(x, axis=None, keepdims=False)",
        "snippet": "def all(x, axis=None, keepdims=False):\n    return np.all(x, axis=axis, keepdims=keepdims)",
        "begin_line": 306,
        "end_line": 307,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.argmax#310",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.argmax(x, axis=-1)",
        "snippet": "def argmax(x, axis=-1):\n    return np.argmax(x, axis=axis)",
        "begin_line": 310,
        "end_line": 311,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.argmin#314",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.argmin(x, axis=-1)",
        "snippet": "def argmin(x, axis=-1):\n    return np.argmin(x, axis=axis)",
        "begin_line": 314,
        "end_line": 315,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.sqrt#318",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.sqrt(x)",
        "snippet": "def sqrt(x):\n    y = np.sqrt(x)\n    y[np.isnan(y)] = 0.\n    return y",
        "begin_line": 318,
        "end_line": 321,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.pow#324",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.pow(x, a=1.0)",
        "snippet": "def pow(x, a=1.):\n    return np.power(x, a)",
        "begin_line": 324,
        "end_line": 325,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.clip#328",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.clip(x, min_value, max_value)",
        "snippet": "def clip(x, min_value, max_value):\n    return np.clip(x, min_value, max_value)",
        "begin_line": 328,
        "end_line": 329,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.reshape#332",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.reshape(x, shape)",
        "snippet": "def reshape(x, shape):\n    return np.reshape(x, shape)",
        "begin_line": 332,
        "end_line": 333,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.repeat_elements#336",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.repeat_elements(x, rep, axis)",
        "snippet": "def repeat_elements(x, rep, axis):\n    return np.repeat(x, rep, axis=axis)",
        "begin_line": 336,
        "end_line": 337,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.eval#340",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.eval(x)",
        "snippet": "def eval(x):\n    return x",
        "begin_line": 340,
        "end_line": 341,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.variable#344",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.variable(value, dtype=None, name=None, constraint=None)",
        "snippet": "def variable(value, dtype=None, name=None, constraint=None):\n    if constraint is not None:\n        raise TypeError(\"Constraint must be None when \"\n                        \"using the NumPy backend.\")\n    return np.array(value, dtype)",
        "begin_line": 344,
        "end_line": 348,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.equal#351",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.equal(x, y)",
        "snippet": "def equal(x, y):\n    return x == y",
        "begin_line": 351,
        "end_line": 352,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.not_equal#355",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.not_equal(x, y)",
        "snippet": "def not_equal(x, y):\n    return x != y",
        "begin_line": 355,
        "end_line": 356,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.greater#359",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.greater(x, y)",
        "snippet": "def greater(x, y):\n    return x > y",
        "begin_line": 359,
        "end_line": 360,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.greater_equal#363",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.greater_equal(x, y)",
        "snippet": "def greater_equal(x, y):\n    return x >= y",
        "begin_line": 363,
        "end_line": 364,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.less#367",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.less(x, y)",
        "snippet": "def less(x, y):\n    return x < y",
        "begin_line": 367,
        "end_line": 368,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.less_equal#371",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.less_equal(x, y)",
        "snippet": "def less_equal(x, y):\n    return x <= y",
        "begin_line": 371,
        "end_line": 372,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.maximum#375",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.maximum(x, y)",
        "snippet": "def maximum(x, y):\n    return np.maximum(x, y)",
        "begin_line": 375,
        "end_line": 376,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.minimum#379",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.minimum(x, y)",
        "snippet": "def minimum(x, y):\n    return np.minimum(x, y)",
        "begin_line": 379,
        "end_line": 380,
        "comment": "",
        "is_bug": false
    }
]