[
    {
        "name": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_append#14",
        "src_path": "pandas/tests/series/test_combine_concat.py",
        "class_name": "pandas.tests.series.test_combine_concat.TestSeriesCombine",
        "signature": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_append(self, datetime_series, string_series, object_series)",
        "snippet": "    def test_append(self, datetime_series, string_series, object_series):\n        appendedSeries = string_series.append(object_series)\n        for idx, value in appendedSeries.items():\n            if idx in string_series.index:\n                assert value == string_series[idx]\n            elif idx in object_series.index:\n                assert value == object_series[idx]\n            else:\n                raise AssertionError(\"orphaned index!\")\n\n        msg = \"Indexes have overlapping values:\"\n        with pytest.raises(ValueError, match=msg):\n            datetime_series.append(datetime_series, verify_integrity=True)",
        "begin_line": 14,
        "end_line": 26,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_append_many#28",
        "src_path": "pandas/tests/series/test_combine_concat.py",
        "class_name": "pandas.tests.series.test_combine_concat.TestSeriesCombine",
        "signature": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_append_many(self, datetime_series)",
        "snippet": "    def test_append_many(self, datetime_series):\n        pieces = [datetime_series[:5], datetime_series[5:10], datetime_series[10:]]\n\n        result = pieces[0].append(pieces[1:])\n        assert_series_equal(result, datetime_series)",
        "begin_line": 28,
        "end_line": 32,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_append_duplicates#34",
        "src_path": "pandas/tests/series/test_combine_concat.py",
        "class_name": "pandas.tests.series.test_combine_concat.TestSeriesCombine",
        "signature": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_append_duplicates(self)",
        "snippet": "    def test_append_duplicates(self):\n        # GH 13677\n        s1 = pd.Series([1, 2, 3])\n        s2 = pd.Series([4, 5, 6])\n        exp = pd.Series([1, 2, 3, 4, 5, 6], index=[0, 1, 2, 0, 1, 2])\n        tm.assert_series_equal(s1.append(s2), exp)\n        tm.assert_series_equal(pd.concat([s1, s2]), exp)\n\n        # the result must have RangeIndex\n        exp = pd.Series([1, 2, 3, 4, 5, 6])\n        tm.assert_series_equal(\n            s1.append(s2, ignore_index=True), exp, check_index_type=True\n        )\n        tm.assert_series_equal(\n            pd.concat([s1, s2], ignore_index=True), exp, check_index_type=True\n        )\n\n        msg = \"Indexes have overlapping values:\"\n        with pytest.raises(ValueError, match=msg):\n            s1.append(s2, verify_integrity=True)\n        with pytest.raises(ValueError, match=msg):\n            pd.concat([s1, s2], verify_integrity=True)",
        "begin_line": 34,
        "end_line": 55,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_append_tuples#57",
        "src_path": "pandas/tests/series/test_combine_concat.py",
        "class_name": "pandas.tests.series.test_combine_concat.TestSeriesCombine",
        "signature": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_append_tuples(self)",
        "snippet": "    def test_append_tuples(self):\n        # GH 28410\n        s = pd.Series([1, 2, 3])\n        list_input = [s, s]\n        tuple_input = (s, s)\n\n        expected = s.append(list_input)\n        result = s.append(tuple_input)\n\n        tm.assert_series_equal(expected, result)",
        "begin_line": 57,
        "end_line": 66,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_combine_scalar#68",
        "src_path": "pandas/tests/series/test_combine_concat.py",
        "class_name": "pandas.tests.series.test_combine_concat.TestSeriesCombine",
        "signature": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_combine_scalar(self)",
        "snippet": "    def test_combine_scalar(self):\n        # GH 21248\n        # Note - combine() with another Series is tested elsewhere because\n        # it is used when testing operators\n        s = pd.Series([i * 10 for i in range(5)])\n        result = s.combine(3, lambda x, y: x + y)\n        expected = pd.Series([i * 10 + 3 for i in range(5)])\n        tm.assert_series_equal(result, expected)\n\n        result = s.combine(22, lambda x, y: min(x, y))\n        expected = pd.Series([min(i * 10, 22) for i in range(5)])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 68,
        "end_line": 79,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_combine_first#81",
        "src_path": "pandas/tests/series/test_combine_concat.py",
        "class_name": "pandas.tests.series.test_combine_concat.TestSeriesCombine",
        "signature": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_combine_first(self)",
        "snippet": "    def test_combine_first(self):\n        values = tm.makeIntIndex(20).values.astype(float)\n        series = Series(values, index=tm.makeIntIndex(20))\n\n        series_copy = series * 2\n        series_copy[::2] = np.NaN\n\n        # nothing used from the input\n        combined = series.combine_first(series_copy)\n\n        tm.assert_series_equal(combined, series)\n\n        # Holes filled from input\n        combined = series_copy.combine_first(series)\n        assert np.isfinite(combined).all()\n\n        tm.assert_series_equal(combined[::2], series[::2])\n        tm.assert_series_equal(combined[1::2], series_copy[1::2])\n\n        # mixed types\n        index = tm.makeStringIndex(20)\n        floats = Series(tm.randn(20), index=index)\n        strings = Series(tm.makeStringIndex(10), index=index[::2])\n\n        combined = strings.combine_first(floats)\n\n        tm.assert_series_equal(strings, combined.loc[index[::2]])\n        tm.assert_series_equal(floats[1::2].astype(object), combined.loc[index[1::2]])\n\n        # corner case\n        s = Series([1.0, 2, 3], index=[0, 1, 2])\n        result = s.combine_first(Series([], index=[]))\n        s.index = s.index.astype(\"O\")\n        assert_series_equal(s, result)",
        "begin_line": 81,
        "end_line": 114,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_update#116",
        "src_path": "pandas/tests/series/test_combine_concat.py",
        "class_name": "pandas.tests.series.test_combine_concat.TestSeriesCombine",
        "signature": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_update(self)",
        "snippet": "    def test_update(self):\n        s = Series([1.5, nan, 3.0, 4.0, nan])\n        s2 = Series([nan, 3.5, nan, 5.0])\n        s.update(s2)\n\n        expected = Series([1.5, 3.5, 3.0, 5.0, np.nan])\n        assert_series_equal(s, expected)\n\n        # GH 3217\n        df = DataFrame([{\"a\": 1}, {\"a\": 3, \"b\": 2}])\n        df[\"c\"] = np.nan\n\n        df[\"c\"].update(Series([\"foo\"], index=[0]))\n        expected = DataFrame(\n            [[1, np.nan, \"foo\"], [3, 2.0, np.nan]], columns=[\"a\", \"b\", \"c\"]\n        )\n        assert_frame_equal(df, expected)",
        "begin_line": 116,
        "end_line": 132,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_update_dtypes#159",
        "src_path": "pandas/tests/series/test_combine_concat.py",
        "class_name": "pandas.tests.series.test_combine_concat.TestSeriesCombine",
        "signature": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_update_dtypes(self, other, dtype, expected)",
        "snippet": "    def test_update_dtypes(self, other, dtype, expected):\n\n        s = Series([10, 11, 12], dtype=dtype)\n        other = Series(other, index=[1, 3])\n        s.update(other)\n\n        assert_series_equal(s, expected)",
        "begin_line": 159,
        "end_line": 165,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_concat_empty_series_dtypes_roundtrips#167",
        "src_path": "pandas/tests/series/test_combine_concat.py",
        "class_name": "pandas.tests.series.test_combine_concat.TestSeriesCombine",
        "signature": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_concat_empty_series_dtypes_roundtrips(self)",
        "snippet": "    def test_concat_empty_series_dtypes_roundtrips(self):\n\n        # round-tripping with self & like self\n        dtypes = map(np.dtype, [\"float64\", \"int8\", \"uint8\", \"bool\", \"m8[ns]\", \"M8[ns]\"])\n\n        for dtype in dtypes:\n            assert pd.concat([Series(dtype=dtype)]).dtype == dtype\n            assert pd.concat([Series(dtype=dtype), Series(dtype=dtype)]).dtype == dtype\n\n        def int_result_type(dtype, dtype2):\n            typs = {dtype.kind, dtype2.kind}\n            if not len(typs - {\"i\", \"u\", \"b\"}) and (\n                dtype.kind == \"i\" or dtype2.kind == \"i\"\n            ):\n                return \"i\"\n            elif not len(typs - {\"u\", \"b\"}) and (\n                dtype.kind == \"u\" or dtype2.kind == \"u\"\n            ):\n                return \"u\"\n            return None\n\n        def float_result_type(dtype, dtype2):\n            typs = {dtype.kind, dtype2.kind}\n            if not len(typs - {\"f\", \"i\", \"u\"}) and (\n                dtype.kind == \"f\" or dtype2.kind == \"f\"\n            ):\n                return \"f\"\n            return None\n\n        def get_result_type(dtype, dtype2):\n            result = float_result_type(dtype, dtype2)\n            if result is not None:\n                return result\n            result = int_result_type(dtype, dtype2)\n            if result is not None:\n                return result\n            return \"O\"\n\n        for dtype in dtypes:\n            for dtype2 in dtypes:\n                if dtype == dtype2:\n                    continue\n\n                expected = get_result_type(dtype, dtype2)\n                result = pd.concat([Series(dtype=dtype), Series(dtype=dtype2)]).dtype\n                assert result.kind == expected",
        "begin_line": 167,
        "end_line": 212,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_combine_concat.TestSeriesCombine.int_result_type#176",
        "src_path": "pandas/tests/series/test_combine_concat.py",
        "class_name": "pandas.tests.series.test_combine_concat.TestSeriesCombine",
        "signature": "pandas.tests.series.test_combine_concat.TestSeriesCombine.int_result_type(dtype, dtype2)",
        "snippet": "        def int_result_type(dtype, dtype2):\n            typs = {dtype.kind, dtype2.kind}\n            if not len(typs - {\"i\", \"u\", \"b\"}) and (\n                dtype.kind == \"i\" or dtype2.kind == \"i\"\n            ):\n                return \"i\"\n            elif not len(typs - {\"u\", \"b\"}) and (\n                dtype.kind == \"u\" or dtype2.kind == \"u\"\n            ):\n                return \"u\"\n            return None",
        "begin_line": 176,
        "end_line": 186,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_combine_concat.TestSeriesCombine.float_result_type#188",
        "src_path": "pandas/tests/series/test_combine_concat.py",
        "class_name": "pandas.tests.series.test_combine_concat.TestSeriesCombine",
        "signature": "pandas.tests.series.test_combine_concat.TestSeriesCombine.float_result_type(dtype, dtype2)",
        "snippet": "        def float_result_type(dtype, dtype2):\n            typs = {dtype.kind, dtype2.kind}\n            if not len(typs - {\"f\", \"i\", \"u\"}) and (\n                dtype.kind == \"f\" or dtype2.kind == \"f\"\n            ):\n                return \"f\"\n            return None",
        "begin_line": 188,
        "end_line": 194,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_combine_concat.TestSeriesCombine.get_result_type#196",
        "src_path": "pandas/tests/series/test_combine_concat.py",
        "class_name": "pandas.tests.series.test_combine_concat.TestSeriesCombine",
        "signature": "pandas.tests.series.test_combine_concat.TestSeriesCombine.get_result_type(dtype, dtype2)",
        "snippet": "        def get_result_type(dtype, dtype2):\n            result = float_result_type(dtype, dtype2)\n            if result is not None:\n                return result\n            result = int_result_type(dtype, dtype2)\n            if result is not None:\n                return result\n            return \"O\"",
        "begin_line": 196,
        "end_line": 203,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_combine_first_dt_tz_values#214",
        "src_path": "pandas/tests/series/test_combine_concat.py",
        "class_name": "pandas.tests.series.test_combine_concat.TestSeriesCombine",
        "signature": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_combine_first_dt_tz_values(self, tz_naive_fixture)",
        "snippet": "    def test_combine_first_dt_tz_values(self, tz_naive_fixture):\n        ser1 = pd.Series(\n            pd.DatetimeIndex([\"20150101\", \"20150102\", \"20150103\"], tz=tz_naive_fixture),\n            name=\"ser1\",\n        )\n        ser2 = pd.Series(\n            pd.DatetimeIndex([\"20160514\", \"20160515\", \"20160516\"], tz=tz_naive_fixture),\n            index=[2, 3, 4],\n            name=\"ser2\",\n        )\n        result = ser1.combine_first(ser2)\n        exp_vals = pd.DatetimeIndex(\n            [\"20150101\", \"20150102\", \"20150103\", \"20160515\", \"20160516\"],\n            tz=tz_naive_fixture,\n        )\n        exp = pd.Series(exp_vals, name=\"ser1\")\n        assert_series_equal(exp, result)",
        "begin_line": 214,
        "end_line": 230,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_concat_empty_series_dtypes#234",
        "src_path": "pandas/tests/series/test_combine_concat.py",
        "class_name": "pandas.tests.series.test_combine_concat.TestSeriesCombine",
        "signature": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_concat_empty_series_dtypes(self)",
        "snippet": "    def test_concat_empty_series_dtypes(self):\n\n        # booleans\n        assert (\n            pd.concat([Series(dtype=np.bool_), Series(dtype=np.int32)]).dtype\n            == np.int32\n        )\n        assert (\n            pd.concat([Series(dtype=np.bool_), Series(dtype=np.float32)]).dtype\n            == np.object_\n        )\n\n        # datetime-like\n        assert (\n            pd.concat([Series(dtype=\"m8[ns]\"), Series(dtype=np.bool)]).dtype\n            == np.object_\n        )\n        assert (\n            pd.concat([Series(dtype=\"m8[ns]\"), Series(dtype=np.int64)]).dtype\n            == np.object_\n        )\n        assert (\n            pd.concat([Series(dtype=\"M8[ns]\"), Series(dtype=np.bool)]).dtype\n            == np.object_\n        )\n        assert (\n            pd.concat([Series(dtype=\"M8[ns]\"), Series(dtype=np.int64)]).dtype\n            == np.object_\n        )\n        assert (\n            pd.concat(\n                [Series(dtype=\"M8[ns]\"), Series(dtype=np.bool_), Series(dtype=np.int64)]\n            ).dtype\n            == np.object_\n        )\n\n        # categorical\n        assert (\n            pd.concat([Series(dtype=\"category\"), Series(dtype=\"category\")]).dtype\n            == \"category\"\n        )\n        # GH 18515\n        assert (\n            pd.concat(\n                [Series(np.array([]), dtype=\"category\"), Series(dtype=\"float64\")]\n            ).dtype\n            == \"float64\"\n        )\n        assert (\n            pd.concat([Series(dtype=\"category\"), Series(dtype=\"object\")]).dtype\n            == \"object\"\n        )\n\n        # sparse\n        # TODO: move?\n        result = pd.concat(\n            [Series(dtype=\"float64\").to_sparse(), Series(dtype=\"float64\").to_sparse()]\n        )\n        assert result.dtype == \"Sparse[float64]\"\n\n        # GH 26705 - Assert .ftype is deprecated\n        with tm.assert_produces_warning(FutureWarning):\n            assert result.ftype == \"float64:sparse\"\n\n        result = pd.concat(\n            [Series(dtype=\"float64\").to_sparse(), Series(dtype=\"float64\")]\n        )\n        # TODO: release-note: concat sparse dtype\n        expected = pd.core.sparse.api.SparseDtype(np.float64)\n        assert result.dtype == expected\n\n        # GH 26705 - Assert .ftype is deprecated\n        with tm.assert_produces_warning(FutureWarning):\n            assert result.ftype == \"float64:sparse\"\n\n        result = pd.concat(\n            [Series(dtype=\"float64\").to_sparse(), Series(dtype=\"object\")]\n        )\n        # TODO: release-note: concat sparse dtype\n        expected = pd.core.sparse.api.SparseDtype(\"object\")\n        assert result.dtype == expected\n\n        # GH 26705 - Assert .ftype is deprecated\n        with tm.assert_produces_warning(FutureWarning):\n            assert result.ftype == \"object:sparse\"",
        "begin_line": 234,
        "end_line": 318,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_combine_first_dt64#320",
        "src_path": "pandas/tests/series/test_combine_concat.py",
        "class_name": "pandas.tests.series.test_combine_concat.TestSeriesCombine",
        "signature": "pandas.tests.series.test_combine_concat.TestSeriesCombine.test_combine_first_dt64(self)",
        "snippet": "    def test_combine_first_dt64(self):\n        from pandas.core.tools.datetimes import to_datetime\n\n        s0 = to_datetime(Series([\"2010\", np.NaN]))\n        s1 = to_datetime(Series([np.NaN, \"2011\"]))\n        rs = s0.combine_first(s1)\n        xp = to_datetime(Series([\"2010\", \"2011\"]))\n        assert_series_equal(rs, xp)\n\n        s0 = to_datetime(Series([\"2010\", np.NaN]))\n        s1 = Series([np.NaN, \"2011\"])\n        rs = s0.combine_first(s1)\n        xp = Series([datetime(2010, 1, 1), \"2011\"])\n        assert_series_equal(rs, xp)",
        "begin_line": 320,
        "end_line": 333,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_combine_concat.TestTimeseries.test_append_concat#337",
        "src_path": "pandas/tests/series/test_combine_concat.py",
        "class_name": "pandas.tests.series.test_combine_concat.TestTimeseries",
        "signature": "pandas.tests.series.test_combine_concat.TestTimeseries.test_append_concat(self)",
        "snippet": "    def test_append_concat(self):\n        rng = date_range(\"5/8/2012 1:45\", periods=10, freq=\"5T\")\n        ts = Series(np.random.randn(len(rng)), rng)\n        df = DataFrame(np.random.randn(len(rng), 4), index=rng)\n\n        result = ts.append(ts)\n        result_df = df.append(df)\n        ex_index = DatetimeIndex(np.tile(rng.values, 2))\n        tm.assert_index_equal(result.index, ex_index)\n        tm.assert_index_equal(result_df.index, ex_index)\n\n        appended = rng.append(rng)\n        tm.assert_index_equal(appended, ex_index)\n\n        appended = rng.append([rng, rng])\n        ex_index = DatetimeIndex(np.tile(rng.values, 3))\n        tm.assert_index_equal(appended, ex_index)\n\n        # different index names\n        rng1 = rng.copy()\n        rng2 = rng.copy()\n        rng1.name = \"foo\"\n        rng2.name = \"bar\"\n        assert rng1.append(rng1).name == \"foo\"\n        assert rng1.append(rng2).name is None",
        "begin_line": 337,
        "end_line": 361,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_combine_concat.TestTimeseries.test_append_concat_tz#363",
        "src_path": "pandas/tests/series/test_combine_concat.py",
        "class_name": "pandas.tests.series.test_combine_concat.TestTimeseries",
        "signature": "pandas.tests.series.test_combine_concat.TestTimeseries.test_append_concat_tz(self)",
        "snippet": "    def test_append_concat_tz(self):\n        # see gh-2938\n        rng = date_range(\"5/8/2012 1:45\", periods=10, freq=\"5T\", tz=\"US/Eastern\")\n        rng2 = date_range(\"5/8/2012 2:35\", periods=10, freq=\"5T\", tz=\"US/Eastern\")\n        rng3 = date_range(\"5/8/2012 1:45\", periods=20, freq=\"5T\", tz=\"US/Eastern\")\n        ts = Series(np.random.randn(len(rng)), rng)\n        df = DataFrame(np.random.randn(len(rng), 4), index=rng)\n        ts2 = Series(np.random.randn(len(rng2)), rng2)\n        df2 = DataFrame(np.random.randn(len(rng2), 4), index=rng2)\n\n        result = ts.append(ts2)\n        result_df = df.append(df2)\n        tm.assert_index_equal(result.index, rng3)\n        tm.assert_index_equal(result_df.index, rng3)\n\n        appended = rng.append(rng2)\n        tm.assert_index_equal(appended, rng3)",
        "begin_line": 363,
        "end_line": 379,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_combine_concat.TestTimeseries.test_append_concat_tz_explicit_pytz#381",
        "src_path": "pandas/tests/series/test_combine_concat.py",
        "class_name": "pandas.tests.series.test_combine_concat.TestTimeseries",
        "signature": "pandas.tests.series.test_combine_concat.TestTimeseries.test_append_concat_tz_explicit_pytz(self)",
        "snippet": "    def test_append_concat_tz_explicit_pytz(self):\n        # see gh-2938\n        from pytz import timezone as timezone\n\n        rng = date_range(\n            \"5/8/2012 1:45\", periods=10, freq=\"5T\", tz=timezone(\"US/Eastern\")\n        )\n        rng2 = date_range(\n            \"5/8/2012 2:35\", periods=10, freq=\"5T\", tz=timezone(\"US/Eastern\")\n        )\n        rng3 = date_range(\n            \"5/8/2012 1:45\", periods=20, freq=\"5T\", tz=timezone(\"US/Eastern\")\n        )\n        ts = Series(np.random.randn(len(rng)), rng)\n        df = DataFrame(np.random.randn(len(rng), 4), index=rng)\n        ts2 = Series(np.random.randn(len(rng2)), rng2)\n        df2 = DataFrame(np.random.randn(len(rng2), 4), index=rng2)\n\n        result = ts.append(ts2)\n        result_df = df.append(df2)\n        tm.assert_index_equal(result.index, rng3)\n        tm.assert_index_equal(result_df.index, rng3)\n\n        appended = rng.append(rng2)\n        tm.assert_index_equal(appended, rng3)",
        "begin_line": 381,
        "end_line": 405,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_combine_concat.TestTimeseries.test_append_concat_tz_dateutil#407",
        "src_path": "pandas/tests/series/test_combine_concat.py",
        "class_name": "pandas.tests.series.test_combine_concat.TestTimeseries",
        "signature": "pandas.tests.series.test_combine_concat.TestTimeseries.test_append_concat_tz_dateutil(self)",
        "snippet": "    def test_append_concat_tz_dateutil(self):\n        # see gh-2938\n        rng = date_range(\n            \"5/8/2012 1:45\", periods=10, freq=\"5T\", tz=\"dateutil/US/Eastern\"\n        )\n        rng2 = date_range(\n            \"5/8/2012 2:35\", periods=10, freq=\"5T\", tz=\"dateutil/US/Eastern\"\n        )\n        rng3 = date_range(\n            \"5/8/2012 1:45\", periods=20, freq=\"5T\", tz=\"dateutil/US/Eastern\"\n        )\n        ts = Series(np.random.randn(len(rng)), rng)\n        df = DataFrame(np.random.randn(len(rng), 4), index=rng)\n        ts2 = Series(np.random.randn(len(rng2)), rng2)\n        df2 = DataFrame(np.random.randn(len(rng2), 4), index=rng2)\n\n        result = ts.append(ts2)\n        result_df = df.append(df2)\n        tm.assert_index_equal(result.index, rng3)\n        tm.assert_index_equal(result_df.index, rng3)\n\n        appended = rng.append(rng2)\n        tm.assert_index_equal(appended, rng3)",
        "begin_line": 407,
        "end_line": 429,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.indexing.conftest.test_data#7",
        "src_path": "pandas/tests/series/indexing/conftest.py",
        "class_name": "pandas.tests.series.indexing.conftest",
        "signature": "pandas.tests.series.indexing.conftest.test_data()",
        "snippet": "def test_data():\n    return TestData()",
        "begin_line": 7,
        "end_line": 8,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.common.TestData.ts#11",
        "src_path": "pandas/tests/series/common.py",
        "class_name": "pandas.tests.series.common.TestData",
        "signature": "pandas.tests.series.common.TestData.ts(self)",
        "snippet": "    def ts(self):\n        ts = _ts.copy()\n        ts.name = \"ts\"\n        return ts",
        "begin_line": 11,
        "end_line": 14,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.common.TestData.series#17",
        "src_path": "pandas/tests/series/common.py",
        "class_name": "pandas.tests.series.common.TestData",
        "signature": "pandas.tests.series.common.TestData.series(self)",
        "snippet": "    def series(self):\n        series = tm.makeStringSeries()\n        series.name = \"series\"\n        return series",
        "begin_line": 17,
        "end_line": 20,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.common.TestData.objSeries#23",
        "src_path": "pandas/tests/series/common.py",
        "class_name": "pandas.tests.series.common.TestData",
        "signature": "pandas.tests.series.common.TestData.objSeries(self)",
        "snippet": "    def objSeries(self):\n        objSeries = tm.makeObjectSeries()\n        objSeries.name = \"objects\"\n        return objSeries",
        "begin_line": 23,
        "end_line": 26,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.common.TestData.empty#29",
        "src_path": "pandas/tests/series/common.py",
        "class_name": "pandas.tests.series.common.TestData",
        "signature": "pandas.tests.series.common.TestData.empty(self)",
        "snippet": "    def empty(self):\n        return pd.Series([], index=[])",
        "begin_line": 29,
        "end_line": 30,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.conftest.datetime_series#7",
        "src_path": "pandas/tests/series/conftest.py",
        "class_name": "pandas.tests.series.conftest",
        "signature": "pandas.tests.series.conftest.datetime_series()",
        "snippet": "def datetime_series():\n    \"\"\"\n    Fixture for Series of floats with DatetimeIndex\n    \"\"\"\n    s = tm.makeTimeSeries()\n    s.name = \"ts\"\n    return s",
        "begin_line": 7,
        "end_line": 13,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.conftest.string_series#17",
        "src_path": "pandas/tests/series/conftest.py",
        "class_name": "pandas.tests.series.conftest",
        "signature": "pandas.tests.series.conftest.string_series()",
        "snippet": "def string_series():\n    \"\"\"\n    Fixture for Series of floats with Index of unique strings\n    \"\"\"\n    s = tm.makeStringSeries()\n    s.name = \"series\"\n    return s",
        "begin_line": 17,
        "end_line": 23,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.conftest.object_series#27",
        "src_path": "pandas/tests/series/conftest.py",
        "class_name": "pandas.tests.series.conftest",
        "signature": "pandas.tests.series.conftest.object_series()",
        "snippet": "def object_series():\n    \"\"\"\n    Fixture for Series of dtype datetime64[ns] with Index of unique strings\n    \"\"\"\n    s = tm.makeObjectSeries()\n    s.name = \"objects\"\n    return s",
        "begin_line": 27,
        "end_line": 33,
        "comment": "",
        "is_bug": false
    }
]