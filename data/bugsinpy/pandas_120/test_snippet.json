[
    {
        "name": "pandas.tests.groupby.test_categorical.cartesian_product_for_groupers#22",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.cartesian_product_for_groupers(result, args, names)",
        "snippet": "def cartesian_product_for_groupers(result, args, names):\n    \"\"\" Reindex to a cartesian production for the groupers,\n    preserving the nature (Categorical) of each grouper \"\"\"\n\n    def f(a):\n        if isinstance(a, (CategoricalIndex, Categorical)):\n            categories = a.categories\n            a = Categorical.from_codes(\n                np.arange(len(categories)), categories=categories, ordered=a.ordered\n            )\n        return a\n\n    index = MultiIndex.from_product(map(f, args), names=names)\n    return result.reindex(index).sort_index()",
        "begin_line": 22,
        "end_line": 35,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.f#26",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.f(a)",
        "snippet": "    def f(a):\n        if isinstance(a, (CategoricalIndex, Categorical)):\n            categories = a.categories\n            a = Categorical.from_codes(\n                np.arange(len(categories)), categories=categories, ordered=a.ordered\n            )\n        return a",
        "begin_line": 26,
        "end_line": 32,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_apply_use_categorical_name#38",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_apply_use_categorical_name(df)",
        "snippet": "def test_apply_use_categorical_name(df):\n    cats = qcut(df.C, 4)\n\n    def get_stats(group):\n        return {\n            \"min\": group.min(),\n            \"max\": group.max(),\n            \"count\": group.count(),\n            \"mean\": group.mean(),\n        }\n\n    result = df.groupby(cats, observed=False).D.apply(get_stats)\n    assert result.index.names[0] == \"C\"",
        "begin_line": 38,
        "end_line": 50,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.get_stats#41",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.get_stats(group)",
        "snippet": "    def get_stats(group):\n        return {\n            \"min\": group.min(),\n            \"max\": group.max(),\n            \"count\": group.count(),\n            \"mean\": group.mean(),\n        }",
        "begin_line": 41,
        "end_line": 47,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_basic#53",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_basic()",
        "snippet": "def test_basic():\n\n    cats = Categorical(\n        [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\"],\n        categories=[\"a\", \"b\", \"c\", \"d\"],\n        ordered=True,\n    )\n    data = DataFrame({\"a\": [1, 1, 1, 2, 2, 2, 3, 4, 5], \"b\": cats})\n\n    exp_index = CategoricalIndex(list(\"abcd\"), name=\"b\", ordered=True)\n    expected = DataFrame({\"a\": [1, 2, 4, np.nan]}, index=exp_index)\n    result = data.groupby(\"b\", observed=False).mean()\n    tm.assert_frame_equal(result, expected)\n\n    cat1 = Categorical([\"a\", \"a\", \"b\", \"b\"], categories=[\"a\", \"b\", \"z\"], ordered=True)\n    cat2 = Categorical([\"c\", \"d\", \"c\", \"d\"], categories=[\"c\", \"d\", \"y\"], ordered=True)\n    df = DataFrame({\"A\": cat1, \"B\": cat2, \"values\": [1, 2, 3, 4]})\n\n    # single grouper\n    gb = df.groupby(\"A\", observed=False)\n    exp_idx = CategoricalIndex([\"a\", \"b\", \"z\"], name=\"A\", ordered=True)\n    expected = DataFrame({\"values\": Series([3, 7, 0], index=exp_idx)})\n    result = gb.sum()\n    tm.assert_frame_equal(result, expected)\n\n    # GH 8623\n    x = DataFrame(\n        [[1, \"John P. Doe\"], [2, \"Jane Dove\"], [1, \"John P. Doe\"]],\n        columns=[\"person_id\", \"person_name\"],\n    )\n    x[\"person_name\"] = Categorical(x.person_name)\n\n    g = x.groupby([\"person_id\"], observed=False)\n    result = g.transform(lambda x: x)\n    tm.assert_frame_equal(result, x[[\"person_name\"]])\n\n    result = x.drop_duplicates(\"person_name\")\n    expected = x.iloc[[0, 1]]\n    tm.assert_frame_equal(result, expected)\n\n    def f(x):\n        return x.drop_duplicates(\"person_name\").iloc[0]\n\n    result = g.apply(f)\n    expected = x.iloc[[0, 1]].copy()\n    expected.index = Index([1, 2], name=\"person_id\")\n    expected[\"person_name\"] = expected[\"person_name\"].astype(\"object\")\n    tm.assert_frame_equal(result, expected)\n\n    # GH 9921\n    # Monotonic\n    df = DataFrame({\"a\": [5, 15, 25]})\n    c = pd.cut(df.a, bins=[0, 10, 20, 30, 40])\n\n    result = df.a.groupby(c, observed=False).transform(sum)\n    tm.assert_series_equal(result, df[\"a\"])\n\n    tm.assert_series_equal(\n        df.a.groupby(c, observed=False).transform(lambda xs: np.sum(xs)), df[\"a\"]\n    )\n    tm.assert_frame_equal(df.groupby(c, observed=False).transform(sum), df[[\"a\"]])\n    tm.assert_frame_equal(\n        df.groupby(c, observed=False).transform(lambda xs: np.max(xs)), df[[\"a\"]]\n    )\n\n    # Filter\n    tm.assert_series_equal(df.a.groupby(c, observed=False).filter(np.all), df[\"a\"])\n    tm.assert_frame_equal(df.groupby(c, observed=False).filter(np.all), df)\n\n    # Non-monotonic\n    df = DataFrame({\"a\": [5, 15, 25, -5]})\n    c = pd.cut(df.a, bins=[-10, 0, 10, 20, 30, 40])\n\n    result = df.a.groupby(c, observed=False).transform(sum)\n    tm.assert_series_equal(result, df[\"a\"])\n\n    tm.assert_series_equal(\n        df.a.groupby(c, observed=False).transform(lambda xs: np.sum(xs)), df[\"a\"]\n    )\n    tm.assert_frame_equal(df.groupby(c, observed=False).transform(sum), df[[\"a\"]])\n    tm.assert_frame_equal(\n        df.groupby(c, observed=False).transform(lambda xs: np.sum(xs)), df[[\"a\"]]\n    )\n\n    # GH 9603\n    df = DataFrame({\"a\": [1, 0, 0, 0]})\n    c = pd.cut(df.a, [0, 1, 2, 3, 4], labels=Categorical(list(\"abcd\")))\n    result = df.groupby(c, observed=False).apply(len)\n\n    exp_index = CategoricalIndex(c.values.categories, ordered=c.values.ordered)\n    expected = Series([1, 0, 0, 0], index=exp_index)\n    expected.index.name = \"a\"\n    tm.assert_series_equal(result, expected)\n\n    # more basic\n    levels = [\"foo\", \"bar\", \"baz\", \"qux\"]\n    codes = np.random.randint(0, 4, size=100)\n\n    cats = Categorical.from_codes(codes, levels, ordered=True)\n\n    data = DataFrame(np.random.randn(100, 4))\n\n    result = data.groupby(cats, observed=False).mean()\n\n    expected = data.groupby(np.asarray(cats), observed=False).mean()\n    exp_idx = CategoricalIndex(levels, categories=cats.categories, ordered=True)\n    expected = expected.reindex(exp_idx)\n\n    tm.assert_frame_equal(result, expected)\n\n    grouped = data.groupby(cats, observed=False)\n    desc_result = grouped.describe()\n\n    idx = cats.codes.argsort()\n    ord_labels = np.asarray(cats).take(idx)\n    ord_data = data.take(idx)\n\n    exp_cats = Categorical(\n        ord_labels, ordered=True, categories=[\"foo\", \"bar\", \"baz\", \"qux\"]\n    )\n    expected = ord_data.groupby(exp_cats, sort=False, observed=False).describe()\n    tm.assert_frame_equal(desc_result, expected)\n\n    # GH 10460\n    expc = Categorical.from_codes(np.arange(4).repeat(8), levels, ordered=True)\n    exp = CategoricalIndex(expc)\n    tm.assert_index_equal((desc_result.stack().index.get_level_values(0)), exp)\n    exp = Index([\"count\", \"mean\", \"std\", \"min\", \"25%\", \"50%\", \"75%\", \"max\"] * 4)\n    tm.assert_index_equal((desc_result.stack().index.get_level_values(1)), exp)",
        "begin_line": 53,
        "end_line": 181,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.f#93",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.f(x)",
        "snippet": "    def f(x):\n        return x.drop_duplicates(\"person_name\").iloc[0]",
        "begin_line": 93,
        "end_line": 94,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_level_get_group#184",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_level_get_group(observed)",
        "snippet": "def test_level_get_group(observed):\n    # GH15155\n    df = DataFrame(\n        data=np.arange(2, 22, 2),\n        index=MultiIndex(\n            levels=[CategoricalIndex([\"a\", \"b\"]), range(10)],\n            codes=[[0] * 5 + [1] * 5, range(10)],\n            names=[\"Index1\", \"Index2\"],\n        ),\n    )\n    g = df.groupby(level=[\"Index1\"], observed=observed)\n\n    # expected should equal test.loc[[\"a\"]]\n    # GH15166\n    expected = DataFrame(\n        data=np.arange(2, 12, 2),\n        index=MultiIndex(\n            levels=[CategoricalIndex([\"a\", \"b\"]), range(5)],\n            codes=[[0] * 5, range(5)],\n            names=[\"Index1\", \"Index2\"],\n        ),\n    )\n    result = g.get_group(\"a\")\n\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 184,
        "end_line": 208,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_apply#215",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_apply(ordered)",
        "snippet": "def test_apply(ordered):\n    # GH 10138\n\n    dense = Categorical(list(\"abc\"), ordered=ordered)\n\n    # 'b' is in the categories but not in the list\n    missing = Categorical(list(\"aaa\"), categories=[\"a\", \"b\"], ordered=ordered)\n    values = np.arange(len(dense))\n    df = DataFrame({\"missing\": missing, \"dense\": dense, \"values\": values})\n    grouped = df.groupby([\"missing\", \"dense\"], observed=True)\n\n    # missing category 'b' should still exist in the output index\n    idx = MultiIndex.from_arrays([missing, dense], names=[\"missing\", \"dense\"])\n    expected = DataFrame([0, 1, 2.0], index=idx, columns=[\"values\"])\n\n    # GH#21636 tracking down the xfail, in some builds np.mean(df.loc[[0]])\n    #  is coming back as Series([0., 1., 0.], index=[\"missing\", \"dense\", \"values\"])\n    #  when we expect Series(0., index=[\"values\"])\n    result = grouped.apply(lambda x: np.mean(x))\n    tm.assert_frame_equal(result, expected)\n\n    # we coerce back to ints\n    expected = expected.astype(\"int\")\n    result = grouped.mean()\n    tm.assert_frame_equal(result, expected)\n\n    result = grouped.agg(np.mean)\n    tm.assert_frame_equal(result, expected)\n\n    # but for transform we should still get back the original index\n    idx = MultiIndex.from_arrays([missing, dense], names=[\"missing\", \"dense\"])\n    expected = Series(1, index=idx)\n    result = grouped.apply(lambda x: 1)\n    tm.assert_series_equal(result, expected)",
        "begin_line": 215,
        "end_line": 248,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_observed#251",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_observed(observed)",
        "snippet": "def test_observed(observed):\n    # multiple groupers, don't re-expand the output space\n    # of the grouper\n    # gh-14942 (implement)\n    # gh-10132 (back-compat)\n    # gh-8138 (back-compat)\n    # gh-8869\n\n    cat1 = Categorical([\"a\", \"a\", \"b\", \"b\"], categories=[\"a\", \"b\", \"z\"], ordered=True)\n    cat2 = Categorical([\"c\", \"d\", \"c\", \"d\"], categories=[\"c\", \"d\", \"y\"], ordered=True)\n    df = DataFrame({\"A\": cat1, \"B\": cat2, \"values\": [1, 2, 3, 4]})\n    df[\"C\"] = [\"foo\", \"bar\"] * 2\n\n    # multiple groupers with a non-cat\n    gb = df.groupby([\"A\", \"B\", \"C\"], observed=observed)\n    exp_index = MultiIndex.from_arrays(\n        [cat1, cat2, [\"foo\", \"bar\"] * 2], names=[\"A\", \"B\", \"C\"]\n    )\n    expected = DataFrame({\"values\": Series([1, 2, 3, 4], index=exp_index)}).sort_index()\n    result = gb.sum()\n    if not observed:\n        expected = cartesian_product_for_groupers(\n            expected, [cat1, cat2, [\"foo\", \"bar\"]], list(\"ABC\")\n        )\n\n    tm.assert_frame_equal(result, expected)\n\n    gb = df.groupby([\"A\", \"B\"], observed=observed)\n    exp_index = MultiIndex.from_arrays([cat1, cat2], names=[\"A\", \"B\"])\n    expected = DataFrame({\"values\": [1, 2, 3, 4]}, index=exp_index)\n    result = gb.sum()\n    if not observed:\n        expected = cartesian_product_for_groupers(expected, [cat1, cat2], list(\"AB\"))\n\n    tm.assert_frame_equal(result, expected)\n\n    # https://github.com/pandas-dev/pandas/issues/8138\n    d = {\n        \"cat\": Categorical(\n            [\"a\", \"b\", \"a\", \"b\"], categories=[\"a\", \"b\", \"c\"], ordered=True\n        ),\n        \"ints\": [1, 1, 2, 2],\n        \"val\": [10, 20, 30, 40],\n    }\n    df = DataFrame(d)\n\n    # Grouping on a single column\n    groups_single_key = df.groupby(\"cat\", observed=observed)\n    result = groups_single_key.mean()\n\n    exp_index = CategoricalIndex(\n        list(\"ab\"), name=\"cat\", categories=list(\"abc\"), ordered=True\n    )\n    expected = DataFrame({\"ints\": [1.5, 1.5], \"val\": [20.0, 30]}, index=exp_index)\n    if not observed:\n        index = CategoricalIndex(\n            list(\"abc\"), name=\"cat\", categories=list(\"abc\"), ordered=True\n        )\n        expected = expected.reindex(index)\n\n    tm.assert_frame_equal(result, expected)\n\n    # Grouping on two columns\n    groups_double_key = df.groupby([\"cat\", \"ints\"], observed=observed)\n    result = groups_double_key.agg(\"mean\")\n    expected = DataFrame(\n        {\n            \"val\": [10, 30, 20, 40],\n            \"cat\": Categorical(\n                [\"a\", \"a\", \"b\", \"b\"], categories=[\"a\", \"b\", \"c\"], ordered=True\n            ),\n            \"ints\": [1, 2, 1, 2],\n        }\n    ).set_index([\"cat\", \"ints\"])\n    if not observed:\n        expected = cartesian_product_for_groupers(\n            expected, [df.cat.values, [1, 2]], [\"cat\", \"ints\"]\n        )\n\n    tm.assert_frame_equal(result, expected)\n\n    # GH 10132\n    for key in [(\"a\", 1), (\"b\", 2), (\"b\", 1), (\"a\", 2)]:\n        c, i = key\n        result = groups_double_key.get_group(key)\n        expected = df[(df.cat == c) & (df.ints == i)]\n        tm.assert_frame_equal(result, expected)\n\n    # gh-8869\n    # with as_index\n    d = {\n        \"foo\": [10, 8, 4, 8, 4, 1, 1],\n        \"bar\": [10, 20, 30, 40, 50, 60, 70],\n        \"baz\": [\"d\", \"c\", \"e\", \"a\", \"a\", \"d\", \"c\"],\n    }\n    df = DataFrame(d)\n    cat = pd.cut(df[\"foo\"], np.linspace(0, 10, 3))\n    df[\"range\"] = cat\n    groups = df.groupby([\"range\", \"baz\"], as_index=False, observed=observed)\n    result = groups.agg(\"mean\")\n\n    groups2 = df.groupby([\"range\", \"baz\"], as_index=True, observed=observed)\n    expected = groups2.agg(\"mean\").reset_index()\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 251,
        "end_line": 354,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_observed_codes_remap#357",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_observed_codes_remap(observed)",
        "snippet": "def test_observed_codes_remap(observed):\n    d = {\"C1\": [3, 3, 4, 5], \"C2\": [1, 2, 3, 4], \"C3\": [10, 100, 200, 34]}\n    df = DataFrame(d)\n    values = pd.cut(df[\"C1\"], [1, 2, 3, 6])\n    values.name = \"cat\"\n    groups_double_key = df.groupby([values, \"C2\"], observed=observed)\n\n    idx = MultiIndex.from_arrays([values, [1, 2, 3, 4]], names=[\"cat\", \"C2\"])\n    expected = DataFrame({\"C1\": [3, 3, 4, 5], \"C3\": [10, 100, 200, 34]}, index=idx)\n    if not observed:\n        expected = cartesian_product_for_groupers(\n            expected, [values.values, [1, 2, 3, 4]], [\"cat\", \"C2\"]\n        )\n\n    result = groups_double_key.agg(\"mean\")\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 357,
        "end_line": 372,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_observed_perf#375",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_observed_perf()",
        "snippet": "def test_observed_perf():\n    # we create a cartesian product, so this is\n    # non-performant if we don't use observed values\n    # gh-14942\n    df = DataFrame(\n        {\n            \"cat\": np.random.randint(0, 255, size=30000),\n            \"int_id\": np.random.randint(0, 255, size=30000),\n            \"other_id\": np.random.randint(0, 10000, size=30000),\n            \"foo\": 0,\n        }\n    )\n    df[\"cat\"] = df.cat.astype(str).astype(\"category\")\n\n    grouped = df.groupby([\"cat\", \"int_id\", \"other_id\"], observed=True)\n    result = grouped.count()\n    assert result.index.levels[0].nunique() == df.cat.nunique()\n    assert result.index.levels[1].nunique() == df.int_id.nunique()\n    assert result.index.levels[2].nunique() == df.other_id.nunique()",
        "begin_line": 375,
        "end_line": 393,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_observed_groups#396",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_observed_groups(observed)",
        "snippet": "def test_observed_groups(observed):\n    # gh-20583\n    # test that we have the appropriate groups\n\n    cat = Categorical([\"a\", \"c\", \"a\"], categories=[\"a\", \"b\", \"c\"])\n    df = DataFrame({\"cat\": cat, \"vals\": [1, 2, 3]})\n    g = df.groupby(\"cat\", observed=observed)\n\n    result = g.groups\n    if observed:\n        expected = {\"a\": Index([0, 2], dtype=\"int64\"), \"c\": Index([1], dtype=\"int64\")}\n    else:\n        expected = {\n            \"a\": Index([0, 2], dtype=\"int64\"),\n            \"b\": Index([], dtype=\"int64\"),\n            \"c\": Index([1], dtype=\"int64\"),\n        }\n\n    tm.assert_dict_equal(result, expected)",
        "begin_line": 396,
        "end_line": 414,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_observed_groups_with_nan#417",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_observed_groups_with_nan(observed)",
        "snippet": "def test_observed_groups_with_nan(observed):\n    # GH 24740\n    df = DataFrame(\n        {\n            \"cat\": Categorical([\"a\", np.nan, \"a\"], categories=[\"a\", \"b\", \"d\"]),\n            \"vals\": [1, 2, 3],\n        }\n    )\n    g = df.groupby(\"cat\", observed=observed)\n    result = g.groups\n    if observed:\n        expected = {\"a\": Index([0, 2], dtype=\"int64\")}\n    else:\n        expected = {\n            \"a\": Index([0, 2], dtype=\"int64\"),\n            \"b\": Index([], dtype=\"int64\"),\n            \"d\": Index([], dtype=\"int64\"),\n        }\n    tm.assert_dict_equal(result, expected)",
        "begin_line": 417,
        "end_line": 435,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_observed_nth#438",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_observed_nth()",
        "snippet": "def test_observed_nth():\n    # GH 26385\n    cat = pd.Categorical([\"a\", np.nan, np.nan], categories=[\"a\", \"b\", \"c\"])\n    ser = pd.Series([1, 2, 3])\n    df = pd.DataFrame({\"cat\": cat, \"ser\": ser})\n\n    result = df.groupby(\"cat\", observed=False)[\"ser\"].nth(0)\n\n    index = pd.Categorical([\"a\", \"b\", \"c\"], categories=[\"a\", \"b\", \"c\"])\n    expected = pd.Series([1, np.nan, np.nan], index=index, name=\"ser\")\n    expected.index.name = \"cat\"\n\n    tm.assert_series_equal(result, expected)",
        "begin_line": 438,
        "end_line": 450,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_dataframe_categorical_with_nan#453",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_dataframe_categorical_with_nan(observed)",
        "snippet": "def test_dataframe_categorical_with_nan(observed):\n    # GH 21151\n    s1 = Categorical([np.nan, \"a\", np.nan, \"a\"], categories=[\"a\", \"b\", \"c\"])\n    s2 = Series([1, 2, 3, 4])\n    df = DataFrame({\"s1\": s1, \"s2\": s2})\n    result = df.groupby(\"s1\", observed=observed).first().reset_index()\n    if observed:\n        expected = DataFrame(\n            {\"s1\": Categorical([\"a\"], categories=[\"a\", \"b\", \"c\"]), \"s2\": [2]}\n        )\n    else:\n        expected = DataFrame(\n            {\n                \"s1\": Categorical([\"a\", \"b\", \"c\"], categories=[\"a\", \"b\", \"c\"]),\n                \"s2\": [2, np.nan, np.nan],\n            }\n        )\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 453,
        "end_line": 470,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_dataframe_categorical_ordered_observed_sort#476",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_dataframe_categorical_ordered_observed_sort(ordered, observed, sort)",
        "snippet": "def test_dataframe_categorical_ordered_observed_sort(ordered, observed, sort):\n    # GH 25871: Fix groupby sorting on ordered Categoricals\n    # GH 25167: Groupby with observed=True doesn't sort\n\n    # Build a dataframe with cat having one unobserved category ('missing'),\n    # and a Series with identical values\n    label = Categorical(\n        [\"d\", \"a\", \"b\", \"a\", \"d\", \"b\"],\n        categories=[\"a\", \"b\", \"missing\", \"d\"],\n        ordered=ordered,\n    )\n    val = Series([\"d\", \"a\", \"b\", \"a\", \"d\", \"b\"])\n    df = DataFrame({\"label\": label, \"val\": val})\n\n    # aggregate on the Categorical\n    result = df.groupby(\"label\", observed=observed, sort=sort)[\"val\"].aggregate(\"first\")\n\n    # If ordering works, we expect index labels equal to aggregation results,\n    # except for 'observed=False': label 'missing' has aggregation None\n    label = Series(result.index.array, dtype=\"object\")\n    aggr = Series(result.array)\n    if not observed:\n        aggr[aggr.isna()] = \"missing\"\n    if not all(label == aggr):\n        msg = (\n            \"Labels and aggregation results not consistently sorted\\n\"\n            + \"for (ordered={}, observed={}, sort={})\\n\"\n            + \"Result:\\n{}\"\n        ).format(ordered, observed, sort, result)\n        assert False, msg",
        "begin_line": 476,
        "end_line": 505,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_datetime#508",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_datetime()",
        "snippet": "def test_datetime():\n    # GH9049: ensure backward compatibility\n    levels = pd.date_range(\"2014-01-01\", periods=4)\n    codes = np.random.randint(0, 4, size=100)\n\n    cats = Categorical.from_codes(codes, levels, ordered=True)\n\n    data = DataFrame(np.random.randn(100, 4))\n    result = data.groupby(cats, observed=False).mean()\n\n    expected = data.groupby(np.asarray(cats), observed=False).mean()\n    expected = expected.reindex(levels)\n    expected.index = CategoricalIndex(\n        expected.index, categories=expected.index, ordered=True\n    )\n\n    tm.assert_frame_equal(result, expected)\n\n    grouped = data.groupby(cats, observed=False)\n    desc_result = grouped.describe()\n\n    idx = cats.codes.argsort()\n    ord_labels = cats.take(idx)\n    ord_data = data.take(idx)\n    expected = ord_data.groupby(ord_labels, observed=False).describe()\n    tm.assert_frame_equal(desc_result, expected)\n    tm.assert_index_equal(desc_result.index, expected.index)\n    tm.assert_index_equal(\n        desc_result.index.get_level_values(0), expected.index.get_level_values(0)\n    )\n\n    # GH 10460\n    expc = Categorical.from_codes(np.arange(4).repeat(8), levels, ordered=True)\n    exp = CategoricalIndex(expc)\n    tm.assert_index_equal((desc_result.stack().index.get_level_values(0)), exp)\n    exp = Index([\"count\", \"mean\", \"std\", \"min\", \"25%\", \"50%\", \"75%\", \"max\"] * 4)\n    tm.assert_index_equal((desc_result.stack().index.get_level_values(1)), exp)",
        "begin_line": 508,
        "end_line": 544,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_categorical_index#547",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_categorical_index()",
        "snippet": "def test_categorical_index():\n\n    s = np.random.RandomState(12345)\n    levels = [\"foo\", \"bar\", \"baz\", \"qux\"]\n    codes = s.randint(0, 4, size=20)\n    cats = Categorical.from_codes(codes, levels, ordered=True)\n    df = DataFrame(np.repeat(np.arange(20), 4).reshape(-1, 4), columns=list(\"abcd\"))\n    df[\"cats\"] = cats\n\n    # with a cat index\n    result = df.set_index(\"cats\").groupby(level=0, observed=False).sum()\n    expected = df[list(\"abcd\")].groupby(cats.codes, observed=False).sum()\n    expected.index = CategoricalIndex(\n        Categorical.from_codes([0, 1, 2, 3], levels, ordered=True), name=\"cats\"\n    )\n    tm.assert_frame_equal(result, expected)\n\n    # with a cat column, should produce a cat index\n    result = df.groupby(\"cats\", observed=False).sum()\n    expected = df[list(\"abcd\")].groupby(cats.codes, observed=False).sum()\n    expected.index = CategoricalIndex(\n        Categorical.from_codes([0, 1, 2, 3], levels, ordered=True), name=\"cats\"\n    )\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 547,
        "end_line": 570,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_describe_categorical_columns#573",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_describe_categorical_columns()",
        "snippet": "def test_describe_categorical_columns():\n    # GH 11558\n    cats = CategoricalIndex(\n        [\"qux\", \"foo\", \"baz\", \"bar\"],\n        categories=[\"foo\", \"bar\", \"baz\", \"qux\"],\n        ordered=True,\n    )\n    df = DataFrame(np.random.randn(20, 4), columns=cats)\n    result = df.groupby([1, 2, 3, 4] * 5).describe()\n\n    tm.assert_index_equal(result.stack().columns, cats)\n    tm.assert_categorical_equal(result.stack().columns.values, cats.values)",
        "begin_line": 573,
        "end_line": 584,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_unstack_categorical#587",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_unstack_categorical()",
        "snippet": "def test_unstack_categorical():\n    # GH11558 (example is taken from the original issue)\n    df = DataFrame(\n        {\"a\": range(10), \"medium\": [\"A\", \"B\"] * 5, \"artist\": list(\"XYXXY\") * 2}\n    )\n    df[\"medium\"] = df[\"medium\"].astype(\"category\")\n\n    gcat = df.groupby([\"artist\", \"medium\"], observed=False)[\"a\"].count().unstack()\n    result = gcat.describe()\n\n    exp_columns = CategoricalIndex([\"A\", \"B\"], ordered=False, name=\"medium\")\n    tm.assert_index_equal(result.columns, exp_columns)\n    tm.assert_categorical_equal(result.columns.values, exp_columns.values)\n\n    result = gcat[\"A\"] + gcat[\"B\"]\n    expected = Series([6, 4], index=Index([\"X\", \"Y\"], name=\"artist\"))\n    tm.assert_series_equal(result, expected)",
        "begin_line": 587,
        "end_line": 603,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_bins_unequal_len#606",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_bins_unequal_len()",
        "snippet": "def test_bins_unequal_len():\n    # GH3011\n    series = Series([np.nan, np.nan, 1, 1, 2, 2, 3, 3, 4, 4])\n    bins = pd.cut(series.dropna().values, 4)\n\n    # len(bins) != len(series) here\n    with pytest.raises(ValueError):\n        series.groupby(bins).mean()",
        "begin_line": 606,
        "end_line": 613,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_as_index#616",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_as_index()",
        "snippet": "def test_as_index():\n    # GH13204\n    df = DataFrame(\n        {\n            \"cat\": Categorical([1, 2, 2], [1, 2, 3]),\n            \"A\": [10, 11, 11],\n            \"B\": [101, 102, 103],\n        }\n    )\n    result = df.groupby([\"cat\", \"A\"], as_index=False, observed=True).sum()\n    expected = DataFrame(\n        {\n            \"cat\": Categorical([1, 2], categories=df.cat.cat.categories),\n            \"A\": [10, 11],\n            \"B\": [101, 205],\n        },\n        columns=[\"cat\", \"A\", \"B\"],\n    )\n    tm.assert_frame_equal(result, expected)\n\n    # function grouper\n    f = lambda r: df.loc[r, \"A\"]\n    result = df.groupby([\"cat\", f], as_index=False, observed=True).sum()\n    expected = DataFrame(\n        {\n            \"cat\": Categorical([1, 2], categories=df.cat.cat.categories),\n            \"A\": [10, 22],\n            \"B\": [101, 205],\n        },\n        columns=[\"cat\", \"A\", \"B\"],\n    )\n    tm.assert_frame_equal(result, expected)\n\n    # another not in-axis grouper (conflicting names in index)\n    s = Series([\"a\", \"b\", \"b\"], name=\"cat\")\n    result = df.groupby([\"cat\", s], as_index=False, observed=True).sum()\n    tm.assert_frame_equal(result, expected)\n\n    # is original index dropped?\n    group_columns = [\"cat\", \"A\"]\n    expected = DataFrame(\n        {\n            \"cat\": Categorical([1, 2], categories=df.cat.cat.categories),\n            \"A\": [10, 11],\n            \"B\": [101, 205],\n        },\n        columns=[\"cat\", \"A\", \"B\"],\n    )\n\n    for name in [None, \"X\", \"B\"]:\n        df.index = Index(list(\"abc\"), name=name)\n        result = df.groupby(group_columns, as_index=False, observed=True).sum()\n\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 616,
        "end_line": 669,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_preserve_categories#672",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_preserve_categories()",
        "snippet": "def test_preserve_categories():\n    # GH-13179\n    categories = list(\"abc\")\n\n    # ordered=True\n    df = DataFrame({\"A\": Categorical(list(\"ba\"), categories=categories, ordered=True)})\n    index = CategoricalIndex(categories, categories, ordered=True, name=\"A\")\n    tm.assert_index_equal(\n        df.groupby(\"A\", sort=True, observed=False).first().index, index\n    )\n    tm.assert_index_equal(\n        df.groupby(\"A\", sort=False, observed=False).first().index, index\n    )\n\n    # ordered=False\n    df = DataFrame({\"A\": Categorical(list(\"ba\"), categories=categories, ordered=False)})\n    sort_index = CategoricalIndex(categories, categories, ordered=False, name=\"A\")\n    nosort_index = CategoricalIndex(list(\"bac\"), list(\"bac\"), ordered=False, name=\"A\")\n    tm.assert_index_equal(\n        df.groupby(\"A\", sort=True, observed=False).first().index, sort_index\n    )\n    tm.assert_index_equal(\n        df.groupby(\"A\", sort=False, observed=False).first().index, nosort_index\n    )",
        "begin_line": 672,
        "end_line": 695,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_preserve_categorical_dtype#698",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_preserve_categorical_dtype()",
        "snippet": "def test_preserve_categorical_dtype():\n    # GH13743, GH13854\n    df = DataFrame(\n        {\n            \"A\": [1, 2, 1, 1, 2],\n            \"B\": [10, 16, 22, 28, 34],\n            \"C1\": Categorical(list(\"abaab\"), categories=list(\"bac\"), ordered=False),\n            \"C2\": Categorical(list(\"abaab\"), categories=list(\"bac\"), ordered=True),\n        }\n    )\n    # single grouper\n    exp_full = DataFrame(\n        {\n            \"A\": [2.0, 1.0, np.nan],\n            \"B\": [25.0, 20.0, np.nan],\n            \"C1\": Categorical(list(\"bac\"), categories=list(\"bac\"), ordered=False),\n            \"C2\": Categorical(list(\"bac\"), categories=list(\"bac\"), ordered=True),\n        }\n    )\n    for col in [\"C1\", \"C2\"]:\n        result1 = df.groupby(by=col, as_index=False, observed=False).mean()\n        result2 = df.groupby(by=col, as_index=True, observed=False).mean().reset_index()\n        expected = exp_full.reindex(columns=result1.columns)\n        tm.assert_frame_equal(result1, expected)\n        tm.assert_frame_equal(result2, expected)",
        "begin_line": 698,
        "end_line": 722,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_preserve_on_ordered_ops#734",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_preserve_on_ordered_ops(func, values)",
        "snippet": "def test_preserve_on_ordered_ops(func, values):\n    # gh-18502\n    # preserve the categoricals on ops\n    c = pd.Categorical([\"first\", \"second\", \"third\", \"fourth\"], ordered=True)\n    df = pd.DataFrame({\"payload\": [-1, -2, -1, -2], \"col\": c})\n    g = df.groupby(\"payload\")\n    result = getattr(g, func)()\n    expected = pd.DataFrame(\n        {\"payload\": [-2, -1], \"col\": pd.Series(values, dtype=c.dtype)}\n    ).set_index(\"payload\")\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 734,
        "end_line": 744,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_categorical_no_compress#747",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_categorical_no_compress()",
        "snippet": "def test_categorical_no_compress():\n    data = Series(np.random.randn(9))\n\n    codes = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2])\n    cats = Categorical.from_codes(codes, [0, 1, 2], ordered=True)\n\n    result = data.groupby(cats, observed=False).mean()\n    exp = data.groupby(codes, observed=False).mean()\n\n    exp.index = CategoricalIndex(\n        exp.index, categories=cats.categories, ordered=cats.ordered\n    )\n    tm.assert_series_equal(result, exp)\n\n    codes = np.array([0, 0, 0, 1, 1, 1, 3, 3, 3])\n    cats = Categorical.from_codes(codes, [0, 1, 2, 3], ordered=True)\n\n    result = data.groupby(cats, observed=False).mean()\n    exp = data.groupby(codes, observed=False).mean().reindex(cats.categories)\n    exp.index = CategoricalIndex(\n        exp.index, categories=cats.categories, ordered=cats.ordered\n    )\n    tm.assert_series_equal(result, exp)\n\n    cats = Categorical(\n        [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\"],\n        categories=[\"a\", \"b\", \"c\", \"d\"],\n        ordered=True,\n    )\n    data = DataFrame({\"a\": [1, 1, 1, 2, 2, 2, 3, 4, 5], \"b\": cats})\n\n    result = data.groupby(\"b\", observed=False).mean()\n    result = result[\"a\"].values\n    exp = np.array([1, 2, 4, np.nan])\n    tm.assert_numpy_array_equal(result, exp)",
        "begin_line": 747,
        "end_line": 781,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_groupby_empty_with_category#784",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_groupby_empty_with_category()",
        "snippet": "def test_groupby_empty_with_category():\n    # GH-9614\n    # test fix for when group by on None resulted in\n    # coercion of dtype categorical -> float\n    df = pd.DataFrame(\n        {\"A\": [None] * 3, \"B\": pd.Categorical([\"train\", \"train\", \"test\"])}\n    )\n    result = df.groupby(\"A\").first()[\"B\"]\n    expected = pd.Series(\n        pd.Categorical([], categories=[\"test\", \"train\"]),\n        index=pd.Series([], dtype=\"object\", name=\"A\"),\n        name=\"B\",\n    )\n    tm.assert_series_equal(result, expected)",
        "begin_line": 784,
        "end_line": 797,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_sort#800",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_sort()",
        "snippet": "def test_sort():\n\n    # http://stackoverflow.com/questions/23814368/sorting-pandas-\n    #        categorical-labels-after-groupby\n    # This should result in a properly sorted Series so that the plot\n    # has a sorted x axis\n    # self.cat.groupby(['value_group'])['value_group'].count().plot(kind='bar')\n\n    df = DataFrame({\"value\": np.random.randint(0, 10000, 100)})\n    labels = [\"{0} - {1}\".format(i, i + 499) for i in range(0, 10000, 500)]\n    cat_labels = Categorical(labels, labels)\n\n    df = df.sort_values(by=[\"value\"], ascending=True)\n    df[\"value_group\"] = pd.cut(\n        df.value, range(0, 10500, 500), right=False, labels=cat_labels\n    )\n\n    res = df.groupby([\"value_group\"], observed=False)[\"value_group\"].count()\n    exp = res[sorted(res.index, key=lambda x: float(x.split()[0]))]\n    exp.index = CategoricalIndex(exp.index, name=exp.index.name)\n    tm.assert_series_equal(res, exp)",
        "begin_line": 800,
        "end_line": 820,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_sort2#823",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_sort2()",
        "snippet": "def test_sort2():\n    # dataframe groupby sort was being ignored # GH 8868\n    df = DataFrame(\n        [\n            [\"(7.5, 10]\", 10, 10],\n            [\"(7.5, 10]\", 8, 20],\n            [\"(2.5, 5]\", 5, 30],\n            [\"(5, 7.5]\", 6, 40],\n            [\"(2.5, 5]\", 4, 50],\n            [\"(0, 2.5]\", 1, 60],\n            [\"(5, 7.5]\", 7, 70],\n        ],\n        columns=[\"range\", \"foo\", \"bar\"],\n    )\n    df[\"range\"] = Categorical(df[\"range\"], ordered=True)\n    index = CategoricalIndex(\n        [\"(0, 2.5]\", \"(2.5, 5]\", \"(5, 7.5]\", \"(7.5, 10]\"], name=\"range\", ordered=True\n    )\n    expected_sort = DataFrame(\n        [[1, 60], [5, 30], [6, 40], [10, 10]], columns=[\"foo\", \"bar\"], index=index\n    )\n\n    col = \"range\"\n    result_sort = df.groupby(col, sort=True, observed=False).first()\n    tm.assert_frame_equal(result_sort, expected_sort)\n\n    # when categories is ordered, group is ordered by category's order\n    expected_sort = result_sort\n    result_sort = df.groupby(col, sort=False, observed=False).first()\n    tm.assert_frame_equal(result_sort, expected_sort)\n\n    df[\"range\"] = Categorical(df[\"range\"], ordered=False)\n    index = CategoricalIndex(\n        [\"(0, 2.5]\", \"(2.5, 5]\", \"(5, 7.5]\", \"(7.5, 10]\"], name=\"range\"\n    )\n    expected_sort = DataFrame(\n        [[1, 60], [5, 30], [6, 40], [10, 10]], columns=[\"foo\", \"bar\"], index=index\n    )\n\n    index = CategoricalIndex(\n        [\"(7.5, 10]\", \"(2.5, 5]\", \"(5, 7.5]\", \"(0, 2.5]\"],\n        categories=[\"(7.5, 10]\", \"(2.5, 5]\", \"(5, 7.5]\", \"(0, 2.5]\"],\n        name=\"range\",\n    )\n    expected_nosort = DataFrame(\n        [[10, 10], [5, 30], [6, 40], [1, 60]], index=index, columns=[\"foo\", \"bar\"]\n    )\n\n    col = \"range\"\n\n    # this is an unordered categorical, but we allow this ####\n    result_sort = df.groupby(col, sort=True, observed=False).first()\n    tm.assert_frame_equal(result_sort, expected_sort)\n\n    result_nosort = df.groupby(col, sort=False, observed=False).first()\n    tm.assert_frame_equal(result_nosort, expected_nosort)",
        "begin_line": 823,
        "end_line": 878,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_sort_datetimelike#881",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_sort_datetimelike()",
        "snippet": "def test_sort_datetimelike():\n    # GH10505\n\n    # use same data as test_groupby_sort_categorical, which category is\n    # corresponding to datetime.month\n    df = DataFrame(\n        {\n            \"dt\": [\n                datetime(2011, 7, 1),\n                datetime(2011, 7, 1),\n                datetime(2011, 2, 1),\n                datetime(2011, 5, 1),\n                datetime(2011, 2, 1),\n                datetime(2011, 1, 1),\n                datetime(2011, 5, 1),\n            ],\n            \"foo\": [10, 8, 5, 6, 4, 1, 7],\n            \"bar\": [10, 20, 30, 40, 50, 60, 70],\n        },\n        columns=[\"dt\", \"foo\", \"bar\"],\n    )\n\n    # ordered=True\n    df[\"dt\"] = Categorical(df[\"dt\"], ordered=True)\n    index = [\n        datetime(2011, 1, 1),\n        datetime(2011, 2, 1),\n        datetime(2011, 5, 1),\n        datetime(2011, 7, 1),\n    ]\n    result_sort = DataFrame(\n        [[1, 60], [5, 30], [6, 40], [10, 10]], columns=[\"foo\", \"bar\"]\n    )\n    result_sort.index = CategoricalIndex(index, name=\"dt\", ordered=True)\n\n    index = [\n        datetime(2011, 7, 1),\n        datetime(2011, 2, 1),\n        datetime(2011, 5, 1),\n        datetime(2011, 1, 1),\n    ]\n    result_nosort = DataFrame(\n        [[10, 10], [5, 30], [6, 40], [1, 60]], columns=[\"foo\", \"bar\"]\n    )\n    result_nosort.index = CategoricalIndex(\n        index, categories=index, name=\"dt\", ordered=True\n    )\n\n    col = \"dt\"\n    tm.assert_frame_equal(\n        result_sort, df.groupby(col, sort=True, observed=False).first()\n    )\n\n    # when categories is ordered, group is ordered by category's order\n    tm.assert_frame_equal(\n        result_sort, df.groupby(col, sort=False, observed=False).first()\n    )\n\n    # ordered = False\n    df[\"dt\"] = Categorical(df[\"dt\"], ordered=False)\n    index = [\n        datetime(2011, 1, 1),\n        datetime(2011, 2, 1),\n        datetime(2011, 5, 1),\n        datetime(2011, 7, 1),\n    ]\n    result_sort = DataFrame(\n        [[1, 60], [5, 30], [6, 40], [10, 10]], columns=[\"foo\", \"bar\"]\n    )\n    result_sort.index = CategoricalIndex(index, name=\"dt\")\n\n    index = [\n        datetime(2011, 7, 1),\n        datetime(2011, 2, 1),\n        datetime(2011, 5, 1),\n        datetime(2011, 1, 1),\n    ]\n    result_nosort = DataFrame(\n        [[10, 10], [5, 30], [6, 40], [1, 60]], columns=[\"foo\", \"bar\"]\n    )\n    result_nosort.index = CategoricalIndex(index, categories=index, name=\"dt\")\n\n    col = \"dt\"\n    tm.assert_frame_equal(\n        result_sort, df.groupby(col, sort=True, observed=False).first()\n    )\n    tm.assert_frame_equal(\n        result_nosort, df.groupby(col, sort=False, observed=False).first()\n    )",
        "begin_line": 881,
        "end_line": 969,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_empty_sum#972",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_empty_sum()",
        "snippet": "def test_empty_sum():\n    # https://github.com/pandas-dev/pandas/issues/18678\n    df = DataFrame(\n        {\"A\": Categorical([\"a\", \"a\", \"b\"], categories=[\"a\", \"b\", \"c\"]), \"B\": [1, 2, 1]}\n    )\n    expected_idx = CategoricalIndex([\"a\", \"b\", \"c\"], name=\"A\")\n\n    # 0 by default\n    result = df.groupby(\"A\", observed=False).B.sum()\n    expected = Series([3, 1, 0], expected_idx, name=\"B\")\n    tm.assert_series_equal(result, expected)\n\n    # min_count=0\n    result = df.groupby(\"A\", observed=False).B.sum(min_count=0)\n    expected = Series([3, 1, 0], expected_idx, name=\"B\")\n    tm.assert_series_equal(result, expected)\n\n    # min_count=1\n    result = df.groupby(\"A\", observed=False).B.sum(min_count=1)\n    expected = Series([3, 1, np.nan], expected_idx, name=\"B\")\n    tm.assert_series_equal(result, expected)\n\n    # min_count>1\n    result = df.groupby(\"A\", observed=False).B.sum(min_count=2)\n    expected = Series([3, np.nan, np.nan], expected_idx, name=\"B\")\n    tm.assert_series_equal(result, expected)",
        "begin_line": 972,
        "end_line": 997,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_empty_prod#1000",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_empty_prod()",
        "snippet": "def test_empty_prod():\n    # https://github.com/pandas-dev/pandas/issues/18678\n    df = DataFrame(\n        {\"A\": Categorical([\"a\", \"a\", \"b\"], categories=[\"a\", \"b\", \"c\"]), \"B\": [1, 2, 1]}\n    )\n\n    expected_idx = CategoricalIndex([\"a\", \"b\", \"c\"], name=\"A\")\n\n    # 1 by default\n    result = df.groupby(\"A\", observed=False).B.prod()\n    expected = Series([2, 1, 1], expected_idx, name=\"B\")\n    tm.assert_series_equal(result, expected)\n\n    # min_count=0\n    result = df.groupby(\"A\", observed=False).B.prod(min_count=0)\n    expected = Series([2, 1, 1], expected_idx, name=\"B\")\n    tm.assert_series_equal(result, expected)\n\n    # min_count=1\n    result = df.groupby(\"A\", observed=False).B.prod(min_count=1)\n    expected = Series([2, 1, np.nan], expected_idx, name=\"B\")\n    tm.assert_series_equal(result, expected)",
        "begin_line": 1000,
        "end_line": 1021,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_groupby_multiindex_categorical_datetime#1024",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_groupby_multiindex_categorical_datetime()",
        "snippet": "def test_groupby_multiindex_categorical_datetime():\n    # https://github.com/pandas-dev/pandas/issues/21390\n\n    df = DataFrame(\n        {\n            \"key1\": Categorical(list(\"abcbabcba\")),\n            \"key2\": Categorical(\n                list(pd.date_range(\"2018-06-01 00\", freq=\"1T\", periods=3)) * 3\n            ),\n            \"values\": np.arange(9),\n        }\n    )\n    result = df.groupby([\"key1\", \"key2\"]).mean()\n\n    idx = MultiIndex.from_product(\n        [\n            Categorical([\"a\", \"b\", \"c\"]),\n            Categorical(pd.date_range(\"2018-06-01 00\", freq=\"1T\", periods=3)),\n        ],\n        names=[\"key1\", \"key2\"],\n    )\n    expected = DataFrame({\"values\": [0, 4, 8, 3, 4, 5, 6, np.nan, 2]}, index=idx)\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 1024,
        "end_line": 1046,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_groupby_agg_observed_true_single_column#1074",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_groupby_agg_observed_true_single_column(as_index, expected)",
        "snippet": "def test_groupby_agg_observed_true_single_column(as_index, expected):\n    # GH-23970\n    df = DataFrame(\n        {\"a\": Series([1, 1, 2], dtype=\"category\"), \"b\": [1, 2, 2], \"x\": [1, 2, 3]}\n    )\n\n    result = df.groupby([\"a\", \"b\"], as_index=as_index, observed=True)[\"x\"].sum()\n\n    tm.assert_equal(result, expected)",
        "begin_line": 1074,
        "end_line": 1082,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_shift#1086",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_shift(fill_value)",
        "snippet": "def test_shift(fill_value):\n    ct = Categorical(\n        [\"a\", \"b\", \"c\", \"d\"], categories=[\"a\", \"b\", \"c\", \"d\"], ordered=False\n    )\n    expected = Categorical(\n        [None, \"a\", \"b\", \"c\"], categories=[\"a\", \"b\", \"c\", \"d\"], ordered=False\n    )\n    res = ct.shift(1, fill_value=fill_value)\n    tm.assert_equal(res, expected)",
        "begin_line": 1086,
        "end_line": 1094,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.df_cat#1098",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.df_cat(df)",
        "snippet": "def df_cat(df):\n    \"\"\"\n    DataFrame with multiple categorical columns and a column of integers.\n    Shortened so as not to contain all possible combinations of categories.\n    Useful for testing `observed` kwarg functionality on GroupBy objects.\n\n    Parameters\n    ----------\n    df: DataFrame\n        Non-categorical, longer DataFrame from another fixture, used to derive\n        this one\n\n    Returns\n    -------\n    df_cat: DataFrame\n    \"\"\"\n    df_cat = df.copy()[:4]  # leave out some groups\n    df_cat[\"A\"] = df_cat[\"A\"].astype(\"category\")\n    df_cat[\"B\"] = df_cat[\"B\"].astype(\"category\")\n    df_cat[\"C\"] = Series([1, 2, 3, 4])\n    df_cat = df_cat.drop([\"D\"], axis=1)\n    return df_cat",
        "begin_line": 1098,
        "end_line": 1119,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_seriesgroupby_observed_true#1125",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_seriesgroupby_observed_true(df_cat, operation, kwargs)",
        "snippet": "def test_seriesgroupby_observed_true(df_cat, operation, kwargs):\n    # GH 24880\n    index = MultiIndex.from_frame(\n        DataFrame(\n            {\"A\": [\"foo\", \"foo\", \"bar\", \"bar\"], \"B\": [\"one\", \"two\", \"one\", \"three\"]},\n            **kwargs,\n        )\n    )\n    expected = Series(data=[1, 3, 2, 4], index=index, name=\"C\")\n    grouped = df_cat.groupby([\"A\", \"B\"], observed=True)[\"C\"]\n    result = getattr(grouped, operation)(sum)\n    tm.assert_series_equal(result, expected)",
        "begin_line": 1125,
        "end_line": 1136,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_seriesgroupby_observed_false_or_none#1141",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_seriesgroupby_observed_false_or_none(df_cat, observed, operation)",
        "snippet": "def test_seriesgroupby_observed_false_or_none(df_cat, observed, operation):\n    # GH 24880\n    index, _ = MultiIndex.from_product(\n        [\n            CategoricalIndex([\"bar\", \"foo\"], ordered=False),\n            CategoricalIndex([\"one\", \"three\", \"two\"], ordered=False),\n        ],\n        names=[\"A\", \"B\"],\n    ).sortlevel()\n\n    expected = Series(data=[2, 4, np.nan, 1, np.nan, 3], index=index, name=\"C\")\n    grouped = df_cat.groupby([\"A\", \"B\"], observed=observed)[\"C\"]\n    result = getattr(grouped, operation)(sum)\n    tm.assert_series_equal(result, expected)",
        "begin_line": 1141,
        "end_line": 1154,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_seriesgroupby_observed_apply_dict#1203",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_seriesgroupby_observed_apply_dict(df_cat, observed, index, data)",
        "snippet": "def test_seriesgroupby_observed_apply_dict(df_cat, observed, index, data):\n    # GH 24880\n    expected = Series(data=data, index=index, name=\"C\")\n    result = df_cat.groupby([\"A\", \"B\"], observed=observed)[\"C\"].apply(\n        lambda x: OrderedDict([(\"min\", x.min()), (\"max\", x.max())])\n    )\n    tm.assert_series_equal(result, expected)",
        "begin_line": 1203,
        "end_line": 1209,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_groupby_categorical_series_dataframe_consistent#1212",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_groupby_categorical_series_dataframe_consistent(df_cat)",
        "snippet": "def test_groupby_categorical_series_dataframe_consistent(df_cat):\n    # GH 20416\n    expected = df_cat.groupby([\"A\", \"B\"])[\"C\"].mean()\n    result = df_cat.groupby([\"A\", \"B\"]).mean()[\"C\"]\n    tm.assert_series_equal(result, expected)",
        "begin_line": 1212,
        "end_line": 1216,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_groupby_categorical_axis_1#1220",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_groupby_categorical_axis_1(code)",
        "snippet": "def test_groupby_categorical_axis_1(code):\n    # GH 13420\n    df = DataFrame({\"a\": [1, 2, 3, 4], \"b\": [-1, -2, -3, -4], \"c\": [5, 6, 7, 8]})\n    cat = pd.Categorical.from_codes(code, categories=list(\"abc\"))\n    result = df.groupby(cat, axis=1).mean()\n    expected = df.T.groupby(cat, axis=0).mean().T\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 1220,
        "end_line": 1226,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_groupby_cat_preserves_structure#1229",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_groupby_cat_preserves_structure(observed, ordered_fixture)",
        "snippet": "def test_groupby_cat_preserves_structure(observed, ordered_fixture):\n    # GH 28787\n    df = DataFrame(\n        {\"Name\": Categorical([\"Bob\", \"Greg\"], ordered=ordered_fixture), \"Item\": [1, 2]},\n        columns=[\"Name\", \"Item\"],\n    )\n    expected = df.copy()\n\n    result = (\n        df.groupby(\"Name\", observed=observed)\n        .agg(pd.DataFrame.sum, skipna=True)\n        .reset_index()\n    )\n\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 1229,
        "end_line": 1243,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_get_nonexistent_category#1246",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_get_nonexistent_category()",
        "snippet": "def test_get_nonexistent_category():\n    # Accessing a Category that is not in the dataframe\n    df = pd.DataFrame({\"var\": [\"a\", \"a\", \"b\", \"b\"], \"val\": range(4)})\n    with pytest.raises(KeyError, match=\"'vau'\"):\n        df.groupby(\"var\").apply(\n            lambda rows: pd.DataFrame(\n                {\"var\": [rows.iloc[-1][\"var\"]], \"val\": [rows.iloc[-1][\"vau\"]]}\n            )\n        )",
        "begin_line": 1246,
        "end_line": 1254,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_series_groupby_on_2_categoricals_unobserved#1257",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_series_groupby_on_2_categoricals_unobserved(reduction_func: str, observed: bool)",
        "snippet": "def test_series_groupby_on_2_categoricals_unobserved(\n    reduction_func: str, observed: bool\n):\n    # GH 17605\n\n    if reduction_func == \"ngroup\":\n        pytest.skip(\"ngroup is not truly a reduction\")\n\n    df = pd.DataFrame(\n        {\n            \"cat_1\": pd.Categorical(list(\"AABB\"), categories=list(\"ABCD\")),\n            \"cat_2\": pd.Categorical(list(\"AB\") * 2, categories=list(\"ABCD\")),\n            \"value\": [0.1] * 4,\n        }\n    )\n    args = {\"nth\": [0]}.get(reduction_func, [])\n\n    expected_length = 4 if observed else 16\n\n    series_groupby = df.groupby([\"cat_1\", \"cat_2\"], observed=observed)[\"value\"]\n    agg = getattr(series_groupby, reduction_func)\n    result = agg(*args)\n\n    assert len(result) == expected_length",
        "begin_line": 1257,
        "end_line": 1280,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_categorical.test_series_groupby_on_2_categoricals_unobserved_zeroes_or_nans#1310",
        "src_path": "pandas/tests/groupby/test_categorical.py",
        "class_name": "pandas.tests.groupby.test_categorical",
        "signature": "pandas.tests.groupby.test_categorical.test_series_groupby_on_2_categoricals_unobserved_zeroes_or_nans(func, zero_or_nan)",
        "snippet": "def test_series_groupby_on_2_categoricals_unobserved_zeroes_or_nans(func, zero_or_nan):\n    # GH 17605\n    # Tests whether the unobserved categories in the result contain 0 or NaN\n    df = pd.DataFrame(\n        {\n            \"cat_1\": pd.Categorical(list(\"AABB\"), categories=list(\"ABC\")),\n            \"cat_2\": pd.Categorical(list(\"AB\") * 2, categories=list(\"ABC\")),\n            \"value\": [0.1] * 4,\n        }\n    )\n    unobserved = [tuple(\"AC\"), tuple(\"BC\"), tuple(\"CA\"), tuple(\"CB\"), tuple(\"CC\")]\n    args = {\"nth\": [0]}.get(func, [])\n\n    series_groupby = df.groupby([\"cat_1\", \"cat_2\"], observed=False)[\"value\"]\n    agg = getattr(series_groupby, func)\n    result = agg(*args)\n\n    for idx in unobserved:\n        val = result.loc[idx]\n        assert (pd.isna(zero_or_nan) and pd.isna(val)) or (val == zero_or_nan)\n\n    # If we expect unobserved values to be zero, we also expect the dtype to be int\n    if zero_or_nan == 0:\n        assert np.issubdtype(result.dtype, np.integer)",
        "begin_line": 1310,
        "end_line": 1333,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.mframe#10",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.mframe()",
        "snippet": "def mframe():\n    index = MultiIndex(\n        levels=[[\"foo\", \"bar\", \"baz\", \"qux\"], [\"one\", \"two\", \"three\"]],\n        codes=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3], [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],\n        names=[\"first\", \"second\"],\n    )\n    return DataFrame(np.random.randn(10, 3), index=index, columns=[\"A\", \"B\", \"C\"])",
        "begin_line": 10,
        "end_line": 16,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.df#20",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.df()",
        "snippet": "def df():\n    return DataFrame(\n        {\n            \"A\": [\"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"foo\"],\n            \"B\": [\"one\", \"one\", \"two\", \"three\", \"two\", \"two\", \"one\", \"three\"],\n            \"C\": np.random.randn(8),\n            \"D\": np.random.randn(8),\n        }\n    )",
        "begin_line": 20,
        "end_line": 28,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.ts#32",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.ts()",
        "snippet": "def ts():\n    return tm.makeTimeSeries()",
        "begin_line": 32,
        "end_line": 33,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.tsd#37",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.tsd()",
        "snippet": "def tsd():\n    return tm.getTimeSeriesData()",
        "begin_line": 37,
        "end_line": 38,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.tsframe#42",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.tsframe(tsd)",
        "snippet": "def tsframe(tsd):\n    return DataFrame(tsd)",
        "begin_line": 42,
        "end_line": 43,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.df_mixed_floats#47",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.df_mixed_floats()",
        "snippet": "def df_mixed_floats():\n    return DataFrame(\n        {\n            \"A\": [\"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"foo\"],\n            \"B\": [\"one\", \"one\", \"two\", \"three\", \"two\", \"two\", \"one\", \"three\"],\n            \"C\": np.random.randn(8),\n            \"D\": np.array(np.random.randn(8), dtype=\"float32\"),\n        }\n    )",
        "begin_line": 47,
        "end_line": 55,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.three_group#59",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.three_group()",
        "snippet": "def three_group():\n    return DataFrame(\n        {\n            \"A\": [\n                \"foo\",\n                \"foo\",\n                \"foo\",\n                \"foo\",\n                \"bar\",\n                \"bar\",\n                \"bar\",\n                \"bar\",\n                \"foo\",\n                \"foo\",\n                \"foo\",\n            ],\n            \"B\": [\n                \"one\",\n                \"one\",\n                \"one\",\n                \"two\",\n                \"one\",\n                \"one\",\n                \"one\",\n                \"two\",\n                \"two\",\n                \"two\",\n                \"one\",\n            ],\n            \"C\": [\n                \"dull\",\n                \"dull\",\n                \"shiny\",\n                \"dull\",\n                \"dull\",\n                \"shiny\",\n                \"shiny\",\n                \"dull\",\n                \"shiny\",\n                \"shiny\",\n                \"shiny\",\n            ],\n            \"D\": np.random.randn(11),\n            \"E\": np.random.randn(11),\n            \"F\": np.random.randn(11),\n        }\n    )",
        "begin_line": 59,
        "end_line": 105,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.reduction_func#109",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.reduction_func(request)",
        "snippet": "def reduction_func(request):\n    \"\"\"yields the string names of all groupby reduction functions, one at a time.\n    \"\"\"\n    return request.param",
        "begin_line": 109,
        "end_line": 112,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalDtype.__init__#22",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalDtype",
        "signature": "pandas.tests.extension.decimal.array.DecimalDtype.__init__(self, context=None)",
        "snippet": "    def __init__(self, context=None):\n        self.context = context or decimal.getcontext()",
        "begin_line": 22,
        "end_line": 23,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalDtype.__repr__#25",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalDtype",
        "signature": "pandas.tests.extension.decimal.array.DecimalDtype.__repr__(self)",
        "snippet": "    def __repr__(self) -> str:\n        return \"DecimalDtype(context={})\".format(self.context)",
        "begin_line": 25,
        "end_line": 26,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalDtype.construct_array_type#29",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalDtype",
        "signature": "pandas.tests.extension.decimal.array.DecimalDtype.construct_array_type(cls)",
        "snippet": "    def construct_array_type(cls):\n        \"\"\"Return the array type associated with this dtype\n\n        Returns\n        -------\n        type\n        \"\"\"\n        return DecimalArray",
        "begin_line": 29,
        "end_line": 36,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalDtype.construct_from_string#39",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalDtype",
        "signature": "pandas.tests.extension.decimal.array.DecimalDtype.construct_from_string(cls, string)",
        "snippet": "    def construct_from_string(cls, string):\n        if string == cls.name:\n            return cls()\n        else:\n            raise TypeError(\"Cannot construct a '{}' from '{}'\".format(cls, string))",
        "begin_line": 39,
        "end_line": 43,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalDtype._is_numeric#46",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalDtype",
        "signature": "pandas.tests.extension.decimal.array.DecimalDtype._is_numeric(self)",
        "snippet": "    def _is_numeric(self):\n        return True",
        "begin_line": 46,
        "end_line": 47,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.__init__#53",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.__init__(self, values, dtype=None, copy=False, context=None)",
        "snippet": "    def __init__(self, values, dtype=None, copy=False, context=None):\n        for val in values:\n            if not isinstance(val, decimal.Decimal):\n                raise TypeError(\"All values must be of type \" + str(decimal.Decimal))\n        values = np.asarray(values, dtype=object)\n\n        self._data = values\n        # Some aliases for common attribute names to ensure pandas supports\n        # these\n        self._items = self.data = self._data\n        # those aliases are currently not working due to assumptions\n        # in internal code (GH-20735)\n        # self._values = self.values = self.data\n        self._dtype = DecimalDtype(context)",
        "begin_line": 53,
        "end_line": 66,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.dtype#69",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.dtype(self)",
        "snippet": "    def dtype(self):\n        return self._dtype",
        "begin_line": 69,
        "end_line": 70,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray._from_sequence#73",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray._from_sequence(cls, scalars, dtype=None, copy=False)",
        "snippet": "    def _from_sequence(cls, scalars, dtype=None, copy=False):\n        return cls(scalars)",
        "begin_line": 73,
        "end_line": 74,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray._from_sequence_of_strings#77",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray._from_sequence_of_strings(cls, strings, dtype=None, copy=False)",
        "snippet": "    def _from_sequence_of_strings(cls, strings, dtype=None, copy=False):\n        return cls._from_sequence([decimal.Decimal(x) for x in strings], dtype, copy)",
        "begin_line": 77,
        "end_line": 78,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray._from_factorized#81",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray._from_factorized(cls, values, original)",
        "snippet": "    def _from_factorized(cls, values, original):\n        return cls(values)",
        "begin_line": 81,
        "end_line": 82,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.__array_ufunc__#86",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.__array_ufunc__(self, ufunc, method, *inputs, **kwargs)",
        "snippet": "    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n        #\n        if not all(\n            isinstance(t, self._HANDLED_TYPES + (DecimalArray,)) for t in inputs\n        ):\n            return NotImplemented\n\n        inputs = tuple(x._data if isinstance(x, DecimalArray) else x for x in inputs)\n        result = getattr(ufunc, method)(*inputs, **kwargs)\n\n        def reconstruct(x):\n            if isinstance(x, (decimal.Decimal, numbers.Number)):\n                return x\n            else:\n                return DecimalArray._from_sequence(x)\n\n        if isinstance(result, tuple):\n            return tuple(reconstruct(x) for x in result)\n        else:\n            return reconstruct(result)",
        "begin_line": 86,
        "end_line": 105,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.__getitem__#107",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.__getitem__(self, item)",
        "snippet": "    def __getitem__(self, item):\n        if isinstance(item, numbers.Integral):\n            return self._data[item]\n        else:\n            return type(self)(self._data[item])",
        "begin_line": 107,
        "end_line": 111,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.take#113",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.take(self, indexer, allow_fill=False, fill_value=None)",
        "snippet": "    def take(self, indexer, allow_fill=False, fill_value=None):\n        from pandas.api.extensions import take\n\n        data = self._data\n        if allow_fill and fill_value is None:\n            fill_value = self.dtype.na_value\n\n        result = take(data, indexer, fill_value=fill_value, allow_fill=allow_fill)\n        return self._from_sequence(result)",
        "begin_line": 113,
        "end_line": 121,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.copy#123",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.copy(self)",
        "snippet": "    def copy(self):\n        return type(self)(self._data.copy())",
        "begin_line": 123,
        "end_line": 124,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.astype#126",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.astype(self, dtype, copy=True)",
        "snippet": "    def astype(self, dtype, copy=True):\n        if isinstance(dtype, type(self.dtype)):\n            return type(self)(self._data, context=dtype.context)\n        return np.asarray(self, dtype=dtype)",
        "begin_line": 126,
        "end_line": 129,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.__setitem__#131",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.__setitem__(self, key, value)",
        "snippet": "    def __setitem__(self, key, value):\n        if pd.api.types.is_list_like(value):\n            if pd.api.types.is_scalar(key):\n                raise ValueError(\"setting an array element with a sequence.\")\n            value = [decimal.Decimal(v) for v in value]\n        else:\n            value = decimal.Decimal(value)\n        self._data[key] = value",
        "begin_line": 131,
        "end_line": 138,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.__len__#140",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.__len__(self)",
        "snippet": "    def __len__(self) -> int:\n        return len(self._data)",
        "begin_line": 140,
        "end_line": 141,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.nbytes#144",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.nbytes(self)",
        "snippet": "    def nbytes(self) -> int:\n        n = len(self)\n        if n:\n            return n * sys.getsizeof(self[0])\n        return 0",
        "begin_line": 144,
        "end_line": 148,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.isna#150",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.isna(self)",
        "snippet": "    def isna(self):\n        return np.array([x.is_nan() for x in self._data], dtype=bool)",
        "begin_line": 150,
        "end_line": 151,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray._na_value#154",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray._na_value(self)",
        "snippet": "    def _na_value(self):\n        return decimal.Decimal(\"NaN\")",
        "begin_line": 154,
        "end_line": 155,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray._formatter#157",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray._formatter(self, boxed=False)",
        "snippet": "    def _formatter(self, boxed=False):\n        if boxed:\n            return \"Decimal: {0}\".format\n        return repr",
        "begin_line": 157,
        "end_line": 160,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray._concat_same_type#163",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray._concat_same_type(cls, to_concat)",
        "snippet": "    def _concat_same_type(cls, to_concat):\n        return cls(np.concatenate([x._data for x in to_concat]))",
        "begin_line": 163,
        "end_line": 164,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray._reduce#166",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray._reduce(self, name, skipna=True, **kwargs)",
        "snippet": "    def _reduce(self, name, skipna=True, **kwargs):\n\n        if skipna:\n            # If we don't have any NAs, we can ignore skipna\n            if self.isna().any():\n                other = self[~self.isna()]\n                return other._reduce(name, **kwargs)\n\n        if name == \"sum\" and len(self) == 0:\n            # GH#29630 avoid returning int 0 or np.bool_(False) on old numpy\n            return decimal.Decimal(0)\n\n        try:\n            op = getattr(self.data, name)\n        except AttributeError:\n            raise NotImplementedError(\n                \"decimal does not support the {} operation\".format(name)\n            )\n        return op(axis=0)",
        "begin_line": 166,
        "end_line": 184,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.to_decimal#187",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array",
        "signature": "pandas.tests.extension.decimal.array.to_decimal(values, context=None)",
        "snippet": "def to_decimal(values, context=None):\n    return DecimalArray([decimal.Decimal(x) for x in values], context=context)",
        "begin_line": 187,
        "end_line": 188,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.make_data#191",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array",
        "signature": "pandas.tests.extension.decimal.array.make_data()",
        "snippet": "def make_data():\n    return [decimal.Decimal(random.random()) for _ in range(100)]",
        "begin_line": 191,
        "end_line": 192,
        "comment": "",
        "is_bug": false
    }
]