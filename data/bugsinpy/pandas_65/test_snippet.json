[
    {
        "name": "pandas.tests.io.excel.conftest.frame#11",
        "src_path": "pandas/tests/io/excel/conftest.py",
        "class_name": "pandas.tests.io.excel.conftest",
        "signature": "pandas.tests.io.excel.conftest.frame(float_frame)",
        "snippet": "def frame(float_frame):\n    \"\"\"\n    Returns the first ten items in fixture \"float_frame\".\n    \"\"\"\n    return float_frame[:10]",
        "begin_line": 11,
        "end_line": 15,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.conftest.tsframe#19",
        "src_path": "pandas/tests/io/excel/conftest.py",
        "class_name": "pandas.tests.io.excel.conftest",
        "signature": "pandas.tests.io.excel.conftest.tsframe()",
        "snippet": "def tsframe():\n    return tm.makeTimeDataFrame()[:5]",
        "begin_line": 19,
        "end_line": 20,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.conftest.merge_cells#24",
        "src_path": "pandas/tests/io/excel/conftest.py",
        "class_name": "pandas.tests.io.excel.conftest",
        "signature": "pandas.tests.io.excel.conftest.merge_cells(request)",
        "snippet": "def merge_cells(request):\n    return request.param",
        "begin_line": 24,
        "end_line": 25,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.conftest.df_ref#29",
        "src_path": "pandas/tests/io/excel/conftest.py",
        "class_name": "pandas.tests.io.excel.conftest",
        "signature": "pandas.tests.io.excel.conftest.df_ref(datapath)",
        "snippet": "def df_ref(datapath):\n    \"\"\"\n    Obtain the reference data from read_csv with the Python engine.\n    \"\"\"\n    filepath = datapath(\"io\", \"data\", \"csv\", \"test1.csv\")\n    df_ref = read_csv(filepath, index_col=0, parse_dates=True, engine=\"python\")\n    return df_ref",
        "begin_line": 29,
        "end_line": 35,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.conftest.read_ext#39",
        "src_path": "pandas/tests/io/excel/conftest.py",
        "class_name": "pandas.tests.io.excel.conftest",
        "signature": "pandas.tests.io.excel.conftest.read_ext(request)",
        "snippet": "def read_ext(request):\n    \"\"\"\n    Valid extensions for reading Excel files.\n    \"\"\"\n    return request.param",
        "begin_line": 39,
        "end_line": 43,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.conftest.check_for_file_leaks#47",
        "src_path": "pandas/tests/io/excel/conftest.py",
        "class_name": "pandas.tests.io.excel.conftest",
        "signature": "pandas.tests.io.excel.conftest.check_for_file_leaks()",
        "snippet": "def check_for_file_leaks():\n    \"\"\"\n    Fixture to run around every test to ensure that we are not leaking files.\n\n    See also\n    --------\n    _test_decorators.check_file_leaks\n    \"\"\"\n    # GH#30162\n    psutil = td.safe_import(\"psutil\")\n    if not psutil:\n        yield\n\n    else:\n        proc = psutil.Process()\n        flist = proc.open_files()\n        yield\n        flist2 = proc.open_files()\n        assert flist == flist2",
        "begin_line": 47,
        "end_line": 65,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.pytables.conftest.setup_mode#13",
        "src_path": "pandas/tests/io/pytables/conftest.py",
        "class_name": "pandas.tests.io.pytables.conftest",
        "signature": "pandas.tests.io.pytables.conftest.setup_mode()",
        "snippet": "def setup_mode():\n    \"\"\" Reset testing mode fixture\"\"\"\n    tm.reset_testing_mode()\n    yield\n    tm.set_testing_mode()",
        "begin_line": 13,
        "end_line": 17,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.conftest.salaries_table#23",
        "src_path": "pandas/tests/io/conftest.py",
        "class_name": "pandas.tests.io.conftest",
        "signature": "pandas.tests.io.conftest.salaries_table(datapath)",
        "snippet": "def salaries_table(datapath):\n    \"\"\"DataFrame with the salaries dataset\"\"\"\n    return read_csv(datapath(\"io\", \"parser\", \"data\", \"salaries.csv\"), sep=\"\\t\")",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.BaseParser.update_kwargs#14",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest.BaseParser",
        "signature": "pandas.tests.io.parser.conftest.BaseParser.update_kwargs(self, kwargs)",
        "snippet": "    def update_kwargs(self, kwargs):\n        kwargs = kwargs.copy()\n        kwargs.update(dict(engine=self.engine, low_memory=self.low_memory))\n\n        return kwargs",
        "begin_line": 14,
        "end_line": 18,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.BaseParser.read_csv#20",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest.BaseParser",
        "signature": "pandas.tests.io.parser.conftest.BaseParser.read_csv(self, *args, **kwargs)",
        "snippet": "    def read_csv(self, *args, **kwargs):\n        kwargs = self.update_kwargs(kwargs)\n        return read_csv(*args, **kwargs)",
        "begin_line": 20,
        "end_line": 22,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.BaseParser.read_table#24",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest.BaseParser",
        "signature": "pandas.tests.io.parser.conftest.BaseParser.read_table(self, *args, **kwargs)",
        "snippet": "    def read_table(self, *args, **kwargs):\n        kwargs = self.update_kwargs(kwargs)\n        return read_table(*args, **kwargs)",
        "begin_line": 24,
        "end_line": 26,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.csv_dir_path#48",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.csv_dir_path(datapath)",
        "snippet": "def csv_dir_path(datapath):\n    \"\"\"\n    The directory path to the data files needed for parser tests.\n    \"\"\"\n    return datapath(\"io\", \"parser\", \"data\")",
        "begin_line": 48,
        "end_line": 52,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.csv1#56",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.csv1(csv_dir_path)",
        "snippet": "def csv1(csv_dir_path):\n    \"\"\"\n    The path to the data file \"test1.csv\" needed for parser tests.\n    \"\"\"\n    return os.path.join(csv_dir_path, \"test1.csv\")",
        "begin_line": 56,
        "end_line": 60,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.all_parsers#77",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.all_parsers(request)",
        "snippet": "def all_parsers(request):\n    \"\"\"\n    Fixture all of the CSV parsers.\n    \"\"\"\n    return request.param",
        "begin_line": 77,
        "end_line": 81,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.c_parser_only#85",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.c_parser_only(request)",
        "snippet": "def c_parser_only(request):\n    \"\"\"\n    Fixture all of the CSV parsers using the C engine.\n    \"\"\"\n    return request.param",
        "begin_line": 85,
        "end_line": 89,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.python_parser_only#93",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.python_parser_only(request)",
        "snippet": "def python_parser_only(request):\n    \"\"\"\n    Fixture all of the CSV parsers using the Python engine.\n    \"\"\"\n    return request.param",
        "begin_line": 93,
        "end_line": 97,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.utf_value#111",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.utf_value(request)",
        "snippet": "def utf_value(request):\n    \"\"\"\n    Fixture for all possible integer values for a UTF encoding.\n    \"\"\"\n    return request.param",
        "begin_line": 111,
        "end_line": 115,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.encoding_fmt#119",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.encoding_fmt(request)",
        "snippet": "def encoding_fmt(request):\n    \"\"\"\n    Fixture for all possible string formats of a UTF encoding.\n    \"\"\"\n    return request.param",
        "begin_line": 119,
        "end_line": 123,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.conftest.orient#5",
        "src_path": "pandas/tests/io/json/conftest.py",
        "class_name": "pandas.tests.io.json.conftest",
        "signature": "pandas.tests.io.json.conftest.orient(request)",
        "snippet": "def orient(request):\n    \"\"\"\n    Fixture for orients excluding the table format.\n    \"\"\"\n    return request.param",
        "begin_line": 5,
        "end_line": 9,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files._create_sp_series#96",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files._create_sp_series()",
        "snippet": "def _create_sp_series():\n    nan = np.nan\n\n    # nan-based\n    arr = np.arange(15, dtype=np.float64)\n    arr[7:12] = nan\n    arr[-1:] = nan\n\n    bseries = Series(SparseArray(arr, kind=\"block\"))\n    bseries.name = \"bseries\"\n    return bseries",
        "begin_line": 96,
        "end_line": 106,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files._create_sp_tsseries#109",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files._create_sp_tsseries()",
        "snippet": "def _create_sp_tsseries():\n    nan = np.nan\n\n    # nan-based\n    arr = np.arange(15, dtype=np.float64)\n    arr[7:12] = nan\n    arr[-1:] = nan\n\n    date_index = bdate_range(\"1/1/2011\", periods=len(arr))\n    bseries = Series(SparseArray(arr, kind=\"block\"), index=date_index)\n    bseries.name = \"btsseries\"\n    return bseries",
        "begin_line": 109,
        "end_line": 120,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files._create_sp_frame#123",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files._create_sp_frame()",
        "snippet": "def _create_sp_frame():\n    nan = np.nan\n\n    data = {\n        \"A\": [nan, nan, nan, 0, 1, 2, 3, 4, 5, 6],\n        \"B\": [0, 1, 2, nan, nan, nan, 3, 4, 5, 6],\n        \"C\": np.arange(10).astype(np.int64),\n        \"D\": [0, 1, 2, 3, 4, 5, nan, nan, nan, nan],\n    }\n\n    dates = bdate_range(\"1/1/2011\", periods=10)\n    return DataFrame(data, index=dates).apply(SparseArray)",
        "begin_line": 123,
        "end_line": 134,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files.create_data#137",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files.create_data()",
        "snippet": "def create_data():\n    \"\"\" create the pickle data \"\"\"\n\n    data = {\n        \"A\": [0.0, 1.0, 2.0, 3.0, np.nan],\n        \"B\": [0, 1, 0, 1, 0],\n        \"C\": [\"foo1\", \"foo2\", \"foo3\", \"foo4\", \"foo5\"],\n        \"D\": date_range(\"1/1/2009\", periods=5),\n        \"E\": [0.0, 1, Timestamp(\"20100101\"), \"foo\", 2.0],\n    }\n\n    scalars = dict(timestamp=Timestamp(\"20130101\"), period=Period(\"2012\", \"M\"))\n\n    index = dict(\n        int=Index(np.arange(10)),\n        date=date_range(\"20130101\", periods=10),\n        period=period_range(\"2013-01-01\", freq=\"M\", periods=10),\n        float=Index(np.arange(10, dtype=np.float64)),\n        uint=Index(np.arange(10, dtype=np.uint64)),\n        timedelta=timedelta_range(\"00:00:00\", freq=\"30T\", periods=10),\n    )\n\n    index[\"range\"] = RangeIndex(10)\n\n    if _loose_version >= LooseVersion(\"0.21\"):\n        from pandas import interval_range\n\n        index[\"interval\"] = interval_range(0, periods=10)\n\n    mi = dict(\n        reg2=MultiIndex.from_tuples(\n            tuple(\n                zip(\n                    *[\n                        [\"bar\", \"bar\", \"baz\", \"baz\", \"foo\", \"foo\", \"qux\", \"qux\"],\n                        [\"one\", \"two\", \"one\", \"two\", \"one\", \"two\", \"one\", \"two\"],\n                    ]\n                )\n            ),\n            names=[\"first\", \"second\"],\n        )\n    )\n\n    series = dict(\n        float=Series(data[\"A\"]),\n        int=Series(data[\"B\"]),\n        mixed=Series(data[\"E\"]),\n        ts=Series(\n            np.arange(10).astype(np.int64), index=date_range(\"20130101\", periods=10)\n        ),\n        mi=Series(\n            np.arange(5).astype(np.float64),\n            index=MultiIndex.from_tuples(\n                tuple(zip(*[[1, 1, 2, 2, 2], [3, 4, 3, 4, 5]])), names=[\"one\", \"two\"]\n            ),\n        ),\n        dup=Series(np.arange(5).astype(np.float64), index=[\"A\", \"B\", \"C\", \"D\", \"A\"]),\n        cat=Series(Categorical([\"foo\", \"bar\", \"baz\"])),\n        dt=Series(date_range(\"20130101\", periods=5)),\n        dt_tz=Series(date_range(\"20130101\", periods=5, tz=\"US/Eastern\")),\n        period=Series([Period(\"2000Q1\")] * 5),\n    )\n\n    mixed_dup_df = DataFrame(data)\n    mixed_dup_df.columns = list(\"ABCDA\")\n    frame = dict(\n        float=DataFrame({\"A\": series[\"float\"], \"B\": series[\"float\"] + 1}),\n        int=DataFrame({\"A\": series[\"int\"], \"B\": series[\"int\"] + 1}),\n        mixed=DataFrame({k: data[k] for k in [\"A\", \"B\", \"C\", \"D\"]}),\n        mi=DataFrame(\n            {\"A\": np.arange(5).astype(np.float64), \"B\": np.arange(5).astype(np.int64)},\n            index=MultiIndex.from_tuples(\n                tuple(\n                    zip(\n                        *[\n                            [\"bar\", \"bar\", \"baz\", \"baz\", \"baz\"],\n                            [\"one\", \"two\", \"one\", \"two\", \"three\"],\n                        ]\n                    )\n                ),\n                names=[\"first\", \"second\"],\n            ),\n        ),\n        dup=DataFrame(\n            np.arange(15).reshape(5, 3).astype(np.float64), columns=[\"A\", \"B\", \"A\"]\n        ),\n        cat_onecol=DataFrame({\"A\": Categorical([\"foo\", \"bar\"])}),\n        cat_and_float=DataFrame(\n            {\n                \"A\": Categorical([\"foo\", \"bar\", \"baz\"]),\n                \"B\": np.arange(3).astype(np.int64),\n            }\n        ),\n        mixed_dup=mixed_dup_df,\n        dt_mixed_tzs=DataFrame(\n            {\n                \"A\": Timestamp(\"20130102\", tz=\"US/Eastern\"),\n                \"B\": Timestamp(\"20130603\", tz=\"CET\"),\n            },\n            index=range(5),\n        ),\n        dt_mixed2_tzs=DataFrame(\n            {\n                \"A\": Timestamp(\"20130102\", tz=\"US/Eastern\"),\n                \"B\": Timestamp(\"20130603\", tz=\"CET\"),\n                \"C\": Timestamp(\"20130603\", tz=\"UTC\"),\n            },\n            index=range(5),\n        ),\n    )\n\n    cat = dict(\n        int8=Categorical(list(\"abcdefg\")),\n        int16=Categorical(np.arange(1000)),\n        int32=Categorical(np.arange(10000)),\n    )\n\n    timestamp = dict(\n        normal=Timestamp(\"2011-01-01\"),\n        nat=NaT,\n        tz=Timestamp(\"2011-01-01\", tz=\"US/Eastern\"),\n    )\n\n    timestamp[\"freq\"] = Timestamp(\"2011-01-01\", freq=\"D\")\n    timestamp[\"both\"] = Timestamp(\"2011-01-01\", tz=\"Asia/Tokyo\", freq=\"M\")\n\n    off = {\n        \"DateOffset\": DateOffset(years=1),\n        \"DateOffset_h_ns\": DateOffset(hour=6, nanoseconds=5824),\n        \"BusinessDay\": BusinessDay(offset=timedelta(seconds=9)),\n        \"BusinessHour\": BusinessHour(normalize=True, n=6, end=\"15:14\"),\n        \"CustomBusinessDay\": CustomBusinessDay(weekmask=\"Mon Fri\"),\n        \"SemiMonthBegin\": SemiMonthBegin(day_of_month=9),\n        \"SemiMonthEnd\": SemiMonthEnd(day_of_month=24),\n        \"MonthBegin\": MonthBegin(1),\n        \"MonthEnd\": MonthEnd(1),\n        \"QuarterBegin\": QuarterBegin(1),\n        \"QuarterEnd\": QuarterEnd(1),\n        \"Day\": Day(1),\n        \"YearBegin\": YearBegin(1),\n        \"YearEnd\": YearEnd(1),\n        \"Week\": Week(1),\n        \"Week_Tues\": Week(2, normalize=False, weekday=1),\n        \"WeekOfMonth\": WeekOfMonth(week=3, weekday=4),\n        \"LastWeekOfMonth\": LastWeekOfMonth(n=1, weekday=3),\n        \"FY5253\": FY5253(n=2, weekday=6, startingMonth=7, variation=\"last\"),\n        \"Easter\": Easter(),\n        \"Hour\": Hour(1),\n        \"Minute\": Minute(1),\n    }\n\n    return dict(\n        series=series,\n        frame=frame,\n        index=index,\n        scalars=scalars,\n        mi=mi,\n        sp_series=dict(float=_create_sp_series(), ts=_create_sp_tsseries()),\n        sp_frame=dict(float=_create_sp_frame()),\n        cat=cat,\n        timestamp=timestamp,\n        offsets=off,\n    )",
        "begin_line": 137,
        "end_line": 299,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files.create_pickle_data#302",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files.create_pickle_data()",
        "snippet": "def create_pickle_data():\n    data = create_data()\n\n    return data",
        "begin_line": 302,
        "end_line": 305,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files.platform_name#308",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files.platform_name()",
        "snippet": "def platform_name():\n    return \"_\".join(\n        [\n            str(pandas.__version__),\n            str(pl.machine()),\n            str(pl.system().lower()),\n            str(pl.python_version()),\n        ]\n    )",
        "begin_line": 308,
        "end_line": 316,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files.write_legacy_pickles#319",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files.write_legacy_pickles(output_dir)",
        "snippet": "def write_legacy_pickles(output_dir):\n\n    version = pandas.__version__\n\n    print(\n        \"This script generates a storage file for the current arch, system, \"\n        \"and python version\"\n    )\n    print(\"  pandas version: {0}\".format(version))\n    print(\"  output dir    : {0}\".format(output_dir))\n    print(\"  storage format: pickle\")\n\n    pth = \"{0}.pickle\".format(platform_name())\n\n    fh = open(os.path.join(output_dir, pth), \"wb\")\n    pickle.dump(create_pickle_data(), fh, pickle.HIGHEST_PROTOCOL)\n    fh.close()\n\n    print(\"created pickle file: {pth}\".format(pth=pth))",
        "begin_line": 319,
        "end_line": 337,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files.write_legacy_file#340",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files.write_legacy_file()",
        "snippet": "def write_legacy_file():\n    # force our cwd to be the first searched\n    sys.path.insert(0, \".\")\n\n    if not (3 <= len(sys.argv) <= 4):\n        exit(\n            \"Specify output directory and storage type: generate_legacy_\"\n            \"storage_files.py <output_dir> <storage_type> \"\n        )\n\n    output_dir = str(sys.argv[1])\n    storage_type = str(sys.argv[2])\n\n    if storage_type == \"pickle\":\n        write_legacy_pickles(output_dir=output_dir)\n    else:\n        exit(\"storage_type must be one of {'pickle'}\")",
        "begin_line": 340,
        "end_line": 356,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.test_encoding.test_bytes_io_input#16",
        "src_path": "pandas/tests/io/parser/test_encoding.py",
        "class_name": "pandas.tests.io.parser.test_encoding",
        "signature": "pandas.tests.io.parser.test_encoding.test_bytes_io_input(all_parsers)",
        "snippet": "def test_bytes_io_input(all_parsers):\n    encoding = \"cp1255\"\n    parser = all_parsers\n\n    data = BytesIO(\"\u05e9\u05dc\u05d5\u05dd:1234\\n562:123\".encode(encoding))\n    result = parser.read_csv(data, sep=\":\", encoding=encoding)\n\n    expected = DataFrame([[562, 123]], columns=[\"\u05e9\u05dc\u05d5\u05dd\", \"1234\"])\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 16,
        "end_line": 24,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.test_encoding.test_read_csv_unicode#27",
        "src_path": "pandas/tests/io/parser/test_encoding.py",
        "class_name": "pandas.tests.io.parser.test_encoding",
        "signature": "pandas.tests.io.parser.test_encoding.test_read_csv_unicode(all_parsers)",
        "snippet": "def test_read_csv_unicode(all_parsers):\n    parser = all_parsers\n    data = BytesIO(\"\\u0141aski, Jan;1\".encode(\"utf-8\"))\n\n    result = parser.read_csv(data, sep=\";\", encoding=\"utf-8\", header=None)\n    expected = DataFrame([[\"\\u0141aski, Jan\", 1]])\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 27,
        "end_line": 33,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.test_encoding.test_utf16_bom_skiprows#38",
        "src_path": "pandas/tests/io/parser/test_encoding.py",
        "class_name": "pandas.tests.io.parser.test_encoding",
        "signature": "pandas.tests.io.parser.test_encoding.test_utf16_bom_skiprows(all_parsers, sep, encoding)",
        "snippet": "def test_utf16_bom_skiprows(all_parsers, sep, encoding):\n    # see gh-2298\n    parser = all_parsers\n    data = \"\"\"skip this\nskip this too\nA,B,C\n1,2,3\n4,5,6\"\"\".replace(\n        \",\", sep\n    )\n    path = \"__{}__.csv\".format(tm.rands(10))\n    kwargs = dict(sep=sep, skiprows=2)\n    utf8 = \"utf-8\"\n\n    with tm.ensure_clean(path) as path:\n        from io import TextIOWrapper\n\n        bytes_data = data.encode(encoding)\n\n        with open(path, \"wb\") as f:\n            f.write(bytes_data)\n\n        bytes_buffer = BytesIO(data.encode(utf8))\n        bytes_buffer = TextIOWrapper(bytes_buffer, encoding=utf8)\n\n        result = parser.read_csv(path, encoding=encoding, **kwargs)\n        expected = parser.read_csv(bytes_buffer, encoding=utf8, **kwargs)\n\n        bytes_buffer.close()\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 38,
        "end_line": 67,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.test_encoding.test_utf16_example#70",
        "src_path": "pandas/tests/io/parser/test_encoding.py",
        "class_name": "pandas.tests.io.parser.test_encoding",
        "signature": "pandas.tests.io.parser.test_encoding.test_utf16_example(all_parsers, csv_dir_path)",
        "snippet": "def test_utf16_example(all_parsers, csv_dir_path):\n    path = os.path.join(csv_dir_path, \"utf16_ex.txt\")\n    parser = all_parsers\n    result = parser.read_csv(path, encoding=\"utf-16\", sep=\"\\t\")\n    assert len(result) == 50",
        "begin_line": 70,
        "end_line": 74,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.test_encoding.test_unicode_encoding#77",
        "src_path": "pandas/tests/io/parser/test_encoding.py",
        "class_name": "pandas.tests.io.parser.test_encoding",
        "signature": "pandas.tests.io.parser.test_encoding.test_unicode_encoding(all_parsers, csv_dir_path)",
        "snippet": "def test_unicode_encoding(all_parsers, csv_dir_path):\n    path = os.path.join(csv_dir_path, \"unicode_series.csv\")\n    parser = all_parsers\n\n    result = parser.read_csv(path, header=None, encoding=\"latin-1\")\n    result = result.set_index(0)\n    got = result[1][1632]\n\n    expected = \"\\xc1 k\\xf6ldum klaka (Cold Fever) (1994)\"\n    assert got == expected",
        "begin_line": 77,
        "end_line": 86,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.test_encoding.test_utf8_bom#108",
        "src_path": "pandas/tests/io/parser/test_encoding.py",
        "class_name": "pandas.tests.io.parser.test_encoding",
        "signature": "pandas.tests.io.parser.test_encoding.test_utf8_bom(all_parsers, data, kwargs, expected)",
        "snippet": "def test_utf8_bom(all_parsers, data, kwargs, expected):\n    # see gh-4793\n    parser = all_parsers\n    bom = \"\\ufeff\"\n    utf8 = \"utf-8\"\n\n    def _encode_data_with_bom(_data):\n        bom_data = (bom + _data).encode(utf8)\n        return BytesIO(bom_data)\n\n    result = parser.read_csv(_encode_data_with_bom(data), encoding=utf8, **kwargs)\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 108,
        "end_line": 119,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.test_encoding._encode_data_with_bom#114",
        "src_path": "pandas/tests/io/parser/test_encoding.py",
        "class_name": "pandas.tests.io.parser.test_encoding",
        "signature": "pandas.tests.io.parser.test_encoding._encode_data_with_bom(_data)",
        "snippet": "    def _encode_data_with_bom(_data):\n        bom_data = (bom + _data).encode(utf8)\n        return BytesIO(bom_data)",
        "begin_line": 114,
        "end_line": 116,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.test_encoding.test_read_csv_utf_aliases#122",
        "src_path": "pandas/tests/io/parser/test_encoding.py",
        "class_name": "pandas.tests.io.parser.test_encoding",
        "signature": "pandas.tests.io.parser.test_encoding.test_read_csv_utf_aliases(all_parsers, utf_value, encoding_fmt)",
        "snippet": "def test_read_csv_utf_aliases(all_parsers, utf_value, encoding_fmt):\n    # see gh-13549\n    expected = DataFrame({\"mb_num\": [4.8], \"multibyte\": [\"test\"]})\n    parser = all_parsers\n\n    encoding = encoding_fmt.format(utf_value)\n    data = \"mb_num,multibyte\\n4.8,test\".encode(encoding)\n\n    result = parser.read_csv(BytesIO(data), encoding=encoding)\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 122,
        "end_line": 131,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.test_encoding.test_binary_mode_file_buffers#142",
        "src_path": "pandas/tests/io/parser/test_encoding.py",
        "class_name": "pandas.tests.io.parser.test_encoding",
        "signature": "pandas.tests.io.parser.test_encoding.test_binary_mode_file_buffers(all_parsers, csv_dir_path, fname, encoding)",
        "snippet": "def test_binary_mode_file_buffers(all_parsers, csv_dir_path, fname, encoding):\n    # gh-23779: Python csv engine shouldn't error on files opened in binary.\n    # gh-31575: Python csv engine shouldn't error on files opened in raw binary.\n    parser = all_parsers\n\n    fpath = os.path.join(csv_dir_path, fname)\n    expected = parser.read_csv(fpath, encoding=encoding)\n\n    with open(fpath, mode=\"r\", encoding=encoding) as fa:\n        result = parser.read_csv(fa)\n    tm.assert_frame_equal(expected, result)\n\n    with open(fpath, mode=\"rb\") as fb:\n        result = parser.read_csv(fb, encoding=encoding)\n    tm.assert_frame_equal(expected, result)\n\n    with open(fpath, mode=\"rb\", buffering=0) as fb:\n        result = parser.read_csv(fb, encoding=encoding)\n    tm.assert_frame_equal(expected, result)",
        "begin_line": 142,
        "end_line": 160,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.test_encoding.test_encoding_temp_file#164",
        "src_path": "pandas/tests/io/parser/test_encoding.py",
        "class_name": "pandas.tests.io.parser.test_encoding",
        "signature": "pandas.tests.io.parser.test_encoding.test_encoding_temp_file(all_parsers, utf_value, encoding_fmt, pass_encoding)",
        "snippet": "def test_encoding_temp_file(all_parsers, utf_value, encoding_fmt, pass_encoding):\n    # see gh-24130\n    parser = all_parsers\n    encoding = encoding_fmt.format(utf_value)\n\n    expected = DataFrame({\"foo\": [\"bar\"]})\n\n    with tm.ensure_clean(mode=\"w+\", encoding=encoding, return_filelike=True) as f:\n        f.write(\"foo\\nbar\")\n        f.seek(0)\n\n        result = parser.read_csv(f, encoding=encoding if pass_encoding else None)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 164,
        "end_line": 176,
        "comment": "",
        "is_bug": false
    }
]