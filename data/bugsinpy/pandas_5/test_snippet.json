[
    {
        "name": "pandas.tests.groupby.test_function.numpy_dtypes_for_minmax#20",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.numpy_dtypes_for_minmax(request)",
        "snippet": "def numpy_dtypes_for_minmax(request):\n    \"\"\"\n    Fixture of numpy dtypes with min and max values used for testing\n    cummin and cummax\n    \"\"\"\n    dtype = request.param\n    min_val = (\n        np.iinfo(dtype).min if np.dtype(dtype).kind == \"i\" else np.finfo(dtype).min\n    )\n    max_val = (\n        np.iinfo(dtype).max if np.dtype(dtype).kind == \"i\" else np.finfo(dtype).max\n    )\n\n    return (dtype, min_val, max_val)",
        "begin_line": 20,
        "end_line": 33,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_groupby_bool_aggs#56",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_groupby_bool_aggs(agg_func, skipna, vals)",
        "snippet": "def test_groupby_bool_aggs(agg_func, skipna, vals):\n    df = DataFrame({\"key\": [\"a\"] * 3 + [\"b\"] * 3, \"val\": vals * 2})\n\n    # Figure out expectation using Python builtin\n    exp = getattr(builtins, agg_func)(vals)\n\n    # edge case for missing data with skipna and 'any'\n    if skipna and all(isna(vals)) and agg_func == \"any\":\n        exp = False\n\n    exp_df = DataFrame([exp] * 2, columns=[\"val\"], index=Index([\"a\", \"b\"], name=\"key\"))\n    result = getattr(df.groupby(\"key\"), agg_func)(skipna=skipna)\n    tm.assert_frame_equal(result, exp_df)",
        "begin_line": 56,
        "end_line": 68,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_max_min_non_numeric#71",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_max_min_non_numeric()",
        "snippet": "def test_max_min_non_numeric():\n    # #2700\n    aa = DataFrame({\"nn\": [11, 11, 22, 22], \"ii\": [1, 2, 3, 4], \"ss\": 4 * [\"mama\"]})\n\n    result = aa.groupby(\"nn\").max()\n    assert \"ss\" in result\n\n    result = aa.groupby(\"nn\").max(numeric_only=False)\n    assert \"ss\" in result\n\n    result = aa.groupby(\"nn\").min()\n    assert \"ss\" in result\n\n    result = aa.groupby(\"nn\").min(numeric_only=False)\n    assert \"ss\" in result",
        "begin_line": 71,
        "end_line": 85,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_intercept_builtin_sum#88",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_intercept_builtin_sum()",
        "snippet": "def test_intercept_builtin_sum():\n    s = Series([1.0, 2.0, np.nan, 3.0])\n    grouped = s.groupby([0, 1, 2, 2])\n\n    result = grouped.agg(builtins.sum)\n    result2 = grouped.apply(builtins.sum)\n    expected = grouped.sum()\n    tm.assert_series_equal(result, expected)\n    tm.assert_series_equal(result2, expected)",
        "begin_line": 88,
        "end_line": 96,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_builtins_apply#105",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_builtins_apply(keys, f)",
        "snippet": "def test_builtins_apply(keys, f):\n    # see gh-8155\n    df = pd.DataFrame(np.random.randint(1, 50, (1000, 2)), columns=[\"jim\", \"joe\"])\n    df[\"jolie\"] = np.random.randn(1000)\n\n    fname = f.__name__\n    result = df.groupby(keys).apply(f)\n    ngroups = len(df.drop_duplicates(subset=keys))\n\n    assert_msg = f\"invalid frame shape: {result.shape} (expected ({ngroups}, 3))\"\n    assert result.shape == (ngroups, 3), assert_msg\n\n    tm.assert_frame_equal(\n        result,  # numpy's equivalent function\n        df.groupby(keys).apply(getattr(np, fname)),\n    )\n\n    if f != sum:\n        expected = df.groupby(keys).agg(fname).reset_index()\n        expected.set_index(keys, inplace=True, drop=False)\n        tm.assert_frame_equal(result, expected, check_dtype=False)\n\n    tm.assert_series_equal(getattr(result, fname)(), getattr(df, fname)())",
        "begin_line": 105,
        "end_line": 127,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_arg_passthru#130",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_arg_passthru()",
        "snippet": "def test_arg_passthru():\n    # make sure that we are passing thru kwargs\n    # to our agg functions\n\n    # GH3668\n    # GH5724\n    df = pd.DataFrame(\n        {\n            \"group\": [1, 1, 2],\n            \"int\": [1, 2, 3],\n            \"float\": [4.0, 5.0, 6.0],\n            \"string\": list(\"abc\"),\n            \"category_string\": pd.Series(list(\"abc\")).astype(\"category\"),\n            \"category_int\": [7, 8, 9],\n            \"datetime\": pd.date_range(\"20130101\", periods=3),\n            \"datetimetz\": pd.date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n            \"timedelta\": pd.timedelta_range(\"1 s\", periods=3, freq=\"s\"),\n        },\n        columns=[\n            \"group\",\n            \"int\",\n            \"float\",\n            \"string\",\n            \"category_string\",\n            \"category_int\",\n            \"datetime\",\n            \"datetimetz\",\n            \"timedelta\",\n        ],\n    )\n\n    expected_columns_numeric = Index([\"int\", \"float\", \"category_int\"])\n\n    # mean / median\n    expected = pd.DataFrame(\n        {\n            \"category_int\": [7.5, 9],\n            \"float\": [4.5, 6.0],\n            \"timedelta\": [pd.Timedelta(\"1.5s\"), pd.Timedelta(\"3s\")],\n            \"int\": [1.5, 3],\n            \"datetime\": [\n                pd.Timestamp(\"2013-01-01 12:00:00\"),\n                pd.Timestamp(\"2013-01-03 00:00:00\"),\n            ],\n            \"datetimetz\": [\n                pd.Timestamp(\"2013-01-01 12:00:00\", tz=\"US/Eastern\"),\n                pd.Timestamp(\"2013-01-03 00:00:00\", tz=\"US/Eastern\"),\n            ],\n        },\n        index=Index([1, 2], name=\"group\"),\n        columns=[\"int\", \"float\", \"category_int\", \"datetime\", \"datetimetz\", \"timedelta\"],\n    )\n\n    for attr in [\"mean\", \"median\"]:\n        result = getattr(df.groupby(\"group\"), attr)()\n        tm.assert_index_equal(result.columns, expected_columns_numeric)\n\n        result = getattr(df.groupby(\"group\"), attr)(numeric_only=False)\n        tm.assert_frame_equal(result.reindex_like(expected), expected)\n\n    # TODO: min, max *should* handle\n    # categorical (ordered) dtype\n    expected_columns = Index(\n        [\n            \"int\",\n            \"float\",\n            \"string\",\n            \"category_int\",\n            \"datetime\",\n            \"datetimetz\",\n            \"timedelta\",\n        ]\n    )\n    for attr in [\"min\", \"max\"]:\n        result = getattr(df.groupby(\"group\"), attr)()\n        tm.assert_index_equal(result.columns, expected_columns)\n\n        result = getattr(df.groupby(\"group\"), attr)(numeric_only=False)\n        tm.assert_index_equal(result.columns, expected_columns)\n\n    expected_columns = Index(\n        [\n            \"int\",\n            \"float\",\n            \"string\",\n            \"category_string\",\n            \"category_int\",\n            \"datetime\",\n            \"datetimetz\",\n            \"timedelta\",\n        ]\n    )\n    for attr in [\"first\", \"last\"]:\n        result = getattr(df.groupby(\"group\"), attr)()\n        tm.assert_index_equal(result.columns, expected_columns)\n\n        result = getattr(df.groupby(\"group\"), attr)(numeric_only=False)\n        tm.assert_index_equal(result.columns, expected_columns)\n\n    expected_columns = Index([\"int\", \"float\", \"string\", \"category_int\", \"timedelta\"])\n\n    result = df.groupby(\"group\").sum()\n    tm.assert_index_equal(result.columns, expected_columns_numeric)\n\n    result = df.groupby(\"group\").sum(numeric_only=False)\n    tm.assert_index_equal(result.columns, expected_columns)\n\n    expected_columns = Index([\"int\", \"float\", \"category_int\"])\n    for attr in [\"prod\", \"cumprod\"]:\n        result = getattr(df.groupby(\"group\"), attr)()\n        tm.assert_index_equal(result.columns, expected_columns_numeric)\n\n        result = getattr(df.groupby(\"group\"), attr)(numeric_only=False)\n        tm.assert_index_equal(result.columns, expected_columns)\n\n    # like min, max, but don't include strings\n    expected_columns = Index(\n        [\"int\", \"float\", \"category_int\", \"datetime\", \"datetimetz\", \"timedelta\"]\n    )\n    for attr in [\"cummin\", \"cummax\"]:\n        result = getattr(df.groupby(\"group\"), attr)()\n        # GH 15561: numeric_only=False set by default like min/max\n        tm.assert_index_equal(result.columns, expected_columns)\n\n        result = getattr(df.groupby(\"group\"), attr)(numeric_only=False)\n        tm.assert_index_equal(result.columns, expected_columns)\n\n    expected_columns = Index([\"int\", \"float\", \"category_int\", \"timedelta\"])\n\n    result = getattr(df.groupby(\"group\"), \"cumsum\")()\n    tm.assert_index_equal(result.columns, expected_columns_numeric)\n\n    result = getattr(df.groupby(\"group\"), \"cumsum\")(numeric_only=False)\n    tm.assert_index_equal(result.columns, expected_columns)",
        "begin_line": 130,
        "end_line": 263,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_non_cython_api#266",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_non_cython_api()",
        "snippet": "def test_non_cython_api():\n\n    # GH5610\n    # non-cython calls should not include the grouper\n\n    df = DataFrame(\n        [[1, 2, \"foo\"], [1, np.nan, \"bar\"], [3, np.nan, \"baz\"]], columns=[\"A\", \"B\", \"C\"]\n    )\n    g = df.groupby(\"A\")\n    gni = df.groupby(\"A\", as_index=False)\n\n    # mad\n    expected = DataFrame([[0], [np.nan]], columns=[\"B\"], index=[1, 3])\n    expected.index.name = \"A\"\n    result = g.mad()\n    tm.assert_frame_equal(result, expected)\n\n    expected = DataFrame([[0.0, 0.0], [0, np.nan]], columns=[\"A\", \"B\"], index=[0, 1])\n    result = gni.mad()\n    tm.assert_frame_equal(result, expected)\n\n    # describe\n    expected_index = pd.Index([1, 3], name=\"A\")\n    expected_col = pd.MultiIndex(\n        levels=[[\"B\"], [\"count\", \"mean\", \"std\", \"min\", \"25%\", \"50%\", \"75%\", \"max\"]],\n        codes=[[0] * 8, list(range(8))],\n    )\n    expected = pd.DataFrame(\n        [\n            [1.0, 2.0, np.nan, 2.0, 2.0, 2.0, 2.0, 2.0],\n            [0.0, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan],\n        ],\n        index=expected_index,\n        columns=expected_col,\n    )\n    result = g.describe()\n    tm.assert_frame_equal(result, expected)\n\n    expected = pd.concat(\n        [\n            df[df.A == 1].describe().unstack().to_frame().T,\n            df[df.A == 3].describe().unstack().to_frame().T,\n        ]\n    )\n    expected.index = pd.Index([0, 1])\n    result = gni.describe()\n    tm.assert_frame_equal(result, expected)\n\n    # any\n    expected = DataFrame(\n        [[True, True], [False, True]], columns=[\"B\", \"C\"], index=[1, 3]\n    )\n    expected.index.name = \"A\"\n    result = g.any()\n    tm.assert_frame_equal(result, expected)\n\n    # idxmax\n    expected = DataFrame([[0.0], [np.nan]], columns=[\"B\"], index=[1, 3])\n    expected.index.name = \"A\"\n    result = g.idxmax()\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 266,
        "end_line": 326,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_cython_api2#329",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_cython_api2()",
        "snippet": "def test_cython_api2():\n\n    # this takes the fast apply path\n\n    # cumsum (GH5614)\n    df = DataFrame([[1, 2, np.nan], [1, np.nan, 9], [3, 4, 9]], columns=[\"A\", \"B\", \"C\"])\n    expected = DataFrame([[2, np.nan], [np.nan, 9], [4, 9]], columns=[\"B\", \"C\"])\n    result = df.groupby(\"A\").cumsum()\n    tm.assert_frame_equal(result, expected)\n\n    # GH 5755 - cumsum is a transformer and should ignore as_index\n    result = df.groupby(\"A\", as_index=False).cumsum()\n    tm.assert_frame_equal(result, expected)\n\n    # GH 13994\n    result = df.groupby(\"A\").cumsum(axis=1)\n    expected = df.cumsum(axis=1)\n    tm.assert_frame_equal(result, expected)\n    result = df.groupby(\"A\").cumprod(axis=1)\n    expected = df.cumprod(axis=1)\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 329,
        "end_line": 349,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_cython_median#352",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_cython_median()",
        "snippet": "def test_cython_median():\n    df = DataFrame(np.random.randn(1000))\n    df.values[::2] = np.nan\n\n    labels = np.random.randint(0, 50, size=1000).astype(float)\n    labels[::17] = np.nan\n\n    result = df.groupby(labels).median()\n    exp = df.groupby(labels).agg(nanops.nanmedian)\n    tm.assert_frame_equal(result, exp)\n\n    df = DataFrame(np.random.randn(1000, 5))\n    rs = df.groupby(labels).agg(np.median)\n    xp = df.groupby(labels).median()\n    tm.assert_frame_equal(rs, xp)",
        "begin_line": 352,
        "end_line": 366,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_median_empty_bins#369",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_median_empty_bins(observed)",
        "snippet": "def test_median_empty_bins(observed):\n    df = pd.DataFrame(np.random.randint(0, 44, 500))\n\n    grps = range(0, 55, 5)\n    bins = pd.cut(df[0], grps)\n\n    result = df.groupby(bins, observed=observed).median()\n    expected = df.groupby(bins, observed=observed).agg(lambda x: x.median())\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 369,
        "end_line": 377,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_groupby_non_arithmetic_agg_types#394",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_groupby_non_arithmetic_agg_types(dtype, method, data)",
        "snippet": "def test_groupby_non_arithmetic_agg_types(dtype, method, data):\n    # GH9311, GH6620\n    df = pd.DataFrame(\n        [{\"a\": 1, \"b\": 1}, {\"a\": 1, \"b\": 2}, {\"a\": 2, \"b\": 3}, {\"a\": 2, \"b\": 4}]\n    )\n\n    df[\"b\"] = df.b.astype(dtype)\n\n    if \"args\" not in data:\n        data[\"args\"] = []\n\n    if \"out_type\" in data:\n        out_type = data[\"out_type\"]\n    else:\n        out_type = dtype\n\n    exp = data[\"df\"]\n    df_out = pd.DataFrame(exp)\n\n    df_out[\"b\"] = df_out.b.astype(out_type)\n    df_out.set_index(\"a\", inplace=True)\n\n    grpd = df.groupby(\"a\")\n    t = getattr(grpd, method)(*data[\"args\"])\n    tm.assert_frame_equal(t, df_out)",
        "begin_line": 394,
        "end_line": 418,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_groupby_non_arithmetic_agg_int_like_precision#431",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_groupby_non_arithmetic_agg_int_like_precision(i)",
        "snippet": "def test_groupby_non_arithmetic_agg_int_like_precision(i):\n    # see gh-6620, gh-9311\n    df = pd.DataFrame([{\"a\": 1, \"b\": i[0]}, {\"a\": 1, \"b\": i[1]}])\n\n    grp_exp = {\n        \"first\": {\"expected\": i[0]},\n        \"last\": {\"expected\": i[1]},\n        \"min\": {\"expected\": i[0]},\n        \"max\": {\"expected\": i[1]},\n        \"nth\": {\"expected\": i[1], \"args\": [1]},\n        \"count\": {\"expected\": 2},\n    }\n\n    for method, data in grp_exp.items():\n        if \"args\" not in data:\n            data[\"args\"] = []\n\n        grouped = df.groupby(\"a\")\n        res = getattr(grouped, method)(*data[\"args\"])\n\n        assert res.iloc[0].b == data[\"expected\"]",
        "begin_line": 431,
        "end_line": 451,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_idxmin_idxmax_returns_int_types#461",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_idxmin_idxmax_returns_int_types(func, values)",
        "snippet": "def test_idxmin_idxmax_returns_int_types(func, values):\n    # GH 25444\n    df = pd.DataFrame(\n        {\n            \"name\": [\"A\", \"A\", \"B\", \"B\"],\n            \"c_int\": [1, 2, 3, 4],\n            \"c_float\": [4.02, 3.03, 2.04, 1.05],\n            \"c_date\": [\"2019\", \"2018\", \"2016\", \"2017\"],\n        }\n    )\n    df[\"c_date\"] = pd.to_datetime(df[\"c_date\"])\n\n    result = getattr(df.groupby(\"name\"), func)()\n\n    expected = pd.DataFrame(values, index=Index([\"A\", \"B\"], name=\"name\"))\n\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 461,
        "end_line": 477,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_fill_consistency#480",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_fill_consistency()",
        "snippet": "def test_fill_consistency():\n\n    # GH9221\n    # pass thru keyword arguments to the generated wrapper\n    # are set if the passed kw is None (only)\n    df = DataFrame(\n        index=pd.MultiIndex.from_product(\n            [[\"value1\", \"value2\"], date_range(\"2014-01-01\", \"2014-01-06\")]\n        ),\n        columns=Index([\"1\", \"2\"], name=\"id\"),\n    )\n    df[\"1\"] = [\n        np.nan,\n        1,\n        np.nan,\n        np.nan,\n        11,\n        np.nan,\n        np.nan,\n        2,\n        np.nan,\n        np.nan,\n        22,\n        np.nan,\n    ]\n    df[\"2\"] = [\n        np.nan,\n        3,\n        np.nan,\n        np.nan,\n        33,\n        np.nan,\n        np.nan,\n        4,\n        np.nan,\n        np.nan,\n        44,\n        np.nan,\n    ]\n\n    expected = df.groupby(level=0, axis=0).fillna(method=\"ffill\")\n    result = df.T.groupby(level=0, axis=1).fillna(method=\"ffill\").T\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 480,
        "end_line": 522,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_groupby_cumprod#525",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_groupby_cumprod()",
        "snippet": "def test_groupby_cumprod():\n    # GH 4095\n    df = pd.DataFrame({\"key\": [\"b\"] * 10, \"value\": 2})\n\n    actual = df.groupby(\"key\")[\"value\"].cumprod()\n    expected = df.groupby(\"key\")[\"value\"].apply(lambda x: x.cumprod())\n    expected.name = \"value\"\n    tm.assert_series_equal(actual, expected)\n\n    df = pd.DataFrame({\"key\": [\"b\"] * 100, \"value\": 2})\n    actual = df.groupby(\"key\")[\"value\"].cumprod()\n    # if overflows, groupby product casts to float\n    # while numpy passes back invalid values\n    df[\"value\"] = df[\"value\"].astype(float)\n    expected = df.groupby(\"key\")[\"value\"].apply(lambda x: x.cumprod())\n    expected.name = \"value\"\n    tm.assert_series_equal(actual, expected)",
        "begin_line": 525,
        "end_line": 541,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.scipy_sem#544",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.scipy_sem(*args, **kwargs)",
        "snippet": "def scipy_sem(*args, **kwargs):\n    from scipy.stats import sem\n\n    return sem(*args, ddof=1, **kwargs)",
        "begin_line": 544,
        "end_line": 547,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_ops_general#567",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_ops_general(op, targop)",
        "snippet": "def test_ops_general(op, targop):\n    df = DataFrame(np.random.randn(1000))\n    labels = np.random.randint(0, 50, size=1000).astype(float)\n\n    result = getattr(df.groupby(labels), op)().astype(float)\n    expected = df.groupby(labels).agg(targop)\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 567,
        "end_line": 573,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_max_nan_bug#576",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_max_nan_bug()",
        "snippet": "def test_max_nan_bug():\n    raw = \"\"\",Date,app,File\n-04-23,2013-04-23 00:00:00,,log080001.log\n-05-06,2013-05-06 00:00:00,,log.log\n-05-07,2013-05-07 00:00:00,OE,xlsx\"\"\"\n\n    df = pd.read_csv(StringIO(raw), parse_dates=[0])\n    gb = df.groupby(\"Date\")\n    r = gb[[\"File\"]].max()\n    e = gb[\"File\"].max().to_frame()\n    tm.assert_frame_equal(r, e)\n    assert not r[\"File\"].isna().any()",
        "begin_line": 576,
        "end_line": 587,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_nlargest#590",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_nlargest()",
        "snippet": "def test_nlargest():\n    a = Series([1, 3, 5, 7, 2, 9, 0, 4, 6, 10])\n    b = Series(list(\"a\" * 5 + \"b\" * 5))\n    gb = a.groupby(b)\n    r = gb.nlargest(3)\n    e = Series(\n        [7, 5, 3, 10, 9, 6],\n        index=MultiIndex.from_arrays([list(\"aaabbb\"), [3, 2, 1, 9, 5, 8]]),\n    )\n    tm.assert_series_equal(r, e)\n\n    a = Series([1, 1, 3, 2, 0, 3, 3, 2, 1, 0])\n    gb = a.groupby(b)\n    e = Series(\n        [3, 2, 1, 3, 3, 2],\n        index=MultiIndex.from_arrays([list(\"aaabbb\"), [2, 3, 1, 6, 5, 7]]),\n    )\n    tm.assert_series_equal(gb.nlargest(3, keep=\"last\"), e)",
        "begin_line": 590,
        "end_line": 607,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_nlargest_mi_grouper#610",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_nlargest_mi_grouper()",
        "snippet": "def test_nlargest_mi_grouper():\n    # see gh-21411\n    npr = np.random.RandomState(123456789)\n\n    dts = date_range(\"20180101\", periods=10)\n    iterables = [dts, [\"one\", \"two\"]]\n\n    idx = MultiIndex.from_product(iterables, names=[\"first\", \"second\"])\n    s = Series(npr.randn(20), index=idx)\n\n    result = s.groupby(\"first\").nlargest(1)\n\n    exp_idx = MultiIndex.from_tuples(\n        [\n            (dts[0], dts[0], \"one\"),\n            (dts[1], dts[1], \"one\"),\n            (dts[2], dts[2], \"one\"),\n            (dts[3], dts[3], \"two\"),\n            (dts[4], dts[4], \"one\"),\n            (dts[5], dts[5], \"one\"),\n            (dts[6], dts[6], \"one\"),\n            (dts[7], dts[7], \"one\"),\n            (dts[8], dts[8], \"two\"),\n            (dts[9], dts[9], \"one\"),\n        ],\n        names=[\"first\", \"first\", \"second\"],\n    )\n\n    exp_values = [\n        2.2129019979039612,\n        1.8417114045748335,\n        0.858963679564603,\n        1.3759151378258088,\n        0.9430284594687134,\n        0.5296914208183142,\n        0.8318045593815487,\n        -0.8476703342910327,\n        0.3804446884133735,\n        -0.8028845810770998,\n    ]\n\n    expected = Series(exp_values, index=exp_idx)\n    tm.assert_series_equal(result, expected, check_exact=False)",
        "begin_line": 610,
        "end_line": 652,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_nsmallest#655",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_nsmallest()",
        "snippet": "def test_nsmallest():\n    a = Series([1, 3, 5, 7, 2, 9, 0, 4, 6, 10])\n    b = Series(list(\"a\" * 5 + \"b\" * 5))\n    gb = a.groupby(b)\n    r = gb.nsmallest(3)\n    e = Series(\n        [1, 2, 3, 0, 4, 6],\n        index=MultiIndex.from_arrays([list(\"aaabbb\"), [0, 4, 1, 6, 7, 8]]),\n    )\n    tm.assert_series_equal(r, e)\n\n    a = Series([1, 1, 3, 2, 0, 3, 3, 2, 1, 0])\n    gb = a.groupby(b)\n    e = Series(\n        [0, 1, 1, 0, 1, 2],\n        index=MultiIndex.from_arrays([list(\"aaabbb\"), [4, 1, 0, 9, 8, 7]]),\n    )\n    tm.assert_series_equal(gb.nsmallest(3, keep=\"last\"), e)",
        "begin_line": 655,
        "end_line": 672,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_numpy_compat#676",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_numpy_compat(func)",
        "snippet": "def test_numpy_compat(func):\n    # see gh-12811\n    df = pd.DataFrame({\"A\": [1, 2, 1], \"B\": [1, 2, 3]})\n    g = df.groupby(\"A\")\n\n    msg = \"numpy operations are not valid with groupby\"\n\n    with pytest.raises(UnsupportedFunctionCall, match=msg):\n        getattr(g, func)(1, 2, 3)\n    with pytest.raises(UnsupportedFunctionCall, match=msg):\n        getattr(g, func)(foo=1)",
        "begin_line": 676,
        "end_line": 686,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_cummin#689",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_cummin(numpy_dtypes_for_minmax)",
        "snippet": "def test_cummin(numpy_dtypes_for_minmax):\n    dtype = numpy_dtypes_for_minmax[0]\n    min_val = numpy_dtypes_for_minmax[1]\n\n    # GH 15048\n    base_df = pd.DataFrame(\n        {\"A\": [1, 1, 1, 1, 2, 2, 2, 2], \"B\": [3, 4, 3, 2, 2, 3, 2, 1]}\n    )\n    expected_mins = [3, 3, 3, 2, 2, 2, 2, 1]\n\n    df = base_df.astype(dtype)\n\n    expected = pd.DataFrame({\"B\": expected_mins}).astype(dtype)\n    result = df.groupby(\"A\").cummin()\n    tm.assert_frame_equal(result, expected)\n    result = df.groupby(\"A\").B.apply(lambda x: x.cummin()).to_frame()\n    tm.assert_frame_equal(result, expected)\n\n    # Test w/ min value for dtype\n    df.loc[[2, 6], \"B\"] = min_val\n    expected.loc[[2, 3, 6, 7], \"B\"] = min_val\n    result = df.groupby(\"A\").cummin()\n    tm.assert_frame_equal(result, expected)\n    expected = df.groupby(\"A\").B.apply(lambda x: x.cummin()).to_frame()\n    tm.assert_frame_equal(result, expected)\n\n    # Test nan in some values\n    base_df.loc[[0, 2, 4, 6], \"B\"] = np.nan\n    expected = pd.DataFrame({\"B\": [np.nan, 4, np.nan, 2, np.nan, 3, np.nan, 1]})\n    result = base_df.groupby(\"A\").cummin()\n    tm.assert_frame_equal(result, expected)\n    expected = base_df.groupby(\"A\").B.apply(lambda x: x.cummin()).to_frame()\n    tm.assert_frame_equal(result, expected)\n\n    # GH 15561\n    df = pd.DataFrame(dict(a=[1], b=pd.to_datetime([\"2001\"])))\n    expected = pd.Series(pd.to_datetime(\"2001\"), index=[0], name=\"b\")\n\n    result = df.groupby(\"a\")[\"b\"].cummin()\n    tm.assert_series_equal(expected, result)\n\n    # GH 15635\n    df = pd.DataFrame(dict(a=[1, 2, 1], b=[1, 2, 2]))\n    result = df.groupby(\"a\").b.cummin()\n    expected = pd.Series([1, 2, 1], name=\"b\")\n    tm.assert_series_equal(result, expected)",
        "begin_line": 689,
        "end_line": 734,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_cummin_all_nan_column#737",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_cummin_all_nan_column()",
        "snippet": "def test_cummin_all_nan_column():\n    base_df = pd.DataFrame({\"A\": [1, 1, 1, 1, 2, 2, 2, 2], \"B\": [np.nan] * 8})\n\n    expected = pd.DataFrame({\"B\": [np.nan] * 8})\n    result = base_df.groupby(\"A\").cummin()\n    tm.assert_frame_equal(expected, result)\n    result = base_df.groupby(\"A\").B.apply(lambda x: x.cummin()).to_frame()\n    tm.assert_frame_equal(expected, result)",
        "begin_line": 737,
        "end_line": 744,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_cummax#747",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_cummax(numpy_dtypes_for_minmax)",
        "snippet": "def test_cummax(numpy_dtypes_for_minmax):\n    dtype = numpy_dtypes_for_minmax[0]\n    max_val = numpy_dtypes_for_minmax[2]\n\n    # GH 15048\n    base_df = pd.DataFrame(\n        {\"A\": [1, 1, 1, 1, 2, 2, 2, 2], \"B\": [3, 4, 3, 2, 2, 3, 2, 1]}\n    )\n    expected_maxs = [3, 4, 4, 4, 2, 3, 3, 3]\n\n    df = base_df.astype(dtype)\n\n    expected = pd.DataFrame({\"B\": expected_maxs}).astype(dtype)\n    result = df.groupby(\"A\").cummax()\n    tm.assert_frame_equal(result, expected)\n    result = df.groupby(\"A\").B.apply(lambda x: x.cummax()).to_frame()\n    tm.assert_frame_equal(result, expected)\n\n    # Test w/ max value for dtype\n    df.loc[[2, 6], \"B\"] = max_val\n    expected.loc[[2, 3, 6, 7], \"B\"] = max_val\n    result = df.groupby(\"A\").cummax()\n    tm.assert_frame_equal(result, expected)\n    expected = df.groupby(\"A\").B.apply(lambda x: x.cummax()).to_frame()\n    tm.assert_frame_equal(result, expected)\n\n    # Test nan in some values\n    base_df.loc[[0, 2, 4, 6], \"B\"] = np.nan\n    expected = pd.DataFrame({\"B\": [np.nan, 4, np.nan, 4, np.nan, 3, np.nan, 3]})\n    result = base_df.groupby(\"A\").cummax()\n    tm.assert_frame_equal(result, expected)\n    expected = base_df.groupby(\"A\").B.apply(lambda x: x.cummax()).to_frame()\n    tm.assert_frame_equal(result, expected)\n\n    # GH 15561\n    df = pd.DataFrame(dict(a=[1], b=pd.to_datetime([\"2001\"])))\n    expected = pd.Series(pd.to_datetime(\"2001\"), index=[0], name=\"b\")\n\n    result = df.groupby(\"a\")[\"b\"].cummax()\n    tm.assert_series_equal(expected, result)\n\n    # GH 15635\n    df = pd.DataFrame(dict(a=[1, 2, 1], b=[2, 1, 1]))\n    result = df.groupby(\"a\").b.cummax()\n    expected = pd.Series([2, 1, 2], name=\"b\")\n    tm.assert_series_equal(result, expected)",
        "begin_line": 747,
        "end_line": 792,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_cummax_all_nan_column#795",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_cummax_all_nan_column()",
        "snippet": "def test_cummax_all_nan_column():\n    base_df = pd.DataFrame({\"A\": [1, 1, 1, 1, 2, 2, 2, 2], \"B\": [np.nan] * 8})\n\n    expected = pd.DataFrame({\"B\": [np.nan] * 8})\n    result = base_df.groupby(\"A\").cummax()\n    tm.assert_frame_equal(expected, result)\n    result = base_df.groupby(\"A\").B.apply(lambda x: x.cummax()).to_frame()\n    tm.assert_frame_equal(expected, result)",
        "begin_line": 795,
        "end_line": 802,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_is_monotonic_increasing#823",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_is_monotonic_increasing(in_vals, out_vals)",
        "snippet": "def test_is_monotonic_increasing(in_vals, out_vals):\n    # GH 17015\n    source_dict = {\n        \"A\": [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\"],\n        \"B\": [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\", \"d\", \"d\"],\n        \"C\": in_vals,\n    }\n    df = pd.DataFrame(source_dict)\n    result = df.groupby(\"B\").C.is_monotonic_increasing\n    index = Index(list(\"abcd\"), name=\"B\")\n    expected = pd.Series(index=index, data=out_vals, name=\"C\")\n    tm.assert_series_equal(result, expected)\n\n    # Also check result equal to manually taking x.is_monotonic_increasing.\n    expected = df.groupby([\"B\"]).C.apply(lambda x: x.is_monotonic_increasing)\n    tm.assert_series_equal(result, expected)",
        "begin_line": 823,
        "end_line": 838,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_is_monotonic_decreasing#859",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_is_monotonic_decreasing(in_vals, out_vals)",
        "snippet": "def test_is_monotonic_decreasing(in_vals, out_vals):\n    # GH 17015\n    source_dict = {\n        \"A\": [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\"],\n        \"B\": [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\", \"d\", \"d\"],\n        \"C\": in_vals,\n    }\n\n    df = pd.DataFrame(source_dict)\n    result = df.groupby(\"B\").C.is_monotonic_decreasing\n    index = Index(list(\"abcd\"), name=\"B\")\n    expected = pd.Series(index=index, data=out_vals, name=\"C\")\n    tm.assert_series_equal(result, expected)",
        "begin_line": 859,
        "end_line": 871,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_apply_describe_bug#878",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_apply_describe_bug(mframe)",
        "snippet": "def test_apply_describe_bug(mframe):\n    grouped = mframe.groupby(level=\"first\")\n    grouped.describe()  # it works!",
        "begin_line": 878,
        "end_line": 880,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_series_describe_multikey#883",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_series_describe_multikey()",
        "snippet": "def test_series_describe_multikey():\n    ts = tm.makeTimeSeries()\n    grouped = ts.groupby([lambda x: x.year, lambda x: x.month])\n    result = grouped.describe()\n    tm.assert_series_equal(result[\"mean\"], grouped.mean(), check_names=False)\n    tm.assert_series_equal(result[\"std\"], grouped.std(), check_names=False)\n    tm.assert_series_equal(result[\"min\"], grouped.min(), check_names=False)",
        "begin_line": 883,
        "end_line": 889,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_series_describe_single#892",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_series_describe_single()",
        "snippet": "def test_series_describe_single():\n    ts = tm.makeTimeSeries()\n    grouped = ts.groupby(lambda x: x.month)\n    result = grouped.apply(lambda x: x.describe())\n    expected = grouped.describe().stack()\n    tm.assert_series_equal(result, expected)",
        "begin_line": 892,
        "end_line": 897,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_series_index_name#900",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_series_index_name(df)",
        "snippet": "def test_series_index_name(df):\n    grouped = df.loc[:, [\"C\"]].groupby(df[\"A\"])\n    result = grouped.agg(lambda x: x.mean())\n    assert result.index.name == \"A\"",
        "begin_line": 900,
        "end_line": 903,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_frame_describe_multikey#906",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_frame_describe_multikey(tsframe)",
        "snippet": "def test_frame_describe_multikey(tsframe):\n    grouped = tsframe.groupby([lambda x: x.year, lambda x: x.month])\n    result = grouped.describe()\n    desc_groups = []\n    for col in tsframe:\n        group = grouped[col].describe()\n        # GH 17464 - Remove duplicate MultiIndex levels\n        group_col = pd.MultiIndex(\n            levels=[[col], group.columns],\n            codes=[[0] * len(group.columns), range(len(group.columns))],\n        )\n        group = pd.DataFrame(group.values, columns=group_col, index=group.index)\n        desc_groups.append(group)\n    expected = pd.concat(desc_groups, axis=1)\n    tm.assert_frame_equal(result, expected)\n\n    groupedT = tsframe.groupby({\"A\": 0, \"B\": 0, \"C\": 1, \"D\": 1}, axis=1)\n    result = groupedT.describe()\n    expected = tsframe.describe().T\n    expected.index = pd.MultiIndex(\n        levels=[[0, 1], expected.index],\n        codes=[[0, 0, 1, 1], range(len(expected.index))],\n    )\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 906,
        "end_line": 929,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_frame_describe_tupleindex#932",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_frame_describe_tupleindex()",
        "snippet": "def test_frame_describe_tupleindex():\n\n    # GH 14848 - regression from 0.19.0 to 0.19.1\n    df1 = DataFrame(\n        {\n            \"x\": [1, 2, 3, 4, 5] * 3,\n            \"y\": [10, 20, 30, 40, 50] * 3,\n            \"z\": [100, 200, 300, 400, 500] * 3,\n        }\n    )\n    df1[\"k\"] = [(0, 0, 1), (0, 1, 0), (1, 0, 0)] * 5\n    df2 = df1.rename(columns={\"k\": \"key\"})\n    msg = \"Names should be list-like for a MultiIndex\"\n    with pytest.raises(ValueError, match=msg):\n        df1.groupby(\"k\").describe()\n    with pytest.raises(ValueError, match=msg):\n        df2.groupby(\"key\").describe()",
        "begin_line": 932,
        "end_line": 948,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_frame_describe_unstacked_format#951",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_frame_describe_unstacked_format()",
        "snippet": "def test_frame_describe_unstacked_format():\n    # GH 4792\n    prices = {\n        pd.Timestamp(\"2011-01-06 10:59:05\", tz=None): 24990,\n        pd.Timestamp(\"2011-01-06 12:43:33\", tz=None): 25499,\n        pd.Timestamp(\"2011-01-06 12:54:09\", tz=None): 25499,\n    }\n    volumes = {\n        pd.Timestamp(\"2011-01-06 10:59:05\", tz=None): 1500000000,\n        pd.Timestamp(\"2011-01-06 12:43:33\", tz=None): 5000000000,\n        pd.Timestamp(\"2011-01-06 12:54:09\", tz=None): 100000000,\n    }\n    df = pd.DataFrame({\"PRICE\": prices, \"VOLUME\": volumes})\n    result = df.groupby(\"PRICE\").VOLUME.describe()\n    data = [\n        df[df.PRICE == 24990].VOLUME.describe().values.tolist(),\n        df[df.PRICE == 25499].VOLUME.describe().values.tolist(),\n    ]\n    expected = pd.DataFrame(\n        data,\n        index=pd.Index([24990, 25499], name=\"PRICE\"),\n        columns=[\"count\", \"mean\", \"std\", \"min\", \"25%\", \"50%\", \"75%\", \"max\"],\n    )\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 951,
        "end_line": 974,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_groupby_mean_no_overflow#977",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_groupby_mean_no_overflow()",
        "snippet": "def test_groupby_mean_no_overflow():\n    # Regression test for (#22487)\n    df = pd.DataFrame(\n        {\n            \"user\": [\"A\", \"A\", \"A\", \"A\", \"A\"],\n            \"connections\": [4970, 4749, 4719, 4704, 18446744073699999744],\n        }\n    )\n    assert df.groupby(\"user\")[\"connections\"].mean()[\"A\"] == 3689348814740003840",
        "begin_line": 977,
        "end_line": 985,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_apply_to_nullable_integer_returns_float#999",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_apply_to_nullable_integer_returns_float(values, function)",
        "snippet": "def test_apply_to_nullable_integer_returns_float(values, function):\n    # https://github.com/pandas-dev/pandas/issues/32219\n    output = 0.5 if function == \"var\" else 1.5\n    arr = np.array([output] * 3, dtype=float)\n    idx = pd.Index([1, 2, 3], dtype=object, name=\"a\")\n    expected = pd.DataFrame({\"b\": arr}, index=idx)\n\n    groups = pd.DataFrame(values, dtype=\"Int64\").groupby(\"a\")\n\n    result = getattr(groups, function)()\n    tm.assert_frame_equal(result, expected)\n\n    result = groups.agg(function)\n    tm.assert_frame_equal(result, expected)\n\n    result = groups.agg([function])\n    expected.columns = MultiIndex.from_tuples([(\"b\", function)])\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 999,
        "end_line": 1016,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_function.test_groupby_sum_below_mincount_nullable_integer#1019",
        "src_path": "pandas/tests/groupby/test_function.py",
        "class_name": "pandas.tests.groupby.test_function",
        "signature": "pandas.tests.groupby.test_function.test_groupby_sum_below_mincount_nullable_integer()",
        "snippet": "def test_groupby_sum_below_mincount_nullable_integer():\n    # https://github.com/pandas-dev/pandas/issues/32861\n    df = pd.DataFrame({\"a\": [0, 1, 2], \"b\": [0, 1, 2], \"c\": [0, 1, 2]}, dtype=\"Int64\")\n    grouped = df.groupby(\"a\")\n    idx = pd.Index([0, 1, 2], dtype=object, name=\"a\")\n\n    result = grouped[\"b\"].sum(min_count=2)\n    expected = pd.Series([pd.NA] * 3, dtype=\"Int64\", index=idx, name=\"b\")\n    tm.assert_series_equal(result, expected)\n\n    result = grouped.sum(min_count=2)\n    expected = pd.DataFrame(\n        {\"b\": [pd.NA] * 3, \"c\": [pd.NA] * 3}, dtype=\"Int64\", index=idx\n    )\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 1019,
        "end_line": 1033,
        "comment": "",
        "is_bug": false
    }
]