[
    {
        "name": "pandas.tests.frame.conftest.float_frame_with_na#9",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.float_frame_with_na()",
        "snippet": "def float_frame_with_na():\n    \"\"\"\n    Fixture for DataFrame of floats with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D']; some entries are missing\n\n                       A         B         C         D\n    ABwBzA0ljw -1.128865 -0.897161  0.046603  0.274997\n    DJiRzmbyQF  0.728869  0.233502  0.722431 -0.890872\n    neMgPD5UBF  0.486072 -1.027393 -0.031553  1.449522\n    0yWA4n8VeX -1.937191 -1.142531  0.805215 -0.462018\n    3slYUbbqU1  0.153260  1.164691  1.489795 -0.545826\n    soujjZ0A08       NaN       NaN       NaN       NaN\n    7W6NLGsjB9       NaN       NaN       NaN       NaN\n    ...              ...       ...       ...       ...\n    uhfeaNkCR1 -0.231210 -0.340472  0.244717 -0.901590\n    n6p7GYuBIV -0.419052  1.922721 -0.125361 -0.727717\n    ZhzAeY6p1y  1.234374 -1.425359 -0.827038 -0.633189\n    uWdPsORyUh  0.046738 -0.980445 -1.102965  0.605503\n    3DJA6aN590 -0.091018 -1.684734 -1.100900  0.215947\n    2GBPAzdbMk -2.883405 -1.021071  1.209877  1.633083\n    sHadBoyVHw -2.223032 -0.326384  0.258931  0.245517\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData())\n    # set some NAs\n    df.loc[5:10] = np.nan\n    df.loc[15:20, -2:] = np.nan\n    return df",
        "begin_line": 9,
        "end_line": 38,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.bool_frame_with_na#42",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.bool_frame_with_na()",
        "snippet": "def bool_frame_with_na():\n    \"\"\"\n    Fixture for DataFrame of booleans with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D']; some entries are missing\n\n                    A      B      C      D\n    zBZxY2IDGd  False  False  False  False\n    IhBWBMWllt  False   True   True   True\n    ctjdvZSR6R   True  False   True   True\n    AVTujptmxb  False   True  False   True\n    G9lrImrSWq  False  False  False   True\n    sFFwdIUfz2    NaN    NaN    NaN    NaN\n    s15ptEJnRb    NaN    NaN    NaN    NaN\n    ...           ...    ...    ...    ...\n    UW41KkDyZ4   True   True  False  False\n    l9l6XkOdqV   True  False  False  False\n    X2MeZfzDYA  False   True  False  False\n    xWkIKU7vfX  False   True  False   True\n    QOhL6VmpGU  False  False  False   True\n    22PwkRJdat  False   True  False  False\n    kfboQ3VeIK   True  False   True  False\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData()) > 0\n    df = df.astype(object)\n    # set some NAs\n    df.loc[5:10] = np.nan\n    df.loc[15:20, -2:] = np.nan\n    return df",
        "begin_line": 42,
        "end_line": 72,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.int_frame#76",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.int_frame()",
        "snippet": "def int_frame():\n    \"\"\"\n    Fixture for DataFrame of ints with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D']\n\n                A  B  C  D\n    vpBeWjM651  1  0  1  0\n    5JyxmrP1En -1  0  0  0\n    qEDaoD49U2 -1  1  0  0\n    m66TkTfsFe  0  0  0  0\n    EHPaNzEUFm -1  0 -1  0\n    fpRJCevQhi  2  0  0  0\n    OlQvnmfi3Q  0  0 -2  0\n    ...        .. .. .. ..\n    uB1FPlz4uP  0  0  0  1\n    EcSe6yNzCU  0  0 -1  0\n    L50VudaiI8 -1  1 -2  0\n    y3bpw4nwIp  0 -1  0  0\n    H0RdLLwrCT  1  1  0  0\n    rY82K0vMwm  0  0  0  0\n    1OPIUjnkjk  2  0  0  0\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame({k: v.astype(int) for k, v in tm.getSeriesData().items()})\n    # force these all to int64 to avoid platform testing issues\n    return DataFrame({c: s for c, s in df.items()}, dtype=np.int64)",
        "begin_line": 76,
        "end_line": 103,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.datetime_frame#107",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.datetime_frame()",
        "snippet": "def datetime_frame():\n    \"\"\"\n    Fixture for DataFrame of floats with DatetimeIndex\n\n    Columns are ['A', 'B', 'C', 'D']\n\n                       A         B         C         D\n    2000-01-03 -1.122153  0.468535  0.122226  1.693711\n    2000-01-04  0.189378  0.486100  0.007864 -1.216052\n    2000-01-05  0.041401 -0.835752 -0.035279 -0.414357\n    2000-01-06  0.430050  0.894352  0.090719  0.036939\n    2000-01-07 -0.620982 -0.668211 -0.706153  1.466335\n    2000-01-10 -0.752633  0.328434 -0.815325  0.699674\n    2000-01-11 -2.236969  0.615737 -0.829076 -1.196106\n    ...              ...       ...       ...       ...\n    2000-02-03  1.642618 -0.579288  0.046005  1.385249\n    2000-02-04 -0.544873 -1.160962 -0.284071 -1.418351\n    2000-02-07 -2.656149 -0.601387  1.410148  0.444150\n    2000-02-08 -1.201881 -1.289040  0.772992 -1.445300\n    2000-02-09  1.377373  0.398619  1.008453 -0.928207\n    2000-02-10  0.473194 -0.636677  0.984058  0.511519\n    2000-02-11 -0.965556  0.408313 -1.312844 -0.381948\n\n    [30 rows x 4 columns]\n    \"\"\"\n    return DataFrame(tm.getTimeSeriesData())",
        "begin_line": 107,
        "end_line": 132,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.float_string_frame#136",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.float_string_frame()",
        "snippet": "def float_string_frame():\n    \"\"\"\n    Fixture for DataFrame of floats and strings with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D', 'foo'].\n\n                       A         B         C         D  foo\n    w3orJvq07g -1.594062 -1.084273 -1.252457  0.356460  bar\n    PeukuVdmz2  0.109855 -0.955086 -0.809485  0.409747  bar\n    ahp2KvwiM8 -1.533729 -0.142519 -0.154666  1.302623  bar\n    3WSJ7BUCGd  2.484964  0.213829  0.034778 -2.327831  bar\n    khdAmufk0U -0.193480 -0.743518 -0.077987  0.153646  bar\n    LE2DZiFlrE -0.193566 -1.343194 -0.107321  0.959978  bar\n    HJXSJhVn7b  0.142590  1.257603 -0.659409 -0.223844  bar\n    ...              ...       ...       ...       ...  ...\n    9a1Vypttgw -1.316394  1.601354  0.173596  1.213196  bar\n    h5d1gVFbEy  0.609475  1.106738 -0.155271  0.294630  bar\n    mK9LsTQG92  1.303613  0.857040 -1.019153  0.369468  bar\n    oOLksd9gKH  0.558219 -0.134491 -0.289869 -0.951033  bar\n    9jgoOjKyHg  0.058270 -0.496110 -0.413212 -0.852659  bar\n    jZLDHclHAO  0.096298  1.267510  0.549206 -0.005235  bar\n    lR0nxDp1C2 -2.119350 -0.794384  0.544118  0.145849  bar\n\n    [30 rows x 5 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData())\n    df[\"foo\"] = \"bar\"\n    return df",
        "begin_line": 136,
        "end_line": 163,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.mixed_float_frame#167",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.mixed_float_frame()",
        "snippet": "def mixed_float_frame():\n    \"\"\"\n    Fixture for DataFrame of different float types with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D'].\n\n                       A         B         C         D\n    GI7bbDaEZe -0.237908 -0.246225 -0.468506  0.752993\n    KGp9mFepzA -1.140809 -0.644046 -1.225586  0.801588\n    VeVYLAb1l2 -1.154013 -1.677615  0.690430 -0.003731\n    kmPME4WKhO  0.979578  0.998274 -0.776367  0.897607\n    CPyopdXTiz  0.048119 -0.257174  0.836426  0.111266\n    0kJZQndAj0  0.274357 -0.281135 -0.344238  0.834541\n    tqdwQsaHG8 -0.979716 -0.519897  0.582031  0.144710\n    ...              ...       ...       ...       ...\n    7FhZTWILQj -2.906357  1.261039 -0.780273 -0.537237\n    4pUDPM4eGq -2.042512 -0.464382 -0.382080  1.132612\n    B8dUgUzwTi -1.506637 -0.364435  1.087891  0.297653\n    hErlVYjVv9  1.477453 -0.495515 -0.713867  1.438427\n    1BKN3o7YLs  0.127535 -0.349812 -0.881836  0.489827\n    9S4Ekn7zga  1.445518 -2.095149  0.031982  0.373204\n    xN1dNn6OV6  1.425017 -0.983995 -0.363281 -0.224502\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData())\n    df.A = df.A.astype(\"float32\")\n    df.B = df.B.astype(\"float32\")\n    df.C = df.C.astype(\"float16\")\n    df.D = df.D.astype(\"float64\")\n    return df",
        "begin_line": 167,
        "end_line": 197,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.mixed_int_frame#201",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.mixed_int_frame()",
        "snippet": "def mixed_int_frame():\n    \"\"\"\n    Fixture for DataFrame of different int types with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D'].\n\n                A  B    C    D\n    mUrCZ67juP  0  1    2    2\n    rw99ACYaKS  0  1    0    0\n    7QsEcpaaVU  0  1    1    1\n    xkrimI2pcE  0  1    0    0\n    dz01SuzoS8  0  1  255  255\n    ccQkqOHX75 -1  1    0    0\n    DN0iXaoDLd  0  1    0    0\n    ...        .. ..  ...  ...\n    Dfb141wAaQ  1  1  254  254\n    IPD8eQOVu5  0  1    0    0\n    CcaKulsCmv  0  1    0    0\n    rIBa8gu7E5  0  1    0    0\n    RP6peZmh5o  0  1    1    1\n    NMb9pipQWQ  0  1    0    0\n    PqgbJEzjib  0  1    3    3\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame({k: v.astype(int) for k, v in tm.getSeriesData().items()})\n    df.A = df.A.astype(\"int32\")\n    df.B = np.ones(len(df.B), dtype=\"uint64\")\n    df.C = df.C.astype(\"uint8\")\n    df.D = df.C.astype(\"int64\")\n    return df",
        "begin_line": 201,
        "end_line": 231,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.mixed_type_frame#235",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.mixed_type_frame()",
        "snippet": "def mixed_type_frame():\n    \"\"\"\n    Fixture for DataFrame of float/int/string columns with RangeIndex\n    Columns are ['a', 'b', 'c', 'float32', 'int32'].\n    \"\"\"\n    return DataFrame(\n        {\n            \"a\": 1.0,\n            \"b\": 2,\n            \"c\": \"foo\",\n            \"float32\": np.array([1.0] * 10, dtype=\"float32\"),\n            \"int32\": np.array([1] * 10, dtype=\"int32\"),\n        },\n        index=np.arange(10),\n    )",
        "begin_line": 235,
        "end_line": 249,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.timezone_frame#253",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.timezone_frame()",
        "snippet": "def timezone_frame():\n    \"\"\"\n    Fixture for DataFrame of date_range Series with different time zones\n\n    Columns are ['A', 'B', 'C']; some entries are missing\n\n               A                         B                         C\n    0 2013-01-01 2013-01-01 00:00:00-05:00 2013-01-01 00:00:00+01:00\n    1 2013-01-02                       NaT                       NaT\n    2 2013-01-03 2013-01-03 00:00:00-05:00 2013-01-03 00:00:00+01:00\n    \"\"\"\n    df = DataFrame(\n        {\n            \"A\": date_range(\"20130101\", periods=3),\n            \"B\": date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n            \"C\": date_range(\"20130101\", periods=3, tz=\"CET\"),\n        }\n    )\n    df.iloc[1, 1] = NaT\n    df.iloc[1, 2] = NaT\n    return df",
        "begin_line": 253,
        "end_line": 273,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.uint64_frame#277",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.uint64_frame()",
        "snippet": "def uint64_frame():\n    \"\"\"\n    Fixture for DataFrame with uint64 values\n\n    Columns are ['A', 'B']\n    \"\"\"\n    return DataFrame(\n        {\"A\": np.arange(3), \"B\": [2 ** 63, 2 ** 63 + 5, 2 ** 63 + 10]}, dtype=np.uint64\n    )",
        "begin_line": 277,
        "end_line": 285,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.simple_frame#289",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.simple_frame()",
        "snippet": "def simple_frame():\n    \"\"\"\n    Fixture for simple 3x3 DataFrame\n\n    Columns are ['one', 'two', 'three'], index is ['a', 'b', 'c'].\n\n       one  two  three\n    a  1.0  2.0    3.0\n    b  4.0  5.0    6.0\n    c  7.0  8.0    9.0\n    \"\"\"\n    arr = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])\n\n    return DataFrame(arr, columns=[\"one\", \"two\", \"three\"], index=[\"a\", \"b\", \"c\"])",
        "begin_line": 289,
        "end_line": 302,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.frame_of_index_cols#306",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.frame_of_index_cols()",
        "snippet": "def frame_of_index_cols():\n    \"\"\"\n    Fixture for DataFrame of columns that can be used for indexing\n\n    Columns are ['A', 'B', 'C', 'D', 'E', ('tuple', 'as', 'label')];\n    'A' & 'B' contain duplicates (but are jointly unique), the rest are unique.\n\n         A      B  C         D         E  (tuple, as, label)\n    0  foo    one  a  0.608477 -0.012500           -1.664297\n    1  foo    two  b -0.633460  0.249614           -0.364411\n    2  foo  three  c  0.615256  2.154968           -0.834666\n    3  bar    one  d  0.234246  1.085675            0.718445\n    4  bar    two  e  0.533841 -0.005702           -3.533912\n    \"\"\"\n    df = DataFrame(\n        {\n            \"A\": [\"foo\", \"foo\", \"foo\", \"bar\", \"bar\"],\n            \"B\": [\"one\", \"two\", \"three\", \"one\", \"two\"],\n            \"C\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n            \"D\": np.random.randn(5),\n            \"E\": np.random.randn(5),\n            (\"tuple\", \"as\", \"label\"): np.random.randn(5),\n        }\n    )\n    return df",
        "begin_line": 306,
        "end_line": 330,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestGet.test_get#32",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestGet",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestGet.test_get(self, float_frame)",
        "snippet": "    def test_get(self, float_frame):\n        b = float_frame.get(\"B\")\n        tm.assert_series_equal(b, float_frame[\"B\"])\n\n        assert float_frame.get(\"foo\") is None\n        tm.assert_series_equal(\n            float_frame.get(\"foo\", float_frame[\"B\"]), float_frame[\"B\"]\n        )",
        "begin_line": 32,
        "end_line": 39,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestGet.test_get_none#49",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestGet",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestGet.test_get_none(self, df)",
        "snippet": "    def test_get_none(self, df):\n        # see gh-5652\n        assert df.get(None) is None",
        "begin_line": 49,
        "end_line": 51,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem#55",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem(self, float_frame)",
        "snippet": "    def test_getitem(self, float_frame):\n        # Slicing\n        sl = float_frame[:20]\n        assert len(sl.index) == 20\n\n        # Column access\n        for _, series in sl.items():\n            assert len(series.index) == 20\n            assert tm.equalContents(series.index, sl.index)\n\n        for key, _ in float_frame._series.items():\n            assert float_frame[key] is not None\n\n        assert \"random\" not in float_frame\n        with pytest.raises(KeyError, match=\"random\"):\n            float_frame[\"random\"]\n\n        df = float_frame.copy()\n        df[\"$10\"] = np.random.randn(len(df))\n\n        ad = np.random.randn(len(df))\n        df[\"@awesome_domain\"] = ad\n\n        with pytest.raises(KeyError, match=re.escape(\"'df[\\\"$10\\\"]'\")):\n            df.__getitem__('df[\"$10\"]')\n\n        res = df[\"@awesome_domain\"]\n        tm.assert_numpy_array_equal(ad, res.values)",
        "begin_line": 55,
        "end_line": 82,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_dupe_cols#84",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_dupe_cols(self)",
        "snippet": "    def test_getitem_dupe_cols(self):\n        df = DataFrame([[1, 2, 3], [4, 5, 6]], columns=[\"a\", \"a\", \"b\"])\n        msg = \"\\\"None of [Index(['baf'], dtype='object')] are in the [columns]\\\"\"\n        with pytest.raises(KeyError, match=re.escape(msg)):\n            df[[\"baf\"]]",
        "begin_line": 84,
        "end_line": 88,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_loc_iterable#91",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_loc_iterable(self, float_frame, key_type)",
        "snippet": "    def test_loc_iterable(self, float_frame, key_type):\n        idx = key_type([\"A\", \"B\", \"C\"])\n        result = float_frame.loc[:, idx]\n        expected = float_frame.loc[:, [\"A\", \"B\", \"C\"]]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 91,
        "end_line": 95,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_listlike#110",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_listlike(self, idx_type, levels, float_frame)",
        "snippet": "    def test_getitem_listlike(self, idx_type, levels, float_frame):\n        # GH 21294\n\n        if levels == 1:\n            frame, missing = float_frame, \"food\"\n        else:\n            # MultiIndex columns\n            frame = DataFrame(\n                np.random.randn(8, 3),\n                columns=Index(\n                    [(\"foo\", \"bar\"), (\"baz\", \"qux\"), (\"peek\", \"aboo\")],\n                    name=(\"sth\", \"sth2\"),\n                ),\n            )\n            missing = (\"good\", \"food\")\n\n        keys = [frame.columns[1], frame.columns[0]]\n        idx = idx_type(keys)\n        idx_check = list(idx_type(keys))\n\n        result = frame[idx]\n\n        expected = frame.loc[:, idx_check]\n        expected.columns.names = frame.columns.names\n\n        tm.assert_frame_equal(result, expected)\n\n        idx = idx_type(keys + [missing])\n        with pytest.raises(KeyError, match=\"not in index\"):\n            frame[idx]",
        "begin_line": 110,
        "end_line": 139,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_loc_uint64#144",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_loc_uint64(self, val, expected)",
        "snippet": "    def test_loc_uint64(self, val, expected):\n        # see gh-19399\n        df = DataFrame([1, 2], index=[2 ** 63 - 1, 2 ** 63])\n        result = df.loc[val]\n\n        expected.name = val\n        tm.assert_series_equal(result, expected)",
        "begin_line": 144,
        "end_line": 150,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_callable#152",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_callable(self, float_frame)",
        "snippet": "    def test_getitem_callable(self, float_frame):\n        # GH 12533\n        result = float_frame[lambda x: \"A\"]\n        tm.assert_series_equal(result, float_frame.loc[:, \"A\"])\n\n        result = float_frame[lambda x: [\"A\", \"B\"]]\n        tm.assert_frame_equal(result, float_frame.loc[:, [\"A\", \"B\"]])\n\n        df = float_frame[:3]\n        result = df[lambda x: [True, False, True]]\n        tm.assert_frame_equal(result, float_frame.iloc[[0, 2], :])",
        "begin_line": 152,
        "end_line": 162,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_list#164",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_list(self, float_frame)",
        "snippet": "    def test_setitem_list(self, float_frame):\n\n        float_frame[\"E\"] = \"foo\"\n        data = float_frame[[\"A\", \"B\"]]\n        float_frame[[\"B\", \"A\"]] = data\n\n        tm.assert_series_equal(float_frame[\"B\"], data[\"A\"], check_names=False)\n        tm.assert_series_equal(float_frame[\"A\"], data[\"B\"], check_names=False)\n\n        msg = \"Columns must be same length as key\"\n        with pytest.raises(ValueError, match=msg):\n            data[[\"A\"]] = float_frame[[\"A\", \"B\"]]\n\n        msg = \"Length of values does not match length of index\"\n        with pytest.raises(ValueError, match=msg):\n            data[\"A\"] = range(len(data.index) - 1)\n\n        df = DataFrame(0, index=range(3), columns=[\"tt1\", \"tt2\"], dtype=np.int_)\n        df.loc[1, [\"tt1\", \"tt2\"]] = [1, 2]\n\n        result = df.loc[df.index[1], [\"tt1\", \"tt2\"]]\n        expected = Series([1, 2], df.columns, dtype=np.int_, name=1)\n        tm.assert_series_equal(result, expected)\n\n        df[\"tt1\"] = df[\"tt2\"] = \"0\"\n        df.loc[df.index[1], [\"tt1\", \"tt2\"]] = [\"1\", \"2\"]\n        result = df.loc[df.index[1], [\"tt1\", \"tt2\"]]\n        expected = Series([\"1\", \"2\"], df.columns, name=1)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 164,
        "end_line": 192,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_list_not_dataframe#194",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_list_not_dataframe(self, float_frame)",
        "snippet": "    def test_setitem_list_not_dataframe(self, float_frame):\n        data = np.random.randn(len(float_frame), 2)\n        float_frame[[\"A\", \"B\"]] = data\n        tm.assert_almost_equal(float_frame[[\"A\", \"B\"]].values, data)",
        "begin_line": 194,
        "end_line": 197,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_list_of_tuples#199",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_list_of_tuples(self, float_frame)",
        "snippet": "    def test_setitem_list_of_tuples(self, float_frame):\n        tuples = list(zip(float_frame[\"A\"], float_frame[\"B\"]))\n        float_frame[\"tuples\"] = tuples\n\n        result = float_frame[\"tuples\"]\n        expected = Series(tuples, index=float_frame.index, name=\"tuples\")\n        tm.assert_series_equal(result, expected)",
        "begin_line": 199,
        "end_line": 205,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_mulit_index#207",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_mulit_index(self)",
        "snippet": "    def test_setitem_mulit_index(self):\n        # GH7655, test that assigning to a sub-frame of a frame\n        # with multi-index columns aligns both rows and columns\n        it = [\"jim\", \"joe\", \"jolie\"], [\"first\", \"last\"], [\"left\", \"center\", \"right\"]\n\n        cols = MultiIndex.from_product(it)\n        index = pd.date_range(\"20141006\", periods=20)\n        vals = np.random.randint(1, 1000, (len(index), len(cols)))\n        df = pd.DataFrame(vals, columns=cols, index=index)\n\n        i, j = df.index.values.copy(), it[-1][:]\n\n        np.random.shuffle(i)\n        df[\"jim\"] = df[\"jolie\"].loc[i, ::-1]\n        tm.assert_frame_equal(df[\"jim\"], df[\"jolie\"])\n\n        np.random.shuffle(j)\n        df[(\"joe\", \"first\")] = df[(\"jolie\", \"last\")].loc[i, j]\n        tm.assert_frame_equal(df[(\"joe\", \"first\")], df[(\"jolie\", \"last\")])\n\n        np.random.shuffle(j)\n        df[(\"joe\", \"last\")] = df[(\"jolie\", \"first\")].loc[i, j]\n        tm.assert_frame_equal(df[(\"joe\", \"last\")], df[(\"jolie\", \"first\")])",
        "begin_line": 207,
        "end_line": 229,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_callable#231",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_callable(self)",
        "snippet": "    def test_setitem_callable(self):\n        # GH 12533\n        df = pd.DataFrame({\"A\": [1, 2, 3, 4], \"B\": [5, 6, 7, 8]})\n        df[lambda x: \"A\"] = [11, 12, 13, 14]\n\n        exp = pd.DataFrame({\"A\": [11, 12, 13, 14], \"B\": [5, 6, 7, 8]})\n        tm.assert_frame_equal(df, exp)",
        "begin_line": 231,
        "end_line": 237,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_other_callable#239",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_other_callable(self)",
        "snippet": "    def test_setitem_other_callable(self):\n        # GH 13299\n        def inc(x):\n            return x + 1\n\n        df = pd.DataFrame([[-1, 1], [1, -1]])\n        df[df > 0] = inc\n\n        expected = pd.DataFrame([[-1, inc], [inc, -1]])\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 239,
        "end_line": 248,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.inc#241",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.inc(x)",
        "snippet": "        def inc(x):\n            return x + 1",
        "begin_line": 241,
        "end_line": 242,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_boolean#250",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_boolean(self, float_string_frame, mixed_float_frame, mixed_int_frame, datetime_frame)",
        "snippet": "    def test_getitem_boolean(\n        self, float_string_frame, mixed_float_frame, mixed_int_frame, datetime_frame\n    ):\n        # boolean indexing\n        d = datetime_frame.index[10]\n        indexer = datetime_frame.index > d\n        indexer_obj = indexer.astype(object)\n\n        subindex = datetime_frame.index[indexer]\n        subframe = datetime_frame[indexer]\n\n        tm.assert_index_equal(subindex, subframe.index)\n        with pytest.raises(ValueError, match=\"Item wrong length\"):\n            datetime_frame[indexer[:-1]]\n\n        subframe_obj = datetime_frame[indexer_obj]\n        tm.assert_frame_equal(subframe_obj, subframe)\n\n        with pytest.raises(ValueError, match=\"Boolean array expected\"):\n            datetime_frame[datetime_frame]\n\n        # test that Series work\n        indexer_obj = Series(indexer_obj, datetime_frame.index)\n\n        subframe_obj = datetime_frame[indexer_obj]\n        tm.assert_frame_equal(subframe_obj, subframe)\n\n        # test that Series indexers reindex\n        # we are producing a warning that since the passed boolean\n        # key is not the same as the given index, we will reindex\n        # not sure this is really necessary\n        with tm.assert_produces_warning(UserWarning, check_stacklevel=False):\n            indexer_obj = indexer_obj.reindex(datetime_frame.index[::-1])\n            subframe_obj = datetime_frame[indexer_obj]\n            tm.assert_frame_equal(subframe_obj, subframe)\n\n        # test df[df > 0]\n        for df in [\n            datetime_frame,\n            float_string_frame,\n            mixed_float_frame,\n            mixed_int_frame,\n        ]:\n            if df is float_string_frame:\n                continue\n\n            data = df._get_numeric_data()\n            bif = df[df > 0]\n            bifw = DataFrame(\n                {c: np.where(data[c] > 0, data[c], np.nan) for c in data.columns},\n                index=data.index,\n                columns=data.columns,\n            )\n\n            # add back other columns to compare\n            for c in df.columns:\n                if c not in bifw:\n                    bifw[c] = df[c]\n            bifw = bifw.reindex(columns=df.columns)\n\n            tm.assert_frame_equal(bif, bifw, check_dtype=False)\n            for c in df.columns:\n                if bif[c].dtype != bifw[c].dtype:\n                    assert bif[c].dtype == df[c].dtype",
        "begin_line": 250,
        "end_line": 313,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_boolean_casting#315",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_boolean_casting(self, datetime_frame)",
        "snippet": "    def test_getitem_boolean_casting(self, datetime_frame):\n\n        # don't upcast if we don't need to\n        df = datetime_frame.copy()\n        df[\"E\"] = 1\n        df[\"E\"] = df[\"E\"].astype(\"int32\")\n        df[\"E1\"] = df[\"E\"].copy()\n        df[\"F\"] = 1\n        df[\"F\"] = df[\"F\"].astype(\"int64\")\n        df[\"F1\"] = df[\"F\"].copy()\n\n        casted = df[df > 0]\n        result = casted.dtypes\n        expected = Series(\n            [np.dtype(\"float64\")] * 4\n            + [np.dtype(\"int32\")] * 2\n            + [np.dtype(\"int64\")] * 2,\n            index=[\"A\", \"B\", \"C\", \"D\", \"E\", \"E1\", \"F\", \"F1\"],\n        )\n        tm.assert_series_equal(result, expected)\n\n        # int block splitting\n        df.loc[df.index[1:3], [\"E1\", \"F1\"]] = 0\n        casted = df[df > 0]\n        result = casted.dtypes\n        expected = Series(\n            [np.dtype(\"float64\")] * 4\n            + [np.dtype(\"int32\")]\n            + [np.dtype(\"float64\")]\n            + [np.dtype(\"int64\")]\n            + [np.dtype(\"float64\")],\n            index=[\"A\", \"B\", \"C\", \"D\", \"E\", \"E1\", \"F\", \"F1\"],\n        )\n        tm.assert_series_equal(result, expected)\n\n        # where dtype conversions\n        # GH 3733\n        df = DataFrame(data=np.random.randn(100, 50))\n        df = df.where(df > 0)  # create nans\n        bools = df > 0\n        mask = isna(df)\n        expected = bools.astype(float).mask(mask)\n        result = bools.mask(mask)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 315,
        "end_line": 358,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_boolean_list#360",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_boolean_list(self)",
        "snippet": "    def test_getitem_boolean_list(self):\n        df = DataFrame(np.arange(12).reshape(3, 4))\n\n        def _checkit(lst):\n            result = df[lst]\n            expected = df.loc[df.index[lst]]\n            tm.assert_frame_equal(result, expected)\n\n        _checkit([True, False, True])\n        _checkit([True, True, True])\n        _checkit([False, False, False])",
        "begin_line": 360,
        "end_line": 370,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing._checkit#363",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing._checkit(lst)",
        "snippet": "        def _checkit(lst):\n            result = df[lst]\n            expected = df.loc[df.index[lst]]\n            tm.assert_frame_equal(result, expected)",
        "begin_line": 363,
        "end_line": 366,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_boolean_iadd#372",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_boolean_iadd(self)",
        "snippet": "    def test_getitem_boolean_iadd(self):\n        arr = np.random.randn(5, 5)\n\n        df = DataFrame(arr.copy(), columns=[\"A\", \"B\", \"C\", \"D\", \"E\"])\n\n        df[df < 0] += 1\n        arr[arr < 0] += 1\n\n        tm.assert_almost_equal(df.values, arr)",
        "begin_line": 372,
        "end_line": 380,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_boolean_index_empty_corner#382",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_boolean_index_empty_corner(self)",
        "snippet": "    def test_boolean_index_empty_corner(self):\n        # #2096\n        blah = DataFrame(np.empty([0, 1]), columns=[\"A\"], index=DatetimeIndex([]))\n\n        # both of these should succeed trivially\n        k = np.array([], bool)\n\n        blah[k]\n        blah[k] = 0",
        "begin_line": 382,
        "end_line": 390,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_ix_mixed_integer#392",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_ix_mixed_integer(self)",
        "snippet": "    def test_getitem_ix_mixed_integer(self):\n        df = DataFrame(\n            np.random.randn(4, 3), index=[1, 10, \"C\", \"E\"], columns=[1, 2, 3]\n        )\n\n        result = df.iloc[:-1]\n        expected = df.loc[df.index[:-1]]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[[1, 10]]\n        expected = df.loc[Index([1, 10])]\n        tm.assert_frame_equal(result, expected)\n\n        # 11320\n        df = pd.DataFrame(\n            {\n                \"rna\": (1.5, 2.2, 3.2, 4.5),\n                -1000: [11, 21, 36, 40],\n                0: [10, 22, 43, 34],\n                1000: [0, 10, 20, 30],\n            },\n            columns=[\"rna\", -1000, 0, 1000],\n        )\n        result = df[[1000]]\n        expected = df.iloc[:, [3]]\n        tm.assert_frame_equal(result, expected)\n        result = df[[-1000]]\n        expected = df.iloc[:, [1]]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 392,
        "end_line": 420,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getattr#422",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getattr(self, float_frame)",
        "snippet": "    def test_getattr(self, float_frame):\n        tm.assert_series_equal(float_frame.A, float_frame[\"A\"])\n        msg = \"'DataFrame' object has no attribute 'NONEXISTENT_NAME'\"\n        with pytest.raises(AttributeError, match=msg):\n            float_frame.NONEXISTENT_NAME",
        "begin_line": 422,
        "end_line": 426,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setattr_column#428",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setattr_column(self)",
        "snippet": "    def test_setattr_column(self):\n        df = DataFrame({\"foobar\": 1}, index=range(10))\n\n        df.foobar = 5\n        assert (df.foobar == 5).all()",
        "begin_line": 428,
        "end_line": 432,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem#434",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem(self, float_frame)",
        "snippet": "    def test_setitem(self, float_frame):\n        # not sure what else to do here\n        series = float_frame[\"A\"][::2]\n        float_frame[\"col5\"] = series\n        assert \"col5\" in float_frame\n\n        assert len(series) == 15\n        assert len(float_frame) == 30\n\n        exp = np.ravel(np.column_stack((series.values, [np.nan] * 15)))\n        exp = Series(exp, index=float_frame.index, name=\"col5\")\n        tm.assert_series_equal(float_frame[\"col5\"], exp)\n\n        series = float_frame[\"A\"]\n        float_frame[\"col6\"] = series\n        tm.assert_series_equal(series, float_frame[\"col6\"], check_names=False)\n\n        msg = (\n            r\"\\\"None of \\[Float64Index\\(\\[.*dtype='float64'\\)\\] are in the \"\n            r\"\\[columns\\]\\\"\"\n        )\n        with pytest.raises(KeyError, match=msg):\n            float_frame[np.random.randn(len(float_frame) + 1)] = 1\n\n        # set ndarray\n        arr = np.random.randn(len(float_frame))\n        float_frame[\"col9\"] = arr\n        assert (float_frame[\"col9\"] == arr).all()\n\n        float_frame[\"col7\"] = 5\n        assert (float_frame[\"col7\"] == 5).all()\n\n        float_frame[\"col0\"] = 3.14\n        assert (float_frame[\"col0\"] == 3.14).all()\n\n        float_frame[\"col8\"] = \"foo\"\n        assert (float_frame[\"col8\"] == \"foo\").all()\n\n        # this is partially a view (e.g. some blocks are view)\n        # so raise/warn\n        smaller = float_frame[:2]\n\n        with pytest.raises(com.SettingWithCopyError):\n            smaller[\"col10\"] = [\"1\", \"2\"]\n\n        assert smaller[\"col10\"].dtype == np.object_\n        assert (smaller[\"col10\"] == [\"1\", \"2\"]).all()\n\n        # dtype changing GH4204\n        df = DataFrame([[0, 0]])\n        df.iloc[0] = np.nan\n        expected = DataFrame([[np.nan, np.nan]])\n        tm.assert_frame_equal(df, expected)\n\n        df = DataFrame([[0, 0]])\n        df.loc[0] = np.nan\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 434,
        "end_line": 490,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_dtype#493",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_dtype(self, dtype, float_frame)",
        "snippet": "    def test_setitem_dtype(self, dtype, float_frame):\n        arr = np.random.randn(len(float_frame))\n\n        float_frame[dtype] = np.array(arr, dtype=dtype)\n        assert float_frame[dtype].dtype.name == dtype",
        "begin_line": 493,
        "end_line": 497,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_tuple#499",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_tuple(self, float_frame)",
        "snippet": "    def test_setitem_tuple(self, float_frame):\n        float_frame[\"A\", \"B\"] = float_frame[\"A\"]\n        tm.assert_series_equal(\n            float_frame[\"A\", \"B\"], float_frame[\"A\"], check_names=False\n        )",
        "begin_line": 499,
        "end_line": 503,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_always_copy#505",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_always_copy(self, float_frame)",
        "snippet": "    def test_setitem_always_copy(self, float_frame):\n        s = float_frame[\"A\"].copy()\n        float_frame[\"E\"] = s\n\n        float_frame[\"E\"][5:10] = np.nan\n        assert notna(s[5:10]).all()",
        "begin_line": 505,
        "end_line": 510,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_boolean#512",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_boolean(self, float_frame)",
        "snippet": "    def test_setitem_boolean(self, float_frame):\n        df = float_frame.copy()\n        values = float_frame.values\n\n        df[df[\"A\"] > 0] = 4\n        values[values[:, 0] > 0] = 4\n        tm.assert_almost_equal(df.values, values)\n\n        # test that column reindexing works\n        series = df[\"A\"] == 4\n        series = series.reindex(df.index[::-1])\n        df[series] = 1\n        values[values[:, 0] == 4] = 1\n        tm.assert_almost_equal(df.values, values)\n\n        df[df > 0] = 5\n        values[values > 0] = 5\n        tm.assert_almost_equal(df.values, values)\n\n        df[df == 5] = 0\n        values[values == 5] = 0\n        tm.assert_almost_equal(df.values, values)\n\n        # a df that needs alignment first\n        df[df[:-1] < 0] = 2\n        np.putmask(values[:-1], values[:-1] < 0, 2)\n        tm.assert_almost_equal(df.values, values)\n\n        # indexed with same shape but rows-reversed df\n        df[df[::-1] == 2] = 3\n        values[values == 2] = 3\n        tm.assert_almost_equal(df.values, values)\n\n        msg = \"Must pass DataFrame or 2-d ndarray with boolean values only\"\n        with pytest.raises(TypeError, match=msg):\n            df[df * 0] = 2\n\n        # index with DataFrame\n        mask = df > np.abs(df)\n        expected = df.copy()\n        df[df > np.abs(df)] = np.nan\n        expected.values[mask.values] = np.nan\n        tm.assert_frame_equal(df, expected)\n\n        # set from DataFrame\n        expected = df.copy()\n        df[df > np.abs(df)] = df * 2\n        np.putmask(expected.values, mask.values, df.values * 2)\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 512,
        "end_line": 560,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_boolean_mask#567",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_boolean_mask(self, mask_type, float_frame)",
        "snippet": "    def test_setitem_boolean_mask(self, mask_type, float_frame):\n\n        # Test for issue #18582\n        df = float_frame.copy()\n        mask = mask_type(df)\n\n        # index with boolean mask\n        result = df.copy()\n        result[mask] = np.nan\n\n        expected = df.copy()\n        expected.values[np.array(mask)] = np.nan\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 567,
        "end_line": 579,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_cast#581",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_cast(self, float_frame)",
        "snippet": "    def test_setitem_cast(self, float_frame):\n        float_frame[\"D\"] = float_frame[\"D\"].astype(\"i8\")\n        assert float_frame[\"D\"].dtype == np.int64\n\n        # #669, should not cast?\n        # this is now set to int64, which means a replacement of the column to\n        # the value dtype (and nothing to do with the existing dtype)\n        float_frame[\"B\"] = 0\n        assert float_frame[\"B\"].dtype == np.int64\n\n        # cast if pass array of course\n        float_frame[\"B\"] = np.arange(len(float_frame))\n        assert issubclass(float_frame[\"B\"].dtype.type, np.integer)\n\n        float_frame[\"foo\"] = \"bar\"\n        float_frame[\"foo\"] = 0\n        assert float_frame[\"foo\"].dtype == np.int64\n\n        float_frame[\"foo\"] = \"bar\"\n        float_frame[\"foo\"] = 2.5\n        assert float_frame[\"foo\"].dtype == np.float64\n\n        float_frame[\"something\"] = 0\n        assert float_frame[\"something\"].dtype == np.int64\n        float_frame[\"something\"] = 2\n        assert float_frame[\"something\"].dtype == np.int64\n        float_frame[\"something\"] = 2.5\n        assert float_frame[\"something\"].dtype == np.float64\n\n        # GH 7704\n        # dtype conversion on setting\n        df = DataFrame(np.random.rand(30, 3), columns=tuple(\"ABC\"))\n        df[\"event\"] = np.nan\n        df.loc[10, \"event\"] = \"foo\"\n        result = df.dtypes\n        expected = Series(\n            [np.dtype(\"float64\")] * 3 + [np.dtype(\"object\")],\n            index=[\"A\", \"B\", \"C\", \"event\"],\n        )\n        tm.assert_series_equal(result, expected)\n\n        # Test that data type is preserved . #5782\n        df = DataFrame({\"one\": np.arange(6, dtype=np.int8)})\n        df.loc[1, \"one\"] = 6\n        assert df.dtypes.one == np.dtype(np.int8)\n        df.one = np.int8(7)\n        assert df.dtypes.one == np.dtype(np.int8)",
        "begin_line": 581,
        "end_line": 627,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_boolean_column#629",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_boolean_column(self, float_frame)",
        "snippet": "    def test_setitem_boolean_column(self, float_frame):\n        expected = float_frame.copy()\n        mask = float_frame[\"A\"] > 0\n\n        float_frame.loc[mask, \"B\"] = 0\n        expected.values[mask.values, 1] = 0\n\n        tm.assert_frame_equal(float_frame, expected)",
        "begin_line": 629,
        "end_line": 636,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_frame_setitem_timestamp#638",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_frame_setitem_timestamp(self)",
        "snippet": "    def test_frame_setitem_timestamp(self):\n        # GH#2155\n        columns = date_range(start=\"1/1/2012\", end=\"2/1/2012\", freq=BDay())\n        data = DataFrame(columns=columns, index=range(10))\n        t = datetime(2012, 11, 1)\n        ts = Timestamp(t)\n        data[ts] = np.nan  # works, mostly a smoke-test\n        assert np.isnan(data[ts]).all()",
        "begin_line": 638,
        "end_line": 645,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_corner#647",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_corner(self, float_frame)",
        "snippet": "    def test_setitem_corner(self, float_frame):\n        # corner case\n        df = DataFrame({\"B\": [1.0, 2.0, 3.0], \"C\": [\"a\", \"b\", \"c\"]}, index=np.arange(3))\n        del df[\"B\"]\n        df[\"B\"] = [1.0, 2.0, 3.0]\n        assert \"B\" in df\n        assert len(df.columns) == 2\n\n        df[\"A\"] = \"beginning\"\n        df[\"E\"] = \"foo\"\n        df[\"D\"] = \"bar\"\n        df[datetime.now()] = \"date\"\n        df[datetime.now()] = 5.0\n\n        # what to do when empty frame with index\n        dm = DataFrame(index=float_frame.index)\n        dm[\"A\"] = \"foo\"\n        dm[\"B\"] = \"bar\"\n        assert len(dm.columns) == 2\n        assert dm.values.dtype == np.object_\n\n        # upcast\n        dm[\"C\"] = 1\n        assert dm[\"C\"].dtype == np.int64\n\n        dm[\"E\"] = 1.0\n        assert dm[\"E\"].dtype == np.float64\n\n        # set existing column\n        dm[\"A\"] = \"bar\"\n        assert \"bar\" == dm[\"A\"][0]\n\n        dm = DataFrame(index=np.arange(3))\n        dm[\"A\"] = 1\n        dm[\"foo\"] = \"bar\"\n        del dm[\"foo\"]\n        dm[\"foo\"] = \"bar\"\n        assert dm[\"foo\"].dtype == np.object_\n\n        dm[\"coercable\"] = [\"1\", \"2\", \"3\"]\n        assert dm[\"coercable\"].dtype == np.object_",
        "begin_line": 647,
        "end_line": 687,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_corner2#689",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_corner2(self)",
        "snippet": "    def test_setitem_corner2(self):\n        data = {\n            \"title\": [\"foobar\", \"bar\", \"foobar\"] + [\"foobar\"] * 17,\n            \"cruft\": np.random.random(20),\n        }\n\n        df = DataFrame(data)\n        ix = df[df[\"title\"] == \"bar\"].index\n\n        df.loc[ix, [\"title\"]] = \"foobar\"\n        df.loc[ix, [\"cruft\"]] = 0\n\n        assert df.loc[1, \"title\"] == \"foobar\"\n        assert df.loc[1, \"cruft\"] == 0",
        "begin_line": 689,
        "end_line": 702,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_ambig#704",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_ambig(self)",
        "snippet": "    def test_setitem_ambig(self):\n        # Difficulties with mixed-type data\n        from decimal import Decimal\n\n        # Created as float type\n        dm = DataFrame(index=range(3), columns=range(3))\n\n        coercable_series = Series([Decimal(1) for _ in range(3)], index=range(3))\n        uncoercable_series = Series([\"foo\", \"bzr\", \"baz\"], index=range(3))\n\n        dm[0] = np.ones(3)\n        assert len(dm.columns) == 3\n\n        dm[1] = coercable_series\n        assert len(dm.columns) == 3\n\n        dm[2] = uncoercable_series\n        assert len(dm.columns) == 3\n        assert dm[2].dtype == np.object_",
        "begin_line": 704,
        "end_line": 722,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_clear_caches#724",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_clear_caches(self)",
        "snippet": "    def test_setitem_clear_caches(self):\n        # see gh-304\n        df = DataFrame(\n            {\"x\": [1.1, 2.1, 3.1, 4.1], \"y\": [5.1, 6.1, 7.1, 8.1]}, index=[0, 1, 2, 3]\n        )\n        df.insert(2, \"z\", np.nan)\n\n        # cache it\n        foo = df[\"z\"]\n        df.loc[df.index[2:], \"z\"] = 42\n\n        expected = Series([np.nan, np.nan, 42, 42], index=df.index, name=\"z\")\n\n        assert df[\"z\"] is not foo\n        tm.assert_series_equal(df[\"z\"], expected)",
        "begin_line": 724,
        "end_line": 738,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_None#740",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_None(self, float_frame)",
        "snippet": "    def test_setitem_None(self, float_frame):\n        # GH #766\n        float_frame[None] = float_frame[\"A\"]\n        tm.assert_series_equal(\n            float_frame.iloc[:, -1], float_frame[\"A\"], check_names=False\n        )\n        tm.assert_series_equal(\n            float_frame.loc[:, None], float_frame[\"A\"], check_names=False\n        )\n        tm.assert_series_equal(float_frame[None], float_frame[\"A\"], check_names=False)\n        repr(float_frame)",
        "begin_line": 740,
        "end_line": 750,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_empty#752",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_empty(self)",
        "snippet": "    def test_setitem_empty(self):\n        # GH 9596\n        df = pd.DataFrame(\n            {\"a\": [\"1\", \"2\", \"3\"], \"b\": [\"11\", \"22\", \"33\"], \"c\": [\"111\", \"222\", \"333\"]}\n        )\n\n        result = df.copy()\n        result.loc[result.b.isna(), \"a\"] = result.a\n        tm.assert_frame_equal(result, df)",
        "begin_line": 752,
        "end_line": 760,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_empty_frame_with_boolean#764",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_empty_frame_with_boolean(self, dtype, kwargs)",
        "snippet": "    def test_setitem_empty_frame_with_boolean(self, dtype, kwargs):\n        # see gh-10126\n        kwargs[\"dtype\"] = dtype\n        df = DataFrame(**kwargs)\n\n        df2 = df.copy()\n        df[df > df2] = 47\n        tm.assert_frame_equal(df, df2)",
        "begin_line": 764,
        "end_line": 771,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_with_empty_listlike#773",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_with_empty_listlike(self)",
        "snippet": "    def test_setitem_with_empty_listlike(self):\n        # GH #17101\n        index = pd.Index([], name=\"idx\")\n        result = pd.DataFrame(columns=[\"A\"], index=index)\n        result[\"A\"] = []\n        expected = pd.DataFrame(columns=[\"A\"], index=index)\n        tm.assert_index_equal(result.index, expected.index)",
        "begin_line": 773,
        "end_line": 779,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_scalars_no_index#781",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_scalars_no_index(self)",
        "snippet": "    def test_setitem_scalars_no_index(self):\n        # GH16823 / 17894\n        df = DataFrame()\n        df[\"foo\"] = 1\n        expected = DataFrame(columns=[\"foo\"]).astype(np.int64)\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 781,
        "end_line": 786,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_empty_frame_with_boolean#788",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_empty_frame_with_boolean(self)",
        "snippet": "    def test_getitem_empty_frame_with_boolean(self):\n        # Test for issue #11859\n\n        df = pd.DataFrame()\n        df2 = df[df > 0]\n        tm.assert_frame_equal(df, df2)",
        "begin_line": 788,
        "end_line": 793,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_delitem_corner#795",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_delitem_corner(self, float_frame)",
        "snippet": "    def test_delitem_corner(self, float_frame):\n        f = float_frame.copy()\n        del f[\"D\"]\n        assert len(f.columns) == 3\n        with pytest.raises(KeyError, match=r\"^'D'$\"):\n            del f[\"D\"]\n        del f[\"B\"]\n        assert len(f.columns) == 2",
        "begin_line": 795,
        "end_line": 802,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_slice_floats#804",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_slice_floats(self)",
        "snippet": "    def test_slice_floats(self):\n        index = [52195.504153, 52196.303147, 52198.369883]\n        df = DataFrame(np.random.rand(3, 2), index=index)\n\n        s1 = df.loc[52195.1:52196.5]\n        assert len(s1) == 2\n\n        s1 = df.loc[52195.1:52196.6]\n        assert len(s1) == 2\n\n        s1 = df.loc[52195.1:52198.9]\n        assert len(s1) == 3",
        "begin_line": 804,
        "end_line": 815,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_fancy_slice_integers_step#817",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_fancy_slice_integers_step(self)",
        "snippet": "    def test_getitem_fancy_slice_integers_step(self):\n        df = DataFrame(np.random.randn(10, 5))\n\n        # this is OK\n        result = df.iloc[:8:2]  # noqa\n        df.iloc[:8:2] = np.nan\n        assert isna(df.iloc[:8:2]).values.all()",
        "begin_line": 817,
        "end_line": 823,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_integer_slice_keyerrors#825",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_integer_slice_keyerrors(self)",
        "snippet": "    def test_getitem_setitem_integer_slice_keyerrors(self):\n        df = DataFrame(np.random.randn(10, 5), index=range(0, 20, 2))\n\n        # this is OK\n        cp = df.copy()\n        cp.iloc[4:10] = 0\n        assert (cp.iloc[4:10] == 0).values.all()\n\n        # so is this\n        cp = df.copy()\n        cp.iloc[3:11] = 0\n        assert (cp.iloc[3:11] == 0).values.all()\n\n        result = df.iloc[2:6]\n        result2 = df.loc[3:11]\n        expected = df.reindex([4, 6, 8, 10])\n\n        tm.assert_frame_equal(result, expected)\n        tm.assert_frame_equal(result2, expected)\n\n        # non-monotonic, raise KeyError\n        df2 = df.iloc[list(range(5)) + list(range(5, 10))[::-1]]\n        with pytest.raises(KeyError, match=r\"^3$\"):\n            df2.loc[3:11]\n        with pytest.raises(KeyError, match=r\"^3$\"):\n            df2.loc[3:11] = 0",
        "begin_line": 825,
        "end_line": 850,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_fancy_getitem_slice_mixed#852",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_fancy_getitem_slice_mixed(self, float_frame, float_string_frame)",
        "snippet": "    def test_fancy_getitem_slice_mixed(self, float_frame, float_string_frame):\n        sliced = float_string_frame.iloc[:, -3:]\n        assert sliced[\"D\"].dtype == np.float64\n\n        # get view with single block\n        # setting it triggers setting with copy\n        sliced = float_frame.iloc[:, -3:]\n\n        with pytest.raises(com.SettingWithCopyError):\n            sliced[\"C\"] = 4.0\n\n        assert (float_frame[\"C\"] == 4).all()",
        "begin_line": 852,
        "end_line": 863,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_slice_position#865",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_slice_position(self)",
        "snippet": "    def test_setitem_slice_position(self):\n        # GH#31469\n        df = pd.DataFrame(np.zeros((100, 1)))\n        df[-4:] = 1\n        arr = np.zeros((100, 1))\n        arr[-4:] = 1\n        expected = pd.DataFrame(arr)\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 865,
        "end_line": 872,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_non_ix_labels#874",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_non_ix_labels(self)",
        "snippet": "    def test_getitem_setitem_non_ix_labels(self):\n        df = tm.makeTimeDataFrame()\n\n        start, end = df.index[[5, 10]]\n\n        result = df.loc[start:end]\n        result2 = df[start:end]\n        expected = df[5:11]\n        tm.assert_frame_equal(result, expected)\n        tm.assert_frame_equal(result2, expected)\n\n        result = df.copy()\n        result.loc[start:end] = 0\n        result2 = df.copy()\n        result2[start:end] = 0\n        expected = df.copy()\n        expected[5:11] = 0\n        tm.assert_frame_equal(result, expected)\n        tm.assert_frame_equal(result2, expected)",
        "begin_line": 874,
        "end_line": 892,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_ix_multi_take#894",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_ix_multi_take(self)",
        "snippet": "    def test_ix_multi_take(self):\n        df = DataFrame(np.random.randn(3, 2))\n        rs = df.loc[df.index == 0, :]\n        xp = df.reindex([0])\n        tm.assert_frame_equal(rs, xp)\n\n        # FIXME: dont leave commented-out\n        \"\"\" #1321\n        df = DataFrame(np.random.randn(3, 2))\n        rs = df.loc[df.index==0, df.columns==1]\n        xp = df.reindex([0], [1])\n        tm.assert_frame_equal(rs, xp)\n        \"\"\"",
        "begin_line": 894,
        "end_line": 906,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_fancy_scalar#908",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_fancy_scalar(self, float_frame)",
        "snippet": "    def test_getitem_fancy_scalar(self, float_frame):\n        f = float_frame\n        ix = f.loc\n\n        # individual value\n        for col in f.columns:\n            ts = f[col]\n            for idx in f.index[::5]:\n                assert ix[idx, col] == ts[idx]",
        "begin_line": 908,
        "end_line": 916,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_fancy_scalar#918",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_fancy_scalar(self, float_frame)",
        "snippet": "    def test_setitem_fancy_scalar(self, float_frame):\n        f = float_frame\n        expected = float_frame.copy()\n        ix = f.loc\n\n        # individual value\n        for j, col in enumerate(f.columns):\n            ts = f[col]  # noqa\n            for idx in f.index[::5]:\n                i = f.index.get_loc(idx)\n                val = np.random.randn()\n                expected.values[i, j] = val\n\n                ix[idx, col] = val\n                tm.assert_frame_equal(f, expected)",
        "begin_line": 918,
        "end_line": 932,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_fancy_boolean#934",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_fancy_boolean(self, float_frame)",
        "snippet": "    def test_getitem_fancy_boolean(self, float_frame):\n        f = float_frame\n        ix = f.loc\n\n        expected = f.reindex(columns=[\"B\", \"D\"])\n        result = ix[:, [False, True, False, True]]\n        tm.assert_frame_equal(result, expected)\n\n        expected = f.reindex(index=f.index[5:10], columns=[\"B\", \"D\"])\n        result = ix[f.index[5:10], [False, True, False, True]]\n        tm.assert_frame_equal(result, expected)\n\n        boolvec = f.index > f.index[7]\n        expected = f.reindex(index=f.index[boolvec])\n        result = ix[boolvec]\n        tm.assert_frame_equal(result, expected)\n        result = ix[boolvec, :]\n        tm.assert_frame_equal(result, expected)\n\n        result = ix[boolvec, f.columns[2:]]\n        expected = f.reindex(index=f.index[boolvec], columns=[\"C\", \"D\"])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 934,
        "end_line": 955,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_fancy_boolean#957",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_fancy_boolean(self, float_frame)",
        "snippet": "    def test_setitem_fancy_boolean(self, float_frame):\n        # from 2d, set with booleans\n        frame = float_frame.copy()\n        expected = float_frame.copy()\n\n        mask = frame[\"A\"] > 0\n        frame.loc[mask] = 0.0\n        expected.values[mask.values] = 0.0\n        tm.assert_frame_equal(frame, expected)\n\n        frame = float_frame.copy()\n        expected = float_frame.copy()\n        frame.loc[mask, [\"A\", \"B\"]] = 0.0\n        expected.values[mask.values, :2] = 0.0\n        tm.assert_frame_equal(frame, expected)",
        "begin_line": 957,
        "end_line": 971,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_fancy_ints#973",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_fancy_ints(self, float_frame)",
        "snippet": "    def test_getitem_fancy_ints(self, float_frame):\n        result = float_frame.iloc[[1, 4, 7]]\n        expected = float_frame.loc[float_frame.index[[1, 4, 7]]]\n        tm.assert_frame_equal(result, expected)\n\n        result = float_frame.iloc[:, [2, 0, 1]]\n        expected = float_frame.loc[:, float_frame.columns[[2, 0, 1]]]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 973,
        "end_line": 980,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_fancy_exceptions#982",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_fancy_exceptions(self, float_frame)",
        "snippet": "    def test_getitem_setitem_fancy_exceptions(self, float_frame):\n        ix = float_frame.iloc\n        with pytest.raises(IndexingError, match=\"Too many indexers\"):\n            ix[:, :, :]\n\n        with pytest.raises(IndexingError):\n            ix[:, :, :] = 1",
        "begin_line": 982,
        "end_line": 988,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_boolean_misaligned#990",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_boolean_misaligned(self, float_frame)",
        "snippet": "    def test_getitem_setitem_boolean_misaligned(self, float_frame):\n        # boolean index misaligned labels\n        mask = float_frame[\"A\"][::-1] > 1\n\n        result = float_frame.loc[mask]\n        expected = float_frame.loc[mask[::-1]]\n        tm.assert_frame_equal(result, expected)\n\n        cp = float_frame.copy()\n        expected = float_frame.copy()\n        cp.loc[mask] = 0\n        expected.loc[mask] = 0\n        tm.assert_frame_equal(cp, expected)",
        "begin_line": 990,
        "end_line": 1002,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_boolean_multi#1004",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_boolean_multi(self)",
        "snippet": "    def test_getitem_setitem_boolean_multi(self):\n        df = DataFrame(np.random.randn(3, 2))\n\n        # get\n        k1 = np.array([True, False, True])\n        k2 = np.array([False, True])\n        result = df.loc[k1, k2]\n        expected = df.loc[[0, 2], [1]]\n        tm.assert_frame_equal(result, expected)\n\n        expected = df.copy()\n        df.loc[np.array([True, False, True]), np.array([False, True])] = 5\n        expected.loc[[0, 2], [1]] = 5\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 1004,
        "end_line": 1017,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_float_labels#1019",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_float_labels(self)",
        "snippet": "    def test_getitem_setitem_float_labels(self):\n        index = Index([1.5, 2, 3, 4, 5])\n        df = DataFrame(np.random.randn(5, 5), index=index)\n\n        result = df.loc[1.5:4]\n        expected = df.reindex([1.5, 2, 3, 4])\n        tm.assert_frame_equal(result, expected)\n        assert len(result) == 4\n\n        result = df.loc[4:5]\n        expected = df.reindex([4, 5])  # reindex with int\n        tm.assert_frame_equal(result, expected, check_index_type=False)\n        assert len(result) == 2\n\n        result = df.loc[4:5]\n        expected = df.reindex([4.0, 5.0])  # reindex with float\n        tm.assert_frame_equal(result, expected)\n        assert len(result) == 2\n\n        # loc_float changes this to work properly\n        result = df.loc[1:2]\n        expected = df.iloc[0:2]\n        tm.assert_frame_equal(result, expected)\n\n        df.loc[1:2] = 0\n        result = df[1:2]\n        assert (result == 0).all().all()\n\n        # #2727\n        index = Index([1.0, 2.5, 3.5, 4.5, 5.0])\n        df = DataFrame(np.random.randn(5, 5), index=index)\n\n        # positional slicing only via iloc!\n        msg = (\n            \"cannot do slice indexing on \"\n            r\"<class 'pandas\\.core\\.indexes\\.numeric\\.Float64Index'> with \"\n            r\"these indexers \\[1.0\\] of <class 'float'>\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            df.iloc[1.0:5]\n\n        result = df.iloc[4:5]\n        expected = df.reindex([5.0])\n        tm.assert_frame_equal(result, expected)\n        assert len(result) == 1\n\n        cp = df.copy()\n\n        with pytest.raises(TypeError):\n            cp.iloc[1.0:5] = 0\n\n        with pytest.raises(TypeError):\n            result = cp.iloc[1.0:5] == 0  # noqa\n\n        assert result.values.all()\n        assert (cp.iloc[0:1] == df.iloc[0:1]).values.all()\n\n        cp = df.copy()\n        cp.iloc[4:5] = 0\n        assert (cp.iloc[4:5] == 0).values.all()\n        assert (cp.iloc[0:4] == df.iloc[0:4]).values.all()\n\n        # float slicing\n        result = df.loc[1.0:5]\n        expected = df\n        tm.assert_frame_equal(result, expected)\n        assert len(result) == 5\n\n        result = df.loc[1.1:5]\n        expected = df.reindex([2.5, 3.5, 4.5, 5.0])\n        tm.assert_frame_equal(result, expected)\n        assert len(result) == 4\n\n        result = df.loc[4.51:5]\n        expected = df.reindex([5.0])\n        tm.assert_frame_equal(result, expected)\n        assert len(result) == 1\n\n        result = df.loc[1.0:5.0]\n        expected = df.reindex([1.0, 2.5, 3.5, 4.5, 5.0])\n        tm.assert_frame_equal(result, expected)\n        assert len(result) == 5\n\n        cp = df.copy()\n        cp.loc[1.0:5.0] = 0\n        result = cp.loc[1.0:5.0]\n        assert (result == 0).values.all()",
        "begin_line": 1019,
        "end_line": 1105,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_single_column_mixed#1107",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_single_column_mixed(self)",
        "snippet": "    def test_setitem_single_column_mixed(self):\n        df = DataFrame(\n            np.random.randn(5, 3),\n            index=[\"a\", \"b\", \"c\", \"d\", \"e\"],\n            columns=[\"foo\", \"bar\", \"baz\"],\n        )\n        df[\"str\"] = \"qux\"\n        df.loc[df.index[::2], \"str\"] = np.nan\n        expected = np.array([np.nan, \"qux\", np.nan, \"qux\", np.nan], dtype=object)\n        tm.assert_almost_equal(df[\"str\"].values, expected)",
        "begin_line": 1107,
        "end_line": 1116,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_single_column_mixed_datetime#1118",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_single_column_mixed_datetime(self)",
        "snippet": "    def test_setitem_single_column_mixed_datetime(self):\n        df = DataFrame(\n            np.random.randn(5, 3),\n            index=[\"a\", \"b\", \"c\", \"d\", \"e\"],\n            columns=[\"foo\", \"bar\", \"baz\"],\n        )\n\n        df[\"timestamp\"] = Timestamp(\"20010102\")\n\n        # check our dtypes\n        result = df.dtypes\n        expected = Series(\n            [np.dtype(\"float64\")] * 3 + [np.dtype(\"datetime64[ns]\")],\n            index=[\"foo\", \"bar\", \"baz\", \"timestamp\"],\n        )\n        tm.assert_series_equal(result, expected)\n\n        # GH#16674 iNaT is treated as an integer when given by the user\n        df.loc[\"b\", \"timestamp\"] = iNaT\n        assert not isna(df.loc[\"b\", \"timestamp\"])\n        assert df[\"timestamp\"].dtype == np.object_\n        assert df.loc[\"b\", \"timestamp\"] == iNaT\n\n        # allow this syntax\n        df.loc[\"c\", \"timestamp\"] = np.nan\n        assert isna(df.loc[\"c\", \"timestamp\"])\n\n        # allow this syntax\n        df.loc[\"d\", :] = np.nan\n        assert not isna(df.loc[\"c\", :]).all()",
        "begin_line": 1118,
        "end_line": 1147,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_mixed_datetime#1155",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_mixed_datetime(self)",
        "snippet": "    def test_setitem_mixed_datetime(self):\n        # GH 9336\n        expected = DataFrame(\n            {\n                \"a\": [0, 0, 0, 0, 13, 14],\n                \"b\": [\n                    datetime(2012, 1, 1),\n                    1,\n                    \"x\",\n                    \"y\",\n                    datetime(2013, 1, 1),\n                    datetime(2014, 1, 1),\n                ],\n            }\n        )\n        df = pd.DataFrame(0, columns=list(\"ab\"), index=range(6))\n        df[\"b\"] = pd.NaT\n        df.loc[0, \"b\"] = datetime(2012, 1, 1)\n        df.loc[1, \"b\"] = 1\n        df.loc[[2, 3], \"b\"] = \"x\", \"y\"\n        A = np.array(\n            [\n                [13, np.datetime64(\"2013-01-01T00:00:00\")],\n                [14, np.datetime64(\"2014-01-01T00:00:00\")],\n            ]\n        )\n        df.loc[[4, 5], [\"a\", \"b\"]] = A\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 1155,
        "end_line": 1182,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_frame_float#1184",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_frame_float(self, float_frame)",
        "snippet": "    def test_setitem_frame_float(self, float_frame):\n        piece = float_frame.loc[float_frame.index[:2], [\"A\", \"B\"]]\n        float_frame.loc[float_frame.index[-2] :, [\"A\", \"B\"]] = piece.values\n        result = float_frame.loc[float_frame.index[-2:], [\"A\", \"B\"]].values\n        expected = piece.values\n        tm.assert_almost_equal(result, expected)",
        "begin_line": 1184,
        "end_line": 1189,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_frame_mixed#1191",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_frame_mixed(self, float_string_frame)",
        "snippet": "    def test_setitem_frame_mixed(self, float_string_frame):\n        # GH 3216\n\n        # already aligned\n        f = float_string_frame.copy()\n        piece = DataFrame(\n            [[1.0, 2.0], [3.0, 4.0]], index=f.index[0:2], columns=[\"A\", \"B\"]\n        )\n        key = (slice(None, 2), [\"A\", \"B\"])\n        f.loc[key] = piece\n        tm.assert_almost_equal(f.loc[f.index[0:2], [\"A\", \"B\"]].values, piece.values)\n\n        # rows unaligned\n        f = float_string_frame.copy()\n        piece = DataFrame(\n            [[1.0, 2.0], [3.0, 4.0], [5.0, 6.0], [7.0, 8.0]],\n            index=list(f.index[0:2]) + [\"foo\", \"bar\"],\n            columns=[\"A\", \"B\"],\n        )\n        key = (slice(None, 2), [\"A\", \"B\"])\n        f.loc[key] = piece\n        tm.assert_almost_equal(\n            f.loc[f.index[0:2:], [\"A\", \"B\"]].values, piece.values[0:2]\n        )\n\n        # key is unaligned with values\n        f = float_string_frame.copy()\n        piece = f.loc[f.index[:2], [\"A\"]]\n        piece.index = f.index[-2:]\n        key = (slice(-2, None), [\"A\", \"B\"])\n        f.loc[key] = piece\n        piece[\"B\"] = np.nan\n        tm.assert_almost_equal(f.loc[f.index[-2:], [\"A\", \"B\"]].values, piece.values)\n\n        # ndarray\n        f = float_string_frame.copy()\n        piece = float_string_frame.loc[f.index[:2], [\"A\", \"B\"]]\n        key = (slice(-2, None), [\"A\", \"B\"])\n        f.loc[key] = piece.values\n        tm.assert_almost_equal(f.loc[f.index[-2:], [\"A\", \"B\"]].values, piece.values)",
        "begin_line": 1191,
        "end_line": 1230,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_frame_upcast#1232",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_frame_upcast(self)",
        "snippet": "    def test_setitem_frame_upcast(self):\n        # needs upcasting\n        df = DataFrame([[1, 2, \"foo\"], [3, 4, \"bar\"]], columns=[\"A\", \"B\", \"C\"])\n        df2 = df.copy()\n        df2.loc[:, [\"A\", \"B\"]] = df.loc[:, [\"A\", \"B\"]] + 0.5\n        expected = df.reindex(columns=[\"A\", \"B\"])\n        expected += 0.5\n        expected[\"C\"] = df[\"C\"]\n        tm.assert_frame_equal(df2, expected)",
        "begin_line": 1232,
        "end_line": 1240,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_frame_align#1242",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_frame_align(self, float_frame)",
        "snippet": "    def test_setitem_frame_align(self, float_frame):\n        piece = float_frame.loc[float_frame.index[:2], [\"A\", \"B\"]]\n        piece.index = float_frame.index[-2:]\n        piece.columns = [\"A\", \"B\"]\n        float_frame.loc[float_frame.index[-2:], [\"A\", \"B\"]] = piece\n        result = float_frame.loc[float_frame.index[-2:], [\"A\", \"B\"]].values\n        expected = piece.values\n        tm.assert_almost_equal(result, expected)",
        "begin_line": 1242,
        "end_line": 1249,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_ix_duplicates#1251",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_ix_duplicates(self)",
        "snippet": "    def test_getitem_setitem_ix_duplicates(self):\n        # #1201\n        df = DataFrame(np.random.randn(5, 3), index=[\"foo\", \"foo\", \"bar\", \"baz\", \"bar\"])\n\n        result = df.loc[\"foo\"]\n        expected = df[:2]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[\"bar\"]\n        expected = df.iloc[[2, 4]]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[\"baz\"]\n        expected = df.iloc[3]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1251,
        "end_line": 1265,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_ix_boolean_duplicates_multiple#1267",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_ix_boolean_duplicates_multiple(self)",
        "snippet": "    def test_getitem_ix_boolean_duplicates_multiple(self):\n        # #1201\n        df = DataFrame(np.random.randn(5, 3), index=[\"foo\", \"foo\", \"bar\", \"baz\", \"bar\"])\n\n        result = df.loc[[\"bar\"]]\n        exp = df.iloc[[2, 4]]\n        tm.assert_frame_equal(result, exp)\n\n        result = df.loc[df[1] > 0]\n        exp = df[df[1] > 0]\n        tm.assert_frame_equal(result, exp)\n\n        result = df.loc[df[0] > 0]\n        exp = df[df[0] > 0]\n        tm.assert_frame_equal(result, exp)",
        "begin_line": 1267,
        "end_line": 1281,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_ix_bool_keyerror#1283",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_ix_bool_keyerror(self)",
        "snippet": "    def test_getitem_setitem_ix_bool_keyerror(self):\n        # #2199\n        df = DataFrame({\"a\": [1, 2, 3]})\n\n        with pytest.raises(KeyError, match=r\"^False$\"):\n            df.loc[False]\n        with pytest.raises(KeyError, match=r\"^True$\"):\n            df.loc[True]\n\n        msg = \"cannot use a single bool to index into setitem\"\n        with pytest.raises(KeyError, match=msg):\n            df.loc[False] = 0\n        with pytest.raises(KeyError, match=msg):\n            df.loc[True] = 0",
        "begin_line": 1283,
        "end_line": 1296,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_list_duplicates#1298",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_list_duplicates(self)",
        "snippet": "    def test_getitem_list_duplicates(self):\n        # #1943\n        df = DataFrame(np.random.randn(4, 4), columns=list(\"AABC\"))\n        df.columns.name = \"foo\"\n\n        result = df[[\"B\", \"C\"]]\n        assert result.columns.name == \"foo\"\n\n        expected = df.iloc[:, 2:]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1298,
        "end_line": 1307,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_get_value#1309",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_get_value(self, float_frame)",
        "snippet": "    def test_get_value(self, float_frame):\n        for idx in float_frame.index:\n            for col in float_frame.columns:\n                result = float_frame._get_value(idx, col)\n                expected = float_frame[col][idx]\n                assert result == expected",
        "begin_line": 1309,
        "end_line": 1314,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_lookup_float#1316",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_lookup_float(self, float_frame)",
        "snippet": "    def test_lookup_float(self, float_frame):\n        df = float_frame\n        rows = list(df.index) * len(df.columns)\n        cols = list(df.columns) * len(df.index)\n        result = df.lookup(rows, cols)\n\n        expected = np.array([df.loc[r, c] for r, c in zip(rows, cols)])\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 1316,
        "end_line": 1323,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_lookup_mixed#1325",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_lookup_mixed(self, float_string_frame)",
        "snippet": "    def test_lookup_mixed(self, float_string_frame):\n        df = float_string_frame\n        rows = list(df.index) * len(df.columns)\n        cols = list(df.columns) * len(df.index)\n        result = df.lookup(rows, cols)\n\n        expected = np.array(\n            [df.loc[r, c] for r, c in zip(rows, cols)], dtype=np.object_\n        )\n        tm.assert_almost_equal(result, expected)",
        "begin_line": 1325,
        "end_line": 1334,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_lookup_bool#1336",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_lookup_bool(self)",
        "snippet": "    def test_lookup_bool(self):\n        df = DataFrame(\n            {\n                \"label\": [\"a\", \"b\", \"a\", \"c\"],\n                \"mask_a\": [True, True, False, True],\n                \"mask_b\": [True, False, False, False],\n                \"mask_c\": [False, True, False, True],\n            }\n        )\n        df[\"mask\"] = df.lookup(df.index, \"mask_\" + df[\"label\"])\n\n        exp_mask = np.array(\n            [df.loc[r, c] for r, c in zip(df.index, \"mask_\" + df[\"label\"])]\n        )\n\n        tm.assert_series_equal(df[\"mask\"], pd.Series(exp_mask, name=\"mask\"))\n        assert df[\"mask\"].dtype == np.bool_",
        "begin_line": 1336,
        "end_line": 1352,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_lookup_raises#1354",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_lookup_raises(self, float_frame)",
        "snippet": "    def test_lookup_raises(self, float_frame):\n        with pytest.raises(KeyError, match=\"'One or more row labels was not found'\"):\n            float_frame.lookup([\"xyz\"], [\"A\"])\n\n        with pytest.raises(KeyError, match=\"'One or more column labels was not found'\"):\n            float_frame.lookup([float_frame.index[0]], [\"xyz\"])\n\n        with pytest.raises(ValueError, match=\"same size\"):\n            float_frame.lookup([\"a\", \"b\", \"c\"], [\"a\"])",
        "begin_line": 1354,
        "end_line": 1362,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_set_value#1364",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_set_value(self, float_frame)",
        "snippet": "    def test_set_value(self, float_frame):\n        for idx in float_frame.index:\n            for col in float_frame.columns:\n                float_frame._set_value(idx, col, 1)\n                assert float_frame[col][idx] == 1",
        "begin_line": 1364,
        "end_line": 1368,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_set_value_resize#1370",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_set_value_resize(self, float_frame)",
        "snippet": "    def test_set_value_resize(self, float_frame):\n\n        res = float_frame._set_value(\"foobar\", \"B\", 0)\n        assert res is float_frame\n        assert res.index[-1] == \"foobar\"\n        assert res._get_value(\"foobar\", \"B\") == 0\n\n        float_frame.loc[\"foobar\", \"qux\"] = 0\n        assert float_frame._get_value(\"foobar\", \"qux\") == 0\n\n        res = float_frame.copy()\n        res3 = res._set_value(\"foobar\", \"baz\", \"sam\")\n        assert res3[\"baz\"].dtype == np.object_\n\n        res = float_frame.copy()\n        res3 = res._set_value(\"foobar\", \"baz\", True)\n        assert res3[\"baz\"].dtype == np.object_\n\n        res = float_frame.copy()\n        res3 = res._set_value(\"foobar\", \"baz\", 5)\n        assert is_float_dtype(res3[\"baz\"])\n        assert isna(res3[\"baz\"].drop([\"foobar\"])).all()\n        msg = \"could not convert string to float: 'sam'\"\n        with pytest.raises(ValueError, match=msg):\n            res3._set_value(\"foobar\", \"baz\", \"sam\")",
        "begin_line": 1370,
        "end_line": 1394,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_set_value_with_index_dtype_change#1396",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_set_value_with_index_dtype_change(self)",
        "snippet": "    def test_set_value_with_index_dtype_change(self):\n        df_orig = DataFrame(np.random.randn(3, 3), index=range(3), columns=list(\"ABC\"))\n\n        # this is actually ambiguous as the 2 is interpreted as a positional\n        # so column is not created\n        df = df_orig.copy()\n        df._set_value(\"C\", 2, 1.0)\n        assert list(df.index) == list(df_orig.index) + [\"C\"]\n        # assert list(df.columns) == list(df_orig.columns) + [2]\n\n        df = df_orig.copy()\n        df.loc[\"C\", 2] = 1.0\n        assert list(df.index) == list(df_orig.index) + [\"C\"]\n        # assert list(df.columns) == list(df_orig.columns) + [2]\n\n        # create both new\n        df = df_orig.copy()\n        df._set_value(\"C\", \"D\", 1.0)\n        assert list(df.index) == list(df_orig.index) + [\"C\"]\n        assert list(df.columns) == list(df_orig.columns) + [\"D\"]\n\n        df = df_orig.copy()\n        df.loc[\"C\", \"D\"] = 1.0\n        assert list(df.index) == list(df_orig.index) + [\"C\"]\n        assert list(df.columns) == list(df_orig.columns) + [\"D\"]",
        "begin_line": 1396,
        "end_line": 1420,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_get_set_value_no_partial_indexing#1422",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_get_set_value_no_partial_indexing(self)",
        "snippet": "    def test_get_set_value_no_partial_indexing(self):\n        # partial w/ MultiIndex raise exception\n        index = MultiIndex.from_tuples([(0, 1), (0, 2), (1, 1), (1, 2)])\n        df = DataFrame(index=index, columns=range(4))\n        with pytest.raises(KeyError, match=r\"^0$\"):\n            df._get_value(0, 1)",
        "begin_line": 1422,
        "end_line": 1427,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_single_element_ix_dont_upcast#1430",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_single_element_ix_dont_upcast(self, float_frame)",
        "snippet": "    def test_single_element_ix_dont_upcast(self, float_frame):\n        float_frame[\"E\"] = 1\n        assert issubclass(float_frame[\"E\"].dtype.type, (int, np.integer))\n\n        result = float_frame.loc[float_frame.index[5], \"E\"]\n        assert is_integer(result)\n\n        # GH 11617\n        df = pd.DataFrame(dict(a=[1.23]))\n        df[\"b\"] = 666\n\n        result = df.loc[0, \"b\"]\n        assert is_integer(result)\n\n        expected = Series([666], [0], name=\"b\")\n        result = df.loc[[0], \"b\"]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1430,
        "end_line": 1446,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_iloc_row#1448",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_iloc_row(self)",
        "snippet": "    def test_iloc_row(self):\n        df = DataFrame(np.random.randn(10, 4), index=range(0, 20, 2))\n\n        result = df.iloc[1]\n        exp = df.loc[2]\n        tm.assert_series_equal(result, exp)\n\n        result = df.iloc[2]\n        exp = df.loc[4]\n        tm.assert_series_equal(result, exp)\n\n        # slice\n        result = df.iloc[slice(4, 8)]\n        expected = df.loc[8:14]\n        tm.assert_frame_equal(result, expected)\n\n        # verify slice is view\n        # setting it makes it raise/warn\n        with pytest.raises(com.SettingWithCopyError):\n            result[2] = 0.0\n\n        exp_col = df[2].copy()\n        exp_col[4:8] = 0.0\n        tm.assert_series_equal(df[2], exp_col)\n\n        # list of integers\n        result = df.iloc[[1, 2, 4, 6]]\n        expected = df.reindex(df.index[[1, 2, 4, 6]])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1448,
        "end_line": 1476,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_iloc_col#1478",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_iloc_col(self)",
        "snippet": "    def test_iloc_col(self):\n\n        df = DataFrame(np.random.randn(4, 10), columns=range(0, 20, 2))\n\n        result = df.iloc[:, 1]\n        exp = df.loc[:, 2]\n        tm.assert_series_equal(result, exp)\n\n        result = df.iloc[:, 2]\n        exp = df.loc[:, 4]\n        tm.assert_series_equal(result, exp)\n\n        # slice\n        result = df.iloc[:, slice(4, 8)]\n        expected = df.loc[:, 8:14]\n        tm.assert_frame_equal(result, expected)\n\n        # verify slice is view\n        # and that we are setting a copy\n        with pytest.raises(com.SettingWithCopyError):\n            result[8] = 0.0\n\n        assert (df[8] == 0).all()\n\n        # list of integers\n        result = df.iloc[:, [1, 2, 4, 6]]\n        expected = df.reindex(columns=df.columns[[1, 2, 4, 6]])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1478,
        "end_line": 1505,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_iloc_duplicates#1507",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_iloc_duplicates(self)",
        "snippet": "    def test_iloc_duplicates(self):\n\n        df = DataFrame(np.random.rand(3, 3), columns=list(\"ABC\"), index=list(\"aab\"))\n\n        result = df.iloc[0]\n        assert isinstance(result, Series)\n        tm.assert_almost_equal(result.values, df.values[0])\n\n        result = df.T.iloc[:, 0]\n        assert isinstance(result, Series)\n        tm.assert_almost_equal(result.values, df.values[0])\n\n        # #2259\n        df = DataFrame([[1, 2, 3], [4, 5, 6]], columns=[1, 1, 2])\n        result = df.iloc[:, [0]]\n        expected = df.take([0], axis=1)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1507,
        "end_line": 1523,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_loc_duplicates#1525",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_loc_duplicates(self)",
        "snippet": "    def test_loc_duplicates(self):\n        # gh-17105\n\n        # insert a duplicate element to the index\n        trange = pd.date_range(\n            start=pd.Timestamp(year=2017, month=1, day=1),\n            end=pd.Timestamp(year=2017, month=1, day=5),\n        )\n\n        trange = trange.insert(loc=5, item=pd.Timestamp(year=2017, month=1, day=5))\n\n        df = pd.DataFrame(0, index=trange, columns=[\"A\", \"B\"])\n        bool_idx = np.array([False, False, False, False, False, True])\n\n        # assignment\n        df.loc[trange[bool_idx], \"A\"] = 6\n\n        expected = pd.DataFrame(\n            {\"A\": [0, 0, 0, 0, 6, 6], \"B\": [0, 0, 0, 0, 0, 0]}, index=trange\n        )\n        tm.assert_frame_equal(df, expected)\n\n        # in-place\n        df = pd.DataFrame(0, index=trange, columns=[\"A\", \"B\"])\n        df.loc[trange[bool_idx], \"A\"] += 6\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 1525,
        "end_line": 1550,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_methods#1560",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_methods(self, method, expected_values)",
        "snippet": "    def test_reindex_methods(self, method, expected_values):\n        df = pd.DataFrame({\"x\": list(range(5))})\n        target = np.array([-0.1, 0.9, 1.1, 1.5])\n\n        expected = pd.DataFrame({\"x\": expected_values}, index=target)\n        actual = df.reindex(target, method=method)\n        tm.assert_frame_equal(expected, actual)\n\n        actual = df.reindex_like(df, method=method, tolerance=0)\n        tm.assert_frame_equal(df, actual)\n        actual = df.reindex_like(df, method=method, tolerance=[0, 0, 0, 0])\n        tm.assert_frame_equal(df, actual)\n\n        actual = df.reindex(target, method=method, tolerance=1)\n        tm.assert_frame_equal(expected, actual)\n        actual = df.reindex(target, method=method, tolerance=[1, 1, 1, 1])\n        tm.assert_frame_equal(expected, actual)\n\n        e2 = expected[::-1]\n        actual = df.reindex(target[::-1], method=method)\n        tm.assert_frame_equal(e2, actual)\n\n        new_order = [3, 0, 2, 1]\n        e2 = expected.iloc[new_order]\n        actual = df.reindex(target[new_order], method=method)\n        tm.assert_frame_equal(e2, actual)\n\n        switched_method = (\n            \"pad\" if method == \"backfill\" else \"backfill\" if method == \"pad\" else method\n        )\n        actual = df[::-1].reindex(target, method=switched_method)\n        tm.assert_frame_equal(expected, actual)",
        "begin_line": 1560,
        "end_line": 1591,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_methods_nearest_special#1593",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_methods_nearest_special(self)",
        "snippet": "    def test_reindex_methods_nearest_special(self):\n        df = pd.DataFrame({\"x\": list(range(5))})\n        target = np.array([-0.1, 0.9, 1.1, 1.5])\n\n        expected = pd.DataFrame({\"x\": [0, 1, 1, np.nan]}, index=target)\n        actual = df.reindex(target, method=\"nearest\", tolerance=0.2)\n        tm.assert_frame_equal(expected, actual)\n\n        expected = pd.DataFrame({\"x\": [0, np.nan, 1, np.nan]}, index=target)\n        actual = df.reindex(target, method=\"nearest\", tolerance=[0.5, 0.01, 0.4, 0.1])\n        tm.assert_frame_equal(expected, actual)",
        "begin_line": 1593,
        "end_line": 1603,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_nearest_tz#1605",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_nearest_tz(self, tz_aware_fixture)",
        "snippet": "    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n\n        expected = df.head(3)\n        actual = df.reindex(idx[:3], method=\"nearest\")\n        tm.assert_frame_equal(expected, actual)",
        "begin_line": 1605,
        "end_line": 1613,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_frame_add_nat#1615",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_frame_add_nat(self)",
        "snippet": "    def test_reindex_frame_add_nat(self):\n        rng = date_range(\"1/1/2000 00:00:00\", periods=10, freq=\"10s\")\n        df = DataFrame({\"A\": np.random.randn(len(rng)), \"B\": rng})\n\n        result = df.reindex(range(15))\n        assert np.issubdtype(result[\"B\"].dtype, np.dtype(\"M8[ns]\"))\n\n        mask = com.isna(result)[\"B\"]\n        assert mask[-5:].all()\n        assert not mask[:-5].any()",
        "begin_line": 1615,
        "end_line": 1624,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_limit#1626",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_limit(self)",
        "snippet": "    def test_reindex_limit(self):\n        # GH 28631\n        data = [[\"A\", \"A\", \"A\"], [\"B\", \"B\", \"B\"], [\"C\", \"C\", \"C\"], [\"D\", \"D\", \"D\"]]\n        exp_data = [\n            [\"A\", \"A\", \"A\"],\n            [\"B\", \"B\", \"B\"],\n            [\"C\", \"C\", \"C\"],\n            [\"D\", \"D\", \"D\"],\n            [\"D\", \"D\", \"D\"],\n            [np.nan, np.nan, np.nan],\n        ]\n        df = DataFrame(data)\n        result = df.reindex([0, 1, 2, 3, 4, 5], method=\"ffill\", limit=1)\n        expected = DataFrame(exp_data)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1626,
        "end_line": 1640,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_set_dataframe_column_ns_dtype#1642",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_set_dataframe_column_ns_dtype(self)",
        "snippet": "    def test_set_dataframe_column_ns_dtype(self):\n        x = DataFrame([datetime.now(), datetime.now()])\n        assert x[0].dtype == np.dtype(\"M8[ns]\")",
        "begin_line": 1642,
        "end_line": 1644,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_non_monotonic_reindex_methods#1646",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_non_monotonic_reindex_methods(self)",
        "snippet": "    def test_non_monotonic_reindex_methods(self):\n        dr = pd.date_range(\"2013-08-01\", periods=6, freq=\"B\")\n        data = np.random.randn(6, 1)\n        df = pd.DataFrame(data, index=dr, columns=list(\"A\"))\n        df_rev = pd.DataFrame(data, index=dr[[3, 4, 5] + [0, 1, 2]], columns=list(\"A\"))\n        # index is not monotonic increasing or decreasing\n        msg = \"index must be monotonic increasing or decreasing\"\n        with pytest.raises(ValueError, match=msg):\n            df_rev.reindex(df.index, method=\"pad\")\n        with pytest.raises(ValueError, match=msg):\n            df_rev.reindex(df.index, method=\"ffill\")\n        with pytest.raises(ValueError, match=msg):\n            df_rev.reindex(df.index, method=\"bfill\")\n        with pytest.raises(ValueError, match=msg):\n            df_rev.reindex(df.index, method=\"nearest\")",
        "begin_line": 1646,
        "end_line": 1660,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_level#1662",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_level(self)",
        "snippet": "    def test_reindex_level(self):\n        from itertools import permutations\n\n        icol = [\"jim\", \"joe\", \"jolie\"]\n\n        def verify_first_level(df, level, idx, check_index_type=True):\n            def f(val):\n                return np.nonzero((df[level] == val).to_numpy())[0]\n\n            i = np.concatenate(list(map(f, idx)))\n            left = df.set_index(icol).reindex(idx, level=level)\n            right = df.iloc[i].set_index(icol)\n            tm.assert_frame_equal(left, right, check_index_type=check_index_type)\n\n        def verify(df, level, idx, indexer, check_index_type=True):\n            left = df.set_index(icol).reindex(idx, level=level)\n            right = df.iloc[indexer].set_index(icol)\n            tm.assert_frame_equal(left, right, check_index_type=check_index_type)\n\n        df = pd.DataFrame(\n            {\n                \"jim\": list(\"B\" * 4 + \"A\" * 2 + \"C\" * 3),\n                \"joe\": list(\"abcdeabcd\")[::-1],\n                \"jolie\": [10, 20, 30] * 3,\n                \"joline\": np.random.randint(0, 1000, 9),\n            }\n        )\n\n        target = [\n            [\"C\", \"B\", \"A\"],\n            [\"F\", \"C\", \"A\", \"D\"],\n            [\"A\"],\n            [\"A\", \"B\", \"C\"],\n            [\"C\", \"A\", \"B\"],\n            [\"C\", \"B\"],\n            [\"C\", \"A\"],\n            [\"A\", \"B\"],\n            [\"B\", \"A\", \"C\"],\n        ]\n\n        for idx in target:\n            verify_first_level(df, \"jim\", idx)\n\n        # reindex by these causes different MultiIndex levels\n        for idx in [[\"D\", \"F\"], [\"A\", \"C\", \"B\"]]:\n            verify_first_level(df, \"jim\", idx, check_index_type=False)\n\n        verify(df, \"joe\", list(\"abcde\"), [3, 2, 1, 0, 5, 4, 8, 7, 6])\n        verify(df, \"joe\", list(\"abcd\"), [3, 2, 1, 0, 5, 8, 7, 6])\n        verify(df, \"joe\", list(\"abc\"), [3, 2, 1, 8, 7, 6])\n        verify(df, \"joe\", list(\"eca\"), [1, 3, 4, 6, 8])\n        verify(df, \"joe\", list(\"edc\"), [0, 1, 4, 5, 6])\n        verify(df, \"joe\", list(\"eadbc\"), [3, 0, 2, 1, 4, 5, 8, 7, 6])\n        verify(df, \"joe\", list(\"edwq\"), [0, 4, 5])\n        verify(df, \"joe\", list(\"wq\"), [], check_index_type=False)\n\n        df = DataFrame(\n            {\n                \"jim\": [\"mid\"] * 5 + [\"btm\"] * 8 + [\"top\"] * 7,\n                \"joe\": [\"3rd\"] * 2\n                + [\"1st\"] * 3\n                + [\"2nd\"] * 3\n                + [\"1st\"] * 2\n                + [\"3rd\"] * 3\n                + [\"1st\"] * 2\n                + [\"3rd\"] * 3\n                + [\"2nd\"] * 2,\n                # this needs to be jointly unique with jim and joe or\n                # reindexing will fail ~1.5% of the time, this works\n                # out to needing unique groups of same size as joe\n                \"jolie\": np.concatenate(\n                    [\n                        np.random.choice(1000, x, replace=False)\n                        for x in [2, 3, 3, 2, 3, 2, 3, 2]\n                    ]\n                ),\n                \"joline\": np.random.randn(20).round(3) * 10,\n            }\n        )\n\n        for idx in permutations(df[\"jim\"].unique()):\n            for i in range(3):\n                verify_first_level(df, \"jim\", idx[: i + 1])\n\n        i = [2, 3, 4, 0, 1, 8, 9, 5, 6, 7, 10, 11, 12, 13, 14, 18, 19, 15, 16, 17]\n        verify(df, \"joe\", [\"1st\", \"2nd\", \"3rd\"], i)\n\n        i = [0, 1, 2, 3, 4, 10, 11, 12, 5, 6, 7, 8, 9, 15, 16, 17, 18, 19, 13, 14]\n        verify(df, \"joe\", [\"3rd\", \"2nd\", \"1st\"], i)\n\n        i = [0, 1, 5, 6, 7, 10, 11, 12, 18, 19, 15, 16, 17]\n        verify(df, \"joe\", [\"2nd\", \"3rd\"], i)\n\n        i = [0, 1, 2, 3, 4, 10, 11, 12, 8, 9, 15, 16, 17, 13, 14]\n        verify(df, \"joe\", [\"3rd\", \"1st\"], i)",
        "begin_line": 1662,
        "end_line": 1756,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.verify_first_level#1667",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.verify_first_level(df, level, idx, check_index_type=True)",
        "snippet": "        def verify_first_level(df, level, idx, check_index_type=True):\n            def f(val):\n                return np.nonzero((df[level] == val).to_numpy())[0]\n\n            i = np.concatenate(list(map(f, idx)))\n            left = df.set_index(icol).reindex(idx, level=level)\n            right = df.iloc[i].set_index(icol)\n            tm.assert_frame_equal(left, right, check_index_type=check_index_type)",
        "begin_line": 1667,
        "end_line": 1674,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.f#1668",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.f(val)",
        "snippet": "            def f(val):\n                return np.nonzero((df[level] == val).to_numpy())[0]",
        "begin_line": 1668,
        "end_line": 1669,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.verify#1676",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.verify(df, level, idx, indexer, check_index_type=True)",
        "snippet": "        def verify(df, level, idx, indexer, check_index_type=True):\n            left = df.set_index(icol).reindex(idx, level=level)\n            right = df.iloc[indexer].set_index(icol)\n            tm.assert_frame_equal(left, right, check_index_type=check_index_type)",
        "begin_line": 1676,
        "end_line": 1679,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_ix_float_duplicates#1758",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_ix_float_duplicates(self)",
        "snippet": "    def test_getitem_ix_float_duplicates(self):\n        df = pd.DataFrame(\n            np.random.randn(3, 3), index=[0.1, 0.2, 0.2], columns=list(\"abc\")\n        )\n        expect = df.iloc[1:]\n        tm.assert_frame_equal(df.loc[0.2], expect)\n\n        expect = df.iloc[1:, 0]\n        tm.assert_series_equal(df.loc[0.2, \"a\"], expect)\n\n        df.index = [1, 0.2, 0.2]\n        expect = df.iloc[1:]\n        tm.assert_frame_equal(df.loc[0.2], expect)\n\n        expect = df.iloc[1:, 0]\n        tm.assert_series_equal(df.loc[0.2, \"a\"], expect)\n\n        df = pd.DataFrame(\n            np.random.randn(4, 3), index=[1, 0.2, 0.2, 1], columns=list(\"abc\")\n        )\n        expect = df.iloc[1:-1]\n        tm.assert_frame_equal(df.loc[0.2], expect)\n\n        expect = df.iloc[1:-1, 0]\n        tm.assert_series_equal(df.loc[0.2, \"a\"], expect)\n\n        df.index = [0.1, 0.2, 2, 0.2]\n        expect = df.iloc[[1, -1]]\n        tm.assert_frame_equal(df.loc[0.2], expect)\n\n        expect = df.iloc[[1, -1], 0]\n        tm.assert_series_equal(df.loc[0.2, \"a\"], expect)",
        "begin_line": 1758,
        "end_line": 1789,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_sparse_column#1791",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_sparse_column(self)",
        "snippet": "    def test_getitem_sparse_column(self):\n        # https://github.com/pandas-dev/pandas/issues/23559\n        data = SparseArray([0, 1])\n        df = pd.DataFrame({\"A\": data})\n        expected = pd.Series(data, name=\"A\")\n        result = df[\"A\"]\n        tm.assert_series_equal(result, expected)\n\n        result = df.iloc[:, 0]\n        tm.assert_series_equal(result, expected)\n\n        result = df.loc[:, \"A\"]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1791,
        "end_line": 1803,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_with_sparse_value#1805",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_with_sparse_value(self)",
        "snippet": "    def test_setitem_with_sparse_value(self):\n        # GH8131\n        df = pd.DataFrame({\"c_1\": [\"a\", \"b\", \"c\"], \"n_1\": [1.0, 2.0, 3.0]})\n        sp_array = SparseArray([0, 0, 1])\n        df[\"new_column\"] = sp_array\n        tm.assert_series_equal(\n            df[\"new_column\"], pd.Series(sp_array, name=\"new_column\"), check_names=False\n        )",
        "begin_line": 1805,
        "end_line": 1812,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_with_unaligned_sparse_value#1814",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_with_unaligned_sparse_value(self)",
        "snippet": "    def test_setitem_with_unaligned_sparse_value(self):\n        df = pd.DataFrame({\"c_1\": [\"a\", \"b\", \"c\"], \"n_1\": [1.0, 2.0, 3.0]})\n        sp_series = pd.Series(SparseArray([0, 0, 1]), index=[2, 1, 0])\n        df[\"new_column\"] = sp_series\n        exp = pd.Series(SparseArray([1, 0, 0]), name=\"new_column\")\n        tm.assert_series_equal(df[\"new_column\"], exp)",
        "begin_line": 1814,
        "end_line": 1819,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_with_unaligned_tz_aware_datetime_column#1821",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_with_unaligned_tz_aware_datetime_column(self)",
        "snippet": "    def test_setitem_with_unaligned_tz_aware_datetime_column(self):\n        # GH 12981\n        # Assignment of unaligned offset-aware datetime series.\n        # Make sure timezone isn't lost\n        column = pd.Series(\n            pd.date_range(\"2015-01-01\", periods=3, tz=\"utc\"), name=\"dates\"\n        )\n        df = pd.DataFrame({\"dates\": column})\n        df[\"dates\"] = column[[1, 0, 2]]\n        tm.assert_series_equal(df[\"dates\"], column)\n\n        df = pd.DataFrame({\"dates\": column})\n        df.loc[[0, 1, 2], \"dates\"] = column[[1, 0, 2]]\n        tm.assert_series_equal(df[\"dates\"], column)",
        "begin_line": 1821,
        "end_line": 1834,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_datetime_coercion#1836",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_datetime_coercion(self)",
        "snippet": "    def test_setitem_datetime_coercion(self):\n        # gh-1048\n        df = pd.DataFrame({\"c\": [pd.Timestamp(\"2010-10-01\")] * 3})\n        df.loc[0:1, \"c\"] = np.datetime64(\"2008-08-08\")\n        assert pd.Timestamp(\"2008-08-08\") == df.loc[0, \"c\"]\n        assert pd.Timestamp(\"2008-08-08\") == df.loc[1, \"c\"]\n        df.loc[2, \"c\"] = date(2005, 5, 5)\n        assert pd.Timestamp(\"2005-05-05\") == df.loc[2, \"c\"]",
        "begin_line": 1836,
        "end_line": 1843,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_datetimelike_with_inference#1845",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_datetimelike_with_inference(self)",
        "snippet": "    def test_setitem_datetimelike_with_inference(self):\n        # GH 7592\n        # assignment of timedeltas with NaT\n\n        one_hour = timedelta(hours=1)\n        df = DataFrame(index=date_range(\"20130101\", periods=4))\n        df[\"A\"] = np.array([1 * one_hour] * 4, dtype=\"m8[ns]\")\n        df.loc[:, \"B\"] = np.array([2 * one_hour] * 4, dtype=\"m8[ns]\")\n        df.loc[:3, \"C\"] = np.array([3 * one_hour] * 3, dtype=\"m8[ns]\")\n        df.loc[:, \"D\"] = np.array([4 * one_hour] * 4, dtype=\"m8[ns]\")\n        df.loc[df.index[:3], \"E\"] = np.array([5 * one_hour] * 3, dtype=\"m8[ns]\")\n        df[\"F\"] = np.timedelta64(\"NaT\")\n        df.loc[df.index[:-1], \"F\"] = np.array([6 * one_hour] * 3, dtype=\"m8[ns]\")\n        df.loc[df.index[-3] :, \"G\"] = date_range(\"20130101\", periods=3)\n        df[\"H\"] = np.datetime64(\"NaT\")\n        result = df.dtypes\n        expected = Series(\n            [np.dtype(\"timedelta64[ns]\")] * 6 + [np.dtype(\"datetime64[ns]\")] * 2,\n            index=list(\"ABCDEFGH\"),\n        )\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1845,
        "end_line": 1865,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_datetimeindex_tz#1868",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_datetimeindex_tz(self, idxer, tz_naive_fixture)",
        "snippet": "    def test_setitem_datetimeindex_tz(self, idxer, tz_naive_fixture):\n        # GH 11365\n        tz = tz_naive_fixture\n        idx = date_range(start=\"2015-07-12\", periods=3, freq=\"H\", tz=tz)\n        expected = DataFrame(1.2, index=idx, columns=[\"var\"])\n        result = DataFrame(index=idx, columns=[\"var\"])\n        result.loc[:, idxer] = expected\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1868,
        "end_line": 1875,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_at_time_between_time_datetimeindex#1877",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_at_time_between_time_datetimeindex(self)",
        "snippet": "    def test_at_time_between_time_datetimeindex(self):\n        index = date_range(\"2012-01-01\", \"2012-01-05\", freq=\"30min\")\n        df = DataFrame(np.random.randn(len(index), 5), index=index)\n        akey = time(12, 0, 0)\n        bkey = slice(time(13, 0, 0), time(14, 0, 0))\n        ainds = [24, 72, 120, 168]\n        binds = [26, 27, 28, 74, 75, 76, 122, 123, 124, 170, 171, 172]\n\n        result = df.at_time(akey)\n        expected = df.loc[akey]\n        expected2 = df.iloc[ainds]\n        tm.assert_frame_equal(result, expected)\n        tm.assert_frame_equal(result, expected2)\n        assert len(result) == 4\n\n        result = df.between_time(bkey.start, bkey.stop)\n        expected = df.loc[bkey]\n        expected2 = df.iloc[binds]\n        tm.assert_frame_equal(result, expected)\n        tm.assert_frame_equal(result, expected2)\n        assert len(result) == 12\n\n        result = df.copy()\n        result.loc[akey] = 0\n        result = result.loc[akey]\n        expected = df.loc[akey].copy()\n        expected.loc[:] = 0\n        tm.assert_frame_equal(result, expected)\n\n        result = df.copy()\n        result.loc[akey] = 0\n        result.loc[akey] = df.iloc[ainds]\n        tm.assert_frame_equal(result, df)\n\n        result = df.copy()\n        result.loc[bkey] = 0\n        result = result.loc[bkey]\n        expected = df.loc[bkey].copy()\n        expected.loc[:] = 0\n        tm.assert_frame_equal(result, expected)\n\n        result = df.copy()\n        result.loc[bkey] = 0\n        result.loc[bkey] = df.iloc[binds]\n        tm.assert_frame_equal(result, df)",
        "begin_line": 1877,
        "end_line": 1921,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_index_namedtuple#1923",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_index_namedtuple(self)",
        "snippet": "    def test_index_namedtuple(self):\n        from collections import namedtuple\n\n        IndexType = namedtuple(\"IndexType\", [\"a\", \"b\"])\n        idx1 = IndexType(\"foo\", \"bar\")\n        idx2 = IndexType(\"baz\", \"bof\")\n        index = Index([idx1, idx2], name=\"composite_index\", tupleize_cols=False)\n        df = DataFrame([(1, 2), (3, 4)], index=index, columns=[\"A\", \"B\"])\n\n        result = df.loc[IndexType(\"foo\", \"bar\")][\"A\"]\n        assert result == 1",
        "begin_line": 1923,
        "end_line": 1933,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_index_single_double_tuples#1936",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_index_single_double_tuples(self, tpl)",
        "snippet": "    def test_index_single_double_tuples(self, tpl):\n        # GH 20991\n        idx = pd.Index([tuple([1]), tuple([1, 2])], name=\"A\", tupleize_cols=False)\n        df = DataFrame(index=idx)\n\n        result = df.loc[[tpl]]\n        idx = pd.Index([tpl], name=\"A\", tupleize_cols=False)\n        expected = DataFrame(index=idx)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1936,
        "end_line": 1944,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_boolean_indexing#1946",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_boolean_indexing(self)",
        "snippet": "    def test_boolean_indexing(self):\n        idx = list(range(3))\n        cols = [\"A\", \"B\", \"C\"]\n        df1 = DataFrame(\n            index=idx,\n            columns=cols,\n            data=np.array(\n                [[0.0, 0.5, 1.0], [1.5, 2.0, 2.5], [3.0, 3.5, 4.0]], dtype=float\n            ),\n        )\n        df2 = DataFrame(index=idx, columns=cols, data=np.ones((len(idx), len(cols))))\n\n        expected = DataFrame(\n            index=idx,\n            columns=cols,\n            data=np.array([[0.0, 0.5, 1.0], [1.5, 2.0, -1], [-1, -1, -1]], dtype=float),\n        )\n\n        df1[df1 > 2.0 * df2] = -1\n        tm.assert_frame_equal(df1, expected)\n        with pytest.raises(ValueError, match=\"Item wrong length\"):\n            df1[df1.index[:-1] > 2] = -1",
        "begin_line": 1946,
        "end_line": 1967,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_boolean_indexing_mixed#1969",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_boolean_indexing_mixed(self)",
        "snippet": "    def test_boolean_indexing_mixed(self):\n        df = DataFrame(\n            {\n                0: {35: np.nan, 40: np.nan, 43: np.nan, 49: np.nan, 50: np.nan},\n                1: {\n                    35: np.nan,\n                    40: 0.32632316859446198,\n                    43: np.nan,\n                    49: 0.32632316859446198,\n                    50: 0.39114724480578139,\n                },\n                2: {\n                    35: np.nan,\n                    40: np.nan,\n                    43: 0.29012581014105987,\n                    49: np.nan,\n                    50: np.nan,\n                },\n                3: {35: np.nan, 40: np.nan, 43: np.nan, 49: np.nan, 50: np.nan},\n                4: {\n                    35: 0.34215328467153283,\n                    40: np.nan,\n                    43: np.nan,\n                    49: np.nan,\n                    50: np.nan,\n                },\n                \"y\": {35: 0, 40: 0, 43: 0, 49: 0, 50: 1},\n            }\n        )\n\n        # mixed int/float ok\n        df2 = df.copy()\n        df2[df2 > 0.3] = 1\n        expected = df.copy()\n        expected.loc[40, 1] = 1\n        expected.loc[49, 1] = 1\n        expected.loc[50, 1] = 1\n        expected.loc[35, 4] = 1\n        tm.assert_frame_equal(df2, expected)\n\n        df[\"foo\"] = \"test\"\n        msg = \"not supported between instances|unorderable types\"\n\n        with pytest.raises(TypeError, match=msg):\n            df[df > 0.3] = 1",
        "begin_line": 1969,
        "end_line": 2013,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_mask#2015",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_mask(self)",
        "snippet": "    def test_mask(self):\n        df = DataFrame(np.random.randn(5, 3))\n        cond = df > 0\n\n        rs = df.where(cond, np.nan)\n        tm.assert_frame_equal(rs, df.mask(df <= 0))\n        tm.assert_frame_equal(rs, df.mask(~cond))\n\n        other = DataFrame(np.random.randn(5, 3))\n        rs = df.where(cond, other)\n        tm.assert_frame_equal(rs, df.mask(df <= 0, other))\n        tm.assert_frame_equal(rs, df.mask(~cond, other))\n\n        # see gh-21891\n        df = DataFrame([1, 2])\n        res = df.mask([[True], [False]])\n\n        exp = DataFrame([np.nan, 2])\n        tm.assert_frame_equal(res, exp)",
        "begin_line": 2015,
        "end_line": 2033,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_mask_inplace#2035",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_mask_inplace(self)",
        "snippet": "    def test_mask_inplace(self):\n        # GH8801\n        df = DataFrame(np.random.randn(5, 3))\n        cond = df > 0\n\n        rdf = df.copy()\n\n        rdf.where(cond, inplace=True)\n        tm.assert_frame_equal(rdf, df.where(cond))\n        tm.assert_frame_equal(rdf, df.mask(~cond))\n\n        rdf = df.copy()\n        rdf.where(cond, -df, inplace=True)\n        tm.assert_frame_equal(rdf, df.where(cond, -df))\n        tm.assert_frame_equal(rdf, df.mask(~cond, -df))",
        "begin_line": 2035,
        "end_line": 2049,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_mask_edge_case_1xN_frame#2051",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_mask_edge_case_1xN_frame(self)",
        "snippet": "    def test_mask_edge_case_1xN_frame(self):\n        # GH4071\n        df = DataFrame([[1, 2]])\n        res = df.mask(DataFrame([[True, False]]))\n        expec = DataFrame([[np.nan, 2]])\n        tm.assert_frame_equal(res, expec)",
        "begin_line": 2051,
        "end_line": 2056,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_mask_callable#2058",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_mask_callable(self)",
        "snippet": "    def test_mask_callable(self):\n        # GH 12533\n        df = DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        result = df.mask(lambda x: x > 4, lambda x: x + 1)\n        exp = DataFrame([[1, 2, 3], [4, 6, 7], [8, 9, 10]])\n        tm.assert_frame_equal(result, exp)\n        tm.assert_frame_equal(result, df.mask(df > 4, df + 1))\n\n        # return ndarray and scalar\n        result = df.mask(lambda x: (x % 2 == 0).values, lambda x: 99)\n        exp = DataFrame([[1, 99, 3], [99, 5, 99], [7, 99, 9]])\n        tm.assert_frame_equal(result, exp)\n        tm.assert_frame_equal(result, df.mask(df % 2 == 0, 99))\n\n        # chain\n        result = (df + 2).mask(lambda x: x > 8, lambda x: x + 10)\n        exp = DataFrame([[3, 4, 5], [6, 7, 8], [19, 20, 21]])\n        tm.assert_frame_equal(result, exp)\n        tm.assert_frame_equal(result, (df + 2).mask((df + 2) > 8, (df + 2) + 10))",
        "begin_line": 2058,
        "end_line": 2076,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_type_error_multiindex#2078",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_type_error_multiindex(self)",
        "snippet": "    def test_type_error_multiindex(self):\n        # See gh-12218\n        df = DataFrame(\n            columns=[\"i\", \"c\", \"x\", \"y\"],\n            data=[[0, 0, 1, 2], [1, 0, 3, 4], [0, 1, 1, 2], [1, 1, 3, 4]],\n        )\n        dg = df.pivot_table(index=\"i\", columns=\"c\", values=[\"x\", \"y\"])\n\n        with pytest.raises(TypeError, match=\"is an invalid key\"):\n            dg[:, 0]\n\n        index = Index(range(2), name=\"i\")\n        columns = MultiIndex(\n            levels=[[\"x\", \"y\"], [0, 1]], codes=[[0, 1], [0, 0]], names=[None, \"c\"]\n        )\n        expected = DataFrame([[1, 2], [3, 4]], columns=columns, index=index)\n\n        result = dg.loc[:, (slice(None), 0)]\n        tm.assert_frame_equal(result, expected)\n\n        name = (\"x\", 0)\n        index = Index(range(2), name=\"i\")\n        expected = Series([1, 3], index=index, name=name)\n\n        result = dg[\"x\", 0]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 2078,
        "end_line": 2103,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_interval_index#2105",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_interval_index(self)",
        "snippet": "    def test_interval_index(self):\n        # GH 19977\n        index = pd.interval_range(start=0, periods=3)\n        df = pd.DataFrame(\n            [[1, 2, 3], [4, 5, 6], [7, 8, 9]], index=index, columns=[\"A\", \"B\", \"C\"]\n        )\n\n        expected = 1\n        result = df.loc[0.5, \"A\"]\n        tm.assert_almost_equal(result, expected)\n\n        index = pd.interval_range(start=0, periods=3, closed=\"both\")\n        df = pd.DataFrame(\n            [[1, 2, 3], [4, 5, 6], [7, 8, 9]], index=index, columns=[\"A\", \"B\", \"C\"]\n        )\n\n        index_exp = pd.interval_range(start=0, periods=2, freq=1, closed=\"both\")\n        expected = pd.Series([1, 4], index=index_exp, name=\"A\")\n        result = df.loc[1, \"A\"]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 2105,
        "end_line": 2124,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexingUInt64.test_setitem#2128",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexingUInt64",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexingUInt64.test_setitem(self, uint64_frame)",
        "snippet": "    def test_setitem(self, uint64_frame):\n\n        df = uint64_frame\n        idx = df[\"A\"].rename(\"foo\")\n\n        # setitem\n        df[\"C\"] = idx\n        tm.assert_series_equal(df[\"C\"], Series(idx, name=\"C\"))\n\n        df[\"D\"] = \"foo\"\n        df[\"D\"] = idx\n        tm.assert_series_equal(df[\"D\"], Series(idx, name=\"D\"))\n        del df[\"D\"]\n\n        # With NaN: because uint64 has no NaN element,\n        # the column should be cast to object.\n        df2 = df.copy()\n        df2.iloc[1, 1] = pd.NaT\n        df2.iloc[1, 2] = pd.NaT\n        result = df2[\"B\"]\n        tm.assert_series_equal(notna(result), Series([True, False, True], name=\"B\"))\n        tm.assert_series_equal(\n            df2.dtypes,\n            Series(\n                [np.dtype(\"uint64\"), np.dtype(\"O\"), np.dtype(\"O\")],\n                index=[\"A\", \"B\", \"C\"],\n            ),\n        )",
        "begin_line": 2128,
        "end_line": 2155,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexingUInt64.test_set_reset#2157",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexingUInt64",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexingUInt64.test_set_reset(self)",
        "snippet": "    def test_set_reset(self):\n\n        idx = Index([2 ** 63, 2 ** 63 + 5, 2 ** 63 + 10], name=\"foo\")\n\n        # set/reset\n        df = DataFrame({\"A\": [0, 1, 2]}, index=idx)\n        result = df.reset_index()\n        assert result[\"foo\"].dtype == np.dtype(\"uint64\")\n\n        df = result.set_index(\"foo\")\n        tm.assert_index_equal(df.index, idx)",
        "begin_line": 2157,
        "end_line": 2167,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.test_object_casting_indexing_wraps_datetimelike#2170",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.test_object_casting_indexing_wraps_datetimelike()",
        "snippet": "def test_object_casting_indexing_wraps_datetimelike():\n    # GH#31649, check the indexing methods all the way down the stack\n    df = pd.DataFrame(\n        {\n            \"A\": [1, 2],\n            \"B\": pd.date_range(\"2000\", periods=2),\n            \"C\": pd.timedelta_range(\"1 Day\", periods=2),\n        }\n    )\n\n    ser = df.loc[0]\n    assert isinstance(ser.values[1], pd.Timestamp)\n    assert isinstance(ser.values[2], pd.Timedelta)\n\n    ser = df.iloc[0]\n    assert isinstance(ser.values[1], pd.Timestamp)\n    assert isinstance(ser.values[2], pd.Timedelta)\n\n    ser = df.xs(0, axis=0)\n    assert isinstance(ser.values[1], pd.Timestamp)\n    assert isinstance(ser.values[2], pd.Timedelta)\n\n    mgr = df._data\n    arr = mgr.fast_xs(0)\n    assert isinstance(arr[1], pd.Timestamp)\n    assert isinstance(arr[2], pd.Timedelta)\n\n    blk = mgr.blocks[mgr._blknos[1]]\n    assert blk.dtype == \"M8[ns]\"  # we got the right block\n    val = blk.iget((0, 0))\n    assert isinstance(val, pd.Timestamp)\n\n    blk = mgr.blocks[mgr._blknos[2]]\n    assert blk.dtype == \"m8[ns]\"  # we got the right block\n    val = blk.iget((0, 0))\n    assert isinstance(val, pd.Timedelta)",
        "begin_line": 2170,
        "end_line": 2205,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common._check_mixed_float#1",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common",
        "signature": "pandas.tests.frame.common._check_mixed_float(df, dtype=None)",
        "snippet": "def _check_mixed_float(df, dtype=None):\n    # float16 are most likely to be upcasted to float32\n    dtypes = dict(A=\"float32\", B=\"float32\", C=\"float16\", D=\"float64\")\n    if isinstance(dtype, str):\n        dtypes = {k: dtype for k, v in dtypes.items()}\n    elif isinstance(dtype, dict):\n        dtypes.update(dtype)\n    if dtypes.get(\"A\"):\n        assert df.dtypes[\"A\"] == dtypes[\"A\"]\n    if dtypes.get(\"B\"):\n        assert df.dtypes[\"B\"] == dtypes[\"B\"]\n    if dtypes.get(\"C\"):\n        assert df.dtypes[\"C\"] == dtypes[\"C\"]\n    if dtypes.get(\"D\"):\n        assert df.dtypes[\"D\"] == dtypes[\"D\"]",
        "begin_line": 1,
        "end_line": 15,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common._check_mixed_int#18",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common",
        "signature": "pandas.tests.frame.common._check_mixed_int(df, dtype=None)",
        "snippet": "def _check_mixed_int(df, dtype=None):\n    dtypes = dict(A=\"int32\", B=\"uint64\", C=\"uint8\", D=\"int64\")\n    if isinstance(dtype, str):\n        dtypes = {k: dtype for k, v in dtypes.items()}\n    elif isinstance(dtype, dict):\n        dtypes.update(dtype)\n    if dtypes.get(\"A\"):\n        assert df.dtypes[\"A\"] == dtypes[\"A\"]\n    if dtypes.get(\"B\"):\n        assert df.dtypes[\"B\"] == dtypes[\"B\"]\n    if dtypes.get(\"C\"):\n        assert df.dtypes[\"C\"] == dtypes[\"C\"]\n    if dtypes.get(\"D\"):\n        assert df.dtypes[\"D\"] == dtypes[\"D\"]",
        "begin_line": 18,
        "end_line": 31,
        "comment": "",
        "is_bug": false
    }
]