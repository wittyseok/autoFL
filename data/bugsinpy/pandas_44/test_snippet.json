[
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_int#16",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_int(self)",
        "snippet": "    def test_loc_getitem_int(self):\n\n        # int label\n        self.check_result(\"loc\", 2, typs=[\"labels\"], fails=KeyError)",
        "begin_line": 16,
        "end_line": 19,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label#21",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label(self)",
        "snippet": "    def test_loc_getitem_label(self):\n\n        # label\n        self.check_result(\"loc\", \"c\", typs=[\"empty\"], fails=KeyError)",
        "begin_line": 21,
        "end_line": 24,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_out_of_range#26",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_out_of_range(self)",
        "snippet": "    def test_loc_getitem_label_out_of_range(self):\n\n        # out of range label\n        self.check_result(\n            \"loc\", \"f\", typs=[\"ints\", \"uints\", \"labels\", \"mixed\", \"ts\"], fails=KeyError,\n        )\n        self.check_result(\"loc\", \"f\", typs=[\"floats\"], fails=KeyError)\n        self.check_result(\"loc\", \"f\", typs=[\"floats\"], fails=KeyError)\n        self.check_result(\n            \"loc\", 20, typs=[\"ints\", \"uints\", \"mixed\"], fails=KeyError,\n        )\n        self.check_result(\"loc\", 20, typs=[\"labels\"], fails=KeyError)\n        self.check_result(\"loc\", 20, typs=[\"ts\"], axes=0, fails=KeyError)\n        self.check_result(\"loc\", 20, typs=[\"floats\"], axes=0, fails=KeyError)",
        "begin_line": 26,
        "end_line": 39,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_list#41",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_list(self)",
        "snippet": "    def test_loc_getitem_label_list(self):\n        # TODO: test something here?\n        # list of labels\n        pass",
        "begin_line": 41,
        "end_line": 44,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_list_with_missing#46",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_list_with_missing(self)",
        "snippet": "    def test_loc_getitem_label_list_with_missing(self):\n        self.check_result(\n            \"loc\", [0, 1, 2], typs=[\"empty\"], fails=KeyError,\n        )\n        self.check_result(\n            \"loc\", [0, 2, 10], typs=[\"ints\", \"uints\", \"floats\"], axes=0, fails=KeyError,\n        )\n\n        self.check_result(\n            \"loc\", [3, 6, 7], typs=[\"ints\", \"uints\", \"floats\"], axes=1, fails=KeyError,\n        )\n\n        # GH 17758 - MultiIndex and missing keys\n        self.check_result(\n            \"loc\", [(1, 3), (1, 4), (2, 5)], typs=[\"multi\"], axes=0, fails=KeyError,\n        )",
        "begin_line": 46,
        "end_line": 61,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_list_fails#63",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_list_fails(self)",
        "snippet": "    def test_loc_getitem_label_list_fails(self):\n        # fails\n        self.check_result(\n            \"loc\", [20, 30, 40], typs=[\"ints\", \"uints\"], axes=1, fails=KeyError,\n        )",
        "begin_line": 63,
        "end_line": 67,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_array_like#69",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_array_like(self)",
        "snippet": "    def test_loc_getitem_label_array_like(self):\n        # TODO: test something?\n        # array like\n        pass",
        "begin_line": 69,
        "end_line": 72,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_bool#74",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_bool(self)",
        "snippet": "    def test_loc_getitem_bool(self):\n        # boolean indexers\n        b = [True, False, True, False]\n\n        self.check_result(\"loc\", b, typs=[\"empty\"], fails=IndexError)",
        "begin_line": 74,
        "end_line": 78,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_slice#80",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_slice(self)",
        "snippet": "    def test_loc_getitem_label_slice(self):\n\n        # label slices (with ints)\n\n        # real label slices\n\n        # GH 14316\n\n        self.check_result(\n            \"loc\",\n            slice(1, 3),\n            typs=[\"labels\", \"mixed\", \"empty\", \"ts\", \"floats\"],\n            fails=TypeError,\n        )\n\n        self.check_result(\n            \"loc\", slice(\"20130102\", \"20130104\"), typs=[\"ts\"], axes=1, fails=TypeError,\n        )\n\n        self.check_result(\n            \"loc\", slice(2, 8), typs=[\"mixed\"], axes=0, fails=TypeError,\n        )\n        self.check_result(\n            \"loc\", slice(2, 8), typs=[\"mixed\"], axes=1, fails=KeyError,\n        )\n\n        self.check_result(\n            \"loc\", slice(2, 4, 2), typs=[\"mixed\"], axes=0, fails=TypeError,\n        )",
        "begin_line": 80,
        "end_line": 108,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_dups#114",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_dups(self)",
        "snippet": "    def test_loc_getitem_dups(self):\n        # GH 5678\n        # repeated getitems on a dup index returning a ndarray\n        df = DataFrame(\n            np.random.random_sample((20, 5)), index=[\"ABCDE\"[x % 5] for x in range(20)]\n        )\n        expected = df.loc[\"A\", 0]\n        result = df.loc[:, 0].loc[\"A\"]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 114,
        "end_line": 122,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_dups2#124",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_dups2(self)",
        "snippet": "    def test_loc_getitem_dups2(self):\n\n        # GH4726\n        # dup indexing with iloc/loc\n        df = DataFrame(\n            [[1, 2, \"foo\", \"bar\", Timestamp(\"20130101\")]],\n            columns=[\"a\", \"a\", \"a\", \"a\", \"a\"],\n            index=[1],\n        )\n        expected = Series(\n            [1, 2, \"foo\", \"bar\", Timestamp(\"20130101\")],\n            index=[\"a\", \"a\", \"a\", \"a\", \"a\"],\n            name=1,\n        )\n\n        result = df.iloc[0]\n        tm.assert_series_equal(result, expected)\n\n        result = df.loc[1]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 124,
        "end_line": 143,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_dups#145",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_dups(self)",
        "snippet": "    def test_loc_setitem_dups(self):\n\n        # GH 6541\n        df_orig = DataFrame(\n            {\n                \"me\": list(\"rttti\"),\n                \"foo\": list(\"aaade\"),\n                \"bar\": np.arange(5, dtype=\"float64\") * 1.34 + 2,\n                \"bar2\": np.arange(5, dtype=\"float64\") * -0.34 + 2,\n            }\n        ).set_index(\"me\")\n\n        indexer = tuple([\"r\", [\"bar\", \"bar2\"]])\n        df = df_orig.copy()\n        df.loc[indexer] *= 2.0\n        tm.assert_series_equal(df.loc[indexer], 2.0 * df_orig.loc[indexer])\n\n        indexer = tuple([\"r\", \"bar\"])\n        df = df_orig.copy()\n        df.loc[indexer] *= 2.0\n        assert df.loc[indexer] == 2.0 * df_orig.loc[indexer]\n\n        indexer = tuple([\"t\", [\"bar\", \"bar2\"]])\n        df = df_orig.copy()\n        df.loc[indexer] *= 2.0\n        tm.assert_frame_equal(df.loc[indexer], 2.0 * df_orig.loc[indexer])",
        "begin_line": 145,
        "end_line": 170,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_slice#172",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_slice(self)",
        "snippet": "    def test_loc_setitem_slice(self):\n        # GH10503\n\n        # assigning the same type should not change the type\n        df1 = DataFrame({\"a\": [0, 1, 1], \"b\": Series([100, 200, 300], dtype=\"uint32\")})\n        ix = df1[\"a\"] == 1\n        newb1 = df1.loc[ix, \"b\"] + 1\n        df1.loc[ix, \"b\"] = newb1\n        expected = DataFrame(\n            {\"a\": [0, 1, 1], \"b\": Series([100, 201, 301], dtype=\"uint32\")}\n        )\n        tm.assert_frame_equal(df1, expected)\n\n        # assigning a new type should get the inferred type\n        df2 = DataFrame({\"a\": [0, 1, 1], \"b\": [100, 200, 300]}, dtype=\"uint64\")\n        ix = df1[\"a\"] == 1\n        newb2 = df2.loc[ix, \"b\"]\n        df1.loc[ix, \"b\"] = newb2\n        expected = DataFrame({\"a\": [0, 1, 1], \"b\": [100, 200, 300]}, dtype=\"uint64\")\n        tm.assert_frame_equal(df2, expected)",
        "begin_line": 172,
        "end_line": 191,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_dtype#193",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_dtype(self)",
        "snippet": "    def test_loc_setitem_dtype(self):\n        # GH31340\n        df = DataFrame({\"id\": [\"A\"], \"a\": [1.2], \"b\": [0.0], \"c\": [-2.5]})\n        cols = [\"a\", \"b\", \"c\"]\n        df.loc[:, cols] = df.loc[:, cols].astype(\"float32\")\n\n        expected = DataFrame(\n            {\"id\": [\"A\"], \"a\": [1.2], \"b\": [0.0], \"c\": [-2.5]}, dtype=\"float32\"\n        )  # id is inferred as object\n\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 193,
        "end_line": 203,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_getitem_label_list_with_missing#205",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_getitem_label_list_with_missing(self)",
        "snippet": "    def test_getitem_label_list_with_missing(self):\n        s = Series(range(3), index=[\"a\", \"b\", \"c\"])\n\n        # consistency\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            s[[\"a\", \"d\"]]\n\n        s = Series(range(3))\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            s[[0, 3]]",
        "begin_line": 205,
        "end_line": 214,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_bool_diff_len#217",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_bool_diff_len(self, index)",
        "snippet": "    def test_loc_getitem_bool_diff_len(self, index):\n        # GH26658\n        s = Series([1, 2, 3])\n        msg = f\"Boolean index has wrong length: {len(index)} instead of {len(s)}\"\n        with pytest.raises(IndexError, match=msg):\n            _ = s.loc[index]",
        "begin_line": 217,
        "end_line": 222,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_int_slice#224",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_int_slice(self)",
        "snippet": "    def test_loc_getitem_int_slice(self):\n        # TODO: test something here?\n        pass",
        "begin_line": 224,
        "end_line": 226,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_to_fail#228",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_to_fail(self)",
        "snippet": "    def test_loc_to_fail(self):\n\n        # GH3449\n        df = DataFrame(\n            np.random.random((3, 3)), index=[\"a\", \"b\", \"c\"], columns=[\"e\", \"f\", \"g\"]\n        )\n\n        # raise a KeyError?\n        msg = (\n            r\"\\\"None of \\[Int64Index\\(\\[1, 2\\], dtype='int64'\\)\\] are \"\n            r\"in the \\[index\\]\\\"\"\n        )\n        with pytest.raises(KeyError, match=msg):\n            df.loc[[1, 2], [1, 2]]\n\n        # GH  7496\n        # loc should not fallback\n\n        s = Series(dtype=object)\n        s.loc[1] = 1\n        s.loc[\"a\"] = 2\n\n        with pytest.raises(KeyError, match=r\"^-1$\"):\n            s.loc[-1]\n\n        msg = (\n            r\"\\\"None of \\[Int64Index\\(\\[-1, -2\\], dtype='int64'\\)\\] are \"\n            r\"in the \\[index\\]\\\"\"\n        )\n        with pytest.raises(KeyError, match=msg):\n            s.loc[[-1, -2]]\n\n        msg = r\"\\\"None of \\[Index\\(\\['4'\\], dtype='object'\\)\\] are in the \\[index\\]\\\"\"\n        with pytest.raises(KeyError, match=msg):\n            s.loc[[\"4\"]]\n\n        s.loc[-1] = 3\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            s.loc[[-1, -2]]\n\n        s[\"a\"] = 2\n        msg = (\n            r\"\\\"None of \\[Int64Index\\(\\[-2\\], dtype='int64'\\)\\] are \"\n            r\"in the \\[index\\]\\\"\"\n        )\n        with pytest.raises(KeyError, match=msg):\n            s.loc[[-2]]\n\n        del s[\"a\"]\n\n        with pytest.raises(KeyError, match=msg):\n            s.loc[[-2]] = 0\n\n        # inconsistency between .loc[values] and .loc[values,:]\n        # GH 7999\n        df = DataFrame([[\"a\"], [\"b\"]], index=[1, 2], columns=[\"value\"])\n\n        msg = (\n            r\"\\\"None of \\[Int64Index\\(\\[3\\], dtype='int64'\\)\\] are \"\n            r\"in the \\[index\\]\\\"\"\n        )\n        with pytest.raises(KeyError, match=msg):\n            df.loc[[3], :]\n\n        with pytest.raises(KeyError, match=msg):\n            df.loc[[3]]",
        "begin_line": 228,
        "end_line": 293,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_list_with_fail#295",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_list_with_fail(self)",
        "snippet": "    def test_loc_getitem_list_with_fail(self):\n        # 15747\n        # should KeyError if *any* missing labels\n\n        s = Series([1, 2, 3])\n\n        s.loc[[2]]\n\n        with pytest.raises(\n            KeyError,\n            match=re.escape(\n                \"\\\"None of [Int64Index([3], dtype='int64')] are in the [index]\\\"\"\n            ),\n        ):\n            s.loc[[3]]\n\n        # a non-match and a match\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            s.loc[[2, 3]]",
        "begin_line": 295,
        "end_line": 313,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_index#315",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_index(self)",
        "snippet": "    def test_loc_index(self):\n        # gh-17131\n        # a boolean index should index like a boolean numpy array\n\n        df = DataFrame(\n            np.random.random(size=(5, 10)),\n            index=[\"alpha_0\", \"alpha_1\", \"alpha_2\", \"beta_0\", \"beta_1\"],\n        )\n\n        mask = df.index.map(lambda x: \"alpha\" in x)\n        expected = df.loc[np.array(mask)]\n\n        result = df.loc[mask]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[mask.values]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[pd.array(mask, dtype=\"boolean\")]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 315,
        "end_line": 334,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_general#336",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_general(self)",
        "snippet": "    def test_loc_general(self):\n\n        df = DataFrame(\n            np.random.rand(4, 4),\n            columns=[\"A\", \"B\", \"C\", \"D\"],\n            index=[\"A\", \"B\", \"C\", \"D\"],\n        )\n\n        # want this to work\n        result = df.loc[:, \"A\":\"B\"].iloc[0:2, :]\n        assert (result.columns == [\"A\", \"B\"]).all()\n        assert (result.index == [\"A\", \"B\"]).all()\n\n        # mixed type\n        result = DataFrame({\"a\": [Timestamp(\"20130101\")], \"b\": [1]}).iloc[0]\n        expected = Series([Timestamp(\"20130101\"), 1], index=[\"a\", \"b\"], name=0)\n        tm.assert_series_equal(result, expected)\n        assert result.dtype == object",
        "begin_line": 336,
        "end_line": 353,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_consistency#355",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_consistency(self)",
        "snippet": "    def test_loc_setitem_consistency(self):\n        # GH 6149\n        # coerce similarly for setitem and loc when rows have a null-slice\n        expected = DataFrame(\n            {\n                \"date\": Series(0, index=range(5), dtype=np.int64),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n\n        df = DataFrame(\n            {\n                \"date\": date_range(\"2000-01-01\", \"2000-01-5\"),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        df.loc[:, \"date\"] = 0\n        tm.assert_frame_equal(df, expected)\n\n        df = DataFrame(\n            {\n                \"date\": date_range(\"2000-01-01\", \"2000-01-5\"),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        df.loc[:, \"date\"] = np.array(0, dtype=np.int64)\n        tm.assert_frame_equal(df, expected)\n\n        df = DataFrame(\n            {\n                \"date\": date_range(\"2000-01-01\", \"2000-01-5\"),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        df.loc[:, \"date\"] = np.array([0, 0, 0, 0, 0], dtype=np.int64)\n        tm.assert_frame_equal(df, expected)\n\n        expected = DataFrame(\n            {\n                \"date\": Series(\"foo\", index=range(5)),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        df = DataFrame(\n            {\n                \"date\": date_range(\"2000-01-01\", \"2000-01-5\"),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        df.loc[:, \"date\"] = \"foo\"\n        tm.assert_frame_equal(df, expected)\n\n        expected = DataFrame(\n            {\n                \"date\": Series(1.0, index=range(5)),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        df = DataFrame(\n            {\n                \"date\": date_range(\"2000-01-01\", \"2000-01-5\"),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        df.loc[:, \"date\"] = 1.0\n        tm.assert_frame_equal(df, expected)\n\n        # GH 15494\n        # setting on frame with single row\n        df = DataFrame({\"date\": Series([Timestamp(\"20180101\")])})\n        df.loc[:, \"date\"] = \"string\"\n        expected = DataFrame({\"date\": Series([\"string\"])})\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 355,
        "end_line": 427,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_consistency_empty#429",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_consistency_empty(self)",
        "snippet": "    def test_loc_setitem_consistency_empty(self):\n        # empty (essentially noops)\n        expected = DataFrame(columns=[\"x\", \"y\"])\n        expected[\"x\"] = expected[\"x\"].astype(np.int64)\n        df = DataFrame(columns=[\"x\", \"y\"])\n        df.loc[:, \"x\"] = 1\n        tm.assert_frame_equal(df, expected)\n\n        df = DataFrame(columns=[\"x\", \"y\"])\n        df[\"x\"] = 1\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 429,
        "end_line": 439,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_consistency_slice_column_len#441",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_consistency_slice_column_len(self)",
        "snippet": "    def test_loc_setitem_consistency_slice_column_len(self):\n        # .loc[:,column] setting with slice == len of the column\n        # GH10408\n        data = \"\"\"Level_0,,,Respondent,Respondent,Respondent,OtherCat,OtherCat\nLevel_1,,,Something,StartDate,EndDate,Yes/No,SomethingElse\nRegion,Site,RespondentID,,,,,\nRegion_1,Site_1,3987227376,A,5/25/2015 10:59,5/25/2015 11:22,Yes,\nRegion_1,Site_1,3980680971,A,5/21/2015 9:40,5/21/2015 9:52,Yes,Yes\nRegion_1,Site_2,3977723249,A,5/20/2015 8:27,5/20/2015 8:41,Yes,\nRegion_1,Site_2,3977723089,A,5/20/2015 8:33,5/20/2015 9:09,Yes,No\"\"\"\n\n        df = pd.read_csv(StringIO(data), header=[0, 1], index_col=[0, 1, 2])\n        df.loc[:, (\"Respondent\", \"StartDate\")] = pd.to_datetime(\n            df.loc[:, (\"Respondent\", \"StartDate\")]\n        )\n        df.loc[:, (\"Respondent\", \"EndDate\")] = pd.to_datetime(\n            df.loc[:, (\"Respondent\", \"EndDate\")]\n        )\n        df.loc[:, (\"Respondent\", \"Duration\")] = (\n            df.loc[:, (\"Respondent\", \"EndDate\")]\n            - df.loc[:, (\"Respondent\", \"StartDate\")]\n        )\n\n        df.loc[:, (\"Respondent\", \"Duration\")] = df.loc[\n            :, (\"Respondent\", \"Duration\")\n        ].astype(\"timedelta64[s]\")\n        expected = Series(\n            [1380, 720, 840, 2160.0], index=df.index, name=(\"Respondent\", \"Duration\")\n        )\n        tm.assert_series_equal(df[(\"Respondent\", \"Duration\")], expected)",
        "begin_line": 441,
        "end_line": 470,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_assign_non_ns_datetime#473",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_assign_non_ns_datetime(self, unit)",
        "snippet": "    def test_loc_assign_non_ns_datetime(self, unit):\n        # GH 27395, non-ns dtype assignment via .loc should work\n        # and return the same result when using simple assignment\n        df = DataFrame(\n            {\n                \"timestamp\": [\n                    np.datetime64(\"2017-02-11 12:41:29\"),\n                    np.datetime64(\"1991-11-07 04:22:37\"),\n                ]\n            }\n        )\n\n        df.loc[:, unit] = df.loc[:, \"timestamp\"].values.astype(f\"datetime64[{unit}]\")\n        df[\"expected\"] = df.loc[:, \"timestamp\"].values.astype(f\"datetime64[{unit}]\")\n        expected = Series(df.loc[:, \"expected\"], name=unit)\n        tm.assert_series_equal(df.loc[:, unit], expected)",
        "begin_line": 473,
        "end_line": 488,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_modify_datetime#490",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_modify_datetime(self)",
        "snippet": "    def test_loc_modify_datetime(self):\n        # see gh-28837\n        df = DataFrame.from_dict(\n            {\"date\": [1485264372711, 1485265925110, 1540215845888, 1540282121025]}\n        )\n\n        df[\"date_dt\"] = pd.to_datetime(df[\"date\"], unit=\"ms\", cache=True)\n\n        df.loc[:, \"date_dt_cp\"] = df.loc[:, \"date_dt\"]\n        df.loc[[2, 3], \"date_dt_cp\"] = df.loc[[2, 3], \"date_dt\"]\n\n        expected = DataFrame(\n            [\n                [1485264372711, \"2017-01-24 13:26:12.711\", \"2017-01-24 13:26:12.711\"],\n                [1485265925110, \"2017-01-24 13:52:05.110\", \"2017-01-24 13:52:05.110\"],\n                [1540215845888, \"2018-10-22 13:44:05.888\", \"2018-10-22 13:44:05.888\"],\n                [1540282121025, \"2018-10-23 08:08:41.025\", \"2018-10-23 08:08:41.025\"],\n            ],\n            columns=[\"date\", \"date_dt\", \"date_dt_cp\"],\n        )\n\n        columns = [\"date_dt\", \"date_dt_cp\"]\n        expected[columns] = expected[columns].apply(pd.to_datetime)\n\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 490,
        "end_line": 514,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_frame#516",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_frame(self)",
        "snippet": "    def test_loc_setitem_frame(self):\n        df = DataFrame(np.random.randn(4, 4), index=list(\"abcd\"), columns=list(\"ABCD\"))\n\n        result = df.iloc[0, 0]\n\n        df.loc[\"a\", \"A\"] = 1\n        result = df.loc[\"a\", \"A\"]\n        assert result == 1\n\n        result = df.iloc[0, 0]\n        assert result == 1\n\n        df.loc[:, \"B\":\"D\"] = 0\n        expected = df.loc[:, \"B\":\"D\"]\n        result = df.iloc[:, 1:]\n        tm.assert_frame_equal(result, expected)\n\n        # GH 6254\n        # setting issue\n        df = DataFrame(index=[3, 5, 4], columns=[\"A\"])\n        df.loc[[4, 3, 5], \"A\"] = np.array([1, 2, 3], dtype=\"int64\")\n        expected = DataFrame(dict(A=Series([1, 2, 3], index=[4, 3, 5]))).reindex(\n            index=[3, 5, 4]\n        )\n        tm.assert_frame_equal(df, expected)\n\n        # GH 6252\n        # setting with an empty frame\n        keys1 = [\"@\" + str(i) for i in range(5)]\n        val1 = np.arange(5, dtype=\"int64\")\n\n        keys2 = [\"@\" + str(i) for i in range(4)]\n        val2 = np.arange(4, dtype=\"int64\")\n\n        index = list(set(keys1).union(keys2))\n        df = DataFrame(index=index)\n        df[\"A\"] = np.nan\n        df.loc[keys1, \"A\"] = val1\n\n        df[\"B\"] = np.nan\n        df.loc[keys2, \"B\"] = val2\n\n        expected = DataFrame(\n            dict(A=Series(val1, index=keys1), B=Series(val2, index=keys2))\n        ).reindex(index=index)\n        tm.assert_frame_equal(df, expected)\n\n        # GH 8669\n        # invalid coercion of nan -> int\n        df = DataFrame({\"A\": [1, 2, 3], \"B\": np.nan})\n        df.loc[df.B > df.A, \"B\"] = df.A\n        expected = DataFrame({\"A\": [1, 2, 3], \"B\": np.nan})\n        tm.assert_frame_equal(df, expected)\n\n        # GH 6546\n        # setting with mixed labels\n        df = DataFrame({1: [1, 2], 2: [3, 4], \"a\": [\"a\", \"b\"]})\n\n        result = df.loc[0, [1, 2]]\n        expected = Series([1, 3], index=[1, 2], dtype=object, name=0)\n        tm.assert_series_equal(result, expected)\n\n        expected = DataFrame({1: [5, 2], 2: [6, 4], \"a\": [\"a\", \"b\"]})\n        df.loc[0, [1, 2]] = [5, 6]\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 516,
        "end_line": 580,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_frame_multiples#582",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_frame_multiples(self)",
        "snippet": "    def test_loc_setitem_frame_multiples(self):\n        # multiple setting\n        df = DataFrame(\n            {\"A\": [\"foo\", \"bar\", \"baz\"], \"B\": Series(range(3), dtype=np.int64)}\n        )\n        rhs = df.loc[1:2]\n        rhs.index = df.index[0:2]\n        df.loc[0:1] = rhs\n        expected = DataFrame(\n            {\"A\": [\"bar\", \"baz\", \"baz\"], \"B\": Series([1, 2, 2], dtype=np.int64)}\n        )\n        tm.assert_frame_equal(df, expected)\n\n        # multiple setting with frame on rhs (with M8)\n        df = DataFrame(\n            {\n                \"date\": date_range(\"2000-01-01\", \"2000-01-5\"),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        expected = DataFrame(\n            {\n                \"date\": [\n                    Timestamp(\"20000101\"),\n                    Timestamp(\"20000102\"),\n                    Timestamp(\"20000101\"),\n                    Timestamp(\"20000102\"),\n                    Timestamp(\"20000103\"),\n                ],\n                \"val\": Series([0, 1, 0, 1, 2], dtype=np.int64),\n            }\n        )\n        rhs = df.loc[0:2]\n        rhs.index = df.index[2:5]\n        df.loc[2:4] = rhs\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 582,
        "end_line": 617,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_with_scalar_index#623",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_with_scalar_index(self, indexer, value)",
        "snippet": "    def test_loc_setitem_with_scalar_index(self, indexer, value):\n        # GH #19474\n        # assigning like \"df.loc[0, ['A']] = ['Z']\" should be evaluated\n        # elementwisely, not using \"setter('A', ['Z'])\".\n\n        df = pd.DataFrame([[1, 2], [3, 4]], columns=[\"A\", \"B\"])\n        df.loc[0, indexer] = value\n        result = df.loc[0, \"A\"]\n\n        assert is_scalar(result) and result == \"Z\"",
        "begin_line": 623,
        "end_line": 632,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_missing_columns#686",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_missing_columns(self, index, box, expected)",
        "snippet": "    def test_loc_setitem_missing_columns(self, index, box, expected):\n        # GH 29334\n        df = pd.DataFrame([[1, 2], [3, 4], [5, 6]], columns=[\"A\", \"B\"])\n        df.loc[index] = box\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 686,
        "end_line": 690,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_coercion#692",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_coercion(self)",
        "snippet": "    def test_loc_coercion(self):\n\n        # 12411\n        df = DataFrame({\"date\": [Timestamp(\"20130101\").tz_localize(\"UTC\"), pd.NaT]})\n        expected = df.dtypes\n\n        result = df.iloc[[0]]\n        tm.assert_series_equal(result.dtypes, expected)\n\n        result = df.iloc[[1]]\n        tm.assert_series_equal(result.dtypes, expected)\n\n        # 12045\n        import datetime\n\n        df = DataFrame(\n            {\"date\": [datetime.datetime(2012, 1, 1), datetime.datetime(1012, 1, 2)]}\n        )\n        expected = df.dtypes\n\n        result = df.iloc[[0]]\n        tm.assert_series_equal(result.dtypes, expected)\n\n        result = df.iloc[[1]]\n        tm.assert_series_equal(result.dtypes, expected)\n\n        # 11594\n        df = DataFrame({\"text\": [\"some words\"] + [None] * 9})\n        expected = df.dtypes\n\n        result = df.iloc[0:2]\n        tm.assert_series_equal(result.dtypes, expected)\n\n        result = df.iloc[3:]\n        tm.assert_series_equal(result.dtypes, expected)",
        "begin_line": 692,
        "end_line": 726,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_setitem_new_key_tz#728",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_setitem_new_key_tz(self)",
        "snippet": "    def test_setitem_new_key_tz(self):\n        # GH#12862 should not raise on assigning the second value\n        vals = [\n            pd.to_datetime(42).tz_localize(\"UTC\"),\n            pd.to_datetime(666).tz_localize(\"UTC\"),\n        ]\n        expected = pd.Series(vals, index=[\"foo\", \"bar\"])\n\n        ser = pd.Series(dtype=object)\n        ser[\"foo\"] = vals[0]\n        ser[\"bar\"] = vals[1]\n\n        tm.assert_series_equal(ser, expected)\n\n        ser = pd.Series(dtype=object)\n        ser.loc[\"foo\"] = vals[0]\n        ser.loc[\"bar\"] = vals[1]\n\n        tm.assert_series_equal(ser, expected)",
        "begin_line": 728,
        "end_line": 746,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_non_unique#748",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_non_unique(self)",
        "snippet": "    def test_loc_non_unique(self):\n        # GH3659\n        # non-unique indexer with loc slice\n        # https://groups.google.com/forum/?fromgroups#!topic/pydata/zTm2No0crYs\n\n        # these are going to raise because the we are non monotonic\n        df = DataFrame(\n            {\"A\": [1, 2, 3, 4, 5, 6], \"B\": [3, 4, 5, 6, 7, 8]}, index=[0, 1, 0, 1, 2, 3]\n        )\n        msg = \"'Cannot get left slice bound for non-unique label: 1'\"\n        with pytest.raises(KeyError, match=msg):\n            df.loc[1:]\n        msg = \"'Cannot get left slice bound for non-unique label: 0'\"\n        with pytest.raises(KeyError, match=msg):\n            df.loc[0:]\n        msg = \"'Cannot get left slice bound for non-unique label: 1'\"\n        with pytest.raises(KeyError, match=msg):\n            df.loc[1:2]\n\n        # monotonic are ok\n        df = DataFrame(\n            {\"A\": [1, 2, 3, 4, 5, 6], \"B\": [3, 4, 5, 6, 7, 8]}, index=[0, 1, 0, 1, 2, 3]\n        ).sort_index(axis=0)\n        result = df.loc[1:]\n        expected = DataFrame({\"A\": [2, 4, 5, 6], \"B\": [4, 6, 7, 8]}, index=[1, 1, 2, 3])\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[0:]\n        tm.assert_frame_equal(result, df)\n\n        result = df.loc[1:2]\n        expected = DataFrame({\"A\": [2, 4, 5], \"B\": [4, 6, 7]}, index=[1, 1, 2])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 748,
        "end_line": 780,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_non_unique_memory_error#782",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_non_unique_memory_error(self)",
        "snippet": "    def test_loc_non_unique_memory_error(self):\n\n        # GH 4280\n        # non_unique index with a large selection triggers a memory error\n\n        columns = list(\"ABCDEFG\")\n\n        def gen_test(l, l2):\n            return pd.concat(\n                [\n                    DataFrame(\n                        np.random.randn(l, len(columns)),\n                        index=np.arange(l),\n                        columns=columns,\n                    ),\n                    DataFrame(\n                        np.ones((l2, len(columns))), index=[0] * l2, columns=columns\n                    ),\n                ]\n            )\n\n        def gen_expected(df, mask):\n            len_mask = len(mask)\n            return pd.concat(\n                [\n                    df.take([0]),\n                    DataFrame(\n                        np.ones((len_mask, len(columns))),\n                        index=[0] * len_mask,\n                        columns=columns,\n                    ),\n                    df.take(mask[1:]),\n                ]\n            )\n\n        df = gen_test(900, 100)\n        assert df.index.is_unique is False\n\n        mask = np.arange(100)\n        result = df.loc[mask]\n        expected = gen_expected(df, mask)\n        tm.assert_frame_equal(result, expected)\n\n        df = gen_test(900000, 100000)\n        assert df.index.is_unique is False\n\n        mask = np.arange(100000)\n        result = df.loc[mask]\n        expected = gen_expected(df, mask)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 782,
        "end_line": 831,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.gen_test#789",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.gen_test(l, l2)",
        "snippet": "        def gen_test(l, l2):\n            return pd.concat(\n                [\n                    DataFrame(\n                        np.random.randn(l, len(columns)),\n                        index=np.arange(l),\n                        columns=columns,\n                    ),\n                    DataFrame(\n                        np.ones((l2, len(columns))), index=[0] * l2, columns=columns\n                    ),\n                ]\n            )",
        "begin_line": 789,
        "end_line": 801,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.gen_expected#803",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.gen_expected(df, mask)",
        "snippet": "        def gen_expected(df, mask):\n            len_mask = len(mask)\n            return pd.concat(\n                [\n                    df.take([0]),\n                    DataFrame(\n                        np.ones((len_mask, len(columns))),\n                        index=[0] * len_mask,\n                        columns=columns,\n                    ),\n                    df.take(mask[1:]),\n                ]\n            )",
        "begin_line": 803,
        "end_line": 815,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_name#833",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_name(self)",
        "snippet": "    def test_loc_name(self):\n        # GH 3880\n        df = DataFrame([[1, 1], [1, 1]])\n        df.index.name = \"index_name\"\n        result = df.iloc[[0, 1]].index.name\n        assert result == \"index_name\"\n\n        result = df.loc[[0, 1]].index.name\n        assert result == \"index_name\"",
        "begin_line": 833,
        "end_line": 841,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_empty_list_indexer_is_ok#843",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_empty_list_indexer_is_ok(self)",
        "snippet": "    def test_loc_empty_list_indexer_is_ok(self):\n\n        df = tm.makeCustomDataframe(5, 2)\n        # vertical empty\n        tm.assert_frame_equal(\n            df.loc[:, []], df.iloc[:, :0], check_index_type=True, check_column_type=True\n        )\n        # horizontal empty\n        tm.assert_frame_equal(\n            df.loc[[], :], df.iloc[:0, :], check_index_type=True, check_column_type=True\n        )\n        # horizontal empty\n        tm.assert_frame_equal(\n            df.loc[[]], df.iloc[:0, :], check_index_type=True, check_column_type=True\n        )",
        "begin_line": 843,
        "end_line": 857,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_identity_slice_returns_new_object#859",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_identity_slice_returns_new_object(self)",
        "snippet": "    def test_identity_slice_returns_new_object(self):\n        # GH13873\n        original_df = DataFrame({\"a\": [1, 2, 3]})\n        sliced_df = original_df.loc[:]\n        assert sliced_df is not original_df\n        assert original_df[:] is not original_df\n\n        # should be a shallow copy\n        original_df[\"a\"] = [4, 4, 4]\n        assert (sliced_df[\"a\"] == 4).all()\n\n        # These should not return copies\n        assert original_df is original_df.loc[:, :]\n        df = DataFrame(np.random.randn(10, 4))\n        assert df[0] is df.loc[:, 0]\n\n        # Same tests for Series\n        original_series = Series([1, 2, 3, 4, 5, 6])\n        sliced_series = original_series.loc[:]\n        assert sliced_series is not original_series\n        assert original_series[:] is not original_series\n\n        original_series[:3] = [7, 8, 9]\n        assert all(sliced_series[:3] == [7, 8, 9])",
        "begin_line": 859,
        "end_line": 882,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_uint64#884",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_uint64(self)",
        "snippet": "    def test_loc_uint64(self):\n        # GH20722\n        # Test whether loc accept uint64 max value as index.\n        s = pd.Series(\n            [1, 2], index=[np.iinfo(\"uint64\").max - 1, np.iinfo(\"uint64\").max]\n        )\n\n        result = s.loc[np.iinfo(\"uint64\").max - 1]\n        expected = s.iloc[0]\n        assert result == expected\n\n        result = s.loc[[np.iinfo(\"uint64\").max - 1]]\n        expected = s.iloc[[0]]\n        tm.assert_series_equal(result, expected)\n\n        result = s.loc[[np.iinfo(\"uint64\").max - 1, np.iinfo(\"uint64\").max]]\n        tm.assert_series_equal(result, s)",
        "begin_line": 884,
        "end_line": 900,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_empty_append#902",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_empty_append(self)",
        "snippet": "    def test_loc_setitem_empty_append(self):\n        # GH6173, various appends to an empty dataframe\n\n        data = [1, 2, 3]\n        expected = DataFrame({\"x\": data, \"y\": [None] * len(data)})\n\n        # appends to fit length of data\n        df = DataFrame(columns=[\"x\", \"y\"])\n        df.loc[:, \"x\"] = data\n        tm.assert_frame_equal(df, expected)\n\n        # only appends one value\n        expected = DataFrame({\"x\": [1.0], \"y\": [np.nan]})\n        df = DataFrame(columns=[\"x\", \"y\"], dtype=np.float)\n        df.loc[0, \"x\"] = expected.loc[0, \"x\"]\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 902,
        "end_line": 917,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_empty_append_raises#919",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_empty_append_raises(self)",
        "snippet": "    def test_loc_setitem_empty_append_raises(self):\n        # GH6173, various appends to an empty dataframe\n\n        data = [1, 2]\n        df = DataFrame(columns=[\"x\", \"y\"])\n        df.index = df.index.astype(np.int64)\n        msg = (\n            r\"None of \\[Int64Index\\(\\[0, 1\\], dtype='int64'\\)\\] \"\n            r\"are in the \\[index\\]\"\n        )\n        with pytest.raises(KeyError, match=msg):\n            df.loc[[0, 1], \"x\"] = data\n\n        msg = \"cannot copy sequence with size 2 to array axis with dimension 0\"\n        with pytest.raises(ValueError, match=msg):\n            df.loc[0:2, \"x\"] = data",
        "begin_line": 919,
        "end_line": 934,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_indexing_zerodim_np_array#936",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_indexing_zerodim_np_array(self)",
        "snippet": "    def test_indexing_zerodim_np_array(self):\n        # GH24924\n        df = DataFrame([[1, 2], [3, 4]])\n        result = df.loc[np.array(0)]\n        s = pd.Series([1, 2], name=0)\n        tm.assert_series_equal(result, s)",
        "begin_line": 936,
        "end_line": 941,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_series_indexing_zerodim_np_array#943",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_series_indexing_zerodim_np_array(self)",
        "snippet": "    def test_series_indexing_zerodim_np_array(self):\n        # GH24924\n        s = Series([1, 2])\n        result = s.loc[np.array(0)]\n        assert result == 1",
        "begin_line": 943,
        "end_line": 947,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_reverse_assignment#949",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_reverse_assignment(self)",
        "snippet": "    def test_loc_reverse_assignment(self):\n        # GH26939\n        data = [1, 2, 3, 4, 5, 6] + [None] * 4\n        expected = Series(data, index=range(2010, 2020))\n\n        result = pd.Series(index=range(2010, 2020), dtype=np.float64)\n        result.loc[2015:2010:-1] = [6, 5, 4, 3, 2, 1]\n\n        tm.assert_series_equal(result, expected)",
        "begin_line": 949,
        "end_line": 957,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.test_series_loc_getitem_label_list_missing_values#960",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc",
        "signature": "pandas.tests.indexing.test_loc.test_series_loc_getitem_label_list_missing_values()",
        "snippet": "def test_series_loc_getitem_label_list_missing_values():\n    # gh-11428\n    key = np.array(\n        [\"2001-01-04\", \"2001-01-02\", \"2001-01-04\", \"2001-01-14\"], dtype=\"datetime64\"\n    )\n    s = Series([2, 5, 8, 11], date_range(\"2001-01-01\", freq=\"D\", periods=4))\n    with pytest.raises(KeyError, match=\"with any missing labels\"):\n        s.loc[key]",
        "begin_line": 960,
        "end_line": 967,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.test_loc_getitem_label_list_integer_labels#978",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc",
        "signature": "pandas.tests.indexing.test_loc.test_loc_getitem_label_list_integer_labels(columns, column_key, expected_columns, check_column_type)",
        "snippet": "def test_loc_getitem_label_list_integer_labels(\n    columns, column_key, expected_columns, check_column_type\n):\n    # gh-14836\n    df = DataFrame(np.random.rand(3, 3), columns=columns, index=list(\"ABC\"))\n    expected = df.iloc[:, expected_columns]\n    result = df.loc[[\"A\", \"B\", \"C\"], column_key]\n    tm.assert_frame_equal(result, expected, check_column_type=check_column_type)",
        "begin_line": 978,
        "end_line": 985,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.test_loc_setitem_float_intindex#988",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc",
        "signature": "pandas.tests.indexing.test_loc.test_loc_setitem_float_intindex()",
        "snippet": "def test_loc_setitem_float_intindex():\n    # GH 8720\n    rand_data = np.random.randn(8, 4)\n    result = pd.DataFrame(rand_data)\n    result.loc[:, 0.5] = np.nan\n    expected_data = np.hstack((rand_data, np.array([np.nan] * 8).reshape(8, 1)))\n    expected = pd.DataFrame(expected_data, columns=[0.0, 1.0, 2.0, 3.0, 0.5])\n    tm.assert_frame_equal(result, expected)\n\n    result = pd.DataFrame(rand_data)\n    result.loc[:, 0.5] = np.nan\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 988,
        "end_line": 999,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.test_loc_axis_1_slice#1002",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc",
        "signature": "pandas.tests.indexing.test_loc.test_loc_axis_1_slice()",
        "snippet": "def test_loc_axis_1_slice():\n    # GH 10586\n    cols = [(yr, m) for yr in [2014, 2015] for m in [7, 8, 9, 10]]\n    df = pd.DataFrame(\n        np.ones((10, 8)),\n        index=tuple(\"ABCDEFGHIJ\"),\n        columns=pd.MultiIndex.from_tuples(cols),\n    )\n    result = df.loc(axis=1)[(2014, 9):(2015, 8)]\n    expected = pd.DataFrame(\n        np.ones((10, 4)),\n        index=tuple(\"ABCDEFGHIJ\"),\n        columns=pd.MultiIndex.from_tuples(\n            [(2014, 9), (2014, 10), (2015, 7), (2015, 8)]\n        ),\n    )\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 1002,
        "end_line": 1018,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.test_loc_set_dataframe_multiindex#1021",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc",
        "signature": "pandas.tests.indexing.test_loc.test_loc_set_dataframe_multiindex()",
        "snippet": "def test_loc_set_dataframe_multiindex():\n    # GH 14592\n    expected = pd.DataFrame(\n        \"a\", index=range(2), columns=pd.MultiIndex.from_product([range(2), range(2)])\n    )\n    result = expected.copy()\n    result.loc[0, [(0, 1)]] = result.loc[0, [(0, 1)]]\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 1021,
        "end_line": 1028,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.test_loc_mixed_int_float#1031",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc",
        "signature": "pandas.tests.indexing.test_loc.test_loc_mixed_int_float()",
        "snippet": "def test_loc_mixed_int_float():\n    # GH#19456\n    ser = pd.Series(range(2), pd.Index([1, 2.0], dtype=object))\n\n    result = ser.loc[1]\n    assert result == 0",
        "begin_line": 1031,
        "end_line": 1036,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.test_loc_with_positional_slice_deprecation#1039",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc",
        "signature": "pandas.tests.indexing.test_loc.test_loc_with_positional_slice_deprecation()",
        "snippet": "def test_loc_with_positional_slice_deprecation():\n    # GH#31840\n    ser = pd.Series(range(4), index=[\"A\", \"B\", \"C\", \"D\"])\n\n    with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n        ser.loc[:3] = 2\n\n    expected = pd.Series([2, 2, 2, 3], index=[\"A\", \"B\", \"C\", \"D\"])\n    tm.assert_series_equal(ser, expected)",
        "begin_line": 1039,
        "end_line": 1047,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.test_loc_slice_disallows_positional#1050",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc",
        "signature": "pandas.tests.indexing.test_loc.test_loc_slice_disallows_positional()",
        "snippet": "def test_loc_slice_disallows_positional():\n    # GH#16121, GH#24612, GH#31810\n    dti = pd.date_range(\"2016-01-01\", periods=3)\n    df = pd.DataFrame(np.random.random((3, 2)), index=dti)\n\n    ser = df[0]\n\n    msg = (\n        \"cannot do slice indexing on DatetimeIndex with these \"\n        r\"indexers \\[1\\] of type int\"\n    )\n\n    for obj in [df, ser]:\n        with pytest.raises(TypeError, match=msg):\n            obj.loc[1:3]\n\n        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n            # GH#31840 deprecated incorrect behavior\n            obj.loc[1:3] = 1\n\n    with pytest.raises(TypeError, match=msg):\n        df.loc[1:3, 1]\n\n    with tm.assert_produces_warning(FutureWarning):\n        # GH#31840 deprecated incorrect behavior\n        df.loc[1:3, 1] = 2",
        "begin_line": 1050,
        "end_line": 1075,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.test_loc_datetimelike_mismatched_dtypes#1078",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc",
        "signature": "pandas.tests.indexing.test_loc.test_loc_datetimelike_mismatched_dtypes()",
        "snippet": "def test_loc_datetimelike_mismatched_dtypes():\n    # GH#32650 dont mix and match datetime/timedelta/period dtypes\n\n    df = pd.DataFrame(\n        np.random.randn(5, 3),\n        columns=[\"a\", \"b\", \"c\"],\n        index=pd.date_range(\"2012\", freq=\"H\", periods=5),\n    )\n    # create dataframe with non-unique DatetimeIndex\n    df = df.iloc[[0, 2, 2, 3]].copy()\n\n    dti = df.index\n    tdi = pd.TimedeltaIndex(dti.asi8)  # matching i8 values\n\n    msg = r\"None of \\[TimedeltaIndex.* are in the \\[index\\]\"\n    with pytest.raises(KeyError, match=msg):\n        df.loc[tdi]\n\n    with pytest.raises(KeyError, match=msg):\n        df[\"a\"].loc[tdi]",
        "begin_line": 1078,
        "end_line": 1097,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.conftest.multiindex_dataframe_random_data#8",
        "src_path": "pandas/tests/indexing/multiindex/conftest.py",
        "class_name": "pandas.tests.indexing.multiindex.conftest",
        "signature": "pandas.tests.indexing.multiindex.conftest.multiindex_dataframe_random_data()",
        "snippet": "def multiindex_dataframe_random_data():\n    \"\"\"DataFrame with 2 level MultiIndex with random data\"\"\"\n    index = MultiIndex(\n        levels=[[\"foo\", \"bar\", \"baz\", \"qux\"], [\"one\", \"two\", \"three\"]],\n        codes=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3], [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],\n        names=[\"first\", \"second\"],\n    )\n    return DataFrame(\n        np.random.randn(10, 3), index=index, columns=Index([\"A\", \"B\", \"C\"], name=\"exp\")\n    )",
        "begin_line": 8,
        "end_line": 17,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.index#51",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.index(self, request)",
        "snippet": "    def index(self, request):\n        \"\"\"\n        Fixture for selectively parametrizing indices_dict via indirect parametrization\n        (parametrize over indices_dict keys with indirect=True). Defaults to string\n        index if no keys are provided.\n        \"\"\"\n        key = getattr(request, \"param\", \"string\")\n\n        # copy to avoid mutation, e.g. setting .name\n        return indices_dict[key].copy()",
        "begin_line": 51,
        "end_line": 60,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.create_index#62",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.create_index(self)",
        "snippet": "    def create_index(self) -> Index:\n        return Index(list(\"abcde\"))",
        "begin_line": 62,
        "end_line": 63,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_can_hold_identifiers#65",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_can_hold_identifiers(self)",
        "snippet": "    def test_can_hold_identifiers(self):\n        index = self.create_index()\n        key = index[0]\n        assert index._can_hold_identifiers_and_holds_name(key) is True",
        "begin_line": 65,
        "end_line": 68,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_new_axis#71",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_new_axis(self, index)",
        "snippet": "    def test_new_axis(self, index):\n        with tm.assert_produces_warning(DeprecationWarning):\n            # GH#30588 multi-dimensional indexing deprecated\n            new_index = index[None, :]\n        assert new_index.ndim == 2\n        assert isinstance(new_index, np.ndarray)",
        "begin_line": 71,
        "end_line": 76,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_copy_and_deepcopy#79",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_copy_and_deepcopy(self, index)",
        "snippet": "    def test_copy_and_deepcopy(self, index):\n        new_copy2 = index.copy(dtype=int)\n        assert new_copy2.dtype.kind == \"i\"",
        "begin_line": 79,
        "end_line": 81,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_constructor_regular#83",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_constructor_regular(self, indices)",
        "snippet": "    def test_constructor_regular(self, indices):\n        tm.assert_contains_all(indices, indices)",
        "begin_line": 83,
        "end_line": 84,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_constructor_casting#86",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_constructor_casting(self, index)",
        "snippet": "    def test_constructor_casting(self, index):\n        # casting\n        arr = np.array(index)\n        new_index = Index(arr)\n        tm.assert_contains_all(arr, new_index)\n        tm.assert_index_equal(index, new_index)",
        "begin_line": 86,
        "end_line": 91,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_constructor_copy#93",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_constructor_copy(self, index)",
        "snippet": "    def test_constructor_copy(self, index):\n        # copy\n        # index = self.create_index()\n        arr = np.array(index)\n        new_index = Index(arr, copy=True, name=\"name\")\n        assert isinstance(new_index, Index)\n        assert new_index.name == \"name\"\n        tm.assert_numpy_array_equal(arr, new_index.values)\n        arr[0] = \"SOMEBIGLONGSTRING\"\n        assert new_index[0] != \"SOMEBIGLONGSTRING\"",
        "begin_line": 93,
        "end_line": 102,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_constructor_from_index_dtlike#125",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_constructor_from_index_dtlike(self, cast_as_obj, index)",
        "snippet": "    def test_constructor_from_index_dtlike(self, cast_as_obj, index):\n        if cast_as_obj:\n            result = pd.Index(index.astype(object))\n        else:\n            result = pd.Index(index)\n\n        tm.assert_index_equal(result, index)\n\n        if isinstance(index, pd.DatetimeIndex):\n            assert result.tz == index.tz\n            if cast_as_obj:\n                # GH#23524 check that Index(dti, dtype=object) does not\n                #  incorrectly raise ValueError, and that nanoseconds are not\n                #  dropped\n                index += pd.Timedelta(nanoseconds=50)\n                result = pd.Index(index, dtype=object)\n                assert result.dtype == np.object_\n                assert list(result) == list(index)",
        "begin_line": 125,
        "end_line": 142,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_constructor_from_series_dtlike#155",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_constructor_from_series_dtlike(self, index, has_tz)",
        "snippet": "    def test_constructor_from_series_dtlike(self, index, has_tz):\n        result = pd.Index(pd.Series(index))\n        tm.assert_index_equal(result, index)\n\n        if has_tz:\n            assert result.tz == index.tz",
        "begin_line": 155,
        "end_line": 160,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_constructor_from_series#163",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_constructor_from_series(self, klass)",
        "snippet": "    def test_constructor_from_series(self, klass):\n        expected = DatetimeIndex(\n            [Timestamp(\"20110101\"), Timestamp(\"20120101\"), Timestamp(\"20130101\")]\n        )\n        s = Series(\n            [Timestamp(\"20110101\"), Timestamp(\"20120101\"), Timestamp(\"20130101\")]\n        )\n        result = klass(s)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 163,
        "end_line": 171,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_constructor_from_series_freq#173",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_constructor_from_series_freq(self)",
        "snippet": "    def test_constructor_from_series_freq(self):\n        # GH 6273\n        # create from a series, passing a freq\n        dts = [\"1-1-1990\", \"2-1-1990\", \"3-1-1990\", \"4-1-1990\", \"5-1-1990\"]\n        expected = DatetimeIndex(dts, freq=\"MS\")\n\n        s = Series(pd.to_datetime(dts))\n        result = DatetimeIndex(s, freq=\"MS\")\n\n        tm.assert_index_equal(result, expected)",
        "begin_line": 173,
        "end_line": 182,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_constructor_from_frame_series_freq#184",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_constructor_from_frame_series_freq(self)",
        "snippet": "    def test_constructor_from_frame_series_freq(self):\n        # GH 6273\n        # create from a series, passing a freq\n        dts = [\"1-1-1990\", \"2-1-1990\", \"3-1-1990\", \"4-1-1990\", \"5-1-1990\"]\n        expected = DatetimeIndex(dts, freq=\"MS\")\n\n        df = pd.DataFrame(np.random.rand(5, 3))\n        df[\"date\"] = dts\n        result = DatetimeIndex(df[\"date\"], freq=\"MS\")\n\n        assert df[\"date\"].dtype == object\n        expected.name = \"date\"\n        tm.assert_index_equal(result, expected)\n\n        expected = pd.Series(dts, name=\"date\")\n        tm.assert_series_equal(df[\"date\"], expected)\n\n        # GH 6274\n        # infer freq of same\n        freq = pd.infer_freq(df[\"date\"])\n        assert freq == \"MS\"",
        "begin_line": 184,
        "end_line": 204,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_constructor_ndarray_like#214",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_constructor_ndarray_like(self, array)",
        "snippet": "    def test_constructor_ndarray_like(self, array):\n        # GH 5460#issuecomment-44474502\n        # it should be possible to convert any object that satisfies the numpy\n        # ndarray interface directly into an Index\n        class ArrayLike:\n            def __init__(self, array):\n                self.array = array\n\n            def __array__(self, dtype=None) -> np.ndarray:\n                return self.array\n\n        expected = pd.Index(array)\n        result = pd.Index(ArrayLike(array))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 214,
        "end_line": 227,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.ArrayLike.test_constructor_ndarray_like#214",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.ArrayLike",
        "signature": "pandas.tests.indexes.test_base.ArrayLike.test_constructor_ndarray_like(self, array)",
        "snippet": "    def test_constructor_ndarray_like(self, array):\n        # GH 5460#issuecomment-44474502\n        # it should be possible to convert any object that satisfies the numpy\n        # ndarray interface directly into an Index\n        class ArrayLike:\n            def __init__(self, array):\n                self.array = array\n\n            def __array__(self, dtype=None) -> np.ndarray:\n                return self.array\n\n        expected = pd.Index(array)\n        result = pd.Index(ArrayLike(array))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 214,
        "end_line": 227,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.ArrayLike.__init__#219",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.ArrayLike",
        "signature": "pandas.tests.indexes.test_base.ArrayLike.__init__(self, array)",
        "snippet": "            def __init__(self, array):\n                self.array = array",
        "begin_line": 219,
        "end_line": 220,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.ArrayLike.__array__#222",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.ArrayLike",
        "signature": "pandas.tests.indexes.test_base.ArrayLike.__array__(self, dtype=None)",
        "snippet": "            def __array__(self, dtype=None) -> np.ndarray:\n                return self.array",
        "begin_line": 222,
        "end_line": 223,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_constructor_int_dtype_nan#229",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_constructor_int_dtype_nan(self)",
        "snippet": "    def test_constructor_int_dtype_nan(self):\n        # see gh-15187\n        data = [np.nan]\n        expected = Float64Index(data)\n        result = Index(data, dtype=\"float\")\n        tm.assert_index_equal(result, expected)",
        "begin_line": 229,
        "end_line": 234,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_constructor_int_dtype_nan_raises#237",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_constructor_int_dtype_nan_raises(self, dtype)",
        "snippet": "    def test_constructor_int_dtype_nan_raises(self, dtype):\n        # see gh-15187\n        data = [np.nan]\n        msg = \"cannot convert\"\n        with pytest.raises(ValueError, match=msg):\n            Index(data, dtype=dtype)",
        "begin_line": 237,
        "end_line": 242,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_constructor_no_pandas_array#244",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_constructor_no_pandas_array(self)",
        "snippet": "    def test_constructor_no_pandas_array(self):\n        ser = pd.Series([1, 2, 3])\n        result = pd.Index(ser.array)\n        expected = pd.Index([1, 2, 3])\n        tm.assert_index_equal(result, expected)",
        "begin_line": 244,
        "end_line": 248,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_index_ctor_infer_nan_nat#257",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_index_ctor_infer_nan_nat(self, klass, dtype, na_val)",
        "snippet": "    def test_index_ctor_infer_nan_nat(self, klass, dtype, na_val):\n        # GH 13467\n        na_list = [na_val, na_val]\n        expected = klass(na_list)\n        assert expected.dtype == dtype\n\n        result = Index(na_list)\n        tm.assert_index_equal(result, expected)\n\n        result = Index(np.array(na_list))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 257,
        "end_line": 267,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_index_ctor_infer_nat_dt_like#277",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_index_ctor_infer_nat_dt_like(self, pos, klass, dtype, ctor, nulls_fixture)",
        "snippet": "    def test_index_ctor_infer_nat_dt_like(self, pos, klass, dtype, ctor, nulls_fixture):\n        expected = klass([pd.NaT, pd.NaT])\n        assert expected.dtype == dtype\n        data = [ctor]\n        data.insert(pos, nulls_fixture)\n\n        if nulls_fixture is pd.NA:\n            expected = Index([pd.NA, pd.NaT])\n            pytest.xfail(\"Broken with np.NaT ctor; see GH 31884\")\n\n        result = Index(data)\n        tm.assert_index_equal(result, expected)\n\n        result = Index(np.array(data, dtype=object))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 277,
        "end_line": 291,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_index_ctor_nat_result#294",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_index_ctor_nat_result(self, swap_objs)",
        "snippet": "    def test_index_ctor_nat_result(self, swap_objs):\n        # mixed np.datetime64/timedelta64 nat results in object\n        data = [np.datetime64(\"nat\"), np.timedelta64(\"nat\")]\n        if swap_objs:\n            data = data[::-1]\n\n        expected = pd.Index(data, dtype=object)\n        tm.assert_index_equal(Index(data), expected)\n        tm.assert_index_equal(Index(np.array(data, dtype=object)), expected)",
        "begin_line": 294,
        "end_line": 302,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_index_ctor_infer_periodindex#304",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_index_ctor_infer_periodindex(self)",
        "snippet": "    def test_index_ctor_infer_periodindex(self):\n        xp = period_range(\"2012-1-1\", freq=\"M\", periods=3)\n        rs = Index(xp)\n        tm.assert_index_equal(rs, xp)\n        assert isinstance(rs, PeriodIndex)",
        "begin_line": 304,
        "end_line": 308,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_constructor_simple_new#318",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_constructor_simple_new(self, vals, dtype)",
        "snippet": "    def test_constructor_simple_new(self, vals, dtype):\n        index = Index(vals, name=dtype)\n        result = index._simple_new(index.values, dtype)\n        tm.assert_index_equal(result, index)",
        "begin_line": 318,
        "end_line": 321,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_constructor_dtypes_to_int64#334",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_constructor_dtypes_to_int64(self, vals)",
        "snippet": "    def test_constructor_dtypes_to_int64(self, vals):\n        index = Index(vals, dtype=int)\n        assert isinstance(index, Int64Index)",
        "begin_line": 334,
        "end_line": 336,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_constructor_dtypes_to_float64#348",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_constructor_dtypes_to_float64(self, vals)",
        "snippet": "    def test_constructor_dtypes_to_float64(self, vals):\n        index = Index(vals, dtype=float)\n        assert isinstance(index, Float64Index)",
        "begin_line": 348,
        "end_line": 350,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_constructor_dtypes_to_categorical#363",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_constructor_dtypes_to_categorical(self, vals)",
        "snippet": "    def test_constructor_dtypes_to_categorical(self, vals):\n        index = Index(vals, dtype=\"category\")\n        assert isinstance(index, CategoricalIndex)",
        "begin_line": 363,
        "end_line": 365,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_constructor_dtypes_to_datetime#382",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_constructor_dtypes_to_datetime(self, cast_index, vals)",
        "snippet": "    def test_constructor_dtypes_to_datetime(self, cast_index, vals):\n        if cast_index:\n            index = Index(vals, dtype=object)\n            assert isinstance(index, Index)\n            assert index.dtype == object\n        else:\n            index = Index(vals)\n            assert isinstance(index, DatetimeIndex)",
        "begin_line": 382,
        "end_line": 389,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_constructor_dtypes_to_timedelta#399",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_constructor_dtypes_to_timedelta(self, cast_index, vals)",
        "snippet": "    def test_constructor_dtypes_to_timedelta(self, cast_index, vals):\n        if cast_index:\n            index = Index(vals, dtype=object)\n            assert isinstance(index, Index)\n            assert index.dtype == object\n        else:\n            index = Index(vals)\n            assert isinstance(index, TimedeltaIndex)",
        "begin_line": 399,
        "end_line": 406,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_constructor_dtypes_datetime#410",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_constructor_dtypes_datetime(self, tz_naive_fixture, attr, klass)",
        "snippet": "    def test_constructor_dtypes_datetime(self, tz_naive_fixture, attr, klass):\n        # Test constructing with a datetimetz dtype\n        # .values produces numpy datetimes, so these are considered naive\n        # .asi8 produces integers, so these are considered epoch timestamps\n        # ^the above will be true in a later version. Right now we `.view`\n        # the i8 values as NS_DTYPE, effectively treating them as wall times.\n        index = pd.date_range(\"2011-01-01\", periods=5)\n        arg = getattr(index, attr)\n        index = index.tz_localize(tz_naive_fixture)\n        dtype = index.dtype\n\n        if attr == \"asi8\":\n            result = pd.DatetimeIndex(arg).tz_localize(tz_naive_fixture)\n        else:\n            result = klass(arg, tz=tz_naive_fixture)\n        tm.assert_index_equal(result, index)\n\n        if attr == \"asi8\":\n            result = pd.DatetimeIndex(arg).astype(dtype)\n        else:\n            result = klass(arg, dtype=dtype)\n        tm.assert_index_equal(result, index)\n\n        if attr == \"asi8\":\n            result = pd.DatetimeIndex(list(arg)).tz_localize(tz_naive_fixture)\n        else:\n            result = klass(list(arg), tz=tz_naive_fixture)\n        tm.assert_index_equal(result, index)\n\n        if attr == \"asi8\":\n            result = pd.DatetimeIndex(list(arg)).astype(dtype)\n        else:\n            result = klass(list(arg), dtype=dtype)\n        tm.assert_index_equal(result, index)",
        "begin_line": 410,
        "end_line": 443,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_constructor_dtypes_timedelta#447",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_constructor_dtypes_timedelta(self, attr, klass)",
        "snippet": "    def test_constructor_dtypes_timedelta(self, attr, klass):\n        index = pd.timedelta_range(\"1 days\", periods=5)\n        dtype = index.dtype\n\n        values = getattr(index, attr)\n\n        result = klass(values, dtype=dtype)\n        tm.assert_index_equal(result, index)\n\n        result = klass(list(values), dtype=dtype)\n        tm.assert_index_equal(result, index)",
        "begin_line": 447,
        "end_line": 457,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_constructor_empty#472",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_constructor_empty(self, value, klass)",
        "snippet": "    def test_constructor_empty(self, value, klass):\n        empty = klass(value)\n        assert isinstance(empty, klass)\n        assert not len(empty)",
        "begin_line": 472,
        "end_line": 475,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_constructor_empty_special#487",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_constructor_empty_special(self, empty, klass)",
        "snippet": "    def test_constructor_empty_special(self, empty, klass):\n        assert isinstance(empty, klass)\n        assert not len(empty)",
        "begin_line": 487,
        "end_line": 489,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_constructor_overflow_int64#491",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_constructor_overflow_int64(self)",
        "snippet": "    def test_constructor_overflow_int64(self):\n        # see gh-15832\n        msg = (\n            \"The elements provided in the data cannot \"\n            \"all be casted to the dtype int64\"\n        )\n        with pytest.raises(OverflowError, match=msg):\n            Index([np.iinfo(np.uint64).max - 1], dtype=\"int64\")",
        "begin_line": 491,
        "end_line": 498,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_view_with_args#515",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_view_with_args(self, index)",
        "snippet": "    def test_view_with_args(self, index):\n        index.view(\"i8\")",
        "begin_line": 515,
        "end_line": 516,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_view_with_args_object_array_raises#529",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_view_with_args_object_array_raises(self, index)",
        "snippet": "    def test_view_with_args_object_array_raises(self, index):\n        msg = \"Cannot change data-type for object array\"\n        with pytest.raises(TypeError, match=msg):\n            index.view(\"i8\")",
        "begin_line": 529,
        "end_line": 532,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_astype#535",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_astype(self, index)",
        "snippet": "    def test_astype(self, index):\n        casted = index.astype(\"i8\")\n\n        # it works!\n        casted.get_loc(5)\n\n        # pass on name\n        index.name = \"foobar\"\n        casted = index.astype(\"i8\")\n        assert casted.name == \"foobar\"",
        "begin_line": 535,
        "end_line": 544,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_equals_object#546",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_equals_object(self)",
        "snippet": "    def test_equals_object(self):\n        # same\n        assert Index([\"a\", \"b\", \"c\"]).equals(Index([\"a\", \"b\", \"c\"]))",
        "begin_line": 546,
        "end_line": 548,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_not_equals_object#553",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_not_equals_object(self, comp)",
        "snippet": "    def test_not_equals_object(self, comp):\n        assert not Index([\"a\", \"b\", \"c\"]).equals(comp)",
        "begin_line": 553,
        "end_line": 554,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_insert_missing#556",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_insert_missing(self, nulls_fixture)",
        "snippet": "    def test_insert_missing(self, nulls_fixture):\n        # GH 22295\n        # test there is no mangling of NA values\n        expected = Index([\"a\", nulls_fixture, \"b\", \"c\"])\n        result = Index(list(\"abc\")).insert(1, nulls_fixture)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 556,
        "end_line": 561,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_delete_raises#563",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_delete_raises(self)",
        "snippet": "    def test_delete_raises(self):\n        index = Index([\"a\", \"b\", \"c\", \"d\"], name=\"index\")\n        msg = \"index 5 is out of bounds for axis 0 with size 4\"\n        with pytest.raises(IndexError, match=msg):\n            index.delete(5)",
        "begin_line": 563,
        "end_line": 567,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_identical#569",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_identical(self)",
        "snippet": "    def test_identical(self):\n\n        # index\n        i1 = Index([\"a\", \"b\", \"c\"])\n        i2 = Index([\"a\", \"b\", \"c\"])\n\n        assert i1.identical(i2)\n\n        i1 = i1.rename(\"foo\")\n        assert i1.equals(i2)\n        assert not i1.identical(i2)\n\n        i2 = i2.rename(\"foo\")\n        assert i1.identical(i2)\n\n        i3 = Index([(\"a\", \"a\"), (\"a\", \"b\"), (\"b\", \"a\")])\n        i4 = Index([(\"a\", \"a\"), (\"a\", \"b\"), (\"b\", \"a\")], tupleize_cols=False)\n        assert not i3.identical(i4)",
        "begin_line": 569,
        "end_line": 586,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_is_#588",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_is_(self)",
        "snippet": "    def test_is_(self):\n        ind = Index(range(10))\n        assert ind.is_(ind)\n        assert ind.is_(ind.view().view().view().view())\n        assert not ind.is_(Index(range(10)))\n        assert not ind.is_(ind.copy())\n        assert not ind.is_(ind.copy(deep=False))\n        assert not ind.is_(ind[:])\n        assert not ind.is_(np.array(range(10)))\n\n        # quasi-implementation dependent\n        assert ind.is_(ind.view())\n        ind2 = ind.view()\n        ind2.name = \"bob\"\n        assert ind.is_(ind2)\n        assert ind2.is_(ind)\n        # doesn't matter if Indices are *actually* views of underlying data,\n        assert not ind.is_(Index(ind.values))\n        arr = np.array(range(1, 11))\n        ind1 = Index(arr, copy=False)\n        ind2 = Index(arr, copy=False)\n        assert not ind1.is_(ind2)",
        "begin_line": 588,
        "end_line": 609,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_asof#612",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_asof(self, index)",
        "snippet": "    def test_asof(self, index):\n        d = index[0]\n        assert index.asof(d) == d\n        assert isna(index.asof(d - timedelta(1)))\n\n        d = index[-1]\n        assert index.asof(d + timedelta(1)) == d\n\n        d = index[0].to_pydatetime()\n        assert isinstance(index.asof(d), Timestamp)",
        "begin_line": 612,
        "end_line": 621,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_asof_datetime_partial#623",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_asof_datetime_partial(self)",
        "snippet": "    def test_asof_datetime_partial(self):\n        index = pd.date_range(\"2010-01-01\", periods=2, freq=\"m\")\n        expected = Timestamp(\"2010-02-28\")\n        result = index.asof(\"2010-02\")\n        assert result == expected\n        assert not isinstance(result, Index)",
        "begin_line": 623,
        "end_line": 628,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_nanosecond_index_access#630",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_nanosecond_index_access(self)",
        "snippet": "    def test_nanosecond_index_access(self):\n        s = Series([Timestamp(\"20130101\")]).values.view(\"i8\")[0]\n        r = DatetimeIndex([s + 50 + i for i in range(100)])\n        x = Series(np.random.randn(100), index=r)\n\n        first_value = x.asof(x.index[0])\n\n        # this does not yet work, as parsing strings is done via dateutil\n        # assert first_value == x['2013-01-01 00:00:00.000000050+0000']\n\n        expected_ts = np_datetime64_compat(\"2013-01-01 00:00:00.000000050+0000\", \"ns\")\n        assert first_value == x[Timestamp(expected_ts)]",
        "begin_line": 630,
        "end_line": 641,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_booleanindex#643",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_booleanindex(self, index)",
        "snippet": "    def test_booleanindex(self, index):\n        bool_index = np.ones(len(index), dtype=bool)\n        bool_index[5:30:2] = False\n\n        sub_index = index[bool_index]\n\n        for i, val in enumerate(sub_index):\n            assert sub_index.get_loc(val) == i\n\n        sub_index = index[list(bool_index)]\n        for i, val in enumerate(sub_index):\n            assert sub_index.get_loc(val) == i",
        "begin_line": 643,
        "end_line": 654,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_fancy#656",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_fancy(self)",
        "snippet": "    def test_fancy(self):\n        index = self.create_index()\n        sl = index[[1, 2, 3]]\n        for i in sl:\n            assert i == sl[sl.get_loc(i)]",
        "begin_line": 656,
        "end_line": 660,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_empty_fancy#664",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_empty_fancy(self, index, dtype)",
        "snippet": "    def test_empty_fancy(self, index, dtype):\n        empty_arr = np.array([], dtype=dtype)\n        empty_index = type(index)([])\n\n        assert index[[]].identical(empty_index)\n        assert index[empty_arr].identical(empty_index)",
        "begin_line": 664,
        "end_line": 669,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_empty_fancy_raises#672",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_empty_fancy_raises(self, index)",
        "snippet": "    def test_empty_fancy_raises(self, index):\n        # pd.DatetimeIndex is excluded, because it overrides getitem and should\n        # be tested separately.\n        empty_farr = np.array([], dtype=np.float_)\n        empty_index = type(index)([])\n\n        assert index[[]].identical(empty_index)\n        # np.ndarray only accepts ndarray of int & bool dtypes, so should Index\n        msg = r\"arrays used as indices must be of integer \\(or boolean\\) type\"\n        with pytest.raises(IndexError, match=msg):\n            index[empty_farr]",
        "begin_line": 672,
        "end_line": 682,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_intersection#684",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_intersection(self, index, sort)",
        "snippet": "    def test_intersection(self, index, sort):\n        first = index[:20]\n        second = index[:10]\n        intersect = first.intersection(second, sort=sort)\n        if sort is None:\n            tm.assert_index_equal(intersect, second.sort_values())\n        assert tm.equalContents(intersect, second)\n\n        # Corner cases\n        inter = first.intersection(first, sort=sort)\n        assert inter is first",
        "begin_line": 684,
        "end_line": 694,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_intersection_name_preservation#704",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_intersection_name_preservation(self, index2, keeps_name, sort)",
        "snippet": "    def test_intersection_name_preservation(self, index2, keeps_name, sort):\n        index1 = Index([1, 2, 3, 4, 5], name=\"index\")\n        expected = Index([3, 4, 5])\n        result = index1.intersection(index2, sort)\n\n        if keeps_name:\n            expected.name = \"index\"\n\n        assert result.name == expected.name\n        tm.assert_index_equal(result, expected)",
        "begin_line": 704,
        "end_line": 713,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_intersection_name_preservation2#719",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_intersection_name_preservation2(self, index, first_name, second_name, expected_name, sort)",
        "snippet": "    def test_intersection_name_preservation2(\n        self, index, first_name, second_name, expected_name, sort\n    ):\n        first = index[5:20]\n        second = index[:10]\n        first.name = first_name\n        second.name = second_name\n        intersect = first.intersection(second, sort=sort)\n        assert intersect.name == expected_name",
        "begin_line": 719,
        "end_line": 727,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_intersection_monotonic#736",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_intersection_monotonic(self, index2, keeps_name, sort)",
        "snippet": "    def test_intersection_monotonic(self, index2, keeps_name, sort):\n        index1 = Index([5, 3, 2, 4, 1], name=\"index\")\n        expected = Index([5, 3, 4])\n\n        if keeps_name:\n            expected.name = \"index\"\n\n        result = index1.intersection(index2, sort=sort)\n        if sort is None:\n            expected = expected.sort_values()\n        tm.assert_index_equal(result, expected)",
        "begin_line": 736,
        "end_line": 746,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_intersection_non_monotonic_non_unique#752",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_intersection_non_monotonic_non_unique(self, index2, expected_arr, sort)",
        "snippet": "    def test_intersection_non_monotonic_non_unique(self, index2, expected_arr, sort):\n        # non-monotonic non-unique\n        index1 = Index([\"A\", \"B\", \"A\", \"C\"])\n        expected = Index(expected_arr, dtype=\"object\")\n        result = index1.intersection(index2, sort=sort)\n        if sort is None:\n            expected = expected.sort_values()\n        tm.assert_index_equal(result, expected)",
        "begin_line": 752,
        "end_line": 759,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_intersect_str_dates#761",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_intersect_str_dates(self, sort)",
        "snippet": "    def test_intersect_str_dates(self, sort):\n        dt_dates = [datetime(2012, 2, 9), datetime(2012, 2, 22)]\n\n        i1 = Index(dt_dates, dtype=object)\n        i2 = Index([\"aa\"], dtype=object)\n        result = i2.intersection(i1, sort=sort)\n\n        assert len(result) == 0",
        "begin_line": 761,
        "end_line": 768,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_intersection_equal_sort_true#771",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_intersection_equal_sort_true(self)",
        "snippet": "    def test_intersection_equal_sort_true(self):\n        # TODO decide on True behaviour\n        idx = pd.Index([\"c\", \"a\", \"b\"])\n        sorted_ = pd.Index([\"a\", \"b\", \"c\"])\n        tm.assert_index_equal(idx.intersection(idx, sort=True), sorted_)",
        "begin_line": 771,
        "end_line": 775,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_chained_union#777",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_chained_union(self, sort)",
        "snippet": "    def test_chained_union(self, sort):\n        # Chained unions handles names correctly\n        i1 = Index([1, 2], name=\"i1\")\n        i2 = Index([5, 6], name=\"i2\")\n        i3 = Index([3, 4], name=\"i3\")\n        union = i1.union(i2.union(i3, sort=sort), sort=sort)\n        expected = i1.union(i2, sort=sort).union(i3, sort=sort)\n        tm.assert_index_equal(union, expected)\n\n        j1 = Index([1, 2], name=\"j1\")\n        j2 = Index([], name=\"j2\")\n        j3 = Index([], name=\"j3\")\n        union = j1.union(j2.union(j3, sort=sort), sort=sort)\n        expected = j1.union(j2, sort=sort).union(j3, sort=sort)\n        tm.assert_index_equal(union, expected)",
        "begin_line": 777,
        "end_line": 791,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_union#793",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_union(self, index, sort)",
        "snippet": "    def test_union(self, index, sort):\n        first = index[5:20]\n        second = index[:10]\n        everything = index[:20]\n\n        union = first.union(second, sort=sort)\n        if sort is None:\n            tm.assert_index_equal(union, everything.sort_values())\n        assert tm.equalContents(union, everything)",
        "begin_line": 793,
        "end_line": 801,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_union_sort_other_special#804",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_union_sort_other_special(self, slice_)",
        "snippet": "    def test_union_sort_other_special(self, slice_):\n        # https://github.com/pandas-dev/pandas/issues/24959\n\n        idx = pd.Index([1, 0, 2])\n        # default, sort=None\n        other = idx[slice_]\n        tm.assert_index_equal(idx.union(other), idx)\n        tm.assert_index_equal(other.union(idx), idx)\n\n        # sort=False\n        tm.assert_index_equal(idx.union(other, sort=False), idx)",
        "begin_line": 804,
        "end_line": 814,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_union_sort_special_true#818",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_union_sort_special_true(self, slice_)",
        "snippet": "    def test_union_sort_special_true(self, slice_):\n        # TODO decide on True behaviour\n        # sort=True\n        idx = pd.Index([1, 0, 2])\n        # default, sort=None\n        other = idx[slice_]\n\n        result = idx.union(other, sort=True)\n        expected = pd.Index([0, 1, 2])\n        tm.assert_index_equal(result, expected)",
        "begin_line": 818,
        "end_line": 827,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_union_from_iterables#830",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_union_from_iterables(self, index, klass, sort)",
        "snippet": "    def test_union_from_iterables(self, index, klass, sort):\n        # GH 10149\n        first = index[5:20]\n        second = index[:10]\n        everything = index[:20]\n\n        case = klass(second.values)\n        result = first.union(case, sort=sort)\n        if sort is None:\n            tm.assert_index_equal(result, everything.sort_values())\n        assert tm.equalContents(result, everything)",
        "begin_line": 830,
        "end_line": 840,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_union_identity#842",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_union_identity(self, index, sort)",
        "snippet": "    def test_union_identity(self, index, sort):\n        first = index[5:20]\n\n        union = first.union(first, sort=sort)\n        # i.e. identity is not preserved when sort is True\n        assert (union is first) is (not sort)\n\n        # This should no longer be the same object, since [] is not consistent,\n        # both objects will be recast to dtype('O')\n        union = first.union([], sort=sort)\n        assert (union is first) is (not sort)\n\n        union = Index([]).union(first, sort=sort)\n        assert (union is first) is (not sort)",
        "begin_line": 842,
        "end_line": 855,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_union_name_preservation#863",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_union_name_preservation(self, first_list, second_list, first_name, second_name, expected_name, sort)",
        "snippet": "    def test_union_name_preservation(\n        self, first_list, second_list, first_name, second_name, expected_name, sort\n    ):\n        first = Index(first_list, name=first_name)\n        second = Index(second_list, name=second_name)\n        union = first.union(second, sort=sort)\n\n        vals = set(first_list).union(second_list)\n\n        if sort is None and len(first_list) > 0 and len(second_list) > 0:\n            expected = Index(sorted(vals), name=expected_name)\n            tm.assert_index_equal(union, expected)\n        else:\n            expected = Index(vals, name=expected_name)\n            assert tm.equalContents(union, expected)",
        "begin_line": 863,
        "end_line": 877,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_union_dt_as_obj#879",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_union_dt_as_obj(self, sort)",
        "snippet": "    def test_union_dt_as_obj(self, sort):\n        # TODO: Replace with fixturesult\n        index = self.create_index()\n        date_index = pd.date_range(\"2019-01-01\", periods=10)\n        first_cat = index.union(date_index)\n        second_cat = index.union(index)\n\n        if date_index.dtype == np.object_:\n            appended = np.append(index, date_index)\n        else:\n            appended = np.append(index, date_index.astype(\"O\"))\n\n        assert tm.equalContents(first_cat, appended)\n        assert tm.equalContents(second_cat, index)\n        tm.assert_contains_all(index, first_cat)\n        tm.assert_contains_all(index, second_cat)\n        tm.assert_contains_all(date_index, first_cat)",
        "begin_line": 879,
        "end_line": 895,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_map_identity_mapping#897",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_map_identity_mapping(self, indices)",
        "snippet": "    def test_map_identity_mapping(self, indices):\n        # GH 12766\n        tm.assert_index_equal(indices, indices.map(lambda x: x))",
        "begin_line": 897,
        "end_line": 899,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_map_with_tuples#901",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_map_with_tuples(self)",
        "snippet": "    def test_map_with_tuples(self):\n        # GH 12766\n\n        # Test that returning a single tuple from an Index\n        #   returns an Index.\n        index = tm.makeIntIndex(3)\n        result = tm.makeIntIndex(3).map(lambda x: (x,))\n        expected = Index([(i,) for i in index])\n        tm.assert_index_equal(result, expected)\n\n        # Test that returning a tuple from a map of a single index\n        #   returns a MultiIndex object.\n        result = index.map(lambda x: (x, x == 1))\n        expected = MultiIndex.from_tuples([(i, i == 1) for i in index])\n        tm.assert_index_equal(result, expected)",
        "begin_line": 901,
        "end_line": 915,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_map_with_tuples_mi#917",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_map_with_tuples_mi(self)",
        "snippet": "    def test_map_with_tuples_mi(self):\n        # Test that returning a single object from a MultiIndex\n        #   returns an Index.\n        first_level = [\"foo\", \"bar\", \"baz\"]\n        multi_index = MultiIndex.from_tuples(zip(first_level, [1, 2, 3]))\n        reduced_index = multi_index.map(lambda x: x[0])\n        tm.assert_index_equal(reduced_index, Index(first_level))",
        "begin_line": 917,
        "end_line": 923,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_map_tseries_indices_return_index#928",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_map_tseries_indices_return_index(self, attr)",
        "snippet": "    def test_map_tseries_indices_return_index(self, attr):\n        index = getattr(tm, attr)(10)\n        expected = Index([1] * 10)\n        result = index.map(lambda x: 1)\n        tm.assert_index_equal(expected, result)",
        "begin_line": 928,
        "end_line": 932,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_map_tseries_indices_accsr_return_index#934",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_map_tseries_indices_accsr_return_index(self)",
        "snippet": "    def test_map_tseries_indices_accsr_return_index(self):\n        date_index = tm.makeDateIndex(24, freq=\"h\", name=\"hourly\")\n        expected = Index(range(24), name=\"hourly\")\n        tm.assert_index_equal(expected, date_index.map(lambda x: x.hour))",
        "begin_line": 934,
        "end_line": 937,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_map_dictlike_simple#946",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_map_dictlike_simple(self, mapper)",
        "snippet": "    def test_map_dictlike_simple(self, mapper):\n        # GH 12756\n        expected = Index([\"foo\", \"bar\", \"baz\"])\n        index = tm.makeIntIndex(3)\n        result = index.map(mapper(expected.values, index))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 946,
        "end_line": 951,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_map_dictlike#960",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_map_dictlike(self, indices, mapper)",
        "snippet": "    def test_map_dictlike(self, indices, mapper):\n        # GH 12756\n        if isinstance(indices, CategoricalIndex):\n            # Tested in test_categorical\n            return\n        elif not indices.is_unique:\n            # Cannot map duplicated index\n            return\n\n        if indices.empty:\n            # to match proper result coercion for uints\n            expected = Index([])\n        else:\n            expected = Index(np.arange(len(indices), 0, -1))\n\n        result = indices.map(mapper(expected, indices))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 960,
        "end_line": 976,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_map_with_non_function_missing_values#982",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_map_with_non_function_missing_values(self, mapper)",
        "snippet": "    def test_map_with_non_function_missing_values(self, mapper):\n        # GH 12756\n        expected = Index([2.0, np.nan, \"foo\"])\n        result = Index([2, 1, 0]).map(mapper)\n\n        tm.assert_index_equal(expected, result)",
        "begin_line": 982,
        "end_line": 987,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_map_na_exclusion#989",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_map_na_exclusion(self)",
        "snippet": "    def test_map_na_exclusion(self):\n        index = Index([1.5, np.nan, 3, np.nan, 5])\n\n        result = index.map(lambda x: x * 2, na_action=\"ignore\")\n        expected = index * 2\n        tm.assert_index_equal(result, expected)",
        "begin_line": 989,
        "end_line": 994,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_map_defaultdict#996",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_map_defaultdict(self)",
        "snippet": "    def test_map_defaultdict(self):\n        index = Index([1, 2, 3])\n        default_dict = defaultdict(lambda: \"blank\")\n        default_dict[1] = \"stuff\"\n        result = index.map(default_dict)\n        expected = Index([\"stuff\", \"blank\", \"blank\"])\n        tm.assert_index_equal(result, expected)",
        "begin_line": 996,
        "end_line": 1002,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_append_empty_preserve_name#1005",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_append_empty_preserve_name(self, name, expected)",
        "snippet": "    def test_append_empty_preserve_name(self, name, expected):\n        left = Index([], name=\"foo\")\n        right = Index([1, 2, 3], name=name)\n\n        result = left.append(right)\n        assert result.name == expected",
        "begin_line": 1005,
        "end_line": 1010,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_difference_name_preservation#1013",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_difference_name_preservation(self, index, second_name, expected, sort)",
        "snippet": "    def test_difference_name_preservation(self, index, second_name, expected, sort):\n        first = index[5:20]\n        second = index[:10]\n        answer = index[10:20]\n\n        first.name = \"name\"\n        second.name = second_name\n        result = first.difference(second, sort=sort)\n\n        assert tm.equalContents(result, answer)\n\n        if expected is None:\n            assert result.name is None\n        else:\n            assert result.name == expected",
        "begin_line": 1013,
        "end_line": 1027,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_difference_empty_arg#1029",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_difference_empty_arg(self, index, sort)",
        "snippet": "    def test_difference_empty_arg(self, index, sort):\n        first = index[5:20]\n        first.name == \"name\"\n        result = first.difference([], sort)\n\n        assert tm.equalContents(result, first)\n        assert result.name == first.name",
        "begin_line": 1029,
        "end_line": 1035,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_difference_identity#1037",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_difference_identity(self, index, sort)",
        "snippet": "    def test_difference_identity(self, index, sort):\n        first = index[5:20]\n        first.name == \"name\"\n        result = first.difference(first, sort)\n\n        assert len(result) == 0\n        assert result.name == first.name",
        "begin_line": 1037,
        "end_line": 1043,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_difference_sort#1045",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_difference_sort(self, index, sort)",
        "snippet": "    def test_difference_sort(self, index, sort):\n        first = index[5:20]\n        second = index[:10]\n\n        result = first.difference(second, sort)\n        expected = index[10:20]\n\n        if sort is None:\n            expected = expected.sort_values()\n\n        tm.assert_index_equal(result, expected)",
        "begin_line": 1045,
        "end_line": 1055,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_symmetric_difference#1057",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_symmetric_difference(self, sort)",
        "snippet": "    def test_symmetric_difference(self, sort):\n        # smoke\n        index1 = Index([5, 2, 3, 4], name=\"index1\")\n        index2 = Index([2, 3, 4, 1])\n        result = index1.symmetric_difference(index2, sort=sort)\n        expected = Index([5, 1])\n        assert tm.equalContents(result, expected)\n        assert result.name is None\n        if sort is None:\n            expected = expected.sort_values()\n        tm.assert_index_equal(result, expected)\n\n        # __xor__ syntax\n        expected = index1 ^ index2\n        assert tm.equalContents(result, expected)\n        assert result.name is None",
        "begin_line": 1057,
        "end_line": 1072,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_difference_incomparable#1075",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_difference_incomparable(self, opname)",
        "snippet": "    def test_difference_incomparable(self, opname):\n        a = pd.Index([3, pd.Timestamp(\"2000\"), 1])\n        b = pd.Index([2, pd.Timestamp(\"1999\"), 1])\n        op = operator.methodcaller(opname, b)\n\n        # sort=None, the default\n        result = op(a)\n        expected = pd.Index([3, pd.Timestamp(\"2000\"), 2, pd.Timestamp(\"1999\")])\n        if opname == \"difference\":\n            expected = expected[:2]\n        tm.assert_index_equal(result, expected)\n\n        # sort=False\n        op = operator.methodcaller(opname, b, sort=False)\n        result = op(a)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 1075,
        "end_line": 1090,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_difference_incomparable_true#1094",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_difference_incomparable_true(self, opname)",
        "snippet": "    def test_difference_incomparable_true(self, opname):\n        # TODO decide on True behaviour\n        # # sort=True, raises\n        a = pd.Index([3, pd.Timestamp(\"2000\"), 1])\n        b = pd.Index([2, pd.Timestamp(\"1999\"), 1])\n        op = operator.methodcaller(opname, b, sort=True)\n\n        with pytest.raises(TypeError, match=\"Cannot compare\"):\n            op(a)",
        "begin_line": 1094,
        "end_line": 1102,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_symmetric_difference_mi#1104",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_symmetric_difference_mi(self, sort)",
        "snippet": "    def test_symmetric_difference_mi(self, sort):\n        index1 = MultiIndex.from_tuples(zip([\"foo\", \"bar\", \"baz\"], [1, 2, 3]))\n        index2 = MultiIndex.from_tuples([(\"foo\", 1), (\"bar\", 3)])\n        result = index1.symmetric_difference(index2, sort=sort)\n        expected = MultiIndex.from_tuples([(\"bar\", 2), (\"baz\", 3), (\"bar\", 3)])\n        if sort is None:\n            expected = expected.sort_values()\n        tm.assert_index_equal(result, expected)\n        assert tm.equalContents(result, expected)",
        "begin_line": 1104,
        "end_line": 1112,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_symmetric_difference_missing#1121",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_symmetric_difference_missing(self, index2, expected, sort)",
        "snippet": "    def test_symmetric_difference_missing(self, index2, expected, sort):\n        # GH 13514 change: {nan} - {nan} == {}\n        # (GH 6444, sorting of nans, is no longer an issue)\n        index1 = Index([1, np.nan, 2, 3])\n\n        result = index1.symmetric_difference(index2, sort=sort)\n        if sort is None:\n            expected = expected.sort_values()\n        tm.assert_index_equal(result, expected)",
        "begin_line": 1121,
        "end_line": 1129,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_symmetric_difference_non_index#1131",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_symmetric_difference_non_index(self, sort)",
        "snippet": "    def test_symmetric_difference_non_index(self, sort):\n        index1 = Index([1, 2, 3, 4], name=\"index1\")\n        index2 = np.array([2, 3, 4, 5])\n        expected = Index([1, 5])\n        result = index1.symmetric_difference(index2, sort=sort)\n        assert tm.equalContents(result, expected)\n        assert result.name == \"index1\"\n\n        result = index1.symmetric_difference(index2, result_name=\"new_name\", sort=sort)\n        assert tm.equalContents(result, expected)\n        assert result.name == \"new_name\"",
        "begin_line": 1131,
        "end_line": 1141,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_difference_type#1143",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_difference_type(self, indices, sort)",
        "snippet": "    def test_difference_type(self, indices, sort):\n        # GH 20040\n        # If taking difference of a set and itself, it\n        # needs to preserve the type of the index\n        if not indices.is_unique:\n            return\n        result = indices.difference(indices, sort=sort)\n        expected = indices.drop(indices)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 1143,
        "end_line": 1151,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_intersection_difference#1153",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_intersection_difference(self, indices, sort)",
        "snippet": "    def test_intersection_difference(self, indices, sort):\n        # GH 20040\n        # Test that the intersection of an index with an\n        # empty index produces the same index as the difference\n        # of an index with itself.  Test for all types\n        if not indices.is_unique:\n            return\n        inter = indices.intersection(indices.drop(indices))\n        diff = indices.difference(indices, sort=sort)\n        tm.assert_index_equal(inter, diff)",
        "begin_line": 1153,
        "end_line": 1162,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_is_numeric#1176",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_is_numeric(self, index, expected)",
        "snippet": "    def test_is_numeric(self, index, expected):\n        assert index.is_numeric() is expected",
        "begin_line": 1176,
        "end_line": 1177,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_is_object#1191",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_is_object(self, index, expected)",
        "snippet": "    def test_is_object(self, index, expected):\n        assert index.is_object() is expected",
        "begin_line": 1191,
        "end_line": 1192,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_is_all_dates#1206",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_is_all_dates(self, index, expected)",
        "snippet": "    def test_is_all_dates(self, index, expected):\n        assert index.is_all_dates is expected",
        "begin_line": 1206,
        "end_line": 1207,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_summary#1209",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_summary(self, indices)",
        "snippet": "    def test_summary(self, indices):\n        self._check_method_works(Index._summary, indices)",
        "begin_line": 1209,
        "end_line": 1210,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_summary_bug#1212",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_summary_bug(self)",
        "snippet": "    def test_summary_bug(self):\n        # GH3869`\n        ind = Index([\"{other}%s\", \"~:{range}:0\"], name=\"A\")\n        result = ind._summary()\n        # shouldn't be formatted accidentally.\n        assert \"~:{range}:0\" in result\n        assert \"{other}%s\" in result",
        "begin_line": 1212,
        "end_line": 1218,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_format#1220",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_format(self, indices)",
        "snippet": "    def test_format(self, indices):\n        self._check_method_works(Index.format, indices)",
        "begin_line": 1220,
        "end_line": 1221,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_format_bug#1223",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_format_bug(self)",
        "snippet": "    def test_format_bug(self):\n        # GH 14626\n        # windows has different precision on datetime.datetime.now (it doesn't\n        # include us since the default for Timestamp shows these but Index\n        # formatting does not we are skipping)\n        now = datetime.now()\n        if not str(now).endswith(\"000\"):\n            index = Index([now])\n            formatted = index.format()\n            expected = [str(index[0])]\n            assert formatted == expected\n\n        Index([]).format()",
        "begin_line": 1223,
        "end_line": 1235,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_format_missing#1238",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_format_missing(self, vals, nulls_fixture)",
        "snippet": "    def test_format_missing(self, vals, nulls_fixture):\n        # 2845\n        vals = list(vals)  # Copy for each iteration\n        vals.append(nulls_fixture)\n        index = Index(vals)\n\n        formatted = index.format()\n        expected = [str(index[0]), str(index[1]), str(index[2]), \"NaN\"]\n\n        assert formatted == expected\n        assert index[3] is nulls_fixture",
        "begin_line": 1238,
        "end_line": 1248,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_format_with_name_time_info#1250",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_format_with_name_time_info(self)",
        "snippet": "    def test_format_with_name_time_info(self):\n        # bug I fixed 12/20/2011\n        dates = date_range(\"2011-01-01 04:00:00\", periods=10, name=\"something\")\n\n        formatted = dates.format(name=True)\n        assert formatted[0] == \"something\"",
        "begin_line": 1250,
        "end_line": 1255,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_format_datetime_with_time#1257",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_format_datetime_with_time(self)",
        "snippet": "    def test_format_datetime_with_time(self):\n        t = Index([datetime(2012, 2, 7), datetime(2012, 2, 7, 23)])\n\n        result = t.format()\n        expected = [\"2012-02-07 00:00:00\", \"2012-02-07 23:00:00\"]\n        assert len(result) == 2\n        assert result == expected",
        "begin_line": 1257,
        "end_line": 1263,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_logical_compat#1266",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_logical_compat(self, op)",
        "snippet": "    def test_logical_compat(self, op):\n        index = self.create_index()\n        assert getattr(index, op)() == getattr(index.values, op)()",
        "begin_line": 1266,
        "end_line": 1268,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex._check_method_works#1270",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex._check_method_works(self, method, index)",
        "snippet": "    def _check_method_works(self, method, index):\n        method(index)",
        "begin_line": 1270,
        "end_line": 1271,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_get_indexer#1273",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_get_indexer(self)",
        "snippet": "    def test_get_indexer(self):\n        index1 = Index([1, 2, 3, 4, 5])\n        index2 = Index([2, 4, 6])\n\n        r1 = index1.get_indexer(index2)\n        e1 = np.array([1, 3, -1], dtype=np.intp)\n        tm.assert_almost_equal(r1, e1)",
        "begin_line": 1273,
        "end_line": 1279,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_get_indexer_methods#1291",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_get_indexer_methods(self, reverse, expected, method)",
        "snippet": "    def test_get_indexer_methods(self, reverse, expected, method):\n        index1 = Index([1, 2, 3, 4, 5])\n        index2 = Index([2, 4, 6])\n\n        if reverse:\n            index1 = index1[::-1]\n            expected = expected[::-1]\n\n        result = index2.get_indexer(index1, method=method)\n        tm.assert_almost_equal(result, expected)",
        "begin_line": 1291,
        "end_line": 1300,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_get_indexer_invalid#1302",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_get_indexer_invalid(self)",
        "snippet": "    def test_get_indexer_invalid(self):\n        # GH10411\n        index = Index(np.arange(10))\n\n        with pytest.raises(ValueError, match=\"tolerance argument\"):\n            index.get_indexer([1, 0], tolerance=1)\n\n        with pytest.raises(ValueError, match=\"limit argument\"):\n            index.get_indexer([1, 0], limit=1)",
        "begin_line": 1302,
        "end_line": 1310,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_get_indexer_nearest#1332",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_get_indexer_nearest(self, method, tolerance, indexer, expected)",
        "snippet": "    def test_get_indexer_nearest(self, method, tolerance, indexer, expected):\n        index = Index(np.arange(10))\n\n        actual = index.get_indexer(indexer, method=method, tolerance=tolerance)\n        tm.assert_numpy_array_equal(actual, np.array(expected, dtype=np.intp))",
        "begin_line": 1332,
        "end_line": 1336,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_get_indexer_nearest_listlike_tolerance#1348",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_get_indexer_nearest_listlike_tolerance(self, tolerance, expected, listtype)",
        "snippet": "    def test_get_indexer_nearest_listlike_tolerance(\n        self, tolerance, expected, listtype\n    ):\n        index = Index(np.arange(10))\n\n        actual = index.get_indexer(\n            [0.2, 1.8, 8.5], method=\"nearest\", tolerance=listtype(tolerance)\n        )\n        tm.assert_numpy_array_equal(actual, np.array(expected, dtype=np.intp))",
        "begin_line": 1348,
        "end_line": 1356,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_get_indexer_nearest_error#1358",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_get_indexer_nearest_error(self)",
        "snippet": "    def test_get_indexer_nearest_error(self):\n        index = Index(np.arange(10))\n        with pytest.raises(ValueError, match=\"limit argument\"):\n            index.get_indexer([1, 0], method=\"nearest\", limit=1)\n\n        with pytest.raises(ValueError, match=\"tolerance size must match\"):\n            index.get_indexer([1, 0], method=\"nearest\", tolerance=[1, 2, 3])",
        "begin_line": 1358,
        "end_line": 1364,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_get_indexer_nearest_decreasing#1370",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_get_indexer_nearest_decreasing(self, method, expected)",
        "snippet": "    def test_get_indexer_nearest_decreasing(self, method, expected):\n        index = Index(np.arange(10))[::-1]\n\n        actual = index.get_indexer([0, 5, 9], method=method)\n        tm.assert_numpy_array_equal(actual, np.array([9, 4, 0], dtype=np.intp))\n\n        actual = index.get_indexer([0.2, 1.8, 8.5], method=method)\n        tm.assert_numpy_array_equal(actual, np.array(expected, dtype=np.intp))",
        "begin_line": 1370,
        "end_line": 1377,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_get_indexer_strings#1386",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_get_indexer_strings(self, method, expected)",
        "snippet": "    def test_get_indexer_strings(self, method, expected):\n        index = pd.Index([\"b\", \"c\"])\n        actual = index.get_indexer([\"a\", \"b\", \"c\", \"d\"], method=method)\n\n        tm.assert_numpy_array_equal(actual, expected)",
        "begin_line": 1386,
        "end_line": 1390,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_get_indexer_strings_raises#1392",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_get_indexer_strings_raises(self)",
        "snippet": "    def test_get_indexer_strings_raises(self):\n        index = pd.Index([\"b\", \"c\"])\n\n        msg = r\"unsupported operand type\\(s\\) for -: 'str' and 'str'\"\n        with pytest.raises(TypeError, match=msg):\n            index.get_indexer([\"a\", \"b\", \"c\", \"d\"], method=\"nearest\")\n\n        with pytest.raises(TypeError, match=msg):\n            index.get_indexer([\"a\", \"b\", \"c\", \"d\"], method=\"pad\", tolerance=2)\n\n        with pytest.raises(TypeError, match=msg):\n            index.get_indexer(\n                [\"a\", \"b\", \"c\", \"d\"], method=\"pad\", tolerance=[2, 2, 2, 2]\n            )",
        "begin_line": 1392,
        "end_line": 1405,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_get_indexer_numeric_index_boolean_target#1408",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_get_indexer_numeric_index_boolean_target(self, idx_class)",
        "snippet": "    def test_get_indexer_numeric_index_boolean_target(self, idx_class):\n        # GH 16877\n\n        numeric_index = idx_class(RangeIndex((4)))\n        result = numeric_index.get_indexer([True, False, True])\n        expected = np.array([-1, -1, -1], dtype=np.intp)\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 1408,
        "end_line": 1414,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_get_indexer_with_NA_values#1416",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_get_indexer_with_NA_values(self, unique_nulls_fixture, unique_nulls_fixture2)",
        "snippet": "    def test_get_indexer_with_NA_values(\n        self, unique_nulls_fixture, unique_nulls_fixture2\n    ):\n        # GH 22332\n        # check pairwise, that no pair of na values\n        # is mangled\n        if unique_nulls_fixture is unique_nulls_fixture2:\n            return  # skip it, values are not unique\n        arr = np.array([unique_nulls_fixture, unique_nulls_fixture2], dtype=np.object)\n        index = pd.Index(arr, dtype=np.object)\n        result = index.get_indexer(\n            [unique_nulls_fixture, unique_nulls_fixture2, \"Unknown\"]\n        )\n        expected = np.array([0, 1, -1], dtype=np.intp)\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 1416,
        "end_line": 1430,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_get_loc#1433",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_get_loc(self, method)",
        "snippet": "    def test_get_loc(self, method):\n        index = pd.Index([0, 1, 2])\n        assert index.get_loc(1, method=method) == 1\n\n        if method:\n            assert index.get_loc(1, method=method, tolerance=0) == 1",
        "begin_line": 1433,
        "end_line": 1438,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_get_loc_raises_bad_label#1441",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_get_loc_raises_bad_label(self, method)",
        "snippet": "    def test_get_loc_raises_bad_label(self, method):\n        index = pd.Index([0, 1, 2])\n        if method:\n            msg = \"not supported between\"\n        else:\n            msg = \"invalid key\"\n\n        with pytest.raises(TypeError, match=msg):\n            index.get_loc([1, 2], method=method)",
        "begin_line": 1441,
        "end_line": 1449,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_get_loc_tolerance#1454",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_get_loc_tolerance(self, method, loc)",
        "snippet": "    def test_get_loc_tolerance(self, method, loc):\n        index = pd.Index([0, 1, 2])\n        assert index.get_loc(1.1, method) == loc\n        assert index.get_loc(1.1, method, tolerance=1) == loc",
        "begin_line": 1454,
        "end_line": 1457,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_get_loc_outside_tolerance_raises#1460",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_get_loc_outside_tolerance_raises(self, method)",
        "snippet": "    def test_get_loc_outside_tolerance_raises(self, method):\n        index = pd.Index([0, 1, 2])\n        with pytest.raises(KeyError, match=\"1.1\"):\n            index.get_loc(1.1, method, tolerance=0.05)",
        "begin_line": 1460,
        "end_line": 1463,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_get_loc_bad_tolerance_raises#1465",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_get_loc_bad_tolerance_raises(self)",
        "snippet": "    def test_get_loc_bad_tolerance_raises(self):\n        index = pd.Index([0, 1, 2])\n        with pytest.raises(ValueError, match=\"must be numeric\"):\n            index.get_loc(1.1, \"nearest\", tolerance=\"invalid\")",
        "begin_line": 1465,
        "end_line": 1468,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_get_loc_tolerance_no_method_raises#1470",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_get_loc_tolerance_no_method_raises(self)",
        "snippet": "    def test_get_loc_tolerance_no_method_raises(self):\n        index = pd.Index([0, 1, 2])\n        with pytest.raises(ValueError, match=\"tolerance .* valid if\"):\n            index.get_loc(1.1, tolerance=1)",
        "begin_line": 1470,
        "end_line": 1473,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_get_loc_raises_missized_tolerance#1475",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_get_loc_raises_missized_tolerance(self)",
        "snippet": "    def test_get_loc_raises_missized_tolerance(self):\n        index = pd.Index([0, 1, 2])\n        with pytest.raises(ValueError, match=\"tolerance size must match\"):\n            index.get_loc(1.1, \"nearest\", tolerance=[1, 1])",
        "begin_line": 1475,
        "end_line": 1478,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_get_loc_raises_object_nearest#1480",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_get_loc_raises_object_nearest(self)",
        "snippet": "    def test_get_loc_raises_object_nearest(self):\n        index = pd.Index([\"a\", \"c\"])\n        with pytest.raises(TypeError, match=\"unsupported operand type\"):\n            index.get_loc(\"a\", method=\"nearest\")",
        "begin_line": 1480,
        "end_line": 1483,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_get_loc_raises_object_tolerance#1485",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_get_loc_raises_object_tolerance(self)",
        "snippet": "    def test_get_loc_raises_object_tolerance(self):\n        index = pd.Index([\"a\", \"c\"])\n        with pytest.raises(TypeError, match=\"unsupported operand type\"):\n            index.get_loc(\"a\", method=\"pad\", tolerance=\"invalid\")",
        "begin_line": 1485,
        "end_line": 1488,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_slice_locs#1491",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_slice_locs(self, dtype)",
        "snippet": "    def test_slice_locs(self, dtype):\n        index = Index(np.array([0, 1, 2, 5, 6, 7, 9, 10], dtype=dtype))\n        n = len(index)\n\n        assert index.slice_locs(start=2) == (2, n)\n        assert index.slice_locs(start=3) == (3, n)\n        assert index.slice_locs(3, 8) == (3, 6)\n        assert index.slice_locs(5, 10) == (3, n)\n        assert index.slice_locs(end=8) == (0, 6)\n        assert index.slice_locs(end=9) == (0, 7)\n\n        # reversed\n        index2 = index[::-1]\n        assert index2.slice_locs(8, 2) == (2, 6)\n        assert index2.slice_locs(7, 3) == (2, 5)",
        "begin_line": 1491,
        "end_line": 1505,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_slice_float_locs#1508",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_slice_float_locs(self, dtype)",
        "snippet": "    def test_slice_float_locs(self, dtype):\n        index = Index(np.array([0, 1, 2, 5, 6, 7, 9, 10], dtype=dtype))\n        n = len(index)\n        assert index.slice_locs(5.0, 10.0) == (3, n)\n        assert index.slice_locs(4.5, 10.5) == (3, 8)\n\n        index2 = index[::-1]\n        assert index2.slice_locs(8.5, 1.5) == (2, 6)\n        assert index2.slice_locs(10.5, -1) == (0, n)",
        "begin_line": 1508,
        "end_line": 1516,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_slice_locs_dup#1518",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_slice_locs_dup(self)",
        "snippet": "    def test_slice_locs_dup(self):\n        index = Index([\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"])\n        assert index.slice_locs(\"a\", \"d\") == (0, 6)\n        assert index.slice_locs(end=\"d\") == (0, 6)\n        assert index.slice_locs(\"a\", \"c\") == (0, 4)\n        assert index.slice_locs(\"b\", \"d\") == (2, 6)\n\n        index2 = index[::-1]\n        assert index2.slice_locs(\"d\", \"a\") == (0, 6)\n        assert index2.slice_locs(end=\"a\") == (0, 6)\n        assert index2.slice_locs(\"d\", \"b\") == (0, 4)\n        assert index2.slice_locs(\"c\", \"a\") == (2, 6)",
        "begin_line": 1518,
        "end_line": 1529,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_slice_locs_dup_numeric#1532",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_slice_locs_dup_numeric(self, dtype)",
        "snippet": "    def test_slice_locs_dup_numeric(self, dtype):\n        index = Index(np.array([10, 12, 12, 14], dtype=dtype))\n        assert index.slice_locs(12, 12) == (1, 3)\n        assert index.slice_locs(11, 13) == (1, 3)\n\n        index2 = index[::-1]\n        assert index2.slice_locs(12, 12) == (1, 3)\n        assert index2.slice_locs(13, 11) == (1, 3)",
        "begin_line": 1532,
        "end_line": 1539,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_slice_locs_na#1541",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_slice_locs_na(self)",
        "snippet": "    def test_slice_locs_na(self):\n        index = Index([np.nan, 1, 2])\n        assert index.slice_locs(1) == (1, 3)\n        assert index.slice_locs(np.nan) == (0, 3)\n\n        index = Index([0, np.nan, np.nan, 1, 2])\n        assert index.slice_locs(np.nan) == (1, 5)",
        "begin_line": 1541,
        "end_line": 1547,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_slice_locs_na_raises#1549",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_slice_locs_na_raises(self)",
        "snippet": "    def test_slice_locs_na_raises(self):\n        index = Index([np.nan, 1, 2])\n        with pytest.raises(KeyError, match=\"\"):\n            index.slice_locs(start=1.5)\n\n        with pytest.raises(KeyError, match=\"\"):\n            index.slice_locs(end=1.5)",
        "begin_line": 1549,
        "end_line": 1555,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_slice_locs_negative_step#1579",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_slice_locs_negative_step(self, in_slice, expected)",
        "snippet": "    def test_slice_locs_negative_step(self, in_slice, expected):\n        index = Index(list(\"bcdxy\"))\n\n        s_start, s_stop = index.slice_locs(in_slice.start, in_slice.stop, in_slice.step)\n        result = index[s_start : s_stop : in_slice.step]\n        expected = pd.Index(list(expected))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 1579,
        "end_line": 1585,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_drop_by_str_label#1588",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_drop_by_str_label(self, index)",
        "snippet": "    def test_drop_by_str_label(self, index):\n        n = len(index)\n        drop = index[list(range(5, 10))]\n        dropped = index.drop(drop)\n\n        expected = index[list(range(5)) + list(range(10, n))]\n        tm.assert_index_equal(dropped, expected)\n\n        dropped = index.drop(index[0])\n        expected = index[1:]\n        tm.assert_index_equal(dropped, expected)",
        "begin_line": 1588,
        "end_line": 1598,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_drop_by_str_label_raises_missing_keys#1602",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_drop_by_str_label_raises_missing_keys(self, index, keys)",
        "snippet": "    def test_drop_by_str_label_raises_missing_keys(self, index, keys):\n        with pytest.raises(KeyError, match=\"\"):\n            index.drop(keys)",
        "begin_line": 1602,
        "end_line": 1604,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_drop_by_str_label_errors_ignore#1607",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_drop_by_str_label_errors_ignore(self, index)",
        "snippet": "    def test_drop_by_str_label_errors_ignore(self, index):\n        n = len(index)\n        drop = index[list(range(5, 10))]\n        mixed = drop.tolist() + [\"foo\"]\n        dropped = index.drop(mixed, errors=\"ignore\")\n\n        expected = index[list(range(5)) + list(range(10, n))]\n        tm.assert_index_equal(dropped, expected)\n\n        dropped = index.drop([\"foo\", \"bar\"], errors=\"ignore\")\n        expected = index[list(range(n))]\n        tm.assert_index_equal(dropped, expected)",
        "begin_line": 1607,
        "end_line": 1618,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_drop_by_numeric_label_loc#1620",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_drop_by_numeric_label_loc(self)",
        "snippet": "    def test_drop_by_numeric_label_loc(self):\n        # TODO: Parametrize numeric and str tests after self.strIndex fixture\n        index = Index([1, 2, 3])\n        dropped = index.drop(1)\n        expected = Index([2, 3])\n\n        tm.assert_index_equal(dropped, expected)",
        "begin_line": 1620,
        "end_line": 1626,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_drop_by_numeric_label_raises_missing_keys#1628",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_drop_by_numeric_label_raises_missing_keys(self)",
        "snippet": "    def test_drop_by_numeric_label_raises_missing_keys(self):\n        index = Index([1, 2, 3])\n        with pytest.raises(KeyError, match=\"\"):\n            index.drop([3, 4])",
        "begin_line": 1628,
        "end_line": 1631,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_drop_by_numeric_label_errors_ignore#1636",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_drop_by_numeric_label_errors_ignore(self, key, expected)",
        "snippet": "    def test_drop_by_numeric_label_errors_ignore(self, key, expected):\n        index = Index([1, 2, 3])\n        dropped = index.drop(key, errors=\"ignore\")\n\n        tm.assert_index_equal(dropped, expected)",
        "begin_line": 1636,
        "end_line": 1640,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_drop_tuple#1647",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_drop_tuple(self, values, to_drop)",
        "snippet": "    def test_drop_tuple(self, values, to_drop):\n        # GH 18304\n        index = pd.Index(values)\n        expected = pd.Index([\"b\"])\n\n        result = index.drop(to_drop)\n        tm.assert_index_equal(result, expected)\n\n        removed = index.drop(to_drop[0])\n        for drop_me in to_drop[1], [to_drop[1]]:\n            result = removed.drop(drop_me)\n            tm.assert_index_equal(result, expected)\n\n        removed = index.drop(to_drop[1])\n        msg = fr\"\\\"\\[{re.escape(to_drop[1].__repr__())}\\] not found in axis\\\"\"\n        for drop_me in to_drop[1], [to_drop[1]]:\n            with pytest.raises(KeyError, match=msg):\n                removed.drop(drop_me)",
        "begin_line": 1647,
        "end_line": 1664,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_tuple_union_bug#1695",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_tuple_union_bug(self, method, expected, sort)",
        "snippet": "    def test_tuple_union_bug(self, method, expected, sort):\n        index1 = Index(\n            np.array(\n                [(1, \"A\"), (2, \"A\"), (1, \"B\"), (2, \"B\")],\n                dtype=[(\"num\", int), (\"let\", \"a1\")],\n            )\n        )\n        index2 = Index(\n            np.array(\n                [(1, \"A\"), (2, \"A\"), (1, \"B\"), (2, \"B\"), (1, \"C\"), (2, \"C\")],\n                dtype=[(\"num\", int), (\"let\", \"a1\")],\n            )\n        )\n\n        result = getattr(index1, method)(index2, sort=sort)\n        assert result.ndim == 1\n\n        expected = Index(expected)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 1695,
        "end_line": 1713,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_is_monotonic_incomparable#1724",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_is_monotonic_incomparable(self, attr)",
        "snippet": "    def test_is_monotonic_incomparable(self, attr):\n        index = Index([5, datetime.now(), 7])\n        assert not getattr(index, attr)",
        "begin_line": 1724,
        "end_line": 1726,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_set_value_deprecated#1728",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_set_value_deprecated(self)",
        "snippet": "    def test_set_value_deprecated(self):\n        # GH 28621\n        idx = self.create_index()\n        arr = np.array([1, 2, 3])\n        with tm.assert_produces_warning(FutureWarning):\n            idx.set_value(arr, idx[1], 80)\n        assert arr[1] == 80",
        "begin_line": 1728,
        "end_line": 1734,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_get_value#1739",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_get_value(self, index)",
        "snippet": "    def test_get_value(self, index):\n        # TODO: Remove function? GH 19728\n        values = np.random.randn(100)\n        value = index[67]\n\n        with pytest.raises(AttributeError, match=\"has no attribute '_values'\"):\n            # Index.get_value requires a Series, not an ndarray\n            index.get_value(values, value)\n\n        result = index.get_value(Series(values, index=values), value)\n        tm.assert_almost_equal(result, values[67])",
        "begin_line": 1739,
        "end_line": 1749,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_isin#1759",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_isin(self, values, index, expected)",
        "snippet": "    def test_isin(self, values, index, expected):\n        result = index.isin(values)\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 1759,
        "end_line": 1761,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_isin_nan_common_object#1763",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_isin_nan_common_object(self, nulls_fixture, nulls_fixture2)",
        "snippet": "    def test_isin_nan_common_object(self, nulls_fixture, nulls_fixture2):\n        # Test cartesian product of null fixtures and ensure that we don't\n        # mangle the various types (save a corner case with PyPy)\n\n        # all nans are the same\n        if (\n            isinstance(nulls_fixture, float)\n            and isinstance(nulls_fixture2, float)\n            and math.isnan(nulls_fixture)\n            and math.isnan(nulls_fixture2)\n        ):\n            tm.assert_numpy_array_equal(\n                Index([\"a\", nulls_fixture]).isin([nulls_fixture2]),\n                np.array([False, True]),\n            )\n\n        elif nulls_fixture is nulls_fixture2:  # should preserve NA type\n            tm.assert_numpy_array_equal(\n                Index([\"a\", nulls_fixture]).isin([nulls_fixture2]),\n                np.array([False, True]),\n            )\n\n        else:\n            tm.assert_numpy_array_equal(\n                Index([\"a\", nulls_fixture]).isin([nulls_fixture2]),\n                np.array([False, False]),\n            )",
        "begin_line": 1763,
        "end_line": 1789,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_isin_nan_common_float64#1791",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_isin_nan_common_float64(self, nulls_fixture)",
        "snippet": "    def test_isin_nan_common_float64(self, nulls_fixture):\n        if nulls_fixture is pd.NaT:\n            pytest.skip(\"pd.NaT not compatible with Float64Index\")\n\n        # Float64Index overrides isin, so must be checked separately\n        if nulls_fixture is pd.NA:\n            pytest.xfail(\"Float64Index cannot contain pd.NA\")\n\n        tm.assert_numpy_array_equal(\n            Float64Index([1.0, nulls_fixture]).isin([np.nan]), np.array([False, True])\n        )\n\n        # we cannot compare NaT with NaN\n        tm.assert_numpy_array_equal(\n            Float64Index([1.0, nulls_fixture]).isin([pd.NaT]), np.array([False, False])\n        )",
        "begin_line": 1791,
        "end_line": 1806,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_isin_level_kwarg#1817",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_isin_level_kwarg(self, level, index)",
        "snippet": "    def test_isin_level_kwarg(self, level, index):\n        values = index.tolist()[-2:] + [\"nonexisting\"]\n\n        expected = np.array([False, False, True, True])\n        tm.assert_numpy_array_equal(expected, index.isin(values, level=level))\n\n        index.name = \"foobar\"\n        tm.assert_numpy_array_equal(expected, index.isin(values, level=\"foobar\"))",
        "begin_line": 1817,
        "end_line": 1824,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_isin_level_kwarg_bad_level_raises#1827",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_isin_level_kwarg_bad_level_raises(self, level, indices)",
        "snippet": "    def test_isin_level_kwarg_bad_level_raises(self, level, indices):\n        index = indices\n        with pytest.raises(IndexError, match=\"Too many levels\"):\n            index.isin([], level=level)",
        "begin_line": 1827,
        "end_line": 1830,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_isin_level_kwarg_bad_label_raises#1833",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_isin_level_kwarg_bad_label_raises(self, label, indices)",
        "snippet": "    def test_isin_level_kwarg_bad_label_raises(self, label, indices):\n        index = indices\n        if isinstance(index, MultiIndex):\n            index = index.rename([\"foo\", \"bar\"])\n            msg = f\"'Level {label} not found'\"\n        else:\n            index = index.rename(\"foo\")\n            msg = fr\"Requested level \\({label}\\) does not match index name \\(foo\\)\"\n        with pytest.raises(KeyError, match=msg):\n            index.isin([], level=label)",
        "begin_line": 1833,
        "end_line": 1842,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_isin_empty#1845",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_isin_empty(self, empty)",
        "snippet": "    def test_isin_empty(self, empty):\n        # see gh-16991\n        index = Index([\"a\", \"b\"])\n        expected = np.array([False, False])\n\n        result = index.isin(empty)\n        tm.assert_numpy_array_equal(expected, result)",
        "begin_line": 1845,
        "end_line": 1851,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_boolean_cmp#1863",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_boolean_cmp(self, values)",
        "snippet": "    def test_boolean_cmp(self, values):\n        index = Index(values)\n        result = index == values\n        expected = np.array([True, True, True, True], dtype=bool)\n\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 1863,
        "end_line": 1868,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_get_level_values#1871",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_get_level_values(self, index, name, level)",
        "snippet": "    def test_get_level_values(self, index, name, level):\n        expected = index.copy()\n        if name:\n            expected.name = name\n\n        result = expected.get_level_values(level)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 1871,
        "end_line": 1877,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_slice_keep_name#1879",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_slice_keep_name(self)",
        "snippet": "    def test_slice_keep_name(self):\n        index = Index([\"a\", \"b\"], name=\"asdf\")\n        assert index.name == index[1:].name",
        "begin_line": 1879,
        "end_line": 1881,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_join_self#1888",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_join_self(self, index, join_type)",
        "snippet": "    def test_join_self(self, index, join_type):\n        joined = index.join(index, how=join_type)\n        assert index is joined",
        "begin_line": 1888,
        "end_line": 1890,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_str_attribute#1893",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_str_attribute(self, method)",
        "snippet": "    def test_str_attribute(self, method):\n        # GH9068\n        index = Index([\" jack\", \"jill \", \" jesse \", \"frank\"])\n        expected = Index([getattr(str, method)(x) for x in index.values])\n\n        result = getattr(index.str, method)()\n        tm.assert_index_equal(result, expected)",
        "begin_line": 1893,
        "end_line": 1899,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_str_attribute_raises#1910",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_str_attribute_raises(self, index)",
        "snippet": "    def test_str_attribute_raises(self, index):\n        with pytest.raises(AttributeError, match=\"only use .str accessor\"):\n            index.str.repeat(2)",
        "begin_line": 1910,
        "end_line": 1912,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_str_split#1927",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_str_split(self, expand, expected)",
        "snippet": "    def test_str_split(self, expand, expected):\n        index = Index([\"a b c\", \"d e\", \"f\"])\n        if expand is not None:\n            result = index.str.split(expand=expand)\n        else:\n            result = index.str.split()\n\n        tm.assert_index_equal(result, expected)",
        "begin_line": 1927,
        "end_line": 1934,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_str_bool_return#1936",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_str_bool_return(self)",
        "snippet": "    def test_str_bool_return(self):\n        # test boolean case, should return np.array instead of boolean Index\n        index = Index([\"a1\", \"a2\", \"b1\", \"b2\"])\n        result = index.str.startswith(\"a\")\n        expected = np.array([True, True, False, False])\n\n        tm.assert_numpy_array_equal(result, expected)\n        assert isinstance(result, np.ndarray)",
        "begin_line": 1936,
        "end_line": 1943,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_str_bool_series_indexing#1945",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_str_bool_series_indexing(self)",
        "snippet": "    def test_str_bool_series_indexing(self):\n        index = Index([\"a1\", \"a2\", \"b1\", \"b2\"])\n        s = Series(range(4), index=index)\n\n        result = s[s.index.str.startswith(\"a\")]\n        expected = Series(range(2), index=[\"a1\", \"a2\"])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1945,
        "end_line": 1951,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_tab_completion#1956",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_tab_completion(self, index, expected)",
        "snippet": "    def test_tab_completion(self, index, expected):\n        # GH 9910\n        result = \"str\" in dir(index)\n        assert result == expected",
        "begin_line": 1956,
        "end_line": 1959,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_indexing_doesnt_change_class#1961",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_indexing_doesnt_change_class(self)",
        "snippet": "    def test_indexing_doesnt_change_class(self):\n        index = Index([1, 2, 3, \"a\", \"b\", \"c\"])\n\n        assert index[1:3].identical(pd.Index([2, 3], dtype=np.object_))\n        assert index[[0, 1]].identical(pd.Index([1, 2], dtype=np.object_))",
        "begin_line": 1961,
        "end_line": 1965,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_outer_join_sort#1967",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_outer_join_sort(self)",
        "snippet": "    def test_outer_join_sort(self):\n        left_index = Index(np.random.permutation(15))\n        right_index = tm.makeDateIndex(10)\n\n        with tm.assert_produces_warning(RuntimeWarning):\n            result = left_index.join(right_index, how=\"outer\")\n\n        # right_index in this case because DatetimeIndex has join precedence\n        # over Int64Index\n        with tm.assert_produces_warning(RuntimeWarning):\n            expected = right_index.astype(object).union(left_index.astype(object))\n\n        tm.assert_index_equal(result, expected)",
        "begin_line": 1967,
        "end_line": 1979,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_nan_first_take_datetime#1981",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_nan_first_take_datetime(self)",
        "snippet": "    def test_nan_first_take_datetime(self):\n        index = Index([pd.NaT, Timestamp(\"20130101\"), Timestamp(\"20130102\")])\n        result = index.take([-1, 0, 1])\n        expected = Index([index[-1], index[0], index[1]])\n        tm.assert_index_equal(result, expected)",
        "begin_line": 1981,
        "end_line": 1985,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_take_fill_value#1987",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_take_fill_value(self)",
        "snippet": "    def test_take_fill_value(self):\n        # GH 12631\n        index = pd.Index(list(\"ABC\"), name=\"xxx\")\n        result = index.take(np.array([1, 0, -1]))\n        expected = pd.Index(list(\"BAC\"), name=\"xxx\")\n        tm.assert_index_equal(result, expected)\n\n        # fill_value\n        result = index.take(np.array([1, 0, -1]), fill_value=True)\n        expected = pd.Index([\"B\", \"A\", np.nan], name=\"xxx\")\n        tm.assert_index_equal(result, expected)\n\n        # allow_fill=False\n        result = index.take(np.array([1, 0, -1]), allow_fill=False, fill_value=True)\n        expected = pd.Index([\"B\", \"A\", \"C\"], name=\"xxx\")\n        tm.assert_index_equal(result, expected)",
        "begin_line": 1987,
        "end_line": 2002,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_take_fill_value_none_raises#2004",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_take_fill_value_none_raises(self)",
        "snippet": "    def test_take_fill_value_none_raises(self):\n        index = pd.Index(list(\"ABC\"), name=\"xxx\")\n        msg = (\n            \"When allow_fill=True and fill_value is not None, \"\n            \"all indices must be >= -1\"\n        )\n\n        with pytest.raises(ValueError, match=msg):\n            index.take(np.array([1, 0, -2]), fill_value=True)\n        with pytest.raises(ValueError, match=msg):\n            index.take(np.array([1, 0, -5]), fill_value=True)",
        "begin_line": 2004,
        "end_line": 2014,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_take_bad_bounds_raises#2016",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_take_bad_bounds_raises(self)",
        "snippet": "    def test_take_bad_bounds_raises(self):\n        index = pd.Index(list(\"ABC\"), name=\"xxx\")\n        with pytest.raises(IndexError, match=\"out of bounds\"):\n            index.take(np.array([1, -5]))",
        "begin_line": 2016,
        "end_line": 2019,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_reindex_preserves_name_if_target_is_list_or_ndarray#2036",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_reindex_preserves_name_if_target_is_list_or_ndarray(self, name, labels)",
        "snippet": "    def test_reindex_preserves_name_if_target_is_list_or_ndarray(self, name, labels):\n        # GH6552\n        index = pd.Index([0, 1, 2])\n        index.name = name\n        assert index.reindex(labels)[0].name == name",
        "begin_line": 2036,
        "end_line": 2040,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_reindex_preserves_type_if_target_is_empty_list_or_array#2043",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_reindex_preserves_type_if_target_is_empty_list_or_array(self, labels)",
        "snippet": "    def test_reindex_preserves_type_if_target_is_empty_list_or_array(self, labels):\n        # GH7774\n        index = pd.Index(list(\"abc\"))\n        assert index.reindex(labels)[0].dtype.type == np.object_",
        "begin_line": 2043,
        "end_line": 2046,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_reindex_doesnt_preserve_type_if_target_is_empty_index#2056",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_reindex_doesnt_preserve_type_if_target_is_empty_index(self, labels, dtype)",
        "snippet": "    def test_reindex_doesnt_preserve_type_if_target_is_empty_index(self, labels, dtype):\n        # GH7774\n        index = pd.Index(list(\"abc\"))\n        assert index.reindex(labels)[0].dtype.type == dtype",
        "begin_line": 2056,
        "end_line": 2059,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_reindex_no_type_preserve_target_empty_mi#2061",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_reindex_no_type_preserve_target_empty_mi(self)",
        "snippet": "    def test_reindex_no_type_preserve_target_empty_mi(self):\n        index = pd.Index(list(\"abc\"))\n        result = index.reindex(\n            pd.MultiIndex([pd.Int64Index([]), pd.Float64Index([])], [[], []])\n        )[0]\n        assert result.levels[0].dtype.type == np.int64\n        assert result.levels[1].dtype.type == np.float64",
        "begin_line": 2061,
        "end_line": 2067,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_groupby#2069",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_groupby(self)",
        "snippet": "    def test_groupby(self):\n        index = Index(range(5))\n        result = index.groupby(np.array([1, 1, 2, 2, 2]))\n        expected = {1: pd.Index([0, 1]), 2: pd.Index([2, 3, 4])}\n\n        tm.assert_dict_equal(result, expected)",
        "begin_line": 2069,
        "end_line": 2074,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_equals_op_multiindex#2083",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_equals_op_multiindex(self, mi, expected)",
        "snippet": "    def test_equals_op_multiindex(self, mi, expected):\n        # GH9785\n        # test comparisons of multiindex\n        df = pd.read_csv(StringIO(\"a,b,c\\n1,2,3\\n4,5,6\"), index_col=[0, 1])\n\n        result = df.index == mi\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 2083,
        "end_line": 2089,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_equals_op_multiindex_identify#2091",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_equals_op_multiindex_identify(self)",
        "snippet": "    def test_equals_op_multiindex_identify(self):\n        df = pd.read_csv(StringIO(\"a,b,c\\n1,2,3\\n4,5,6\"), index_col=[0, 1])\n\n        result = df.index == df.index\n        expected = np.array([True, True])\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 2091,
        "end_line": 2096,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_equals_op_mismatched_multiindex_raises#2105",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_equals_op_mismatched_multiindex_raises(self, index)",
        "snippet": "    def test_equals_op_mismatched_multiindex_raises(self, index):\n        df = pd.read_csv(StringIO(\"a,b,c\\n1,2,3\\n4,5,6\"), index_col=[0, 1])\n\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            df.index == index",
        "begin_line": 2105,
        "end_line": 2109,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_equals_op_index_vs_mi_same_length#2111",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_equals_op_index_vs_mi_same_length(self)",
        "snippet": "    def test_equals_op_index_vs_mi_same_length(self):\n        mi = MultiIndex.from_tuples([(1, 2), (4, 5), (8, 9)])\n        index = Index([\"foo\", \"bar\", \"baz\"])\n\n        result = mi == index\n        expected = np.array([False, False, False])\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 2111,
        "end_line": 2117,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_dt_conversion_preserves_name#2120",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_dt_conversion_preserves_name(self, dt_conv)",
        "snippet": "    def test_dt_conversion_preserves_name(self, dt_conv):\n        # GH 10875\n        index = pd.Index([\"01:02:03\", \"01:02:04\"], name=\"label\")\n        assert index.name == dt_conv(index).name",
        "begin_line": 2120,
        "end_line": 2123,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_string_index_repr#2185",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_string_index_repr(self, index, expected)",
        "snippet": "    def test_string_index_repr(self, index, expected):\n        result = repr(index)\n        assert result == expected",
        "begin_line": 2185,
        "end_line": 2187,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_string_index_repr_with_unicode_option#2228",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_string_index_repr_with_unicode_option(self, index, expected)",
        "snippet": "    def test_string_index_repr_with_unicode_option(self, index, expected):\n        # Enable Unicode option -----------------------------------------\n        with cf.option_context(\"display.unicode.east_asian_width\", True):\n            result = repr(index)\n            assert result == expected",
        "begin_line": 2228,
        "end_line": 2232,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_cached_properties_not_settable#2234",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_cached_properties_not_settable(self)",
        "snippet": "    def test_cached_properties_not_settable(self):\n        index = pd.Index([1, 2, 3])\n        with pytest.raises(AttributeError, match=\"Can't set attribute\"):\n            index.is_unique = False",
        "begin_line": 2234,
        "end_line": 2237,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_tab_complete_warning#2240",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_tab_complete_warning(self, ip)",
        "snippet": "    async def test_tab_complete_warning(self, ip):\n        # https://github.com/pandas-dev/pandas/issues/16409\n        pytest.importorskip(\"IPython\", minversion=\"6.0.0\")\n        from IPython.core.completer import provisionalcompleter\n\n        code = \"import pandas as pd; idx = pd.Index([1, 2])\"\n        await ip.run_code(code)\n\n        # GH 31324 newer jedi version raises Deprecation warning\n        import jedi\n\n        if jedi.__version__ < \"0.16.0\":\n            warning = tm.assert_produces_warning(None)\n        else:\n            warning = tm.assert_produces_warning(\n                DeprecationWarning, check_stacklevel=False\n            )\n        with warning:\n            with provisionalcompleter(\"ignore\"):\n                list(ip.Completer.completions(\"idx.\", 4))",
        "begin_line": 2240,
        "end_line": 2259,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndex.test_contains_method_removed#2261",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndex",
        "signature": "pandas.tests.indexes.test_base.TestIndex.test_contains_method_removed(self, indices)",
        "snippet": "    def test_contains_method_removed(self, indices):\n        # GH#30103 method removed for all types except IntervalIndex\n        if isinstance(indices, pd.IntervalIndex):\n            indices.contains(1)\n        else:\n            with pytest.raises(AttributeError):\n                indices.contains(1)",
        "begin_line": 2261,
        "end_line": 2267,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestMixedIntIndex.indices#2277",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestMixedIntIndex",
        "signature": "pandas.tests.indexes.test_base.TestMixedIntIndex.indices(self, request)",
        "snippet": "    def indices(self, request):\n        return Index(request.param)",
        "begin_line": 2277,
        "end_line": 2278,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestMixedIntIndex.create_index#2280",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestMixedIntIndex",
        "signature": "pandas.tests.indexes.test_base.TestMixedIntIndex.create_index(self)",
        "snippet": "    def create_index(self) -> Index:\n        return Index([0, \"a\", 1, \"b\", 2, \"c\"])",
        "begin_line": 2280,
        "end_line": 2281,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_argsort#2283",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestMixedIntIndex",
        "signature": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_argsort(self)",
        "snippet": "    def test_argsort(self):\n        index = self.create_index()\n        with pytest.raises(TypeError, match=\"'>|<' not supported\"):\n            index.argsort()",
        "begin_line": 2283,
        "end_line": 2286,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_numpy_argsort#2288",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestMixedIntIndex",
        "signature": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_numpy_argsort(self)",
        "snippet": "    def test_numpy_argsort(self):\n        index = self.create_index()\n        with pytest.raises(TypeError, match=\"'>|<' not supported\"):\n            np.argsort(index)",
        "begin_line": 2288,
        "end_line": 2291,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_copy_name#2293",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestMixedIntIndex",
        "signature": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_copy_name(self)",
        "snippet": "    def test_copy_name(self):\n        # Check that \"name\" argument passed at initialization is honoured\n        # GH12309\n        index = self.create_index()\n\n        first = type(index)(index, copy=True, name=\"mario\")\n        second = type(first)(first, copy=False)\n\n        # Even though \"copy=False\", we want a new object.\n        assert first is not second\n        tm.assert_index_equal(first, second)\n\n        assert first.name == \"mario\"\n        assert second.name == \"mario\"\n\n        s1 = Series(2, index=first)\n        s2 = Series(3, index=second[:-1])\n\n        s3 = s1 * s2\n\n        assert s3.index.name == \"mario\"",
        "begin_line": 2293,
        "end_line": 2313,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_copy_name2#2315",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestMixedIntIndex",
        "signature": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_copy_name2(self)",
        "snippet": "    def test_copy_name2(self):\n        # Check that adding a \"name\" parameter to the copy is honored\n        # GH14302\n        index = pd.Index([1, 2], name=\"MyName\")\n        index1 = index.copy()\n\n        tm.assert_index_equal(index, index1)\n\n        index2 = index.copy(name=\"NewName\")\n        tm.assert_index_equal(index, index2, check_names=False)\n        assert index.name == \"MyName\"\n        assert index2.name == \"NewName\"\n\n        index3 = index.copy(names=[\"NewName\"])\n        tm.assert_index_equal(index, index3, check_names=False)\n        assert index.name == \"MyName\"\n        assert index.names == [\"MyName\"]\n        assert index3.name == \"NewName\"\n        assert index3.names == [\"NewName\"]",
        "begin_line": 2315,
        "end_line": 2333,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_unique_na#2335",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestMixedIntIndex",
        "signature": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_unique_na(self)",
        "snippet": "    def test_unique_na(self):\n        idx = pd.Index([2, np.nan, 2, 1], name=\"my_index\")\n        expected = pd.Index([2, np.nan, 1], name=\"my_index\")\n        result = idx.unique()\n        tm.assert_index_equal(result, expected)",
        "begin_line": 2335,
        "end_line": 2339,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_logical_compat#2341",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestMixedIntIndex",
        "signature": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_logical_compat(self)",
        "snippet": "    def test_logical_compat(self):\n        index = self.create_index()\n        assert index.all() == index.values.all()\n        assert index.any() == index.values.any()",
        "begin_line": 2341,
        "end_line": 2344,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_dropna#2358",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestMixedIntIndex",
        "signature": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_dropna(self, how, dtype, vals, expected)",
        "snippet": "    def test_dropna(self, how, dtype, vals, expected):\n        # GH 6194\n        index = pd.Index(vals, dtype=dtype)\n        result = index.dropna(how=how)\n        expected = pd.Index(expected, dtype=dtype)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 2358,
        "end_line": 2363,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_dropna_dt_like#2395",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestMixedIntIndex",
        "signature": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_dropna_dt_like(self, how, index, expected)",
        "snippet": "    def test_dropna_dt_like(self, how, index, expected):\n        result = index.dropna(how=how)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 2395,
        "end_line": 2397,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_dropna_invalid_how_raises#2399",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestMixedIntIndex",
        "signature": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_dropna_invalid_how_raises(self)",
        "snippet": "    def test_dropna_invalid_how_raises(self):\n        msg = \"invalid how option: xxx\"\n        with pytest.raises(ValueError, match=msg):\n            pd.Index([1, 2, 3]).dropna(how=\"xxx\")",
        "begin_line": 2399,
        "end_line": 2402,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_get_combined_index#2404",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestMixedIntIndex",
        "signature": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_get_combined_index(self)",
        "snippet": "    def test_get_combined_index(self):\n        result = _get_combined_index([])\n        expected = Index([])\n        tm.assert_index_equal(result, expected)",
        "begin_line": 2404,
        "end_line": 2407,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_is_monotonic_na#2422",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestMixedIntIndex",
        "signature": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_is_monotonic_na(self, index)",
        "snippet": "    def test_is_monotonic_na(self, index):\n        assert index.is_monotonic_increasing is False\n        assert index.is_monotonic_decreasing is False\n        assert index._is_strictly_monotonic_increasing is False\n        assert index._is_strictly_monotonic_decreasing is False",
        "begin_line": 2422,
        "end_line": 2426,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_repr_summary#2428",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestMixedIntIndex",
        "signature": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_repr_summary(self)",
        "snippet": "    def test_repr_summary(self):\n        with cf.option_context(\"display.max_seq_items\", 10):\n            result = repr(pd.Index(np.arange(1000)))\n            assert len(result) < 200\n            assert \"...\" in result",
        "begin_line": 2428,
        "end_line": 2432,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_int_name_format#2435",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestMixedIntIndex",
        "signature": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_int_name_format(self, klass)",
        "snippet": "    def test_int_name_format(self, klass):\n        index = Index([\"a\", \"b\", \"c\"], name=0)\n        result = klass(list(range(3)), index=index)\n        assert \"0\" in repr(result)",
        "begin_line": 2435,
        "end_line": 2438,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_print_unicode_columns#2440",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestMixedIntIndex",
        "signature": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_print_unicode_columns(self)",
        "snippet": "    def test_print_unicode_columns(self):\n        df = pd.DataFrame({\"\\u05d0\": [1, 2, 3], \"\\u05d1\": [4, 5, 6], \"c\": [7, 8, 9]})\n        repr(df.columns)  # should not raise UnicodeDecodeError",
        "begin_line": 2440,
        "end_line": 2442,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_str_to_bytes_raises#2444",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestMixedIntIndex",
        "signature": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_str_to_bytes_raises(self)",
        "snippet": "    def test_str_to_bytes_raises(self):\n        # GH 26447\n        index = Index([str(x) for x in range(10)])\n        msg = \"^'str' object cannot be interpreted as an integer$\"\n        with pytest.raises(TypeError, match=msg):\n            bytes(index)",
        "begin_line": 2444,
        "end_line": 2449,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_intersect_str_dates#2451",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestMixedIntIndex",
        "signature": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_intersect_str_dates(self)",
        "snippet": "    def test_intersect_str_dates(self):\n        dt_dates = [datetime(2012, 2, 9), datetime(2012, 2, 22)]\n\n        index1 = Index(dt_dates, dtype=object)\n        index2 = Index([\"aa\"], dtype=object)\n        result = index2.intersection(index1)\n\n        expected = Index([], dtype=object)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 2451,
        "end_line": 2459,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_index_repr_bool_nan#2461",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestMixedIntIndex",
        "signature": "pandas.tests.indexes.test_base.TestMixedIntIndex.test_index_repr_bool_nan(self)",
        "snippet": "    def test_index_repr_bool_nan(self):\n        # GH32146\n        arr = Index([True, False, np.nan], dtype=object)\n        exp1 = arr.format()\n        out1 = [\"True\", \"False\", \"NaN\"]\n        assert out1 == exp1\n\n        exp2 = repr(arr)\n        out2 = \"Index([True, False, nan], dtype='object')\"\n        assert out2 == exp2",
        "begin_line": 2461,
        "end_line": 2470,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndexUtils.test_ensure_index_from_sequences#2491",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndexUtils",
        "signature": "pandas.tests.indexes.test_base.TestIndexUtils.test_ensure_index_from_sequences(self, data, names, expected)",
        "snippet": "    def test_ensure_index_from_sequences(self, data, names, expected):\n        result = ensure_index_from_sequences(data, names)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 2491,
        "end_line": 2493,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.TestIndexUtils.test_ensure_index_mixed_closed_intervals#2495",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base.TestIndexUtils",
        "signature": "pandas.tests.indexes.test_base.TestIndexUtils.test_ensure_index_mixed_closed_intervals(self)",
        "snippet": "    def test_ensure_index_mixed_closed_intervals(self):\n        # GH27172\n        intervals = [\n            pd.Interval(0, 1, closed=\"left\"),\n            pd.Interval(1, 2, closed=\"right\"),\n            pd.Interval(2, 3, closed=\"neither\"),\n            pd.Interval(3, 4, closed=\"both\"),\n        ]\n        result = ensure_index(intervals)\n        expected = Index(intervals, dtype=object)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 2495,
        "end_line": 2505,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.test_generated_op_names#2533",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base",
        "signature": "pandas.tests.indexes.test_base.test_generated_op_names(opname, indices)",
        "snippet": "def test_generated_op_names(opname, indices):\n    if isinstance(indices, ABCIndex) and opname == \"rsub\":\n        # pd.Index.__rsub__ does not exist; though the method does exist\n        # for subclasses.  see GH#19723\n        return\n    opname = f\"__{opname}__\"\n    method = getattr(indices, opname)\n    assert method.__name__ == opname",
        "begin_line": 2533,
        "end_line": 2540,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.test_index_subclass_constructor_wrong_kwargs#2544",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base",
        "signature": "pandas.tests.indexes.test_base.test_index_subclass_constructor_wrong_kwargs(index_maker)",
        "snippet": "def test_index_subclass_constructor_wrong_kwargs(index_maker):\n    # GH #19348\n    with pytest.raises(TypeError, match=\"unexpected keyword argument\"):\n        index_maker(foo=\"bar\")",
        "begin_line": 2544,
        "end_line": 2547,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.test_deprecated_fastpath#2550",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base",
        "signature": "pandas.tests.indexes.test_base.test_deprecated_fastpath()",
        "snippet": "def test_deprecated_fastpath():\n    msg = \"[Uu]nexpected keyword argument\"\n    with pytest.raises(TypeError, match=msg):\n        pd.Index(np.array([\"a\", \"b\"], dtype=object), name=\"test\", fastpath=True)\n\n    with pytest.raises(TypeError, match=msg):\n        pd.Int64Index(np.array([1, 2, 3], dtype=\"int64\"), name=\"test\", fastpath=True)\n\n    with pytest.raises(TypeError, match=msg):\n        pd.RangeIndex(0, 5, 2, name=\"test\", fastpath=True)\n\n    with pytest.raises(TypeError, match=msg):\n        pd.CategoricalIndex([\"a\", \"b\", \"c\"], name=\"test\", fastpath=True)",
        "begin_line": 2550,
        "end_line": 2562,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.test_shape_of_invalid_index#2565",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base",
        "signature": "pandas.tests.indexes.test_base.test_shape_of_invalid_index()",
        "snippet": "def test_shape_of_invalid_index():\n    # Currently, it is possible to create \"invalid\" index objects backed by\n    # a multi-dimensional array (see https://github.com/pandas-dev/pandas/issues/27125\n    # about this). However, as long as this is not solved in general,this test ensures\n    # that the returned shape is consistent with this underlying array for\n    # compat with matplotlib (see https://github.com/pandas-dev/pandas/issues/27775)\n    idx = pd.Index([0, 1, 2, 3])\n    with tm.assert_produces_warning(DeprecationWarning):\n        # GH#30588 multi-dimensional indexing deprecated\n        assert idx[:, None].shape == (4, 1)",
        "begin_line": 2565,
        "end_line": 2574,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.test_validate_1d_input#2577",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base",
        "signature": "pandas.tests.indexes.test_base.test_validate_1d_input()",
        "snippet": "def test_validate_1d_input():\n    # GH#27125 check that we do not have >1-dimensional input\n    msg = \"Index data must be 1-dimensional\"\n\n    arr = np.arange(8).reshape(2, 2, 2)\n    with pytest.raises(ValueError, match=msg):\n        pd.Index(arr)\n\n    with pytest.raises(ValueError, match=msg):\n        pd.Float64Index(arr.astype(np.float64))\n\n    with pytest.raises(ValueError, match=msg):\n        pd.Int64Index(arr.astype(np.int64))\n\n    with pytest.raises(ValueError, match=msg):\n        pd.UInt64Index(arr.astype(np.uint64))\n\n    df = pd.DataFrame(arr.reshape(4, 2))\n    with pytest.raises(ValueError, match=msg):\n        pd.Index(df)\n\n    # GH#13601 trying to assign a multi-dimensional array to an index is not\n    #  allowed\n    ser = pd.Series(0, range(4))\n    with pytest.raises(ValueError, match=msg):\n        ser.index = np.array([[2, 3]] * 4)",
        "begin_line": 2577,
        "end_line": 2602,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.test_convert_almost_null_slice#2605",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base",
        "signature": "pandas.tests.indexes.test_base.test_convert_almost_null_slice(indices)",
        "snippet": "def test_convert_almost_null_slice(indices):\n    # slice with None at both ends, but not step\n    idx = indices\n\n    key = slice(None, None, \"foo\")\n\n    if isinstance(idx, pd.IntervalIndex):\n        msg = \"label-based slicing with step!=1 is not supported for IntervalIndex\"\n        with pytest.raises(ValueError, match=msg):\n            idx._convert_slice_indexer(key, \"loc\")\n    else:\n        msg = \"'>=' not supported between instances of 'str' and 'int'\"\n        with pytest.raises(TypeError, match=msg):\n            idx._convert_slice_indexer(key, \"loc\")",
        "begin_line": 2605,
        "end_line": 2618,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.test_get_indexer_non_unique_wrong_dtype#2631",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base",
        "signature": "pandas.tests.indexes.test_base.test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype)",
        "snippet": "def test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n\n    vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n\n    def construct(dtype):\n        if dtype is dtlike_dtypes[-1]:\n            # PeriodArray will try to cast ints to strings\n            return pd.DatetimeIndex(vals).astype(dtype)\n        return pd.Index(vals, dtype=dtype)\n\n    left = construct(ldtype)\n    right = construct(rdtype)\n\n    result = left.get_indexer_non_unique(right)\n\n    if ldtype is rdtype:\n        ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n        ex2 = np.array([], dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], ex1)\n        tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n\n    else:\n        no_matches = np.array([-1] * 6, dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], no_matches)\n        tm.assert_numpy_array_equal(result[1], no_matches)",
        "begin_line": 2631,
        "end_line": 2655,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_base.construct#2635",
        "src_path": "pandas/tests/indexes/test_base.py",
        "class_name": "pandas.tests.indexes.test_base",
        "signature": "pandas.tests.indexes.test_base.construct(dtype)",
        "snippet": "    def construct(dtype):\n        if dtype is dtlike_dtypes[-1]:\n            # PeriodArray will try to cast ints to strings\n            return pd.DatetimeIndex(vals).astype(dtype)\n        return pd.Index(vals, dtype=dtype)",
        "begin_line": 2635,
        "end_line": 2639,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common._mklbl#10",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common",
        "signature": "pandas.tests.indexing.common._mklbl(prefix, n)",
        "snippet": "def _mklbl(prefix, n):\n    return [f\"{prefix}{i}\" for i in range(n)]",
        "begin_line": 10,
        "end_line": 11,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common._axify#14",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common",
        "signature": "pandas.tests.indexing.common._axify(obj, key, axis)",
        "snippet": "def _axify(obj, key, axis):\n    # create a tuple accessor\n    axes = [slice(None)] * obj.ndim\n    axes[axis] = key\n    return tuple(axes)",
        "begin_line": 14,
        "end_line": 18,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.setup_method#37",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.setup_method(self, method)",
        "snippet": "    def setup_method(self, method):\n\n        self.series_ints = Series(np.random.rand(4), index=np.arange(0, 8, 2))\n        self.frame_ints = DataFrame(\n            np.random.randn(4, 4), index=np.arange(0, 8, 2), columns=np.arange(0, 12, 3)\n        )\n\n        self.series_uints = Series(\n            np.random.rand(4), index=UInt64Index(np.arange(0, 8, 2))\n        )\n        self.frame_uints = DataFrame(\n            np.random.randn(4, 4),\n            index=UInt64Index(range(0, 8, 2)),\n            columns=UInt64Index(range(0, 12, 3)),\n        )\n\n        self.series_floats = Series(\n            np.random.rand(4), index=Float64Index(range(0, 8, 2))\n        )\n        self.frame_floats = DataFrame(\n            np.random.randn(4, 4),\n            index=Float64Index(range(0, 8, 2)),\n            columns=Float64Index(range(0, 12, 3)),\n        )\n\n        m_idces = [\n            MultiIndex.from_product([[1, 2], [3, 4]]),\n            MultiIndex.from_product([[5, 6], [7, 8]]),\n            MultiIndex.from_product([[9, 10], [11, 12]]),\n        ]\n\n        self.series_multi = Series(np.random.rand(4), index=m_idces[0])\n        self.frame_multi = DataFrame(\n            np.random.randn(4, 4), index=m_idces[0], columns=m_idces[1]\n        )\n\n        self.series_labels = Series(np.random.randn(4), index=list(\"abcd\"))\n        self.frame_labels = DataFrame(\n            np.random.randn(4, 4), index=list(\"abcd\"), columns=list(\"ABCD\")\n        )\n\n        self.series_mixed = Series(np.random.randn(4), index=[2, 4, \"null\", 8])\n        self.frame_mixed = DataFrame(np.random.randn(4, 4), index=[2, 4, \"null\", 8])\n\n        self.series_ts = Series(\n            np.random.randn(4), index=date_range(\"20130101\", periods=4)\n        )\n        self.frame_ts = DataFrame(\n            np.random.randn(4, 4), index=date_range(\"20130101\", periods=4)\n        )\n\n        dates_rev = date_range(\"20130101\", periods=4).sort_values(ascending=False)\n        self.series_ts_rev = Series(np.random.randn(4), index=dates_rev)\n        self.frame_ts_rev = DataFrame(np.random.randn(4, 4), index=dates_rev)\n\n        self.frame_empty = DataFrame()\n        self.series_empty = Series(dtype=object)\n\n        # form agglomerates\n        for kind in self._kinds:\n            d = dict()\n            for typ in self._typs:\n                d[typ] = getattr(self, f\"{kind}_{typ}\")\n\n            setattr(self, kind, d)",
        "begin_line": 37,
        "end_line": 101,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.generate_indices#103",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.generate_indices(self, f, values=False)",
        "snippet": "    def generate_indices(self, f, values=False):\n        \"\"\"\n        generate the indices\n        if values is True , use the axis values\n        is False, use the range\n        \"\"\"\n        axes = f.axes\n        if values:\n            axes = (list(range(len(ax))) for ax in axes)\n\n        return itertools.product(*axes)",
        "begin_line": 103,
        "end_line": 113,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.get_value#115",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.get_value(self, name, f, i, values=False)",
        "snippet": "    def get_value(self, name, f, i, values=False):\n        \"\"\" return the value for the location i \"\"\"\n        # check against values\n        if values:\n            return f.values[i]\n\n        elif name == \"iat\":\n            return f.iloc[i]\n        else:\n            assert name == \"at\"\n            return f.loc[i]",
        "begin_line": 115,
        "end_line": 125,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.check_values#127",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.check_values(self, f, func, values=False)",
        "snippet": "    def check_values(self, f, func, values=False):\n\n        if f is None:\n            return\n        axes = f.axes\n        indicies = itertools.product(*axes)\n\n        for i in indicies:\n            result = getattr(f, func)[i]\n\n            # check against values\n            if values:\n                expected = f.values[i]\n            else:\n                expected = f\n                for a in reversed(i):\n                    expected = expected.__getitem__(a)\n\n            tm.assert_almost_equal(result, expected)",
        "begin_line": 127,
        "end_line": 145,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.check_result#147",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.check_result(self, method, key, typs=None, axes=None, fails=None)",
        "snippet": "    def check_result(\n        self, method, key, typs=None, axes=None, fails=None,\n    ):\n        def _eq(axis, obj, key):\n            \"\"\" compare equal for these 2 keys \"\"\"\n            axified = _axify(obj, key, axis)\n            try:\n                getattr(obj, method).__getitem__(axified)\n\n            except (IndexError, TypeError, KeyError) as detail:\n\n                # if we are in fails, the ok, otherwise raise it\n                if fails is not None:\n                    if isinstance(detail, fails):\n                        return\n                raise\n\n        if typs is None:\n            typs = self._typs\n\n        if axes is None:\n            axes = [0, 1]\n        else:\n            assert axes in [0, 1]\n            axes = [axes]\n\n        # check\n        for kind in self._kinds:\n\n            d = getattr(self, kind)\n            for ax in axes:\n                for typ in typs:\n                    assert typ in self._typs\n\n                    obj = d[typ]\n                    if ax < obj.ndim:\n                        _eq(axis=ax, obj=obj, key=key)",
        "begin_line": 147,
        "end_line": 183,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base._eq#150",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base._eq(axis, obj, key)",
        "snippet": "        def _eq(axis, obj, key):\n            \"\"\" compare equal for these 2 keys \"\"\"\n            axified = _axify(obj, key, axis)\n            try:\n                getattr(obj, method).__getitem__(axified)\n\n            except (IndexError, TypeError, KeyError) as detail:\n\n                # if we are in fails, the ok, otherwise raise it\n                if fails is not None:\n                    if isinstance(detail, fails):\n                        return\n                raise",
        "begin_line": 150,
        "end_line": 162,
        "comment": "",
        "is_bug": false
    }
]