[
    {
        "name": "pandas.tests.indexing.multiindex.conftest.multiindex_dataframe_random_data#8",
        "src_path": "pandas/tests/indexing/multiindex/conftest.py",
        "class_name": "pandas.tests.indexing.multiindex.conftest",
        "signature": "pandas.tests.indexing.multiindex.conftest.multiindex_dataframe_random_data()",
        "snippet": "def multiindex_dataframe_random_data():\n    \"\"\"DataFrame with 2 level MultiIndex with random data\"\"\"\n    index = MultiIndex(\n        levels=[[\"foo\", \"bar\", \"baz\", \"qux\"], [\"one\", \"two\", \"three\"]],\n        codes=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3], [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],\n        names=[\"first\", \"second\"],\n    )\n    return DataFrame(\n        np.random.randn(10, 3), index=index, columns=Index([\"A\", \"B\", \"C\"], name=\"exp\")\n    )",
        "begin_line": 8,
        "end_line": 17,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common._mklbl#10",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common",
        "signature": "pandas.tests.indexing.common._mklbl(prefix, n)",
        "snippet": "def _mklbl(prefix, n):\n    return [f\"{prefix}{i}\" for i in range(n)]",
        "begin_line": 10,
        "end_line": 11,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common._axify#14",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common",
        "signature": "pandas.tests.indexing.common._axify(obj, key, axis)",
        "snippet": "def _axify(obj, key, axis):\n    # create a tuple accessor\n    axes = [slice(None)] * obj.ndim\n    axes[axis] = key\n    return tuple(axes)",
        "begin_line": 14,
        "end_line": 18,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.setup_method#37",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.setup_method(self, method)",
        "snippet": "    def setup_method(self, method):\n\n        self.series_ints = Series(np.random.rand(4), index=np.arange(0, 8, 2))\n        self.frame_ints = DataFrame(\n            np.random.randn(4, 4), index=np.arange(0, 8, 2), columns=np.arange(0, 12, 3)\n        )\n\n        self.series_uints = Series(\n            np.random.rand(4), index=UInt64Index(np.arange(0, 8, 2))\n        )\n        self.frame_uints = DataFrame(\n            np.random.randn(4, 4),\n            index=UInt64Index(range(0, 8, 2)),\n            columns=UInt64Index(range(0, 12, 3)),\n        )\n\n        self.series_floats = Series(\n            np.random.rand(4), index=Float64Index(range(0, 8, 2))\n        )\n        self.frame_floats = DataFrame(\n            np.random.randn(4, 4),\n            index=Float64Index(range(0, 8, 2)),\n            columns=Float64Index(range(0, 12, 3)),\n        )\n\n        m_idces = [\n            MultiIndex.from_product([[1, 2], [3, 4]]),\n            MultiIndex.from_product([[5, 6], [7, 8]]),\n            MultiIndex.from_product([[9, 10], [11, 12]]),\n        ]\n\n        self.series_multi = Series(np.random.rand(4), index=m_idces[0])\n        self.frame_multi = DataFrame(\n            np.random.randn(4, 4), index=m_idces[0], columns=m_idces[1]\n        )\n\n        self.series_labels = Series(np.random.randn(4), index=list(\"abcd\"))\n        self.frame_labels = DataFrame(\n            np.random.randn(4, 4), index=list(\"abcd\"), columns=list(\"ABCD\")\n        )\n\n        self.series_mixed = Series(np.random.randn(4), index=[2, 4, \"null\", 8])\n        self.frame_mixed = DataFrame(np.random.randn(4, 4), index=[2, 4, \"null\", 8])\n\n        self.series_ts = Series(\n            np.random.randn(4), index=date_range(\"20130101\", periods=4)\n        )\n        self.frame_ts = DataFrame(\n            np.random.randn(4, 4), index=date_range(\"20130101\", periods=4)\n        )\n\n        dates_rev = date_range(\"20130101\", periods=4).sort_values(ascending=False)\n        self.series_ts_rev = Series(np.random.randn(4), index=dates_rev)\n        self.frame_ts_rev = DataFrame(np.random.randn(4, 4), index=dates_rev)\n\n        self.frame_empty = DataFrame()\n        self.series_empty = Series(dtype=object)\n\n        # form agglomerates\n        for kind in self._kinds:\n            d = dict()\n            for typ in self._typs:\n                d[typ] = getattr(self, f\"{kind}_{typ}\")\n\n            setattr(self, kind, d)",
        "begin_line": 37,
        "end_line": 101,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.generate_indices#103",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.generate_indices(self, f, values=False)",
        "snippet": "    def generate_indices(self, f, values=False):\n        \"\"\"\n        generate the indices\n        if values is True , use the axis values\n        is False, use the range\n        \"\"\"\n        axes = f.axes\n        if values:\n            axes = (list(range(len(ax))) for ax in axes)\n\n        return itertools.product(*axes)",
        "begin_line": 103,
        "end_line": 113,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.get_value#115",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.get_value(self, name, f, i, values=False)",
        "snippet": "    def get_value(self, name, f, i, values=False):\n        \"\"\" return the value for the location i \"\"\"\n        # check against values\n        if values:\n            return f.values[i]\n\n        elif name == \"iat\":\n            return f.iloc[i]\n        else:\n            assert name == \"at\"\n            return f.loc[i]",
        "begin_line": 115,
        "end_line": 125,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.check_values#127",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.check_values(self, f, func, values=False)",
        "snippet": "    def check_values(self, f, func, values=False):\n\n        if f is None:\n            return\n        axes = f.axes\n        indicies = itertools.product(*axes)\n\n        for i in indicies:\n            result = getattr(f, func)[i]\n\n            # check against values\n            if values:\n                expected = f.values[i]\n            else:\n                expected = f\n                for a in reversed(i):\n                    expected = expected.__getitem__(a)\n\n            tm.assert_almost_equal(result, expected)",
        "begin_line": 127,
        "end_line": 145,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.check_result#147",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.check_result(self, method, key, typs=None, axes=None, fails=None)",
        "snippet": "    def check_result(\n        self, method, key, typs=None, axes=None, fails=None,\n    ):\n        def _eq(axis, obj, key):\n            \"\"\" compare equal for these 2 keys \"\"\"\n            axified = _axify(obj, key, axis)\n            try:\n                getattr(obj, method).__getitem__(axified)\n\n            except (IndexError, TypeError, KeyError) as detail:\n\n                # if we are in fails, the ok, otherwise raise it\n                if fails is not None:\n                    if isinstance(detail, fails):\n                        return\n                raise\n\n        if typs is None:\n            typs = self._typs\n\n        if axes is None:\n            axes = [0, 1]\n        else:\n            assert axes in [0, 1]\n            axes = [axes]\n\n        # check\n        for kind in self._kinds:\n\n            d = getattr(self, kind)\n            for ax in axes:\n                for typ in typs:\n                    assert typ in self._typs\n\n                    obj = d[typ]\n                    if ax < obj.ndim:\n                        _eq(axis=ax, obj=obj, key=key)",
        "begin_line": 147,
        "end_line": 183,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base._eq#150",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base._eq(axis, obj, key)",
        "snippet": "        def _eq(axis, obj, key):\n            \"\"\" compare equal for these 2 keys \"\"\"\n            axified = _axify(obj, key, axis)\n            try:\n                getattr(obj, method).__getitem__(axified)\n\n            except (IndexError, TypeError, KeyError) as detail:\n\n                # if we are in fails, the ok, otherwise raise it\n                if fails is not None:\n                    if isinstance(detail, fails):\n                        return\n                raise",
        "begin_line": 150,
        "end_line": 162,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar.test_at_and_iat_get#14",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar.test_at_and_iat_get(self, kind)",
        "snippet": "    def test_at_and_iat_get(self, kind):\n        def _check(f, func, values=False):\n\n            if f is not None:\n                indices = self.generate_indices(f, values)\n                for i in indices:\n                    result = getattr(f, func)[i]\n                    expected = self.get_value(func, f, i, values)\n                    tm.assert_almost_equal(result, expected)\n\n        d = getattr(self, kind)\n\n        # iat\n        for f in [d[\"ints\"], d[\"uints\"]]:\n            _check(f, \"iat\", values=True)\n\n        for f in [d[\"labels\"], d[\"ts\"], d[\"floats\"]]:\n            if f is not None:\n                msg = \"iAt based indexing can only have integer indexers\"\n                with pytest.raises(ValueError, match=msg):\n                    self.check_values(f, \"iat\")\n\n        # at\n        for f in [d[\"ints\"], d[\"uints\"], d[\"labels\"], d[\"ts\"], d[\"floats\"]]:\n            _check(f, \"at\")",
        "begin_line": 14,
        "end_line": 38,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar._check#15",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar._check(f, func, values=False)",
        "snippet": "        def _check(f, func, values=False):\n\n            if f is not None:\n                indices = self.generate_indices(f, values)\n                for i in indices:\n                    result = getattr(f, func)[i]\n                    expected = self.get_value(func, f, i, values)\n                    tm.assert_almost_equal(result, expected)",
        "begin_line": 15,
        "end_line": 22,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar.test_at_and_iat_set#41",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar.test_at_and_iat_set(self, kind)",
        "snippet": "    def test_at_and_iat_set(self, kind):\n        def _check(f, func, values=False):\n\n            if f is not None:\n                indices = self.generate_indices(f, values)\n                for i in indices:\n                    getattr(f, func)[i] = 1\n                    expected = self.get_value(func, f, i, values)\n                    tm.assert_almost_equal(expected, 1)\n\n        d = getattr(self, kind)\n\n        # iat\n        for f in [d[\"ints\"], d[\"uints\"]]:\n            _check(f, \"iat\", values=True)\n\n        for f in [d[\"labels\"], d[\"ts\"], d[\"floats\"]]:\n            if f is not None:\n                msg = \"iAt based indexing can only have integer indexers\"\n                with pytest.raises(ValueError, match=msg):\n                    _check(f, \"iat\")\n\n        # at\n        for f in [d[\"ints\"], d[\"uints\"], d[\"labels\"], d[\"ts\"], d[\"floats\"]]:\n            _check(f, \"at\")",
        "begin_line": 41,
        "end_line": 65,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar._check#42",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar._check(f, func, values=False)",
        "snippet": "        def _check(f, func, values=False):\n\n            if f is not None:\n                indices = self.generate_indices(f, values)\n                for i in indices:\n                    getattr(f, func)[i] = 1\n                    expected = self.get_value(func, f, i, values)\n                    tm.assert_almost_equal(expected, 1)",
        "begin_line": 42,
        "end_line": 49,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_at_iat_coercion#71",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_at_iat_coercion(self)",
        "snippet": "    def test_at_iat_coercion(self):\n\n        # as timestamp is not a tuple!\n        dates = date_range(\"1/1/2000\", periods=8)\n        df = DataFrame(np.random.randn(8, 4), index=dates, columns=[\"A\", \"B\", \"C\", \"D\"])\n        s = df[\"A\"]\n\n        result = s.at[dates[5]]\n        xp = s.values[5]\n        assert result == xp\n\n        # GH 7729\n        # make sure we are boxing the returns\n        s = Series([\"2014-01-01\", \"2014-02-02\"], dtype=\"datetime64[ns]\")\n        expected = Timestamp(\"2014-02-02\")\n\n        for r in [lambda: s.iat[1], lambda: s.iloc[1]]:\n            result = r()\n            assert result == expected\n\n        s = Series([\"1 days\", \"2 days\"], dtype=\"timedelta64[ns]\")\n        expected = Timedelta(\"2 days\")\n\n        for r in [lambda: s.iat[1], lambda: s.iloc[1]]:\n            result = r()\n            assert result == expected",
        "begin_line": 71,
        "end_line": 96,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_iat_invalid_args#98",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_iat_invalid_args(self)",
        "snippet": "    def test_iat_invalid_args(self):\n        pass",
        "begin_line": 98,
        "end_line": 99,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_imethods_with_dups#101",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_imethods_with_dups(self)",
        "snippet": "    def test_imethods_with_dups(self):\n\n        # GH6493\n        # iat/iloc with dups\n\n        s = Series(range(5), index=[1, 1, 2, 2, 3], dtype=\"int64\")\n        result = s.iloc[2]\n        assert result == 2\n        result = s.iat[2]\n        assert result == 2\n\n        msg = \"index 10 is out of bounds for axis 0 with size 5\"\n        with pytest.raises(IndexError, match=msg):\n            s.iat[10]\n        msg = \"index -10 is out of bounds for axis 0 with size 5\"\n        with pytest.raises(IndexError, match=msg):\n            s.iat[-10]\n\n        result = s.iloc[[2, 3]]\n        expected = Series([2, 3], [2, 2], dtype=\"int64\")\n        tm.assert_series_equal(result, expected)\n\n        df = s.to_frame()\n        result = df.iloc[2]\n        expected = Series(2, index=[0], name=2)\n        tm.assert_series_equal(result, expected)\n\n        result = df.iat[2, 0]\n        assert result == 2",
        "begin_line": 101,
        "end_line": 129,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_frame_at_with_duplicate_axes#131",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_frame_at_with_duplicate_axes(self)",
        "snippet": "    def test_frame_at_with_duplicate_axes(self):\n        # GH#33041\n        arr = np.random.randn(6).reshape(3, 2)\n        df = DataFrame(arr, columns=[\"A\", \"A\"])\n\n        result = df.at[0, \"A\"]\n        expected = df.iloc[0]\n\n        tm.assert_series_equal(result, expected)\n\n        result = df.T.at[\"A\", 0]\n        tm.assert_series_equal(result, expected)\n\n        # setter\n        df.at[1, \"A\"] = 2\n        expected = Series([2.0, 2.0], index=[\"A\", \"A\"], name=1)\n        tm.assert_series_equal(df.iloc[1], expected)",
        "begin_line": 131,
        "end_line": 147,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_frame_at_with_duplicate_axes_requires_scalar_lookup#149",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_frame_at_with_duplicate_axes_requires_scalar_lookup(self)",
        "snippet": "    def test_frame_at_with_duplicate_axes_requires_scalar_lookup(self):\n        # GH#33041 check that falling back to loc doesn't allow non-scalar\n        #  args to slip in\n\n        arr = np.random.randn(6).reshape(3, 2)\n        df = DataFrame(arr, columns=[\"A\", \"A\"])\n\n        msg = \"Invalid call for scalar access\"\n        with pytest.raises(ValueError, match=msg):\n            df.at[[1, 2]]\n        with pytest.raises(ValueError, match=msg):\n            df.at[1, [\"A\"]]\n        with pytest.raises(ValueError, match=msg):\n            df.at[:, \"A\"]\n\n        with pytest.raises(ValueError, match=msg):\n            df.at[[1, 2]] = 1\n        with pytest.raises(ValueError, match=msg):\n            df.at[1, [\"A\"]] = 1\n        with pytest.raises(ValueError, match=msg):\n            df.at[:, \"A\"] = 1",
        "begin_line": 149,
        "end_line": 169,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_series_at_raises_type_error#171",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_series_at_raises_type_error(self)",
        "snippet": "    def test_series_at_raises_type_error(self):\n        # at should not fallback\n        # GH 7814\n        # GH#31724 .at should match .loc\n        ser = Series([1, 2, 3], index=list(\"abc\"))\n        result = ser.at[\"a\"]\n        assert result == 1\n        result = ser.loc[\"a\"]\n        assert result == 1\n\n        with pytest.raises(KeyError, match=\"^0$\"):\n            ser.at[0]\n        with pytest.raises(KeyError, match=\"^0$\"):\n            ser.loc[0]",
        "begin_line": 171,
        "end_line": 184,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_frame_raises_key_error#186",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_frame_raises_key_error(self)",
        "snippet": "    def test_frame_raises_key_error(self):\n        # GH#31724 .at should match .loc\n        df = DataFrame({\"A\": [1, 2, 3]}, index=list(\"abc\"))\n        result = df.at[\"a\", \"A\"]\n        assert result == 1\n        result = df.loc[\"a\", \"A\"]\n        assert result == 1\n\n        with pytest.raises(KeyError, match=\"^0$\"):\n            df.at[\"a\", 0]\n        with pytest.raises(KeyError, match=\"^0$\"):\n            df.loc[\"a\", 0]",
        "begin_line": 186,
        "end_line": 197,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_series_at_raises_key_error#199",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_series_at_raises_key_error(self)",
        "snippet": "    def test_series_at_raises_key_error(self):\n        # GH#31724 .at should match .loc\n\n        ser = Series([1, 2, 3], index=[3, 2, 1])\n        result = ser.at[1]\n        assert result == 3\n        result = ser.loc[1]\n        assert result == 3\n\n        with pytest.raises(KeyError, match=\"a\"):\n            ser.at[\"a\"]\n        with pytest.raises(KeyError, match=\"a\"):\n            # .at should match .loc\n            ser.loc[\"a\"]",
        "begin_line": 199,
        "end_line": 212,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_frame_at_raises_key_error#214",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_frame_at_raises_key_error(self)",
        "snippet": "    def test_frame_at_raises_key_error(self):\n        # GH#31724 .at should match .loc\n\n        df = DataFrame({0: [1, 2, 3]}, index=[3, 2, 1])\n\n        result = df.at[1, 0]\n        assert result == 3\n        result = df.loc[1, 0]\n        assert result == 3\n\n        with pytest.raises(KeyError, match=\"a\"):\n            df.at[\"a\", 0]\n        with pytest.raises(KeyError, match=\"a\"):\n            df.loc[\"a\", 0]\n\n        with pytest.raises(KeyError, match=\"a\"):\n            df.at[1, \"a\"]\n        with pytest.raises(KeyError, match=\"a\"):\n            df.loc[1, \"a\"]",
        "begin_line": 214,
        "end_line": 232,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_getitem_list_missing_key#235",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_getitem_list_missing_key(self)",
        "snippet": "    def test_getitem_list_missing_key(self):\n        # GH 13822, incorrect error string with non-unique columns when missing\n        # column is accessed\n        df = DataFrame({\"x\": [1.0], \"y\": [2.0], \"z\": [3.0]})\n        df.columns = [\"x\", \"x\", \"z\"]\n\n        # Check that we get the correct value in the KeyError\n        with pytest.raises(KeyError, match=r\"\\['y'\\] not in index\"):\n            df[[\"x\", \"y\", \"z\"]]",
        "begin_line": 235,
        "end_line": 243,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_at_with_tz#245",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_at_with_tz(self)",
        "snippet": "    def test_at_with_tz(self):\n        # gh-15822\n        df = DataFrame(\n            {\n                \"name\": [\"John\", \"Anderson\"],\n                \"date\": [\n                    Timestamp(2017, 3, 13, 13, 32, 56),\n                    Timestamp(2017, 2, 16, 12, 10, 3),\n                ],\n            }\n        )\n        df[\"date\"] = df[\"date\"].dt.tz_localize(\"Asia/Shanghai\")\n\n        expected = Timestamp(\"2017-03-13 13:32:56+0800\", tz=\"Asia/Shanghai\")\n\n        result = df.loc[0, \"date\"]\n        assert result == expected\n\n        result = df.at[0, \"date\"]\n        assert result == expected",
        "begin_line": 245,
        "end_line": 264,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_series_set_tz_timestamp#266",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_series_set_tz_timestamp(self, tz_naive_fixture)",
        "snippet": "    def test_series_set_tz_timestamp(self, tz_naive_fixture):\n        # GH 25506\n        ts = Timestamp(\"2017-08-05 00:00:00+0100\", tz=tz_naive_fixture)\n        result = Series(ts)\n        result.at[1] = ts\n        expected = Series([ts, ts])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 266,
        "end_line": 272,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_mixed_index_at_iat_loc_iloc_series#274",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_mixed_index_at_iat_loc_iloc_series(self)",
        "snippet": "    def test_mixed_index_at_iat_loc_iloc_series(self):\n        # GH 19860\n        s = Series([1, 2, 3, 4, 5], index=[\"a\", \"b\", \"c\", 1, 2])\n        for el, item in s.items():\n            assert s.at[el] == s.loc[el] == item\n        for i in range(len(s)):\n            assert s.iat[i] == s.iloc[i] == i + 1\n\n        with pytest.raises(KeyError, match=\"^4$\"):\n            s.at[4]\n        with pytest.raises(KeyError, match=\"^4$\"):\n            s.loc[4]",
        "begin_line": 274,
        "end_line": 285,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_mixed_index_at_iat_loc_iloc_dataframe#287",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_mixed_index_at_iat_loc_iloc_dataframe(self)",
        "snippet": "    def test_mixed_index_at_iat_loc_iloc_dataframe(self):\n        # GH 19860\n        df = DataFrame(\n            [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]], columns=[\"a\", \"b\", \"c\", 1, 2]\n        )\n        for rowIdx, row in df.iterrows():\n            for el, item in row.items():\n                assert df.at[rowIdx, el] == df.loc[rowIdx, el] == item\n\n        for row in range(2):\n            for i in range(5):\n                assert df.iat[row, i] == df.iloc[row, i] == row * 5 + i\n\n        with pytest.raises(KeyError, match=\"^3$\"):\n            df.at[0, 3]\n        with pytest.raises(KeyError, match=\"^3$\"):\n            df.loc[0, 3]",
        "begin_line": 287,
        "end_line": 303,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_iat_setter_incompatible_assignment#305",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_iat_setter_incompatible_assignment(self)",
        "snippet": "    def test_iat_setter_incompatible_assignment(self):\n        # GH 23236\n        result = DataFrame({\"a\": [0, 1], \"b\": [4, 5]})\n        result.iat[0, 0] = None\n        expected = DataFrame({\"a\": [None, 1], \"b\": [4, 5]})\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 305,
        "end_line": 310,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_getitem_zerodim_np_array#312",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_getitem_zerodim_np_array(self)",
        "snippet": "    def test_getitem_zerodim_np_array(self):\n        # GH24924\n        # dataframe __getitem__\n        df = DataFrame([[1, 2], [3, 4]])\n        result = df[np.array(0)]\n        expected = Series([1, 3], name=0)\n        tm.assert_series_equal(result, expected)\n\n        # series __getitem__\n        s = Series([1, 2])\n        result = s[np.array(0)]\n        assert result == 1",
        "begin_line": 312,
        "end_line": 323,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.test_iat_dont_wrap_object_datetimelike#326",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar",
        "signature": "pandas.tests.indexing.test_scalar.test_iat_dont_wrap_object_datetimelike()",
        "snippet": "def test_iat_dont_wrap_object_datetimelike():\n    # GH#32809 .iat calls go through DataFrame._get_value, should not\n    #  call maybe_box_datetimelike\n    dti = date_range(\"2016-01-01\", periods=3)\n    tdi = dti - dti\n    ser = Series(dti.to_pydatetime(), dtype=object)\n    ser2 = Series(tdi.to_pytimedelta(), dtype=object)\n    df = DataFrame({\"A\": ser, \"B\": ser2})\n    assert (df.dtypes == object).all()\n\n    for result in [df.at[0, \"A\"], df.iat[0, 0], df.loc[0, \"A\"], df.iloc[0, 0]]:\n        assert result is ser[0]\n        assert isinstance(result, datetime)\n        assert not isinstance(result, Timestamp)\n\n    for result in [df.at[1, \"B\"], df.iat[1, 1], df.loc[1, \"B\"], df.iloc[1, 1]]:\n        assert result is ser2[1]\n        assert isinstance(result, timedelta)\n        assert not isinstance(result, Timedelta)",
        "begin_line": 326,
        "end_line": 344,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.test_iat_series_with_period_index#347",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar",
        "signature": "pandas.tests.indexing.test_scalar.test_iat_series_with_period_index()",
        "snippet": "def test_iat_series_with_period_index():\n    # GH 4390, iat incorrectly indexing\n    index = period_range(\"1/1/2001\", periods=10)\n    ser = Series(np.random.randn(10), index=index)\n    expected = ser[index[0]]\n    result = ser.iat[0]\n    assert expected == result",
        "begin_line": 347,
        "end_line": 353,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.test_at_with_tuple_index_get#356",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar",
        "signature": "pandas.tests.indexing.test_scalar.test_at_with_tuple_index_get()",
        "snippet": "def test_at_with_tuple_index_get():\n    # GH 26989\n    # DataFrame.at getter works with Index of tuples\n    df = DataFrame({\"a\": [1, 2]}, index=[(1, 2), (3, 4)])\n    assert df.index.nlevels == 1\n    assert df.at[(1, 2), \"a\"] == 1\n\n    # Series.at getter works with Index of tuples\n    series = df[\"a\"]\n    assert series.index.nlevels == 1\n    assert series.at[(1, 2)] == 1",
        "begin_line": 356,
        "end_line": 366,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.test_at_with_tuple_index_set#369",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar",
        "signature": "pandas.tests.indexing.test_scalar.test_at_with_tuple_index_set()",
        "snippet": "def test_at_with_tuple_index_set():\n    # GH 26989\n    # DataFrame.at setter works with Index of tuples\n    df = DataFrame({\"a\": [1, 2]}, index=[(1, 2), (3, 4)])\n    assert df.index.nlevels == 1\n    df.at[(1, 2), \"a\"] = 2\n    assert df.at[(1, 2), \"a\"] == 2\n\n    # Series.at setter works with Index of tuples\n    series = df[\"a\"]\n    assert series.index.nlevels == 1\n    series.at[1, 2] = 3\n    assert series.at[1, 2] == 3",
        "begin_line": 369,
        "end_line": 381,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.test_multiindex_at_get#384",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar",
        "signature": "pandas.tests.indexing.test_scalar.test_multiindex_at_get()",
        "snippet": "def test_multiindex_at_get():\n    # GH 26989\n    # DataFrame.at and DataFrame.loc getter works with MultiIndex\n    df = DataFrame({\"a\": [1, 2]}, index=[[1, 2], [3, 4]])\n    assert df.index.nlevels == 2\n    assert df.at[(1, 3), \"a\"] == 1\n    assert df.loc[(1, 3), \"a\"] == 1\n\n    # Series.at and Series.loc getter works with MultiIndex\n    series = df[\"a\"]\n    assert series.index.nlevels == 2\n    assert series.at[1, 3] == 1\n    assert series.loc[1, 3] == 1",
        "begin_line": 384,
        "end_line": 396,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.test_multiindex_at_set#399",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar",
        "signature": "pandas.tests.indexing.test_scalar.test_multiindex_at_set()",
        "snippet": "def test_multiindex_at_set():\n    # GH 26989\n    # DataFrame.at and DataFrame.loc setter works with MultiIndex\n    df = DataFrame({\"a\": [1, 2]}, index=[[1, 2], [3, 4]])\n    assert df.index.nlevels == 2\n    df.at[(1, 3), \"a\"] = 3\n    assert df.at[(1, 3), \"a\"] == 3\n    df.loc[(1, 3), \"a\"] = 4\n    assert df.loc[(1, 3), \"a\"] == 4\n\n    # Series.at and Series.loc setter works with MultiIndex\n    series = df[\"a\"]\n    assert series.index.nlevels == 2\n    series.at[1, 3] = 5\n    assert series.at[1, 3] == 5\n    series.loc[1, 3] = 6\n    assert series.loc[1, 3] == 6",
        "begin_line": 399,
        "end_line": 415,
        "comment": "",
        "is_bug": false
    }
]