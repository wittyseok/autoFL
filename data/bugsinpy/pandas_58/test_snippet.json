[
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_validate_ordered#31",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_validate_ordered(self)",
        "snippet": "    def test_validate_ordered(self):\n        # see gh-14058\n        exp_msg = \"'ordered' must either be 'True' or 'False'\"\n        exp_err = TypeError\n\n        # This should be a boolean.\n        ordered = np.array([0, 1, 2])\n\n        with pytest.raises(exp_err, match=exp_msg):\n            Categorical([1, 2, 3], ordered=ordered)\n\n        with pytest.raises(exp_err, match=exp_msg):\n            Categorical.from_codes(\n                [0, 0, 1], categories=[\"a\", \"b\", \"c\"], ordered=ordered\n            )",
        "begin_line": 31,
        "end_line": 45,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_empty#47",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_empty(self)",
        "snippet": "    def test_constructor_empty(self):\n        # GH 17248\n        c = Categorical([])\n        expected = Index([])\n        tm.assert_index_equal(c.categories, expected)\n\n        c = Categorical([], categories=[1, 2, 3])\n        expected = pd.Int64Index([1, 2, 3])\n        tm.assert_index_equal(c.categories, expected)",
        "begin_line": 47,
        "end_line": 55,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_empty_boolean#57",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_empty_boolean(self)",
        "snippet": "    def test_constructor_empty_boolean(self):\n        # see gh-22702\n        cat = pd.Categorical([], categories=[True, False])\n        categories = sorted(cat.categories.tolist())\n        assert categories == [False, True]",
        "begin_line": 57,
        "end_line": 61,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_tuples#63",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_tuples(self)",
        "snippet": "    def test_constructor_tuples(self):\n        values = np.array([(1,), (1, 2), (1,), (1, 2)], dtype=object)\n        result = Categorical(values)\n        expected = Index([(1,), (1, 2)], tupleize_cols=False)\n        tm.assert_index_equal(result.categories, expected)\n        assert result.ordered is False",
        "begin_line": 63,
        "end_line": 68,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_tuples_datetimes#70",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_tuples_datetimes(self)",
        "snippet": "    def test_constructor_tuples_datetimes(self):\n        # numpy will auto reshape when all of the tuples are the\n        # same len, so add an extra one with 2 items and slice it off\n        values = np.array(\n            [\n                (Timestamp(\"2010-01-01\"),),\n                (Timestamp(\"2010-01-02\"),),\n                (Timestamp(\"2010-01-01\"),),\n                (Timestamp(\"2010-01-02\"),),\n                (\"a\", \"b\"),\n            ],\n            dtype=object,\n        )[:-1]\n        result = Categorical(values)\n        expected = Index(\n            [(Timestamp(\"2010-01-01\"),), (Timestamp(\"2010-01-02\"),)],\n            tupleize_cols=False,\n        )\n        tm.assert_index_equal(result.categories, expected)",
        "begin_line": 70,
        "end_line": 88,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_unsortable#90",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_unsortable(self)",
        "snippet": "    def test_constructor_unsortable(self):\n\n        # it works!\n        arr = np.array([1, 2, 3, datetime.now()], dtype=\"O\")\n        factor = Categorical(arr, ordered=False)\n        assert not factor.ordered\n\n        # this however will raise as cannot be sorted\n        msg = (\n            \"'values' is not ordered, please explicitly specify the \"\n            \"categories order by passing in a categories argument.\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            Categorical(arr, ordered=True)",
        "begin_line": 90,
        "end_line": 103,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_interval#105",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_interval(self)",
        "snippet": "    def test_constructor_interval(self):\n        result = Categorical(\n            [Interval(1, 2), Interval(2, 3), Interval(3, 6)], ordered=True\n        )\n        ii = IntervalIndex([Interval(1, 2), Interval(2, 3), Interval(3, 6)])\n        exp = Categorical(ii, ordered=True)\n        tm.assert_categorical_equal(result, exp)\n        tm.assert_index_equal(result.categories, ii)",
        "begin_line": 105,
        "end_line": 112,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor#114",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor(self)",
        "snippet": "    def test_constructor(self):\n\n        exp_arr = np.array([\"a\", \"b\", \"c\", \"a\", \"b\", \"c\"], dtype=np.object_)\n        c1 = Categorical(exp_arr)\n        tm.assert_numpy_array_equal(c1.__array__(), exp_arr)\n        c2 = Categorical(exp_arr, categories=[\"a\", \"b\", \"c\"])\n        tm.assert_numpy_array_equal(c2.__array__(), exp_arr)\n        c2 = Categorical(exp_arr, categories=[\"c\", \"b\", \"a\"])\n        tm.assert_numpy_array_equal(c2.__array__(), exp_arr)\n\n        # categories must be unique\n        msg = \"Categorical categories must be unique\"\n        with pytest.raises(ValueError, match=msg):\n            Categorical([1, 2], [1, 2, 2])\n\n        with pytest.raises(ValueError, match=msg):\n            Categorical([\"a\", \"b\"], [\"a\", \"b\", \"b\"])\n\n        # The default should be unordered\n        c1 = Categorical([\"a\", \"b\", \"c\", \"a\"])\n        assert not c1.ordered\n\n        # Categorical as input\n        c1 = Categorical([\"a\", \"b\", \"c\", \"a\"])\n        c2 = Categorical(c1)\n        tm.assert_categorical_equal(c1, c2)\n\n        c1 = Categorical([\"a\", \"b\", \"c\", \"a\"], categories=[\"a\", \"b\", \"c\", \"d\"])\n        c2 = Categorical(c1)\n        tm.assert_categorical_equal(c1, c2)\n\n        c1 = Categorical([\"a\", \"b\", \"c\", \"a\"], categories=[\"a\", \"c\", \"b\"])\n        c2 = Categorical(c1)\n        tm.assert_categorical_equal(c1, c2)\n\n        c1 = Categorical([\"a\", \"b\", \"c\", \"a\"], categories=[\"a\", \"c\", \"b\"])\n        c2 = Categorical(c1, categories=[\"a\", \"b\", \"c\"])\n        tm.assert_numpy_array_equal(c1.__array__(), c2.__array__())\n        tm.assert_index_equal(c2.categories, Index([\"a\", \"b\", \"c\"]))\n\n        # Series of dtype category\n        c1 = Categorical([\"a\", \"b\", \"c\", \"a\"], categories=[\"a\", \"b\", \"c\", \"d\"])\n        c2 = Categorical(Series(c1))\n        tm.assert_categorical_equal(c1, c2)\n\n        c1 = Categorical([\"a\", \"b\", \"c\", \"a\"], categories=[\"a\", \"c\", \"b\"])\n        c2 = Categorical(Series(c1))\n        tm.assert_categorical_equal(c1, c2)\n\n        # Series\n        c1 = Categorical([\"a\", \"b\", \"c\", \"a\"])\n        c2 = Categorical(Series([\"a\", \"b\", \"c\", \"a\"]))\n        tm.assert_categorical_equal(c1, c2)\n\n        c1 = Categorical([\"a\", \"b\", \"c\", \"a\"], categories=[\"a\", \"b\", \"c\", \"d\"])\n        c2 = Categorical(Series([\"a\", \"b\", \"c\", \"a\"]), categories=[\"a\", \"b\", \"c\", \"d\"])\n        tm.assert_categorical_equal(c1, c2)\n\n        # This should result in integer categories, not float!\n        cat = Categorical([1, 2, 3, np.nan], categories=[1, 2, 3])\n        assert is_integer_dtype(cat.categories)\n\n        # https://github.com/pandas-dev/pandas/issues/3678\n        cat = Categorical([np.nan, 1, 2, 3])\n        assert is_integer_dtype(cat.categories)\n\n        # this should result in floats\n        cat = Categorical([np.nan, 1, 2.0, 3])\n        assert is_float_dtype(cat.categories)\n\n        cat = Categorical([np.nan, 1.0, 2.0, 3.0])\n        assert is_float_dtype(cat.categories)\n\n        # This doesn't work -> this would probably need some kind of \"remember\n        # the original type\" feature to try to cast the array interface result\n        # to...\n\n        # vals = np.asarray(cat[cat.notna()])\n        # assert is_integer_dtype(vals)\n\n        # corner cases\n        cat = Categorical([1])\n        assert len(cat.categories) == 1\n        assert cat.categories[0] == 1\n        assert len(cat.codes) == 1\n        assert cat.codes[0] == 0\n\n        cat = Categorical([\"a\"])\n        assert len(cat.categories) == 1\n        assert cat.categories[0] == \"a\"\n        assert len(cat.codes) == 1\n        assert cat.codes[0] == 0\n\n        # Scalars should be converted to lists\n        cat = Categorical(1)\n        assert len(cat.categories) == 1\n        assert cat.categories[0] == 1\n        assert len(cat.codes) == 1\n        assert cat.codes[0] == 0\n\n        # two arrays\n        #  - when the first is an integer dtype and the second is not\n        #  - when the resulting codes are all -1/NaN\n        with tm.assert_produces_warning(None):\n            c_old = Categorical([0, 1, 2, 0, 1, 2], categories=[\"a\", \"b\", \"c\"])  # noqa\n\n        with tm.assert_produces_warning(None):\n            c_old = Categorical([0, 1, 2, 0, 1, 2], categories=[3, 4, 5])  # noqa\n\n        # the next one are from the old docs\n        with tm.assert_produces_warning(None):\n            c_old2 = Categorical([0, 1, 2, 0, 1, 2], [1, 2, 3])  # noqa\n            cat = Categorical([1, 2], categories=[1, 2, 3])\n\n        # this is a legitimate constructor\n        with tm.assert_produces_warning(None):\n            c = Categorical(  # noqa\n                np.array([], dtype=\"int64\"), categories=[3, 2, 1], ordered=True\n            )",
        "begin_line": 114,
        "end_line": 232,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_with_existing_categories#234",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_with_existing_categories(self)",
        "snippet": "    def test_constructor_with_existing_categories(self):\n        # GH25318: constructing with pd.Series used to bogusly skip recoding\n        # categories\n        c0 = Categorical([\"a\", \"b\", \"c\", \"a\"])\n        c1 = Categorical([\"a\", \"b\", \"c\", \"a\"], categories=[\"b\", \"c\"])\n\n        c2 = Categorical(c0, categories=c1.categories)\n        tm.assert_categorical_equal(c1, c2)\n\n        c3 = Categorical(Series(c0), categories=c1.categories)\n        tm.assert_categorical_equal(c1, c3)",
        "begin_line": 234,
        "end_line": 244,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_not_sequence#246",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_not_sequence(self)",
        "snippet": "    def test_constructor_not_sequence(self):\n        # https://github.com/pandas-dev/pandas/issues/16022\n        msg = r\"^Parameter 'categories' must be list-like, was\"\n        with pytest.raises(TypeError, match=msg):\n            Categorical([\"a\", \"b\"], categories=\"a\")",
        "begin_line": 246,
        "end_line": 250,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_with_null#252",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_with_null(self)",
        "snippet": "    def test_constructor_with_null(self):\n\n        # Cannot have NaN in categories\n        msg = \"Categorial categories cannot be null\"\n        with pytest.raises(ValueError, match=msg):\n            Categorical([np.nan, \"a\", \"b\", \"c\"], categories=[np.nan, \"a\", \"b\", \"c\"])\n\n        with pytest.raises(ValueError, match=msg):\n            Categorical([None, \"a\", \"b\", \"c\"], categories=[None, \"a\", \"b\", \"c\"])\n\n        with pytest.raises(ValueError, match=msg):\n            Categorical(\n                DatetimeIndex([\"nat\", \"20160101\"]),\n                categories=[NaT, Timestamp(\"20160101\")],\n            )",
        "begin_line": 252,
        "end_line": 266,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_with_index#268",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_with_index(self)",
        "snippet": "    def test_constructor_with_index(self):\n        ci = CategoricalIndex(list(\"aabbca\"), categories=list(\"cab\"))\n        tm.assert_categorical_equal(ci.values, Categorical(ci))\n\n        ci = CategoricalIndex(list(\"aabbca\"), categories=list(\"cab\"))\n        tm.assert_categorical_equal(\n            ci.values, Categorical(ci.astype(object), categories=ci.categories)\n        )",
        "begin_line": 268,
        "end_line": 275,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_with_generator#277",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_with_generator(self)",
        "snippet": "    def test_constructor_with_generator(self):\n        # This was raising an Error in isna(single_val).any() because isna\n        # returned a scalar for a generator\n\n        exp = Categorical([0, 1, 2])\n        cat = Categorical((x for x in [0, 1, 2]))\n        tm.assert_categorical_equal(cat, exp)\n        cat = Categorical(range(3))\n        tm.assert_categorical_equal(cat, exp)\n\n        MultiIndex.from_product([range(5), [\"a\", \"b\", \"c\"]])\n\n        # check that categories accept generators and sequences\n        cat = Categorical([0, 1, 2], categories=(x for x in [0, 1, 2]))\n        tm.assert_categorical_equal(cat, exp)\n        cat = Categorical([0, 1, 2], categories=range(3))\n        tm.assert_categorical_equal(cat, exp)",
        "begin_line": 277,
        "end_line": 293,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_with_datetimelike#303",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_with_datetimelike(self, dtl)",
        "snippet": "    def test_constructor_with_datetimelike(self, dtl):\n        # see gh-12077\n        # constructor with a datetimelike and NaT\n\n        s = Series(dtl)\n        c = Categorical(s)\n\n        expected = type(dtl)(s)\n        expected._data.freq = None\n\n        tm.assert_index_equal(c.categories, expected)\n        tm.assert_numpy_array_equal(c.codes, np.arange(5, dtype=\"int8\"))\n\n        # with NaT\n        s2 = s.copy()\n        s2.iloc[-1] = NaT\n        c = Categorical(s2)\n\n        expected = type(dtl)(s2.dropna())\n        expected._data.freq = None\n\n        tm.assert_index_equal(c.categories, expected)\n\n        exp = np.array([0, 1, 2, 3, -1], dtype=np.int8)\n        tm.assert_numpy_array_equal(c.codes, exp)\n\n        result = repr(c)\n        assert \"NaT\" in result",
        "begin_line": 303,
        "end_line": 330,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_from_index_series_datetimetz#332",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_from_index_series_datetimetz(self)",
        "snippet": "    def test_constructor_from_index_series_datetimetz(self):\n        idx = date_range(\"2015-01-01 10:00\", freq=\"D\", periods=3, tz=\"US/Eastern\")\n        result = Categorical(idx)\n        tm.assert_index_equal(result.categories, idx)\n\n        result = Categorical(Series(idx))\n        tm.assert_index_equal(result.categories, idx)",
        "begin_line": 332,
        "end_line": 338,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_from_index_series_timedelta#340",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_from_index_series_timedelta(self)",
        "snippet": "    def test_constructor_from_index_series_timedelta(self):\n        idx = timedelta_range(\"1 days\", freq=\"D\", periods=3)\n        result = Categorical(idx)\n        tm.assert_index_equal(result.categories, idx)\n\n        result = Categorical(Series(idx))\n        tm.assert_index_equal(result.categories, idx)",
        "begin_line": 340,
        "end_line": 346,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_from_index_series_period#348",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_from_index_series_period(self)",
        "snippet": "    def test_constructor_from_index_series_period(self):\n        idx = period_range(\"2015-01-01\", freq=\"D\", periods=3)\n        result = Categorical(idx)\n        tm.assert_index_equal(result.categories, idx)\n\n        result = Categorical(Series(idx))\n        tm.assert_index_equal(result.categories, idx)",
        "begin_line": 348,
        "end_line": 354,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_invariant#356",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_invariant(self)",
        "snippet": "    def test_constructor_invariant(self):\n        # GH 14190\n        vals = [\n            np.array([1.0, 1.2, 1.8, np.nan]),\n            np.array([1, 2, 3], dtype=\"int64\"),\n            [\"a\", \"b\", \"c\", np.nan],\n            [pd.Period(\"2014-01\"), pd.Period(\"2014-02\"), NaT],\n            [Timestamp(\"2014-01-01\"), Timestamp(\"2014-01-02\"), NaT],\n            [\n                Timestamp(\"2014-01-01\", tz=\"US/Eastern\"),\n                Timestamp(\"2014-01-02\", tz=\"US/Eastern\"),\n                NaT,\n            ],\n        ]\n        for val in vals:\n            c = Categorical(val)\n            c2 = Categorical(c)\n            tm.assert_categorical_equal(c, c2)",
        "begin_line": 356,
        "end_line": 373,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_with_dtype#376",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_with_dtype(self, ordered)",
        "snippet": "    def test_constructor_with_dtype(self, ordered):\n        categories = [\"b\", \"a\", \"c\"]\n        dtype = CategoricalDtype(categories, ordered=ordered)\n        result = Categorical([\"a\", \"b\", \"a\", \"c\"], dtype=dtype)\n        expected = Categorical(\n            [\"a\", \"b\", \"a\", \"c\"], categories=categories, ordered=ordered\n        )\n        tm.assert_categorical_equal(result, expected)\n        assert result.ordered is ordered",
        "begin_line": 376,
        "end_line": 384,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_dtype_and_others_raises#386",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_dtype_and_others_raises(self)",
        "snippet": "    def test_constructor_dtype_and_others_raises(self):\n        dtype = CategoricalDtype([\"a\", \"b\"], ordered=True)\n        msg = \"Cannot specify `categories` or `ordered` together with `dtype`.\"\n        with pytest.raises(ValueError, match=msg):\n            Categorical([\"a\", \"b\"], categories=[\"a\", \"b\"], dtype=dtype)\n\n        with pytest.raises(ValueError, match=msg):\n            Categorical([\"a\", \"b\"], ordered=True, dtype=dtype)\n\n        with pytest.raises(ValueError, match=msg):\n            Categorical([\"a\", \"b\"], ordered=False, dtype=dtype)",
        "begin_line": 386,
        "end_line": 396,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_str_category#400",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_str_category(self, categories, ordered)",
        "snippet": "    def test_constructor_str_category(self, categories, ordered):\n        result = Categorical(\n            [\"a\", \"b\"], categories=categories, ordered=ordered, dtype=\"category\"\n        )\n        expected = Categorical([\"a\", \"b\"], categories=categories, ordered=ordered)\n        tm.assert_categorical_equal(result, expected)",
        "begin_line": 400,
        "end_line": 405,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_str_unknown#407",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_str_unknown(self)",
        "snippet": "    def test_constructor_str_unknown(self):\n        with pytest.raises(ValueError, match=\"Unknown dtype\"):\n            Categorical([1, 2], dtype=\"foo\")",
        "begin_line": 407,
        "end_line": 409,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_np_strs#411",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_np_strs(self)",
        "snippet": "    def test_constructor_np_strs(self):\n        # GH#31499 Hastable.map_locations needs to work on np.str_ objects\n        cat = pd.Categorical([\"1\", \"0\", \"1\"], [np.str_(\"0\"), np.str_(\"1\")])\n        assert all(isinstance(x, np.str_) for x in cat.categories)",
        "begin_line": 411,
        "end_line": 414,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_from_categorical_with_dtype#416",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_from_categorical_with_dtype(self)",
        "snippet": "    def test_constructor_from_categorical_with_dtype(self):\n        dtype = CategoricalDtype([\"a\", \"b\", \"c\"], ordered=True)\n        values = Categorical([\"a\", \"b\", \"d\"])\n        result = Categorical(values, dtype=dtype)\n        # We use dtype.categories, not values.categories\n        expected = Categorical(\n            [\"a\", \"b\", \"d\"], categories=[\"a\", \"b\", \"c\"], ordered=True\n        )\n        tm.assert_categorical_equal(result, expected)",
        "begin_line": 416,
        "end_line": 424,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_from_categorical_with_unknown_dtype#426",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_from_categorical_with_unknown_dtype(self)",
        "snippet": "    def test_constructor_from_categorical_with_unknown_dtype(self):\n        dtype = CategoricalDtype(None, ordered=True)\n        values = Categorical([\"a\", \"b\", \"d\"])\n        result = Categorical(values, dtype=dtype)\n        # We use values.categories, not dtype.categories\n        expected = Categorical(\n            [\"a\", \"b\", \"d\"], categories=[\"a\", \"b\", \"d\"], ordered=True\n        )\n        tm.assert_categorical_equal(result, expected)",
        "begin_line": 426,
        "end_line": 434,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_from_categorical_string#436",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_from_categorical_string(self)",
        "snippet": "    def test_constructor_from_categorical_string(self):\n        values = Categorical([\"a\", \"b\", \"d\"])\n        # use categories, ordered\n        result = Categorical(\n            values, categories=[\"a\", \"b\", \"c\"], ordered=True, dtype=\"category\"\n        )\n        expected = Categorical(\n            [\"a\", \"b\", \"d\"], categories=[\"a\", \"b\", \"c\"], ordered=True\n        )\n        tm.assert_categorical_equal(result, expected)\n\n        # No string\n        result = Categorical(values, categories=[\"a\", \"b\", \"c\"], ordered=True)\n        tm.assert_categorical_equal(result, expected)",
        "begin_line": 436,
        "end_line": 449,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_with_categorical_categories#451",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_with_categorical_categories(self)",
        "snippet": "    def test_constructor_with_categorical_categories(self):\n        # GH17884\n        expected = Categorical([\"a\", \"b\"], categories=[\"a\", \"b\", \"c\"])\n\n        result = Categorical([\"a\", \"b\"], categories=Categorical([\"a\", \"b\", \"c\"]))\n        tm.assert_categorical_equal(result, expected)\n\n        result = Categorical([\"a\", \"b\"], categories=CategoricalIndex([\"a\", \"b\", \"c\"]))\n        tm.assert_categorical_equal(result, expected)",
        "begin_line": 451,
        "end_line": 459,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_codes#461",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_codes(self)",
        "snippet": "    def test_from_codes(self):\n\n        # too few categories\n        dtype = CategoricalDtype(categories=[1, 2])\n        msg = \"codes need to be between \"\n        with pytest.raises(ValueError, match=msg):\n            Categorical.from_codes([1, 2], categories=dtype.categories)\n        with pytest.raises(ValueError, match=msg):\n            Categorical.from_codes([1, 2], dtype=dtype)\n\n        # no int codes\n        msg = \"codes need to be array-like integers\"\n        with pytest.raises(ValueError, match=msg):\n            Categorical.from_codes([\"a\"], categories=dtype.categories)\n        with pytest.raises(ValueError, match=msg):\n            Categorical.from_codes([\"a\"], dtype=dtype)\n\n        # no unique categories\n        with pytest.raises(ValueError, match=\"Categorical categories must be unique\"):\n            Categorical.from_codes([0, 1, 2], categories=[\"a\", \"a\", \"b\"])\n\n        # NaN categories included\n        with pytest.raises(ValueError, match=\"Categorial categories cannot be null\"):\n            Categorical.from_codes([0, 1, 2], categories=[\"a\", \"b\", np.nan])\n\n        # too negative\n        dtype = CategoricalDtype(categories=[\"a\", \"b\", \"c\"])\n        msg = r\"codes need to be between -1 and len\\(categories\\)-1\"\n        with pytest.raises(ValueError, match=msg):\n            Categorical.from_codes([-2, 1, 2], categories=dtype.categories)\n        with pytest.raises(ValueError, match=msg):\n            Categorical.from_codes([-2, 1, 2], dtype=dtype)\n\n        exp = Categorical([\"a\", \"b\", \"c\"], ordered=False)\n        res = Categorical.from_codes([0, 1, 2], categories=dtype.categories)\n        tm.assert_categorical_equal(exp, res)\n\n        res = Categorical.from_codes([0, 1, 2], dtype=dtype)\n        tm.assert_categorical_equal(exp, res)",
        "begin_line": 461,
        "end_line": 499,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_codes_with_categorical_categories#501",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_codes_with_categorical_categories(self)",
        "snippet": "    def test_from_codes_with_categorical_categories(self):\n        # GH17884\n        expected = Categorical([\"a\", \"b\"], categories=[\"a\", \"b\", \"c\"])\n\n        result = Categorical.from_codes([0, 1], categories=Categorical([\"a\", \"b\", \"c\"]))\n        tm.assert_categorical_equal(result, expected)\n\n        result = Categorical.from_codes(\n            [0, 1], categories=CategoricalIndex([\"a\", \"b\", \"c\"])\n        )\n        tm.assert_categorical_equal(result, expected)\n\n        # non-unique Categorical still raises\n        with pytest.raises(ValueError, match=\"Categorical categories must be unique\"):\n            Categorical.from_codes([0, 1], Categorical([\"a\", \"b\", \"a\"]))",
        "begin_line": 501,
        "end_line": 515,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_codes_with_nan_code#517",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_codes_with_nan_code(self)",
        "snippet": "    def test_from_codes_with_nan_code(self):\n        # GH21767\n        codes = [1, 2, np.nan]\n        dtype = CategoricalDtype(categories=[\"a\", \"b\", \"c\"])\n        with pytest.raises(ValueError, match=\"codes need to be array-like integers\"):\n            Categorical.from_codes(codes, categories=dtype.categories)\n        with pytest.raises(ValueError, match=\"codes need to be array-like integers\"):\n            Categorical.from_codes(codes, dtype=dtype)",
        "begin_line": 517,
        "end_line": 524,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_codes_with_float#526",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_codes_with_float(self)",
        "snippet": "    def test_from_codes_with_float(self):\n        # GH21767\n        codes = [1.0, 2.0, 0]  # integer, but in float dtype\n        dtype = CategoricalDtype(categories=[\"a\", \"b\", \"c\"])\n\n        # empty codes should not raise for floats\n        Categorical.from_codes([], dtype.categories)\n\n        with pytest.raises(ValueError, match=\"codes need to be array-like integers\"):\n            Categorical.from_codes(codes, dtype.categories)\n\n        with pytest.raises(ValueError, match=\"codes need to be array-like integers\"):\n            Categorical.from_codes(codes, dtype=dtype)\n\n        codes = [1.1, 2.0, 0]  # non-integer\n        with pytest.raises(ValueError, match=\"codes need to be array-like integers\"):\n            Categorical.from_codes(codes, dtype.categories)\n        with pytest.raises(ValueError, match=\"codes need to be array-like integers\"):\n            Categorical.from_codes(codes, dtype=dtype)",
        "begin_line": 526,
        "end_line": 544,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_codes_with_dtype_raises#546",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_codes_with_dtype_raises(self)",
        "snippet": "    def test_from_codes_with_dtype_raises(self):\n        msg = \"Cannot specify\"\n        with pytest.raises(ValueError, match=msg):\n            Categorical.from_codes(\n                [0, 1], categories=[\"a\", \"b\"], dtype=CategoricalDtype([\"a\", \"b\"])\n            )\n\n        with pytest.raises(ValueError, match=msg):\n            Categorical.from_codes(\n                [0, 1], ordered=True, dtype=CategoricalDtype([\"a\", \"b\"])\n            )",
        "begin_line": 546,
        "end_line": 556,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_codes_neither#558",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_codes_neither(self)",
        "snippet": "    def test_from_codes_neither(self):\n        msg = \"Both were None\"\n        with pytest.raises(ValueError, match=msg):\n            Categorical.from_codes([0, 1])",
        "begin_line": 558,
        "end_line": 561,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_codes_with_nullable_int#563",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_codes_with_nullable_int(self)",
        "snippet": "    def test_from_codes_with_nullable_int(self):\n        codes = pd.array([0, 1], dtype=\"Int64\")\n        categories = [\"a\", \"b\"]\n\n        result = Categorical.from_codes(codes, categories=categories)\n        expected = Categorical.from_codes(codes.to_numpy(int), categories=categories)\n\n        tm.assert_categorical_equal(result, expected)",
        "begin_line": 563,
        "end_line": 570,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_codes_with_nullable_int_na_raises#572",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_codes_with_nullable_int_na_raises(self)",
        "snippet": "    def test_from_codes_with_nullable_int_na_raises(self):\n        codes = pd.array([0, None], dtype=\"Int64\")\n        categories = [\"a\", \"b\"]\n\n        msg = \"codes cannot contain NA values\"\n        with pytest.raises(ValueError, match=msg):\n            Categorical.from_codes(codes, categories=categories)",
        "begin_line": 572,
        "end_line": 578,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_inferred_categories#581",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_inferred_categories(self, dtype)",
        "snippet": "    def test_from_inferred_categories(self, dtype):\n        cats = [\"a\", \"b\"]\n        codes = np.array([0, 0, 1, 1], dtype=\"i8\")\n        result = Categorical._from_inferred_categories(cats, codes, dtype)\n        expected = Categorical.from_codes(codes, cats)\n        tm.assert_categorical_equal(result, expected)",
        "begin_line": 581,
        "end_line": 586,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_inferred_categories_sorts#589",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_inferred_categories_sorts(self, dtype)",
        "snippet": "    def test_from_inferred_categories_sorts(self, dtype):\n        cats = [\"b\", \"a\"]\n        codes = np.array([0, 1, 1, 1], dtype=\"i8\")\n        result = Categorical._from_inferred_categories(cats, codes, dtype)\n        expected = Categorical.from_codes([1, 0, 0, 0], [\"a\", \"b\"])\n        tm.assert_categorical_equal(result, expected)",
        "begin_line": 589,
        "end_line": 594,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_inferred_categories_dtype#596",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_inferred_categories_dtype(self)",
        "snippet": "    def test_from_inferred_categories_dtype(self):\n        cats = [\"a\", \"b\", \"d\"]\n        codes = np.array([0, 1, 0, 2], dtype=\"i8\")\n        dtype = CategoricalDtype([\"c\", \"b\", \"a\"], ordered=True)\n        result = Categorical._from_inferred_categories(cats, codes, dtype)\n        expected = Categorical(\n            [\"a\", \"b\", \"a\", \"d\"], categories=[\"c\", \"b\", \"a\"], ordered=True\n        )\n        tm.assert_categorical_equal(result, expected)",
        "begin_line": 596,
        "end_line": 604,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_inferred_categories_coerces#606",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_from_inferred_categories_coerces(self)",
        "snippet": "    def test_from_inferred_categories_coerces(self):\n        cats = [\"1\", \"2\", \"bad\"]\n        codes = np.array([0, 0, 1, 2], dtype=\"i8\")\n        dtype = CategoricalDtype([1, 2])\n        result = Categorical._from_inferred_categories(cats, codes, dtype)\n        expected = Categorical([1, 1, 2, np.nan])\n        tm.assert_categorical_equal(result, expected)",
        "begin_line": 606,
        "end_line": 612,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_construction_with_ordered#615",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_construction_with_ordered(self, ordered)",
        "snippet": "    def test_construction_with_ordered(self, ordered):\n        # GH 9347, 9190\n        cat = Categorical([0, 1, 2], ordered=ordered)\n        assert cat.ordered == bool(ordered)",
        "begin_line": 615,
        "end_line": 618,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_imaginary#621",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_imaginary(self)",
        "snippet": "    def test_constructor_imaginary(self):\n        values = [1, 2, 3 + 1j]\n        c1 = Categorical(values)\n        tm.assert_index_equal(c1.categories, Index(values))\n        tm.assert_numpy_array_equal(np.array(c1), np.array(values))",
        "begin_line": 621,
        "end_line": 625,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_string_and_tuples#628",
        "src_path": "pandas/tests/arrays/categorical/test_constructors.py",
        "class_name": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors",
        "signature": "pandas.tests.arrays.categorical.test_constructors.TestCategoricalConstructors.test_constructor_string_and_tuples(self)",
        "snippet": "    def test_constructor_string_and_tuples(self):\n        # GH 21416\n        c = pd.Categorical(np.array([\"c\", (\"a\", \"b\"), (\"b\", \"a\"), \"c\"], dtype=object))\n        expected_index = pd.Index([(\"a\", \"b\"), (\"b\", \"a\"), \"c\"])\n        assert c.categories.equals(expected_index)",
        "begin_line": 628,
        "end_line": 632,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.conftest.allow_fill#5",
        "src_path": "pandas/tests/arrays/categorical/conftest.py",
        "class_name": "pandas.tests.arrays.categorical.conftest",
        "signature": "pandas.tests.arrays.categorical.conftest.allow_fill(request)",
        "snippet": "def allow_fill(request):\n    \"\"\"Boolean 'allow_fill' parameter for Categorical.take\"\"\"\n    return request.param",
        "begin_line": 5,
        "end_line": 7,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.base.base.BaseExtensionTests.assert_series_equal#12",
        "src_path": "pandas/tests/extension/base/base.py",
        "class_name": "pandas.tests.extension.base.base.BaseExtensionTests",
        "signature": "pandas.tests.extension.base.base.BaseExtensionTests.assert_series_equal(cls, left, right, *args, **kwargs)",
        "snippet": "    def assert_series_equal(cls, left, right, *args, **kwargs):\n        return tm.assert_series_equal(left, right, *args, **kwargs)",
        "begin_line": 12,
        "end_line": 13,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.base.ops.BaseOpsUtil.get_op_from_name#13",
        "src_path": "pandas/tests/extension/base/ops.py",
        "class_name": "pandas.tests.extension.base.ops.BaseOpsUtil",
        "signature": "pandas.tests.extension.base.ops.BaseOpsUtil.get_op_from_name(self, op_name)",
        "snippet": "    def get_op_from_name(self, op_name):\n        short_opname = op_name.strip(\"_\")\n        try:\n            op = getattr(operator, short_opname)\n        except AttributeError:\n            # Assume it is the reverse operator\n            rop = getattr(operator, short_opname[1:])\n            op = lambda x, y: rop(y, x)\n\n        return op",
        "begin_line": 13,
        "end_line": 22,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.common.TestCategorical.setup_method#5",
        "src_path": "pandas/tests/arrays/categorical/common.py",
        "class_name": "pandas.tests.arrays.categorical.common.TestCategorical",
        "signature": "pandas.tests.arrays.categorical.common.TestCategorical.setup_method(self, method)",
        "snippet": "    def setup_method(self, method):\n        self.factor = Categorical(\n            [\"a\", \"b\", \"b\", \"a\", \"a\", \"c\", \"c\", \"c\"], ordered=True\n        )",
        "begin_line": 5,
        "end_line": 8,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalDtype.__init__#24",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalDtype",
        "signature": "pandas.tests.extension.decimal.array.DecimalDtype.__init__(self, context=None)",
        "snippet": "    def __init__(self, context=None):\n        self.context = context or decimal.getcontext()",
        "begin_line": 24,
        "end_line": 25,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalDtype.construct_array_type#31",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalDtype",
        "signature": "pandas.tests.extension.decimal.array.DecimalDtype.construct_array_type(cls)",
        "snippet": "    def construct_array_type(cls) -> Type[\"DecimalArray\"]:\n        \"\"\"\n        Return the array type associated with this dtype.\n\n        Returns\n        -------\n        type\n        \"\"\"\n        return DecimalArray",
        "begin_line": 31,
        "end_line": 39,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.__init__#49",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.__init__(self, values, dtype=None, copy=False, context=None)",
        "snippet": "    def __init__(self, values, dtype=None, copy=False, context=None):\n        for val in values:\n            if not isinstance(val, decimal.Decimal):\n                raise TypeError(\"All values must be of type \" + str(decimal.Decimal))\n        values = np.asarray(values, dtype=object)\n\n        self._data = values\n        # Some aliases for common attribute names to ensure pandas supports\n        # these\n        self._items = self.data = self._data\n        # those aliases are currently not working due to assumptions\n        # in internal code (GH-20735)\n        # self._values = self.values = self.data\n        self._dtype = DecimalDtype(context)",
        "begin_line": 49,
        "end_line": 62,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.dtype#65",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.dtype(self)",
        "snippet": "    def dtype(self):\n        return self._dtype",
        "begin_line": 65,
        "end_line": 66,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray._from_sequence#69",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray._from_sequence(cls, scalars, dtype=None, copy=False)",
        "snippet": "    def _from_sequence(cls, scalars, dtype=None, copy=False):\n        return cls(scalars)",
        "begin_line": 69,
        "end_line": 70,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.__getitem__#109",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.__getitem__(self, item)",
        "snippet": "    def __getitem__(self, item):\n        if isinstance(item, numbers.Integral):\n            return self._data[item]\n        else:\n            # array, slice.\n            item = pd.api.indexers.check_array_indexer(self, item)\n            return type(self)(self._data[item])",
        "begin_line": 109,
        "end_line": 115,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.astype#130",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.astype(self, dtype, copy=True)",
        "snippet": "    def astype(self, dtype, copy=True):\n        if isinstance(dtype, type(self.dtype)):\n            return type(self)(self._data, context=dtype.context)\n        return np.asarray(self, dtype=dtype)",
        "begin_line": 130,
        "end_line": 133,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.__len__#146",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.__len__(self)",
        "snippet": "    def __len__(self) -> int:\n        return len(self._data)",
        "begin_line": 146,
        "end_line": 147,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.isna#156",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.isna(self)",
        "snippet": "    def isna(self):\n        return np.array([x.is_nan() for x in self._data], dtype=bool)",
        "begin_line": 156,
        "end_line": 157,
        "comment": "",
        "is_bug": false
    }
]