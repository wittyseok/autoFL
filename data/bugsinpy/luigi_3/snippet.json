[
    {
        "name": "luigi.contrib.external_daily_snapshot.ExternalDailySnapshot.latest#55",
        "src_path": "luigi/contrib/external_daily_snapshot.py",
        "class_name": "luigi.contrib.external_daily_snapshot.ExternalDailySnapshot",
        "signature": "luigi.contrib.external_daily_snapshot.ExternalDailySnapshot.latest(cls, *args, **kwargs)",
        "snippet": "    def latest(cls, *args, **kwargs):\n        \"\"\"This is cached so that requires() is deterministic.\"\"\"\n        date = kwargs.pop(\"date\", datetime.date.today())\n        lookback = kwargs.pop(\"lookback\", 14)\n        # hashing kwargs deterministically would be hard. Let's just lookup by equality\n        key = (cls, args, kwargs, lookback, date)\n        for k, v in ExternalDailySnapshot.__cache:\n            if k == key:\n                return v\n        val = cls.__latest(date, lookback, args, kwargs)\n        ExternalDailySnapshot.__cache.append((key, val))\n        return val",
        "begin_line": 55,
        "end_line": 66,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.external_daily_snapshot.ExternalDailySnapshot.__latest#69",
        "src_path": "luigi/contrib/external_daily_snapshot.py",
        "class_name": "luigi.contrib.external_daily_snapshot.ExternalDailySnapshot",
        "signature": "luigi.contrib.external_daily_snapshot.ExternalDailySnapshot.__latest(cls, date, lookback, args, kwargs)",
        "snippet": "    def __latest(cls, date, lookback, args, kwargs):\n        assert lookback > 0\n        t = None\n        for i in xrange(lookback):\n            d = date - datetime.timedelta(i)\n            t = cls(date=d, *args, **kwargs)\n            if t.complete():\n                return t\n        logger.debug(\"Could not find last dump for %s (looked back %d days)\",\n                     cls.__name__, lookback)\n        return t",
        "begin_line": 69,
        "end_line": 79,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__init__#63",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__init__(self, date_a, date_b)",
        "snippet": "    def __init__(self, date_a, date_b):\n        self.date_a = date_a\n        self.date_b = date_b",
        "begin_line": 63,
        "end_line": 65,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00018264840182648402,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.dates#67",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.dates(self)",
        "snippet": "    def dates(self):\n        ''' Returns a list of dates in this date interval.'''\n        dates = []\n        d = self.date_a\n        while d < self.date_b:\n            dates.append(d)\n            d += datetime.timedelta(1)\n\n        return dates",
        "begin_line": 67,
        "end_line": 75,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002294630564479119,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.hours#77",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.hours(self)",
        "snippet": "    def hours(self):\n        ''' Same as dates() but returns 24 times more info: one for each hour.'''\n        for date in self.dates():\n            for hour in xrange(24):\n                yield datetime.datetime.combine(date, datetime.time(hour))",
        "begin_line": 77,
        "end_line": 81,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__str__#83",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__str__(self)",
        "snippet": "    def __str__(self):\n        return self.to_string()",
        "begin_line": 83,
        "end_line": 84,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__repr__#86",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__repr__(self)",
        "snippet": "    def __repr__(self):\n        return self.to_string()",
        "begin_line": 86,
        "end_line": 87,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.prev#89",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.prev(self)",
        "snippet": "    def prev(self):\n        ''' Returns the preceding corresponding date interval (eg. May -> April).'''\n        return self.from_date(self.date_a - datetime.timedelta(1))",
        "begin_line": 89,
        "end_line": 91,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.next#93",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.next(self)",
        "snippet": "    def next(self):\n        ''' Returns the subsequent corresponding date interval (eg. 2014 -> 2015).'''\n        return self.from_date(self.date_b)",
        "begin_line": 93,
        "end_line": 95,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.from_date#101",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.from_date(cls, d)",
        "snippet": "    def from_date(cls, d):\n        ''' Abstract class method.\n\n        For instance, ``Month.from_date(datetime.date(2012, 6, 6))`` returns a ``Month(2012, 6)``.'''\n        raise NotImplementedError",
        "begin_line": 101,
        "end_line": 105,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__hash__#121",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__hash__(self)",
        "snippet": "    def __hash__(self):\n        return hash(repr(self))",
        "begin_line": 121,
        "end_line": 122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__lt__#131",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__lt__(self, other)",
        "snippet": "    def __lt__(self, other):\n        if not isinstance(self, type(other)):\n            raise TypeError('Date interval type mismatch')\n        return (self.date_a, self.date_b) < (other.date_a, other.date_b)",
        "begin_line": 131,
        "end_line": 134,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__le__#136",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__le__(self, other)",
        "snippet": "    def __le__(self, other):\n        if not isinstance(self, type(other)):\n            raise TypeError('Date interval type mismatch')\n        return (self.date_a, self.date_b) <= (other.date_a, other.date_b)",
        "begin_line": 136,
        "end_line": 139,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__gt__#141",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__gt__(self, other)",
        "snippet": "    def __gt__(self, other):\n        if not isinstance(self, type(other)):\n            raise TypeError('Date interval type mismatch')\n        return (self.date_a, self.date_b) > (other.date_a, other.date_b)",
        "begin_line": 141,
        "end_line": 144,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__ge__#146",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__ge__(self, other)",
        "snippet": "    def __ge__(self, other):\n        if not isinstance(self, type(other)):\n            raise TypeError('Date interval type mismatch')\n        return (self.date_a, self.date_b) >= (other.date_a, other.date_b)",
        "begin_line": 146,
        "end_line": 149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__eq__#151",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__eq__(self, other)",
        "snippet": "    def __eq__(self, other):\n        if not isinstance(other, DateInterval):\n            return False\n        if not isinstance(self, type(other)):\n            raise TypeError('Date interval type mismatch')\n        else:\n            return (self.date_a, self.date_b) == (other.date_a, other.date_b)",
        "begin_line": 151,
        "end_line": 157,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__ne__#159",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__ne__(self, other)",
        "snippet": "    def __ne__(self, other):\n        return not self.__eq__(other)",
        "begin_line": 159,
        "end_line": 160,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.Date.__init__#167",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Date",
        "signature": "luigi.date_interval.Date.__init__(self, y, m, d)",
        "snippet": "    def __init__(self, y, m, d):\n        a = datetime.date(y, m, d)\n        b = datetime.date(y, m, d) + datetime.timedelta(1)\n        super(Date, self).__init__(a, b)",
        "begin_line": 167,
        "end_line": 170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.Date.to_string#172",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Date",
        "signature": "luigi.date_interval.Date.to_string(self)",
        "snippet": "    def to_string(self):\n        return self.date_a.strftime('%Y-%m-%d')",
        "begin_line": 172,
        "end_line": 173,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.Date.from_date#176",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Date",
        "signature": "luigi.date_interval.Date.from_date(cls, d)",
        "snippet": "    def from_date(cls, d):\n        return Date(d.year, d.month, d.day)",
        "begin_line": 176,
        "end_line": 177,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.Date.parse#180",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Date",
        "signature": "luigi.date_interval.Date.parse(cls, s)",
        "snippet": "    def parse(cls, s):\n        if re.match(r'\\d\\d\\d\\d\\-\\d\\d\\-\\d\\d$', s):\n            return Date(*map(int, s.split('-')))",
        "begin_line": 180,
        "end_line": 182,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.Week.__init__#191",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Week",
        "signature": "luigi.date_interval.Week.__init__(self, y, w)",
        "snippet": "    def __init__(self, y, w):\n        ''' Python datetime does not have a method to convert from ISO weeks, so the constructor uses some stupid brute force'''\n        for d in xrange(-10, 370):\n            date = datetime.date(y, 1, 1) + datetime.timedelta(d)\n            if date.isocalendar() == (y, w, 1):\n                date_a = date\n                break\n        else:\n            raise ValueError('Invalid week')\n        date_b = date_a + datetime.timedelta(7)\n        super(Week, self).__init__(date_a, date_b)",
        "begin_line": 191,
        "end_line": 201,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.Week.to_string#203",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Week",
        "signature": "luigi.date_interval.Week.to_string(self)",
        "snippet": "    def to_string(self):\n        return '%d-W%02d' % self.date_a.isocalendar()[:2]",
        "begin_line": 203,
        "end_line": 204,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.Week.from_date#207",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Week",
        "signature": "luigi.date_interval.Week.from_date(cls, d)",
        "snippet": "    def from_date(cls, d):\n        return Week(*d.isocalendar()[:2])",
        "begin_line": 207,
        "end_line": 208,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.Week.parse#211",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Week",
        "signature": "luigi.date_interval.Week.parse(cls, s)",
        "snippet": "    def parse(cls, s):\n        if re.match(r'\\d\\d\\d\\d\\-W\\d\\d$', s):\n            y, w = map(int, s.split('-W'))\n            return Week(y, w)",
        "begin_line": 211,
        "end_line": 214,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.Month.__init__#219",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Month",
        "signature": "luigi.date_interval.Month.__init__(self, y, m)",
        "snippet": "    def __init__(self, y, m):\n        date_a = datetime.date(y, m, 1)\n        date_b = datetime.date(y + m // 12, 1 + m % 12, 1)\n        super(Month, self).__init__(date_a, date_b)",
        "begin_line": 219,
        "end_line": 222,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.Month.to_string#224",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Month",
        "signature": "luigi.date_interval.Month.to_string(self)",
        "snippet": "    def to_string(self):\n        return self.date_a.strftime('%Y-%m')",
        "begin_line": 224,
        "end_line": 225,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.Month.from_date#228",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Month",
        "signature": "luigi.date_interval.Month.from_date(cls, d)",
        "snippet": "    def from_date(cls, d):\n        return Month(d.year, d.month)",
        "begin_line": 228,
        "end_line": 229,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.Month.parse#232",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Month",
        "signature": "luigi.date_interval.Month.parse(cls, s)",
        "snippet": "    def parse(cls, s):\n        if re.match(r'\\d\\d\\d\\d\\-\\d\\d$', s):\n            y, m = map(int, s.split('-'))\n            return Month(y, m)",
        "begin_line": 232,
        "end_line": 235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.Year.__init__#240",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Year",
        "signature": "luigi.date_interval.Year.__init__(self, y)",
        "snippet": "    def __init__(self, y):\n        date_a = datetime.date(y, 1, 1)\n        date_b = datetime.date(y + 1, 1, 1)\n        super(Year, self).__init__(date_a, date_b)",
        "begin_line": 240,
        "end_line": 243,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00022331397945511388,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.Year.to_string#245",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Year",
        "signature": "luigi.date_interval.Year.to_string(self)",
        "snippet": "    def to_string(self):\n        return self.date_a.strftime('%Y')",
        "begin_line": 245,
        "end_line": 246,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.Year.from_date#249",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Year",
        "signature": "luigi.date_interval.Year.from_date(cls, d)",
        "snippet": "    def from_date(cls, d):\n        return Year(d.year)",
        "begin_line": 249,
        "end_line": 250,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.Year.parse#253",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Year",
        "signature": "luigi.date_interval.Year.parse(cls, s)",
        "snippet": "    def parse(cls, s):\n        if re.match(r'\\d\\d\\d\\d$', s):\n            return Year(int(s))",
        "begin_line": 253,
        "end_line": 255,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.Custom.to_string#266",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Custom",
        "signature": "luigi.date_interval.Custom.to_string(self)",
        "snippet": "    def to_string(self):\n        return '-'.join([d.strftime('%Y-%m-%d') for d in (self.date_a, self.date_b)])",
        "begin_line": 266,
        "end_line": 267,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.date_interval.Custom.parse#270",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Custom",
        "signature": "luigi.date_interval.Custom.parse(cls, s)",
        "snippet": "    def parse(cls, s):\n        if re.match(r'\\d\\d\\d\\d\\-\\d\\d\\-\\d\\d\\-\\d\\d\\d\\d\\-\\d\\d\\-\\d\\d$', s):\n            x = list(map(int, s.split('-')))\n            date_a = datetime.date(*x[:3])\n            date_b = datetime.date(*x[3:])\n            return Custom(date_a, date_b)",
        "begin_line": 270,
        "end_line": 275,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.copy#40",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.copy(self, path, dest, raise_if_exists=False)",
        "snippet": "    def copy(self, path, dest, raise_if_exists=False):\n        \"\"\"\n        Copies the contents of a single file path to dest\n        \"\"\"\n        if raise_if_exists and dest in self.get_all_data():\n            raise RuntimeError('Destination exists: %s' % path)\n        contents = self.get_all_data()[path]\n        self.get_all_data()[dest] = contents",
        "begin_line": 40,
        "end_line": 47,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.get_all_data#49",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.get_all_data(self)",
        "snippet": "    def get_all_data(self):\n        # This starts a server in the background, so we don't want to do it in the global scope\n        if MockFileSystem._data is None:\n            MockFileSystem._data = multiprocessing.Manager().dict()\n        return MockFileSystem._data",
        "begin_line": 49,
        "end_line": 53,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010548523206751054,
            "pseudo_dstar_susp": 0.0008756567425569177,
            "pseudo_tarantula_susp": 0.001303780964797914,
            "pseudo_op2_susp": 0.0008756567425569177,
            "pseudo_barinel_susp": 0.001303780964797914
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.get_data#55",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.get_data(self, fn)",
        "snippet": "    def get_data(self, fn):\n        return self.get_all_data()[fn]",
        "begin_line": 55,
        "end_line": 56,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.exists#58",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.exists(self, path)",
        "snippet": "    def exists(self, path):\n        return MockTarget(path).exists()",
        "begin_line": 58,
        "end_line": 59,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001440922190201729,
            "pseudo_dstar_susp": 0.0005675368898978433,
            "pseudo_tarantula_susp": 0.0023752969121140144,
            "pseudo_op2_susp": 0.0005675368898978433,
            "pseudo_barinel_susp": 0.0023752969121140144
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.remove#61",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.remove(self, path, recursive=True, skip_trash=True)",
        "snippet": "    def remove(self, path, recursive=True, skip_trash=True):\n        \"\"\"\n        Removes the given mockfile. skip_trash doesn't have any meaning.\n        \"\"\"\n        if recursive:\n            to_delete = []\n            for s in self.get_all_data().keys():\n                if s.startswith(path):\n                    to_delete.append(s)\n            for s in to_delete:\n                self.get_all_data().pop(s)\n        else:\n            self.get_all_data().pop(path)",
        "begin_line": 61,
        "end_line": 73,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00022331397945511388,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.move#75",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.move(self, path, dest, raise_if_exists=False)",
        "snippet": "    def move(self, path, dest, raise_if_exists=False):\n        \"\"\"\n        Moves a single file from path to dest\n        \"\"\"\n        if raise_if_exists and dest in self.get_all_data():\n            raise RuntimeError('Destination exists: %s' % path)\n        contents = self.get_all_data().pop(path)\n        self.get_all_data()[dest] = contents",
        "begin_line": 75,
        "end_line": 82,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.listdir#84",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.listdir(self, path)",
        "snippet": "    def listdir(self, path):\n        \"\"\"\n        listdir does a prefix match of self.get_all_data(), but doesn't yet support globs.\n        \"\"\"\n        return [s for s in self.get_all_data().keys()\n                if s.startswith(path)]",
        "begin_line": 84,
        "end_line": 89,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.clear#100",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.clear(self)",
        "snippet": "    def clear(self):\n        self.get_all_data().clear()",
        "begin_line": 100,
        "end_line": 101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007380073800738007,
            "pseudo_dstar_susp": 0.0005296610169491525,
            "pseudo_tarantula_susp": 0.0014104372355430183,
            "pseudo_op2_susp": 0.0005296610169491525,
            "pseudo_barinel_susp": 0.0014104372355430183
        }
    },
    {
        "name": "luigi.mock.MockTarget.__init__#107",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockTarget",
        "signature": "luigi.mock.MockTarget.__init__(self, fn, is_tmp=None, mirror_on_stderr=False, format=None)",
        "snippet": "    def __init__(self, fn, is_tmp=None, mirror_on_stderr=False, format=None):\n        self._mirror_on_stderr = mirror_on_stderr\n        self.path = fn\n        if format is None:\n            format = get_default_format()\n\n        # Allow to write unicode in file for retrocompatibility\n        if six.PY2:\n            format = format >> MixedUnicodeBytes\n\n        self.format = format",
        "begin_line": 107,
        "end_line": 117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005277044854881266,
            "pseudo_dstar_susp": 0.0005035246727089627,
            "pseudo_tarantula_susp": 0.000794912559618442,
            "pseudo_op2_susp": 0.0005035246727089627,
            "pseudo_barinel_susp": 0.000794912559618442
        }
    },
    {
        "name": "luigi.mock.MockTarget.exists#119",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockTarget",
        "signature": "luigi.mock.MockTarget.exists(self)",
        "snippet": "    def exists(self,):\n        return self.path in self.fs.get_all_data()",
        "begin_line": 119,
        "end_line": 120,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005892751915144372,
            "pseudo_dstar_susp": 0.0005184033177812338,
            "pseudo_tarantula_susp": 0.0010940919037199124,
            "pseudo_op2_susp": 0.0005184033177812338,
            "pseudo_barinel_susp": 0.0010940919037199124
        }
    },
    {
        "name": "luigi.mock.MockTarget.open#134",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockTarget",
        "signature": "luigi.mock.MockTarget.open(self, mode='r')",
        "snippet": "    def open(self, mode='r'):\n        fn = self.path\n        mock_target = self\n\n        class Buffer(BytesIO):\n            # Just to be able to do writing + reading from the same buffer\n\n            _write_line = True\n\n            def set_wrapper(self, wrapper):\n                self.wrapper = wrapper\n\n            def write(self, data):\n                if mock_target._mirror_on_stderr:\n                    if self._write_line:\n                        sys.stderr.write(fn + \": \")\n                    if six.binary_type:\n                        sys.stderr.write(data.decode('utf8'))\n                    else:\n                        sys.stderr.write(data)\n                    if (data[-1]) == '\\n':\n                        self._write_line = True\n                    else:\n                        self._write_line = False\n                super(Buffer, self).write(data)\n\n            def close(self):\n                if mode[0] == 'w':\n                    try:\n                        mock_target.wrapper.flush()\n                    except AttributeError:\n                        pass\n                    mock_target.fs.get_all_data()[fn] = self.getvalue()\n                super(Buffer, self).close()\n\n            def __exit__(self, exc_type, exc_val, exc_tb):\n                if not exc_type:\n                    self.close()\n\n            def __enter__(self):\n                return self\n\n            def readable(self):\n                return mode[0] == 'r'\n\n            def writeable(self):\n                return mode[0] == 'w'\n\n            def seekable(self):\n                return False\n\n        if mode[0] == 'w':\n            wrapper = self.format.pipe_writer(Buffer())\n            wrapper.set_wrapper(wrapper)\n            return wrapper\n        else:\n            return self.format.pipe_reader(Buffer(self.fs.get_all_data()[fn]))",
        "begin_line": 134,
        "end_line": 190,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0001756543123133673,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.mock.Buffer.open#134",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.open(self, mode='r')",
        "snippet": "    def open(self, mode='r'):\n        fn = self.path\n        mock_target = self\n\n        class Buffer(BytesIO):\n            # Just to be able to do writing + reading from the same buffer\n\n            _write_line = True\n\n            def set_wrapper(self, wrapper):\n                self.wrapper = wrapper\n\n            def write(self, data):\n                if mock_target._mirror_on_stderr:\n                    if self._write_line:\n                        sys.stderr.write(fn + \": \")\n                    if six.binary_type:\n                        sys.stderr.write(data.decode('utf8'))\n                    else:\n                        sys.stderr.write(data)\n                    if (data[-1]) == '\\n':\n                        self._write_line = True\n                    else:\n                        self._write_line = False\n                super(Buffer, self).write(data)\n\n            def close(self):\n                if mode[0] == 'w':\n                    try:\n                        mock_target.wrapper.flush()\n                    except AttributeError:\n                        pass\n                    mock_target.fs.get_all_data()[fn] = self.getvalue()\n                super(Buffer, self).close()\n\n            def __exit__(self, exc_type, exc_val, exc_tb):\n                if not exc_type:\n                    self.close()\n\n            def __enter__(self):\n                return self\n\n            def readable(self):\n                return mode[0] == 'r'\n\n            def writeable(self):\n                return mode[0] == 'w'\n\n            def seekable(self):\n                return False\n\n        if mode[0] == 'w':\n            wrapper = self.format.pipe_writer(Buffer())\n            wrapper.set_wrapper(wrapper)\n            return wrapper\n        else:\n            return self.format.pipe_reader(Buffer(self.fs.get_all_data()[fn]))",
        "begin_line": 134,
        "end_line": 190,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016758840288252054,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.mock.Buffer.set_wrapper#143",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.set_wrapper(self, wrapper)",
        "snippet": "            def set_wrapper(self, wrapper):\n                self.wrapper = wrapper",
        "begin_line": 143,
        "end_line": 144,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016826518593303046,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.mock.Buffer.write#146",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.write(self, data)",
        "snippet": "            def write(self, data):\n                if mock_target._mirror_on_stderr:\n                    if self._write_line:\n                        sys.stderr.write(fn + \": \")\n                    if six.binary_type:\n                        sys.stderr.write(data.decode('utf8'))\n                    else:\n                        sys.stderr.write(data)\n                    if (data[-1]) == '\\n':\n                        self._write_line = True\n                    else:\n                        self._write_line = False\n                super(Buffer, self).write(data)",
        "begin_line": 146,
        "end_line": 158,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.mock.Buffer.close#160",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.close(self)",
        "snippet": "            def close(self):\n                if mode[0] == 'w':\n                    try:\n                        mock_target.wrapper.flush()\n                    except AttributeError:\n                        pass\n                    mock_target.fs.get_all_data()[fn] = self.getvalue()\n                super(Buffer, self).close()",
        "begin_line": 160,
        "end_line": 167,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016812373907195696,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.mock.Buffer.__exit__#169",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.__exit__(self, exc_type, exc_val, exc_tb)",
        "snippet": "            def __exit__(self, exc_type, exc_val, exc_tb):\n                if not exc_type:\n                    self.close()",
        "begin_line": 169,
        "end_line": 171,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017655367231638418,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.mock.Buffer.__enter__#173",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.__enter__(self)",
        "snippet": "            def __enter__(self):\n                return self",
        "begin_line": 173,
        "end_line": 174,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017655367231638418,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.mock.Buffer.readable#176",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.readable(self)",
        "snippet": "            def readable(self):\n                return mode[0] == 'r'",
        "begin_line": 176,
        "end_line": 177,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016784155756965425,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.mock.Buffer.writeable#179",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.writeable(self)",
        "snippet": "            def writeable(self):\n                return mode[0] == 'w'",
        "begin_line": 179,
        "end_line": 180,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016758840288252054,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.mock.Buffer.seekable#182",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.seekable(self)",
        "snippet": "            def seekable(self):\n                return False",
        "begin_line": 182,
        "end_line": 183,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016784155756965425,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.mock.MockFile.__init__#194",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFile",
        "signature": "luigi.mock.MockFile.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        warnings.warn(\"MockFile has been renamed MockTarget\", DeprecationWarning, stacklevel=2)\n        super(MockFile, self).__init__(*args, **kwargs)",
        "begin_line": 194,
        "end_line": 196,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.configuration.base_parser.BaseParser.instance#25",
        "src_path": "luigi/configuration/base_parser.py",
        "class_name": "luigi.configuration.base_parser.BaseParser",
        "signature": "luigi.configuration.base_parser.BaseParser.instance(cls, *args, **kwargs)",
        "snippet": "    def instance(cls, *args, **kwargs):\n        \"\"\" Singleton getter \"\"\"\n        if cls._instance is None:\n            cls._instance = cls(*args, **kwargs)\n            loaded = cls._instance.reload()\n            logging.getLogger('luigi-interface').info('Loaded %r', loaded)\n\n        return cls._instance",
        "begin_line": 25,
        "end_line": 32,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.014492753623188406,
            "pseudo_dstar_susp": 0.125,
            "pseudo_tarantula_susp": 0.0017211703958691911,
            "pseudo_op2_susp": 0.125,
            "pseudo_barinel_susp": 0.0017211703958691911
        }
    },
    {
        "name": "luigi.configuration.base_parser.BaseParser.add_config_path#35",
        "src_path": "luigi/configuration/base_parser.py",
        "class_name": "luigi.configuration.base_parser.BaseParser",
        "signature": "luigi.configuration.base_parser.BaseParser.add_config_path(cls, path)",
        "snippet": "    def add_config_path(cls, path):\n        cls._config_paths.append(path)\n        cls.reload()",
        "begin_line": 35,
        "end_line": 37,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.configuration.base_parser.BaseParser.reload#40",
        "src_path": "luigi/configuration/base_parser.py",
        "class_name": "luigi.configuration.base_parser.BaseParser",
        "signature": "luigi.configuration.base_parser.BaseParser.reload(cls)",
        "snippet": "    def reload(cls):\n        return cls.instance().read(cls._config_paths)",
        "begin_line": 40,
        "end_line": 41,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002294630564479119,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.app_options#57",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.app_options(self)",
        "snippet": "    def app_options(self):\n        \"\"\"\n        Subclass this method to map your task parameters to the app's arguments\n\n        \"\"\"\n        return []",
        "begin_line": 57,
        "end_line": 62,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002079002079002079,
            "pseudo_dstar_susp": 0.0005861664712778429,
            "pseudo_tarantula_susp": 0.002770083102493075,
            "pseudo_op2_susp": 0.0005861664712778429,
            "pseudo_barinel_susp": 0.002770083102493075
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.spark_version#65",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.spark_version(self)",
        "snippet": "    def spark_version(self):\n        return \"spark\"",
        "begin_line": 65,
        "end_line": 66,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013550135501355014,
            "pseudo_dstar_susp": 0.0005586592178770949,
            "pseudo_tarantula_susp": 0.0022123893805309734,
            "pseudo_op2_susp": 0.0005586592178770949,
            "pseudo_barinel_susp": 0.0022123893805309734
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.spark_submit#69",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.spark_submit(self)",
        "snippet": "    def spark_submit(self):\n        return configuration.get_config().get(self.spark_version, 'spark-submit', 'spark-submit')",
        "begin_line": 69,
        "end_line": 70,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.master#73",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.master(self)",
        "snippet": "    def master(self):\n        return configuration.get_config().get(self.spark_version, \"master\", None)",
        "begin_line": 73,
        "end_line": 74,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.deploy_mode#77",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.deploy_mode(self)",
        "snippet": "    def deploy_mode(self):\n        return configuration.get_config().get(self.spark_version, \"deploy-mode\", None)",
        "begin_line": 77,
        "end_line": 78,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017921146953405018,
            "pseudo_dstar_susp": 0.0005827505827505828,
            "pseudo_tarantula_susp": 0.0026954177897574125,
            "pseudo_op2_susp": 0.0005827505827505828,
            "pseudo_barinel_susp": 0.0026954177897574125
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.jars#81",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.jars(self)",
        "snippet": "    def jars(self):\n        return self._list_config(configuration.get_config().get(self.spark_version, \"jars\", None))",
        "begin_line": 81,
        "end_line": 82,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.packages#85",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.packages(self)",
        "snippet": "    def packages(self):\n        return self._list_config(configuration.get_config().get(\n            self.spark_version, \"packages\", None))",
        "begin_line": 85,
        "end_line": 87,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.py_files#90",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.py_files(self)",
        "snippet": "    def py_files(self):\n        return self._list_config(configuration.get_config().get(\n            self.spark_version, \"py-files\", None))",
        "begin_line": 90,
        "end_line": 92,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.files#95",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.files(self)",
        "snippet": "    def files(self):\n        return self._list_config(configuration.get_config().get(self.spark_version, \"files\", None))",
        "begin_line": 95,
        "end_line": 96,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.conf#99",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.conf(self)",
        "snippet": "    def conf(self):\n        return self._dict_config(configuration.get_config().get(self.spark_version, \"conf\", None))",
        "begin_line": 99,
        "end_line": 100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.properties_file#103",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.properties_file(self)",
        "snippet": "    def properties_file(self):\n        return configuration.get_config().get(self.spark_version, \"properties-file\", None)",
        "begin_line": 103,
        "end_line": 104,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.driver_memory#107",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.driver_memory(self)",
        "snippet": "    def driver_memory(self):\n        return configuration.get_config().get(self.spark_version, \"driver-memory\", None)",
        "begin_line": 107,
        "end_line": 108,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.driver_java_options#111",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.driver_java_options(self)",
        "snippet": "    def driver_java_options(self):\n        return configuration.get_config().get(self.spark_version, \"driver-java-options\", None)",
        "begin_line": 111,
        "end_line": 112,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.driver_library_path#115",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.driver_library_path(self)",
        "snippet": "    def driver_library_path(self):\n        return configuration.get_config().get(self.spark_version, \"driver-library-path\", None)",
        "begin_line": 115,
        "end_line": 116,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.driver_class_path#119",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.driver_class_path(self)",
        "snippet": "    def driver_class_path(self):\n        return configuration.get_config().get(self.spark_version, \"driver-class-path\", None)",
        "begin_line": 119,
        "end_line": 120,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.executor_memory#123",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.executor_memory(self)",
        "snippet": "    def executor_memory(self):\n        return configuration.get_config().get(self.spark_version, \"executor-memory\", None)",
        "begin_line": 123,
        "end_line": 124,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.driver_cores#127",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.driver_cores(self)",
        "snippet": "    def driver_cores(self):\n        return configuration.get_config().get(self.spark_version, \"driver-cores\", None)",
        "begin_line": 127,
        "end_line": 128,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.supervise#131",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.supervise(self)",
        "snippet": "    def supervise(self):\n        return bool(configuration.get_config().get(self.spark_version, \"supervise\", False))",
        "begin_line": 131,
        "end_line": 132,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.total_executor_cores#135",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.total_executor_cores(self)",
        "snippet": "    def total_executor_cores(self):\n        return configuration.get_config().get(self.spark_version, \"total-executor-cores\", None)",
        "begin_line": 135,
        "end_line": 136,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.executor_cores#139",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.executor_cores(self)",
        "snippet": "    def executor_cores(self):\n        return configuration.get_config().get(self.spark_version, \"executor-cores\", None)",
        "begin_line": 139,
        "end_line": 140,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.queue#143",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.queue(self)",
        "snippet": "    def queue(self):\n        return configuration.get_config().get(self.spark_version, \"queue\", None)",
        "begin_line": 143,
        "end_line": 144,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.num_executors#147",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.num_executors(self)",
        "snippet": "    def num_executors(self):\n        return configuration.get_config().get(self.spark_version, \"num-executors\", None)",
        "begin_line": 147,
        "end_line": 148,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.archives#151",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.archives(self)",
        "snippet": "    def archives(self):\n        return self._list_config(configuration.get_config().get(\n            self.spark_version, \"archives\", None))",
        "begin_line": 151,
        "end_line": 153,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.hadoop_conf_dir#156",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.hadoop_conf_dir(self)",
        "snippet": "    def hadoop_conf_dir(self):\n        return configuration.get_config().get(self.spark_version, \"hadoop-conf-dir\", None)",
        "begin_line": 156,
        "end_line": 157,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021101498206372652,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.get_environment#159",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.get_environment(self)",
        "snippet": "    def get_environment(self):\n        env = os.environ.copy()\n        hadoop_conf_dir = self.hadoop_conf_dir\n        if hadoop_conf_dir:\n            env['HADOOP_CONF_DIR'] = hadoop_conf_dir\n        return env",
        "begin_line": 159,
        "end_line": 164,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.program_environment#166",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.program_environment(self)",
        "snippet": "    def program_environment(self):\n        return self.get_environment()",
        "begin_line": 166,
        "end_line": 167,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021101498206372652,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.program_args#169",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.program_args(self)",
        "snippet": "    def program_args(self):\n        return self.spark_command() + self.app_command()",
        "begin_line": 169,
        "end_line": 170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.spark_command#172",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.spark_command(self)",
        "snippet": "    def spark_command(self):\n        command = [self.spark_submit]\n        command += self._text_arg('--master', self.master)\n        command += self._text_arg('--deploy-mode', self.deploy_mode)\n        command += self._text_arg('--name', self.name)\n        command += self._text_arg('--class', self.entry_class)\n        command += self._list_arg('--jars', self.jars)\n        command += self._list_arg('--packages', self.packages)\n        command += self._list_arg('--py-files', self.py_files)\n        command += self._list_arg('--files', self.files)\n        command += self._list_arg('--archives', self.archives)\n        command += self._dict_arg('--conf', self.conf)\n        command += self._text_arg('--properties-file', self.properties_file)\n        command += self._text_arg('--driver-memory', self.driver_memory)\n        command += self._text_arg('--driver-java-options', self.driver_java_options)\n        command += self._text_arg('--driver-library-path', self.driver_library_path)\n        command += self._text_arg('--driver-class-path', self.driver_class_path)\n        command += self._text_arg('--executor-memory', self.executor_memory)\n        command += self._text_arg('--driver-cores', self.driver_cores)\n        command += self._flag_arg('--supervise', self.supervise)\n        command += self._text_arg('--total-executor-cores', self.total_executor_cores)\n        command += self._text_arg('--executor-cores', self.executor_cores)\n        command += self._text_arg('--queue', self.queue)\n        command += self._text_arg('--num-executors', self.num_executors)\n        return command",
        "begin_line": 172,
        "end_line": 196,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.app_command#198",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.app_command(self)",
        "snippet": "    def app_command(self):\n        if not self.app:\n            raise NotImplementedError(\"subclass should define an app (.jar or .py file)\")\n        return [self.app] + self.app_options()",
        "begin_line": 198,
        "end_line": 201,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask._list_config#203",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask._list_config(self, config)",
        "snippet": "    def _list_config(self, config):\n        if config and isinstance(config, six.string_types):\n            return list(map(lambda x: x.strip(), config.split(',')))",
        "begin_line": 203,
        "end_line": 205,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask._dict_config#207",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask._dict_config(self, config)",
        "snippet": "    def _dict_config(self, config):\n        if config and isinstance(config, six.string_types):\n            return dict(map(lambda i: i.split('=', 1), config.split('|')))",
        "begin_line": 207,
        "end_line": 209,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask._text_arg#211",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask._text_arg(self, name, value)",
        "snippet": "    def _text_arg(self, name, value):\n        if value:\n            return [name, value]\n        return []",
        "begin_line": 211,
        "end_line": 214,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021101498206372652,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask._list_arg#216",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask._list_arg(self, name, value)",
        "snippet": "    def _list_arg(self, name, value):\n        if value and isinstance(value, (list, tuple)):\n            return [name, ','.join(value)]\n        return []",
        "begin_line": 216,
        "end_line": 219,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00022331397945511388,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask._dict_arg#221",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask._dict_arg(self, name, value)",
        "snippet": "    def _dict_arg(self, name, value):\n        command = []\n        if value and isinstance(value, dict):\n            for prop, value in value.items():\n                command += [name, '{0}={1}'.format(prop, value)]\n        return command",
        "begin_line": 221,
        "end_line": 226,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002294630564479119,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask._flag_arg#228",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask._flag_arg(self, name, value)",
        "snippet": "    def _flag_arg(self, name, value):\n        if value:\n            return [name]\n        return []",
        "begin_line": 228,
        "end_line": 231,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask.name#249",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask.name(self)",
        "snippet": "    def name(self):\n        return self.__class__.__name__",
        "begin_line": 249,
        "end_line": 250,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024630541871921183,
            "pseudo_dstar_susp": 0.0005931198102016608,
            "pseudo_tarantula_susp": 0.0033112582781456954,
            "pseudo_op2_susp": 0.0005931198102016608,
            "pseudo_barinel_susp": 0.0033112582781456954
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask.py_packages#253",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask.py_packages(self)",
        "snippet": "    def py_packages(self):\n        packages = configuration.get_config().get('spark', 'py-packages', None)\n        if packages:\n            return map(lambda s: s.strip(), packages.split(','))",
        "begin_line": 253,
        "end_line": 256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01818181818181818,
            "pseudo_dstar_susp": 0.0010940919037199124,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.0010940919037199124,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask.files#259",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask.files(self)",
        "snippet": "    def files(self):\n        if self.deploy_mode == \"cluster\":\n            return [self.run_pickle]",
        "begin_line": 259,
        "end_line": 261,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask.setup#263",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask.setup(self, conf)",
        "snippet": "    def setup(self, conf):\n        \"\"\"\n        Called by the pyspark_runner with a SparkConf instance that will be used to instantiate the SparkContext\n\n        :param conf: SparkConf\n        \"\"\"",
        "begin_line": 263,
        "end_line": 268,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01818181818181818,
            "pseudo_dstar_susp": 0.0010940919037199124,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.0010940919037199124,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask.setup_remote#270",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask.setup_remote(self, sc)",
        "snippet": "    def setup_remote(self, sc):\n        self._setup_packages(sc)",
        "begin_line": 270,
        "end_line": 271,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008,
            "pseudo_dstar_susp": 0.0006211180124223603,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.0006211180124223603,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask.app_command#282",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask.app_command(self)",
        "snippet": "    def app_command(self):\n        if self.deploy_mode == \"cluster\":\n            pickle_loc = os.path.basename(self.run_pickle)\n        else:\n            pickle_loc = self.run_pickle\n        return [self.app, pickle_loc] + self.app_options()",
        "begin_line": 282,
        "end_line": 287,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029498525073746312,
            "pseudo_dstar_susp": 0.0006024096385542169,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.0006024096385542169,
            "pseudo_barinel_susp": 0.004629629629629629
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask.run#289",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask.run(self)",
        "snippet": "    def run(self):\n        self.run_path = tempfile.mkdtemp(prefix=self.name)\n        self.run_pickle = os.path.join(self.run_path, '.'.join([self.name.replace(' ', '_'), 'pickle']))\n        with open(self.run_pickle, 'wb') as fd:\n            # Copy module file to run path.\n            module_path = os.path.abspath(inspect.getfile(self.__class__))\n            shutil.copy(module_path, os.path.join(self.run_path, '.'))\n            self._dump(fd)\n        try:\n            super(PySparkTask, self).run()\n        finally:\n            shutil.rmtree(self.run_path)",
        "begin_line": 289,
        "end_line": 300,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024630541871921183,
            "pseudo_dstar_susp": 0.0005931198102016608,
            "pseudo_tarantula_susp": 0.0033112582781456954,
            "pseudo_op2_susp": 0.0005931198102016608,
            "pseudo_barinel_susp": 0.0033112582781456954
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask._dump#302",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask._dump(self, fd)",
        "snippet": "    def _dump(self, fd):\n        with self.no_unpicklable_properties():\n            if self.__module__ == '__main__':\n                d = pickle.dumps(self)\n                module_name = os.path.basename(sys.argv[0]).rsplit('.', 1)[0]\n                d = d.replace(b'c__main__', b'c' + module_name.encode('ascii'))\n                fd.write(d)\n            else:\n                pickle.dump(self, fd)",
        "begin_line": 302,
        "end_line": 310,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024630541871921183,
            "pseudo_dstar_susp": 0.0005931198102016608,
            "pseudo_tarantula_susp": 0.0033112582781456954,
            "pseudo_op2_susp": 0.0005931198102016608,
            "pseudo_barinel_susp": 0.0033112582781456954
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask._setup_packages#312",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask._setup_packages(self, sc)",
        "snippet": "    def _setup_packages(self, sc):\n        \"\"\"\n        This method compresses and uploads packages to the cluster\n\n        \"\"\"\n        packages = self.py_packages\n        if not packages:\n            return\n        for package in packages:\n            mod = importlib.import_module(package)\n            try:\n                mod_path = mod.__path__[0]\n            except AttributeError:\n                mod_path = mod.__file__\n            tar_path = os.path.join(self.run_path, package + '.tar.gz')\n            tar = tarfile.open(tar_path, \"w:gz\")\n            tar.add(mod_path, os.path.basename(mod_path))\n            tar.close()\n            sc.addPyFile(tar_path)",
        "begin_line": 312,
        "end_line": 330,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008,
            "pseudo_dstar_susp": 0.0006211180124223603,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.0006211180124223603,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.contrib.lsf.LSFJobTask._init_local#143",
        "src_path": "luigi/contrib/lsf.py",
        "class_name": "luigi.contrib.lsf.LSFJobTask",
        "signature": "luigi.contrib.lsf.LSFJobTask._init_local(self)",
        "snippet": "    def _init_local(self):\n\n        base_tmp_dir = self.shared_tmp_dir\n\n        random_id = '%016x' % random.getrandbits(64)\n        task_name = random_id + self.task_id\n        # If any parameters are directories, if we don't\n        # replace the separators on *nix, it'll create a weird nested directory\n        task_name = task_name.replace(\"/\", \"::\")\n\n        # Max filename length\n        max_filename_length = os.fstatvfs(0).f_namemax\n        self.tmp_dir = os.path.join(base_tmp_dir, task_name[:max_filename_length])\n\n        LOGGER.info(\"Tmp dir: %s\", self.tmp_dir)\n        os.makedirs(self.tmp_dir)\n\n        # Dump the code to be run into a pickle file\n        LOGGER.debug(\"Dumping pickled class\")\n        self._dump(self.tmp_dir)\n\n        # Make sure that all the class's dependencies are tarred and available\n        LOGGER.debug(\"Tarballing dependencies\")\n        # Grab luigi and the module containing the code to be run\n        packages = [luigi, __import__(self.__module__, None, None, 'dummy')]\n        create_packages_archive(packages, os.path.join(self.tmp_dir, \"packages.tar\"))\n\n        # Now, pass onto the class's specified init_local() method.\n        self.init_local()",
        "begin_line": 143,
        "end_line": 171,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.lsf.LSFJobTask.run#181",
        "src_path": "luigi/contrib/lsf.py",
        "class_name": "luigi.contrib.lsf.LSFJobTask",
        "signature": "luigi.contrib.lsf.LSFJobTask.run(self)",
        "snippet": "    def run(self):\n        \"\"\"\n        The procedure:\n        - Pickle the class\n        - Tarball the dependencies\n        - Construct a bsub argument that runs a generic runner function with the path to the pickled class\n        - Runner function loads the class from pickle\n        - Runner class untars the dependencies\n        - Runner function hits the button on the class's work() method\n        \"\"\"\n        self._init_local()\n        self._run_job()",
        "begin_line": 181,
        "end_line": 192,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.lsf.LSFJobTask._dump#205",
        "src_path": "luigi/contrib/lsf.py",
        "class_name": "luigi.contrib.lsf.LSFJobTask",
        "signature": "luigi.contrib.lsf.LSFJobTask._dump(self, out_dir='')",
        "snippet": "    def _dump(self, out_dir=''):\n        \"\"\"\n        Dump instance to file.\n        \"\"\"\n        self.job_file = os.path.join(out_dir, 'job-instance.pickle')\n        if self.__module__ == '__main__':\n            dump_inst = pickle.dumps(self)\n            module_name = os.path.basename(sys.argv[0]).rsplit('.', 1)[0]\n            dump_inst = dump_inst.replace('(c__main__', \"(c\" + module_name)\n            open(self.job_file, \"w\").write(dump_inst)\n\n        else:\n            pickle.dump(self, open(self.job_file, \"w\"))",
        "begin_line": 205,
        "end_line": 217,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.retcodes.run_with_retcodes#61",
        "src_path": "luigi/retcodes.py",
        "class_name": "luigi.retcodes",
        "signature": "luigi.retcodes.run_with_retcodes(argv)",
        "snippet": "def run_with_retcodes(argv):\n    \"\"\"\n    Run luigi with command line parsing, but raise ``SystemExit`` with the configured exit code.\n\n    Note: Usually you use the luigi binary directly and don't call this function yourself.\n\n    :param argv: Should (conceptually) be ``sys.argv[1:]``\n    \"\"\"\n    logger = logging.getLogger('luigi-interface')\n    with luigi.cmdline_parser.CmdlineParser.global_instance(argv):\n        retcodes = retcode()\n\n    worker = None\n    try:\n        worker = luigi.interface._run(argv)['worker']\n    except luigi.interface.PidLockAlreadyTakenExit:\n        sys.exit(retcodes.already_running)\n    except Exception:\n        # Some errors occur before logging is set up, we set it up now\n        env_params = luigi.interface.core()\n        InterfaceLogging.setup(env_params)\n        logger.exception(\"Uncaught exception in luigi\")\n        sys.exit(retcodes.unhandled_exception)\n\n    with luigi.cmdline_parser.CmdlineParser.global_instance(argv):\n        task_sets = luigi.execution_summary._summary_dict(worker)\n        root_task = luigi.execution_summary._root_task(worker)\n        non_empty_categories = {k: v for k, v in task_sets.items() if v}.keys()\n\n    def has(status):\n        assert status in luigi.execution_summary._ORDERED_STATUSES\n        return status in non_empty_categories\n\n    codes_and_conds = (\n        (retcodes.missing_data, has('still_pending_ext')),\n        (retcodes.task_failed, has('failed')),\n        (retcodes.already_running, has('run_by_other_worker')),\n        (retcodes.scheduling_error, has('scheduling_error')),\n        (retcodes.not_run, has('not_run')),\n    )\n    expected_ret_code = max(code * (1 if cond else 0) for code, cond in codes_and_conds)\n\n    if expected_ret_code == 0 and \\\n       root_task not in task_sets[\"completed\"] and \\\n       root_task not in task_sets[\"already_done\"]:\n        sys.exit(retcodes.not_run)\n    else:\n        sys.exit(expected_ret_code)",
        "begin_line": 61,
        "end_line": 108,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.retcodes.has#90",
        "src_path": "luigi/retcodes.py",
        "class_name": "luigi.retcodes",
        "signature": "luigi.retcodes.has(status)",
        "snippet": "    def has(status):\n        assert status in luigi.execution_summary._ORDERED_STATUSES\n        return status in non_empty_categories",
        "begin_line": 90,
        "end_line": 92,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.process.check_pid#31",
        "src_path": "luigi/process.py",
        "class_name": "luigi.process",
        "signature": "luigi.process.check_pid(pidfile)",
        "snippet": "def check_pid(pidfile):\n    if pidfile and os.path.exists(pidfile):\n        try:\n            pid = int(open(pidfile).read().strip())\n            os.kill(pid, 0)\n            return pid\n        except BaseException:\n            return 0\n    return 0",
        "begin_line": 31,
        "end_line": 39,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008,
            "pseudo_dstar_susp": 0.0006211180124223603,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.0006211180124223603,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.process.write_pid#42",
        "src_path": "luigi/process.py",
        "class_name": "luigi.process",
        "signature": "luigi.process.write_pid(pidfile)",
        "snippet": "def write_pid(pidfile):\n    server_logger.info(\"Writing pid file\")\n    piddir = os.path.dirname(pidfile)\n    if piddir != '':\n        try:\n            os.makedirs(piddir)\n        except OSError:\n            pass\n\n    with open(pidfile, 'w') as fobj:\n        fobj.write(str(os.getpid()))",
        "begin_line": 42,
        "end_line": 52,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008,
            "pseudo_dstar_susp": 0.0006211180124223603,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.0006211180124223603,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.process.get_log_format#55",
        "src_path": "luigi/process.py",
        "class_name": "luigi.process",
        "signature": "luigi.process.get_log_format()",
        "snippet": "def get_log_format():\n    return \"%(asctime)s %(name)s[%(process)s] %(levelname)s: %(message)s\"",
        "begin_line": 55,
        "end_line": 56,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008,
            "pseudo_dstar_susp": 0.0006211180124223603,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.0006211180124223603,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.process.get_spool_handler#59",
        "src_path": "luigi/process.py",
        "class_name": "luigi.process",
        "signature": "luigi.process.get_spool_handler(filename)",
        "snippet": "def get_spool_handler(filename):\n    handler = logging.handlers.TimedRotatingFileHandler(\n        filename=filename,\n        when='d',\n        encoding='utf8',\n        backupCount=7  # keep one week of historical logs\n    )\n    formatter = logging.Formatter(get_log_format())\n    handler.setFormatter(formatter)\n    return handler",
        "begin_line": 59,
        "end_line": 68,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008,
            "pseudo_dstar_susp": 0.0006211180124223603,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.0006211180124223603,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.process._server_already_running#71",
        "src_path": "luigi/process.py",
        "class_name": "luigi.process",
        "signature": "luigi.process._server_already_running(pidfile)",
        "snippet": "def _server_already_running(pidfile):\n    existing_pid = check_pid(pidfile)\n    if pidfile and existing_pid:\n        return True\n    return False",
        "begin_line": 71,
        "end_line": 75,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008,
            "pseudo_dstar_susp": 0.0006211180124223603,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.0006211180124223603,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.process.daemonize#78",
        "src_path": "luigi/process.py",
        "class_name": "luigi.process",
        "signature": "luigi.process.daemonize(cmd, pidfile=None, logdir=None, api_port=8082, address=None, unix_socket=None)",
        "snippet": "def daemonize(cmd, pidfile=None, logdir=None, api_port=8082, address=None, unix_socket=None):\n    import daemon\n\n    logdir = logdir or \"/var/log/luigi\"\n    if not os.path.exists(logdir):\n        os.makedirs(logdir)\n\n    log_path = os.path.join(logdir, \"luigi-server.log\")\n\n    # redirect stdout/stderr\n    today = datetime.date.today()\n    stdout_path = os.path.join(\n        logdir,\n        \"luigi-server-{0:%Y-%m-%d}.out\".format(today)\n    )\n    stderr_path = os.path.join(\n        logdir,\n        \"luigi-server-{0:%Y-%m-%d}.err\".format(today)\n    )\n    stdout_proxy = open(stdout_path, 'a+')\n    stderr_proxy = open(stderr_path, 'a+')\n\n    try:\n        ctx = daemon.DaemonContext(\n            stdout=stdout_proxy,\n            stderr=stderr_proxy,\n            working_directory='.',\n            initgroups=False,\n        )\n    except TypeError:\n        # Older versions of python-daemon cannot deal with initgroups arg.\n        ctx = daemon.DaemonContext(\n            stdout=stdout_proxy,\n            stderr=stderr_proxy,\n            working_directory='.',\n        )\n\n    with ctx:\n        loghandler = get_spool_handler(log_path)\n        rootlogger.addHandler(loghandler)\n\n        if pidfile:\n            server_logger.info(\"Checking pid file\")\n            existing_pid = check_pid(pidfile)\n            if pidfile and existing_pid:\n                server_logger.info(\"Server already running (pid=%s)\", existing_pid)\n                return\n            write_pid(pidfile)\n\n        cmd(api_port=api_port, address=address, unix_socket=unix_socket)",
        "begin_line": 78,
        "end_line": 127,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008,
            "pseudo_dstar_susp": 0.0006211180124223603,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.0006211180124223603,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory._session#66",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory._session(self, session=None)",
        "snippet": "    def _session(self, session=None):\n        if session:\n            yield session\n        else:\n            session = self.session_factory()\n            try:\n                yield session\n            except BaseException:\n                session.rollback()\n                raise\n            else:\n                session.commit()",
        "begin_line": 66,
        "end_line": 77,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00425531914893617,
            "pseudo_dstar_susp": 0.0010152284263959391,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.0010152284263959391,
            "pseudo_barinel_susp": 0.004629629629629629
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory.__init__#79",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory.__init__(self)",
        "snippet": "    def __init__(self):\n        config = configuration.get_config()\n        connection_string = config.get('task_history', 'db_connection')\n        self.engine = sqlalchemy.create_engine(connection_string)\n        self.session_factory = sqlalchemy.orm.sessionmaker(bind=self.engine, expire_on_commit=False)\n        Base.metadata.create_all(self.engine)\n        self.tasks = {}  # task_id -> TaskRecord\n\n        _upgrade_schema(self.engine)",
        "begin_line": 79,
        "end_line": 87,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00425531914893617,
            "pseudo_dstar_susp": 0.0010152284263959391,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.0010152284263959391,
            "pseudo_barinel_susp": 0.004629629629629629
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory.task_scheduled#89",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory.task_scheduled(self, task)",
        "snippet": "    def task_scheduled(self, task):\n        htask = self._get_task(task, status=PENDING)\n        self._add_task_event(htask, TaskEvent(event_name=PENDING, ts=datetime.datetime.now()))",
        "begin_line": 89,
        "end_line": 91,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00425531914893617,
            "pseudo_dstar_susp": 0.0010152284263959391,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.0010152284263959391,
            "pseudo_barinel_susp": 0.004629629629629629
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory.task_finished#93",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory.task_finished(self, task, successful)",
        "snippet": "    def task_finished(self, task, successful):\n        event_name = DONE if successful else FAILED\n        htask = self._get_task(task, status=event_name)\n        self._add_task_event(htask, TaskEvent(event_name=event_name, ts=datetime.datetime.now()))",
        "begin_line": 93,
        "end_line": 96,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00425531914893617,
            "pseudo_dstar_susp": 0.0010152284263959391,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.0010152284263959391,
            "pseudo_barinel_susp": 0.004629629629629629
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory.task_started#98",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory.task_started(self, task, worker_host)",
        "snippet": "    def task_started(self, task, worker_host):\n        htask = self._get_task(task, status=RUNNING, host=worker_host)\n        self._add_task_event(htask, TaskEvent(event_name=RUNNING, ts=datetime.datetime.now()))",
        "begin_line": 98,
        "end_line": 100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00425531914893617,
            "pseudo_dstar_susp": 0.0010152284263959391,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.0010152284263959391,
            "pseudo_barinel_susp": 0.004629629629629629
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory._get_task#102",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory._get_task(self, task, status, host=None)",
        "snippet": "    def _get_task(self, task, status, host=None):\n        if task.id in self.tasks:\n            htask = self.tasks[task.id]\n            htask.status = status\n            if host:\n                htask.host = host\n        else:\n            htask = self.tasks[task.id] = task_history.StoredTask(task, status, host)\n        return htask",
        "begin_line": 102,
        "end_line": 110,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00425531914893617,
            "pseudo_dstar_susp": 0.0010152284263959391,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.0010152284263959391,
            "pseudo_barinel_susp": 0.004629629629629629
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory._add_task_event#112",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory._add_task_event(self, task, event)",
        "snippet": "    def _add_task_event(self, task, event):\n        for (task_record, session) in self._find_or_create_task(task):\n            task_record.events.append(event)",
        "begin_line": 112,
        "end_line": 114,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00425531914893617,
            "pseudo_dstar_susp": 0.0010152284263959391,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.0010152284263959391,
            "pseudo_barinel_susp": 0.004629629629629629
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory._find_or_create_task#116",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory._find_or_create_task(self, task)",
        "snippet": "    def _find_or_create_task(self, task):\n        with self._session() as session:\n            if task.record_id is not None:\n                logger.debug(\"Finding task with record_id [%d]\", task.record_id)\n                task_record = session.query(TaskRecord).get(task.record_id)\n                if not task_record:\n                    raise Exception(\"Task with record_id, but no matching Task record!\")\n                yield (task_record, session)\n            else:\n                task_record = TaskRecord(task_id=task._task.id, name=task.task_family, host=task.host)\n                for (k, v) in six.iteritems(task.parameters):\n                    task_record.parameters[k] = TaskParameter(name=k, value=v)\n                session.add(task_record)\n                yield (task_record, session)\n            if task.host:\n                task_record.host = task.host\n        task.record_id = task_record.id",
        "begin_line": 116,
        "end_line": 132,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00425531914893617,
            "pseudo_dstar_susp": 0.0010152284263959391,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.0010152284263959391,
            "pseudo_barinel_susp": 0.004629629629629629
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory.find_all_by_parameters#134",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory.find_all_by_parameters(self, task_name, session=None, **task_params)",
        "snippet": "    def find_all_by_parameters(self, task_name, session=None, **task_params):\n        \"\"\"\n        Find tasks with the given task_name and the same parameters as the kwargs.\n        \"\"\"\n        with self._session(session) as session:\n            query = session.query(TaskRecord).join(TaskEvent).filter(TaskRecord.name == task_name)\n            for (k, v) in six.iteritems(task_params):\n                alias = sqlalchemy.orm.aliased(TaskParameter)\n                query = query.join(alias).filter(alias.name == k, alias.value == v)\n\n            tasks = query.order_by(TaskEvent.ts)\n            for task in tasks:\n                # Sanity check\n                assert all(k in task.parameters and v == str(task.parameters[k].value) for (k, v) in six.iteritems(task_params))\n\n                yield task",
        "begin_line": 134,
        "end_line": 149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.0030211480362537764,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.0030211480362537764,
            "pseudo_barinel_susp": 0.004629629629629629
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory.find_all_by_name#151",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory.find_all_by_name(self, task_name, session=None)",
        "snippet": "    def find_all_by_name(self, task_name, session=None):\n        \"\"\"\n        Find all tasks with the given task_name.\n        \"\"\"\n        return self.find_all_by_parameters(task_name, session)",
        "begin_line": 151,
        "end_line": 155,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005376344086021506,
            "pseudo_dstar_susp": 0.001059322033898305,
            "pseudo_tarantula_susp": 0.006134969325153374,
            "pseudo_op2_susp": 0.001059322033898305,
            "pseudo_barinel_susp": 0.006134969325153374
        }
    },
    {
        "name": "luigi.db_task_history.TaskEvent.__repr__#215",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.TaskEvent",
        "signature": "luigi.db_task_history.TaskEvent.__repr__(self)",
        "snippet": "    def __repr__(self):\n        return \"TaskEvent(task_id=%s, event_name=%s, ts=%s\" % (self.task_id, self.event_name, self.ts)",
        "begin_line": 215,
        "end_line": 216,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.db_task_history._upgrade_schema#243",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history",
        "signature": "luigi.db_task_history._upgrade_schema(engine)",
        "snippet": "def _upgrade_schema(engine):\n    \"\"\"\n    Ensure the database schema is up to date with the codebase.\n\n    :param engine: SQLAlchemy engine of the underlying database.\n    \"\"\"\n    inspector = reflection.Inspector.from_engine(engine)\n    with engine.connect() as conn:\n\n        # Upgrade 1.  Add task_id column and index to tasks\n        if 'task_id' not in [x['name'] for x in inspector.get_columns('tasks')]:\n            logger.warning('Upgrading DbTaskHistory schema: Adding tasks.task_id')\n            conn.execute('ALTER TABLE tasks ADD COLUMN task_id VARCHAR(200)')\n            conn.execute('CREATE INDEX ix_task_id ON tasks (task_id)')\n\n        # Upgrade 2. Alter value column to be TEXT, note that this is idempotent so no if-guard\n        if 'mysql' in engine.dialect.name:\n            conn.execute('ALTER TABLE task_parameters MODIFY COLUMN value TEXT')\n        elif 'oracle' in engine.dialect.name:\n            conn.execute('ALTER TABLE task_parameters MODIFY value TEXT')\n        elif 'mssql' in engine.dialect.name:\n            conn.execute('ALTER TABLE task_parameters ALTER COLUMN value TEXT')\n        elif 'postgresql' in engine.dialect.name:\n            if str([x for x in inspector.get_columns('task_parameters')\n                    if x['name'] == 'value'][0]['type']) != 'TEXT':\n                conn.execute('ALTER TABLE task_parameters ALTER COLUMN value TYPE TEXT')\n        elif 'sqlite' in engine.dialect.name:\n            # SQLite does not support changing column types. A database file will need\n            # to be used to pickup this migration change.\n            for i in conn.execute('PRAGMA table_info(task_parameters);').fetchall():\n                if i['name'] == 'value' and i['type'] != 'TEXT':\n                    logger.warning(\n                        'SQLite can not change column types. Please use a new database '\n                        'to pickup column type changes.'\n                    )\n        else:\n            logger.warning(\n                'SQLAlcheny dialect {} could not be migrated to the TEXT type'.format(\n                    engine.dialect\n                )\n            )",
        "begin_line": 243,
        "end_line": 283,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.0030211480362537764,
            "pseudo_tarantula_susp": 0.006756756756756757,
            "pseudo_op2_susp": 0.0030211480362537764,
            "pseudo_barinel_susp": 0.006756756756756757
        }
    },
    {
        "name": "luigi.task_history.StoredTask.__init__#38",
        "src_path": "luigi/task_history.py",
        "class_name": "luigi.task_history.StoredTask",
        "signature": "luigi.task_history.StoredTask.__init__(self, task, status, host=None)",
        "snippet": "    def __init__(self, task, status, host=None):\n        self._task = task\n        self.status = status\n        self.record_id = None\n        self.host = host",
        "begin_line": 38,
        "end_line": 42,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00425531914893617,
            "pseudo_dstar_susp": 0.0010152284263959391,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.0010152284263959391,
            "pseudo_barinel_susp": 0.004629629629629629
        }
    },
    {
        "name": "luigi.task_history.StoredTask.task_family#45",
        "src_path": "luigi/task_history.py",
        "class_name": "luigi.task_history.StoredTask",
        "signature": "luigi.task_history.StoredTask.task_family(self)",
        "snippet": "    def task_family(self):\n        return self._task.family",
        "begin_line": 45,
        "end_line": 46,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00425531914893617,
            "pseudo_dstar_susp": 0.0010152284263959391,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.0010152284263959391,
            "pseudo_barinel_susp": 0.004629629629629629
        }
    },
    {
        "name": "luigi.task_history.StoredTask.parameters#49",
        "src_path": "luigi/task_history.py",
        "class_name": "luigi.task_history.StoredTask",
        "signature": "luigi.task_history.StoredTask.parameters(self)",
        "snippet": "    def parameters(self):\n        return self._task.params",
        "begin_line": 49,
        "end_line": 50,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00425531914893617,
            "pseudo_dstar_susp": 0.0010152284263959391,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.0010152284263959391,
            "pseudo_barinel_susp": 0.004629629629629629
        }
    },
    {
        "name": "luigi.task_history.NopHistory.task_scheduled#76",
        "src_path": "luigi/task_history.py",
        "class_name": "luigi.task_history.NopHistory",
        "signature": "luigi.task_history.NopHistory.task_scheduled(self, task)",
        "snippet": "    def task_scheduled(self, task):\n        pass",
        "begin_line": 76,
        "end_line": 77,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004945598417408506,
            "pseudo_dstar_susp": 0.0006389776357827476,
            "pseudo_tarantula_susp": 0.0004780114722753346,
            "pseudo_op2_susp": 0.0006389776357827476,
            "pseudo_barinel_susp": 0.0004780114722753346
        }
    },
    {
        "name": "luigi.task_history.NopHistory.task_finished#79",
        "src_path": "luigi/task_history.py",
        "class_name": "luigi.task_history.NopHistory",
        "signature": "luigi.task_history.NopHistory.task_finished(self, task, successful)",
        "snippet": "    def task_finished(self, task, successful):\n        pass",
        "begin_line": 79,
        "end_line": 80,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007369196757553427,
            "pseudo_dstar_susp": 0.0013315579227696406,
            "pseudo_tarantula_susp": 0.0006277463904582549,
            "pseudo_op2_susp": 0.0013315579227696406,
            "pseudo_barinel_susp": 0.0006277463904582549
        }
    },
    {
        "name": "luigi.task_history.NopHistory.task_started#82",
        "src_path": "luigi/task_history.py",
        "class_name": "luigi.task_history.NopHistory",
        "signature": "luigi.task_history.NopHistory.task_started(self, task, worker_host)",
        "snippet": "    def task_started(self, task, worker_host):\n        pass",
        "begin_line": 82,
        "end_line": 83,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000514668039114771,
            "pseudo_dstar_susp": 0.0006626905235255136,
            "pseudo_tarantula_susp": 0.0005157297576070139,
            "pseudo_op2_susp": 0.0006626905235255136,
            "pseudo_barinel_susp": 0.0005157297576070139
        }
    },
    {
        "name": "luigi.contrib.hdfs.clients.get_autoconfig_client#36",
        "src_path": "luigi/contrib/hdfs/clients.py",
        "class_name": "luigi.contrib.hdfs.clients",
        "signature": "luigi.contrib.hdfs.clients.get_autoconfig_client(client_cache=_AUTOCONFIG_CLIENT)",
        "snippet": "def get_autoconfig_client(client_cache=_AUTOCONFIG_CLIENT):\n    \"\"\"\n    Creates the client as specified in the `luigi.cfg` configuration.\n    \"\"\"\n    try:\n        return client_cache.client\n    except AttributeError:\n        configured_client = hdfs_config.get_configured_hdfs_client()\n        if configured_client == \"webhdfs\":\n            client_cache.client = hdfs_webhdfs_client.WebHdfsClient()\n        elif configured_client == \"snakebite\":\n            client_cache.client = hdfs_snakebite_client.SnakebiteHdfsClient()\n        elif configured_client == \"snakebite_with_hadoopcli_fallback\":\n            client_cache.client = luigi.contrib.target.CascadingClient([\n                hdfs_snakebite_client.SnakebiteHdfsClient(),\n                hdfs_hadoopcli_clients.create_hadoopcli_client(),\n            ])\n        elif configured_client == \"hadoopcli\":\n            client_cache.client = hdfs_hadoopcli_clients.create_hadoopcli_client()\n        else:\n            raise Exception(\"Unknown hdfs client \" + configured_client)\n        return client_cache.client",
        "begin_line": 36,
        "end_line": 57,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.lock.getpcmd#33",
        "src_path": "luigi/lock.py",
        "class_name": "luigi.lock",
        "signature": "luigi.lock.getpcmd(pid)",
        "snippet": "def getpcmd(pid):\n    \"\"\"\n    Returns command of process.\n\n    :param pid:\n    \"\"\"\n    if os.name == \"nt\":\n        # Use wmic command instead of ps on Windows.\n        cmd = 'wmic path win32_process where ProcessID=%s get Commandline 2> nul' % (pid, )\n        with os.popen(cmd, 'r') as p:\n            lines = [line for line in p.readlines() if line.strip(\"\\r\\n \") != \"\"]\n            if lines:\n                _, val = lines\n                return val\n    elif sys.platform == \"darwin\":\n        # Use pgrep instead of /proc on macOS.\n        pidfile = \".%d.pid\" % (pid, )\n        with open(pidfile, 'w') as f:\n            f.write(str(pid))\n        try:\n            p = Popen(['pgrep', '-lf', '-F', pidfile], stdout=PIPE)\n            stdout, _ = p.communicate()\n            line = stdout.decode('utf8').strip()\n            if line:\n                _, scmd = line.split(' ', 1)\n                return scmd\n        finally:\n            os.unlink(pidfile)\n    else:\n        # Use the /proc filesystem\n        # At least on android there have been some issues with not all\n        # process infos being readable. In these cases using the `ps` command\n        # worked. See the pull request at\n        # https://github.com/spotify/luigi/pull/1876\n        try:\n            with open('/proc/{0}/cmdline'.format(pid), 'r') as fh:\n                if six.PY3:\n                    return fh.read().replace('\\0', ' ').rstrip()\n                else:\n                    return fh.read().replace('\\0', ' ').decode('utf8').rstrip()\n        except IOError:\n            # the system may not allow reading the command line\n            # of a process owned by another user\n            pass\n\n    # Fallback instead of None, for e.g. Cygwin where -o is an \"unknown option\" for the ps command:\n    return '[PROCESS_WITH_PID={}]'.format(pid)",
        "begin_line": 33,
        "end_line": 79,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.lock.get_info#82",
        "src_path": "luigi/lock.py",
        "class_name": "luigi.lock",
        "signature": "luigi.lock.get_info(pid_dir, my_pid=None)",
        "snippet": "def get_info(pid_dir, my_pid=None):\n    # Check the name and pid of this process\n    if my_pid is None:\n        my_pid = os.getpid()\n\n    my_cmd = getpcmd(my_pid)\n    cmd_hash = my_cmd.encode('utf8')\n    pid_file = os.path.join(pid_dir, hashlib.md5(cmd_hash).hexdigest()) + '.pid'\n\n    return my_pid, my_cmd, pid_file",
        "begin_line": 82,
        "end_line": 91,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.lock.acquire_for#94",
        "src_path": "luigi/lock.py",
        "class_name": "luigi.lock",
        "signature": "luigi.lock.acquire_for(pid_dir, num_available=1, kill_signal=None)",
        "snippet": "def acquire_for(pid_dir, num_available=1, kill_signal=None):\n    \"\"\"\n    Makes sure the process is only run once at the same time with the same name.\n\n    Notice that we since we check the process name, different parameters to the same\n    command can spawn multiple processes at the same time, i.e. running\n    \"/usr/bin/my_process\" does not prevent anyone from launching\n    \"/usr/bin/my_process --foo bar\".\n    \"\"\"\n\n    my_pid, my_cmd, pid_file = get_info(pid_dir)\n\n    # Create a pid file if it does not exist\n    try:\n        os.mkdir(pid_dir)\n        os.chmod(pid_dir, 0o777)\n    except OSError as exc:\n        if exc.errno != errno.EEXIST:\n            raise\n        pass\n\n    # Let variable \"pids\" be all pids who exist in the .pid-file who are still\n    # about running the same command.\n    pids = {pid for pid in _read_pids_file(pid_file) if getpcmd(pid) == my_cmd}\n\n    if kill_signal is not None:\n        for pid in pids:\n            os.kill(pid, kill_signal)\n        print('Sent kill signal to Pids: {}'.format(pids))\n        # We allow for the killer to progress, yet we don't want these to stack\n        # up! So we only allow it once.\n        num_available += 1\n\n    if len(pids) >= num_available:\n        # We are already running under a different pid\n        print('Pid(s) {} already running'.format(pids))\n        if kill_signal is not None:\n            print('Note: There have (probably) been 1 other \"--take-lock\"'\n                  ' process which continued to run! Probably no need to run'\n                  ' this one as well.')\n        return False\n\n    _write_pids_file(pid_file, pids | {my_pid})\n\n    return True",
        "begin_line": 94,
        "end_line": 138,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.lock._read_pids_file#141",
        "src_path": "luigi/lock.py",
        "class_name": "luigi.lock",
        "signature": "luigi.lock._read_pids_file(pid_file)",
        "snippet": "def _read_pids_file(pid_file):\n    # First setup a python 2 vs 3 compatibility\n    # http://stackoverflow.com/a/21368622/621449\n    try:\n        FileNotFoundError\n    except NameError:\n        # Should only happen on python 2\n        FileNotFoundError = IOError\n    # If the file happen to not exist, simply return\n    # an empty set()\n    try:\n        with open(pid_file, 'r') as f:\n            return {int(pid_str.strip()) for pid_str in f if pid_str.strip()}\n    except FileNotFoundError:\n        return set()",
        "begin_line": 141,
        "end_line": 155,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.lock._write_pids_file#158",
        "src_path": "luigi/lock.py",
        "class_name": "luigi.lock",
        "signature": "luigi.lock._write_pids_file(pid_file, pids_set)",
        "snippet": "def _write_pids_file(pid_file, pids_set):\n    with open(pid_file, 'w') as f:\n        f.writelines('{}\\n'.format(pid) for pid in pids_set)\n\n    # Make the .pid-file writable by all (when the os allows for it)\n    if os.name != 'nt':\n        s = os.stat(pid_file)\n        if os.getuid() == s.st_uid:\n            os.chmod(pid_file, s.st_mode | 0o777)",
        "begin_line": 158,
        "end_line": 166,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.worker._is_external#87",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker",
        "signature": "luigi.worker._is_external(task)",
        "snippet": "def _is_external(task):\n    return task.run is None or task.run == NotImplemented",
        "begin_line": 87,
        "end_line": 88,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005931198102016608,
            "pseudo_dstar_susp": 0.0007002801120448179,
            "pseudo_tarantula_susp": 0.0005896226415094339,
            "pseudo_op2_susp": 0.0007002801120448179,
            "pseudo_barinel_susp": 0.0005896226415094339
        }
    },
    {
        "name": "luigi.worker._get_retry_policy_dict#91",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker",
        "signature": "luigi.worker._get_retry_policy_dict(task)",
        "snippet": "def _get_retry_policy_dict(task):\n    return RetryPolicy(task.retry_count, task.disable_hard_timeout, task.disable_window_seconds)._asdict()",
        "begin_line": 91,
        "end_line": 92,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000855431993156544,
            "pseudo_dstar_susp": 0.0015037593984962407,
            "pseudo_tarantula_susp": 0.0007142857142857143,
            "pseudo_op2_susp": 0.0015037593984962407,
            "pseudo_barinel_susp": 0.0007142857142857143
        }
    },
    {
        "name": "luigi.worker.TaskProcess.__init__#125",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.TaskProcess",
        "signature": "luigi.worker.TaskProcess.__init__(self, task, worker_id, result_queue, status_reporter, use_multiprocessing=False, worker_timeout=0, check_unfulfilled_deps=True)",
        "snippet": "    def __init__(self, task, worker_id, result_queue, status_reporter,\n                 use_multiprocessing=False, worker_timeout=0, check_unfulfilled_deps=True):\n        super(TaskProcess, self).__init__()\n        self.task = task\n        self.worker_id = worker_id\n        self.result_queue = result_queue\n        self.status_reporter = status_reporter\n        if task.worker_timeout is not None:\n            worker_timeout = task.worker_timeout\n        self.timeout_time = time.time() + worker_timeout if worker_timeout else None\n        self.use_multiprocessing = use_multiprocessing or self.timeout_time is not None\n        self.check_unfulfilled_deps = check_unfulfilled_deps",
        "begin_line": 125,
        "end_line": 136,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006277463904582549,
            "pseudo_dstar_susp": 0.0007267441860465116,
            "pseudo_tarantula_susp": 0.0006397952655150352,
            "pseudo_op2_susp": 0.0007267441860465116,
            "pseudo_barinel_susp": 0.0006397952655150352
        }
    },
    {
        "name": "luigi.worker.TaskProcess._run_get_new_deps#138",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.TaskProcess",
        "signature": "luigi.worker.TaskProcess._run_get_new_deps(self)",
        "snippet": "    def _run_get_new_deps(self):\n        task_gen = self.task.run()\n\n        if not isinstance(task_gen, types.GeneratorType):\n            return None\n\n        next_send = None\n        while True:\n            try:\n                if next_send is None:\n                    requires = six.next(task_gen)\n                else:\n                    requires = task_gen.send(next_send)\n            except StopIteration:\n                return None\n\n            new_req = flatten(requires)\n            if all(t.complete() for t in new_req):\n                next_send = getpaths(requires)\n            else:\n                new_deps = [(t.task_module, t.task_family, t.to_str_params())\n                            for t in new_req]\n                return new_deps",
        "begin_line": 138,
        "end_line": 160,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00048216007714561236,
            "pseudo_dstar_susp": 0.00048216007714561236,
            "pseudo_tarantula_susp": 0.0005271481286241434,
            "pseudo_op2_susp": 0.00048216007714561236,
            "pseudo_barinel_susp": 0.0005271481286241434
        }
    },
    {
        "name": "luigi.worker.TaskProcess.run#162",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.TaskProcess",
        "signature": "luigi.worker.TaskProcess.run(self)",
        "snippet": "    def run(self):\n        logger.info('[pid %s] Worker %s running   %s', os.getpid(), self.worker_id, self.task)\n\n        if self.use_multiprocessing:\n            # Need to have different random seeds if running in separate processes\n            random.seed((os.getpid(), time.time()))\n\n        status = FAILED\n        expl = ''\n        missing = []\n        new_deps = []\n        try:\n            # Verify that all the tasks are fulfilled! For external tasks we\n            # don't care about unfulfilled dependencies, because we are just\n            # checking completeness of self.task so outputs of dependencies are\n            # irrelevant.\n            if self.check_unfulfilled_deps and not _is_external(self.task):\n                missing = [dep.task_id for dep in self.task.deps() if not dep.complete()]\n                if missing:\n                    deps = 'dependency' if len(missing) == 1 else 'dependencies'\n                    raise RuntimeError('Unfulfilled %s at run time: %s' % (deps, ', '.join(missing)))\n            self.task.trigger_event(Event.START, self.task)\n            t0 = time.time()\n            status = None\n\n            if _is_external(self.task):\n                # External task\n                # TODO(erikbern): We should check for task completeness after non-external tasks too!\n                # This will resolve #814 and make things a lot more consistent\n                if self.task.complete():\n                    status = DONE\n                else:\n                    status = FAILED\n                    expl = 'Task is an external data dependency ' \\\n                        'and data does not exist (yet?).'\n            else:\n                with self._forward_attributes():\n                    new_deps = self._run_get_new_deps()\n                status = DONE if not new_deps else PENDING\n\n            if new_deps:\n                logger.info(\n                    '[pid %s] Worker %s new requirements      %s',\n                    os.getpid(), self.worker_id, self.task)\n            elif status == DONE:\n                self.task.trigger_event(\n                    Event.PROCESSING_TIME, self.task, time.time() - t0)\n                expl = self.task.on_success()\n                logger.info('[pid %s] Worker %s done      %s', os.getpid(),\n                            self.worker_id, self.task)\n                self.task.trigger_event(Event.SUCCESS, self.task)\n\n        except KeyboardInterrupt:\n            raise\n        except BaseException as ex:\n            status = FAILED\n            logger.exception(\"[pid %s] Worker %s failed    %s\", os.getpid(), self.worker_id, self.task)\n            self.task.trigger_event(Event.FAILURE, self.task, ex)\n            raw_error_message = self.task.on_failure(ex)\n            expl = raw_error_message\n\n        finally:\n            self.result_queue.put(\n                (self.task.task_id, status, expl, missing, new_deps))",
        "begin_line": 162,
        "end_line": 225,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006821282401091405,
            "pseudo_dstar_susp": 0.0006657789613848203,
            "pseudo_tarantula_susp": 0.001303780964797914,
            "pseudo_op2_susp": 0.0006657789613848203,
            "pseudo_barinel_susp": 0.001303780964797914
        }
    },
    {
        "name": "luigi.worker.TaskProcess._recursive_terminate#227",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.TaskProcess",
        "signature": "luigi.worker.TaskProcess._recursive_terminate(self)",
        "snippet": "    def _recursive_terminate(self):\n        import psutil\n\n        try:\n            parent = psutil.Process(self.pid)\n            children = parent.children(recursive=True)\n\n            # terminate parent. Give it a chance to clean up\n            super(TaskProcess, self).terminate()\n            parent.wait()\n\n            # terminate children\n            for child in children:\n                try:\n                    child.terminate()\n                except psutil.NoSuchProcess:\n                    continue\n        except psutil.NoSuchProcess:\n            return",
        "begin_line": 227,
        "end_line": 245,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.worker.TaskProcess.terminate#247",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.TaskProcess",
        "signature": "luigi.worker.TaskProcess.terminate(self)",
        "snippet": "    def terminate(self):\n        \"\"\"Terminate this process and its subprocesses.\"\"\"\n        # default terminate() doesn't cleanup child processes, it orphans them.\n        try:\n            return self._recursive_terminate()\n        except ImportError:\n            return super(TaskProcess, self).terminate()",
        "begin_line": 247,
        "end_line": 253,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.worker.TaskProcess._forward_attributes#256",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.TaskProcess",
        "signature": "luigi.worker.TaskProcess._forward_attributes(self)",
        "snippet": "    def _forward_attributes(self):\n        # forward configured attributes to the task\n        for reporter_attr, task_attr in six.iteritems(self.forward_reporter_attributes):\n            setattr(self.task, task_attr, getattr(self.status_reporter, reporter_attr))\n        try:\n            yield self\n        finally:\n            # reset attributes again\n            for reporter_attr, task_attr in six.iteritems(self.forward_reporter_attributes):\n                setattr(self.task, task_attr, None)",
        "begin_line": 256,
        "end_line": 265,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00048216007714561236,
            "pseudo_dstar_susp": 0.00048216007714561236,
            "pseudo_tarantula_susp": 0.0005271481286241434,
            "pseudo_op2_susp": 0.00048216007714561236,
            "pseudo_barinel_susp": 0.0005271481286241434
        }
    },
    {
        "name": "luigi.worker.ContextManagedTaskProcess.__init__#271",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.ContextManagedTaskProcess",
        "signature": "luigi.worker.ContextManagedTaskProcess.__init__(self, context, *args, **kwargs)",
        "snippet": "    def __init__(self, context, *args, **kwargs):\n        super(ContextManagedTaskProcess, self).__init__(*args, **kwargs)\n        self.context = context",
        "begin_line": 271,
        "end_line": 273,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006361323155216285,
            "pseudo_dstar_susp": 0.0007380073800738007,
            "pseudo_tarantula_susp": 0.0006485084306095979,
            "pseudo_op2_susp": 0.0007380073800738007,
            "pseudo_barinel_susp": 0.0006485084306095979
        }
    },
    {
        "name": "luigi.worker.ContextManagedTaskProcess.run#275",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.ContextManagedTaskProcess",
        "signature": "luigi.worker.ContextManagedTaskProcess.run(self)",
        "snippet": "    def run(self):\n        if self.context:\n            logger.debug('Importing module and instantiating ' + self.context)\n            module_path, class_name = self.context.rsplit('.', 1)\n            module = importlib.import_module(module_path)\n            cls = getattr(module, class_name)\n\n            with cls(self):\n                super(ContextManagedTaskProcess, self).run()\n        else:\n            super(ContextManagedTaskProcess, self).run()",
        "begin_line": 275,
        "end_line": 285,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004837929366231253,
            "pseudo_dstar_susp": 0.0004837929366231253,
            "pseudo_tarantula_susp": 0.0005302226935312832,
            "pseudo_op2_susp": 0.0004837929366231253,
            "pseudo_barinel_susp": 0.0005302226935312832
        }
    },
    {
        "name": "luigi.worker.TaskStatusReporter.__init__#295",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.TaskStatusReporter",
        "signature": "luigi.worker.TaskStatusReporter.__init__(self, scheduler, task_id, worker_id, scheduler_messages)",
        "snippet": "    def __init__(self, scheduler, task_id, worker_id, scheduler_messages):\n        self._task_id = task_id\n        self._worker_id = worker_id\n        self._scheduler = scheduler\n        self.scheduler_messages = scheduler_messages",
        "begin_line": 295,
        "end_line": 299,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006325110689437065,
            "pseudo_dstar_susp": 0.0007331378299120235,
            "pseudo_tarantula_susp": 0.0006447453255963894,
            "pseudo_op2_susp": 0.0007331378299120235,
            "pseudo_barinel_susp": 0.0006447453255963894
        }
    },
    {
        "name": "luigi.worker.TaskStatusReporter.update_tracking_url#301",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.TaskStatusReporter",
        "signature": "luigi.worker.TaskStatusReporter.update_tracking_url(self, tracking_url)",
        "snippet": "    def update_tracking_url(self, tracking_url):\n        self._scheduler.add_task(\n            task_id=self._task_id,\n            worker=self._worker_id,\n            status=RUNNING,\n            tracking_url=tracking_url\n        )",
        "begin_line": 301,
        "end_line": 307,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.worker.TaskStatusReporter.update_status_message#309",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.TaskStatusReporter",
        "signature": "luigi.worker.TaskStatusReporter.update_status_message(self, message)",
        "snippet": "    def update_status_message(self, message):\n        self._scheduler.set_task_status_message(self._task_id, message)",
        "begin_line": 309,
        "end_line": 310,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.worker.TaskStatusReporter.update_progress_percentage#312",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.TaskStatusReporter",
        "signature": "luigi.worker.TaskStatusReporter.update_progress_percentage(self, percentage)",
        "snippet": "    def update_progress_percentage(self, percentage):\n        self._scheduler.set_task_progress_percentage(self._task_id, percentage)",
        "begin_line": 312,
        "end_line": 313,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.worker.TaskStatusReporter.decrease_running_resources#315",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.TaskStatusReporter",
        "signature": "luigi.worker.TaskStatusReporter.decrease_running_resources(self, decrease_resources)",
        "snippet": "    def decrease_running_resources(self, decrease_resources):\n        self._scheduler.decrease_running_task_resources(self._task_id, decrease_resources)",
        "begin_line": 315,
        "end_line": 316,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.worker.SchedulerMessage.__init__#325",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.SchedulerMessage",
        "signature": "luigi.worker.SchedulerMessage.__init__(self, scheduler, task_id, message_id, content, **payload)",
        "snippet": "    def __init__(self, scheduler, task_id, message_id, content, **payload):\n        super(SchedulerMessage, self).__init__()\n\n        self._scheduler = scheduler\n        self._task_id = task_id\n        self._message_id = message_id\n\n        self.content = content\n        self.payload = payload",
        "begin_line": 325,
        "end_line": 333,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.worker.SingleProcessPool.apply_async#352",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.SingleProcessPool",
        "signature": "luigi.worker.SingleProcessPool.apply_async(self, function, args)",
        "snippet": "    def apply_async(self, function, args):\n        return function(*args)",
        "begin_line": 352,
        "end_line": 353,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008873114463176575,
            "pseudo_dstar_susp": 0.0015873015873015873,
            "pseudo_tarantula_susp": 0.0007380073800738007,
            "pseudo_op2_susp": 0.0015873015873015873,
            "pseudo_barinel_susp": 0.0007369196757553427
        }
    },
    {
        "name": "luigi.worker.SingleProcessPool.close#355",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.SingleProcessPool",
        "signature": "luigi.worker.SingleProcessPool.close(self)",
        "snippet": "    def close(self):\n        pass",
        "begin_line": 355,
        "end_line": 356,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008936550491510277,
            "pseudo_dstar_susp": 0.001607717041800643,
            "pseudo_tarantula_susp": 0.0007423904974016332,
            "pseudo_op2_susp": 0.001607717041800643,
            "pseudo_barinel_susp": 0.0007423904974016332
        }
    },
    {
        "name": "luigi.worker.SingleProcessPool.join#358",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.SingleProcessPool",
        "signature": "luigi.worker.SingleProcessPool.join(self)",
        "snippet": "    def join(self):\n        pass",
        "begin_line": 358,
        "end_line": 359,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008936550491510277,
            "pseudo_dstar_susp": 0.001607717041800643,
            "pseudo_tarantula_susp": 0.0007423904974016332,
            "pseudo_op2_susp": 0.001607717041800643,
            "pseudo_barinel_susp": 0.0007423904974016332
        }
    },
    {
        "name": "luigi.worker.DequeQueue.put#367",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.DequeQueue",
        "signature": "luigi.worker.DequeQueue.put(self, obj, block=None, timeout=None)",
        "snippet": "    def put(self, obj, block=None, timeout=None):\n        return self.append(obj)",
        "begin_line": 367,
        "end_line": 368,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008936550491510277,
            "pseudo_dstar_susp": 0.001607717041800643,
            "pseudo_tarantula_susp": 0.0007423904974016332,
            "pseudo_op2_susp": 0.001607717041800643,
            "pseudo_barinel_susp": 0.0007423904974016332
        }
    },
    {
        "name": "luigi.worker.DequeQueue.get#370",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.DequeQueue",
        "signature": "luigi.worker.DequeQueue.get(self, block=None, timeout=None)",
        "snippet": "    def get(self, block=None, timeout=None):\n        try:\n            return self.pop()\n        except IndexError:\n            raise Queue.Empty",
        "begin_line": 370,
        "end_line": 374,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008936550491510277,
            "pseudo_dstar_susp": 0.001607717041800643,
            "pseudo_tarantula_susp": 0.0007423904974016332,
            "pseudo_op2_susp": 0.001607717041800643,
            "pseudo_barinel_susp": 0.0007423904974016332
        }
    },
    {
        "name": "luigi.worker.AsyncCompletionException.__init__#382",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.AsyncCompletionException",
        "signature": "luigi.worker.AsyncCompletionException.__init__(self, trace)",
        "snippet": "    def __init__(self, trace):\n        self.trace = trace",
        "begin_line": 382,
        "end_line": 383,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019747235387045813,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.worker.TracebackWrapper.__init__#391",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.TracebackWrapper",
        "signature": "luigi.worker.TracebackWrapper.__init__(self, trace)",
        "snippet": "    def __init__(self, trace):\n        self.trace = trace",
        "begin_line": 391,
        "end_line": 392,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.worker.check_complete#395",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker",
        "signature": "luigi.worker.check_complete(task, out_queue)",
        "snippet": "def check_complete(task, out_queue):\n    \"\"\"\n    Checks if task is complete, puts the result to out_queue.\n    \"\"\"\n    logger.debug(\"Checking if %s is complete\", task)\n    try:\n        is_complete = task.complete()\n    except Exception:\n        is_complete = TracebackWrapper(traceback.format_exc())\n    out_queue.put((task, is_complete))",
        "begin_line": 395,
        "end_line": 404,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008936550491510277,
            "pseudo_dstar_susp": 0.001607717041800643,
            "pseudo_tarantula_susp": 0.0007423904974016332,
            "pseudo_op2_susp": 0.001607717041800643,
            "pseudo_barinel_susp": 0.0007423904974016332
        }
    },
    {
        "name": "luigi.worker.KeepAliveThread.__init__#462",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.KeepAliveThread",
        "signature": "luigi.worker.KeepAliveThread.__init__(self, scheduler, worker_id, ping_interval, rpc_message_callback)",
        "snippet": "    def __init__(self, scheduler, worker_id, ping_interval, rpc_message_callback):\n        super(KeepAliveThread, self).__init__()\n        self._should_stop = threading.Event()\n        self._scheduler = scheduler\n        self._worker_id = worker_id\n        self._ping_interval = ping_interval\n        self._rpc_message_callback = rpc_message_callback",
        "begin_line": 462,
        "end_line": 468,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006079027355623101,
            "pseudo_dstar_susp": 0.0007158196134574087,
            "pseudo_tarantula_susp": 0.0006024096385542169,
            "pseudo_op2_susp": 0.0007158196134574087,
            "pseudo_barinel_susp": 0.0006024096385542169
        }
    },
    {
        "name": "luigi.worker.KeepAliveThread.stop#470",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.KeepAliveThread",
        "signature": "luigi.worker.KeepAliveThread.stop(self)",
        "snippet": "    def stop(self):\n        self._should_stop.set()",
        "begin_line": 470,
        "end_line": 471,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006079027355623101,
            "pseudo_dstar_susp": 0.0007158196134574087,
            "pseudo_tarantula_susp": 0.0006024096385542169,
            "pseudo_op2_susp": 0.0007158196134574087,
            "pseudo_barinel_susp": 0.0006024096385542169
        }
    },
    {
        "name": "luigi.worker.KeepAliveThread.run#473",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.KeepAliveThread",
        "signature": "luigi.worker.KeepAliveThread.run(self)",
        "snippet": "    def run(self):\n        while True:\n            self._should_stop.wait(self._ping_interval)\n            if self._should_stop.is_set():\n                logger.info(\"Worker %s was stopped. Shutting down Keep-Alive thread\" % self._worker_id)\n                break\n            with fork_lock:\n                response = None\n                try:\n                    response = self._scheduler.ping(worker=self._worker_id)\n                except BaseException:  # httplib.BadStatusLine:\n                    logger.warning('Failed pinging scheduler')\n\n                # handle rpc messages\n                if response:\n                    for message in response[\"rpc_messages\"]:\n                        self._rpc_message_callback(message)",
        "begin_line": 473,
        "end_line": 489,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006079027355623101,
            "pseudo_dstar_susp": 0.0007158196134574087,
            "pseudo_tarantula_susp": 0.0006024096385542169,
            "pseudo_op2_susp": 0.0007158196134574087,
            "pseudo_barinel_susp": 0.0006024096385542169
        }
    },
    {
        "name": "luigi.worker.Worker.__init__#507",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker.__init__(self, scheduler=None, worker_id=None, worker_processes=1, assistant=False, **kwargs)",
        "snippet": "    def __init__(self, scheduler=None, worker_id=None, worker_processes=1, assistant=False, **kwargs):\n        if scheduler is None:\n            scheduler = Scheduler()\n\n        self.worker_processes = int(worker_processes)\n        self._worker_info = self._generate_worker_info()\n\n        if not worker_id:\n            worker_id = 'Worker(%s)' % ', '.join(['%s=%s' % (k, v) for k, v in self._worker_info])\n\n        self._config = worker(**kwargs)\n\n        assert self._config.wait_interval >= _WAIT_INTERVAL_EPS, \"[worker] wait_interval must be positive\"\n        assert self._config.wait_jitter >= 0.0, \"[worker] wait_jitter must be equal or greater than zero\"\n\n        self._id = worker_id\n        self._scheduler = scheduler\n        self._assistant = assistant\n        self._stop_requesting_work = False\n\n        self.host = socket.gethostname()\n        self._scheduled_tasks = {}\n        self._suspended_tasks = {}\n        self._batch_running_tasks = {}\n        self._batch_families_sent = set()\n\n        self._first_task = None\n\n        self.add_succeeded = True\n        self.run_succeeded = True\n\n        self.unfulfilled_counts = collections.defaultdict(int)\n\n        # note that ``signal.signal(signal.SIGUSR1, fn)`` only works inside the main execution thread, which is why we\n        # provide the ability to conditionally install the hook.\n        if not self._config.no_install_shutdown_handler:\n            try:\n                signal.signal(signal.SIGUSR1, self.handle_interrupt)\n                signal.siginterrupt(signal.SIGUSR1, False)\n            except AttributeError:\n                pass\n\n        # Keep info about what tasks are running (could be in other processes)\n        self._task_result_queue = multiprocessing.Queue()\n        self._running_tasks = {}\n\n        # Stuff for execution_summary\n        self._add_task_history = []\n        self._get_work_response_history = []",
        "begin_line": 507,
        "end_line": 555,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001524390243902439,
            "pseudo_dstar_susp": 0.005747126436781609,
            "pseudo_tarantula_susp": 0.0017152658662092624,
            "pseudo_op2_susp": 0.005747126436781609,
            "pseudo_barinel_susp": 0.0017152658662092624
        }
    },
    {
        "name": "luigi.worker.Worker._add_task#557",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._add_task(self, *args, **kwargs)",
        "snippet": "    def _add_task(self, *args, **kwargs):\n        \"\"\"\n        Call ``self._scheduler.add_task``, but store the values too so we can\n        implement :py:func:`luigi.execution_summary.summary`.\n        \"\"\"\n        task_id = kwargs['task_id']\n        status = kwargs['status']\n        runnable = kwargs['runnable']\n        task = self._scheduled_tasks.get(task_id)\n        if task:\n            self._add_task_history.append((task, status, runnable))\n            kwargs['owners'] = task._owner_list()\n\n        if task_id in self._batch_running_tasks:\n            for batch_task in self._batch_running_tasks.pop(task_id):\n                self._add_task_history.append((batch_task, status, True))\n\n        if task and kwargs.get('params'):\n            kwargs['param_visibilities'] = task._get_param_visibilities()\n\n        self._scheduler.add_task(*args, **kwargs)\n\n        logger.info('Informed scheduler that task   %s   has status   %s', task_id, status)",
        "begin_line": 557,
        "end_line": 579,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008718395815170009,
            "pseudo_dstar_susp": 0.0015552099533437014,
            "pseudo_tarantula_susp": 0.0008084074373484236,
            "pseudo_op2_susp": 0.0015552099533437014,
            "pseudo_barinel_susp": 0.0008084074373484236
        }
    },
    {
        "name": "luigi.worker.Worker.__enter__#581",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker.__enter__(self)",
        "snippet": "    def __enter__(self):\n        \"\"\"\n        Start the KeepAliveThread.\n        \"\"\"\n        self._keep_alive_thread = KeepAliveThread(self._scheduler, self._id,\n                                                  self._config.ping_interval,\n                                                  self._handle_rpc_message)\n        self._keep_alive_thread.daemon = True\n        self._keep_alive_thread.start()\n        return self",
        "begin_line": 581,
        "end_line": 590,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006079027355623101,
            "pseudo_dstar_susp": 0.0007158196134574087,
            "pseudo_tarantula_susp": 0.0006024096385542169,
            "pseudo_op2_susp": 0.0007158196134574087,
            "pseudo_barinel_susp": 0.0006024096385542169
        }
    },
    {
        "name": "luigi.worker.Worker.__exit__#592",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker.__exit__(self, type, value, traceback)",
        "snippet": "    def __exit__(self, type, value, traceback):\n        \"\"\"\n        Stop the KeepAliveThread and kill still running tasks.\n        \"\"\"\n        self._keep_alive_thread.stop()\n        self._keep_alive_thread.join()\n        for task in self._running_tasks.values():\n            if task.is_alive():\n                task.terminate()\n        return False  # Don't suppress exception",
        "begin_line": 592,
        "end_line": 601,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006079027355623101,
            "pseudo_dstar_susp": 0.0007158196134574087,
            "pseudo_tarantula_susp": 0.0006024096385542169,
            "pseudo_op2_susp": 0.0007158196134574087,
            "pseudo_barinel_susp": 0.0006024096385542169
        }
    },
    {
        "name": "luigi.worker.Worker._generate_worker_info#603",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._generate_worker_info(self)",
        "snippet": "    def _generate_worker_info(self):\n        # Generate as much info as possible about the worker\n        # Some of these calls might not be available on all OS's\n        args = [('salt', '%09d' % random.randrange(0, 999999999)),\n                ('workers', self.worker_processes)]\n        try:\n            args += [('host', socket.gethostname())]\n        except BaseException:\n            pass\n        try:\n            args += [('username', getpass.getuser())]\n        except BaseException:\n            pass\n        try:\n            args += [('pid', os.getpid())]\n        except BaseException:\n            pass\n        try:\n            sudo_user = os.getenv(\"SUDO_USER\")\n            if sudo_user:\n                args.append(('sudo_user', sudo_user))\n        except BaseException:\n            pass\n        return args",
        "begin_line": 603,
        "end_line": 626,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011668611435239206,
            "pseudo_dstar_susp": 0.002577319587628866,
            "pseudo_tarantula_susp": 0.0009216589861751152,
            "pseudo_op2_susp": 0.002577319587628866,
            "pseudo_barinel_susp": 0.0009216589861751152
        }
    },
    {
        "name": "luigi.worker.Worker._validate_task#628",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._validate_task(self, task)",
        "snippet": "    def _validate_task(self, task):\n        if not isinstance(task, Task):\n            raise TaskException('Can not schedule non-task %s' % task)\n\n        if not task.initialized():\n            # we can't get the repr of it since it's not initialized...\n            raise TaskException('Task of class %s not initialized. Did you override __init__ and forget to call super(...).__init__?' % task.__class__.__name__)",
        "begin_line": 628,
        "end_line": 634,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008230452674897119,
            "pseudo_dstar_susp": 0.0014084507042253522,
            "pseudo_tarantula_susp": 0.0006915629322268327,
            "pseudo_op2_susp": 0.0014084507042253522,
            "pseudo_barinel_susp": 0.0006915629322268327
        }
    },
    {
        "name": "luigi.worker.Worker._log_complete_error#636",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._log_complete_error(self, task, tb)",
        "snippet": "    def _log_complete_error(self, task, tb):\n        log_msg = \"Will not run {task} or any dependencies due to error in complete() method:\\n{tb}\".format(task=task, tb=tb)\n        logger.warning(log_msg)",
        "begin_line": 636,
        "end_line": 638,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019102196752626553,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.worker.Worker._log_dependency_error#640",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._log_dependency_error(self, task, tb)",
        "snippet": "    def _log_dependency_error(self, task, tb):\n        log_msg = \"Will not run {task} or any dependencies due to error in deps() method:\\n{tb}\".format(task=task, tb=tb)\n        logger.warning(log_msg)",
        "begin_line": 640,
        "end_line": 642,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00020052135552436334,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.worker.Worker._log_unexpected_error#644",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._log_unexpected_error(self, task)",
        "snippet": "    def _log_unexpected_error(self, task):\n        logger.exception(\"Luigi unexpected framework error while scheduling %s\", task)  # needs to be called from within except clause",
        "begin_line": 644,
        "end_line": 645,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.worker.Worker._announce_scheduling_failure#647",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._announce_scheduling_failure(self, task, expl)",
        "snippet": "    def _announce_scheduling_failure(self, task, expl):\n        try:\n            self._scheduler.announce_scheduling_failure(\n                worker=self._id,\n                task_name=str(task),\n                family=task.task_family,\n                params=task.to_str_params(only_significant=True),\n                expl=expl,\n                owners=task._owner_list(),\n            )\n        except Exception:\n            formatted_traceback = traceback.format_exc()\n            self._email_unexpected_error(task, formatted_traceback)\n            raise",
        "begin_line": 647,
        "end_line": 660,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.worker.Worker._email_complete_error#662",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._email_complete_error(self, task, formatted_traceback)",
        "snippet": "    def _email_complete_error(self, task, formatted_traceback):\n        self._announce_scheduling_failure(task, formatted_traceback)\n        if self._config.send_failure_email:\n            self._email_error(task, formatted_traceback,\n                              subject=\"Luigi: {task} failed scheduling. Host: {host}\",\n                              headline=\"Will not run {task} or any dependencies due to error in complete() method\",\n                              )",
        "begin_line": 662,
        "end_line": 668,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00020052135552436334,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.worker.Worker._email_dependency_error#670",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._email_dependency_error(self, task, formatted_traceback)",
        "snippet": "    def _email_dependency_error(self, task, formatted_traceback):\n        self._announce_scheduling_failure(task, formatted_traceback)\n        if self._config.send_failure_email:\n            self._email_error(task, formatted_traceback,\n                              subject=\"Luigi: {task} failed scheduling. Host: {host}\",\n                              headline=\"Will not run {task} or any dependencies due to error in deps() method\",\n                              )",
        "begin_line": 670,
        "end_line": 676,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.worker.Worker._email_unexpected_error#678",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._email_unexpected_error(self, task, formatted_traceback)",
        "snippet": "    def _email_unexpected_error(self, task, formatted_traceback):\n        # this sends even if failure e-mails are disabled, as they may indicate\n        # a more severe failure that may not reach other alerting methods such\n        # as scheduler batch notification\n        self._email_error(task, formatted_traceback,\n                          subject=\"Luigi: Framework error while scheduling {task}. Host: {host}\",\n                          headline=\"Luigi framework error\",\n                          )",
        "begin_line": 678,
        "end_line": 685,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.worker.Worker._email_task_failure#687",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._email_task_failure(self, task, formatted_traceback)",
        "snippet": "    def _email_task_failure(self, task, formatted_traceback):\n        if self._config.send_failure_email:\n            self._email_error(task, formatted_traceback,\n                              subject=\"Luigi: {task} FAILED. Host: {host}\",\n                              headline=\"A task failed when running. Most likely run() raised an exception.\",\n                              )",
        "begin_line": 687,
        "end_line": 692,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006666666666666666,
            "pseudo_dstar_susp": 0.0005227391531625719,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.0005227391531625719,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "luigi.worker.Worker._email_error#694",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._email_error(self, task, formatted_traceback, subject, headline)",
        "snippet": "    def _email_error(self, task, formatted_traceback, subject, headline):\n        formatted_subject = subject.format(task=task, host=self.host)\n        formatted_headline = headline.format(task=task, host=self.host)\n        command = subprocess.list2cmdline(sys.argv)\n        message = notifications.format_task_error(\n            formatted_headline, task, command, formatted_traceback)\n        notifications.send_error_email(formatted_subject, message, task.owner_email)",
        "begin_line": 694,
        "end_line": 700,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000546448087431694,
            "pseudo_dstar_susp": 0.0005096839959225281,
            "pseudo_tarantula_susp": 0.0009487666034155598,
            "pseudo_op2_susp": 0.0005096839959225281,
            "pseudo_barinel_susp": 0.0009487666034155598
        }
    },
    {
        "name": "luigi.worker.Worker._handle_task_load_error#702",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._handle_task_load_error(self, exception, task_ids)",
        "snippet": "    def _handle_task_load_error(self, exception, task_ids):\n        msg = 'Cannot find task(s) sent by scheduler: {}'.format(','.join(task_ids))\n        logger.exception(msg)\n        subject = 'Luigi: {}'.format(msg)\n        error_message = notifications.wrap_traceback(exception)\n        for task_id in task_ids:\n            self._add_task(\n                worker=self._id,\n                task_id=task_id,\n                status=FAILED,\n                runnable=False,\n                expl=error_message,\n            )\n        notifications.send_error_email(subject, error_message)",
        "begin_line": 702,
        "end_line": 715,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.worker.Worker.add#717",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker.add(self, task, multiprocess=False, processes=0)",
        "snippet": "    def add(self, task, multiprocess=False, processes=0):\n        \"\"\"\n        Add a Task for the worker to check and possibly schedule and run.\n\n        Returns True if task and its dependencies were successfully scheduled or completed before.\n        \"\"\"\n        if self._first_task is None and hasattr(task, 'task_id'):\n            self._first_task = task.task_id\n        self.add_succeeded = True\n        if multiprocess:\n            queue = multiprocessing.Manager().Queue()\n            pool = multiprocessing.Pool(processes=processes if processes > 0 else None)\n        else:\n            queue = DequeQueue()\n            pool = SingleProcessPool()\n        self._validate_task(task)\n        pool.apply_async(check_complete, [task, queue])\n\n        # we track queue size ourselves because len(queue) won't work for multiprocessing\n        queue_size = 1\n        try:\n            seen = {task.task_id}\n            while queue_size:\n                current = queue.get()\n                queue_size -= 1\n                item, is_complete = current\n                for next in self._add(item, is_complete):\n                    if next.task_id not in seen:\n                        self._validate_task(next)\n                        seen.add(next.task_id)\n                        pool.apply_async(check_complete, [next, queue])\n                        queue_size += 1\n        except (KeyboardInterrupt, TaskException):\n            raise\n        except Exception as ex:\n            self.add_succeeded = False\n            formatted_traceback = traceback.format_exc()\n            self._log_unexpected_error(task)\n            task.trigger_event(Event.BROKEN_TASK, task, ex)\n            self._email_unexpected_error(task, formatted_traceback)\n            raise\n        finally:\n            pool.close()\n            pool.join()\n        return self.add_succeeded",
        "begin_line": 717,
        "end_line": 761,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008771929824561404,
            "pseudo_dstar_susp": 0.0015723270440251573,
            "pseudo_tarantula_susp": 0.0007320644216691069,
            "pseudo_op2_susp": 0.0015723270440251573,
            "pseudo_barinel_susp": 0.0007320644216691069
        }
    },
    {
        "name": "luigi.worker.Worker._add_task_batcher#763",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._add_task_batcher(self, task)",
        "snippet": "    def _add_task_batcher(self, task):\n        family = task.task_family\n        if family not in self._batch_families_sent:\n            task_class = type(task)\n            batch_param_names = task_class.batch_param_names()\n            if batch_param_names:\n                self._scheduler.add_task_batcher(\n                    worker=self._id,\n                    task_family=family,\n                    batched_args=batch_param_names,\n                    max_batch_size=task.max_batch_size,\n                )\n            self._batch_families_sent.add(family)",
        "begin_line": 763,
        "end_line": 775,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006002400960384153,
            "pseudo_dstar_susp": 0.0007067137809187279,
            "pseudo_tarantula_susp": 0.0005945303210463733,
            "pseudo_op2_susp": 0.0007067137809187279,
            "pseudo_barinel_susp": 0.0005945303210463733
        }
    },
    {
        "name": "luigi.worker.Worker._add#777",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._add(self, task, is_complete)",
        "snippet": "    def _add(self, task, is_complete):\n        if self._config.task_limit is not None and len(self._scheduled_tasks) >= self._config.task_limit:\n            logger.warning('Will not run %s or any dependencies due to exceeded task-limit of %d', task, self._config.task_limit)\n            deps = None\n            status = UNKNOWN\n            runnable = False\n\n        else:\n            formatted_traceback = None\n            try:\n                self._check_complete_value(is_complete)\n            except KeyboardInterrupt:\n                raise\n            except AsyncCompletionException as ex:\n                formatted_traceback = ex.trace\n            except BaseException:\n                formatted_traceback = traceback.format_exc()\n\n            if formatted_traceback is not None:\n                self.add_succeeded = False\n                self._log_complete_error(task, formatted_traceback)\n                task.trigger_event(Event.DEPENDENCY_MISSING, task)\n                self._email_complete_error(task, formatted_traceback)\n                deps = None\n                status = UNKNOWN\n                runnable = False\n\n            elif is_complete:\n                deps = None\n                status = DONE\n                runnable = False\n                task.trigger_event(Event.DEPENDENCY_PRESENT, task)\n\n            elif _is_external(task):\n                deps = None\n                status = PENDING\n                runnable = self._config.retry_external_tasks\n                task.trigger_event(Event.DEPENDENCY_MISSING, task)\n                logger.warning('Data for %s does not exist (yet?). The task is an '\n                               'external data dependency, so it cannot be run from'\n                               ' this luigi process.', task)\n\n            else:\n                try:\n                    deps = task.deps()\n                    self._add_task_batcher(task)\n                except Exception as ex:\n                    formatted_traceback = traceback.format_exc()\n                    self.add_succeeded = False\n                    self._log_dependency_error(task, formatted_traceback)\n                    task.trigger_event(Event.BROKEN_TASK, task, ex)\n                    self._email_dependency_error(task, formatted_traceback)\n                    deps = None\n                    status = UNKNOWN\n                    runnable = False\n                else:\n                    status = PENDING\n                    runnable = True\n\n            if task.disabled:\n                status = DISABLED\n\n            if deps:\n                for d in deps:\n                    self._validate_dependency(d)\n                    task.trigger_event(Event.DEPENDENCY_DISCOVERED, task, d)\n                    yield d  # return additional tasks to add\n\n                deps = [d.task_id for d in deps]\n\n        self._scheduled_tasks[task.task_id] = task\n        self._add_task(\n            worker=self._id,\n            task_id=task.task_id,\n            status=status,\n            deps=deps,\n            runnable=runnable,\n            priority=task.priority,\n            resources=task.process_resources(),\n            params=task.to_str_params(),\n            family=task.task_family,\n            module=task.task_module,\n            batchable=task.batchable,\n            retry_policy_dict=_get_retry_policy_dict(task),\n            accepts_messages=task.accepts_messages,\n        )",
        "begin_line": 777,
        "end_line": 862,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008976660682226212,
            "pseudo_dstar_susp": 0.0016207455429497568,
            "pseudo_tarantula_susp": 0.001201923076923077,
            "pseudo_op2_susp": 0.0016207455429497568,
            "pseudo_barinel_susp": 0.001201923076923077
        }
    },
    {
        "name": "luigi.worker.Worker._validate_dependency#864",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._validate_dependency(self, dependency)",
        "snippet": "    def _validate_dependency(self, dependency):\n        if isinstance(dependency, Target):\n            raise Exception('requires() can not return Target objects. Wrap it in an ExternalTask class')\n        elif not isinstance(dependency, Task):\n            raise Exception('requires() must return Task objects but {} is a {}'.format(dependency, type(dependency)))",
        "begin_line": 864,
        "end_line": 868,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.worker.Worker._check_complete_value#870",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._check_complete_value(self, is_complete)",
        "snippet": "    def _check_complete_value(self, is_complete):\n        if is_complete not in (True, False):\n            if isinstance(is_complete, TracebackWrapper):\n                raise AsyncCompletionException(is_complete.trace)\n            raise Exception(\"Return value of Task.complete() must be boolean (was %r)\" % is_complete)",
        "begin_line": 870,
        "end_line": 874,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008319467554076539,
            "pseudo_dstar_susp": 0.0014347202295552368,
            "pseudo_tarantula_susp": 0.0006978367062107466,
            "pseudo_op2_susp": 0.0014347202295552368,
            "pseudo_barinel_susp": 0.0006978367062107466
        }
    },
    {
        "name": "luigi.worker.Worker._add_worker#876",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._add_worker(self)",
        "snippet": "    def _add_worker(self):\n        self._worker_info.append(('first_task', self._first_task))\n        self._scheduler.add_worker(self._id, self._worker_info)",
        "begin_line": 876,
        "end_line": 878,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009041591320072332,
            "pseudo_dstar_susp": 0.0016420361247947454,
            "pseudo_tarantula_susp": 0.0007598784194528875,
            "pseudo_op2_susp": 0.0016420361247947454,
            "pseudo_barinel_susp": 0.0007598784194528875
        }
    },
    {
        "name": "luigi.worker.Worker._log_remote_tasks#880",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._log_remote_tasks(self, get_work_response)",
        "snippet": "    def _log_remote_tasks(self, get_work_response):\n        logger.debug(\"Done\")\n        logger.debug(\"There are no more tasks to run at this time\")\n        if get_work_response.running_tasks:\n            for r in get_work_response.running_tasks:\n                logger.debug('%s is currently run by worker %s', r['task_id'], r['worker'])\n        elif get_work_response.n_pending_tasks:\n            logger.debug(\n                \"There are %s pending tasks possibly being run by other workers\",\n                get_work_response.n_pending_tasks)\n            if get_work_response.n_unique_pending:\n                logger.debug(\n                    \"There are %i pending tasks unique to this worker\",\n                    get_work_response.n_unique_pending)\n            if get_work_response.n_pending_last_scheduled:\n                logger.debug(\n                    \"There are %i pending tasks last scheduled by this worker\",\n                    get_work_response.n_pending_last_scheduled)",
        "begin_line": 880,
        "end_line": 897,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009523809523809524,
            "pseudo_dstar_susp": 0.0018050541516245488,
            "pseudo_tarantula_susp": 0.0010940919037199124,
            "pseudo_op2_susp": 0.0018050541516245488,
            "pseudo_barinel_susp": 0.0010940919037199124
        }
    },
    {
        "name": "luigi.worker.Worker._get_work_task_id#899",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._get_work_task_id(self, get_work_response)",
        "snippet": "    def _get_work_task_id(self, get_work_response):\n        if get_work_response.get('task_id') is not None:\n            return get_work_response['task_id']\n        elif 'batch_id' in get_work_response:\n            try:\n                task = load_task(\n                    module=get_work_response.get('task_module'),\n                    task_name=get_work_response['task_family'],\n                    params_str=get_work_response['task_params'],\n                )\n            except Exception as ex:\n                self._handle_task_load_error(ex, get_work_response['batch_task_ids'])\n                self.run_succeeded = False\n                return None\n\n            self._scheduler.add_task(\n                worker=self._id,\n                task_id=task.task_id,\n                module=get_work_response.get('task_module'),\n                family=get_work_response['task_family'],\n                params=task.to_str_params(),\n                status=RUNNING,\n                batch_id=get_work_response['batch_id'],\n            )\n            return task.task_id\n        else:\n            return None",
        "begin_line": 899,
        "end_line": 925,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009398496240601503,
            "pseudo_dstar_susp": 0.0017605633802816902,
            "pseudo_tarantula_susp": 0.0007886435331230284,
            "pseudo_op2_susp": 0.0017605633802816902,
            "pseudo_barinel_susp": 0.0007886435331230284
        }
    },
    {
        "name": "luigi.worker.Worker._get_work#927",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._get_work(self)",
        "snippet": "    def _get_work(self):\n        if self._stop_requesting_work:\n            return GetWorkResponse(None, 0, 0, 0, 0, WORKER_STATE_DISABLED)\n\n        if self.worker_processes > 0:\n            logger.debug(\"Asking scheduler for work...\")\n            r = self._scheduler.get_work(\n                worker=self._id,\n                host=self.host,\n                assistant=self._assistant,\n                current_tasks=list(self._running_tasks.keys()),\n            )\n        else:\n            logger.debug(\"Checking if tasks are still pending\")\n            r = self._scheduler.count_pending(worker=self._id)\n\n        running_tasks = r['running_tasks']\n        task_id = self._get_work_task_id(r)\n\n        self._get_work_response_history.append({\n            'task_id': task_id,\n            'running_tasks': running_tasks,\n        })\n\n        if task_id is not None and task_id not in self._scheduled_tasks:\n            logger.info('Did not schedule %s, will load it dynamically', task_id)\n\n            try:\n                # TODO: we should obtain the module name from the server!\n                self._scheduled_tasks[task_id] = \\\n                    load_task(module=r.get('task_module'),\n                              task_name=r['task_family'],\n                              params_str=r['task_params'])\n            except TaskClassException as ex:\n                self._handle_task_load_error(ex, [task_id])\n                task_id = None\n                self.run_succeeded = False\n\n        if task_id is not None and 'batch_task_ids' in r:\n            batch_tasks = filter(None, [\n                self._scheduled_tasks.get(batch_id) for batch_id in r['batch_task_ids']])\n            self._batch_running_tasks[task_id] = batch_tasks\n\n        return GetWorkResponse(\n            task_id=task_id,\n            running_tasks=running_tasks,\n            n_pending_tasks=r['n_pending_tasks'],\n            n_unique_pending=r['n_unique_pending'],\n\n            # TODO: For a tiny amount of time (a month?) we'll keep forwards compatibility\n            #  That is you can user a newer client than server (Sep 2016)\n            n_pending_last_scheduled=r.get('n_pending_last_scheduled', 0),\n            worker_state=r.get('worker_state', WORKER_STATE_ACTIVE),\n        )",
        "begin_line": 927,
        "end_line": 980,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000949667616334283,
            "pseudo_dstar_susp": 0.0017953321364452424,
            "pseudo_tarantula_susp": 0.0007974481658692185,
            "pseudo_op2_susp": 0.0017953321364452424,
            "pseudo_barinel_susp": 0.0007974481658692185
        }
    },
    {
        "name": "luigi.worker.Worker._run_task#982",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._run_task(self, task_id)",
        "snippet": "    def _run_task(self, task_id):\n        if task_id in self._running_tasks:\n            logger.debug('Got already running task id {} from scheduler, taking a break'.format(task_id))\n            next(self._sleeper())\n            return\n\n        task = self._scheduled_tasks[task_id]\n\n        task_process = self._create_task_process(task)\n\n        self._running_tasks[task_id] = task_process\n\n        if task_process.use_multiprocessing:\n            with fork_lock:\n                task_process.start()\n        else:\n            # Run in the same process\n            task_process.run()",
        "begin_line": 982,
        "end_line": 999,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000757002271006813,
            "pseudo_dstar_susp": 0.0007407407407407407,
            "pseudo_tarantula_susp": 0.0014925373134328358,
            "pseudo_op2_susp": 0.0007407407407407407,
            "pseudo_barinel_susp": 0.0014925373134328358
        }
    },
    {
        "name": "luigi.worker.Worker._create_task_process#1001",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._create_task_process(self, task)",
        "snippet": "    def _create_task_process(self, task):\n        message_queue = multiprocessing.Queue() if task.accepts_messages else None\n        reporter = TaskStatusReporter(self._scheduler, task.task_id, self._id, message_queue)\n        use_multiprocessing = self._config.force_multiprocessing or bool(self.worker_processes > 1)\n        return ContextManagedTaskProcess(\n            self._config.task_process_context,\n            task, self._id, self._task_result_queue, reporter,\n            use_multiprocessing=use_multiprocessing,\n            worker_timeout=self._config.timeout,\n            check_unfulfilled_deps=self._config.check_unfulfilled_deps,\n        )",
        "begin_line": 1001,
        "end_line": 1011,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006325110689437065,
            "pseudo_dstar_susp": 0.0007331378299120235,
            "pseudo_tarantula_susp": 0.0006447453255963894,
            "pseudo_op2_susp": 0.0007331378299120235,
            "pseudo_barinel_susp": 0.0006447453255963894
        }
    },
    {
        "name": "luigi.worker.Worker._purge_children#1013",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._purge_children(self)",
        "snippet": "    def _purge_children(self):\n        \"\"\"\n        Find dead children and put a response on the result queue.\n\n        :return:\n        \"\"\"\n        for task_id, p in six.iteritems(self._running_tasks):\n            if not p.is_alive() and p.exitcode:\n                error_msg = 'Task {} died unexpectedly with exit code {}'.format(task_id, p.exitcode)\n                p.task.trigger_event(Event.PROCESS_FAILURE, p.task, error_msg)\n            elif p.timeout_time is not None and time.time() > float(p.timeout_time) and p.is_alive():\n                p.terminate()\n                error_msg = 'Task {} timed out after {} seconds and was terminated.'.format(task_id, p.task.worker_timeout)\n                p.task.trigger_event(Event.TIMEOUT, p.task, error_msg)\n            else:\n                continue\n\n            logger.info(error_msg)\n            self._task_result_queue.put((task_id, FAILED, error_msg, [], []))",
        "begin_line": 1013,
        "end_line": 1031,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006657789613848203,
            "pseudo_dstar_susp": 0.0007616146230007616,
            "pseudo_tarantula_susp": 0.0006724949562878278,
            "pseudo_op2_susp": 0.0007616146230007616,
            "pseudo_barinel_susp": 0.0006724949562878278
        }
    },
    {
        "name": "luigi.worker.Worker._handle_next_task#1033",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._handle_next_task(self)",
        "snippet": "    def _handle_next_task(self):\n        \"\"\"\n        We have to catch three ways a task can be \"done\":\n\n        1. normal execution: the task runs/fails and puts a result back on the queue,\n        2. new dependencies: the task yielded new deps that were not complete and\n           will be rescheduled and dependencies added,\n        3. child process dies: we need to catch this separately.\n        \"\"\"\n        while True:\n            self._purge_children()  # Deal with subprocess failures\n\n            try:\n                task_id, status, expl, missing, new_requirements = (\n                    self._task_result_queue.get(\n                        timeout=self._config.wait_interval))\n            except Queue.Empty:\n                return\n\n            task = self._scheduled_tasks[task_id]\n            if not task or task_id not in self._running_tasks:\n                continue\n                # Not a running task. Probably already removed.\n                # Maybe it yielded something?\n\n            # external task if run not implemented, retry-able if config option is enabled.\n            external_task_retryable = _is_external(task) and self._config.retry_external_tasks\n            if status == FAILED and not external_task_retryable:\n                self._email_task_failure(task, expl)\n\n            new_deps = []\n            if new_requirements:\n                new_req = [load_task(module, name, params)\n                           for module, name, params in new_requirements]\n                for t in new_req:\n                    self.add(t)\n                new_deps = [t.task_id for t in new_req]\n\n            self._add_task(worker=self._id,\n                           task_id=task_id,\n                           status=status,\n                           expl=json.dumps(expl),\n                           resources=task.process_resources(),\n                           runnable=None,\n                           params=task.to_str_params(),\n                           family=task.task_family,\n                           module=task.task_module,\n                           new_deps=new_deps,\n                           assistant=self._assistant,\n                           retry_policy_dict=_get_retry_policy_dict(task))\n\n            self._running_tasks.pop(task_id)\n\n            # re-add task to reschedule missing dependencies\n            if missing:\n                reschedule = True\n\n                # keep out of infinite loops by not rescheduling too many times\n                for task_id in missing:\n                    self.unfulfilled_counts[task_id] += 1\n                    if (self.unfulfilled_counts[task_id] >\n                            self._config.max_reschedules):\n                        reschedule = False\n                if reschedule:\n                    self.add(task)\n\n            self.run_succeeded &= (status == DONE) or (len(new_deps) > 0)\n            return",
        "begin_line": 1033,
        "end_line": 1100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006583278472679394,
            "pseudo_dstar_susp": 0.0007518796992481203,
            "pseudo_tarantula_susp": 0.0011627906976744186,
            "pseudo_op2_susp": 0.0007518796992481203,
            "pseudo_barinel_susp": 0.0011627906976744186
        }
    },
    {
        "name": "luigi.worker.Worker._sleeper#1102",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._sleeper(self)",
        "snippet": "    def _sleeper(self):\n        # TODO is exponential backoff necessary?\n        while True:\n            jitter = self._config.wait_jitter\n            wait_interval = self._config.wait_interval + random.uniform(0, jitter)\n            logger.debug('Sleeping for %f seconds', wait_interval)\n            time.sleep(wait_interval)\n            yield",
        "begin_line": 1102,
        "end_line": 1109,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009174311926605505,
            "pseudo_dstar_susp": 0.0016863406408094434,
            "pseudo_tarantula_susp": 0.0007692307692307692,
            "pseudo_op2_susp": 0.0016863406408094434,
            "pseudo_barinel_susp": 0.0007692307692307692
        }
    },
    {
        "name": "luigi.worker.Worker._keep_alive#1111",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._keep_alive(self, get_work_response)",
        "snippet": "    def _keep_alive(self, get_work_response):\n        \"\"\"\n        Returns true if a worker should stay alive given.\n\n        If worker-keep-alive is not set, this will always return false.\n        For an assistant, it will always return the value of worker-keep-alive.\n        Otherwise, it will return true for nonzero n_pending_tasks.\n\n        If worker-count-uniques is true, it will also\n        require that one of the tasks is unique to this worker.\n        \"\"\"\n        if not self._config.keep_alive:\n            return False\n        elif self._assistant:\n            return True\n        elif self._config.count_last_scheduled:\n            return get_work_response.n_pending_last_scheduled > 0\n        elif self._config.count_uniques:\n            return get_work_response.n_unique_pending > 0\n        else:\n            return get_work_response.n_pending_tasks > 0",
        "begin_line": 1111,
        "end_line": 1131,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009794319294809011,
            "pseudo_dstar_susp": 0.0018083182640144665,
            "pseudo_tarantula_susp": 0.0008090614886731392,
            "pseudo_op2_susp": 0.0018083182640144665,
            "pseudo_barinel_susp": 0.0008090614886731392
        }
    },
    {
        "name": "luigi.worker.Worker.handle_interrupt#1133",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker.handle_interrupt(self, signum, _)",
        "snippet": "    def handle_interrupt(self, signum, _):\n        \"\"\"\n        Stops the assistant from asking for more work on SIGUSR1\n        \"\"\"\n        if signum == signal.SIGUSR1:\n            self._start_phasing_out()",
        "begin_line": 1133,
        "end_line": 1138,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.worker.Worker._start_phasing_out#1140",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._start_phasing_out(self)",
        "snippet": "    def _start_phasing_out(self):\n        \"\"\"\n        Go into a mode where we dont ask for more work and quit once existing\n        tasks are done.\n        \"\"\"\n        self._config.keep_alive = False\n        self._stop_requesting_work = True",
        "begin_line": 1140,
        "end_line": 1146,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002294630564479119,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.worker.Worker.run#1148",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker.run(self)",
        "snippet": "    def run(self):\n        \"\"\"\n        Returns True if all scheduled tasks were executed successfully.\n        \"\"\"\n        logger.info('Running Worker with %d processes', self.worker_processes)\n\n        sleeper = self._sleeper()\n        self.run_succeeded = True\n\n        self._add_worker()\n\n        while True:\n            while len(self._running_tasks) >= self.worker_processes > 0:\n                logger.debug('%d running tasks, waiting for next task to finish', len(self._running_tasks))\n                self._handle_next_task()\n\n            get_work_response = self._get_work()\n\n            if get_work_response.worker_state == WORKER_STATE_DISABLED:\n                self._start_phasing_out()\n\n            if get_work_response.task_id is None:\n                if not self._stop_requesting_work:\n                    self._log_remote_tasks(get_work_response)\n                if len(self._running_tasks) == 0:\n                    if self._keep_alive(get_work_response):\n                        six.next(sleeper)\n                        continue\n                    else:\n                        break\n                else:\n                    self._handle_next_task()\n                    continue\n\n            # task_id is not None:\n            logger.debug(\"Pending tasks: %s\", get_work_response.n_pending_tasks)\n            self._run_task(get_work_response.task_id)\n\n        while len(self._running_tasks):\n            logger.debug('Shut down Worker, %d more tasks to go', len(self._running_tasks))\n            self._handle_next_task()\n\n        return self.run_succeeded",
        "begin_line": 1148,
        "end_line": 1190,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009398496240601503,
            "pseudo_dstar_susp": 0.0017605633802816902,
            "pseudo_tarantula_susp": 0.0007886435331230284,
            "pseudo_op2_susp": 0.0017605633802816902,
            "pseudo_barinel_susp": 0.0007886435331230284
        }
    },
    {
        "name": "luigi.worker.Worker._handle_rpc_message#1192",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._handle_rpc_message(self, message)",
        "snippet": "    def _handle_rpc_message(self, message):\n        logger.info(\"Worker %s got message %s\" % (self._id, message))\n\n        # the message is a dict {'name': <function_name>, 'kwargs': <function_kwargs>}\n        name = message['name']\n        kwargs = message['kwargs']\n\n        # find the function and check if it's callable and configured to work\n        # as a message callback\n        func = getattr(self, name, None)\n        tpl = (self._id, name)\n        if not callable(func):\n            logger.error(\"Worker %s has no function '%s'\" % tpl)\n        elif not getattr(func, \"is_rpc_message_callback\", False):\n            logger.error(\"Worker %s function '%s' is not available as rpc message callback\" % tpl)\n        else:\n            logger.info(\"Worker %s successfully dispatched rpc message to function '%s'\" % tpl)\n            func(**kwargs)",
        "begin_line": 1192,
        "end_line": 1209,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.worker.Worker.set_worker_processes#1212",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker.set_worker_processes(self, n)",
        "snippet": "    def set_worker_processes(self, n):\n        # set the new value\n        self.worker_processes = max(1, n)\n\n        # tell the scheduler\n        self._scheduler.add_worker(self._id, {'workers': self.worker_processes})",
        "begin_line": 1212,
        "end_line": 1217,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.worker.Worker.dispatch_scheduler_message#1220",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker.dispatch_scheduler_message(self, task_id, message_id, content, **kwargs)",
        "snippet": "    def dispatch_scheduler_message(self, task_id, message_id, content, **kwargs):\n        task_id = str(task_id)\n        if task_id in self._running_tasks:\n            task_process = self._running_tasks[task_id]\n            if task_process.status_reporter.scheduler_messages:\n                message = SchedulerMessage(self._scheduler, task_id, message_id, content, **kwargs)\n                task_process.status_reporter.scheduler_messages.put(message)",
        "begin_line": 1220,
        "end_line": 1226,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.__init__#68",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.__init__(self)",
        "snippet": "    def __init__(self):\n        conf = luigi.configuration.get_config()\n\n        default = os.environ.get('SCALA_HOME', '/usr/share/scala')\n        self.scala_home = conf.get('scalding', 'scala-home', default)\n\n        default = os.environ.get('SCALDING_HOME', '/usr/share/scalding')\n        self.scalding_home = conf.get('scalding', 'scalding-home', default)\n        self.provided_dir = conf.get(\n            'scalding', 'scalding-provided', os.path.join(default, 'provided'))\n        self.libjars_dir = conf.get(\n            'scalding', 'scalding-libjars', os.path.join(default, 'libjars'))\n\n        self.tmp_dir = LocalTarget(is_tmp=True)",
        "begin_line": 68,
        "end_line": 81,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner._get_jars#83",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner._get_jars(self, path)",
        "snippet": "    def _get_jars(self, path):\n        return [os.path.join(path, j) for j in os.listdir(path)\n                if j.endswith('.jar')]",
        "begin_line": 83,
        "end_line": 85,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.get_scala_jars#87",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.get_scala_jars(self, include_compiler=False)",
        "snippet": "    def get_scala_jars(self, include_compiler=False):\n        lib_dir = os.path.join(self.scala_home, 'lib')\n        jars = [os.path.join(lib_dir, 'scala-library.jar')]\n\n        # additional jar for scala 2.10 only\n        reflect = os.path.join(lib_dir, 'scala-reflect.jar')\n        if os.path.exists(reflect):\n            jars.append(reflect)\n\n        if include_compiler:\n            jars.append(os.path.join(lib_dir, 'scala-compiler.jar'))\n\n        return jars",
        "begin_line": 87,
        "end_line": 99,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.get_scalding_jars#101",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.get_scalding_jars(self)",
        "snippet": "    def get_scalding_jars(self):\n        lib_dir = os.path.join(self.scalding_home, 'lib')\n        return self._get_jars(lib_dir)",
        "begin_line": 101,
        "end_line": 103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.get_scalding_core#105",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.get_scalding_core(self)",
        "snippet": "    def get_scalding_core(self):\n        lib_dir = os.path.join(self.scalding_home, 'lib')\n        for j in os.listdir(lib_dir):\n            if j.startswith('scalding-core-'):\n                p = os.path.join(lib_dir, j)\n                logger.debug('Found scalding-core: %s', p)\n                return p\n        raise luigi.contrib.hadoop.HadoopJobError('Could not find scalding-core.')",
        "begin_line": 105,
        "end_line": 112,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.get_provided_jars#114",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.get_provided_jars(self)",
        "snippet": "    def get_provided_jars(self):\n        return self._get_jars(self.provided_dir)",
        "begin_line": 114,
        "end_line": 115,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.get_libjars#117",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.get_libjars(self)",
        "snippet": "    def get_libjars(self):\n        return self._get_jars(self.libjars_dir)",
        "begin_line": 117,
        "end_line": 118,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.get_tmp_job_jar#120",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.get_tmp_job_jar(self, source)",
        "snippet": "    def get_tmp_job_jar(self, source):\n        job_name = os.path.basename(os.path.splitext(source)[0])\n        return os.path.join(self.tmp_dir.path, job_name + '.jar')",
        "begin_line": 120,
        "end_line": 122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.get_build_dir#124",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.get_build_dir(self, source)",
        "snippet": "    def get_build_dir(self, source):\n        build_dir = os.path.join(self.tmp_dir.path, 'build')\n        return build_dir",
        "begin_line": 124,
        "end_line": 126,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.get_job_class#128",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.get_job_class(self, source)",
        "snippet": "    def get_job_class(self, source):\n        # find name of the job class\n        # usually the one that matches file name or last class that extends Job\n        job_name = os.path.splitext(os.path.basename(source))[0]\n        package = None\n        job_class = None\n        for l in open(source).readlines():\n            p = re.search(r'package\\s+([^\\s\\(]+)', l)\n            if p:\n                package = p.groups()[0]\n            p = re.search(r'class\\s+([^\\s\\(]+).*extends\\s+.*Job', l)\n            if p:\n                job_class = p.groups()[0]\n                if job_class == job_name:\n                    break\n        if job_class:\n            if package:\n                job_class = package + '.' + job_class\n            logger.debug('Found scalding job class: %s', job_class)\n            return job_class\n        else:\n            raise luigi.contrib.hadoop.HadoopJobError('Coudl not find scalding job class.')",
        "begin_line": 128,
        "end_line": 149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.build_job_jar#151",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.build_job_jar(self, job)",
        "snippet": "    def build_job_jar(self, job):\n        job_jar = job.jar()\n        if job_jar:\n            if not os.path.exists(job_jar):\n                logger.error(\"Can't find jar: %s, full path %s\", job_jar, os.path.abspath(job_jar))\n                raise Exception(\"job jar does not exist\")\n            if not job.job_class():\n                logger.error(\"Undefined job_class()\")\n                raise Exception(\"Undefined job_class()\")\n            return job_jar\n\n        job_src = job.source()\n        if not job_src:\n            logger.error(\"Both source() and jar() undefined\")\n            raise Exception(\"Both source() and jar() undefined\")\n        if not os.path.exists(job_src):\n            logger.error(\"Can't find source: %s, full path %s\", job_src, os.path.abspath(job_src))\n            raise Exception(\"job source does not exist\")\n\n        job_src = job.source()\n        job_jar = self.get_tmp_job_jar(job_src)\n\n        build_dir = self.get_build_dir(job_src)\n        if not os.path.exists(build_dir):\n            os.makedirs(build_dir)\n\n        classpath = ':'.join(filter(None,\n                                    self.get_scalding_jars() +\n                                    self.get_provided_jars() +\n                                    self.get_libjars() +\n                                    job.extra_jars()))\n        scala_cp = ':'.join(self.get_scala_jars(include_compiler=True))\n\n        # compile scala source\n        arglist = ['java', '-cp', scala_cp, 'scala.tools.nsc.Main',\n                   '-classpath', classpath,\n                   '-d', build_dir, job_src]\n        logger.info('Compiling scala source: %s', subprocess.list2cmdline(arglist))\n        subprocess.check_call(arglist)\n\n        # build job jar file\n        arglist = ['jar', 'cf', job_jar, '-C', build_dir, '.']\n        logger.info('Building job jar: %s', subprocess.list2cmdline(arglist))\n        subprocess.check_call(arglist)\n        return job_jar",
        "begin_line": 151,
        "end_line": 195,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.run_job#197",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.run_job(self, job, tracking_url_callback=None)",
        "snippet": "    def run_job(self, job, tracking_url_callback=None):\n        if tracking_url_callback is not None:\n            warnings.warn(\"tracking_url_callback argument is deprecated, task.set_tracking_url is \"\n                          \"used instead.\", DeprecationWarning)\n\n        job_jar = self.build_job_jar(job)\n        jars = [job_jar] + self.get_libjars() + job.extra_jars()\n        scalding_core = self.get_scalding_core()\n        libjars = ','.join(filter(None, jars))\n        arglist = luigi.contrib.hdfs.load_hadoop_cmd() + ['jar', scalding_core, '-libjars', libjars]\n        arglist += ['-D%s' % c for c in job.jobconfs()]\n\n        job_class = job.job_class() or self.get_job_class(job.source())\n        arglist += [job_class, '--hdfs']\n\n        # scalding does not parse argument with '=' properly\n        arglist += ['--name', job.task_id.replace('=', ':')]\n\n        (tmp_files, job_args) = luigi.contrib.hadoop_jar.fix_paths(job)\n        arglist += job_args\n\n        env = os.environ.copy()\n        jars.append(scalding_core)\n        hadoop_cp = ':'.join(filter(None, jars))\n        env['HADOOP_CLASSPATH'] = hadoop_cp\n        logger.info(\"Submitting Hadoop job: HADOOP_CLASSPATH=%s %s\",\n                    hadoop_cp, subprocess.list2cmdline(arglist))\n        luigi.contrib.hadoop.run_and_track_hadoop_job(arglist, job.set_tracking_url, env=env)\n\n        for a, b in tmp_files:\n            a.move(b)",
        "begin_line": 197,
        "end_line": 227,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobTask.jar#261",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobTask",
        "signature": "luigi.contrib.scalding.ScaldingJobTask.jar(self)",
        "snippet": "    def jar(self):\n        \"\"\"\n        Path to the jar file for this Scalding Job\n\n        Either one of source() or jar() must be specified.\n        \"\"\"\n        return None",
        "begin_line": 261,
        "end_line": 267,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobTask.extra_jars#269",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobTask",
        "signature": "luigi.contrib.scalding.ScaldingJobTask.extra_jars(self)",
        "snippet": "    def extra_jars(self):\n        \"\"\"\n        Extra jars for building and running this Scalding Job.\n        \"\"\"\n        return []",
        "begin_line": 269,
        "end_line": 273,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobTask.job_class#275",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobTask",
        "signature": "luigi.contrib.scalding.ScaldingJobTask.job_class(self)",
        "snippet": "    def job_class(self):\n        \"\"\"\n        optional main job class for this Scalding Job.\n        \"\"\"\n        return None",
        "begin_line": 275,
        "end_line": 279,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobTask.job_runner#281",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobTask",
        "signature": "luigi.contrib.scalding.ScaldingJobTask.job_runner(self)",
        "snippet": "    def job_runner(self):\n        return ScaldingJobRunner()",
        "begin_line": 281,
        "end_line": 282,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobTask.requires#291",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobTask",
        "signature": "luigi.contrib.scalding.ScaldingJobTask.requires(self)",
        "snippet": "    def requires(self):\n        return {}",
        "begin_line": 291,
        "end_line": 292,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobTask.job_args#294",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobTask",
        "signature": "luigi.contrib.scalding.ScaldingJobTask.job_args(self)",
        "snippet": "    def job_args(self):\n        \"\"\"\n        Extra arguments to pass to the Scalding job.\n        \"\"\"\n        return []",
        "begin_line": 294,
        "end_line": 298,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobTask.args#300",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobTask",
        "signature": "luigi.contrib.scalding.ScaldingJobTask.args(self)",
        "snippet": "    def args(self):\n        \"\"\"\n        Returns an array of args to pass to the job.\n        \"\"\"\n        arglist = []\n        for k, v in six.iteritems(self.requires_hadoop()):\n            arglist.append('--' + k)\n            arglist.extend([t.output().path for t in flatten(v)])\n        arglist.extend(['--output', self.output()])\n        arglist.extend(self.job_args())\n        return arglist",
        "begin_line": 300,
        "end_line": 310,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.configuration.core._check_parser#43",
        "src_path": "luigi/configuration/core.py",
        "class_name": "luigi.configuration.core",
        "signature": "luigi.configuration.core._check_parser(parser_class, parser)",
        "snippet": "def _check_parser(parser_class, parser):\n    if not parser_class.enabled:\n        msg = (\n            \"Parser not installed yet. \"\n            \"Please, install luigi with required parser:\\n\"\n            \"pip install luigi[{parser}]\"\n        )\n        raise ImportError(msg.format(parser=parser))",
        "begin_line": 43,
        "end_line": 50,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.015151515151515152,
            "pseudo_dstar_susp": 0.2,
            "pseudo_tarantula_susp": 0.0017301038062283738,
            "pseudo_op2_susp": 0.2,
            "pseudo_barinel_susp": 0.0017301038062283738
        }
    },
    {
        "name": "luigi.configuration.core.get_config#53",
        "src_path": "luigi/configuration/core.py",
        "class_name": "luigi.configuration.core",
        "signature": "luigi.configuration.core.get_config(parser=PARSER)",
        "snippet": "def get_config(parser=PARSER):\n    \"\"\"Get configs singleton for parser\n    \"\"\"\n    parser_class = PARSERS[parser]\n    _check_parser(parser_class, parser)\n    return parser_class.instance()",
        "begin_line": 53,
        "end_line": 58,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.016129032258064516,
            "pseudo_dstar_susp": 1.0,
            "pseudo_tarantula_susp": 0.0017421602787456446,
            "pseudo_op2_susp": 1.0,
            "pseudo_barinel_susp": 0.0017421602787456446
        }
    },
    {
        "name": "luigi.configuration.core.add_config_path#61",
        "src_path": "luigi/configuration/core.py",
        "class_name": "luigi.configuration.core",
        "signature": "luigi.configuration.core.add_config_path(path)",
        "snippet": "def add_config_path(path):\n    \"\"\"Select config parser by file extension and add path into parser.\n    \"\"\"\n    if not os.path.isfile(path):\n        warnings.warn(\"Config file does not exist: {path}\".format(path=path))\n        return False\n\n    # select parser by file extension\n    _base, ext = os.path.splitext(path)\n    if ext and ext[1:] in PARSERS:\n        parser = ext[1:]\n    else:\n        parser = PARSER\n    parser_class = PARSERS[parser]\n\n    _check_parser(parser_class, parser)\n    if parser != PARSER:\n        msg = (\n            \"Config for {added} parser added, but used {used} parser. \"\n            \"Set up right parser via env var: \"\n            \"export LUIGI_CONFIG_PARSER={added}\"\n        )\n        warnings.warn(msg.format(added=parser, used=PARSER))\n\n    # add config path to parser\n    parser_class.add_config_path(path)\n    return True",
        "begin_line": 61,
        "end_line": 87,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient.__init__#58",
        "src_path": "luigi/contrib/hdfs/webhdfs_client.py",
        "class_name": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient",
        "signature": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient.__init__(self, host=None, port=None, user=None, client_type=None)",
        "snippet": "    def __init__(self, host=None, port=None, user=None, client_type=None):\n        self.host = host or hdfs_config.hdfs().namenode_host\n        self.port = port or webhdfs().port\n        self.user = user or webhdfs().user or os.environ['USER']\n        self.client_type = client_type or webhdfs().client_type",
        "begin_line": 58,
        "end_line": 62,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02702702702702703,
            "pseudo_dstar_susp": 0.002257336343115124,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.002257336343115124,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient.url#65",
        "src_path": "luigi/contrib/hdfs/webhdfs_client.py",
        "class_name": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient",
        "signature": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient.url(self)",
        "snippet": "    def url(self):\n        # the hdfs package allows it to specify multiple namenodes by passing a string containing\n        # multiple namenodes separated by ';'\n        hosts = self.host.split(\";\")\n        urls = ['http://' + host + ':' + str(self.port) for host in hosts]\n        return \";\".join(urls)",
        "begin_line": 65,
        "end_line": 70,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02702702702702703,
            "pseudo_dstar_susp": 0.002257336343115124,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.002257336343115124,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient.client#73",
        "src_path": "luigi/contrib/hdfs/webhdfs_client.py",
        "class_name": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient",
        "signature": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient.client(self)",
        "snippet": "    def client(self):\n        # A naive benchmark showed that 1000 existence checks took 2.5 secs\n        # when not recreating the client, and 4.0 secs when recreating it. So\n        # not urgent to memoize it. Note that it *might* be issues with process\n        # forking and whatnot (as the one in the snakebite client) if we\n        # memoize it too trivially.\n        if self.client_type == 'kerberos':\n            from hdfs.ext.kerberos import KerberosClient\n            return KerberosClient(url=self.url)\n        else:\n            import hdfs\n            return hdfs.InsecureClient(url=self.url, user=self.user)",
        "begin_line": 73,
        "end_line": 84,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02702702702702703,
            "pseudo_dstar_susp": 0.002257336343115124,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.002257336343115124,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient.exists#89",
        "src_path": "luigi/contrib/hdfs/webhdfs_client.py",
        "class_name": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient",
        "signature": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient.exists(self, path)",
        "snippet": "    def exists(self, path):\n        \"\"\"\n        Returns true if the path exists and false otherwise.\n        \"\"\"\n        import hdfs\n        try:\n            self.client.status(path)\n            return True\n        except hdfs.util.HdfsError as e:\n            if str(e).startswith('File does not exist: '):\n                return False\n            else:\n                raise e",
        "begin_line": 89,
        "end_line": 101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02702702702702703,
            "pseudo_dstar_susp": 0.002257336343115124,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.002257336343115124,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.contrib.salesforce.QuerySalesforce.content_type#144",
        "src_path": "luigi/contrib/salesforce.py",
        "class_name": "luigi.contrib.salesforce.QuerySalesforce",
        "signature": "luigi.contrib.salesforce.QuerySalesforce.content_type(self)",
        "snippet": "    def content_type(self):\n        \"\"\"\n        Override to use a different content type. Salesforce allows XML, CSV, ZIP_CSV, or ZIP_XML. Defaults to CSV.\n        \"\"\"\n        return \"CSV\"",
        "begin_line": 144,
        "end_line": 148,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.salesforce.QuerySalesforce.merge_batch_results#212",
        "src_path": "luigi/contrib/salesforce.py",
        "class_name": "luigi.contrib.salesforce.QuerySalesforce",
        "signature": "luigi.contrib.salesforce.QuerySalesforce.merge_batch_results(self, result_ids)",
        "snippet": "    def merge_batch_results(self, result_ids):\n        \"\"\"\n        Merges the resulting files of a multi-result batch bulk query.\n        \"\"\"\n        outfile = open(self.output().path, 'w')\n\n        if self.content_type.lower() == 'csv':\n            for i, result_id in enumerate(result_ids):\n                with open(\"%s.%d\" % (self.output().path, i), 'r') as f:\n                    header = f.readline()\n                    if i == 0:\n                        outfile.write(header)\n                    for line in f:\n                        outfile.write(line)\n        else:\n            raise Exception(\"Batch result merging not implemented for %s\" % self.content_type)\n\n        outfile.close()",
        "begin_line": 212,
        "end_line": 229,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.salesforce.SalesforceAPI.__init__#241",
        "src_path": "luigi/contrib/salesforce.py",
        "class_name": "luigi.contrib.salesforce.SalesforceAPI",
        "signature": "luigi.contrib.salesforce.SalesforceAPI.__init__(self, username, password, security_token, sb_token=None, sandbox_name=None)",
        "snippet": "    def __init__(self, username, password, security_token, sb_token=None, sandbox_name=None):\n        self.username = username\n        self.password = password\n        self.security_token = security_token\n        self.sb_security_token = sb_token\n        self.sandbox_name = sandbox_name\n\n        if self.sandbox_name:\n            self.username += \".%s\" % self.sandbox_name\n\n        self.session_id = None\n        self.server_url = None\n        self.hostname = None",
        "begin_line": 241,
        "end_line": 253,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.salesforce.SalesforceAPI.get_batch_results#511",
        "src_path": "luigi/contrib/salesforce.py",
        "class_name": "luigi.contrib.salesforce.SalesforceAPI",
        "signature": "luigi.contrib.salesforce.SalesforceAPI.get_batch_results(self, job_id, batch_id)",
        "snippet": "    def get_batch_results(self, job_id, batch_id):\n        \"\"\"\n        DEPRECATED: Use `get_batch_result_ids`\n        \"\"\"\n        warnings.warn(\"get_batch_results is deprecated and only returns one batch result. Please use get_batch_result_ids\")\n        return self.get_batch_result_ids(job_id, batch_id)[0]",
        "begin_line": 511,
        "end_line": 516,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.salesforce.SalesforceAPI.get_batch_result_ids#518",
        "src_path": "luigi/contrib/salesforce.py",
        "class_name": "luigi.contrib.salesforce.SalesforceAPI",
        "signature": "luigi.contrib.salesforce.SalesforceAPI.get_batch_result_ids(self, job_id, batch_id)",
        "snippet": "    def get_batch_result_ids(self, job_id, batch_id):\n        \"\"\"\n        Get result IDs of a batch that has completed processing.\n\n        :param job_id: job_id as returned by 'create_operation_job(...)'\n        :param batch_id: batch_id as returned by 'create_batch(...)'\n        :return: list of batch result IDs to be used in 'get_batch_result(...)'\n        \"\"\"\n        response = requests.get(self._get_batch_results_url(job_id, batch_id),\n                                headers=self._get_batch_info_headers())\n        response.raise_for_status()\n\n        root = ET.fromstring(response.text)\n        result_ids = [r.text for r in root.findall('%sresult' % self.API_NS)]\n\n        return result_ids",
        "begin_line": 518,
        "end_line": 533,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.salesforce.SalesforceAPI._get_base_url#569",
        "src_path": "luigi/contrib/salesforce.py",
        "class_name": "luigi.contrib.salesforce.SalesforceAPI",
        "signature": "luigi.contrib.salesforce.SalesforceAPI._get_base_url(self)",
        "snippet": "    def _get_base_url(self):\n        return \"https://%s/services\" % self.hostname",
        "begin_line": 569,
        "end_line": 570,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.salesforce.SalesforceAPI._get_bulk_base_url#572",
        "src_path": "luigi/contrib/salesforce.py",
        "class_name": "luigi.contrib.salesforce.SalesforceAPI",
        "signature": "luigi.contrib.salesforce.SalesforceAPI._get_bulk_base_url(self)",
        "snippet": "    def _get_bulk_base_url(self):\n        # Expands on Base Url for Bulk\n        return \"%s/async/%s\" % (self._get_base_url(), self.API_VERSION)",
        "begin_line": 572,
        "end_line": 574,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.salesforce.SalesforceAPI._get_create_job_url#584",
        "src_path": "luigi/contrib/salesforce.py",
        "class_name": "luigi.contrib.salesforce.SalesforceAPI",
        "signature": "luigi.contrib.salesforce.SalesforceAPI._get_create_job_url(self)",
        "snippet": "    def _get_create_job_url(self):\n        # Expands on Bulk url\n        return \"%s/job\" % (self._get_bulk_base_url())",
        "begin_line": 584,
        "end_line": 586,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.salesforce.SalesforceAPI._get_job_id_url#588",
        "src_path": "luigi/contrib/salesforce.py",
        "class_name": "luigi.contrib.salesforce.SalesforceAPI",
        "signature": "luigi.contrib.salesforce.SalesforceAPI._get_job_id_url(self, job_id)",
        "snippet": "    def _get_job_id_url(self, job_id):\n        # Expands on Job Creation url\n        return \"%s/%s\" % (self._get_create_job_url(), job_id)",
        "begin_line": 588,
        "end_line": 590,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.salesforce.SalesforceAPI._get_create_batch_url#604",
        "src_path": "luigi/contrib/salesforce.py",
        "class_name": "luigi.contrib.salesforce.SalesforceAPI",
        "signature": "luigi.contrib.salesforce.SalesforceAPI._get_create_batch_url(self, job_id)",
        "snippet": "    def _get_create_batch_url(self, job_id):\n        # Expands on basic Job Id url\n        return \"%s/batch\" % (self._get_job_id_url(job_id))",
        "begin_line": 604,
        "end_line": 606,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.salesforce.SalesforceAPI._get_batch_info_url#608",
        "src_path": "luigi/contrib/salesforce.py",
        "class_name": "luigi.contrib.salesforce.SalesforceAPI",
        "signature": "luigi.contrib.salesforce.SalesforceAPI._get_batch_info_url(self, job_id, batch_id)",
        "snippet": "    def _get_batch_info_url(self, job_id, batch_id):\n        # Expands on Batch Creation url\n        return \"%s/%s\" % (self._get_create_batch_url(job_id), batch_id)",
        "begin_line": 608,
        "end_line": 610,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.salesforce.SalesforceAPI._get_batch_results_url#612",
        "src_path": "luigi/contrib/salesforce.py",
        "class_name": "luigi.contrib.salesforce.SalesforceAPI",
        "signature": "luigi.contrib.salesforce.SalesforceAPI._get_batch_results_url(self, job_id, batch_id)",
        "snippet": "    def _get_batch_results_url(self, job_id, batch_id):\n        # Expands on Batch Info url\n        return \"%s/result\" % (self._get_batch_info_url(job_id, batch_id))",
        "begin_line": 612,
        "end_line": 614,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.salesforce.SalesforceAPI._get_session_headers#627",
        "src_path": "luigi/contrib/salesforce.py",
        "class_name": "luigi.contrib.salesforce.SalesforceAPI",
        "signature": "luigi.contrib.salesforce.SalesforceAPI._get_session_headers(self)",
        "snippet": "    def _get_session_headers(self):\n        headers = {\n            'X-SFDC-Session': self.session_id\n        }\n        return headers",
        "begin_line": 627,
        "end_line": 631,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.salesforce.SalesforceAPI._get_batch_info_headers#664",
        "src_path": "luigi/contrib/salesforce.py",
        "class_name": "luigi.contrib.salesforce.SalesforceAPI",
        "signature": "luigi.contrib.salesforce.SalesforceAPI._get_batch_info_headers(self)",
        "snippet": "    def _get_batch_info_headers(self):\n        return self._get_session_headers()",
        "begin_line": 664,
        "end_line": 665,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.gcs.GCSTarget.__init__#467",
        "src_path": "luigi/contrib/gcs.py",
        "class_name": "luigi.contrib.gcs.GCSTarget",
        "signature": "luigi.contrib.gcs.GCSTarget.__init__(self, path, format=None, client=None)",
        "snippet": "    def __init__(self, path, format=None, client=None):\n        super(GCSTarget, self).__init__(path)\n        if format is None:\n            format = luigi.format.get_default_format()\n\n        self.format = format\n        self.fs = client or GCSClient()",
        "begin_line": 467,
        "end_line": 473,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.task.namespace#55",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task",
        "signature": "luigi.task.namespace(namespace=None, scope='')",
        "snippet": "def namespace(namespace=None, scope=''):\n    \"\"\"\n    Call to set namespace of tasks declared after the call.\n\n    It is often desired to call this function with the keyword argument\n    ``scope=__name__``.\n\n    The ``scope`` keyword makes it so that this call is only effective for task\n    classes with a matching [*]_ ``__module__``. The default value for\n    ``scope`` is the empty string, which means all classes. Multiple calls with\n    the same scope simply replace each other.\n\n    The namespace of a :py:class:`Task` can also be changed by specifying the property\n    ``task_namespace``.\n\n    .. code-block:: python\n\n        class Task2(luigi.Task):\n            task_namespace = 'namespace2'\n\n    This explicit setting takes priority over whatever is set in the\n    ``namespace()`` method, and it's also inherited through normal python\n    inheritence.\n\n    There's no equivalent way to set the ``task_family``.\n\n    *New since Luigi 2.6.0:* ``scope`` keyword argument.\n\n    .. [*] When there are multiple levels of matching module scopes like\n           ``a.b`` vs ``a.b.c``, the more specific one (``a.b.c``) wins.\n    .. seealso:: The new and better scaling :py:func:`auto_namespace`\n    \"\"\"\n    Register._default_namespace_dict[scope] = namespace or ''",
        "begin_line": 55,
        "end_line": 87,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019327406262079628,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.task.auto_namespace#90",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task",
        "signature": "luigi.task.auto_namespace(scope='')",
        "snippet": "def auto_namespace(scope=''):\n    \"\"\"\n    Same as :py:func:`namespace`, but instead of a constant namespace, it will\n    be set to the ``__module__`` of the task class. This is desirable for these\n    reasons:\n\n     * Two tasks with the same name will not have conflicting task families\n     * It's more pythonic, as modules are Python's recommended way to\n       do namespacing.\n     * It's traceable. When you see the full name of a task, you can immediately\n       identify where it is defined.\n\n    We recommend calling this function from your package's outermost\n    ``__init__.py`` file. The file contents could look like this:\n\n    .. code-block:: python\n\n        import luigi\n\n        luigi.auto_namespace(scope=__name__)\n\n    To reset an ``auto_namespace()`` call, you can use\n    ``namespace(scope='my_scope')``.  But this will not be\n    needed (and is also discouraged) if you use the ``scope`` kwarg.\n\n    *New since Luigi 2.6.0.*\n    \"\"\"\n    namespace(namespace=_SAME_AS_PYTHON_MODULE, scope=scope)",
        "begin_line": 90,
        "end_line": 117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.task.task_id_str#120",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task",
        "signature": "luigi.task.task_id_str(task_family, params)",
        "snippet": "def task_id_str(task_family, params):\n    \"\"\"\n    Returns a canonical string used to identify a particular task\n\n    :param task_family: The task family (class name) of the task\n    :param params: a dict mapping parameter names to their serialized values\n    :return: A unique, shortened identifier corresponding to the family and params\n    \"\"\"\n    # task_id is a concatenation of task family, the first values of the first 3 parameters\n    # sorted by parameter name and a md5hash of the family/parameters as a cananocalised json.\n    param_str = json.dumps(params, separators=(',', ':'), sort_keys=True)\n    param_hash = hashlib.md5(param_str.encode('utf-8')).hexdigest()\n\n    param_summary = '_'.join(p[:TASK_ID_TRUNCATE_PARAMS]\n                             for p in (params[p] for p in sorted(params)[:TASK_ID_INCLUDE_PARAMS]))\n    param_summary = TASK_ID_INVALID_CHAR_REGEX.sub('_', param_summary)\n\n    return '{}_{}_{}'.format(task_family, param_summary, param_hash[:TASK_ID_TRUNCATE_HASH])",
        "begin_line": 120,
        "end_line": 137,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003663003663003663,
            "pseudo_dstar_susp": 0.037037037037037035,
            "pseudo_tarantula_susp": 0.0012787723785166241,
            "pseudo_op2_susp": 0.06666666666666667,
            "pseudo_barinel_susp": 0.0012787723785166241
        }
    },
    {
        "name": "luigi.task.Task.batchable#199",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.batchable(self)",
        "snippet": "    def batchable(self):\n        \"\"\"\n        True if this instance can be run as part of a batch. By default, True\n        if it has any batched parameters\n        \"\"\"\n        return bool(self.batch_param_names())",
        "begin_line": 199,
        "end_line": 204,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008718395815170009,
            "pseudo_dstar_susp": 0.0015552099533437014,
            "pseudo_tarantula_susp": 0.0007283321194464676,
            "pseudo_op2_susp": 0.0015552099533437014,
            "pseudo_barinel_susp": 0.0007267441860465116
        }
    },
    {
        "name": "luigi.task.Task.retry_count#207",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.retry_count(self)",
        "snippet": "    def retry_count(self):\n        \"\"\"\n        Override this positive integer to have different ``retry_count`` at task level\n        Check :ref:`scheduler-config`\n        \"\"\"\n        return None",
        "begin_line": 207,
        "end_line": 212,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000855431993156544,
            "pseudo_dstar_susp": 0.0015037593984962407,
            "pseudo_tarantula_susp": 0.0007142857142857143,
            "pseudo_op2_susp": 0.0015037593984962407,
            "pseudo_barinel_susp": 0.0007142857142857143
        }
    },
    {
        "name": "luigi.task.Task.disable_hard_timeout#215",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.disable_hard_timeout(self)",
        "snippet": "    def disable_hard_timeout(self):\n        \"\"\"\n        Override this positive integer to have different ``disable_hard_timeout`` at task level.\n        Check :ref:`scheduler-config`\n        \"\"\"\n        return None",
        "begin_line": 215,
        "end_line": 220,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000855431993156544,
            "pseudo_dstar_susp": 0.0015037593984962407,
            "pseudo_tarantula_susp": 0.0007142857142857143,
            "pseudo_op2_susp": 0.0015037593984962407,
            "pseudo_barinel_susp": 0.0007142857142857143
        }
    },
    {
        "name": "luigi.task.Task.disable_window_seconds#223",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.disable_window_seconds(self)",
        "snippet": "    def disable_window_seconds(self):\n        \"\"\"\n        Override this positive integer to have different ``disable_window_seconds`` at task level.\n        Check :ref:`scheduler-config`\n        \"\"\"\n        return None",
        "begin_line": 223,
        "end_line": 228,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000855431993156544,
            "pseudo_dstar_susp": 0.0015037593984962407,
            "pseudo_tarantula_susp": 0.0007142857142857143,
            "pseudo_op2_susp": 0.0015037593984962407,
            "pseudo_barinel_susp": 0.0007142857142857143
        }
    },
    {
        "name": "luigi.task.Task.owner_email#231",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.owner_email(self)",
        "snippet": "    def owner_email(self):\n        '''\n        Override this to send out additional error emails to task owner, in addition to the one\n        defined in the global configuration. This should return a string or a list of strings. e.g.\n        'test@exmaple.com' or ['test1@example.com', 'test2@example.com']\n        '''\n        return None",
        "begin_line": 231,
        "end_line": 237,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008771929824561404,
            "pseudo_dstar_susp": 0.0015723270440251573,
            "pseudo_tarantula_susp": 0.0007320644216691069,
            "pseudo_op2_susp": 0.0015723270440251573,
            "pseudo_barinel_susp": 0.0007320644216691069
        }
    },
    {
        "name": "luigi.task.Task._owner_list#239",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task._owner_list(self)",
        "snippet": "    def _owner_list(self):\n        \"\"\"\n        Turns the owner_email property into a list. This should not be overridden.\n        \"\"\"\n        owner_email = self.owner_email\n        if owner_email is None:\n            return []\n        elif isinstance(owner_email, six.string_types):\n            return owner_email.split(',')\n        else:\n            return owner_email",
        "begin_line": 239,
        "end_line": 249,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008795074758135445,
            "pseudo_dstar_susp": 0.0015772870662460567,
            "pseudo_tarantula_susp": 0.0007342143906020558,
            "pseudo_op2_susp": 0.0015772870662460567,
            "pseudo_barinel_susp": 0.0007342143906020558
        }
    },
    {
        "name": "luigi.task.Task.wrapped#262",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.wrapped(callback)",
        "snippet": "        def wrapped(callback):\n            cls._event_callbacks.setdefault(cls, {}).setdefault(event, set()).add(callback)\n            return callback",
        "begin_line": 262,
        "end_line": 264,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012239902080783353,
            "pseudo_dstar_susp": 0.0009293680297397769,
            "pseudo_tarantula_susp": 0.0016339869281045752,
            "pseudo_op2_susp": 0.0009293680297397769,
            "pseudo_barinel_susp": 0.0016339869281045752
        }
    },
    {
        "name": "luigi.task.Task.event_handler#258",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.event_handler(cls, event)",
        "snippet": "    def event_handler(cls, event):\n        \"\"\"\n        Decorator for adding event handlers.\n        \"\"\"\n        def wrapped(callback):\n            cls._event_callbacks.setdefault(cls, {}).setdefault(event, set()).add(callback)\n            return callback\n        return wrapped",
        "begin_line": 258,
        "end_line": 265,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00088261253309797,
            "pseudo_dstar_susp": 0.0005431830526887561,
            "pseudo_tarantula_susp": 0.0016339869281045752,
            "pseudo_op2_susp": 0.0005431830526887561,
            "pseudo_barinel_susp": 0.0016339869281045752
        }
    },
    {
        "name": "luigi.task.Task.trigger_event#267",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.trigger_event(self, event, *args, **kwargs)",
        "snippet": "    def trigger_event(self, event, *args, **kwargs):\n        \"\"\"\n        Trigger that calls all of the specified events associated with this class.\n        \"\"\"\n        for event_class, event_callbacks in six.iteritems(self._event_callbacks):\n            if not isinstance(self, event_class):\n                continue\n            for callback in event_callbacks.get(event, []):\n                try:\n                    # callbacks are protected\n                    callback(*args, **kwargs)\n                except KeyboardInterrupt:\n                    return\n                except BaseException:\n                    logger.exception(\"Error in event callback for %r\", event)",
        "begin_line": 267,
        "end_line": 281,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005543237250554324,
            "pseudo_dstar_susp": 0.0006968641114982578,
            "pseudo_tarantula_susp": 0.0005763688760806917,
            "pseudo_op2_susp": 0.0006968641114982578,
            "pseudo_barinel_susp": 0.0005763688760806917
        }
    },
    {
        "name": "luigi.task.Task.accepts_messages#284",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.accepts_messages(self)",
        "snippet": "    def accepts_messages(self):\n        \"\"\"\n        For configuring which scheduler messages can be received. When falsy, this tasks does not\n        accept any message. When True, all messages are accepted.\n        \"\"\"\n        return False",
        "begin_line": 284,
        "end_line": 289,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008718395815170009,
            "pseudo_dstar_susp": 0.0015552099533437014,
            "pseudo_tarantula_susp": 0.0007283321194464676,
            "pseudo_op2_susp": 0.0015552099533437014,
            "pseudo_barinel_susp": 0.0007267441860465116
        }
    },
    {
        "name": "luigi.task.Task.task_module#292",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.task_module(self)",
        "snippet": "    def task_module(self):\n        ''' Returns what Python module to import to get access to this class. '''\n        # TODO(erikbern): we should think about a language-agnostic mechanism\n        return self.__class__.__module__",
        "begin_line": 292,
        "end_line": 295,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008718395815170009,
            "pseudo_dstar_susp": 0.0015552099533437014,
            "pseudo_tarantula_susp": 0.0007283321194464676,
            "pseudo_op2_susp": 0.0015552099533437014,
            "pseudo_barinel_susp": 0.0007267441860465116
        }
    },
    {
        "name": "luigi.task.Task.get_task_namespace#317",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.get_task_namespace(cls)",
        "snippet": "    def get_task_namespace(cls):\n        \"\"\"\n        The task family for the given class.\n\n        Note: You normally don't want to override this.\n        \"\"\"\n        if cls.task_namespace != cls.__not_user_specified:\n            return cls.task_namespace\n        elif cls._namespace_at_class_time == _SAME_AS_PYTHON_MODULE:\n            return cls.__module__\n        return cls._namespace_at_class_time",
        "begin_line": 317,
        "end_line": 327,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022172949002217295,
            "pseudo_dstar_susp": 0.02564102564102564,
            "pseudo_tarantula_susp": 0.001004016064257028,
            "pseudo_op2_susp": 0.02564102564102564,
            "pseudo_barinel_susp": 0.001004016064257028
        }
    },
    {
        "name": "luigi.task.Task.task_family#330",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.task_family(self)",
        "snippet": "    def task_family(self):\n        \"\"\"\n        DEPRECATED since after 2.4.0. See :py:meth:`get_task_family` instead.\n        Hopefully there will be less meta magic in Luigi.\n\n        Convenience method since a property on the metaclass isn't directly\n        accessible through the class instances.\n        \"\"\"\n        return self.__class__.task_family",
        "begin_line": 330,
        "end_line": 338,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001336898395721925,
            "pseudo_dstar_susp": 0.0041841004184100415,
            "pseudo_tarantula_susp": 0.001160092807424594,
            "pseudo_op2_susp": 0.0041841004184100415,
            "pseudo_barinel_susp": 0.001160092807424594
        }
    },
    {
        "name": "luigi.task.Task.get_task_family#341",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.get_task_family(cls)",
        "snippet": "    def get_task_family(cls):\n        \"\"\"\n        The task family for the given class.\n\n        If ``task_namespace`` is not set, then it's simply the name of the\n        class.  Otherwise, ``<task_namespace>.`` is prefixed to the class name.\n\n        Note: You normally don't want to override this.\n        \"\"\"\n        if not cls.get_task_namespace():\n            return cls.__name__\n        else:\n            return \"{}.{}\".format(cls.get_task_namespace(), cls.__name__)",
        "begin_line": 341,
        "end_line": 353,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022172949002217295,
            "pseudo_dstar_susp": 0.02564102564102564,
            "pseudo_tarantula_susp": 0.001004016064257028,
            "pseudo_op2_susp": 0.02564102564102564,
            "pseudo_barinel_susp": 0.001004016064257028
        }
    },
    {
        "name": "luigi.task.Task.get_params#356",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.get_params(cls)",
        "snippet": "    def get_params(cls):\n        \"\"\"\n        Returns all of the Parameters for this Task.\n        \"\"\"\n        # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter):\n                continue\n\n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1]._counter)\n        return params",
        "begin_line": 356,
        "end_line": 371,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003067484662576687,
            "pseudo_dstar_susp": 0.08333333333333333,
            "pseudo_tarantula_susp": 0.0010080645161290322,
            "pseudo_op2_susp": 0.08333333333333333,
            "pseudo_barinel_susp": 0.0010080645161290322
        }
    },
    {
        "name": "luigi.task.Task.batch_param_names#374",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.batch_param_names(cls)",
        "snippet": "    def batch_param_names(cls):\n        return [name for name, p in cls.get_params() if p._is_batchable()]",
        "begin_line": 374,
        "end_line": 375,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012224938875305623,
            "pseudo_dstar_susp": 0.004830917874396135,
            "pseudo_tarantula_susp": 0.0007037297677691766,
            "pseudo_op2_susp": 0.004830917874396135,
            "pseudo_barinel_susp": 0.0007037297677691766
        }
    },
    {
        "name": "luigi.task.Task.get_param_values#382",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.get_param_values(cls, params, args, kwargs)",
        "snippet": "    def get_param_values(cls, params, args, kwargs):\n        \"\"\"\n        Get the values of the parameters from the args and kwargs.\n\n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n        result = {}\n\n        params_dict = dict(params)\n\n        task_family = cls.get_task_family()\n\n        # In case any exceptions are thrown, create a helpful description of how the Task was invoked\n        # TODO: should we detect non-reprable arguments? These will lead to mysterious errors\n        exc_desc = '%s[args=%s, kwargs=%s]' % (task_family, args, kwargs)\n\n        # Fill in the positional arguments\n        positional_params = [(n, p) for n, p in params if p.positional]\n        for i, arg in enumerate(args):\n            if i >= len(positional_params):\n                raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n            param_name, param_obj = positional_params[i]\n            result[param_name] = param_obj.normalize(arg)\n\n        # Then the keyword arguments\n        for param_name, arg in six.iteritems(kwargs):\n            if param_name in result:\n                raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n            if param_name not in params_dict:\n                raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n            result[param_name] = params_dict[param_name].normalize(arg)\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_task_value(task_family, param_name):\n                    raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n                result[param_name] = param_obj.task_value(task_family, param_name)\n\n        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n            if isinstance(x, list) or isinstance(x, set):\n                return tuple(x)\n            else:\n                return x\n        # Sort it by the correct order and make a list\n        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]",
        "begin_line": 382,
        "end_line": 431,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003076923076923077,
            "pseudo_dstar_susp": 0.09090909090909091,
            "pseudo_tarantula_susp": 0.0010718113612004287,
            "pseudo_op2_susp": 0.09090909090909091,
            "pseudo_barinel_susp": 0.0010718113612004287
        }
    },
    {
        "name": "luigi.task.Task.list_to_tuple#424",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.list_to_tuple(x)",
        "snippet": "        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n            if isinstance(x, list) or isinstance(x, set):\n                return tuple(x)\n            else:\n                return x",
        "begin_line": 424,
        "end_line": 429,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0030864197530864196,
            "pseudo_dstar_susp": 0.1,
            "pseudo_tarantula_susp": 0.0010193679918450561,
            "pseudo_op2_susp": 0.1,
            "pseudo_barinel_susp": 0.0010193679918450561
        }
    },
    {
        "name": "luigi.task.Task.__init__#433",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        # Register kwargs as an attribute on the class. Might be useful\n        self.param_kwargs = dict(param_values)\n\n        self._warn_on_wrong_param_types()\n        self.task_id = task_id_str(self.get_task_family(), self.to_str_params(only_significant=True, only_public=True))\n        self.__hash = hash(self.task_id)\n\n        self.set_tracking_url = None\n        self.set_status_message = None\n        self.set_progress_percentage = None",
        "begin_line": 433,
        "end_line": 450,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0028328611898017,
            "pseudo_dstar_susp": 0.008547008547008548,
            "pseudo_tarantula_susp": 0.001349527665317139,
            "pseudo_op2_susp": 0.008547008547008548,
            "pseudo_barinel_susp": 0.001349527665317139
        }
    },
    {
        "name": "luigi.task.Task.param_args#453",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.param_args(self)",
        "snippet": "    def param_args(self):\n        warnings.warn(\"Use of param_args has been deprecated.\", DeprecationWarning)\n        return tuple(self.param_kwargs[k] for k, v in self.get_params())",
        "begin_line": 453,
        "end_line": 455,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.task.Task.initialized#457",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.initialized(self)",
        "snippet": "    def initialized(self):\n        \"\"\"\n        Returns ``True`` if the Task is initialized and ``False`` otherwise.\n        \"\"\"\n        return hasattr(self, 'task_id')",
        "begin_line": 457,
        "end_line": 461,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008230452674897119,
            "pseudo_dstar_susp": 0.0014084507042253522,
            "pseudo_tarantula_susp": 0.0006915629322268327,
            "pseudo_op2_susp": 0.0014084507042253522,
            "pseudo_barinel_susp": 0.0006915629322268327
        }
    },
    {
        "name": "luigi.task.Task._warn_on_wrong_param_types#463",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task._warn_on_wrong_param_types(self)",
        "snippet": "    def _warn_on_wrong_param_types(self):\n        params = dict(self.get_params())\n        for param_name, param_value in six.iteritems(self.param_kwargs):\n            params[param_name]._warn_on_wrong_param_type(param_name, param_value)",
        "begin_line": 463,
        "end_line": 466,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0028328611898017,
            "pseudo_dstar_susp": 0.008547008547008548,
            "pseudo_tarantula_susp": 0.001349527665317139,
            "pseudo_op2_susp": 0.008547008547008548,
            "pseudo_barinel_susp": 0.001349527665317139
        }
    },
    {
        "name": "luigi.task.Task.from_str_params#469",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.from_str_params(cls, params_str)",
        "snippet": "    def from_str_params(cls, params_str):\n        \"\"\"\n        Creates an instance from a str->str hash.\n\n        :param params_str: dict of param name -> value as string.\n        \"\"\"\n        kwargs = {}\n        for param_name, param in cls.get_params():\n            if param_name in params_str:\n                param_str = params_str[param_name]\n                if isinstance(param_str, list):\n                    kwargs[param_name] = param._parse_list(param_str)\n                else:\n                    kwargs[param_name] = param.parse(param_str)\n\n        return cls(**kwargs)",
        "begin_line": 469,
        "end_line": 484,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.task.Task.to_str_params#486",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.to_str_params(self, only_significant=False, only_public=False)",
        "snippet": "    def to_str_params(self, only_significant=False, only_public=False):\n        \"\"\"\n        Convert all parameters to a str->str hash.\n        \"\"\"\n        params_str = {}\n        params = dict(self.get_params())\n        for param_name, param_value in six.iteritems(self.param_kwargs):\n            if (((not only_significant) or params[param_name].significant)\n                    and ((not only_public) or params[param_name].visibility == ParameterVisibility.PUBLIC)\n                    and params[param_name].visibility != ParameterVisibility.PRIVATE):\n                params_str[param_name] = params[param_name].serialize(param_value)\n\n        return params_str",
        "begin_line": 486,
        "end_line": 498,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0028169014084507044,
            "pseudo_dstar_susp": 0.008403361344537815,
            "pseudo_tarantula_susp": 0.0013386880856760374,
            "pseudo_op2_susp": 0.008403361344537815,
            "pseudo_barinel_susp": 0.0013386880856760374
        }
    },
    {
        "name": "luigi.task.Task._get_param_visibilities#500",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task._get_param_visibilities(self)",
        "snippet": "    def _get_param_visibilities(self):\n        param_visibilities = {}\n        params = dict(self.get_params())\n        for param_name, param_value in six.iteritems(self.param_kwargs):\n            if params[param_name].visibility != ParameterVisibility.PRIVATE:\n                param_visibilities[param_name] = params[param_name].visibility.serialize()\n\n        return param_visibilities",
        "begin_line": 500,
        "end_line": 507,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006901311249137336,
            "pseudo_dstar_susp": 0.0007739938080495357,
            "pseudo_tarantula_susp": 0.0008051529790660225,
            "pseudo_op2_susp": 0.0007739938080495357,
            "pseudo_barinel_susp": 0.0008051529790660225
        }
    },
    {
        "name": "luigi.task.Task.clone#509",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.clone(self, cls=None, **kwargs)",
        "snippet": "    def clone(self, cls=None, **kwargs):\n        \"\"\"\n        Creates a new instance from an existing instance where some of the args have changed.\n\n        There's at least two scenarios where this is useful (see test/clone_test.py):\n\n        * remove a lot of boiler plate when you have recursive dependencies and lots of args\n        * there's task inheritance and some logic is on the base class\n\n        :param cls:\n        :param kwargs:\n        :return:\n        \"\"\"\n        if cls is None:\n            cls = self.__class__\n\n        new_k = {}\n        for param_name, param_class in cls.get_params():\n            if param_name in kwargs:\n                new_k[param_name] = kwargs[param_name]\n            elif hasattr(self, param_name):\n                new_k[param_name] = getattr(self, param_name)\n\n        return cls(**new_k)",
        "begin_line": 509,
        "end_line": 532,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00018712574850299402,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.task.Task.__hash__#534",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.__hash__(self)",
        "snippet": "    def __hash__(self):\n        return self.__hash",
        "begin_line": 534,
        "end_line": 535,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007072135785007072,
            "pseudo_dstar_susp": 0.000794912559618442,
            "pseudo_tarantula_susp": 0.0008340283569641367,
            "pseudo_op2_susp": 0.000794912559618442,
            "pseudo_barinel_susp": 0.0008340283569641367
        }
    },
    {
        "name": "luigi.task.Task.__repr__#537",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.__repr__(self)",
        "snippet": "    def __repr__(self):\n        \"\"\"\n        Build a task representation like `MyTask(param1=1.5, param2='5')`\n        \"\"\"\n        params = self.get_params()\n        param_values = self.get_param_values(params, [], self.param_kwargs)\n\n        # Build up task id\n        repr_parts = []\n        param_objs = dict(params)\n        for param_name, param_value in param_values:\n            if param_objs[param_name].significant:\n                repr_parts.append('%s=%s' % (param_name, param_objs[param_name].serialize(param_value)))\n\n        task_str = '{}({})'.format(self.get_task_family(), ', '.join(repr_parts))\n\n        return task_str",
        "begin_line": 537,
        "end_line": 553,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007639419404125286,
            "pseudo_dstar_susp": 0.0013422818791946308,
            "pseudo_tarantula_susp": 0.0006720430107526882,
            "pseudo_op2_susp": 0.0013422818791946308,
            "pseudo_barinel_susp": 0.0006720430107526882
        }
    },
    {
        "name": "luigi.task.Task.__eq__#555",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.__eq__(self, other)",
        "snippet": "    def __eq__(self, other):\n        return self.__class__ == other.__class__ and self.task_id == other.task_id",
        "begin_line": 555,
        "end_line": 556,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00018864365214110544,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.task.Task.complete#558",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.complete(self)",
        "snippet": "    def complete(self):\n        \"\"\"\n        If the task has any outputs, return ``True`` if all outputs exist.\n        Otherwise, return ``False``.\n\n        However, you may freely override this method with custom logic.\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            warnings.warn(\n                \"Task %r without outputs has no custom complete() method\" % self,\n                stacklevel=2\n            )\n            return False\n\n        return all(map(lambda output: output.exists(), outputs))",
        "begin_line": 558,
        "end_line": 573,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006775067750677507,
            "pseudo_dstar_susp": 0.0007680491551459293,
            "pseudo_tarantula_susp": 0.0007352941176470588,
            "pseudo_op2_susp": 0.0007680491551459293,
            "pseudo_barinel_susp": 0.0007369196757553427
        }
    },
    {
        "name": "luigi.task.Task.bulk_complete#576",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.bulk_complete(cls, parameter_tuples)",
        "snippet": "    def bulk_complete(cls, parameter_tuples):\n        \"\"\"\n        Returns those of parameter_tuples for which this Task is complete.\n\n        Override (with an efficient implementation) for efficient scheduling\n        with range tools. Keep the logic consistent with that of complete().\n        \"\"\"\n        raise BulkCompleteNotImplementedError()",
        "begin_line": 576,
        "end_line": 583,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001440922190201729,
            "pseudo_dstar_susp": 0.0005675368898978433,
            "pseudo_tarantula_susp": 0.0023752969121140144,
            "pseudo_op2_susp": 0.0005675368898978433,
            "pseudo_barinel_susp": 0.0023752969121140144
        }
    },
    {
        "name": "luigi.task.Task.output#585",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.output(self)",
        "snippet": "    def output(self):\n        \"\"\"\n        The output that this Task produces.\n\n        The output of the Task determines if the Task needs to be run--the task\n        is considered finished iff the outputs all exist. Subclasses should\n        override this method to return a single :py:class:`Target` or a list of\n        :py:class:`Target` instances.\n\n        Implementation note\n          If running multiple workers, the output must be a resource that is accessible\n          by all workers, such as a DFS or database. Otherwise, workers might compute\n          the same output since they don't see the work done by other workers.\n\n        See :ref:`Task.output`\n        \"\"\"\n        return []  # default impl",
        "begin_line": 585,
        "end_line": 601,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016409583196586806,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.task.Task.requires#603",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.requires(self)",
        "snippet": "    def requires(self):\n        \"\"\"\n        The Tasks that this Task depends on.\n\n        A Task will only run if all of the Tasks that it requires are completed.\n        If your Task does not require any other Tasks, then you don't need to\n        override this method. Otherwise, a subclass can override this method\n        to return a single Task, a list of Task instances, or a dict whose\n        values are Task instances.\n\n        See :ref:`Task.requires`\n        \"\"\"\n        return []  # default impl",
        "begin_line": 603,
        "end_line": 615,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006747638326585695,
            "pseudo_dstar_susp": 0.0007656967840735069,
            "pseudo_tarantula_susp": 0.0006854009595613434,
            "pseudo_op2_susp": 0.0007656967840735069,
            "pseudo_barinel_susp": 0.0006854009595613434
        }
    },
    {
        "name": "luigi.task.Task._requires#617",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task._requires(self)",
        "snippet": "    def _requires(self):\n        \"\"\"\n        Override in \"template\" tasks which themselves are supposed to be\n        subclassed and thus have their requires() overridden (name preserved to\n        provide consistent end-user experience), yet need to introduce\n        (non-input) dependencies.\n\n        Must return an iterable which among others contains the _requires() of\n        the superclass.\n        \"\"\"\n        return flatten(self.requires())  # base impl",
        "begin_line": 617,
        "end_line": 627,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000591715976331361,
            "pseudo_dstar_susp": 0.0006983240223463687,
            "pseudo_tarantula_susp": 0.000588235294117647,
            "pseudo_op2_susp": 0.0006983240223463687,
            "pseudo_barinel_susp": 0.000588235294117647
        }
    },
    {
        "name": "luigi.task.Task.process_resources#629",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.process_resources(self)",
        "snippet": "    def process_resources(self):\n        \"\"\"\n        Override in \"template\" tasks which provide common resource functionality\n        but allow subclasses to specify additional resources while preserving\n        the name for consistent end-user experience.\n        \"\"\"\n        return self.resources  # default impl",
        "begin_line": 629,
        "end_line": 635,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008718395815170009,
            "pseudo_dstar_susp": 0.0015552099533437014,
            "pseudo_tarantula_susp": 0.0007283321194464676,
            "pseudo_op2_susp": 0.0015552099533437014,
            "pseudo_barinel_susp": 0.0007267441860465116
        }
    },
    {
        "name": "luigi.task.Task.input#637",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.input(self)",
        "snippet": "    def input(self):\n        \"\"\"\n        Returns the outputs of the Tasks returned by :py:meth:`requires`\n\n        See :ref:`Task.input`\n\n        :return: a list of :py:class:`Target` objects which are specified as\n                 outputs of all required Tasks.\n        \"\"\"\n        return getpaths(self.requires())",
        "begin_line": 637,
        "end_line": 646,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.000181422351233672,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.task.Task.deps#648",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.deps(self)",
        "snippet": "    def deps(self):\n        \"\"\"\n        Internal method used by the scheduler.\n\n        Returns the flattened list of requires.\n        \"\"\"\n        # used by scheduler\n        return flatten(self._requires())",
        "begin_line": 648,
        "end_line": 655,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005970149253731343,
            "pseudo_dstar_susp": 0.0007032348804500703,
            "pseudo_tarantula_susp": 0.0005920663114268798,
            "pseudo_op2_susp": 0.0007032348804500703,
            "pseudo_barinel_susp": 0.0005920663114268798
        }
    },
    {
        "name": "luigi.task.Task.run#657",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.run(self)",
        "snippet": "    def run(self):\n        \"\"\"\n        The task run method, to be overridden in a subclass.\n\n        See :ref:`Task.run`\n        \"\"\"\n        pass  # default impl",
        "begin_line": 657,
        "end_line": 663,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017232465965879716,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.task.Task.on_failure#665",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.on_failure(self, exception)",
        "snippet": "    def on_failure(self, exception):\n        \"\"\"\n        Override for custom error handling.\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        The returned value of this method is json encoded and sent to the scheduler\n        as the `expl` argument. Its string representation will be used as the\n        body of the error email sent out if any.\n\n        Default behavior is to return a string representation of the stack trace.\n        \"\"\"\n\n        traceback_string = traceback.format_exc()\n        return \"Runtime error:\\n%s\" % traceback_string",
        "begin_line": 665,
        "end_line": 678,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006863417982155113,
            "pseudo_dstar_susp": 0.0005288207297726071,
            "pseudo_tarantula_susp": 0.0013422818791946308,
            "pseudo_op2_susp": 0.0005288207297726071,
            "pseudo_barinel_susp": 0.0013422818791946308
        }
    },
    {
        "name": "luigi.task.Task.on_success#680",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.on_success(self)",
        "snippet": "    def on_success(self):\n        \"\"\"\n        Override for doing custom completion handling for a larger class of tasks\n\n        This method gets called when :py:meth:`run` completes without raising any exceptions.\n\n        The returned value is json encoded and sent to the scheduler as the `expl` argument.\n\n        Default behavior is to send an None value\"\"\"\n        pass",
        "begin_line": 680,
        "end_line": 689,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016118633139909736,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.task.Task.no_unpicklable_properties#692",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.no_unpicklable_properties(self)",
        "snippet": "    def no_unpicklable_properties(self):\n        \"\"\"\n        Remove unpicklable properties before dump task and resume them after.\n\n        This method could be called in subtask's dump method, to ensure unpicklable\n        properties won't break dump.\n\n        This method is a context-manager which can be called as below:\n\n        .. code-block: python\n\n            class DummyTask(luigi):\n\n                def _dump(self):\n                    with self.no_unpicklable_properties():\n                        pickle.dumps(self)\n\n        \"\"\"\n        unpicklable_properties = tuple(luigi.worker.TaskProcess.forward_reporter_attributes.values())\n        reserved_properties = {}\n        for property_name in unpicklable_properties:\n            if hasattr(self, property_name):\n                reserved_properties[property_name] = getattr(self, property_name)\n                setattr(self, property_name, 'placeholder_during_pickling')\n\n        yield\n\n        for property_name, value in six.iteritems(reserved_properties):\n            setattr(self, property_name, value)",
        "begin_line": 692,
        "end_line": 720,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0032679738562091504,
            "pseudo_dstar_susp": 0.0009596928982725527,
            "pseudo_tarantula_susp": 0.0029411764705882353,
            "pseudo_op2_susp": 0.0009596928982725527,
            "pseudo_barinel_susp": 0.0029411764705882353
        }
    },
    {
        "name": "luigi.task.MixinNaiveBulkComplete.bulk_complete#732",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.MixinNaiveBulkComplete",
        "signature": "luigi.task.MixinNaiveBulkComplete.bulk_complete(cls, parameter_tuples)",
        "snippet": "    def bulk_complete(cls, parameter_tuples):\n        generated_tuples = []\n        for parameter_tuple in parameter_tuples:\n            if isinstance(parameter_tuple, (list, tuple)):\n                if cls(*parameter_tuple).complete():\n                    generated_tuples.append(parameter_tuple)\n            elif isinstance(parameter_tuple, dict):\n                if cls(**parameter_tuple).complete():\n                    generated_tuples.append(parameter_tuple)\n            else:\n                if cls(parameter_tuple).complete():\n                    generated_tuples.append(parameter_tuple)\n        return generated_tuples",
        "begin_line": 732,
        "end_line": 744,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.task.externalize#758",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task",
        "signature": "luigi.task.externalize(taskclass_or_taskobject)",
        "snippet": "def externalize(taskclass_or_taskobject):\n    \"\"\"\n    Returns an externalized version of a Task. You may both pass an\n    instantiated task object or a task class. Some examples:\n\n    .. code-block:: python\n\n        class RequiringTask(luigi.Task):\n            def requires(self):\n                task_object = self.clone(MyTask)\n                return externalize(task_object)\n\n            ...\n\n    Here's mostly equivalent code, but ``externalize`` is applied to a task\n    class instead.\n\n    .. code-block:: python\n\n        @luigi.util.requires(externalize(MyTask))\n        class RequiringTask(luigi.Task):\n            pass\n            ...\n\n    Of course, it may also be used directly on classes and objects (for example\n    for reexporting or other usage).\n\n    .. code-block:: python\n\n        MyTask = externalize(MyTask)\n        my_task_2 = externalize(MyTask2(param='foo'))\n\n    If you however want a task class to be external from the beginning, you're\n    better off inheriting :py:class:`ExternalTask` rather than :py:class:`Task`.\n\n    This function tries to be side-effect free by creating a copy of the class\n    or the object passed in and then modify that object. In particular this\n    code shouldn't do anything.\n\n    .. code-block:: python\n\n        externalize(MyTask)  # BAD: This does nothing (as after luigi 2.4.0)\n    \"\"\"\n    # Seems like with python < 3.3 copy.copy can't copy classes\n    # and objects with specified metaclass http://bugs.python.org/issue11480\n    compatible_copy = copy.copy if six.PY3 else copy.deepcopy\n    copied_value = compatible_copy(taskclass_or_taskobject)\n    if copied_value is taskclass_or_taskobject:\n        # Assume it's a class\n        clazz = taskclass_or_taskobject\n\n        @_task_wraps(clazz)\n        class _CopyOfClass(clazz):\n            # How to copy a class: http://stackoverflow.com/a/9541120/621449\n            _visible_in_registry = False\n        _CopyOfClass.run = None\n        return _CopyOfClass\n    else:\n        # We assume it's an object\n        copied_value.run = None\n        return copied_value",
        "begin_line": 758,
        "end_line": 818,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002294630564479119,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.task._CopyOfClass.externalize#758",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task._CopyOfClass",
        "signature": "luigi.task._CopyOfClass.externalize(taskclass_or_taskobject)",
        "snippet": "def externalize(taskclass_or_taskobject):\n    \"\"\"\n    Returns an externalized version of a Task. You may both pass an\n    instantiated task object or a task class. Some examples:\n\n    .. code-block:: python\n\n        class RequiringTask(luigi.Task):\n            def requires(self):\n                task_object = self.clone(MyTask)\n                return externalize(task_object)\n\n            ...\n\n    Here's mostly equivalent code, but ``externalize`` is applied to a task\n    class instead.\n\n    .. code-block:: python\n\n        @luigi.util.requires(externalize(MyTask))\n        class RequiringTask(luigi.Task):\n            pass\n            ...\n\n    Of course, it may also be used directly on classes and objects (for example\n    for reexporting or other usage).\n\n    .. code-block:: python\n\n        MyTask = externalize(MyTask)\n        my_task_2 = externalize(MyTask2(param='foo'))\n\n    If you however want a task class to be external from the beginning, you're\n    better off inheriting :py:class:`ExternalTask` rather than :py:class:`Task`.\n\n    This function tries to be side-effect free by creating a copy of the class\n    or the object passed in and then modify that object. In particular this\n    code shouldn't do anything.\n\n    .. code-block:: python\n\n        externalize(MyTask)  # BAD: This does nothing (as after luigi 2.4.0)\n    \"\"\"\n    # Seems like with python < 3.3 copy.copy can't copy classes\n    # and objects with specified metaclass http://bugs.python.org/issue11480\n    compatible_copy = copy.copy if six.PY3 else copy.deepcopy\n    copied_value = compatible_copy(taskclass_or_taskobject)\n    if copied_value is taskclass_or_taskobject:\n        # Assume it's a class\n        clazz = taskclass_or_taskobject\n\n        @_task_wraps(clazz)\n        class _CopyOfClass(clazz):\n            # How to copy a class: http://stackoverflow.com/a/9541120/621449\n            _visible_in_registry = False\n        _CopyOfClass.run = None\n        return _CopyOfClass\n    else:\n        # We assume it's an object\n        copied_value.run = None\n        return copied_value",
        "begin_line": 758,
        "end_line": 818,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00020052135552436334,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.task.WrapperTask.complete#826",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.WrapperTask",
        "signature": "luigi.task.WrapperTask.complete(self)",
        "snippet": "    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))",
        "begin_line": 826,
        "end_line": 827,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017325017325017325,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.task.getpaths#839",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task",
        "signature": "luigi.task.getpaths(struct)",
        "snippet": "def getpaths(struct):\n    \"\"\"\n    Maps all Tasks in a structured data object to their .output().\n    \"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        return struct.__class__((k, getpaths(v)) for k, v in six.iteritems(struct))\n    elif isinstance(struct, (list, tuple)):\n        return struct.__class__(getpaths(r) for r in struct)\n    else:\n        # Remaining case: assume struct is iterable...\n        try:\n            return [getpaths(r) for r in struct]\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))",
        "begin_line": 839,
        "end_line": 854,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.task.flatten#857",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task",
        "signature": "luigi.task.flatten(struct)",
        "snippet": "def flatten(struct):\n    \"\"\"\n    Creates a flat list of all all items in structured output (dicts, lists, items):\n\n    .. code-block:: python\n\n        >>> sorted(flatten({'a': 'foo', 'b': 'bar'}))\n        ['bar', 'foo']\n        >>> sorted(flatten(['foo', ['bar', 'troll']]))\n        ['bar', 'foo', 'troll']\n        >>> flatten('foo')\n        ['foo']\n        >>> flatten(42)\n        [42]\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for _, result in six.iteritems(struct):\n            flat += flatten(result)\n        return flat\n    if isinstance(struct, six.string_types):\n        return [struct]\n\n    try:\n        # if iterable\n        iterator = iter(struct)\n    except TypeError:\n        return [struct]\n\n    for result in iterator:\n        flat += flatten(result)\n    return flat",
        "begin_line": 857,
        "end_line": 890,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007898894154818325,
            "pseudo_dstar_susp": 0.0013774104683195593,
            "pseudo_tarantula_susp": 0.0006844626967830253,
            "pseudo_op2_susp": 0.0013774104683195593,
            "pseudo_barinel_susp": 0.0006844626967830253
        }
    },
    {
        "name": "luigi.task.flatten_output#893",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task",
        "signature": "luigi.task.flatten_output(task)",
        "snippet": "def flatten_output(task):\n    \"\"\"\n    Lists all output targets by recursively walking output-less (wrapper) tasks.\n\n    FIXME order consistently.\n    \"\"\"\n    r = flatten(task.output())\n    if not r:\n        for dep in flatten(task.requires()):\n            r += flatten_output(dep)\n    return r",
        "begin_line": 893,
        "end_line": 903,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012437810945273632,
            "pseudo_dstar_susp": 0.0005485463521667581,
            "pseudo_tarantula_susp": 0.0019267822736030828,
            "pseudo_op2_susp": 0.0005485463521667581,
            "pseudo_barinel_susp": 0.0019267822736030828
        }
    },
    {
        "name": "luigi.task._task_wraps#906",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task",
        "signature": "luigi.task._task_wraps(task_class)",
        "snippet": "def _task_wraps(task_class):\n    # In order to make the behavior of a wrapper class nicer, we set the name of the\n    # new class to the wrapped class, and copy over the docstring and module as well.\n    # This makes it possible to pickle the wrapped class etc.\n    # Btw, this is a slight abuse of functools.wraps. It's meant to be used only for\n    # functions, but it works for classes too, if you pass updated=[]\n    assigned = functools.WRAPPER_ASSIGNMENTS + ('_namespace_at_class_time',)\n    return functools.wraps(task_class, assigned=assigned, updated=[])",
        "begin_line": 906,
        "end_line": 913,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00020052135552436334,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.target.FileSystem.rename#176",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.FileSystem",
        "signature": "luigi.target.FileSystem.rename(self, *args, **kwargs)",
        "snippet": "    def rename(self, *args, **kwargs):\n        \"\"\"\n        Alias for ``move()``\n        \"\"\"\n        self.move(*args, **kwargs)",
        "begin_line": 176,
        "end_line": 180,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.target.FileSystemTarget.__init__#204",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.FileSystemTarget",
        "signature": "luigi.target.FileSystemTarget.__init__(self, path)",
        "snippet": "    def __init__(self, path):\n        \"\"\"\n        Initializes a FileSystemTarget instance.\n\n        :param str path: the path associated with this FileSystemTarget.\n        \"\"\"\n        self.path = path",
        "begin_line": 204,
        "end_line": 210,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014727540500736377,
            "pseudo_dstar_susp": 0.0028328611898017,
            "pseudo_tarantula_susp": 0.001610305958132045,
            "pseudo_op2_susp": 0.0028328611898017,
            "pseudo_barinel_susp": 0.001610305958132045
        }
    },
    {
        "name": "luigi.target.FileSystemTarget.exists#233",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.FileSystemTarget",
        "signature": "luigi.target.FileSystemTarget.exists(self)",
        "snippet": "    def exists(self):\n        \"\"\"\n        Returns ``True`` if the path for this FileSystemTarget exists; ``False`` otherwise.\n\n        This method is implemented by using :py:attr:`fs`.\n        \"\"\"\n        path = self.path\n        if '*' in path or '?' in path or '[' in path or '{' in path:\n            logger.warning(\"Using wildcards in path %s might lead to processing of an incomplete dataset; \"\n                           \"override exists() to suppress the warning.\", path)\n        return self.fs.exists(path)",
        "begin_line": 233,
        "end_line": 243,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000594883997620464,
            "pseudo_dstar_susp": 0.0005197505197505198,
            "pseudo_tarantula_susp": 0.0011037527593818985,
            "pseudo_op2_susp": 0.0005197505197505198,
            "pseudo_barinel_susp": 0.0011037527593818985
        }
    },
    {
        "name": "luigi.target.FileSystemTarget.temporary_path#253",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.FileSystemTarget",
        "signature": "luigi.target.FileSystemTarget.temporary_path(self)",
        "snippet": "    def temporary_path(self):\n        \"\"\"\n        A context manager that enables a reasonably short, general and\n        magic-less way to solve the :ref:`AtomicWrites`.\n\n         * On *entering*, it will create the parent directories so the\n           temporary_path is writeable right away.\n           This step uses :py:meth:`FileSystem.mkdir`.\n         * On *exiting*, it will move the temporary file if there was no exception thrown.\n           This step uses :py:meth:`FileSystem.rename_dont_move`\n\n        The file system operations will be carried out by calling them on :py:attr:`fs`.\n\n        The typical use case looks like this:\n\n        .. code:: python\n\n            class MyTask(luigi.Task):\n                def output(self):\n                    return MyFileSystemTarget(...)\n\n                def run(self):\n                    with self.output().temporary_path() as self.temp_output_path:\n                        run_some_external_command(output_path=self.temp_output_path)\n        \"\"\"\n        class _Manager(object):\n            target = self\n\n            def __init__(self):\n                num = random.randrange(0, 1e10)\n                slashless_path = self.target.path.rstrip('/').rstrip(\"\\\\\")\n                self._temp_path = '{}-luigi-tmp-{:010}{}'.format(\n                    slashless_path,\n                    num,\n                    self.target._trailing_slash())\n                # TODO: os.path doesn't make sense here as it's os-dependent\n                tmp_dir = os.path.dirname(slashless_path)\n                if tmp_dir:\n                    self.target.fs.mkdir(tmp_dir, parents=True, raise_if_exists=False)\n\n            def __enter__(self):\n                return self._temp_path\n\n            def __exit__(self, exc_type, exc_value, traceback):\n                if exc_type is None:\n                    # There were no exceptions\n                    self.target.fs.rename_dont_move(self._temp_path, self.target.path)\n                return False  # False means we don't suppress the exception\n\n        return _Manager()",
        "begin_line": 253,
        "end_line": 302,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00022331397945511388,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.target._Manager.temporary_path#253",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target._Manager",
        "signature": "luigi.target._Manager.temporary_path(self)",
        "snippet": "    def temporary_path(self):\n        \"\"\"\n        A context manager that enables a reasonably short, general and\n        magic-less way to solve the :ref:`AtomicWrites`.\n\n         * On *entering*, it will create the parent directories so the\n           temporary_path is writeable right away.\n           This step uses :py:meth:`FileSystem.mkdir`.\n         * On *exiting*, it will move the temporary file if there was no exception thrown.\n           This step uses :py:meth:`FileSystem.rename_dont_move`\n\n        The file system operations will be carried out by calling them on :py:attr:`fs`.\n\n        The typical use case looks like this:\n\n        .. code:: python\n\n            class MyTask(luigi.Task):\n                def output(self):\n                    return MyFileSystemTarget(...)\n\n                def run(self):\n                    with self.output().temporary_path() as self.temp_output_path:\n                        run_some_external_command(output_path=self.temp_output_path)\n        \"\"\"\n        class _Manager(object):\n            target = self\n\n            def __init__(self):\n                num = random.randrange(0, 1e10)\n                slashless_path = self.target.path.rstrip('/').rstrip(\"\\\\\")\n                self._temp_path = '{}-luigi-tmp-{:010}{}'.format(\n                    slashless_path,\n                    num,\n                    self.target._trailing_slash())\n                # TODO: os.path doesn't make sense here as it's os-dependent\n                tmp_dir = os.path.dirname(slashless_path)\n                if tmp_dir:\n                    self.target.fs.mkdir(tmp_dir, parents=True, raise_if_exists=False)\n\n            def __enter__(self):\n                return self._temp_path\n\n            def __exit__(self, exc_type, exc_value, traceback):\n                if exc_type is None:\n                    # There were no exceptions\n                    self.target.fs.rename_dont_move(self._temp_path, self.target.path)\n                return False  # False means we don't suppress the exception\n\n        return _Manager()",
        "begin_line": 253,
        "end_line": 302,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00022331397945511388,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.target._Manager.__init__#281",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target._Manager",
        "signature": "luigi.target._Manager.__init__(self)",
        "snippet": "            def __init__(self):\n                num = random.randrange(0, 1e10)\n                slashless_path = self.target.path.rstrip('/').rstrip(\"\\\\\")\n                self._temp_path = '{}-luigi-tmp-{:010}{}'.format(\n                    slashless_path,\n                    num,\n                    self.target._trailing_slash())\n                # TODO: os.path doesn't make sense here as it's os-dependent\n                tmp_dir = os.path.dirname(slashless_path)\n                if tmp_dir:\n                    self.target.fs.mkdir(tmp_dir, parents=True, raise_if_exists=False)",
        "begin_line": 281,
        "end_line": 291,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.target._Manager.__enter__#293",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target._Manager",
        "signature": "luigi.target._Manager.__enter__(self)",
        "snippet": "            def __enter__(self):\n                return self._temp_path",
        "begin_line": 293,
        "end_line": 294,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00022331397945511388,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.target._Manager.__exit__#296",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target._Manager",
        "signature": "luigi.target._Manager.__exit__(self, exc_type, exc_value, traceback)",
        "snippet": "            def __exit__(self, exc_type, exc_value, traceback):\n                if exc_type is None:\n                    # There were no exceptions\n                    self.target.fs.rename_dont_move(self._temp_path, self.target.path)\n                return False  # False means we don't suppress the exception",
        "begin_line": 296,
        "end_line": 300,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00022331397945511388,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.target.FileSystemTarget._touchz#304",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.FileSystemTarget",
        "signature": "luigi.target.FileSystemTarget._touchz(self)",
        "snippet": "    def _touchz(self):\n        with self.open('w'):\n            pass",
        "begin_line": 304,
        "end_line": 306,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002294630564479119,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.target.FileSystemTarget._trailing_slash#308",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.FileSystemTarget",
        "signature": "luigi.target.FileSystemTarget._trailing_slash(self)",
        "snippet": "    def _trailing_slash(self):\n        # I suppose one day schema-like paths, like\n        # file:///path/blah.txt?params=etc can be parsed too\n        return self.path[-1] if self.path[-1] in r'\\/' else ''",
        "begin_line": 308,
        "end_line": 311,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00022331397945511388,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.target.AtomicLocalFile.__init__#323",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.AtomicLocalFile",
        "signature": "luigi.target.AtomicLocalFile.__init__(self, path)",
        "snippet": "    def __init__(self, path):\n        self.__tmp_path = self.generate_tmp_path(path)\n        self.path = path\n        super(AtomicLocalFile, self).__init__(io.FileIO(self.__tmp_path, 'w'))",
        "begin_line": 323,
        "end_line": 326,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016409583196586806,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.target.AtomicLocalFile.close#328",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.AtomicLocalFile",
        "signature": "luigi.target.AtomicLocalFile.close(self)",
        "snippet": "    def close(self):\n        super(AtomicLocalFile, self).close()\n        self.move_to_final_destination()",
        "begin_line": 328,
        "end_line": 330,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016539861065167054,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.target.AtomicLocalFile.__del__#338",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.AtomicLocalFile",
        "signature": "luigi.target.AtomicLocalFile.__del__(self)",
        "snippet": "    def __del__(self):\n        if os.path.exists(self.tmp_path):\n            os.remove(self.tmp_path)",
        "begin_line": 338,
        "end_line": 340,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019747235387045813,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.target.AtomicLocalFile.tmp_path#343",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.AtomicLocalFile",
        "signature": "luigi.target.AtomicLocalFile.tmp_path(self)",
        "snippet": "    def tmp_path(self):\n        return self.__tmp_path",
        "begin_line": 343,
        "end_line": 344,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016409583196586806,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.target.AtomicLocalFile.__exit__#346",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.AtomicLocalFile",
        "signature": "luigi.target.AtomicLocalFile.__exit__(self, exc_type, exc, traceback)",
        "snippet": "    def __exit__(self, exc_type, exc, traceback):\n        \" Close/commit the file if there are no exception \"\n        if exc_type:\n            return\n        return super(AtomicLocalFile, self).__exit__(exc_type, exc, traceback)",
        "begin_line": 346,
        "end_line": 350,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.ParameterVisibility.has_value#58",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.ParameterVisibility",
        "signature": "luigi.parameter.ParameterVisibility.has_value(cls, value)",
        "snippet": "    def has_value(cls, value):\n        return any(value == item.value for item in cls)",
        "begin_line": 58,
        "end_line": 59,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018181818181818182,
            "pseudo_dstar_susp": 0.006211180124223602,
            "pseudo_tarantula_susp": 0.001226993865030675,
            "pseudo_op2_susp": 0.006211180124223602,
            "pseudo_barinel_susp": 0.001226993865030675
        }
    },
    {
        "name": "luigi.parameter.ParameterVisibility.serialize#61",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.ParameterVisibility",
        "signature": "luigi.parameter.ParameterVisibility.serialize(self)",
        "snippet": "    def serialize(self):\n        return self.value",
        "begin_line": 61,
        "end_line": 62,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000687757909215956,
            "pseudo_dstar_susp": 0.0007710100231303007,
            "pseudo_tarantula_susp": 0.0008019246190858059,
            "pseudo_op2_susp": 0.0007710100231303007,
            "pseudo_barinel_susp": 0.0008019246190858059
        }
    },
    {
        "name": "luigi.parameter.Parameter.__init__#133",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.__init__(self, default=_no_value, is_global=False, significant=True, description=None, config_path=None, positional=True, always_in_help=False, batch_method=None, visibility=ParameterVisibility.PUBLIC)",
        "snippet": "    def __init__(self, default=_no_value, is_global=False, significant=True, description=None,\n                 config_path=None, positional=True, always_in_help=False, batch_method=None,\n                 visibility=ParameterVisibility.PUBLIC):\n        \"\"\"\n        :param default: the default value for this parameter. This should match the type of the\n                        Parameter, i.e. ``datetime.date`` for ``DateParameter`` or ``int`` for\n                        ``IntParameter``. By default, no default is stored and\n                        the value must be specified at runtime.\n        :param bool significant: specify ``False`` if the parameter should not be treated as part of\n                                 the unique identifier for a Task. An insignificant Parameter might\n                                 also be used to specify a password or other sensitive information\n                                 that should not be made public via the scheduler. Default:\n                                 ``True``.\n        :param str description: A human-readable string describing the purpose of this Parameter.\n                                For command-line invocations, this will be used as the `help` string\n                                shown to users. Default: ``None``.\n        :param dict config_path: a dictionary with entries ``section`` and ``name``\n                                 specifying a config file entry from which to read the\n                                 default value for this parameter. DEPRECATED.\n                                 Default: ``None``.\n        :param bool positional: If true, you can set the argument as a\n                                positional argument. It's true by default but we recommend\n                                ``positional=False`` for abstract base classes and similar cases.\n        :param bool always_in_help: For the --help option in the command line\n                                    parsing. Set true to always show in --help.\n        :param function(iterable[A])->A batch_method: Method to combine an iterable of parsed\n                                                        parameter values into a single value. Used\n                                                        when receiving batched parameter lists from\n                                                        the scheduler. See :ref:`batch_method`\n\n        :param visibility: A Parameter whose value is a :py:class:`~luigi.parameter.ParameterVisibility`.\n                            Default value is ParameterVisibility.PUBLIC\n\n        \"\"\"\n        self._default = default\n        self._batch_method = batch_method\n        if is_global:\n            warnings.warn(\"is_global support is removed. Assuming positional=False\",\n                          DeprecationWarning,\n                          stacklevel=2)\n            positional = False\n        self.significant = significant  # Whether different values for this parameter will differentiate otherwise equal tasks\n        self.positional = positional\n        self.visibility = visibility if ParameterVisibility.has_value(visibility) else ParameterVisibility.PUBLIC\n\n        self.description = description\n        self.always_in_help = always_in_help\n\n        if config_path is not None and ('section' not in config_path or 'name' not in config_path):\n            raise ParameterException('config_path must be a hash containing entries for section and name')\n        self._config_path = config_path\n\n        self._counter = Parameter._counter  # We need to keep track of this to get the order right (see Task class)\n        Parameter._counter += 1",
        "begin_line": 133,
        "end_line": 186,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001375515818431912,
            "pseudo_dstar_susp": 0.0043859649122807015,
            "pseudo_tarantula_susp": 0.001226993865030675,
            "pseudo_op2_susp": 0.0043859649122807015,
            "pseudo_barinel_susp": 0.001226993865030675
        }
    },
    {
        "name": "luigi.parameter.Parameter._get_value_from_config#188",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter._get_value_from_config(self, section, name)",
        "snippet": "    def _get_value_from_config(self, section, name):\n        \"\"\"Loads the default from the config. Returns _no_value if it doesn't exist\"\"\"\n\n        conf = configuration.get_config()\n\n        try:\n            value = conf.get(section, name)\n        except (NoSectionError, NoOptionError, KeyError):\n            return _no_value\n\n        return self.parse(value)",
        "begin_line": 188,
        "end_line": 198,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00196078431372549,
            "pseudo_dstar_susp": 0.011627906976744186,
            "pseudo_tarantula_susp": 0.0010799136069114472,
            "pseudo_op2_susp": 0.011627906976744186,
            "pseudo_barinel_susp": 0.0010799136069114472
        }
    },
    {
        "name": "luigi.parameter.Parameter._get_value#200",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter._get_value(self, task_name, param_name)",
        "snippet": "    def _get_value(self, task_name, param_name):\n        for value, warn in self._value_iterator(task_name, param_name):\n            if value != _no_value:\n                if warn:\n                    warnings.warn(warn, DeprecationWarning)\n                return value\n        return _no_value",
        "begin_line": 200,
        "end_line": 206,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0019342359767891683,
            "pseudo_dstar_susp": 0.010752688172043012,
            "pseudo_tarantula_susp": 0.0010718113612004287,
            "pseudo_op2_susp": 0.010752688172043012,
            "pseudo_barinel_susp": 0.0010718113612004287
        }
    },
    {
        "name": "luigi.parameter.Parameter._value_iterator#208",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter._value_iterator(self, task_name, param_name)",
        "snippet": "    def _value_iterator(self, task_name, param_name):\n        \"\"\"\n        Yield the parameter values, with optional deprecation warning as second tuple value.\n\n        The parameter value will be whatever non-_no_value that is yielded first.\n        \"\"\"\n        cp_parser = CmdlineParser.get_instance()\n        if cp_parser:\n            dest = self._parser_global_dest(param_name, task_name)\n            found = getattr(cp_parser.known_args, dest, None)\n            yield (self._parse_or_no_value(found), None)\n        yield (self._get_value_from_config(task_name, param_name), None)\n        yield (self._get_value_from_config(task_name, param_name.replace('_', '-')),\n               'Configuration [{}] {} (with dashes) should be avoided. Please use underscores.'.format(\n                   task_name, param_name))\n        if self._config_path:\n            yield (self._get_value_from_config(self._config_path['section'], self._config_path['name']),\n                   'The use of the configuration [{}] {} is deprecated. Please use [{}] {}'.format(\n                       self._config_path['section'], self._config_path['name'], task_name, param_name))\n        yield (self._default, None)",
        "begin_line": 208,
        "end_line": 227,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0021141649048625794,
            "pseudo_dstar_susp": 0.012048192771084338,
            "pseudo_tarantula_susp": 0.00117096018735363,
            "pseudo_op2_susp": 0.012048192771084338,
            "pseudo_barinel_susp": 0.00117096018735363
        }
    },
    {
        "name": "luigi.parameter.Parameter.has_task_value#229",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.has_task_value(self, task_name, param_name)",
        "snippet": "    def has_task_value(self, task_name, param_name):\n        return self._get_value(task_name, param_name) != _no_value",
        "begin_line": 229,
        "end_line": 230,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018450184501845018,
            "pseudo_dstar_susp": 0.009345794392523364,
            "pseudo_tarantula_susp": 0.0010559662090813093,
            "pseudo_op2_susp": 0.009345794392523364,
            "pseudo_barinel_susp": 0.0010559662090813093
        }
    },
    {
        "name": "luigi.parameter.Parameter.task_value#232",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.task_value(self, task_name, param_name)",
        "snippet": "    def task_value(self, task_name, param_name):\n        value = self._get_value(task_name, param_name)\n        if value == _no_value:\n            raise MissingParameterException(\"No default specified\")\n        else:\n            return self.normalize(value)",
        "begin_line": 232,
        "end_line": 237,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0019342359767891683,
            "pseudo_dstar_susp": 0.010752688172043012,
            "pseudo_tarantula_susp": 0.0010718113612004287,
            "pseudo_op2_susp": 0.010752688172043012,
            "pseudo_barinel_susp": 0.0010718113612004287
        }
    },
    {
        "name": "luigi.parameter.Parameter._is_batchable#239",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter._is_batchable(self)",
        "snippet": "    def _is_batchable(self):\n        return self._batch_method is not None",
        "begin_line": 239,
        "end_line": 240,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006854009595613434,
            "pseudo_dstar_susp": 0.0007698229407236335,
            "pseudo_tarantula_susp": 0.0008,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0008
        }
    },
    {
        "name": "luigi.parameter.Parameter.parse#242",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.parse(self, x)",
        "snippet": "    def parse(self, x):\n        \"\"\"\n        Parse an individual value from the input.\n\n        The default implementation is the identity function, but subclasses should override\n        this method for specialized parsing.\n\n        :param str x: the value to parse.\n        :return: the parsed value.\n        \"\"\"\n        return x  # default impl",
        "begin_line": 242,
        "end_line": 252,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000676132521974307,
            "pseudo_dstar_susp": 0.0007668711656441718,
            "pseudo_tarantula_susp": 0.0007336757153338225,
            "pseudo_op2_susp": 0.0007668711656441718,
            "pseudo_barinel_susp": 0.0007336757153338225
        }
    },
    {
        "name": "luigi.parameter.Parameter._parse_list#254",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter._parse_list(self, xs)",
        "snippet": "    def _parse_list(self, xs):\n        \"\"\"\n        Parse a list of values from the scheduler.\n\n        Only possible if this is_batchable() is True. This will combine the list into a single\n        parameter value using batch method. This should never need to be overridden.\n\n        :param xs: list of values to parse and combine\n        :return: the combined parsed values\n        \"\"\"\n        if not self._is_batchable():\n            raise NotImplementedError('No batch method found')\n        elif not xs:\n            raise ValueError('Empty parameter list passed to parse_list')\n        else:\n            return self._batch_method(map(self.parse, xs))",
        "begin_line": 254,
        "end_line": 269,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.Parameter.serialize#271",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.serialize(self, x)",
        "snippet": "    def serialize(self, x):\n        \"\"\"\n        Opposite of :py:meth:`parse`.\n\n        Converts the value ``x`` to a string.\n\n        :param x: the value to serialize.\n        \"\"\"\n        return str(x)",
        "begin_line": 271,
        "end_line": 279,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002785515320334262,
            "pseudo_dstar_susp": 0.006802721088435374,
            "pseudo_tarantula_susp": 0.0013531799729364006,
            "pseudo_op2_susp": 0.006802721088435374,
            "pseudo_barinel_susp": 0.0013531799729364006
        }
    },
    {
        "name": "luigi.parameter.Parameter._warn_on_wrong_param_type#281",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter._warn_on_wrong_param_type(self, param_name, param_value)",
        "snippet": "    def _warn_on_wrong_param_type(self, param_name, param_value):\n        if self.__class__ != Parameter:\n            return\n        if not isinstance(param_value, six.string_types):\n            warnings.warn('Parameter \"{}\" with value \"{}\" is not of type string.'.format(param_name, param_value))",
        "begin_line": 281,
        "end_line": 285,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003048780487804878,
            "pseudo_dstar_susp": 0.008695652173913044,
            "pseudo_tarantula_susp": 0.0018656716417910447,
            "pseudo_op2_susp": 0.008695652173913044,
            "pseudo_barinel_susp": 0.001869158878504673
        }
    },
    {
        "name": "luigi.parameter.Parameter.normalize#287",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.normalize(self, x)",
        "snippet": "    def normalize(self, x):\n        \"\"\"\n        Given a parsed parameter value, normalizes it.\n\n        The value can either be the result of parse(), the default value or\n        arguments passed into the task's constructor by instantiation.\n\n        This is very implementation defined, but can be used to validate/clamp\n        valid values. For example, if you wanted to only accept even integers,\n        and \"correct\" odd values to the nearest integer, you can implement\n        normalize as ``x // 2 * 2``.\n        \"\"\"\n        return x  # default impl",
        "begin_line": 287,
        "end_line": 299,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018248175182481751,
            "pseudo_dstar_susp": 0.008849557522123894,
            "pseudo_tarantula_susp": 0.0010471204188481676,
            "pseudo_op2_susp": 0.008849557522123894,
            "pseudo_barinel_susp": 0.0010471204188481676
        }
    },
    {
        "name": "luigi.parameter.Parameter.next_in_enumeration#301",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.next_in_enumeration(self, _value)",
        "snippet": "    def next_in_enumeration(self, _value):\n        \"\"\"\n        If your Parameter type has an enumerable ordering of values. You can\n        choose to override this method. This method is used by the\n        :py:mod:`luigi.execution_summary` module for pretty printing\n        purposes. Enabling it to pretty print tasks like ``MyTask(num=1),\n        MyTask(num=2), MyTask(num=3)`` to ``MyTask(num=1..3)``.\n\n        :param value: The value\n        :return: The next value, like \"value + 1\". Or ``None`` if there's no enumerable ordering.\n        \"\"\"\n        return None",
        "begin_line": 301,
        "end_line": 312,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017455053237912376,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.Parameter._parse_or_no_value#314",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter._parse_or_no_value(self, x)",
        "snippet": "    def _parse_or_no_value(self, x):\n        if not x:\n            return _no_value\n        else:\n            return self.parse(x)",
        "begin_line": 314,
        "end_line": 318,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005980861244019139,
            "pseudo_dstar_susp": 0.0005202913631633715,
            "pseudo_tarantula_susp": 0.0011160714285714285,
            "pseudo_op2_susp": 0.0005202913631633715,
            "pseudo_barinel_susp": 0.0011235955056179776
        }
    },
    {
        "name": "luigi.parameter.Parameter._parser_global_dest#321",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter._parser_global_dest(param_name, task_name)",
        "snippet": "    def _parser_global_dest(param_name, task_name):\n        return task_name + '_' + param_name",
        "begin_line": 321,
        "end_line": 322,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001098901098901099,
            "pseudo_dstar_susp": 0.0008992805755395684,
            "pseudo_tarantula_susp": 0.0014104372355430183,
            "pseudo_op2_susp": 0.0008992805755395684,
            "pseudo_barinel_susp": 0.0014104372355430183
        }
    },
    {
        "name": "luigi.parameter.Parameter._parser_kwargs#325",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter._parser_kwargs(cls, param_name, task_name=None)",
        "snippet": "    def _parser_kwargs(cls, param_name, task_name=None):\n        return {\n            \"action\": \"store\",\n            \"dest\": cls._parser_global_dest(param_name, task_name) if task_name else param_name,\n        }",
        "begin_line": 325,
        "end_line": 329,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001098901098901099,
            "pseudo_dstar_susp": 0.0008992805755395684,
            "pseudo_tarantula_susp": 0.0014104372355430183,
            "pseudo_op2_susp": 0.0008992805755395684,
            "pseudo_barinel_susp": 0.0014104372355430183
        }
    },
    {
        "name": "luigi.parameter.OptionalParameter.serialize#335",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.OptionalParameter",
        "signature": "luigi.parameter.OptionalParameter.serialize(self, x)",
        "snippet": "    def serialize(self, x):\n        if x is None:\n            return ''\n        else:\n            return str(x)",
        "begin_line": 335,
        "end_line": 339,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002079002079002079,
            "pseudo_dstar_susp": 0.0028089887640449437,
            "pseudo_tarantula_susp": 0.002770083102493075,
            "pseudo_op2_susp": 0.0028089887640449437,
            "pseudo_barinel_susp": 0.002770083102493075
        }
    },
    {
        "name": "luigi.parameter.OptionalParameter.parse#341",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.OptionalParameter",
        "signature": "luigi.parameter.OptionalParameter.parse(self, x)",
        "snippet": "    def parse(self, x):\n        return x or None",
        "begin_line": 341,
        "end_line": 342,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.OptionalParameter._warn_on_wrong_param_type#344",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.OptionalParameter",
        "signature": "luigi.parameter.OptionalParameter._warn_on_wrong_param_type(self, param_name, param_value)",
        "snippet": "    def _warn_on_wrong_param_type(self, param_name, param_value):\n        if self.__class__ != OptionalParameter:\n            return\n        if not isinstance(param_value, six.string_types) and param_value is not None:\n            warnings.warn('OptionalParameter \"{}\" with value \"{}\" is not of type string or None.'.format(\n                param_name, param_value))",
        "begin_line": 344,
        "end_line": 349,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012787723785166241,
            "pseudo_dstar_susp": 0.002785515320334262,
            "pseudo_tarantula_susp": 0.001182033096926714,
            "pseudo_op2_susp": 0.002785515320334262,
            "pseudo_barinel_susp": 0.001182033096926714
        }
    },
    {
        "name": "luigi.parameter._DateParameterBase.__init__#360",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._DateParameterBase",
        "signature": "luigi.parameter._DateParameterBase.__init__(self, interval=1, start=None, **kwargs)",
        "snippet": "    def __init__(self, interval=1, start=None, **kwargs):\n        super(_DateParameterBase, self).__init__(**kwargs)\n        self.interval = interval\n        self.start = start if start is not None else _UNIX_EPOCH.date()",
        "begin_line": 360,
        "end_line": 363,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0001726817475392851,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter._DateParameterBase.parse#372",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._DateParameterBase",
        "signature": "luigi.parameter._DateParameterBase.parse(self, s)",
        "snippet": "    def parse(self, s):\n        \"\"\"\n        Parses a date string formatted like ``YYYY-MM-DD``.\n        \"\"\"\n        return datetime.datetime.strptime(s, self.date_format).date()",
        "begin_line": 372,
        "end_line": 376,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0001839926402943882,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter._DateParameterBase.serialize#378",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._DateParameterBase",
        "signature": "luigi.parameter._DateParameterBase.serialize(self, dt)",
        "snippet": "    def serialize(self, dt):\n        \"\"\"\n        Converts the date to a string using the :py:attr:`~_DateParameterBase.date_format`.\n        \"\"\"\n        if dt is None:\n            return str(dt)\n        return dt.strftime(self.date_format)",
        "begin_line": 378,
        "end_line": 384,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00020052135552436334,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.DateParameter.next_in_enumeration#420",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.DateParameter",
        "signature": "luigi.parameter.DateParameter.next_in_enumeration(self, value)",
        "snippet": "    def next_in_enumeration(self, value):\n        return value + datetime.timedelta(days=self.interval)",
        "begin_line": 420,
        "end_line": 421,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021101498206372652,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.DateParameter.normalize#423",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.DateParameter",
        "signature": "luigi.parameter.DateParameter.normalize(self, value)",
        "snippet": "    def normalize(self, value):\n        if value is None:\n            return None\n\n        if isinstance(value, datetime.datetime):\n            value = value.date()\n\n        delta = (value - self.start).days % self.interval\n        return value - datetime.timedelta(days=delta)",
        "begin_line": 423,
        "end_line": 431,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.MonthParameter._add_months#446",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.MonthParameter",
        "signature": "luigi.parameter.MonthParameter._add_months(self, date, months)",
        "snippet": "    def _add_months(self, date, months):\n        \"\"\"\n        Add ``months`` months to ``date``.\n\n        Unfortunately we can't use timedeltas to add months because timedelta counts in days\n        and there's no foolproof way to add N months in days without counting the number of\n        days per month.\n        \"\"\"\n        year = date.year + (date.month + months - 1) // 12\n        month = (date.month + months - 1) % 12 + 1\n        return datetime.date(year=year, month=month, day=1)",
        "begin_line": 446,
        "end_line": 456,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0001839926402943882,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.MonthParameter.next_in_enumeration#458",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.MonthParameter",
        "signature": "luigi.parameter.MonthParameter.next_in_enumeration(self, value)",
        "snippet": "    def next_in_enumeration(self, value):\n        return self._add_months(value, self.interval)",
        "begin_line": 458,
        "end_line": 459,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.MonthParameter.normalize#461",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.MonthParameter",
        "signature": "luigi.parameter.MonthParameter.normalize(self, value)",
        "snippet": "    def normalize(self, value):\n        if value is None:\n            return None\n\n        if isinstance(value, date_interval.Month):\n            value = value.date_a\n\n        months_since_start = (value.year - self.start.year) * 12 + (value.month - self.start.month)\n        months_since_start -= months_since_start % self.interval\n\n        return self._add_months(self.start, months_since_start)",
        "begin_line": 461,
        "end_line": 471,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.YearParameter.normalize#488",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.YearParameter",
        "signature": "luigi.parameter.YearParameter.normalize(self, value)",
        "snippet": "    def normalize(self, value):\n        if value is None:\n            return None\n\n        if isinstance(value, date_interval.Year):\n            value = value.date_a\n\n        delta = (value.year - self.start.year) % self.interval\n        return datetime.date(year=value.year - delta, month=1, day=1)",
        "begin_line": 488,
        "end_line": 496,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter._DatetimeParameterBase.__init__#504",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._DatetimeParameterBase",
        "signature": "luigi.parameter._DatetimeParameterBase.__init__(self, interval=1, start=None, **kwargs)",
        "snippet": "    def __init__(self, interval=1, start=None, **kwargs):\n        super(_DatetimeParameterBase, self).__init__(**kwargs)\n        self.interval = interval\n        self.start = start if start is not None else _UNIX_EPOCH",
        "begin_line": 504,
        "end_line": 507,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002136752136752137,
            "pseudo_dstar_susp": 0.0019569471624266144,
            "pseudo_tarantula_susp": 0.001968503937007874,
            "pseudo_op2_susp": 0.0019569471624266144,
            "pseudo_barinel_susp": 0.001968503937007874
        }
    },
    {
        "name": "luigi.parameter._DatetimeParameterBase.parse#523",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._DatetimeParameterBase",
        "signature": "luigi.parameter._DatetimeParameterBase.parse(self, s)",
        "snippet": "    def parse(self, s):\n        \"\"\"\n        Parses a string to a :py:class:`~datetime.datetime`.\n        \"\"\"\n        return datetime.datetime.strptime(s, self.date_format)",
        "begin_line": 523,
        "end_line": 527,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019102196752626553,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter._DatetimeParameterBase.serialize#529",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._DatetimeParameterBase",
        "signature": "luigi.parameter._DatetimeParameterBase.serialize(self, dt)",
        "snippet": "    def serialize(self, dt):\n        \"\"\"\n        Converts the date to a string using the :py:attr:`~_DatetimeParameterBase.date_format`.\n        \"\"\"\n        if dt is None:\n            return str(dt)\n        return dt.strftime(self.date_format)",
        "begin_line": 529,
        "end_line": 535,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016722408026755853,
            "pseudo_dstar_susp": 0.001838235294117647,
            "pseudo_tarantula_susp": 0.0019267822736030828,
            "pseudo_op2_susp": 0.001838235294117647,
            "pseudo_barinel_susp": 0.0019267822736030828
        }
    },
    {
        "name": "luigi.parameter._DatetimeParameterBase._convert_to_dt#538",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._DatetimeParameterBase",
        "signature": "luigi.parameter._DatetimeParameterBase._convert_to_dt(dt)",
        "snippet": "    def _convert_to_dt(dt):\n        if not isinstance(dt, datetime.datetime):\n            dt = datetime.datetime.combine(dt, datetime.time.min)\n        return dt",
        "begin_line": 538,
        "end_line": 541,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001697792869269949,
            "pseudo_dstar_susp": 0.001869158878504673,
            "pseudo_tarantula_susp": 0.0017857142857142857,
            "pseudo_op2_susp": 0.001869158878504673,
            "pseudo_barinel_susp": 0.0017857142857142857
        }
    },
    {
        "name": "luigi.parameter._DatetimeParameterBase.normalize#543",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._DatetimeParameterBase",
        "signature": "luigi.parameter._DatetimeParameterBase.normalize(self, dt)",
        "snippet": "    def normalize(self, dt):\n        \"\"\"\n        Clamp dt to every Nth :py:attr:`~_DatetimeParameterBase.interval` starting at\n        :py:attr:`~_DatetimeParameterBase.start`.\n        \"\"\"\n        if dt is None:\n            return None\n\n        dt = self._convert_to_dt(dt)\n\n        dt = dt.replace(microsecond=0)  # remove microseconds, to avoid float rounding issues.\n        delta = (dt - self.start).total_seconds()\n        granularity = (self._timedelta * self.interval).total_seconds()\n        return dt - datetime.timedelta(seconds=delta % granularity)",
        "begin_line": 543,
        "end_line": 556,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001697792869269949,
            "pseudo_dstar_susp": 0.001869158878504673,
            "pseudo_tarantula_susp": 0.0019267822736030828,
            "pseudo_op2_susp": 0.001869158878504673,
            "pseudo_barinel_susp": 0.0019267822736030828
        }
    },
    {
        "name": "luigi.parameter._DatetimeParameterBase.next_in_enumeration#558",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._DatetimeParameterBase",
        "signature": "luigi.parameter._DatetimeParameterBase.next_in_enumeration(self, value)",
        "snippet": "    def next_in_enumeration(self, value):\n        return value + self._timedelta * self.interval",
        "begin_line": 558,
        "end_line": 559,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.DateMinuteParameter.parse#590",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.DateMinuteParameter",
        "signature": "luigi.parameter.DateMinuteParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        try:\n            value = datetime.datetime.strptime(s, self.deprecated_date_format)\n            warnings.warn(\n                'Using \"H\" between hours and minutes is deprecated, omit it instead.',\n                DeprecationWarning,\n                stacklevel=2\n            )\n            return value\n        except ValueError:\n            return super(DateMinuteParameter, self).parse(s)",
        "begin_line": 590,
        "end_line": 600,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.IntParameter.parse#623",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.IntParameter",
        "signature": "luigi.parameter.IntParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        \"\"\"\n        Parses an ``int`` from the string using ``int()``.\n        \"\"\"\n        return int(s)",
        "begin_line": 623,
        "end_line": 627,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006027727546714888,
            "pseudo_dstar_susp": 0.0005208333333333333,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0005208333333333333,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "luigi.parameter.IntParameter.next_in_enumeration#629",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.IntParameter",
        "signature": "luigi.parameter.IntParameter.next_in_enumeration(self, value)",
        "snippet": "    def next_in_enumeration(self, value):\n        return value + 1",
        "begin_line": 629,
        "end_line": 630,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0001737921445950643,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.FloatParameter.parse#638",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.FloatParameter",
        "signature": "luigi.parameter.FloatParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        \"\"\"\n        Parses a ``float`` from the string using ``float()``.\n        \"\"\"\n        return float(s)",
        "begin_line": 638,
        "end_line": 642,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00020052135552436334,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.BoolParameter.__init__#679",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.BoolParameter",
        "signature": "luigi.parameter.BoolParameter.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        self.parsing = kwargs.pop(\"parsing\", self.__class__.parsing)\n        super(BoolParameter, self).__init__(*args, **kwargs)\n        if self._default == _no_value:\n            self._default = False",
        "begin_line": 679,
        "end_line": 683,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002079002079002079,
            "pseudo_dstar_susp": 0.0005861664712778429,
            "pseudo_tarantula_susp": 0.002770083102493075,
            "pseudo_op2_susp": 0.0005861664712778429,
            "pseudo_barinel_susp": 0.002770083102493075
        }
    },
    {
        "name": "luigi.parameter.BoolParameter.parse#685",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.BoolParameter",
        "signature": "luigi.parameter.BoolParameter.parse(self, val)",
        "snippet": "    def parse(self, val):\n        \"\"\"\n        Parses a ``bool`` from the string, matching 'true' or 'false' ignoring case.\n        \"\"\"\n        s = str(val).lower()\n        if s == \"true\":\n            return True\n        elif s == \"false\":\n            return False\n        else:\n            raise ValueError(\"cannot interpret '{}' as boolean\".format(val))",
        "begin_line": 685,
        "end_line": 695,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017699115044247787,
            "pseudo_dstar_susp": 0.006493506493506494,
            "pseudo_tarantula_susp": 0.001040582726326743,
            "pseudo_op2_susp": 0.006493506493506494,
            "pseudo_barinel_susp": 0.0010362694300518134
        }
    },
    {
        "name": "luigi.parameter.BoolParameter.normalize#697",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.BoolParameter",
        "signature": "luigi.parameter.BoolParameter.normalize(self, value)",
        "snippet": "    def normalize(self, value):\n        try:\n            return self.parse(value)\n        except ValueError:\n            return None",
        "begin_line": 697,
        "end_line": 701,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017699115044247787,
            "pseudo_dstar_susp": 0.006493506493506494,
            "pseudo_tarantula_susp": 0.001040582726326743,
            "pseudo_op2_susp": 0.006493506493506494,
            "pseudo_barinel_susp": 0.0010362694300518134
        }
    },
    {
        "name": "luigi.parameter.BoolParameter._parser_kwargs#703",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.BoolParameter",
        "signature": "luigi.parameter.BoolParameter._parser_kwargs(self, *args, **kwargs)",
        "snippet": "    def _parser_kwargs(self, *args, **kwargs):\n        parser_kwargs = super(BoolParameter, self)._parser_kwargs(*args, **kwargs)\n        if self.parsing == self.IMPLICIT_PARSING:\n            parser_kwargs[\"action\"] = \"store_true\"\n        elif self.parsing == self.EXPLICIT_PARSING:\n            parser_kwargs[\"nargs\"] = \"?\"\n            parser_kwargs[\"const\"] = True\n        else:\n            raise ValueError(\"unknown parsing value '{}'\".format(self.parsing))\n        return parser_kwargs",
        "begin_line": 703,
        "end_line": 712,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001098901098901099,
            "pseudo_dstar_susp": 0.0008992805755395684,
            "pseudo_tarantula_susp": 0.0014104372355430183,
            "pseudo_op2_susp": 0.0008992805755395684,
            "pseudo_barinel_susp": 0.0014104372355430183
        }
    },
    {
        "name": "luigi.parameter.DateIntervalParameter.parse#725",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.DateIntervalParameter",
        "signature": "luigi.parameter.DateIntervalParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        \"\"\"\n        Parses a :py:class:`~luigi.date_interval.DateInterval` from the input.\n\n        see :py:mod:`luigi.date_interval`\n          for details on the parsing of DateIntervals.\n        \"\"\"\n        # TODO: can we use xml.utils.iso8601 or something similar?\n\n        from luigi import date_interval as d\n\n        for cls in [d.Year, d.Month, d.Week, d.Date, d.Custom]:\n            i = cls.parse(s)\n            if i:\n                return i\n\n        raise ValueError('Invalid date interval - could not be parsed')",
        "begin_line": 725,
        "end_line": 741,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.TimeDeltaParameter._apply_regex#756",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TimeDeltaParameter",
        "signature": "luigi.parameter.TimeDeltaParameter._apply_regex(self, regex, input)",
        "snippet": "    def _apply_regex(self, regex, input):\n        import re\n        re_match = re.match(regex, input)\n        if re_match and any(re_match.groups()):\n            kwargs = {}\n            has_val = False\n            for k, v in six.iteritems(re_match.groupdict(default=\"0\")):\n                val = int(v)\n                if val > -1:\n                    has_val = True\n                    kwargs[k] = val\n            if has_val:\n                return datetime.timedelta(**kwargs)",
        "begin_line": 756,
        "end_line": 768,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00020052135552436334,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.TimeDeltaParameter._parseIso8601#770",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TimeDeltaParameter",
        "signature": "luigi.parameter.TimeDeltaParameter._parseIso8601(self, input)",
        "snippet": "    def _parseIso8601(self, input):\n        def field(key):\n            return r\"(?P<%s>\\d+)%s\" % (key, key[0].upper())\n\n        def optional_field(key):\n            return \"(%s)?\" % field(key)\n\n        # A little loose: ISO 8601 does not allow weeks in combination with other fields, but this regex does (as does python timedelta)\n        regex = \"P(%s|%s(T%s)?)\" % (field(\"weeks\"), optional_field(\"days\"),\n                                    \"\".join([optional_field(key) for key in [\"hours\", \"minutes\", \"seconds\"]]))\n        return self._apply_regex(regex, input)",
        "begin_line": 770,
        "end_line": 780,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019508388607101054,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.TimeDeltaParameter.field#771",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TimeDeltaParameter",
        "signature": "luigi.parameter.TimeDeltaParameter.field(key)",
        "snippet": "        def field(key):\n            return r\"(?P<%s>\\d+)%s\" % (key, key[0].upper())",
        "begin_line": 771,
        "end_line": 772,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019508388607101054,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.TimeDeltaParameter.optional_field#774",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TimeDeltaParameter",
        "signature": "luigi.parameter.TimeDeltaParameter.optional_field(key)",
        "snippet": "        def optional_field(key):\n            return \"(%s)?\" % field(key)",
        "begin_line": 774,
        "end_line": 775,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019508388607101054,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.TimeDeltaParameter._parseSimple#782",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TimeDeltaParameter",
        "signature": "luigi.parameter.TimeDeltaParameter._parseSimple(self, input)",
        "snippet": "    def _parseSimple(self, input):\n        keys = [\"weeks\", \"days\", \"hours\", \"minutes\", \"seconds\"]\n        # Give the digits a regex group name from the keys, then look for text with the first letter of the key,\n        # optionally followed by the rest of the word, with final char (the \"s\") optional\n        regex = \"\".join([r\"((?P<%s>\\d+) ?%s(%s)?(%s)? ?)?\" % (k, k[0], k[1:-1], k[-1]) for k in keys])\n        return self._apply_regex(regex, input)",
        "begin_line": 782,
        "end_line": 787,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.TimeDeltaParameter.parse#789",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TimeDeltaParameter",
        "signature": "luigi.parameter.TimeDeltaParameter.parse(self, input)",
        "snippet": "    def parse(self, input):\n        \"\"\"\n        Parses a time delta from the input.\n\n        See :py:class:`TimeDeltaParameter` for details on supported formats.\n        \"\"\"\n        result = self._parseIso8601(input)\n        if not result:\n            result = self._parseSimple(input)\n        if result is not None:\n            return result\n        else:\n            raise ParameterException(\"Invalid time delta - could not parse %s\" % input)",
        "begin_line": 789,
        "end_line": 801,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.TimeDeltaParameter.serialize#803",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TimeDeltaParameter",
        "signature": "luigi.parameter.TimeDeltaParameter.serialize(self, x)",
        "snippet": "    def serialize(self, x):\n        \"\"\"\n        Converts datetime.timedelta to a string\n\n        :param x: the value to serialize.\n        \"\"\"\n        weeks = x.days // 7\n        days = x.days % 7\n        hours = x.seconds // 3600\n        minutes = (x.seconds % 3600) // 60\n        seconds = (x.seconds % 3600) % 60\n        result = \"{} w {} d {} h {} m {} s\".format(weeks, days, hours, minutes, seconds)\n        return result",
        "begin_line": 803,
        "end_line": 815,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019102196752626553,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.TimeDeltaParameter._warn_on_wrong_param_type#817",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TimeDeltaParameter",
        "signature": "luigi.parameter.TimeDeltaParameter._warn_on_wrong_param_type(self, param_name, param_value)",
        "snippet": "    def _warn_on_wrong_param_type(self, param_name, param_value):\n        if self.__class__ != TimeDeltaParameter:\n            return\n        if not isinstance(param_value, datetime.timedelta):\n            warnings.warn('Parameter \"{}\" with value \"{}\" is not of type timedelta.'.format(param_name, param_value))",
        "begin_line": 817,
        "end_line": 821,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.TaskParameter.parse#843",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TaskParameter",
        "signature": "luigi.parameter.TaskParameter.parse(self, input)",
        "snippet": "    def parse(self, input):\n        \"\"\"\n        Parse a task_famly using the :class:`~luigi.task_register.Register`\n        \"\"\"\n        return task_register.Register.get_task_cls(input)",
        "begin_line": 843,
        "end_line": 847,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.TaskParameter.serialize#849",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TaskParameter",
        "signature": "luigi.parameter.TaskParameter.serialize(self, cls)",
        "snippet": "    def serialize(self, cls):\n        \"\"\"\n        Converts the :py:class:`luigi.task.Task` (sub) class to its family name.\n        \"\"\"\n        return cls.get_task_family()",
        "begin_line": 849,
        "end_line": 853,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018115942028985507,
            "pseudo_dstar_susp": 0.0019455252918287938,
            "pseudo_tarantula_susp": 0.0018867924528301887,
            "pseudo_op2_susp": 0.0019455252918287938,
            "pseudo_barinel_susp": 0.0018867924528301887
        }
    },
    {
        "name": "luigi.parameter.EnumParameter.__init__#879",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.EnumParameter",
        "signature": "luigi.parameter.EnumParameter.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        if 'enum' not in kwargs:\n            raise ParameterException('An enum class must be specified.')\n        self._enum = kwargs.pop('enum')\n        super(EnumParameter, self).__init__(*args, **kwargs)",
        "begin_line": 879,
        "end_line": 883,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.EnumParameter.parse#885",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.EnumParameter",
        "signature": "luigi.parameter.EnumParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        try:\n            return self._enum[s]\n        except KeyError:\n            raise ValueError('Invalid enum value - could not be parsed')",
        "begin_line": 885,
        "end_line": 889,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024630541871921183,
            "pseudo_dstar_susp": 0.0005931198102016608,
            "pseudo_tarantula_susp": 0.0033112582781456954,
            "pseudo_op2_susp": 0.0005931198102016608,
            "pseudo_barinel_susp": 0.0033112582781456954
        }
    },
    {
        "name": "luigi.parameter.EnumParameter.serialize#891",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.EnumParameter",
        "signature": "luigi.parameter.EnumParameter.serialize(self, e)",
        "snippet": "    def serialize(self, e):\n        return e.name",
        "begin_line": 891,
        "end_line": 892,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012755102040816326,
            "pseudo_dstar_susp": 0.002770083102493075,
            "pseudo_tarantula_susp": 0.0011792452830188679,
            "pseudo_op2_susp": 0.002770083102493075,
            "pseudo_barinel_susp": 0.0011792452830188679
        }
    },
    {
        "name": "luigi.parameter._FrozenOrderedDict.__init__#901",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._FrozenOrderedDict",
        "signature": "luigi.parameter._FrozenOrderedDict.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        self.__dict = OrderedDict(*args, **kwargs)\n        self.__hash = None",
        "begin_line": 901,
        "end_line": 903,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016722408026755853,
            "pseudo_dstar_susp": 0.001838235294117647,
            "pseudo_tarantula_susp": 0.0017574692442882249,
            "pseudo_op2_susp": 0.001838235294117647,
            "pseudo_barinel_susp": 0.0017574692442882249
        }
    },
    {
        "name": "luigi.parameter._FrozenOrderedDict.__getitem__#905",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._FrozenOrderedDict",
        "signature": "luigi.parameter._FrozenOrderedDict.__getitem__(self, key)",
        "snippet": "    def __getitem__(self, key):\n        return self.__dict[key]",
        "begin_line": 905,
        "end_line": 906,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012285012285012285,
            "pseudo_dstar_susp": 0.000546448087431694,
            "pseudo_tarantula_susp": 0.001893939393939394,
            "pseudo_op2_susp": 0.000546448087431694,
            "pseudo_barinel_susp": 0.001893939393939394
        }
    },
    {
        "name": "luigi.parameter._FrozenOrderedDict.__iter__#908",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._FrozenOrderedDict",
        "signature": "luigi.parameter._FrozenOrderedDict.__iter__(self)",
        "snippet": "    def __iter__(self):\n        return iter(self.__dict)",
        "begin_line": 908,
        "end_line": 909,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001697792869269949,
            "pseudo_dstar_susp": 0.001869158878504673,
            "pseudo_tarantula_susp": 0.0017857142857142857,
            "pseudo_op2_susp": 0.001869158878504673,
            "pseudo_barinel_susp": 0.0017857142857142857
        }
    },
    {
        "name": "luigi.parameter._FrozenOrderedDict.__repr__#914",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._FrozenOrderedDict",
        "signature": "luigi.parameter._FrozenOrderedDict.__repr__(self)",
        "snippet": "    def __repr__(self):\n        return '<FrozenOrderedDict %s>' % repr(self.__dict)",
        "begin_line": 914,
        "end_line": 915,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021101498206372652,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter._FrozenOrderedDict.__hash__#917",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._FrozenOrderedDict",
        "signature": "luigi.parameter._FrozenOrderedDict.__hash__(self)",
        "snippet": "    def __hash__(self):\n        if self.__hash is None:\n            hashes = map(hash, self.items())\n            self.__hash = functools.reduce(operator.xor, hashes, 0)\n\n        return self.__hash",
        "begin_line": 917,
        "end_line": 922,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017331022530329288,
            "pseudo_dstar_susp": 0.0019083969465648854,
            "pseudo_tarantula_susp": 0.001834862385321101,
            "pseudo_op2_susp": 0.0019083969465648854,
            "pseudo_barinel_susp": 0.001834862385321101
        }
    },
    {
        "name": "luigi.parameter._FrozenOrderedDict.get_wrapped#924",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._FrozenOrderedDict",
        "signature": "luigi.parameter._FrozenOrderedDict.get_wrapped(self)",
        "snippet": "    def get_wrapped(self):\n        return self.__dict",
        "begin_line": 924,
        "end_line": 925,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017331022530329288,
            "pseudo_dstar_susp": 0.0019083969465648854,
            "pseudo_tarantula_susp": 0.001834862385321101,
            "pseudo_op2_susp": 0.0019083969465648854,
            "pseudo_barinel_susp": 0.001834862385321101
        }
    },
    {
        "name": "luigi.parameter._recursively_freeze#928",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter",
        "signature": "luigi.parameter._recursively_freeze(value)",
        "snippet": "def _recursively_freeze(value):\n    \"\"\"\n    Recursively walks ``Mapping``s and ``list``s and converts them to ``_FrozenOrderedDict`` and ``tuples``, respectively.\n    \"\"\"\n    if isinstance(value, Mapping):\n        return _FrozenOrderedDict(((k, _recursively_freeze(v)) for k, v in value.items()))\n    elif isinstance(value, list) or isinstance(value, tuple):\n        return tuple(_recursively_freeze(v) for v in value)\n    return value",
        "begin_line": 928,
        "end_line": 936,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002840909090909091,
            "pseudo_dstar_susp": 0.005291005291005291,
            "pseudo_tarantula_susp": 0.001834862385321101,
            "pseudo_op2_susp": 0.005291005291005291,
            "pseudo_barinel_susp": 0.001834862385321101
        }
    },
    {
        "name": "luigi.parameter._DictParamEncoder.default#944",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._DictParamEncoder",
        "signature": "luigi.parameter._DictParamEncoder.default(self, obj)",
        "snippet": "    def default(self, obj):\n        if isinstance(obj, _FrozenOrderedDict):\n            return obj.get_wrapped()\n        return json.JSONEncoder.default(self, obj)",
        "begin_line": 944,
        "end_line": 947,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017331022530329288,
            "pseudo_dstar_susp": 0.0019083969465648854,
            "pseudo_tarantula_susp": 0.001834862385321101,
            "pseudo_op2_susp": 0.0019083969465648854,
            "pseudo_barinel_susp": 0.001834862385321101
        }
    },
    {
        "name": "luigi.parameter.DictParameter.normalize#983",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.DictParameter",
        "signature": "luigi.parameter.DictParameter.normalize(self, value)",
        "snippet": "    def normalize(self, value):\n        \"\"\"\n        Ensure that dictionary parameter is converted to a _FrozenOrderedDict so it can be hashed.\n        \"\"\"\n        return _recursively_freeze(value)",
        "begin_line": 983,
        "end_line": 987,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017574692442882249,
            "pseudo_dstar_susp": 0.001937984496124031,
            "pseudo_tarantula_susp": 0.0018796992481203006,
            "pseudo_op2_susp": 0.001937984496124031,
            "pseudo_barinel_susp": 0.0018796992481203006
        }
    },
    {
        "name": "luigi.parameter.DictParameter.parse#989",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.DictParameter",
        "signature": "luigi.parameter.DictParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        \"\"\"\n        Parses an immutable and ordered ``dict`` from a JSON string using standard JSON library.\n\n        We need to use an immutable dictionary, to create a hashable parameter and also preserve the internal structure\n        of parsing. The traversal order of standard ``dict`` is undefined, which can result various string\n        representations of this parameter, and therefore a different task id for the task containing this parameter.\n        This is because task id contains the hash of parameters' JSON representation.\n\n        :param s: String to be parse\n        \"\"\"\n        return json.loads(s, object_pairs_hook=_FrozenOrderedDict)",
        "begin_line": 989,
        "end_line": 1000,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.DictParameter.serialize#1002",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.DictParameter",
        "signature": "luigi.parameter.DictParameter.serialize(self, x)",
        "snippet": "    def serialize(self, x):\n        return json.dumps(x, cls=_DictParamEncoder)",
        "begin_line": 1002,
        "end_line": 1003,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017513134851138354,
            "pseudo_dstar_susp": 0.0019305019305019305,
            "pseudo_tarantula_susp": 0.0018726591760299626,
            "pseudo_op2_susp": 0.0019305019305019305,
            "pseudo_barinel_susp": 0.001869158878504673
        }
    },
    {
        "name": "luigi.parameter.ListParameter.normalize#1037",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.ListParameter",
        "signature": "luigi.parameter.ListParameter.normalize(self, x)",
        "snippet": "    def normalize(self, x):\n        \"\"\"\n        Ensure that struct is recursively converted to a tuple so it can be hashed.\n\n        :param str x: the value to parse.\n        :return: the normalized (hashable/immutable) value.\n        \"\"\"\n        return _recursively_freeze(x)",
        "begin_line": 1037,
        "end_line": 1044,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00015941335883947074,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.ListParameter.parse#1046",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.ListParameter",
        "signature": "luigi.parameter.ListParameter.parse(self, x)",
        "snippet": "    def parse(self, x):\n        \"\"\"\n        Parse an individual value from the input.\n\n        :param str x: the value to parse.\n        :return: the parsed value.\n        \"\"\"\n        return list(json.loads(x, object_pairs_hook=_FrozenOrderedDict))",
        "begin_line": 1046,
        "end_line": 1053,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.ListParameter.serialize#1055",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.ListParameter",
        "signature": "luigi.parameter.ListParameter.serialize(self, x)",
        "snippet": "    def serialize(self, x):\n        \"\"\"\n        Opposite of :py:meth:`parse`.\n\n        Converts the value ``x`` to a string.\n\n        :param x: the value to serialize.\n        \"\"\"\n        return json.dumps(x, cls=_DictParamEncoder)",
        "begin_line": 1055,
        "end_line": 1063,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008084074373484236,
            "pseudo_dstar_susp": 0.0005402485143165856,
            "pseudo_tarantula_susp": 0.0015698587127158557,
            "pseudo_op2_susp": 0.0005402485143165856,
            "pseudo_barinel_susp": 0.0015698587127158557
        }
    },
    {
        "name": "luigi.parameter.TupleParameter.parse#1095",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TupleParameter",
        "signature": "luigi.parameter.TupleParameter.parse(self, x)",
        "snippet": "    def parse(self, x):\n        \"\"\"\n        Parse an individual value from the input.\n\n        :param str x: the value to parse.\n        :return: the parsed value.\n        \"\"\"\n        # Since the result of json.dumps(tuple) differs from a tuple string, we must handle either case.\n        # A tuple string may come from a config file or from cli execution.\n\n        # t = ((1, 2), (3, 4))\n        # t_str = '((1,2),(3,4))'\n        # t_json_str = json.dumps(t)\n        # t_json_str == '[[1, 2], [3, 4]]'\n        # json.loads(t_json_str) == t\n        # json.loads(t_str) == ValueError: No JSON object could be decoded\n\n        # Therefore, if json.loads(x) returns a ValueError, try ast.literal_eval(x).\n        # ast.literal_eval(t_str) == t\n        try:\n            # loop required to parse tuple of tuples\n            return tuple(tuple(x) for x in json.loads(x, object_pairs_hook=_FrozenOrderedDict))\n        except ValueError:\n            return literal_eval(x)  # if this causes an error, let that error be raised.",
        "begin_line": 1095,
        "end_line": 1118,
        "comment": "",
        "is_bug": true,
        "susp": {
            "pseudo_ochiai_susp": 0.0032679738562091504,
            "pseudo_dstar_susp": 0.0009596928982725527,
            "pseudo_tarantula_susp": 0.0029411764705882353,
            "pseudo_op2_susp": 0.0009596928982725527,
            "pseudo_barinel_susp": 0.0029411764705882353
        }
    },
    {
        "name": "luigi.parameter.NumericalParameter.__init__#1143",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.NumericalParameter",
        "signature": "luigi.parameter.NumericalParameter.__init__(self, left_op=operator.le, right_op=operator.lt, *args, **kwargs)",
        "snippet": "    def __init__(self, left_op=operator.le, right_op=operator.lt, *args, **kwargs):\n        \"\"\"\n        :param function var_type: The type of the input variable, e.g. int or float.\n        :param min_value: The minimum value permissible in the accepted values\n                          range.  May be inclusive or exclusive based on left_op parameter.\n                          This should be the same type as var_type.\n        :param max_value: The maximum value permissible in the accepted values\n                          range.  May be inclusive or exclusive based on right_op parameter.\n                          This should be the same type as var_type.\n        :param function left_op: The comparison operator for the left-most comparison in\n                                 the expression ``min_value left_op value right_op value``.\n                                 This operator should generally be either\n                                 ``operator.lt`` or ``operator.le``.\n                                 Default: ``operator.le``.\n        :param function right_op: The comparison operator for the right-most comparison in\n                                  the expression ``min_value left_op value right_op value``.\n                                  This operator should generally be either\n                                  ``operator.lt`` or ``operator.le``.\n                                  Default: ``operator.lt``.\n        \"\"\"\n        if \"var_type\" not in kwargs:\n            raise ParameterException(\"var_type must be specified\")\n        self._var_type = kwargs.pop(\"var_type\")\n        if \"min_value\" not in kwargs:\n            raise ParameterException(\"min_value must be specified\")\n        self._min_value = kwargs.pop(\"min_value\")\n        if \"max_value\" not in kwargs:\n            raise ParameterException(\"max_value must be specified\")\n        self._max_value = kwargs.pop(\"max_value\")\n        self._left_op = left_op\n        self._right_op = right_op\n        self._permitted_range = (\n            \"{var_type} in {left_endpoint}{min_value}, {max_value}{right_endpoint}\".format(\n                var_type=self._var_type.__name__,\n                min_value=self._min_value, max_value=self._max_value,\n                left_endpoint=\"[\" if left_op == operator.le else \"(\",\n                right_endpoint=\")\" if right_op == operator.lt else \"]\"))\n        super(NumericalParameter, self).__init__(*args, **kwargs)\n        if self.description:\n            self.description += \" \"\n        else:\n            self.description = \"\"\n        self.description += \"permitted values: \" + self._permitted_range",
        "begin_line": 1143,
        "end_line": 1185,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.NumericalParameter.parse#1187",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.NumericalParameter",
        "signature": "luigi.parameter.NumericalParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        value = self._var_type(s)\n        if (self._left_op(self._min_value, value) and self._right_op(value, self._max_value)):\n            return value\n        else:\n            raise ValueError(\n                \"{s} is not in the set of {permitted_range}\".format(\n                    s=s, permitted_range=self._permitted_range))",
        "begin_line": 1187,
        "end_line": 1194,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.ChoiceParameter.__init__#1222",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.ChoiceParameter",
        "signature": "luigi.parameter.ChoiceParameter.__init__(self, var_type=str, *args, **kwargs)",
        "snippet": "    def __init__(self, var_type=str, *args, **kwargs):\n        \"\"\"\n        :param function var_type: The type of the input variable, e.g. str, int,\n                                  float, etc.\n                                  Default: str\n        :param choices: An iterable, all of whose elements are of `var_type` to\n                        restrict parameter choices to.\n        \"\"\"\n        if \"choices\" not in kwargs:\n            raise ParameterException(\"A choices iterable must be specified\")\n        self._choices = set(kwargs.pop(\"choices\"))\n        self._var_type = var_type\n        assert all(type(choice) is self._var_type for choice in self._choices), \"Invalid type in choices\"\n        super(ChoiceParameter, self).__init__(*args, **kwargs)\n        if self.description:\n            self.description += \" \"\n        else:\n            self.description = \"\"\n        self.description += (\n            \"Choices: {\" + \", \".join(str(choice) for choice in self._choices) + \"}\")",
        "begin_line": 1222,
        "end_line": 1241,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.ChoiceParameter.parse#1243",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.ChoiceParameter",
        "signature": "luigi.parameter.ChoiceParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        var = self._var_type(s)\n        return self.normalize(var)",
        "begin_line": 1243,
        "end_line": 1245,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019327406262079628,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.parameter.ChoiceParameter.normalize#1247",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.ChoiceParameter",
        "signature": "luigi.parameter.ChoiceParameter.normalize(self, var)",
        "snippet": "    def normalize(self, var):\n        if var in self._choices:\n            return var\n        else:\n            raise ValueError(\"{var} is not a valid choice from {choices}\".format(\n                var=var, choices=self._choices))",
        "begin_line": 1247,
        "end_line": 1252,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013458950201884253,
            "pseudo_dstar_susp": 0.00423728813559322,
            "pseudo_tarantula_susp": 0.0011723329425556857,
            "pseudo_op2_susp": 0.00423728813559322,
            "pseudo_barinel_susp": 0.0011723329425556857
        }
    },
    {
        "name": "luigi.configuration.toml_parser.LuigiTomlParser._update_data#38",
        "src_path": "luigi/configuration/toml_parser.py",
        "class_name": "luigi.configuration.toml_parser.LuigiTomlParser",
        "signature": "luigi.configuration.toml_parser.LuigiTomlParser._update_data(data, new_data)",
        "snippet": "    def _update_data(data, new_data):\n        if not new_data:\n            return data\n        if not data:\n            return new_data\n        for section, content in new_data.items():\n            if section not in data:\n                data[section] = dict()\n            data[section].update(content)\n        return data",
        "begin_line": 38,
        "end_line": 47,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.configuration.toml_parser.LuigiTomlParser.read#49",
        "src_path": "luigi/configuration/toml_parser.py",
        "class_name": "luigi.configuration.toml_parser.LuigiTomlParser",
        "signature": "luigi.configuration.toml_parser.LuigiTomlParser.read(self, config_paths)",
        "snippet": "    def read(self, config_paths):\n        self.data = dict()\n        for path in config_paths:\n            if os.path.isfile(path):\n                self.data = self._update_data(self.data, toml.load(path))\n        return self.data",
        "begin_line": 49,
        "end_line": 54,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.configuration.toml_parser.LuigiTomlParser.get#56",
        "src_path": "luigi/configuration/toml_parser.py",
        "class_name": "luigi.configuration.toml_parser.LuigiTomlParser",
        "signature": "luigi.configuration.toml_parser.LuigiTomlParser.get(self, section, option, default=NO_DEFAULT, **kwargs)",
        "snippet": "    def get(self, section, option, default=NO_DEFAULT, **kwargs):\n        try:\n            return self.data[section][option]\n        except KeyError:\n            if default is self.NO_DEFAULT:\n                raise\n            return default",
        "begin_line": 56,
        "end_line": 62,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.configuration.toml_parser.LuigiTomlParser.getboolean#64",
        "src_path": "luigi/configuration/toml_parser.py",
        "class_name": "luigi.configuration.toml_parser.LuigiTomlParser",
        "signature": "luigi.configuration.toml_parser.LuigiTomlParser.getboolean(self, section, option, default=NO_DEFAULT)",
        "snippet": "    def getboolean(self, section, option, default=NO_DEFAULT):\n        return self.get(section, option, default)",
        "begin_line": 64,
        "end_line": 65,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021101498206372652,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.configuration.toml_parser.LuigiTomlParser.set#76",
        "src_path": "luigi/configuration/toml_parser.py",
        "class_name": "luigi.configuration.toml_parser.LuigiTomlParser",
        "signature": "luigi.configuration.toml_parser.LuigiTomlParser.set(self, section, option, value=None)",
        "snippet": "    def set(self, section, option, value=None):\n        if section not in self.data:\n            self.data[section] = {}\n        self.data[section][option] = value",
        "begin_line": 76,
        "end_line": 79,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.configuration.toml_parser.LuigiTomlParser.__getitem__#81",
        "src_path": "luigi/configuration/toml_parser.py",
        "class_name": "luigi.configuration.toml_parser.LuigiTomlParser",
        "signature": "luigi.configuration.toml_parser.LuigiTomlParser.__getitem__(self, name)",
        "snippet": "    def __getitem__(self, name):\n        return self.data[name]",
        "begin_line": 81,
        "end_line": 82,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.HiveCommandError.__init__#41",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveCommandError",
        "signature": "luigi.contrib.hive.HiveCommandError.__init__(self, message, out=None, err=None)",
        "snippet": "    def __init__(self, message, out=None, err=None):\n        super(HiveCommandError, self).__init__(message, out, err)\n        self.message = message\n        self.out = out\n        self.err = err",
        "begin_line": 41,
        "end_line": 45,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.load_hive_cmd#48",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive",
        "signature": "luigi.contrib.hive.load_hive_cmd()",
        "snippet": "def load_hive_cmd():\n    return luigi.configuration.get_config().get('hive', 'command', 'hive').split(' ')",
        "begin_line": 48,
        "end_line": 49,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.get_hive_syntax#52",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive",
        "signature": "luigi.contrib.hive.get_hive_syntax()",
        "snippet": "def get_hive_syntax():\n    return luigi.configuration.get_config().get('hive', 'release', 'cdh4')",
        "begin_line": 52,
        "end_line": 53,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.run_hive#56",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive",
        "signature": "luigi.contrib.hive.run_hive(args, check_return_code=True)",
        "snippet": "def run_hive(args, check_return_code=True):\n    \"\"\"\n    Runs the `hive` from the command line, passing in the given args, and\n    returning stdout.\n\n    With the apache release of Hive, so of the table existence checks\n    (which are done using DESCRIBE do not exit with a return code of 0\n    so we need an option to ignore the return code and just return stdout for parsing\n    \"\"\"\n    cmd = load_hive_cmd() + args\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    stdout, stderr = p.communicate()\n    if check_return_code and p.returncode != 0:\n        raise HiveCommandError(\"Hive command: {0} failed with error code: {1}\".format(\" \".join(cmd), p.returncode),\n                               stdout, stderr)\n    return stdout.decode('utf-8')",
        "begin_line": 56,
        "end_line": 71,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.run_hive_cmd#74",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive",
        "signature": "luigi.contrib.hive.run_hive_cmd(hivecmd, check_return_code=True)",
        "snippet": "def run_hive_cmd(hivecmd, check_return_code=True):\n    \"\"\"\n    Runs the given hive query and returns stdout.\n    \"\"\"\n    return run_hive(['-e', hivecmd], check_return_code)",
        "begin_line": 74,
        "end_line": 78,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.run_hive_script#81",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive",
        "signature": "luigi.contrib.hive.run_hive_script(script)",
        "snippet": "def run_hive_script(script):\n    \"\"\"\n    Runs the contents of the given script in hive and returns stdout.\n    \"\"\"\n    if not os.path.isfile(script):\n        raise RuntimeError(\"Hive script: {0} does not exist.\".format(script))\n    return run_hive(['-f', script])",
        "begin_line": 81,
        "end_line": 87,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.HiveCommandClient.table_location#127",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveCommandClient",
        "signature": "luigi.contrib.hive.HiveCommandClient.table_location(self, table, database='default', partition=None)",
        "snippet": "    def table_location(self, table, database='default', partition=None):\n        cmd = \"use {0}; describe formatted {1}\".format(database, table)\n        if partition is not None:\n            cmd += \" PARTITION ({0})\".format(self.partition_spec(partition))\n\n        stdout = run_hive_cmd(cmd)\n\n        for line in stdout.split(\"\\n\"):\n            if \"Location:\" in line:\n                return line.split(\"\\t\")[1]",
        "begin_line": 127,
        "end_line": 136,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.HiveCommandClient.table_exists#138",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveCommandClient",
        "signature": "luigi.contrib.hive.HiveCommandClient.table_exists(self, table, database='default', partition=None)",
        "snippet": "    def table_exists(self, table, database='default', partition=None):\n        if partition is None:\n            stdout = run_hive_cmd('use {0}; show tables like \"{1}\";'.format(database, table))\n\n            return stdout and table.lower() in stdout\n        else:\n            stdout = run_hive_cmd(\"\"\"use %s; show partitions %s partition\n                                (%s)\"\"\" % (database, table, self.partition_spec(partition)))\n\n            if stdout:\n                return True\n            else:\n                return False",
        "begin_line": 138,
        "end_line": 150,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.HiveCommandClient.table_schema#152",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveCommandClient",
        "signature": "luigi.contrib.hive.HiveCommandClient.table_schema(self, table, database='default')",
        "snippet": "    def table_schema(self, table, database='default'):\n        describe = run_hive_cmd(\"use {0}; describe {1}\".format(database, table))\n        if not describe or \"does not exist\" in describe:\n            return None\n        return [tuple([x.strip() for x in line.strip().split(\"\\t\")]) for line in describe.strip().split(\"\\n\")]",
        "begin_line": 152,
        "end_line": 156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.HiveCommandClient.partition_spec#158",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveCommandClient",
        "signature": "luigi.contrib.hive.HiveCommandClient.partition_spec(self, partition)",
        "snippet": "    def partition_spec(self, partition):\n        \"\"\"\n        Turns a dict into the a Hive partition specification string.\n        \"\"\"\n        return ','.join([\"`{0}`='{1}'\".format(k, v) for (k, v) in\n                         sorted(six.iteritems(partition), key=operator.itemgetter(0))])",
        "begin_line": 158,
        "end_line": 163,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.ApacheHiveCommandClient.table_schema#172",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.ApacheHiveCommandClient",
        "signature": "luigi.contrib.hive.ApacheHiveCommandClient.table_schema(self, table, database='default')",
        "snippet": "    def table_schema(self, table, database='default'):\n        describe = run_hive_cmd(\"use {0}; describe {1}\".format(database, table), False)\n        if not describe or \"Table not found\" in describe:\n            return None\n        return [tuple([x.strip() for x in line.strip().split(\"\\t\")]) for line in describe.strip().split(\"\\n\")]",
        "begin_line": 172,
        "end_line": 176,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.MetastoreClient.table_exists#194",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.MetastoreClient",
        "signature": "luigi.contrib.hive.MetastoreClient.table_exists(self, table, database='default', partition=None)",
        "snippet": "    def table_exists(self, table, database='default', partition=None):\n        with HiveThriftContext() as client:\n            if partition is None:\n                return table in client.get_all_tables(database)\n            else:\n                return partition in self._existing_partitions(table, database, client)",
        "begin_line": 194,
        "end_line": 199,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.MetastoreClient._existing_partitions#201",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.MetastoreClient",
        "signature": "luigi.contrib.hive.MetastoreClient._existing_partitions(self, table, database, client)",
        "snippet": "    def _existing_partitions(self, table, database, client):\n        def _parse_partition_string(partition_string):\n            partition_def = {}\n            for part in partition_string.split(\"/\"):\n                name, value = part.split(\"=\")\n                partition_def[name] = value\n            return partition_def\n\n        # -1 is max_parts, the # of partition names to return (-1 = unlimited)\n        partition_strings = client.get_partition_names(database, table, -1)\n        return [_parse_partition_string(existing_partition) for existing_partition in partition_strings]",
        "begin_line": 201,
        "end_line": 211,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.MetastoreClient._parse_partition_string#202",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.MetastoreClient",
        "signature": "luigi.contrib.hive.MetastoreClient._parse_partition_string(partition_string)",
        "snippet": "        def _parse_partition_string(partition_string):\n            partition_def = {}\n            for part in partition_string.split(\"/\"):\n                name, value = part.split(\"=\")\n                partition_def[name] = value\n            return partition_def",
        "begin_line": 202,
        "end_line": 207,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.MetastoreClient.partition_spec#217",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.MetastoreClient",
        "signature": "luigi.contrib.hive.MetastoreClient.partition_spec(self, partition)",
        "snippet": "    def partition_spec(self, partition):\n        return \"/\".join(\"%s=%s\" % (k, v) for (k, v) in sorted(six.iteritems(partition), key=operator.itemgetter(0)))",
        "begin_line": 217,
        "end_line": 218,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.get_default_client#251",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive",
        "signature": "luigi.contrib.hive.get_default_client()",
        "snippet": "def get_default_client():\n    syntax = get_hive_syntax()\n    if syntax == \"apache\":\n        return ApacheHiveCommandClient()\n    elif syntax == \"metastore\":\n        return MetastoreClient()\n    else:\n        return HiveCommandClient()",
        "begin_line": 251,
        "end_line": 258,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.HiveQueryTask.hiverc#279",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveQueryTask",
        "signature": "luigi.contrib.hive.HiveQueryTask.hiverc(self)",
        "snippet": "    def hiverc(self):\n        \"\"\"\n        Location of an rc file to run before the query\n        if hiverc-location key is specified in luigi.cfg, will default to the value there\n        otherwise returns None.\n\n        Returning a list of rc files will load all of them in order.\n        \"\"\"\n        return luigi.configuration.get_config().get('hive', 'hiverc-location', default=None)",
        "begin_line": 279,
        "end_line": 287,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.HiveQueryTask.hivevars#289",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveQueryTask",
        "signature": "luigi.contrib.hive.HiveQueryTask.hivevars(self)",
        "snippet": "    def hivevars(self):\n        \"\"\"\n        Returns a dict of key=value settings to be passed along\n        to the hive command line via --hivevar.\n        This option can be used as a separated namespace for script local variables.\n        See https://cwiki.apache.org/confluence/display/Hive/LanguageManual+VariableSubstitution\n        \"\"\"\n        return {}",
        "begin_line": 289,
        "end_line": 296,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.HiveQueryTask.hiveconfs#298",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveQueryTask",
        "signature": "luigi.contrib.hive.HiveQueryTask.hiveconfs(self)",
        "snippet": "    def hiveconfs(self):\n        \"\"\"\n        Returns a dict of key=value settings to be passed along\n        to the hive command line via --hiveconf. By default, sets\n        mapred.job.name to task_id and if not None, sets:\n\n        * mapred.reduce.tasks (n_reduce_tasks)\n        * mapred.fairscheduler.pool (pool) or mapred.job.queue.name (pool)\n        * hive.exec.reducers.bytes.per.reducer (bytes_per_reducer)\n        * hive.exec.reducers.max (reducers_max)\n        \"\"\"\n        jcs = {}\n        jcs['mapred.job.name'] = \"'\" + self.task_id + \"'\"\n        if self.n_reduce_tasks is not None:\n            jcs['mapred.reduce.tasks'] = self.n_reduce_tasks\n        if self.pool is not None:\n            # Supporting two schedulers: fair (default) and capacity using the same option\n            scheduler_type = luigi.configuration.get_config().get('hadoop', 'scheduler', 'fair')\n            if scheduler_type == 'fair':\n                jcs['mapred.fairscheduler.pool'] = self.pool\n            elif scheduler_type == 'capacity':\n                jcs['mapred.job.queue.name'] = self.pool\n        if self.bytes_per_reducer is not None:\n            jcs['hive.exec.reducers.bytes.per.reducer'] = self.bytes_per_reducer\n        if self.reducers_max is not None:\n            jcs['hive.exec.reducers.max'] = self.reducers_max\n        return jcs",
        "begin_line": 298,
        "end_line": 324,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.HiveQueryTask.job_runner#326",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveQueryTask",
        "signature": "luigi.contrib.hive.HiveQueryTask.job_runner(self)",
        "snippet": "    def job_runner(self):\n        return HiveQueryRunner()",
        "begin_line": 326,
        "end_line": 327,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.HiveQueryRunner.prepare_outputs#335",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveQueryRunner",
        "signature": "luigi.contrib.hive.HiveQueryRunner.prepare_outputs(self, job)",
        "snippet": "    def prepare_outputs(self, job):\n        \"\"\"\n        Called before job is started.\n\n        If output is a `FileSystemTarget`, create parent directories so the hive command won't fail\n        \"\"\"\n        outputs = flatten(job.output())\n        for o in outputs:\n            if isinstance(o, FileSystemTarget):\n                parent_dir = os.path.dirname(o.path)\n                if parent_dir and not o.fs.exists(parent_dir):\n                    logger.info(\"Creating parent directory %r\", parent_dir)\n                    try:\n                        # there is a possible race condition\n                        # which needs to be handled here\n                        o.fs.mkdir(parent_dir)\n                    except FileAlreadyExists:\n                        pass",
        "begin_line": 335,
        "end_line": 352,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.HiveQueryRunner.get_arglist#354",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveQueryRunner",
        "signature": "luigi.contrib.hive.HiveQueryRunner.get_arglist(self, f_name, job)",
        "snippet": "    def get_arglist(self, f_name, job):\n        arglist = load_hive_cmd() + ['-f', f_name]\n        hiverc = job.hiverc()\n        if hiverc:\n            if isinstance(hiverc, str):\n                hiverc = [hiverc]\n            for rcfile in hiverc:\n                arglist += ['-i', rcfile]\n        hiveconfs = job.hiveconfs()\n        if hiveconfs:\n            for k, v in six.iteritems(hiveconfs):\n                arglist += ['--hiveconf', '{0}={1}'.format(k, v)]\n        hivevars = job.hivevars()\n        if hivevars:\n            for k, v in six.iteritems(hivevars):\n                arglist += ['--hivevar', '{0}={1}'.format(k, v)]\n        logger.info(arglist)\n        return arglist",
        "begin_line": 354,
        "end_line": 371,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.HiveQueryRunner.run_job#373",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveQueryRunner",
        "signature": "luigi.contrib.hive.HiveQueryRunner.run_job(self, job, tracking_url_callback=None)",
        "snippet": "    def run_job(self, job, tracking_url_callback=None):\n        if tracking_url_callback is not None:\n            warnings.warn(\"tracking_url_callback argument is deprecated, task.set_tracking_url is \"\n                          \"used instead.\", DeprecationWarning)\n\n        self.prepare_outputs(job)\n        with tempfile.NamedTemporaryFile() as f:\n            query = job.query()\n            if isinstance(query, unicode):\n                query = query.encode('utf8')\n            f.write(query)\n            f.flush()\n            arglist = self.get_arglist(f.name, job)\n            return luigi.contrib.hadoop.run_and_track_hadoop_job(arglist, job.set_tracking_url)",
        "begin_line": 373,
        "end_line": 386,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.HiveTableTarget.__init__#394",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveTableTarget",
        "signature": "luigi.contrib.hive.HiveTableTarget.__init__(self, table, database='default', client=None)",
        "snippet": "    def __init__(self, table, database='default', client=None):\n        self.database = database\n        self.table = table\n        self.client = client or get_default_client()",
        "begin_line": 394,
        "end_line": 397,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.HiveTableTarget.exists#399",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveTableTarget",
        "signature": "luigi.contrib.hive.HiveTableTarget.exists(self)",
        "snippet": "    def exists(self):\n        logger.debug(\"Checking if Hive table '%s.%s' exists\", self.database, self.table)\n        return self.client.table_exists(self.table, self.database)",
        "begin_line": 399,
        "end_line": 401,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.HivePartitionTarget.__init__#422",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HivePartitionTarget",
        "signature": "luigi.contrib.hive.HivePartitionTarget.__init__(self, table, partition, database='default', fail_missing_table=True, client=None)",
        "snippet": "    def __init__(self, table, partition, database='default', fail_missing_table=True, client=None):\n        self.database = database\n        self.table = table\n        self.partition = partition\n        self.client = client or get_default_client()\n\n        self.fail_missing_table = fail_missing_table",
        "begin_line": 422,
        "end_line": 428,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hive.HivePartitionTarget.exists#430",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HivePartitionTarget",
        "signature": "luigi.contrib.hive.HivePartitionTarget.exists(self)",
        "snippet": "    def exists(self):\n        try:\n            logger.debug(\"Checking Hive table '{d}.{t}' for partition {p}\".format(d=self.database, t=self.table, p=str(self.partition)))\n            return self.client.table_exists(self.table, self.database, self.partition)\n        except HiveCommandError:\n            if self.fail_missing_table:\n                raise\n            else:\n                if self.client.table_exists(self.table, self.database):\n                    # a real error occurred\n                    raise\n                else:\n                    # oh the table just doesn't exist\n                    return False",
        "begin_line": 430,
        "end_line": 443,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.task_register.Register.__new__#58",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.__new__(metacls, classname, bases, classdict)",
        "snippet": "    def __new__(metacls, classname, bases, classdict):\n        \"\"\"\n        Custom class creation for namespacing.\n\n        Also register all subclasses.\n\n        When the set or inherited namespace evaluates to ``None``, set the task namespace to\n        whatever the currently declared namespace is.\n        \"\"\"\n        cls = super(Register, metacls).__new__(metacls, classname, bases, classdict)\n        cls._namespace_at_class_time = metacls._get_namespace(cls.__module__)\n        metacls._reg.append(cls)\n        return cls",
        "begin_line": 58,
        "end_line": 70,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012919896640826874,
            "pseudo_dstar_susp": 0.004,
            "pseudo_tarantula_susp": 0.0011261261261261261,
            "pseudo_op2_susp": 0.004,
            "pseudo_barinel_susp": 0.0011235955056179776
        }
    },
    {
        "name": "luigi.task_register.Register.__call__#72",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.__call__(cls, *args, **kwargs)",
        "snippet": "    def __call__(cls, *args, **kwargs):\n        \"\"\"\n        Custom class instantiation utilizing instance cache.\n\n        If a Task has already been instantiated with the same parameters,\n        the previous instance is returned to reduce number of object instances.\n        \"\"\"\n        def instantiate():\n            return super(Register, cls).__call__(*args, **kwargs)\n\n        h = cls.__instance_cache\n\n        if h is None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        try:\n            hash(k)\n        except TypeError:\n            logger.debug(\"Not all parameter values are hashable so instance isn't coming from the cache\")\n            return instantiate()  # unhashable types in parameters\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]",
        "begin_line": 72,
        "end_line": 101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002631578947368421,
            "pseudo_dstar_susp": 0.02,
            "pseudo_tarantula_susp": 0.0012594458438287153,
            "pseudo_op2_susp": 0.02,
            "pseudo_barinel_susp": 0.0012594458438287153
        }
    },
    {
        "name": "luigi.task_register.Register.instantiate#79",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.instantiate()",
        "snippet": "        def instantiate():\n            return super(Register, cls).__call__(*args, **kwargs)",
        "begin_line": 79,
        "end_line": 80,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0030959752321981426,
            "pseudo_dstar_susp": 0.07142857142857142,
            "pseudo_tarantula_susp": 0.0012578616352201257,
            "pseudo_op2_susp": 0.07142857142857142,
            "pseudo_barinel_susp": 0.0012578616352201257
        }
    },
    {
        "name": "luigi.task_register.Register.clear_instance_cache#104",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.clear_instance_cache(cls)",
        "snippet": "    def clear_instance_cache(cls):\n        \"\"\"\n        Clear/Reset the instance cache.\n        \"\"\"\n        cls.__instance_cache = {}",
        "begin_line": 104,
        "end_line": 108,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007733952049497294,
            "pseudo_dstar_susp": 0.0013568521031207597,
            "pseudo_tarantula_susp": 0.0006506180871828237,
            "pseudo_op2_susp": 0.0013568521031207597,
            "pseudo_barinel_susp": 0.0006506180871828237
        }
    },
    {
        "name": "luigi.task_register.Register.task_family#118",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.task_family(cls)",
        "snippet": "    def task_family(cls):\n        \"\"\"\n        Internal note: This function will be deleted soon.\n        \"\"\"\n        if not cls.get_task_namespace():\n            return cls.__name__\n        else:\n            return \"{}.{}\".format(cls.get_task_namespace(), cls.__name__)",
        "begin_line": 118,
        "end_line": 125,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0019723865877712033,
            "pseudo_dstar_susp": 0.014705882352941176,
            "pseudo_tarantula_susp": 0.0012468827930174563,
            "pseudo_op2_susp": 0.014705882352941176,
            "pseudo_barinel_susp": 0.0012468827930174563
        }
    },
    {
        "name": "luigi.task_register.Register._get_reg#128",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register._get_reg(cls)",
        "snippet": "    def _get_reg(cls):\n        \"\"\"Return all of the registered classes.\n\n        :return:  an ``dict`` of task_family -> class\n        \"\"\"\n        # We have to do this on-demand in case task names have changed later\n        reg = dict()\n        for task_cls in cls._reg:\n            if not task_cls._visible_in_registry:\n                continue\n\n            name = task_cls.get_task_family()\n            if name in reg and \\\n                    (reg[name] == Register.AMBIGUOUS_CLASS or  # Check so issubclass doesn't crash\n                     not issubclass(task_cls, reg[name])):\n                # Registering two different classes - this means we can't instantiate them by name\n                # The only exception is if one class is a subclass of the other. In that case, we\n                # instantiate the most-derived class (this fixes some issues with decorator wrappers).\n                reg[name] = Register.AMBIGUOUS_CLASS\n            else:\n                reg[name] = task_cls\n\n        return reg",
        "begin_line": 128,
        "end_line": 150,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010482180293501049,
            "pseudo_dstar_susp": 0.002380952380952381,
            "pseudo_tarantula_susp": 0.0007535795026375283,
            "pseudo_op2_susp": 0.002380952380952381,
            "pseudo_barinel_susp": 0.0007535795026375283
        }
    },
    {
        "name": "luigi.task_register.Register._set_reg#153",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register._set_reg(cls, reg)",
        "snippet": "    def _set_reg(cls, reg):\n        \"\"\"The writing complement of _get_reg\n        \"\"\"\n        cls._reg = [task_cls for task_cls in reg.values() if task_cls is not cls.AMBIGUOUS_CLASS]",
        "begin_line": 153,
        "end_line": 156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012004801920768306,
            "pseudo_dstar_susp": 0.004807692307692308,
            "pseudo_tarantula_susp": 0.00065359477124183,
            "pseudo_op2_susp": 0.004807692307692308,
            "pseudo_barinel_susp": 0.00065359477124183
        }
    },
    {
        "name": "luigi.task_register.Register.task_names#159",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.task_names(cls)",
        "snippet": "    def task_names(cls):\n        \"\"\"\n        List of task names as strings\n        \"\"\"\n        return sorted(cls._get_reg().keys())",
        "begin_line": 159,
        "end_line": 163,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016260162601626016,
            "pseudo_dstar_susp": 0.0005773672055427252,
            "pseudo_tarantula_susp": 0.002577319587628866,
            "pseudo_op2_susp": 0.0005773672055427252,
            "pseudo_barinel_susp": 0.002577319587628866
        }
    },
    {
        "name": "luigi.task_register.Register.tasks_str#166",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.tasks_str(cls)",
        "snippet": "    def tasks_str(cls):\n        \"\"\"\n        Human-readable register contents dump.\n        \"\"\"\n        return ','.join(cls.task_names())",
        "begin_line": 166,
        "end_line": 170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.task_register.Register.get_task_cls#173",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.get_task_cls(cls, name)",
        "snippet": "    def get_task_cls(cls, name):\n        \"\"\"\n        Returns an unambiguous class or raises an exception.\n        \"\"\"\n        task_cls = cls._get_reg().get(name)\n        if not task_cls:\n            raise TaskClassNotFoundException(cls._missing_task_msg(name))\n\n        if task_cls == cls.AMBIGUOUS_CLASS:\n            raise TaskClassAmbigiousException('Task %r is ambiguous' % name)\n        return task_cls",
        "begin_line": 173,
        "end_line": 183,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016260162601626016,
            "pseudo_dstar_susp": 0.0008710801393728223,
            "pseudo_tarantula_susp": 0.002577319587628866,
            "pseudo_op2_susp": 0.0008710801393728223,
            "pseudo_barinel_susp": 0.002577319587628866
        }
    },
    {
        "name": "luigi.task_register.Register.get_all_params#186",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.get_all_params(cls)",
        "snippet": "    def get_all_params(cls):\n        \"\"\"\n        Compiles and returns all parameters for all :py:class:`Task`.\n\n        :return: a generator of tuples (TODO: we should make this more elegant)\n        \"\"\"\n        for task_name, task_cls in six.iteritems(cls._get_reg()):\n            if task_cls == cls.AMBIGUOUS_CLASS:\n                continue\n            for param_name, param_obj in task_cls.get_params():\n                yield task_name, (not task_cls.use_cmdline_section), param_name, param_obj",
        "begin_line": 186,
        "end_line": 196,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001098901098901099,
            "pseudo_dstar_susp": 0.0008992805755395684,
            "pseudo_tarantula_susp": 0.0014104372355430183,
            "pseudo_op2_susp": 0.0008992805755395684,
            "pseudo_barinel_susp": 0.0014104372355430183
        }
    },
    {
        "name": "luigi.task_register.Register._editdistance#199",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register._editdistance(a, b)",
        "snippet": "    def _editdistance(a, b):\n        \"\"\" Simple unweighted Levenshtein distance \"\"\"\n        r0 = range(0, len(b) + 1)\n        r1 = [0] * (len(b) + 1)\n\n        for i in range(0, len(a)):\n            r1[0] = i + 1\n\n            for j in range(0, len(b)):\n                c = 0 if a[i] is b[j] else 1\n                r1[j + 1] = min(r1[j] + 1, r0[j + 1] + 1, r0[j] + c)\n\n            r0 = r1[:]\n\n        return r1[len(b)]",
        "begin_line": 199,
        "end_line": 213,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016260162601626016,
            "pseudo_dstar_susp": 0.0005773672055427252,
            "pseudo_tarantula_susp": 0.002577319587628866,
            "pseudo_op2_susp": 0.0005773672055427252,
            "pseudo_barinel_susp": 0.002577319587628866
        }
    },
    {
        "name": "luigi.task_register.Register._missing_task_msg#216",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register._missing_task_msg(cls, task_name)",
        "snippet": "    def _missing_task_msg(cls, task_name):\n        weighted_tasks = [(Register._editdistance(task_name, task_name_2), task_name_2) for task_name_2 in cls.task_names()]\n        ordered_tasks = sorted(weighted_tasks, key=lambda pair: pair[0])\n        candidates = [task for (dist, task) in ordered_tasks if dist <= 5 and dist < len(task)]\n        if candidates:\n            return \"No task %s. Did you mean:\\n%s\" % (task_name, '\\n'.join(candidates))\n        else:\n            return \"No task %s. Candidates are: %s\" % (task_name, cls.tasks_str())",
        "begin_line": 216,
        "end_line": 223,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029498525073746312,
            "pseudo_dstar_susp": 0.0009433962264150943,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.0009433962264150943,
            "pseudo_barinel_susp": 0.004629629629629629
        }
    },
    {
        "name": "luigi.task_register.Register._get_namespace#226",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register._get_namespace(mcs, module_name)",
        "snippet": "    def _get_namespace(mcs, module_name):\n        for parent in mcs._module_parents(module_name):\n            entry = mcs._default_namespace_dict.get(parent)\n            if entry:\n                return entry\n        return ''  # Default if nothing specifies",
        "begin_line": 226,
        "end_line": 231,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001310615989515072,
            "pseudo_dstar_susp": 0.004149377593360996,
            "pseudo_tarantula_susp": 0.0011389521640091116,
            "pseudo_op2_susp": 0.004149377593360996,
            "pseudo_barinel_susp": 0.0011389521640091116
        }
    },
    {
        "name": "luigi.task_register.Register._module_parents#234",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register._module_parents(module_name)",
        "snippet": "    def _module_parents(module_name):\n        '''\n        >>> list(Register._module_parents('a.b'))\n        ['a.b', 'a', '']\n        '''\n        spl = module_name.split('.')\n        for i in range(len(spl), 0, -1):\n            yield '.'.join(spl[0:i])\n        if module_name:\n            yield ''",
        "begin_line": 234,
        "end_line": 243,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013089005235602095,
            "pseudo_dstar_susp": 0.004132231404958678,
            "pseudo_tarantula_susp": 0.0011363636363636363,
            "pseudo_op2_susp": 0.004132231404958678,
            "pseudo_barinel_susp": 0.0011363636363636363
        }
    },
    {
        "name": "luigi.task_register.load_task#246",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register",
        "signature": "luigi.task_register.load_task(module, task_name, params_str)",
        "snippet": "def load_task(module, task_name, params_str):\n    \"\"\"\n    Imports task dynamically given a module and a task name.\n    \"\"\"\n    if module is not None:\n        __import__(module)\n    task_cls = Register.get_task_cls(task_name)\n    return task_cls.from_str_params(params_str)",
        "begin_line": 246,
        "end_line": 253,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017966223499820338,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.mysqldb.MySqlTarget.__init__#41",
        "src_path": "luigi/contrib/mysqldb.py",
        "class_name": "luigi.contrib.mysqldb.MySqlTarget",
        "signature": "luigi.contrib.mysqldb.MySqlTarget.__init__(self, host, database, user, password, table, update_id, **cnx_kwargs)",
        "snippet": "    def __init__(self, host, database, user, password, table, update_id, **cnx_kwargs):\n        \"\"\"\n        Initializes a MySqlTarget instance.\n\n        :param host: MySql server address. Possibly a host:port string.\n        :type host: str\n        :param database: database name.\n        :type database: str\n        :param user: database user\n        :type user: str\n        :param password: password for specified user.\n        :type password: str\n        :param update_id: an identifier for this data set.\n        :type update_id: str\n        :param cnx_kwargs: optional params for mysql connector constructor.\n            See https://dev.mysql.com/doc/connector-python/en/connector-python-connectargs.html.\n        \"\"\"\n        if ':' in host:\n            self.host, self.port = host.split(':')\n            self.port = int(self.port)\n        else:\n            self.host = host\n            self.port = 3306\n        self.database = database\n        self.user = user\n        self.password = password\n        self.table = table\n        self.update_id = update_id\n        self.cnx_kwargs = cnx_kwargs",
        "begin_line": 41,
        "end_line": 69,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.mysqldb.MySqlTarget.touch#71",
        "src_path": "luigi/contrib/mysqldb.py",
        "class_name": "luigi.contrib.mysqldb.MySqlTarget",
        "signature": "luigi.contrib.mysqldb.MySqlTarget.touch(self, connection=None)",
        "snippet": "    def touch(self, connection=None):\n        \"\"\"\n        Mark this update as complete.\n\n        IMPORTANT, If the marker table doesn't exist,\n        the connection transaction will be aborted and the connection reset.\n        Then the marker table will be created.\n        \"\"\"\n        self.create_marker_table()\n\n        if connection is None:\n            connection = self.connect()\n            connection.autocommit = True  # if connection created here, we commit it here\n\n        connection.cursor().execute(\n            \"\"\"INSERT INTO {marker_table} (update_id, target_table)\n               VALUES (%s, %s)\n               ON DUPLICATE KEY UPDATE\n               update_id = VALUES(update_id)\n            \"\"\".format(marker_table=self.marker_table),\n            (self.update_id, self.table)\n        )\n        # make sure update is properly marked\n        assert self.exists(connection)",
        "begin_line": 71,
        "end_line": 94,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.mysqldb.MySqlTarget.exists#96",
        "src_path": "luigi/contrib/mysqldb.py",
        "class_name": "luigi.contrib.mysqldb.MySqlTarget",
        "signature": "luigi.contrib.mysqldb.MySqlTarget.exists(self, connection=None)",
        "snippet": "    def exists(self, connection=None):\n        if connection is None:\n            connection = self.connect()\n            connection.autocommit = True\n        cursor = connection.cursor()\n        try:\n            cursor.execute(\"\"\"SELECT 1 FROM {marker_table}\n                WHERE update_id = %s\n                LIMIT 1\"\"\".format(marker_table=self.marker_table),\n                           (self.update_id,)\n                           )\n            row = cursor.fetchone()\n        except mysql.connector.Error as e:\n            if e.errno == errorcode.ER_NO_SUCH_TABLE:\n                row = None\n            else:\n                raise\n        return row is not None",
        "begin_line": 96,
        "end_line": 113,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.mysqldb.MySqlTarget.connect#115",
        "src_path": "luigi/contrib/mysqldb.py",
        "class_name": "luigi.contrib.mysqldb.MySqlTarget",
        "signature": "luigi.contrib.mysqldb.MySqlTarget.connect(self, autocommit=False)",
        "snippet": "    def connect(self, autocommit=False):\n        connection = mysql.connector.connect(user=self.user,\n                                             password=self.password,\n                                             host=self.host,\n                                             port=self.port,\n                                             database=self.database,\n                                             autocommit=autocommit,\n                                             **self.cnx_kwargs)\n        return connection",
        "begin_line": 115,
        "end_line": 123,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.mysqldb.MySqlTarget.create_marker_table#125",
        "src_path": "luigi/contrib/mysqldb.py",
        "class_name": "luigi.contrib.mysqldb.MySqlTarget",
        "signature": "luigi.contrib.mysqldb.MySqlTarget.create_marker_table(self)",
        "snippet": "    def create_marker_table(self):\n        \"\"\"\n        Create marker table if it doesn't exist.\n\n        Using a separate connection since the transaction might have to be reset.\n        \"\"\"\n        connection = self.connect(autocommit=True)\n        cursor = connection.cursor()\n        try:\n            cursor.execute(\n                \"\"\" CREATE TABLE {marker_table} (\n                        id            BIGINT(20)    NOT NULL AUTO_INCREMENT,\n                        update_id     VARCHAR(128)  NOT NULL,\n                        target_table  VARCHAR(128),\n                        inserted      TIMESTAMP DEFAULT NOW(),\n                        PRIMARY KEY (update_id),\n                        KEY id (id)\n                    )\n                \"\"\"\n                .format(marker_table=self.marker_table)\n            )\n        except mysql.connector.Error as e:\n            if e.errno == errorcode.ER_TABLE_EXISTS_ERROR:\n                pass\n            else:\n                raise\n        connection.close()",
        "begin_line": 125,
        "end_line": 151,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.mysqldb.CopyToTable.output#176",
        "src_path": "luigi/contrib/mysqldb.py",
        "class_name": "luigi.contrib.mysqldb.CopyToTable",
        "signature": "luigi.contrib.mysqldb.CopyToTable.output(self)",
        "snippet": "    def output(self):\n        \"\"\"\n        Returns a MySqlTarget representing the inserted dataset.\n\n        Normally you don't override this.\n        \"\"\"\n        return MySqlTarget(\n            host=self.host,\n            database=self.database,\n            user=self.user,\n            password=self.password,\n            table=self.table,\n            update_id=self.update_id\n\n        )",
        "begin_line": 176,
        "end_line": 190,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.mysqldb.CopyToTable.copy#192",
        "src_path": "luigi/contrib/mysqldb.py",
        "class_name": "luigi.contrib.mysqldb.CopyToTable",
        "signature": "luigi.contrib.mysqldb.CopyToTable.copy(self, cursor, file=None)",
        "snippet": "    def copy(self, cursor, file=None):\n        values = '({})'.format(','.join(['%s' for i in range(len(self.columns))]))\n        columns = '({})'.format(','.join([c[0] for c in self.columns]))\n        query = 'INSERT INTO {} {} VALUES {}'.format(self.table, columns, values)\n        rows = []\n\n        for idx, row in enumerate(self.rows()):\n            rows.append(row)\n\n            if (idx + 1) % self.bulk_size == 0:\n                cursor.executemany(query, rows)\n                rows = []\n\n        cursor.executemany(query, rows)",
        "begin_line": 192,
        "end_line": 205,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.mysqldb.CopyToTable.run#207",
        "src_path": "luigi/contrib/mysqldb.py",
        "class_name": "luigi.contrib.mysqldb.CopyToTable",
        "signature": "luigi.contrib.mysqldb.CopyToTable.run(self)",
        "snippet": "    def run(self):\n        \"\"\"\n        Inserts data generated by rows() into target table.\n\n        If the target table doesn't exist, self.create_table will be called to attempt to create the table.\n\n        Normally you don't want to override this.\n        \"\"\"\n        if not (self.table and self.columns):\n            raise Exception(\"table and columns need to be specified\")\n\n        connection = self.output().connect()\n\n        # attempt to copy the data into mysql\n        # if it fails because the target table doesn't exist\n        # try to create it by running self.create_table\n        for attempt in range(2):\n            try:\n                cursor = connection.cursor()\n                print(\"caling init copy...\")\n                self.init_copy(connection)\n                self.copy(cursor)\n                self.post_copy(connection)\n                if self.enable_metadata_columns:\n                    self.post_copy_metacolumns(cursor)\n            except Error as err:\n                if err.errno == errorcode.ER_NO_SUCH_TABLE and attempt == 0:\n                    # if first attempt fails with \"relation not found\", try creating table\n                    # logger.info(\"Creating table %s\", self.table)\n                    connection.reconnect()\n                    self.create_table(connection)\n                else:\n                    raise\n            else:\n                break\n\n        # mark as complete in same transaction\n        self.output().touch(connection)\n        connection.commit()\n        connection.close()",
        "begin_line": 207,
        "end_line": 246,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.mysqldb.CopyToTable.bulk_size#249",
        "src_path": "luigi/contrib/mysqldb.py",
        "class_name": "luigi.contrib.mysqldb.CopyToTable",
        "signature": "luigi.contrib.mysqldb.CopyToTable.bulk_size(self)",
        "snippet": "    def bulk_size(self):\n        return 10000",
        "begin_line": 249,
        "end_line": 250,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop.get_extra_files#100",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop",
        "signature": "luigi.contrib.hadoop.get_extra_files(extra_files)",
        "snippet": "def get_extra_files(extra_files):\n    result = []\n    for f in extra_files:\n        if isinstance(f, str):\n            src, dst = f, os.path.basename(f)\n        elif isinstance(f, tuple):\n            src, dst = f\n        else:\n            raise Exception()\n\n        if os.path.isdir(src):\n            src_prefix = os.path.join(src, '')\n            for base, dirs, files in os.walk(src):\n                for f in files:\n                    f_src = os.path.join(base, f)\n                    f_src_stripped = f_src[len(src_prefix):]\n                    f_dst = os.path.join(dst, f_src_stripped)\n                    result.append((f_src, f_dst))\n        else:\n            result.append((src, dst))\n\n    return result",
        "begin_line": 100,
        "end_line": 121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop.HadoopJobRunner.__init__#405",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.HadoopJobRunner",
        "signature": "luigi.contrib.hadoop.HadoopJobRunner.__init__(self, streaming_jar, modules=None, streaming_args=None, libjars=None, libjars_in_hdfs=None, jobconfs=None, input_format=None, output_format=None, end_job_with_atomic_move_dir=True, archives=None)",
        "snippet": "    def __init__(self, streaming_jar, modules=None, streaming_args=None,\n                 libjars=None, libjars_in_hdfs=None, jobconfs=None,\n                 input_format=None, output_format=None,\n                 end_job_with_atomic_move_dir=True, archives=None):\n        def get(x, default):\n            return x is not None and x or default\n        self.streaming_jar = streaming_jar\n        self.modules = get(modules, [])\n        self.streaming_args = get(streaming_args, [])\n        self.libjars = get(libjars, [])\n        self.libjars_in_hdfs = get(libjars_in_hdfs, [])\n        self.archives = get(archives, [])\n        self.jobconfs = get(jobconfs, {})\n        self.input_format = input_format\n        self.output_format = output_format\n        self.end_job_with_atomic_move_dir = end_job_with_atomic_move_dir\n        self.tmp_dir = False",
        "begin_line": 405,
        "end_line": 421,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop.HadoopJobRunner.get#409",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.HadoopJobRunner",
        "signature": "luigi.contrib.hadoop.HadoopJobRunner.get(x, default)",
        "snippet": "        def get(x, default):\n            return x is not None and x or default",
        "begin_line": 409,
        "end_line": 410,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop.HadoopJobRunner.run_job#423",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.HadoopJobRunner",
        "signature": "luigi.contrib.hadoop.HadoopJobRunner.run_job(self, job, tracking_url_callback=None)",
        "snippet": "    def run_job(self, job, tracking_url_callback=None):\n        if tracking_url_callback is not None:\n            warnings.warn(\"tracking_url_callback argument is deprecated, task.set_tracking_url is \"\n                          \"used instead.\", DeprecationWarning)\n\n        packages = [luigi] + self.modules + job.extra_modules() + list(_attached_packages)\n\n        # find the module containing the job\n        packages.append(__import__(job.__module__, None, None, 'dummy'))\n\n        # find the path to out runner.py\n        runner_path = mrrunner.__file__\n        # assume source is next to compiled\n        if runner_path.endswith(\"pyc\"):\n            runner_path = runner_path[:-3] + \"py\"\n\n        base_tmp_dir = configuration.get_config().get('core', 'tmp-dir', None)\n        if base_tmp_dir:\n            warnings.warn(\"The core.tmp-dir configuration item is\"\n                          \" deprecated, please use the TMPDIR\"\n                          \" environment variable if you wish\"\n                          \" to control where luigi.contrib.hadoop may\"\n                          \" create temporary files and directories.\")\n            self.tmp_dir = os.path.join(base_tmp_dir, 'hadoop_job_%016x' % random.getrandbits(64))\n            os.makedirs(self.tmp_dir)\n        else:\n            self.tmp_dir = tempfile.mkdtemp()\n\n        logger.debug(\"Tmp dir: %s\", self.tmp_dir)\n\n        # build arguments\n        config = configuration.get_config()\n        python_executable = config.get('hadoop', 'python-executable', 'python')\n        runner_arg = 'mrrunner.pex' if job.package_binary is not None else 'mrrunner.py'\n        command = '{0} {1} {{step}}'.format(python_executable, runner_arg)\n        map_cmd = command.format(step='map')\n        cmb_cmd = command.format(step='combiner')\n        red_cmd = command.format(step='reduce')\n\n        output_final = job.output().path\n        # atomic output: replace output with a temporary work directory\n        if self.end_job_with_atomic_move_dir:\n            illegal_targets = (\n                luigi.contrib.s3.S3FlagTarget, luigi.contrib.gcs.GCSFlagTarget)\n            if isinstance(job.output(), illegal_targets):\n                raise TypeError(\"end_job_with_atomic_move_dir is not supported\"\n                                \" for {}\".format(illegal_targets))\n            output_hadoop = '{output}-temp-{time}'.format(\n                output=output_final,\n                time=datetime.datetime.now().isoformat().replace(':', '-'))\n        else:\n            output_hadoop = output_final\n\n        arglist = luigi.contrib.hdfs.load_hadoop_cmd() + ['jar', self.streaming_jar]\n\n        # 'libjars' is a generic option, so place it first\n        libjars = [libjar for libjar in self.libjars]\n\n        for libjar in self.libjars_in_hdfs:\n            run_cmd = luigi.contrib.hdfs.load_hadoop_cmd() + ['fs', '-get', libjar, self.tmp_dir]\n            logger.debug(subprocess.list2cmdline(run_cmd))\n            subprocess.call(run_cmd)\n            libjars.append(os.path.join(self.tmp_dir, os.path.basename(libjar)))\n\n        if libjars:\n            arglist += ['-libjars', ','.join(libjars)]\n\n        # 'archives' is also a generic option\n        archives = []\n        extra_archives = job.extra_archives()\n\n        if self.archives:\n            archives = self.archives\n\n        if extra_archives:\n            archives += extra_archives\n\n        if archives:\n            arglist += ['-archives', ','.join(archives)]\n\n        # Add static files and directories\n        extra_files = get_extra_files(job.extra_files())\n\n        files = []\n        for src, dst in extra_files:\n            dst_tmp = '%s_%09d' % (dst.replace('/', '_'), random.randint(0, 999999999))\n            files += ['%s#%s' % (src, dst_tmp)]\n            # -files doesn't support subdirectories, so we need to create the dst_tmp -> dst manually\n            job.add_link(dst_tmp, dst)\n\n        if files:\n            arglist += ['-files', ','.join(files)]\n\n        jobconfs = job.jobconfs()\n\n        for k, v in six.iteritems(self.jobconfs):\n            jobconfs.append('%s=%s' % (k, v))\n\n        for conf in jobconfs:\n            arglist += ['-D', conf]\n\n        arglist += self.streaming_args\n\n        # Add additonal non-generic  per-job streaming args\n        extra_streaming_args = job.extra_streaming_arguments()\n        for (arg, value) in extra_streaming_args:\n            if not arg.startswith('-'):  # safety first\n                arg = '-' + arg\n            arglist += [arg, value]\n\n        arglist += ['-mapper', map_cmd]\n\n        if job.combiner != NotImplemented:\n            arglist += ['-combiner', cmb_cmd]\n        if job.reducer != NotImplemented:\n            arglist += ['-reducer', red_cmd]\n        packages_fn = 'mrrunner.pex' if job.package_binary is not None else 'packages.tar'\n        files = [\n            runner_path if job.package_binary is None else None,\n            os.path.join(self.tmp_dir, packages_fn),\n            os.path.join(self.tmp_dir, 'job-instance.pickle'),\n        ]\n\n        for f in filter(None, files):\n            arglist += ['-file', f]\n\n        if self.output_format:\n            arglist += ['-outputformat', self.output_format]\n        if self.input_format:\n            arglist += ['-inputformat', self.input_format]\n\n        allowed_input_targets = (\n            luigi.contrib.hdfs.HdfsTarget,\n            luigi.contrib.s3.S3Target,\n            luigi.contrib.gcs.GCSTarget)\n        for target in luigi.task.flatten(job.input_hadoop()):\n            if not isinstance(target, allowed_input_targets):\n                raise TypeError('target must one of: {}'.format(\n                    allowed_input_targets))\n            arglist += ['-input', target.path]\n\n        allowed_output_targets = (\n            luigi.contrib.hdfs.HdfsTarget,\n            luigi.contrib.s3.S3FlagTarget,\n            luigi.contrib.gcs.GCSFlagTarget)\n        if not isinstance(job.output(), allowed_output_targets):\n            raise TypeError('output must be one of: {}'.format(\n                allowed_output_targets))\n        arglist += ['-output', output_hadoop]\n\n        # submit job\n        if job.package_binary is not None:\n            shutil.copy(job.package_binary, os.path.join(self.tmp_dir, 'mrrunner.pex'))\n        else:\n            create_packages_archive(packages, os.path.join(self.tmp_dir, 'packages.tar'))\n\n        job.dump(self.tmp_dir)\n\n        run_and_track_hadoop_job(arglist, tracking_url_callback=job.set_tracking_url)\n\n        if self.end_job_with_atomic_move_dir:\n            luigi.contrib.hdfs.HdfsTarget(output_hadoop).move_dir(output_final)\n        self.finish()",
        "begin_line": 423,
        "end_line": 585,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop.HadoopJobRunner.finish#587",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.HadoopJobRunner",
        "signature": "luigi.contrib.hadoop.HadoopJobRunner.finish(self)",
        "snippet": "    def finish(self):\n        # FIXME: check for isdir?\n        if self.tmp_dir and os.path.exists(self.tmp_dir):\n            logger.debug('Removing directory %s', self.tmp_dir)\n            shutil.rmtree(self.tmp_dir)",
        "begin_line": 587,
        "end_line": 591,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop.HadoopJobRunner.__del__#593",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.HadoopJobRunner",
        "signature": "luigi.contrib.hadoop.HadoopJobRunner.__del__(self)",
        "snippet": "    def __del__(self):\n        self.finish()",
        "begin_line": 593,
        "end_line": 594,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop.BaseHadoopJobTask._get_pool#688",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.BaseHadoopJobTask",
        "signature": "luigi.contrib.hadoop.BaseHadoopJobTask._get_pool(self)",
        "snippet": "    def _get_pool(self):\n        \"\"\" Protected method \"\"\"\n        if self.pool:\n            return self.pool\n        if hadoop().pool:\n            return hadoop().pool",
        "begin_line": 688,
        "end_line": 693,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop.BaseHadoopJobTask.jobconfs#699",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.BaseHadoopJobTask",
        "signature": "luigi.contrib.hadoop.BaseHadoopJobTask.jobconfs(self)",
        "snippet": "    def jobconfs(self):\n        jcs = []\n        jcs.append('mapred.job.name=%s' % self)\n        if self.mr_priority != NotImplemented:\n            jcs.append('mapred.job.priority=%s' % self.mr_priority())\n        pool = self._get_pool()\n        if pool is not None:\n            # Supporting two schedulers: fair (default) and capacity using the same option\n            scheduler_type = configuration.get_config().get('hadoop', 'scheduler', 'fair')\n            if scheduler_type == 'fair':\n                jcs.append('mapred.fairscheduler.pool=%s' % pool)\n            elif scheduler_type == 'capacity':\n                jcs.append('mapred.job.queue.name=%s' % pool)\n        return jcs",
        "begin_line": 699,
        "end_line": 712,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop.BaseHadoopJobTask.init_local#714",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.BaseHadoopJobTask",
        "signature": "luigi.contrib.hadoop.BaseHadoopJobTask.init_local(self)",
        "snippet": "    def init_local(self):\n        \"\"\"\n        Implement any work to setup any internal datastructure etc here.\n\n        You can add extra input using the requires_local/input_local methods.\n\n        Anything you set on the object will be pickled and available on the Hadoop nodes.\n        \"\"\"\n        pass",
        "begin_line": 714,
        "end_line": 722,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop.BaseHadoopJobTask.run#730",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.BaseHadoopJobTask",
        "signature": "luigi.contrib.hadoop.BaseHadoopJobTask.run(self)",
        "snippet": "    def run(self):\n        # The best solution is to store them as lazy `cached_property`, but it\n        # has extraneous dependency. And `property` is slow (need to be\n        # calculated every time when called), so we save them as attributes\n        # directly.\n        self.serialize = DataInterchange[self.data_interchange_format]['serialize']\n        self.internal_serialize = DataInterchange[self.data_interchange_format]['internal_serialize']\n        self.deserialize = DataInterchange[self.data_interchange_format]['deserialize']\n\n        self.init_local()\n        self.job_runner().run_job(self)",
        "begin_line": 730,
        "end_line": 740,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop.BaseHadoopJobTask.requires_local#742",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.BaseHadoopJobTask",
        "signature": "luigi.contrib.hadoop.BaseHadoopJobTask.requires_local(self)",
        "snippet": "    def requires_local(self):\n        \"\"\"\n        Default impl - override this method if you need any local input to be accessible in init().\n        \"\"\"\n        return []",
        "begin_line": 742,
        "end_line": 746,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop.BaseHadoopJobTask.requires_hadoop#748",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.BaseHadoopJobTask",
        "signature": "luigi.contrib.hadoop.BaseHadoopJobTask.requires_hadoop(self)",
        "snippet": "    def requires_hadoop(self):\n        return self.requires()  # default impl",
        "begin_line": 748,
        "end_line": 749,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002294630564479119,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop.BaseHadoopJobTask.input_hadoop#754",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.BaseHadoopJobTask",
        "signature": "luigi.contrib.hadoop.BaseHadoopJobTask.input_hadoop(self)",
        "snippet": "    def input_hadoop(self):\n        return luigi.task.getpaths(self.requires_hadoop())",
        "begin_line": 754,
        "end_line": 755,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop.BaseHadoopJobTask.deps#757",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.BaseHadoopJobTask",
        "signature": "luigi.contrib.hadoop.BaseHadoopJobTask.deps(self)",
        "snippet": "    def deps(self):\n        # Overrides the default implementation\n        return luigi.task.flatten(self.requires_hadoop()) + luigi.task.flatten(self.requires_local())",
        "begin_line": 757,
        "end_line": 759,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop.JobTask.jobconfs#791",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.JobTask",
        "signature": "luigi.contrib.hadoop.JobTask.jobconfs(self)",
        "snippet": "    def jobconfs(self):\n        jcs = super(JobTask, self).jobconfs()\n        if self.reducer == NotImplemented:\n            jcs.append('mapred.reduce.tasks=0')\n        else:\n            jcs.append('mapred.reduce.tasks=%s' % self.n_reduce_tasks)\n        if self.jobconf_truncate >= 0:\n            jcs.append('stream.jobconf.truncate.limit=%i' % self.jobconf_truncate)\n        return jcs",
        "begin_line": 791,
        "end_line": 799,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop.JobTask.extra_modules#920",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.JobTask",
        "signature": "luigi.contrib.hadoop.JobTask.extra_modules(self)",
        "snippet": "    def extra_modules(self):\n        return []  # can be overridden in subclass",
        "begin_line": 920,
        "end_line": 921,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop.JobTask.extra_files#923",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.JobTask",
        "signature": "luigi.contrib.hadoop.JobTask.extra_files(self)",
        "snippet": "    def extra_files(self):\n        \"\"\"\n        Can be overriden in subclass.\n\n        Each element is either a string, or a pair of two strings (src, dst).\n\n        * `src` can be a directory (in which case everything will be copied recursively).\n        * `dst` can include subdirectories (foo/bar/baz.txt etc)\n\n        Uses Hadoop's -files option so that the same file is reused across tasks.\n        \"\"\"\n        return []",
        "begin_line": 923,
        "end_line": 934,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop.JobTask.extra_streaming_arguments#936",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.JobTask",
        "signature": "luigi.contrib.hadoop.JobTask.extra_streaming_arguments(self)",
        "snippet": "    def extra_streaming_arguments(self):\n        \"\"\"\n        Extra arguments to Hadoop command line.\n        Return here a list of (parameter, value) tuples.\n        \"\"\"\n        return []",
        "begin_line": 936,
        "end_line": 941,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop.JobTask.extra_archives#943",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.JobTask",
        "signature": "luigi.contrib.hadoop.JobTask.extra_archives(self)",
        "snippet": "    def extra_archives(self):\n        \"\"\"List of paths to archives \"\"\"\n        return []",
        "begin_line": 943,
        "end_line": 945,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop.JobTask.dump#974",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.JobTask",
        "signature": "luigi.contrib.hadoop.JobTask.dump(self, directory='')",
        "snippet": "    def dump(self, directory=''):\n        \"\"\"\n        Dump instance to file.\n        \"\"\"\n        with self.no_unpicklable_properties():\n            file_name = os.path.join(directory, 'job-instance.pickle')\n            if self.__module__ == '__main__':\n                d = pickle.dumps(self)\n                module_name = os.path.basename(sys.argv[0]).rsplit('.', 1)[0]\n                d = d.replace(b'(c__main__', \"(c\" + module_name)\n                open(file_name, \"wb\").write(d)\n\n            else:\n                pickle.dump(self, open(file_name, \"wb\"))",
        "begin_line": 974,
        "end_line": 987,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.target.CascadingClient.__init__#45",
        "src_path": "luigi/contrib/target.py",
        "class_name": "luigi.contrib.target.CascadingClient",
        "signature": "luigi.contrib.target.CascadingClient.__init__(self, clients, method_names=None)",
        "snippet": "    def __init__(self, clients, method_names=None):\n        self.clients = clients\n        if method_names is None:\n            method_names = self.ALL_METHOD_NAMES\n\n        for method_name in method_names:\n            new_method = self._make_method(method_name)\n            real_method = six.create_bound_method(new_method, self)\n            setattr(self, method_name, real_method)",
        "begin_line": 45,
        "end_line": 53,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.target.CascadingClient.new_method#57",
        "src_path": "luigi/contrib/target.py",
        "class_name": "luigi.contrib.target.CascadingClient",
        "signature": "luigi.contrib.target.CascadingClient.new_method(self, *args, **kwargs)",
        "snippet": "        def new_method(self, *args, **kwargs):\n            return self._chained_call(method_name, *args, **kwargs)",
        "begin_line": 57,
        "end_line": 58,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.target.CascadingClient._make_method#56",
        "src_path": "luigi/contrib/target.py",
        "class_name": "luigi.contrib.target.CascadingClient",
        "signature": "luigi.contrib.target.CascadingClient._make_method(cls, method_name)",
        "snippet": "    def _make_method(cls, method_name):\n        def new_method(self, *args, **kwargs):\n            return self._chained_call(method_name, *args, **kwargs)\n        return new_method",
        "begin_line": 56,
        "end_line": 59,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.target.CascadingClient._chained_call#61",
        "src_path": "luigi/contrib/target.py",
        "class_name": "luigi.contrib.target.CascadingClient",
        "signature": "luigi.contrib.target.CascadingClient._chained_call(self, method_name, *args, **kwargs)",
        "snippet": "    def _chained_call(self, method_name, *args, **kwargs):\n        for i in range(len(self.clients)):\n            client = self.clients[i]\n            try:\n                result = getattr(client, method_name)(*args, **kwargs)\n                return result\n            except luigi.target.FileSystemException:\n                # For exceptions that are semantical, we must throw along\n                raise\n            except BaseException:\n                is_last_iteration = (i + 1) >= len(self.clients)\n                if is_last_iteration:\n                    raise\n                else:\n                    logger.warning('The %s failed to %s, using fallback class %s',\n                                   client.__class__.__name__, method_name, self.clients[i + 1].__class__.__name__)",
        "begin_line": 61,
        "end_line": 76,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.tools.range.RangeBase.of_cls#117",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeBase",
        "signature": "luigi.tools.range.RangeBase.of_cls(self)",
        "snippet": "    def of_cls(self):\n        \"\"\"\n        DONT USE. Will be deleted soon. Use ``self.of``!\n        \"\"\"\n        if isinstance(self.of, six.string_types):\n            warnings.warn('When using Range programatically, dont pass \"of\" param as string!')\n            return Register.get_task_cls(self.of)\n        return self.of",
        "begin_line": 117,
        "end_line": 124,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022471910112359553,
            "pseudo_dstar_susp": 0.0020161290322580645,
            "pseudo_tarantula_susp": 0.0020876826722338203,
            "pseudo_op2_susp": 0.0020161290322580645,
            "pseudo_barinel_susp": 0.00205761316872428
        }
    },
    {
        "name": "luigi.tools.range.RangeBase._emit_metrics#166",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeBase",
        "signature": "luigi.tools.range.RangeBase._emit_metrics(self, missing_datetimes, finite_start, finite_stop)",
        "snippet": "    def _emit_metrics(self, missing_datetimes, finite_start, finite_stop):\n        \"\"\"\n        For consistent metrics one should consider the entire range, but\n        it is open (infinite) if stop or start is None.\n\n        Hence make do with metrics respective to the finite simplification.\n        \"\"\"\n        datetimes = self.finite_datetimes(\n            finite_start if self.start is None else min(finite_start, self.parameter_to_datetime(self.start)),\n            finite_stop if self.stop is None else max(finite_stop, self.parameter_to_datetime(self.stop)))\n\n        delay_in_jobs = len(datetimes) - datetimes.index(missing_datetimes[0]) if datetimes and missing_datetimes else 0\n        self.trigger_event(RangeEvent.DELAY, self.of_cls.task_family, delay_in_jobs)\n\n        expected_count = len(datetimes)\n        complete_count = expected_count - len(missing_datetimes)\n        self.trigger_event(RangeEvent.COMPLETE_COUNT, self.of_cls.task_family, complete_count)\n        self.trigger_event(RangeEvent.COMPLETE_FRACTION, self.of_cls.task_family, float(complete_count) / expected_count if expected_count else 1)",
        "begin_line": 166,
        "end_line": 183,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007680491551459293,
            "pseudo_dstar_susp": 0.0005347593582887701,
            "pseudo_tarantula_susp": 0.0015174506828528073,
            "pseudo_op2_susp": 0.0005347593582887701,
            "pseudo_barinel_susp": 0.0015174506828528073
        }
    },
    {
        "name": "luigi.tools.range.RangeBase._format_datetime#185",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeBase",
        "signature": "luigi.tools.range.RangeBase._format_datetime(self, dt)",
        "snippet": "    def _format_datetime(self, dt):\n        return self.datetime_to_parameter(dt)",
        "begin_line": 185,
        "end_line": 186,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019747235387045813,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.tools.range.RangeBase._format_range#188",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeBase",
        "signature": "luigi.tools.range.RangeBase._format_range(self, datetimes)",
        "snippet": "    def _format_range(self, datetimes):\n        param_first = self._format_datetime(datetimes[0])\n        param_last = self._format_datetime(datetimes[-1])\n        return '[%s, %s]' % (param_first, param_last)",
        "begin_line": 188,
        "end_line": 191,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00228310502283105,
            "pseudo_dstar_susp": 0.0020325203252032522,
            "pseudo_tarantula_susp": 0.002105263157894737,
            "pseudo_op2_susp": 0.0020325203252032522,
            "pseudo_barinel_susp": 0.002105263157894737
        }
    },
    {
        "name": "luigi.tools.range.RangeBase._instantiate_task_cls#193",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeBase",
        "signature": "luigi.tools.range.RangeBase._instantiate_task_cls(self, param)",
        "snippet": "    def _instantiate_task_cls(self, param):\n        return self.of(**self._task_parameters(param))",
        "begin_line": 193,
        "end_line": 194,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008084074373484236,
            "pseudo_dstar_susp": 0.0005402485143165856,
            "pseudo_tarantula_susp": 0.0015698587127158557,
            "pseudo_op2_susp": 0.0005402485143165856,
            "pseudo_barinel_susp": 0.0015698587127158557
        }
    },
    {
        "name": "luigi.tools.range.RangeBase._param_name#197",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeBase",
        "signature": "luigi.tools.range.RangeBase._param_name(self)",
        "snippet": "    def _param_name(self):\n        if self.param_name is None:\n            return next(x[0] for x in self.of.get_params() if x[1].positional)\n        else:\n            return self.param_name",
        "begin_line": 197,
        "end_line": 201,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012300123001230013,
            "pseudo_dstar_susp": 0.0009302325581395349,
            "pseudo_tarantula_susp": 0.0016891891891891893,
            "pseudo_op2_susp": 0.0009302325581395349,
            "pseudo_barinel_susp": 0.0016891891891891893
        }
    },
    {
        "name": "luigi.tools.range.RangeBase._task_parameters#203",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeBase",
        "signature": "luigi.tools.range.RangeBase._task_parameters(self, param)",
        "snippet": "    def _task_parameters(self, param):\n        kwargs = dict(**self.of_params)\n        kwargs[self._param_name] = param\n        return kwargs",
        "begin_line": 203,
        "end_line": 206,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008084074373484236,
            "pseudo_dstar_susp": 0.0005402485143165856,
            "pseudo_tarantula_susp": 0.0015698587127158557,
            "pseudo_op2_susp": 0.0005402485143165856,
            "pseudo_barinel_susp": 0.0015698587127158557
        }
    },
    {
        "name": "luigi.tools.range.RangeBase.requires#208",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeBase",
        "signature": "luigi.tools.range.RangeBase.requires(self)",
        "snippet": "    def requires(self):\n        # cache because we anticipate a fair amount of computation\n        if hasattr(self, '_cached_requires'):\n            return self._cached_requires\n\n        if not self.start and not self.stop:\n            raise ParameterException(\"At least one of start and stop needs to be specified\")\n        if not self.start and not self.reverse:\n            raise ParameterException(\"Either start needs to be specified or reverse needs to be True\")\n        if self.start and self.stop and self.start > self.stop:\n            raise ParameterException(\"Can't have start > stop\")\n        # TODO check overridden complete() and exists()\n\n        now = datetime.utcfromtimestamp(time.time() if self.now is None else self.now)\n\n        moving_start = self.moving_start(now)\n        finite_start = moving_start if self.start is None else max(self.parameter_to_datetime(self.start), moving_start)\n        moving_stop = self.moving_stop(now)\n        finite_stop = moving_stop if self.stop is None else min(self.parameter_to_datetime(self.stop), moving_stop)\n\n        datetimes = self.finite_datetimes(finite_start, finite_stop) if finite_start <= finite_stop else []\n\n        if datetimes:\n            logger.debug('Actually checking if range %s of %s is complete',\n                         self._format_range(datetimes), self.of_cls.task_family)\n            missing_datetimes = sorted(self._missing_datetimes(datetimes))\n            logger.debug('Range %s lacked %d of expected %d %s instances',\n                         self._format_range(datetimes), len(missing_datetimes), len(datetimes), self.of_cls.task_family)\n        else:\n            missing_datetimes = []\n            logger.debug('Empty range. No %s instances expected', self.of_cls.task_family)\n\n        self._emit_metrics(missing_datetimes, finite_start, finite_stop)\n\n        if self.reverse:\n            required_datetimes = missing_datetimes[-self.task_limit:]\n        else:\n            required_datetimes = missing_datetimes[:self.task_limit]\n        if required_datetimes:\n            logger.debug('Requiring %d missing %s instances in range %s',\n                         len(required_datetimes), self.of_cls.task_family, self._format_range(required_datetimes))\n        if self.reverse:\n            required_datetimes.reverse()  # TODO priorities, so that within the batch tasks are ordered too\n\n        self._cached_requires = [self._instantiate_task_cls(self.datetime_to_parameter(d)) for d in required_datetimes]\n        return self._cached_requires",
        "begin_line": 208,
        "end_line": 253,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002347417840375587,
            "pseudo_dstar_susp": 0.002053388090349076,
            "pseudo_tarantula_susp": 0.0021691973969631237,
            "pseudo_op2_susp": 0.002053388090349076,
            "pseudo_barinel_susp": 0.0021691973969631237
        }
    },
    {
        "name": "luigi.tools.range.RangeBase.missing_datetimes#255",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeBase",
        "signature": "luigi.tools.range.RangeBase.missing_datetimes(self, finite_datetimes)",
        "snippet": "    def missing_datetimes(self, finite_datetimes):\n        \"\"\"\n        Override in subclasses to do bulk checks.\n\n        Returns a sorted list.\n\n        This is a conservative base implementation that brutally checks completeness, instance by instance.\n\n        Inadvisable as it may be slow.\n        \"\"\"\n        return [d for d in finite_datetimes if not self._instantiate_task_cls(self.datetime_to_parameter(d)).complete()]",
        "begin_line": 255,
        "end_line": 265,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.tools.range.RangeBase._missing_datetimes#267",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeBase",
        "signature": "luigi.tools.range.RangeBase._missing_datetimes(self, finite_datetimes)",
        "snippet": "    def _missing_datetimes(self, finite_datetimes):\n        \"\"\"\n        Backward compatible wrapper. Will be deleted eventually (stated on Dec 2015)\n        \"\"\"\n        try:\n            return self.missing_datetimes(finite_datetimes)\n        except TypeError as ex:\n            if 'missing_datetimes()' in repr(ex):\n                warnings.warn('In your Range* subclass, missing_datetimes() should only take 1 argument (see latest docs)')\n                return self.missing_datetimes(self.of_cls, finite_datetimes)\n            else:\n                raise",
        "begin_line": 267,
        "end_line": 278,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01818181818181818,
            "pseudo_dstar_susp": 0.002053388090349076,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.002053388090349076,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.tools.range.RangeDailyBase.datetime_to_parameter#304",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeDailyBase",
        "signature": "luigi.tools.range.RangeDailyBase.datetime_to_parameter(self, dt)",
        "snippet": "    def datetime_to_parameter(self, dt):\n        return dt.date()",
        "begin_line": 304,
        "end_line": 305,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019747235387045813,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.tools.range.RangeDailyBase.parameter_to_datetime#307",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeDailyBase",
        "signature": "luigi.tools.range.RangeDailyBase.parameter_to_datetime(self, p)",
        "snippet": "    def parameter_to_datetime(self, p):\n        return datetime(p.year, p.month, p.day)",
        "begin_line": 307,
        "end_line": 308,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019747235387045813,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.tools.range.RangeDailyBase.moving_start#323",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeDailyBase",
        "signature": "luigi.tools.range.RangeDailyBase.moving_start(self, now)",
        "snippet": "    def moving_start(self, now):\n        return now - timedelta(days=self.days_back)",
        "begin_line": 323,
        "end_line": 324,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019747235387045813,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.tools.range.RangeDailyBase.moving_stop#326",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeDailyBase",
        "signature": "luigi.tools.range.RangeDailyBase.moving_stop(self, now)",
        "snippet": "    def moving_stop(self, now):\n        return now + timedelta(days=self.days_forward)",
        "begin_line": 326,
        "end_line": 327,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019747235387045813,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.tools.range.RangeDailyBase.finite_datetimes#329",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeDailyBase",
        "signature": "luigi.tools.range.RangeDailyBase.finite_datetimes(self, finite_start, finite_stop)",
        "snippet": "    def finite_datetimes(self, finite_start, finite_stop):\n        \"\"\"\n        Simply returns the points in time that correspond to turn of day.\n        \"\"\"\n        date_start = datetime(finite_start.year, finite_start.month, finite_start.day)\n        dates = []\n        for i in itertools.count():\n            t = date_start + timedelta(days=i)\n            if t >= finite_stop:\n                return dates\n            if t >= finite_start:\n                dates.append(t)",
        "begin_line": 329,
        "end_line": 340,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00020052135552436334,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase.datetime_to_parameter#367",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase.datetime_to_parameter(self, dt)",
        "snippet": "    def datetime_to_parameter(self, dt):\n        return dt",
        "begin_line": 367,
        "end_line": 368,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase.parameter_to_datetime#370",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase.parameter_to_datetime(self, p)",
        "snippet": "    def parameter_to_datetime(self, p):\n        return p",
        "begin_line": 370,
        "end_line": 371,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021101498206372652,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase.moving_start#385",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase.moving_start(self, now)",
        "snippet": "    def moving_start(self, now):\n        return now - timedelta(hours=self.hours_back)",
        "begin_line": 385,
        "end_line": 386,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021101498206372652,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase.moving_stop#388",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase.moving_stop(self, now)",
        "snippet": "    def moving_stop(self, now):\n        return now + timedelta(hours=self.hours_forward)",
        "begin_line": 388,
        "end_line": 389,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021101498206372652,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase.finite_datetimes#391",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase.finite_datetimes(self, finite_start, finite_stop)",
        "snippet": "    def finite_datetimes(self, finite_start, finite_stop):\n        \"\"\"\n        Simply returns the points in time that correspond to whole hours.\n        \"\"\"\n        datehour_start = datetime(finite_start.year, finite_start.month, finite_start.day, finite_start.hour)\n        datehours = []\n        for i in itertools.count():\n            t = datehour_start + timedelta(hours=i)\n            if t >= finite_stop:\n                return datehours\n            if t >= finite_start:\n                datehours.append(t)",
        "begin_line": 391,
        "end_line": 402,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase._format_datetime#404",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase._format_datetime(self, dt)",
        "snippet": "    def _format_datetime(self, dt):\n        return luigi.DateHourParameter().serialize(dt)",
        "begin_line": 404,
        "end_line": 405,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021101498206372652,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.tools.range.RangeByMinutesBase.datetime_to_parameter#437",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeByMinutesBase",
        "signature": "luigi.tools.range.RangeByMinutesBase.datetime_to_parameter(self, dt)",
        "snippet": "    def datetime_to_parameter(self, dt):\n        return dt",
        "begin_line": 437,
        "end_line": 438,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0032679738562091504,
            "pseudo_dstar_susp": 0.0009596928982725527,
            "pseudo_tarantula_susp": 0.0029411764705882353,
            "pseudo_op2_susp": 0.0009596928982725527,
            "pseudo_barinel_susp": 0.0029411764705882353
        }
    },
    {
        "name": "luigi.tools.range.RangeByMinutesBase.parameter_to_datetime#440",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeByMinutesBase",
        "signature": "luigi.tools.range.RangeByMinutesBase.parameter_to_datetime(self, p)",
        "snippet": "    def parameter_to_datetime(self, p):\n        return p",
        "begin_line": 440,
        "end_line": 441,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0020833333333333333,
            "pseudo_tarantula_susp": 0.0033112582781456954,
            "pseudo_op2_susp": 0.0020833333333333333,
            "pseudo_barinel_susp": 0.0033112582781456954
        }
    },
    {
        "name": "luigi.tools.range.RangeByMinutesBase.moving_start#456",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeByMinutesBase",
        "signature": "luigi.tools.range.RangeByMinutesBase.moving_start(self, now)",
        "snippet": "    def moving_start(self, now):\n        return now - timedelta(minutes=self.minutes_back)",
        "begin_line": 456,
        "end_line": 457,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0020833333333333333,
            "pseudo_tarantula_susp": 0.0033112582781456954,
            "pseudo_op2_susp": 0.0020833333333333333,
            "pseudo_barinel_susp": 0.0033112582781456954
        }
    },
    {
        "name": "luigi.tools.range.RangeByMinutesBase.moving_stop#459",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeByMinutesBase",
        "signature": "luigi.tools.range.RangeByMinutesBase.moving_stop(self, now)",
        "snippet": "    def moving_stop(self, now):\n        return now + timedelta(minutes=self.minutes_forward)",
        "begin_line": 459,
        "end_line": 460,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0020833333333333333,
            "pseudo_tarantula_susp": 0.0033112582781456954,
            "pseudo_op2_susp": 0.0020833333333333333,
            "pseudo_barinel_susp": 0.0033112582781456954
        }
    },
    {
        "name": "luigi.tools.range.RangeByMinutesBase.finite_datetimes#462",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeByMinutesBase",
        "signature": "luigi.tools.range.RangeByMinutesBase.finite_datetimes(self, finite_start, finite_stop)",
        "snippet": "    def finite_datetimes(self, finite_start, finite_stop):\n        \"\"\"\n        Simply returns the points in time that correspond to a whole number of minutes intervals.\n        \"\"\"\n        # Validate that the minutes_interval can divide 60 and it is greater than 0 and lesser than 60\n        if not (0 < self.minutes_interval < 60):\n            raise ParameterException('minutes-interval must be within 0..60')\n        if (60 / self.minutes_interval) * self.minutes_interval != 60:\n            raise ParameterException('minutes-interval does not evenly divide 60')\n        # start of a complete interval, e.g. 20:13 and the interval is 5 -> 20:10\n        start_minute = int(finite_start.minute/self.minutes_interval)*self.minutes_interval\n        datehour_start = datetime(\n            year=finite_start.year,\n            month=finite_start.month,\n            day=finite_start.day,\n            hour=finite_start.hour,\n            minute=start_minute)\n        datehours = []\n        for i in itertools.count():\n            t = datehour_start + timedelta(minutes=i*self.minutes_interval)\n            if t >= finite_stop:\n                return datehours\n            if t >= finite_start:\n                datehours.append(t)",
        "begin_line": 462,
        "end_line": 485,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006134969325153374,
            "pseudo_dstar_susp": 0.002173913043478261,
            "pseudo_tarantula_susp": 0.0038022813688212928,
            "pseudo_op2_susp": 0.002173913043478261,
            "pseudo_barinel_susp": 0.0038022813688212928
        }
    },
    {
        "name": "luigi.tools.range.RangeByMinutesBase._format_datetime#487",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeByMinutesBase",
        "signature": "luigi.tools.range.RangeByMinutesBase._format_datetime(self, dt)",
        "snippet": "    def _format_datetime(self, dt):\n        return luigi.DateMinuteParameter().serialize(dt)",
        "begin_line": 487,
        "end_line": 488,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005813953488372093,
            "pseudo_dstar_susp": 0.0021321961620469083,
            "pseudo_tarantula_susp": 0.0036496350364963502,
            "pseudo_op2_susp": 0.0021321961620469083,
            "pseudo_barinel_susp": 0.0036496350364963502
        }
    },
    {
        "name": "luigi.tools.range._constrain_glob#491",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range._constrain_glob(glob, paths, limit=5)",
        "snippet": "def _constrain_glob(glob, paths, limit=5):\n    \"\"\"\n    Tweaks glob into a list of more specific globs that together still cover paths and not too much extra.\n\n    Saves us minutes long listings for long dataset histories.\n\n    Specifically, in this implementation the leftmost occurrences of \"[0-9]\"\n    give rise to a few separate globs that each specialize the expression to\n    digits that actually occur in paths.\n    \"\"\"\n\n    def digit_set_wildcard(chars):\n        \"\"\"\n        Makes a wildcard expression for the set, a bit readable, e.g. [1-5].\n        \"\"\"\n        chars = sorted(chars)\n        if len(chars) > 1 and ord(chars[-1]) - ord(chars[0]) == len(chars) - 1:\n            return '[%s-%s]' % (chars[0], chars[-1])\n        else:\n            return '[%s]' % ''.join(chars)\n\n    current = {glob: paths}\n    while True:\n        pos = list(current.keys())[0].find('[0-9]')\n        if pos == -1:\n            # no wildcard expressions left to specialize in the glob\n            return list(current.keys())\n        char_sets = {}\n        for g, p in six.iteritems(current):\n            char_sets[g] = sorted({path[pos] for path in p})\n        if sum(len(s) for s in char_sets.values()) > limit:\n            return [g.replace('[0-9]', digit_set_wildcard(char_sets[g]), 1) for g in current]\n        for g, s in six.iteritems(char_sets):\n            for c in s:\n                new_glob = g.replace('[0-9]', c, 1)\n                new_paths = list(filter(lambda p: p[pos] == c, current[g]))\n                current[new_glob] = new_paths\n            del current[g]",
        "begin_line": 491,
        "end_line": 528,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002079002079002079,
            "pseudo_dstar_susp": 0.0009398496240601503,
            "pseudo_tarantula_susp": 0.0023752969121140144,
            "pseudo_op2_susp": 0.0009398496240601503,
            "pseudo_barinel_susp": 0.0023752969121140144
        }
    },
    {
        "name": "luigi.tools.range.digit_set_wildcard#502",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range.digit_set_wildcard(chars)",
        "snippet": "    def digit_set_wildcard(chars):\n        \"\"\"\n        Makes a wildcard expression for the set, a bit readable, e.g. [1-5].\n        \"\"\"\n        chars = sorted(chars)\n        if len(chars) > 1 and ord(chars[-1]) - ord(chars[0]) == len(chars) - 1:\n            return '[%s-%s]' % (chars[0], chars[-1])\n        else:\n            return '[%s]' % ''.join(chars)",
        "begin_line": 502,
        "end_line": 510,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012642225031605564,
            "pseudo_dstar_susp": 0.0005524861878453039,
            "pseudo_tarantula_susp": 0.0020491803278688526,
            "pseudo_op2_susp": 0.0005524861878453039,
            "pseudo_barinel_susp": 0.00205761316872428
        }
    },
    {
        "name": "luigi.tools.range.most_common#531",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range.most_common(items)",
        "snippet": "def most_common(items):\n    \"\"\"\n    Wanted functionality from Counters (new in Python 2.7).\n    \"\"\"\n    counts = {}\n    for i in items:\n        counts.setdefault(i, 0)\n        counts[i] += 1\n    return max(six.iteritems(counts), key=operator.itemgetter(1))",
        "begin_line": 531,
        "end_line": 539,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012642225031605564,
            "pseudo_dstar_susp": 0.0005524861878453039,
            "pseudo_tarantula_susp": 0.0020491803278688526,
            "pseudo_op2_susp": 0.0005524861878453039,
            "pseudo_barinel_susp": 0.00205761316872428
        }
    },
    {
        "name": "luigi.tools.range._get_per_location_glob#542",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range._get_per_location_glob(tasks, outputs, regexes)",
        "snippet": "def _get_per_location_glob(tasks, outputs, regexes):\n    \"\"\"\n    Builds a glob listing existing output paths.\n\n    Esoteric reverse engineering, but worth it given that (compared to an\n    equivalent contiguousness guarantee by naive complete() checks)\n    requests to the filesystem are cut by orders of magnitude, and users\n    don't even have to retrofit existing tasks anyhow.\n    \"\"\"\n    paths = [o.path for o in outputs]\n    # naive, because some matches could be confused by numbers earlier\n    # in path, e.g. /foo/fifa2000k/bar/2000-12-31/00\n    matches = [r.search(p) for r, p in zip(regexes, paths)]\n\n    for m, p, t in zip(matches, paths, tasks):\n        if m is None:\n            raise NotImplementedError(\"Couldn't deduce datehour representation in output path %r of task %s\" % (p, t))\n\n    n_groups = len(matches[0].groups())\n    # the most common position of every group is likely\n    # to be conclusive hit or miss\n    positions = [most_common((m.start(i), m.end(i)) for m in matches)[0] for i in range(1, n_groups + 1)]\n\n    glob = list(paths[0])  # FIXME sanity check that it's the same for all paths\n    for start, end in positions:\n        glob = glob[:start] + ['[0-9]'] * (end - start) + glob[end:]\n    # chop off the last path item\n    # (wouldn't need to if `hadoop fs -ls -d` equivalent were available)\n    return ''.join(glob).rsplit('/', 1)[0]",
        "begin_line": 542,
        "end_line": 570,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017152658662092624,
            "pseudo_dstar_susp": 0.0009380863039399625,
            "pseudo_tarantula_susp": 0.0021321961620469083,
            "pseudo_op2_susp": 0.0009380863039399625,
            "pseudo_barinel_susp": 0.0021321961620469083
        }
    },
    {
        "name": "luigi.tools.range._get_filesystems_and_globs#573",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range._get_filesystems_and_globs(datetime_to_task, datetime_to_re)",
        "snippet": "def _get_filesystems_and_globs(datetime_to_task, datetime_to_re):\n    \"\"\"\n    Yields a (filesystem, glob) tuple per every output location of task.\n\n    The task can have one or several FileSystemTarget outputs.\n\n    For convenience, the task can be a luigi.WrapperTask,\n    in which case outputs of all its dependencies are considered.\n    \"\"\"\n    # probe some scattered datetimes unlikely to all occur in paths, other than by being sincere datetime parameter's representations\n    # TODO limit to [self.start, self.stop) so messages are less confusing? Done trivially it can kill correctness\n    sample_datetimes = [datetime(y, m, d, h) for y in range(2000, 2050, 10) for m in range(1, 4) for d in range(5, 8) for h in range(21, 24)]\n    regexes = [re.compile(datetime_to_re(d)) for d in sample_datetimes]\n    sample_tasks = [datetime_to_task(d) for d in sample_datetimes]\n    sample_outputs = [flatten_output(t) for t in sample_tasks]\n\n    for o, t in zip(sample_outputs, sample_tasks):\n        if len(o) != len(sample_outputs[0]):\n            raise NotImplementedError(\"Outputs must be consistent over time, sorry; was %r for %r and %r for %r\" % (o, t, sample_outputs[0], sample_tasks[0]))\n            # TODO fall back on requiring last couple of days? to avoid astonishing blocking when changes like that are deployed\n            # erm, actually it's not hard to test entire hours_back..hours_forward and split into consistent subranges FIXME?\n        for target in o:\n            if not isinstance(target, FileSystemTarget):\n                raise NotImplementedError(\"Output targets must be instances of FileSystemTarget; was %r for %r\" % (target, t))\n\n    for o in zip(*sample_outputs):  # transposed, so here we're iterating over logical outputs, not datetimes\n        glob = _get_per_location_glob(sample_tasks, o, regexes)\n        yield o[0].fs, glob",
        "begin_line": 573,
        "end_line": 600,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001579778830963665,
            "pseudo_dstar_susp": 0.0009345794392523365,
            "pseudo_tarantula_susp": 0.0021321961620469083,
            "pseudo_op2_susp": 0.0009345794392523365,
            "pseudo_barinel_susp": 0.0021321961620469083
        }
    },
    {
        "name": "luigi.tools.range._list_existing#603",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range._list_existing(filesystem, glob, paths)",
        "snippet": "def _list_existing(filesystem, glob, paths):\n    \"\"\"\n    Get all the paths that do in fact exist. Returns a set of all existing paths.\n\n    Takes a luigi.target.FileSystem object, a str which represents a glob and\n    a list of strings representing paths.\n    \"\"\"\n    globs = _constrain_glob(glob, paths)\n    time_start = time.time()\n    listing = []\n    for g in sorted(globs):\n        logger.debug('Listing %s', g)\n        if filesystem.exists(g):\n            listing.extend(filesystem.listdir(g))\n    logger.debug('%d %s listings took %f s to return %d items',\n                 len(globs), filesystem.__class__.__name__, time.time() - time_start, len(listing))\n    return set(listing)",
        "begin_line": 603,
        "end_line": 619,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001440922190201729,
            "pseudo_dstar_susp": 0.0005675368898978433,
            "pseudo_tarantula_susp": 0.0023752969121140144,
            "pseudo_op2_susp": 0.0005675368898978433,
            "pseudo_barinel_susp": 0.0023752969121140144
        }
    },
    {
        "name": "luigi.tools.range.infer_bulk_complete_from_fs#622",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range.infer_bulk_complete_from_fs(datetimes, datetime_to_task, datetime_to_re)",
        "snippet": "def infer_bulk_complete_from_fs(datetimes, datetime_to_task, datetime_to_re):\n    \"\"\"\n    Efficiently determines missing datetimes by filesystem listing.\n\n    The current implementation works for the common case of a task writing\n    output to a ``FileSystemTarget`` whose path is built using strftime with\n    format like '...%Y...%m...%d...%H...', without custom ``complete()`` or\n    ``exists()``.\n\n    (Eventually Luigi could have ranges of completion as first-class citizens.\n    Then this listing business could be factored away/be provided for\n    explicitly in target API or some kind of a history server.)\n    \"\"\"\n    filesystems_and_globs_by_location = _get_filesystems_and_globs(datetime_to_task, datetime_to_re)\n    paths_by_datetime = [[o.path for o in flatten_output(datetime_to_task(d))] for d in datetimes]\n    listing = set()\n    for (f, g), p in zip(filesystems_and_globs_by_location, zip(*paths_by_datetime)):  # transposed, so here we're iterating over logical outputs, not datetimes\n        listing |= _list_existing(f, g, p)\n\n    # quickly learn everything that's missing\n    missing_datetimes = []\n    for d, p in zip(datetimes, paths_by_datetime):\n        if not set(p) <= listing:\n            missing_datetimes.append(d)\n\n    return missing_datetimes",
        "begin_line": 622,
        "end_line": 647,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022935779816513763,
            "pseudo_dstar_susp": 0.0009416195856873823,
            "pseudo_tarantula_susp": 0.0023752969121140144,
            "pseudo_op2_susp": 0.0009416195856873823,
            "pseudo_barinel_susp": 0.0023752969121140144
        }
    },
    {
        "name": "luigi.tools.range.RangeMonthly.datetime_to_parameter#678",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeMonthly",
        "signature": "luigi.tools.range.RangeMonthly.datetime_to_parameter(self, dt)",
        "snippet": "    def datetime_to_parameter(self, dt):\n        return date(dt.year, dt.month, 1)",
        "begin_line": 678,
        "end_line": 679,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.tools.range.RangeMonthly.parameter_to_datetime#681",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeMonthly",
        "signature": "luigi.tools.range.RangeMonthly.parameter_to_datetime(self, p)",
        "snippet": "    def parameter_to_datetime(self, p):\n        return datetime(p.year, p.month, 1)",
        "begin_line": 681,
        "end_line": 682,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.tools.range.RangeMonthly._format_datetime#697",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeMonthly",
        "signature": "luigi.tools.range.RangeMonthly._format_datetime(self, dt)",
        "snippet": "    def _format_datetime(self, dt):\n        return dt.strftime('%Y-%m')",
        "begin_line": 697,
        "end_line": 698,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021101498206372652,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.tools.range.RangeMonthly.moving_start#700",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeMonthly",
        "signature": "luigi.tools.range.RangeMonthly.moving_start(self, now)",
        "snippet": "    def moving_start(self, now):\n        return now - relativedelta(months=self.months_back)",
        "begin_line": 700,
        "end_line": 701,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.tools.range.RangeMonthly.moving_stop#703",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeMonthly",
        "signature": "luigi.tools.range.RangeMonthly.moving_stop(self, now)",
        "snippet": "    def moving_stop(self, now):\n        return now + relativedelta(months=self.months_forward)",
        "begin_line": 703,
        "end_line": 704,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.tools.range.RangeMonthly.finite_datetimes#706",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeMonthly",
        "signature": "luigi.tools.range.RangeMonthly.finite_datetimes(self, finite_start, finite_stop)",
        "snippet": "    def finite_datetimes(self, finite_start, finite_stop):\n        \"\"\"\n        Simply returns the points in time that correspond to turn of month.\n        \"\"\"\n        start_date = datetime(finite_start.year, finite_start.month, 1)\n        dates = []\n        for m in itertools.count():\n            t = start_date + relativedelta(months=m)\n            if t >= finite_stop:\n                return dates\n            if t >= finite_start:\n                dates.append(t)",
        "begin_line": 706,
        "end_line": 717,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.tools.range.RangeDaily.missing_datetimes#734",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeDaily",
        "signature": "luigi.tools.range.RangeDaily.missing_datetimes(self, finite_datetimes)",
        "snippet": "    def missing_datetimes(self, finite_datetimes):\n        try:\n            cls_with_params = functools.partial(self.of, **self.of_params)\n            complete_parameters = self.of.bulk_complete.__func__(cls_with_params, map(self.datetime_to_parameter, finite_datetimes))\n            return set(finite_datetimes) - set(map(self.parameter_to_datetime, complete_parameters))\n        except NotImplementedError:\n            return infer_bulk_complete_from_fs(\n                finite_datetimes,\n                lambda d: self._instantiate_task_cls(self.datetime_to_parameter(d)),\n                lambda d: d.strftime('(%Y).*(%m).*(%d)'))",
        "begin_line": 734,
        "end_line": 743,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.tools.range.RangeHourly.missing_datetimes#762",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourly",
        "signature": "luigi.tools.range.RangeHourly.missing_datetimes(self, finite_datetimes)",
        "snippet": "    def missing_datetimes(self, finite_datetimes):\n        try:\n            # TODO: Why is there a list() here but not for the RangeDaily??\n            cls_with_params = functools.partial(self.of, **self.of_params)\n            complete_parameters = self.of.bulk_complete.__func__(cls_with_params, list(map(self.datetime_to_parameter, finite_datetimes)))\n            return set(finite_datetimes) - set(map(self.parameter_to_datetime, complete_parameters))\n        except NotImplementedError:\n            return infer_bulk_complete_from_fs(\n                finite_datetimes,\n                lambda d: self._instantiate_task_cls(self.datetime_to_parameter(d)),\n                lambda d: d.strftime('(%Y).*(%m).*(%d).*(%H)'))",
        "begin_line": 762,
        "end_line": 772,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.tools.range.RangeByMinutes.missing_datetimes#791",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeByMinutes",
        "signature": "luigi.tools.range.RangeByMinutes.missing_datetimes(self, finite_datetimes)",
        "snippet": "    def missing_datetimes(self, finite_datetimes):\n        try:\n            cls_with_params = functools.partial(self.of, **self.of_params)\n            complete_parameters = self.of.bulk_complete.__func__(cls_with_params, map(self.datetime_to_parameter, finite_datetimes))\n            return set(finite_datetimes) - set(map(self.parameter_to_datetime, complete_parameters))\n        except NotImplementedError:\n            return infer_bulk_complete_from_fs(\n                finite_datetimes,\n                lambda d: self._instantiate_task_cls(self.datetime_to_parameter(d)),\n                lambda d: d.strftime('(%Y).*(%m).*(%d).*(%H).*(%M)'))",
        "begin_line": 791,
        "end_line": 800,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0136986301369863,
            "pseudo_dstar_susp": 0.002188183807439825,
            "pseudo_tarantula_susp": 0.006756756756756757,
            "pseudo_op2_susp": 0.002188183807439825,
            "pseudo_barinel_susp": 0.006756756756756757
        }
    },
    {
        "name": "luigi.batch_notifier.ExplQueue.__init__#34",
        "src_path": "luigi/batch_notifier.py",
        "class_name": "luigi.batch_notifier.ExplQueue",
        "signature": "luigi.batch_notifier.ExplQueue.__init__(self, num_items)",
        "snippet": "    def __init__(self, num_items):\n        self.num_items = num_items\n        super(ExplQueue, self).__init__()",
        "begin_line": 34,
        "end_line": 36,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017053206002728513,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.batch_notifier.ExplQueue.enqueue#38",
        "src_path": "luigi/batch_notifier.py",
        "class_name": "luigi.batch_notifier.ExplQueue",
        "signature": "luigi.batch_notifier.ExplQueue.enqueue(self, item)",
        "snippet": "    def enqueue(self, item):\n        self.pop(item, None)\n        self[item] = datetime.now()\n        if len(self) > self.num_items:\n            self.popitem(last=False)  # pop first item if past length",
        "begin_line": 38,
        "end_line": 42,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0001781895937277263,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.batch_notifier._fail_queue#45",
        "src_path": "luigi/batch_notifier.py",
        "class_name": "luigi.batch_notifier",
        "signature": "luigi.batch_notifier._fail_queue(num_messages)",
        "snippet": "def _fail_queue(num_messages):\n    return lambda: collections.defaultdict(lambda: ExplQueue(num_messages))",
        "begin_line": 45,
        "end_line": 46,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016883336147222692,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.batch_notifier._plural_format#49",
        "src_path": "luigi/batch_notifier.py",
        "class_name": "luigi.batch_notifier",
        "signature": "luigi.batch_notifier._plural_format(template, number, plural='s')",
        "snippet": "def _plural_format(template, number, plural='s'):\n    if number == 0:\n        return ''\n    return template.format(number, '' if number == 1 else plural)",
        "begin_line": 49,
        "end_line": 52,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017053206002728513,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.batch_notifier.BatchNotifier.__init__#56",
        "src_path": "luigi/batch_notifier.py",
        "class_name": "luigi.batch_notifier.BatchNotifier",
        "signature": "luigi.batch_notifier.BatchNotifier.__init__(self, **kwargs)",
        "snippet": "    def __init__(self, **kwargs):\n        self._config = batch_email(**kwargs)\n        self._fail_counts = collections.defaultdict(collections.Counter)\n        self._disabled_counts = collections.defaultdict(collections.Counter)\n        self._scheduling_fail_counts = collections.defaultdict(collections.Counter)\n        self._fail_expls = collections.defaultdict(_fail_queue(self._config.error_messages))\n        self._update_next_send()\n\n        self._email_format = email().format\n        if email().receiver:\n            self._default_owner = set(filter(None, email().receiver.split(',')))\n        else:\n            self._default_owner = set()",
        "begin_line": 56,
        "end_line": 68,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.batch_notifier.BatchNotifier._update_next_send#70",
        "src_path": "luigi/batch_notifier.py",
        "class_name": "luigi.batch_notifier.BatchNotifier",
        "signature": "luigi.batch_notifier.BatchNotifier._update_next_send(self)",
        "snippet": "    def _update_next_send(self):\n        self._next_send = time.time() + 60 * self._config.email_interval",
        "begin_line": 70,
        "end_line": 71,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016883336147222692,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.batch_notifier.BatchNotifier._key#73",
        "src_path": "luigi/batch_notifier.py",
        "class_name": "luigi.batch_notifier.BatchNotifier",
        "signature": "luigi.batch_notifier.BatchNotifier._key(self, task_name, family, unbatched_args)",
        "snippet": "    def _key(self, task_name, family, unbatched_args):\n        if self._config.batch_mode == 'all':\n            return task_name\n        elif self._config.batch_mode == 'family':\n            return family\n        elif self._config.batch_mode == 'unbatched_params':\n            param_str = six.u(', ').join(six.u('{}={}').format(*kv) for kv in six.iteritems(unbatched_args))\n            return six.u('{}({})').format(family, param_str)\n        else:\n            raise ValueError('Unknown batch mode for batch notifier: {}'.format(\n                self._config.batch_mode))",
        "begin_line": 73,
        "end_line": 83,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021101498206372652,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.batch_notifier.BatchNotifier._format_expl#85",
        "src_path": "luigi/batch_notifier.py",
        "class_name": "luigi.batch_notifier.BatchNotifier",
        "signature": "luigi.batch_notifier.BatchNotifier._format_expl(self, expl)",
        "snippet": "    def _format_expl(self, expl):\n        lines = expl.rstrip().split('\\n')[-self._config.error_lines:]\n        if self._email_format == 'html':\n            return six.u('<pre>{}</pre>').format('\\n'.join(lines))\n        else:\n            return six.u('\\n{}').format(six.u('\\n').join(map(six.u('      {}').format, lines)))",
        "begin_line": 85,
        "end_line": 90,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.batch_notifier.BatchNotifier._expl_body#92",
        "src_path": "luigi/batch_notifier.py",
        "class_name": "luigi.batch_notifier.BatchNotifier",
        "signature": "luigi.batch_notifier.BatchNotifier._expl_body(self, expls)",
        "snippet": "    def _expl_body(self, expls):\n        lines = [self._format_expl(expl) for expl in expls]\n        if lines and self._email_format != 'html':\n            lines.append('')\n        return '\\n'.join(lines)",
        "begin_line": 92,
        "end_line": 96,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019508388607101054,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.batch_notifier.BatchNotifier._format_task#98",
        "src_path": "luigi/batch_notifier.py",
        "class_name": "luigi.batch_notifier.BatchNotifier",
        "signature": "luigi.batch_notifier.BatchNotifier._format_task(self, task_tuple)",
        "snippet": "    def _format_task(self, task_tuple):\n        task, failure_count, disable_count, scheduling_count = task_tuple\n        counts = [\n            _plural_format('{} failure{}', failure_count),\n            _plural_format('{} disable{}', disable_count),\n            _plural_format('{} scheduling failure{}', scheduling_count),\n        ]\n        count_str = six.u(', ').join(filter(None, counts))\n        return six.u('{} ({})').format(task, count_str)",
        "begin_line": 98,
        "end_line": 106,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017053206002728513,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.batch_notifier.BatchNotifier._format_tasks#108",
        "src_path": "luigi/batch_notifier.py",
        "class_name": "luigi.batch_notifier.BatchNotifier",
        "signature": "luigi.batch_notifier.BatchNotifier._format_tasks(self, tasks)",
        "snippet": "    def _format_tasks(self, tasks):\n        lines = map(self._format_task, sorted(tasks, key=self._expl_key))\n        if self._email_format == 'html':\n            return six.u('<li>{}').format(six.u('\\n<br>').join(lines))\n        else:\n            return six.u('- {}').format(six.u('\\n  ').join(lines))",
        "begin_line": 108,
        "end_line": 113,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00022331397945511388,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.batch_notifier.BatchNotifier._owners#115",
        "src_path": "luigi/batch_notifier.py",
        "class_name": "luigi.batch_notifier.BatchNotifier",
        "signature": "luigi.batch_notifier.BatchNotifier._owners(self, owners)",
        "snippet": "    def _owners(self, owners):\n        return self._default_owner | set(owners)",
        "begin_line": 115,
        "end_line": 116,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016937669376693767,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.batch_notifier.BatchNotifier.add_failure#118",
        "src_path": "luigi/batch_notifier.py",
        "class_name": "luigi.batch_notifier.BatchNotifier",
        "signature": "luigi.batch_notifier.BatchNotifier.add_failure(self, task_name, family, unbatched_args, expl, owners)",
        "snippet": "    def add_failure(self, task_name, family, unbatched_args, expl, owners):\n        key = self._key(task_name, family, unbatched_args)\n        for owner in self._owners(owners):\n            self._fail_counts[owner][key] += 1\n            self._fail_expls[owner][key].enqueue(expl)",
        "begin_line": 118,
        "end_line": 122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0001737921445950643,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.batch_notifier.BatchNotifier.add_disable#124",
        "src_path": "luigi/batch_notifier.py",
        "class_name": "luigi.batch_notifier.BatchNotifier",
        "signature": "luigi.batch_notifier.BatchNotifier.add_disable(self, task_name, family, unbatched_args, owners)",
        "snippet": "    def add_disable(self, task_name, family, unbatched_args, owners):\n        key = self._key(task_name, family, unbatched_args)\n        for owner in self._owners(owners):\n            self._disabled_counts[owner][key] += 1\n            self._fail_counts[owner].setdefault(key, 0)",
        "begin_line": 124,
        "end_line": 128,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002294630564479119,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.batch_notifier.BatchNotifier.add_scheduling_fail#130",
        "src_path": "luigi/batch_notifier.py",
        "class_name": "luigi.batch_notifier.BatchNotifier",
        "signature": "luigi.batch_notifier.BatchNotifier.add_scheduling_fail(self, task_name, family, unbatched_args, expl, owners)",
        "snippet": "    def add_scheduling_fail(self, task_name, family, unbatched_args, expl, owners):\n        key = self._key(task_name, family, unbatched_args)\n        for owner in self._owners(owners):\n            self._scheduling_fail_counts[owner][key] += 1\n            self._fail_expls[owner][key].enqueue(expl)\n            self._fail_counts[owner].setdefault(key, 0)",
        "begin_line": 130,
        "end_line": 135,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00022331397945511388,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.batch_notifier.BatchNotifier._task_expl_groups#137",
        "src_path": "luigi/batch_notifier.py",
        "class_name": "luigi.batch_notifier.BatchNotifier",
        "signature": "luigi.batch_notifier.BatchNotifier._task_expl_groups(self, expls)",
        "snippet": "    def _task_expl_groups(self, expls):\n        if not self._config.group_by_error_messages:\n            return [((task,), msg) for task, msg in six.iteritems(expls)]\n\n        groups = collections.defaultdict(list)\n        for task, msg in six.iteritems(expls):\n            groups[msg].append(task)\n        return [(tasks, msg) for msg, tasks in six.iteritems(groups)]",
        "begin_line": 137,
        "end_line": 144,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.batch_notifier.BatchNotifier._expls_key#146",
        "src_path": "luigi/batch_notifier.py",
        "class_name": "luigi.batch_notifier.BatchNotifier",
        "signature": "luigi.batch_notifier.BatchNotifier._expls_key(self, expls_tuple)",
        "snippet": "    def _expls_key(self, expls_tuple):\n        expls = expls_tuple[0]\n        num_failures = sum(failures + scheduling_fails for (_1, failures, _2, scheduling_fails) in expls)\n        num_disables = sum(disables for (_1, _2, disables, _3) in expls)\n        min_name = min(expls)[0]\n        return -num_failures, -num_disables, min_name",
        "begin_line": 146,
        "end_line": 151,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017053206002728513,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.batch_notifier.BatchNotifier._expl_key#153",
        "src_path": "luigi/batch_notifier.py",
        "class_name": "luigi.batch_notifier.BatchNotifier",
        "signature": "luigi.batch_notifier.BatchNotifier._expl_key(self, expl)",
        "snippet": "    def _expl_key(self, expl):\n        return self._expls_key(((expl,), None))",
        "begin_line": 153,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017053206002728513,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.batch_notifier.BatchNotifier._email_body#156",
        "src_path": "luigi/batch_notifier.py",
        "class_name": "luigi.batch_notifier.BatchNotifier",
        "signature": "luigi.batch_notifier.BatchNotifier._email_body(self, fail_counts, disable_counts, scheduling_counts, fail_expls)",
        "snippet": "    def _email_body(self, fail_counts, disable_counts, scheduling_counts, fail_expls):\n        expls = {\n            (name, fail_count, disable_counts[name], scheduling_counts[name]): self._expl_body(fail_expls[name])\n            for name, fail_count in six.iteritems(fail_counts)\n        }\n        expl_groups = sorted(self._task_expl_groups(expls), key=self._expls_key)\n        body_lines = []\n        for tasks, msg in expl_groups:\n            body_lines.append(self._format_tasks(tasks))\n            body_lines.append(msg)\n        body = six.u('\\n').join(filter(None, body_lines)).rstrip()\n        if self._email_format == 'html':\n            return six.u('<ul>\\n{}\\n</ul>').format(body)\n        else:\n            return body",
        "begin_line": 156,
        "end_line": 170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00022331397945511388,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.batch_notifier.BatchNotifier._send_email#172",
        "src_path": "luigi/batch_notifier.py",
        "class_name": "luigi.batch_notifier.BatchNotifier",
        "signature": "luigi.batch_notifier.BatchNotifier._send_email(self, fail_counts, disable_counts, scheduling_counts, fail_expls, owner)",
        "snippet": "    def _send_email(self, fail_counts, disable_counts, scheduling_counts, fail_expls, owner):\n        num_failures = sum(six.itervalues(fail_counts))\n        num_disables = sum(six.itervalues(disable_counts))\n        num_scheduling_failures = sum(six.itervalues(scheduling_counts))\n        subject_parts = [\n            _plural_format('{} failure{}', num_failures),\n            _plural_format('{} disable{}', num_disables),\n            _plural_format('{} scheduling failure{}', num_scheduling_failures),\n        ]\n        subject_base = ', '.join(filter(None, subject_parts))\n        if subject_base:\n            prefix = '' if owner in self._default_owner else 'Your tasks have '\n            subject = 'Luigi: {}{} in the last {} minutes'.format(\n                prefix, subject_base, self._config.email_interval)\n            email_body = self._email_body(fail_counts, disable_counts, scheduling_counts, fail_expls)\n            send_email(subject, email_body, email().sender, (owner,))",
        "begin_line": 172,
        "end_line": 187,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017053206002728513,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.batch_notifier.BatchNotifier.send_email#189",
        "src_path": "luigi/batch_notifier.py",
        "class_name": "luigi.batch_notifier.BatchNotifier",
        "signature": "luigi.batch_notifier.BatchNotifier.send_email(self)",
        "snippet": "    def send_email(self):\n        try:\n            for owner, failures in six.iteritems(self._fail_counts):\n                self._send_email(\n                    fail_counts=failures,\n                    disable_counts=self._disabled_counts[owner],\n                    scheduling_counts=self._scheduling_fail_counts[owner],\n                    fail_expls=self._fail_expls[owner],\n                    owner=owner,\n                )\n        finally:\n            self._update_next_send()\n            self._fail_counts.clear()\n            self._disabled_counts.clear()\n            self._scheduling_fail_counts.clear()\n            self._fail_expls.clear()",
        "begin_line": 189,
        "end_line": 204,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017053206002728513,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.batch_notifier.BatchNotifier.update#206",
        "src_path": "luigi/batch_notifier.py",
        "class_name": "luigi.batch_notifier.BatchNotifier",
        "signature": "luigi.batch_notifier.BatchNotifier.update(self)",
        "snippet": "    def update(self):\n        if time.time() >= self._next_send:\n            self.send_email()",
        "begin_line": 206,
        "end_line": 208,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.azureblob.AzureBlobClient.connection#69",
        "src_path": "luigi/contrib/azureblob.py",
        "class_name": "luigi.contrib.azureblob.AzureBlobClient",
        "signature": "luigi.contrib.azureblob.AzureBlobClient.connection(self)",
        "snippet": "    def connection(self):\n        return blockblobservice.BlockBlobService(account_name=self.options.get(\"account_name\"),\n                                                 account_key=self.options.get(\"account_key\"),\n                                                 sas_token=self.options.get(\"sas_token\"),\n                                                 protocol=self.kwargs.get(\"protocol\"),\n                                                 connection_string=self.kwargs.get(\"connection_string\"),\n                                                 endpoint_suffix=self.kwargs.get(\"endpoint_suffix\"),\n                                                 custom_domain=self.kwargs.get(\"custom_domain\"),\n                                                 is_emulated=self.kwargs.get(\"is_emulated\") or False)",
        "begin_line": 69,
        "end_line": 77,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.0010799136069114472,
            "pseudo_tarantula_susp": 0.007407407407407408,
            "pseudo_op2_susp": 0.0010799136069114472,
            "pseudo_barinel_susp": 0.007407407407407408
        }
    },
    {
        "name": "luigi.contrib.azureblob.AzureBlobClient.create_container#102",
        "src_path": "luigi/contrib/azureblob.py",
        "class_name": "luigi.contrib.azureblob.AzureBlobClient",
        "signature": "luigi.contrib.azureblob.AzureBlobClient.create_container(self, container_name)",
        "snippet": "    def create_container(self, container_name):\n        return self.connection.create_container(container_name)",
        "begin_line": 102,
        "end_line": 103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008,
            "pseudo_dstar_susp": 0.0006211180124223603,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.0006211180124223603,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.contrib.azureblob.AzureBlobClient.exists#109",
        "src_path": "luigi/contrib/azureblob.py",
        "class_name": "luigi.contrib.azureblob.AzureBlobClient",
        "signature": "luigi.contrib.azureblob.AzureBlobClient.exists(self, path)",
        "snippet": "    def exists(self, path):\n        container, blob = self.splitfilepath(path)\n        return self.connection.exists(container, blob)",
        "begin_line": 109,
        "end_line": 111,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0035971223021582736,
            "pseudo_dstar_susp": 0.0006071645415907711,
            "pseudo_tarantula_susp": 0.006756756756756757,
            "pseudo_op2_susp": 0.0006071645415907711,
            "pseudo_barinel_susp": 0.006756756756756757
        }
    },
    {
        "name": "luigi.contrib.azureblob.AzureBlobClient.splitfilepath#166",
        "src_path": "luigi/contrib/azureblob.py",
        "class_name": "luigi.contrib.azureblob.AzureBlobClient",
        "signature": "luigi.contrib.azureblob.AzureBlobClient.splitfilepath(filepath)",
        "snippet": "    def splitfilepath(filepath):\n        splitpath = filepath.split(\"/\")\n        container = splitpath[0]\n        blobsplit = splitpath[1:]\n        blob = None if not blobsplit else \"/\".join(blobsplit)\n        return container, blob",
        "begin_line": 166,
        "end_line": 171,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002079002079002079,
            "pseudo_dstar_susp": 0.0005861664712778429,
            "pseudo_tarantula_susp": 0.002770083102493075,
            "pseudo_op2_susp": 0.0005861664712778429,
            "pseudo_barinel_susp": 0.002770083102493075
        }
    },
    {
        "name": "luigi.contrib.azureblob.AzureBlobTarget.__init__#239",
        "src_path": "luigi/contrib/azureblob.py",
        "class_name": "luigi.contrib.azureblob.AzureBlobTarget",
        "signature": "luigi.contrib.azureblob.AzureBlobTarget.__init__(self, container, blob, client=None, format=None, download_when_reading=True, **kwargs)",
        "snippet": "    def __init__(self, container, blob, client=None, format=None, download_when_reading=True, **kwargs):\n        \"\"\"\n        :param str account_name:\n            The storage account name. This is used to authenticate requests signed with an account key and to construct\n            the storage endpoint. It is required unless a connection string is given, or if a custom domain is\n            used with anonymous authentication.\n        :param str container:\n            The azure container in which the blob needs to be stored\n        :param str blob:\n            The name of the blob under container specified\n        :param str client:\n            An instance of :class:`.AzureBlobClient`. If none is specified, anonymous access would be used\n        :param str format:\n            An instance of :class:`luigi.format`.\n        :param bool download_when_reading:\n            Determines whether the file has to be downloaded to temporary location on disk. Defaults to `True`.\n\n        Pass the argument **progress_callback** with signature *(func(current, total))* to get real time progress of upload\n        \"\"\"\n        super(AzureBlobTarget, self).__init__(os.path.join(container, blob))\n        if format is None:\n            format = get_default_format()\n        self.container = container\n        self.blob = blob\n        self.client = client or AzureBlobClient()\n        self.format = format\n        self.download_when_reading = download_when_reading\n        self.azure_blob_options = kwargs",
        "begin_line": 239,
        "end_line": 266,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.azureblob.AzureBlobTarget.fs#269",
        "src_path": "luigi/contrib/azureblob.py",
        "class_name": "luigi.contrib.azureblob.AzureBlobTarget",
        "signature": "luigi.contrib.azureblob.AzureBlobTarget.fs(self)",
        "snippet": "    def fs(self):\n        \"\"\"\n        The :py:class:`FileSystem` associated with :class:`.AzureBlobTarget`\n        \"\"\"\n        return self.client",
        "begin_line": 269,
        "end_line": 273,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.util.common_params#234",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util",
        "signature": "luigi.util.common_params(task_instance, task_cls)",
        "snippet": "def common_params(task_instance, task_cls):\n    \"\"\"\n    Grab all the values in task_instance that are found in task_cls.\n    \"\"\"\n    if not isinstance(task_cls, task.Register):\n        raise TypeError(\"task_cls must be an uninstantiated Task\")\n\n    task_instance_param_names = dict(task_instance.get_params()).keys()\n    task_cls_params_dict = dict(task_cls.get_params())\n    task_cls_param_names = task_cls_params_dict.keys()\n    common_param_names = set(task_instance_param_names).intersection(set(task_cls_param_names))\n    common_param_vals = [(key, task_cls_params_dict[key]) for key in common_param_names]\n    common_kwargs = dict((key, task_instance.param_kwargs[key]) for key in common_param_names)\n    vals = dict(task_instance.get_param_values(common_param_vals, [], common_kwargs))\n    return vals",
        "begin_line": 234,
        "end_line": 248,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.util.inherits.__init__#286",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util.inherits",
        "signature": "luigi.util.inherits.__init__(self, *tasks_to_inherit)",
        "snippet": "    def __init__(self, *tasks_to_inherit):\n        super(inherits, self).__init__()\n        if not tasks_to_inherit:\n            raise TypeError(\"tasks_to_inherit cannot be empty\")\n\n        self.tasks_to_inherit = tasks_to_inherit",
        "begin_line": 286,
        "end_line": 291,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.util.inherits.__call__#293",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util.inherits",
        "signature": "luigi.util.inherits.__call__(self, task_that_inherits)",
        "snippet": "    def __call__(self, task_that_inherits):\n        # Get all parameter objects from each of the underlying tasks\n        for task_to_inherit in self.tasks_to_inherit:\n            for param_name, param_obj in task_to_inherit.get_params():\n                # Check if the parameter exists in the inheriting task\n                if not hasattr(task_that_inherits, param_name):\n                    # If not, add it to the inheriting task\n                    setattr(task_that_inherits, param_name, param_obj)\n\n        # Modify task_that_inherits by adding methods\n        def clone_parent(_self, **kwargs):\n            return _self.clone(cls=self.tasks_to_inherit[0], **kwargs)\n        task_that_inherits.clone_parent = clone_parent\n\n        def clone_parents(_self, **kwargs):\n            return [\n                _self.clone(cls=task_to_inherit, **kwargs)\n                for task_to_inherit in self.tasks_to_inherit\n            ]\n        task_that_inherits.clone_parents = clone_parents\n\n        return task_that_inherits",
        "begin_line": 293,
        "end_line": 314,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.util.inherits.clone_parent#303",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util.inherits",
        "signature": "luigi.util.inherits.clone_parent(_self, **kwargs)",
        "snippet": "        def clone_parent(_self, **kwargs):\n            return _self.clone(cls=self.tasks_to_inherit[0], **kwargs)",
        "begin_line": 303,
        "end_line": 304,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019327406262079628,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.util.inherits.clone_parents#307",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util.inherits",
        "signature": "luigi.util.inherits.clone_parents(_self, **kwargs)",
        "snippet": "        def clone_parents(_self, **kwargs):\n            return [\n                _self.clone(cls=task_to_inherit, **kwargs)\n                for task_to_inherit in self.tasks_to_inherit\n            ]",
        "begin_line": 307,
        "end_line": 311,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.util.requires.__init__#325",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util.requires",
        "signature": "luigi.util.requires.__init__(self, *tasks_to_require)",
        "snippet": "    def __init__(self, *tasks_to_require):\n        super(requires, self).__init__()\n        if not tasks_to_require:\n            raise TypeError(\"tasks_to_require cannot be empty\")\n\n        self.tasks_to_require = tasks_to_require",
        "begin_line": 325,
        "end_line": 330,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.util.requires.__call__#332",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util.requires",
        "signature": "luigi.util.requires.__call__(self, task_that_requires)",
        "snippet": "    def __call__(self, task_that_requires):\n        task_that_requires = inherits(*self.tasks_to_require)(task_that_requires)\n\n        # Modify task_that_requires by adding requires method.\n        # If only one task is required, this single task is returned.\n        # Otherwise, list of tasks is returned\n        def requires(_self):\n            return _self.clone_parent() if len(self.tasks_to_require) == 1 else _self.clone_parents()\n        task_that_requires.requires = requires\n\n        return task_that_requires",
        "begin_line": 332,
        "end_line": 342,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002294630564479119,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.util.requires.requires#338",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util.requires",
        "signature": "luigi.util.requires.requires(_self)",
        "snippet": "        def requires(_self):\n            return _self.clone_parent() if len(self.tasks_to_require) == 1 else _self.clone_parents()",
        "begin_line": 338,
        "end_line": 339,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.util.Wrapped.run#370",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util.Wrapped",
        "signature": "luigi.util.Wrapped.run(_self)",
        "snippet": "            def run(_self):\n                i, o = _self.input(), _self.output()\n                f = o.open('w')  # TODO: assert that i, o are Target objects and not complex datastructures\n                for line in i.open('r'):\n                    f.write(line)\n                f.close()",
        "begin_line": 370,
        "end_line": 375,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.util.delegates#380",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util",
        "signature": "luigi.util.delegates(task_that_delegates)",
        "snippet": "def delegates(task_that_delegates):\n    \"\"\" Lets a task call methods on subtask(s).\n\n    The way this works is that the subtask is run as a part of the task, but\n    the task itself doesn't have to care about the requirements of the subtasks.\n    The subtask doesn't exist from the scheduler's point of view, and\n    its dependencies are instead required by the main task.\n\n    Example:\n\n    .. code-block:: python\n\n        class PowersOfN(luigi.Task):\n            n = luigi.IntParameter()\n            def f(self, x): return x ** self.n\n\n        @delegates\n        class T(luigi.Task):\n            def subtasks(self): return PowersOfN(5)\n            def run(self): print self.subtasks().f(42)\n    \"\"\"\n    if not hasattr(task_that_delegates, 'subtasks'):\n        # This method can (optionally) define a couple of delegate tasks that\n        # will be accessible as interfaces, meaning that the task can access\n        # those tasks and run methods defined on them, etc\n        raise AttributeError('%s needs to implement the method \"subtasks\"' % task_that_delegates)\n\n    @task._task_wraps(task_that_delegates)\n    class Wrapped(task_that_delegates):\n\n        def deps(self):\n            # Overrides method in base class\n            return task.flatten(self.requires()) + task.flatten([t.deps() for t in task.flatten(self.subtasks())])\n\n        def run(self):\n            for t in task.flatten(self.subtasks()):\n                t.run()\n            task_that_delegates.run(self)\n\n    return Wrapped",
        "begin_line": 380,
        "end_line": 419,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.util.Wrapped.deps#410",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util.Wrapped",
        "signature": "luigi.util.Wrapped.deps(self)",
        "snippet": "        def deps(self):\n            # Overrides method in base class\n            return task.flatten(self.requires()) + task.flatten([t.deps() for t in task.flatten(self.subtasks())])",
        "begin_line": 410,
        "end_line": 412,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.util.Wrapped.run#414",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util.Wrapped",
        "signature": "luigi.util.Wrapped.run(self)",
        "snippet": "        def run(self):\n            for t in task.flatten(self.subtasks()):\n                t.run()\n            task_that_delegates.run(self)",
        "begin_line": 414,
        "end_line": 417,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.util.previous#422",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util",
        "signature": "luigi.util.previous(task)",
        "snippet": "def previous(task):\n    \"\"\"\n    Return a previous Task of the same family.\n\n    By default checks if this task family only has one non-global parameter and if\n    it is a DateParameter, DateHourParameter or DateIntervalParameter in which case\n    it returns with the time decremented by 1 (hour, day or interval)\n    \"\"\"\n    params = task.get_params()\n    previous_params = {}\n    previous_date_params = {}\n\n    for param_name, param_obj in params:\n        param_value = getattr(task, param_name)\n\n        if isinstance(param_obj, parameter.DateParameter):\n            previous_date_params[param_name] = param_value - datetime.timedelta(days=1)\n        elif isinstance(param_obj, parameter.DateSecondParameter):\n            previous_date_params[param_name] = param_value - datetime.timedelta(seconds=1)\n        elif isinstance(param_obj, parameter.DateMinuteParameter):\n            previous_date_params[param_name] = param_value - datetime.timedelta(minutes=1)\n        elif isinstance(param_obj, parameter.DateHourParameter):\n            previous_date_params[param_name] = param_value - datetime.timedelta(hours=1)\n        elif isinstance(param_obj, parameter.DateIntervalParameter):\n            previous_date_params[param_name] = param_value.prev()\n        else:\n            previous_params[param_name] = param_value\n\n    previous_params.update(previous_date_params)\n\n    if len(previous_date_params) == 0:\n        raise NotImplementedError(\"No task parameter - can't determine previous task\")\n    elif len(previous_date_params) > 1:\n        raise NotImplementedError(\"Too many date-related task parameters - can't determine previous task\")\n    else:\n        return task.clone(**previous_params)",
        "begin_line": 422,
        "end_line": 457,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.util.get_previous_completed#460",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util",
        "signature": "luigi.util.get_previous_completed(task, max_steps=10)",
        "snippet": "def get_previous_completed(task, max_steps=10):\n    prev = task\n    for _ in xrange(max_steps):\n        prev = previous(prev)\n        logger.debug(\"Checking if %s is complete\", prev)\n        if prev.complete():\n            return prev\n    return None",
        "begin_line": 460,
        "end_line": 467,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalProgramTask.program_args#64",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalProgramTask",
        "signature": "luigi.contrib.external_program.ExternalProgramTask.program_args(self)",
        "snippet": "    def program_args(self):\n        \"\"\"\n        Override this method to map your task parameters to the program arguments\n\n        :return: list to pass as ``args`` to :py:class:`subprocess.Popen`\n        \"\"\"\n        raise NotImplementedError",
        "begin_line": 64,
        "end_line": 70,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalProgramTask.program_environment#72",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalProgramTask",
        "signature": "luigi.contrib.external_program.ExternalProgramTask.program_environment(self)",
        "snippet": "    def program_environment(self):\n        \"\"\"\n        Override this method to control environment variables for the program\n\n        :return: dict mapping environment variable names to values\n        \"\"\"\n        env = os.environ.copy()\n        return env",
        "begin_line": 72,
        "end_line": 79,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019747235387045813,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalProgramTask.always_log_stderr#82",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalProgramTask",
        "signature": "luigi.contrib.external_program.ExternalProgramTask.always_log_stderr(self)",
        "snippet": "    def always_log_stderr(self):\n        \"\"\"\n        When True, stderr will be logged even if program execution succeeded\n\n        Override to False to log stderr only when program execution fails.\n        \"\"\"\n        return True",
        "begin_line": 82,
        "end_line": 88,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalProgramTask._clean_output_file#90",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalProgramTask",
        "signature": "luigi.contrib.external_program.ExternalProgramTask._clean_output_file(self, file_object)",
        "snippet": "    def _clean_output_file(self, file_object):\n        file_object.seek(0)\n        return ''.join(map(lambda s: s.decode('utf-8'), file_object.readlines()))",
        "begin_line": 90,
        "end_line": 92,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0001839926402943882,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalProgramTask.run#94",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalProgramTask",
        "signature": "luigi.contrib.external_program.ExternalProgramTask.run(self)",
        "snippet": "    def run(self):\n        args = list(map(str, self.program_args()))\n\n        logger.info('Running command: %s', ' '.join(args))\n        env = self.program_environment()\n        kwargs = {'env': env}\n        if self.capture_output:\n            tmp_stdout, tmp_stderr = tempfile.TemporaryFile(), tempfile.TemporaryFile()\n            kwargs.update({'stdout': tmp_stdout, 'stderr': tmp_stderr})\n        proc = subprocess.Popen(\n            args,\n            **kwargs\n        )\n\n        try:\n            with ExternalProgramRunContext(proc):\n                proc.wait()\n            success = proc.returncode == 0\n\n            if self.capture_output:\n                stdout = self._clean_output_file(tmp_stdout)\n                stderr = self._clean_output_file(tmp_stderr)\n\n                if stdout:\n                    logger.info('Program stdout:\\n{}'.format(stdout))\n                if stderr:\n                    if self.always_log_stderr or not success:\n                        logger.info('Program stderr:\\n{}'.format(stderr))\n            else:\n                stdout, stderr = None, None\n\n            if not success:\n                raise ExternalProgramRunError(\n                    'Program failed with return code={}:'.format(proc.returncode),\n                    args, env=env, stdout=stdout, stderr=stderr)\n        finally:\n            if self.capture_output:\n                tmp_stderr.close()\n                tmp_stdout.close()",
        "begin_line": 94,
        "end_line": 132,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalProgramRunContext.__init__#136",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalProgramRunContext",
        "signature": "luigi.contrib.external_program.ExternalProgramRunContext.__init__(self, proc)",
        "snippet": "    def __init__(self, proc):\n        self.proc = proc",
        "begin_line": 136,
        "end_line": 137,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.000181422351233672,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalProgramRunContext.__enter__#139",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalProgramRunContext",
        "signature": "luigi.contrib.external_program.ExternalProgramRunContext.__enter__(self)",
        "snippet": "    def __enter__(self):\n        self.__old_signal = signal.getsignal(signal.SIGTERM)\n        signal.signal(signal.SIGTERM, self.kill_job)\n        return self",
        "begin_line": 139,
        "end_line": 142,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.000181422351233672,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalProgramRunContext.__exit__#144",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalProgramRunContext",
        "signature": "luigi.contrib.external_program.ExternalProgramRunContext.__exit__(self, exc_type, exc_val, exc_tb)",
        "snippet": "    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is KeyboardInterrupt:\n            self.kill_job()\n        signal.signal(signal.SIGTERM, self.__old_signal)",
        "begin_line": 144,
        "end_line": 147,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalProgramRunContext.kill_job#149",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalProgramRunContext",
        "signature": "luigi.contrib.external_program.ExternalProgramRunContext.kill_job(self, captured_signal=None, stack_frame=None)",
        "snippet": "    def kill_job(self, captured_signal=None, stack_frame=None):\n        self.proc.kill()\n        if captured_signal is not None:\n            # adding 128 gives the exit code corresponding to a signal\n            sys.exit(128 + captured_signal)",
        "begin_line": 149,
        "end_line": 153,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalProgramRunError.__init__#157",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalProgramRunError",
        "signature": "luigi.contrib.external_program.ExternalProgramRunError.__init__(self, message, args, env=None, stdout=None, stderr=None)",
        "snippet": "    def __init__(self, message, args, env=None, stdout=None, stderr=None):\n        super(ExternalProgramRunError, self).__init__(message, args, env, stdout, stderr)\n        self.message = message\n        self.args = args\n        self.env = env\n        self.out = stdout\n        self.err = stderr",
        "begin_line": 157,
        "end_line": 163,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalProgramRunError.__str__#165",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalProgramRunError",
        "signature": "luigi.contrib.external_program.ExternalProgramRunError.__str__(self)",
        "snippet": "    def __str__(self):\n        info = self.message\n        info += '\\nCOMMAND: {}'.format(' '.join(self.args))\n        info += '\\nSTDOUT: {}'.format(self.out or '[empty]')\n        info += '\\nSTDERR: {}'.format(self.err or '[empty]')\n        env_string = None\n        if self.env:\n            env_string = ' '.join(['='.join([k, '\\'{}\\''.format(v)]) for k, v in self.env.items()])\n        info += '\\nENVIRONMENT: {}'.format(env_string or '[empty]')\n        # reset terminal color in case the ENVIRONMENT changes colors\n        info += '\\033[m'\n        return info",
        "begin_line": 165,
        "end_line": 176,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalPythonProgramTask.program_environment#199",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalPythonProgramTask",
        "signature": "luigi.contrib.external_program.ExternalPythonProgramTask.program_environment(self)",
        "snippet": "    def program_environment(self):\n        env = super(ExternalPythonProgramTask, self).program_environment()\n\n        if self.extra_pythonpath:\n            pythonpath = ':'.join([self.extra_pythonpath, env.get('PYTHONPATH', '')])\n            env.update({'PYTHONPATH': pythonpath})\n\n        if self.virtualenv:\n            # Make the same changes to the env that a normal venv/bin/activate script would\n            path = ':'.join(['{}/bin'.format(self.virtualenv), env.get('PATH', '')])\n            env.update({\n                'PATH': path,\n                'VIRTUAL_ENV': self.virtualenv\n            })\n            # remove PYTHONHOME env variable, if it exists\n            env.pop('PYTHONHOME', None)\n\n        return env",
        "begin_line": 199,
        "end_line": 216,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.pyspark_runner.PySparkRunner.__init__#45",
        "src_path": "luigi/contrib/pyspark_runner.py",
        "class_name": "luigi.contrib.pyspark_runner.PySparkRunner",
        "signature": "luigi.contrib.pyspark_runner.PySparkRunner.__init__(self, job, *args)",
        "snippet": "    def __init__(self, job, *args):\n        # Append job directory to PYTHON_PATH to enable dynamic import\n        # of the module in which the class resides on unpickling\n        sys.path.append(os.path.dirname(job))\n        with open(job, \"rb\") as fd:\n            self.job = pickle.load(fd)\n        self.args = args",
        "begin_line": 45,
        "end_line": 51,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01818181818181818,
            "pseudo_dstar_susp": 0.0010940919037199124,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.0010940919037199124,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.contrib.pyspark_runner.PySparkRunner.run#53",
        "src_path": "luigi/contrib/pyspark_runner.py",
        "class_name": "luigi.contrib.pyspark_runner.PySparkRunner",
        "signature": "luigi.contrib.pyspark_runner.PySparkRunner.run(self)",
        "snippet": "    def run(self):\n        from pyspark import SparkContext, SparkConf\n        conf = SparkConf()\n        self.job.setup(conf)\n        with SparkContext(conf=conf) as sc:\n            self.job.setup_remote(sc)\n            self.job.main(sc, *self.args)",
        "begin_line": 53,
        "end_line": 59,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01818181818181818,
            "pseudo_dstar_susp": 0.0010940919037199124,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.0010940919037199124,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.execution_summary._partition_tasks#35",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._partition_tasks(worker)",
        "snippet": "def _partition_tasks(worker):\n    \"\"\"\n    Takes a worker and sorts out tasks based on their status.\n    Still_pending_not_ext is only used to get upstream_failure, upstream_missing_dependency and run_by_other_worker\n    \"\"\"\n    task_history = worker._add_task_history\n    pending_tasks = {task for(task, status, ext) in task_history if status == 'PENDING'}\n    set_tasks = {}\n    set_tasks[\"completed\"] = {task for (task, status, ext) in task_history if status == 'DONE' and task in pending_tasks}\n    set_tasks[\"already_done\"] = {task for (task, status, ext) in task_history\n                                 if status == 'DONE' and task not in pending_tasks and task not in set_tasks[\"completed\"]}\n    set_tasks[\"ever_failed\"] = {task for (task, status, ext) in task_history if status == 'FAILED'}\n    set_tasks[\"failed\"] = set_tasks[\"ever_failed\"] - set_tasks[\"completed\"]\n    set_tasks[\"scheduling_error\"] = {task for(task, status, ext) in task_history if status == 'UNKNOWN'}\n    set_tasks[\"still_pending_ext\"] = {task for (task, status, ext) in task_history\n                                      if status == 'PENDING' and task not in set_tasks[\"ever_failed\"] and task not in set_tasks[\"completed\"] and not ext}\n    set_tasks[\"still_pending_not_ext\"] = {task for (task, status, ext) in task_history\n                                          if status == 'PENDING' and task not in set_tasks[\"ever_failed\"] and task not in set_tasks[\"completed\"] and ext}\n    set_tasks[\"run_by_other_worker\"] = set()\n    set_tasks[\"upstream_failure\"] = set()\n    set_tasks[\"upstream_missing_dependency\"] = set()\n    set_tasks[\"upstream_run_by_other_worker\"] = set()\n    set_tasks[\"upstream_scheduling_error\"] = set()\n    set_tasks[\"not_run\"] = set()\n    return set_tasks",
        "begin_line": 35,
        "end_line": 59,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010604453870625664,
            "pseudo_dstar_susp": 0.002421307506053269,
            "pseudo_tarantula_susp": 0.0008340283569641367,
            "pseudo_op2_susp": 0.002421307506053269,
            "pseudo_barinel_susp": 0.0008340283569641367
        }
    },
    {
        "name": "luigi.execution_summary._root_task#62",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._root_task(worker)",
        "snippet": "def _root_task(worker):\n    \"\"\"\n    Return the first task scheduled by the worker, corresponding to the root task\n    \"\"\"\n    return worker._add_task_history[0][0]",
        "begin_line": 62,
        "end_line": 66,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.execution_summary._populate_unknown_statuses#69",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._populate_unknown_statuses(set_tasks)",
        "snippet": "def _populate_unknown_statuses(set_tasks):\n    \"\"\"\n    Add the \"upstream_*\" and \"not_run\" statuses my mutating set_tasks.\n    \"\"\"\n    visited = set()\n    for task in set_tasks[\"still_pending_not_ext\"]:\n        _depth_first_search(set_tasks, task, visited)",
        "begin_line": 69,
        "end_line": 75,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006988120195667365,
            "pseudo_dstar_susp": 0.0007849293563579278,
            "pseudo_tarantula_susp": 0.0008203445447087777,
            "pseudo_op2_susp": 0.0007849293563579278,
            "pseudo_barinel_susp": 0.0008203445447087777
        }
    },
    {
        "name": "luigi.execution_summary._depth_first_search#78",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._depth_first_search(set_tasks, current_task, visited)",
        "snippet": "def _depth_first_search(set_tasks, current_task, visited):\n    \"\"\"\n    This dfs checks why tasks are still pending.\n    \"\"\"\n    visited.add(current_task)\n    if current_task in set_tasks[\"still_pending_not_ext\"]:\n        upstream_failure = False\n        upstream_missing_dependency = False\n        upstream_run_by_other_worker = False\n        upstream_scheduling_error = False\n        for task in current_task._requires():\n            if task not in visited:\n                _depth_first_search(set_tasks, task, visited)\n            if task in set_tasks[\"ever_failed\"] or task in set_tasks[\"upstream_failure\"]:\n                set_tasks[\"upstream_failure\"].add(current_task)\n                upstream_failure = True\n            if task in set_tasks[\"still_pending_ext\"] or task in set_tasks[\"upstream_missing_dependency\"]:\n                set_tasks[\"upstream_missing_dependency\"].add(current_task)\n                upstream_missing_dependency = True\n            if task in set_tasks[\"run_by_other_worker\"] or task in set_tasks[\"upstream_run_by_other_worker\"]:\n                set_tasks[\"upstream_run_by_other_worker\"].add(current_task)\n                upstream_run_by_other_worker = True\n            if task in set_tasks[\"scheduling_error\"]:\n                set_tasks[\"upstream_scheduling_error\"].add(current_task)\n                upstream_scheduling_error = True\n        if not upstream_failure and not upstream_missing_dependency and \\\n                not upstream_run_by_other_worker and not upstream_scheduling_error and \\\n                current_task not in set_tasks[\"run_by_other_worker\"]:\n            set_tasks[\"not_run\"].add(current_task)",
        "begin_line": 78,
        "end_line": 106,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.execution_summary._get_str#109",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._get_str(task_dict, extra_indent)",
        "snippet": "def _get_str(task_dict, extra_indent):\n    \"\"\"\n    This returns a string for each status\n    \"\"\"\n    summary_length = execution_summary().summary_length\n\n    lines = []\n    task_names = sorted(task_dict.keys())\n    for task_family in task_names:\n        tasks = task_dict[task_family]\n        tasks = sorted(tasks, key=lambda x: str(x))\n        prefix_size = 8 if extra_indent else 4\n        prefix = ' ' * prefix_size\n\n        line = None\n\n        if summary_length > 0 and len(lines) >= summary_length:\n            line = prefix + \"...\"\n            lines.append(line)\n            break\n        if len(tasks[0].get_params()) == 0:\n            line = prefix + '- {0} {1}()'.format(len(tasks), str(task_family))\n        elif _get_len_of_params(tasks[0]) > 60 or len(str(tasks[0])) > 200 or \\\n                (len(tasks) == 2 and len(tasks[0].get_params()) > 1 and (_get_len_of_params(tasks[0]) > 40 or len(str(tasks[0])) > 100)):\n            \"\"\"\n            This is to make sure that there is no really long task in the output\n            \"\"\"\n            line = prefix + '- {0} {1}(...)'.format(len(tasks), task_family)\n        elif len((tasks[0].get_params())) == 1:\n            attributes = {getattr(task, tasks[0].get_params()[0][0]) for task in tasks}\n            param_class = tasks[0].get_params()[0][1]\n            first, last = _ranging_attributes(attributes, param_class)\n            if first is not None and last is not None and len(attributes) > 3:\n                param_str = '{0}...{1}'.format(param_class.serialize(first), param_class.serialize(last))\n            else:\n                param_str = '{0}'.format(_get_str_one_parameter(tasks))\n            line = prefix + '- {0} {1}({2}={3})'.format(len(tasks), task_family, tasks[0].get_params()[0][0], param_str)\n        else:\n            ranging = False\n            params = _get_set_of_params(tasks)\n            unique_param_keys = list(_get_unique_param_keys(params))\n            if len(unique_param_keys) == 1:\n                unique_param, = unique_param_keys\n                attributes = params[unique_param]\n                param_class = unique_param[1]\n                first, last = _ranging_attributes(attributes, param_class)\n                if first is not None and last is not None and len(attributes) > 2:\n                    ranging = True\n                    line = prefix + '- {0} {1}({2}'.format(len(tasks), task_family, _get_str_ranging_multiple_parameters(first, last, tasks, unique_param))\n            if not ranging:\n                if len(tasks) == 1:\n                    line = prefix + '- {0} {1}'.format(len(tasks), tasks[0])\n                if len(tasks) == 2:\n                    line = prefix + '- {0} {1} and {2}'.format(len(tasks), tasks[0], tasks[1])\n                if len(tasks) > 2:\n                    line = prefix + '- {0} {1} ...'.format(len(tasks), tasks[0])\n        lines.append(line)\n    return '\\n'.join(lines)",
        "begin_line": 109,
        "end_line": 166,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001440922190201729,
            "pseudo_dstar_susp": 0.0024509803921568627,
            "pseudo_tarantula_susp": 0.0023752969121140144,
            "pseudo_op2_susp": 0.0024509803921568627,
            "pseudo_barinel_susp": 0.0023752969121140144
        }
    },
    {
        "name": "luigi.execution_summary._get_len_of_params#169",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._get_len_of_params(task)",
        "snippet": "def _get_len_of_params(task):\n    return sum(len(param[0]) for param in task.get_params())",
        "begin_line": 169,
        "end_line": 170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001314060446780552,
            "pseudo_dstar_susp": 0.0028089887640449437,
            "pseudo_tarantula_susp": 0.001201923076923077,
            "pseudo_op2_susp": 0.0028089887640449437,
            "pseudo_barinel_susp": 0.001201923076923077
        }
    },
    {
        "name": "luigi.execution_summary._get_str_ranging_multiple_parameters#173",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._get_str_ranging_multiple_parameters(first, last, tasks, unique_param)",
        "snippet": "def _get_str_ranging_multiple_parameters(first, last, tasks, unique_param):\n    row = ''\n    str_unique_param = '{0}...{1}'.format(unique_param[1].serialize(first), unique_param[1].serialize(last))\n    for param in tasks[0].get_params():\n        row += '{0}='.format(param[0])\n        if param[0] == unique_param[0]:\n            row += '{0}'.format(str_unique_param)\n        else:\n            row += '{0}'.format(param[1].serialize(getattr(tasks[0], param[0])))\n        if param != tasks[0].get_params()[-1]:\n            row += \", \"\n    row += ')'\n    return row",
        "begin_line": 173,
        "end_line": 185,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.execution_summary._get_set_of_params#188",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._get_set_of_params(tasks)",
        "snippet": "def _get_set_of_params(tasks):\n    params = {}\n    for param in tasks[0].get_params():\n        params[param] = {getattr(task, param[0]) for task in tasks}\n    return params",
        "begin_line": 188,
        "end_line": 192,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011376564277588168,
            "pseudo_dstar_susp": 0.0009233610341643582,
            "pseudo_tarantula_susp": 0.0014925373134328358,
            "pseudo_op2_susp": 0.0009233610341643582,
            "pseudo_barinel_susp": 0.0014925373134328358
        }
    },
    {
        "name": "luigi.execution_summary._get_unique_param_keys#195",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._get_unique_param_keys(params)",
        "snippet": "def _get_unique_param_keys(params):\n    for param_key, param_values in params.items():\n        if len(param_values) > 1:\n            yield param_key",
        "begin_line": 195,
        "end_line": 198,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000757002271006813,
            "pseudo_dstar_susp": 0.0005319148936170213,
            "pseudo_tarantula_susp": 0.0014925373134328358,
            "pseudo_op2_susp": 0.0005319148936170213,
            "pseudo_barinel_susp": 0.0014925373134328358
        }
    },
    {
        "name": "luigi.execution_summary._ranging_attributes#201",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._ranging_attributes(attributes, param_class)",
        "snippet": "def _ranging_attributes(attributes, param_class):\n    \"\"\"\n    Checks if there is a continuous range\n    \"\"\"\n    next_attributes = {param_class.next_in_enumeration(attribute) for attribute in attributes}\n    in_first = attributes.difference(next_attributes)\n    in_second = next_attributes.difference(attributes)\n    if len(in_first) == 1 and len(in_second) == 1:\n        for x in attributes:\n            if {param_class.next_in_enumeration(x)} == in_second:\n                return next(iter(in_first)), x\n    return None, None",
        "begin_line": 201,
        "end_line": 212,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019102196752626553,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.execution_summary._get_str_one_parameter#215",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._get_str_one_parameter(tasks)",
        "snippet": "def _get_str_one_parameter(tasks):\n    row = ''\n    count = 0\n    for task in tasks:\n        if (len(row) >= 30 and count > 2 and count != len(tasks) - 1) or len(row) > 200:\n            row += '...'\n            break\n        param = task.get_params()[0]\n        row += '{0}'.format(param[1].serialize(getattr(task, param[0])))\n        if count < len(tasks) - 1:\n            row += ','\n        count += 1\n    return row",
        "begin_line": 215,
        "end_line": 227,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.execution_summary._get_number_of_tasks_for#234",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._get_number_of_tasks_for(status, group_tasks)",
        "snippet": "def _get_number_of_tasks_for(status, group_tasks):\n    if status == \"still_pending\":\n        return (_get_number_of_tasks(group_tasks[\"still_pending_ext\"]) +\n                _get_number_of_tasks(group_tasks[\"still_pending_not_ext\"]))\n    return _get_number_of_tasks(group_tasks[status])",
        "begin_line": 234,
        "end_line": 238,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007230657989877079,
            "pseudo_dstar_susp": 0.0008136696501220504,
            "pseudo_tarantula_susp": 0.0008576329331046312,
            "pseudo_op2_susp": 0.0008136696501220504,
            "pseudo_barinel_susp": 0.0008576329331046312
        }
    },
    {
        "name": "luigi.execution_summary._get_number_of_tasks#241",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._get_number_of_tasks(task_dict)",
        "snippet": "def _get_number_of_tasks(task_dict):\n    return sum(len(tasks) for tasks in task_dict.values())",
        "begin_line": 241,
        "end_line": 242,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010649627263045794,
            "pseudo_dstar_susp": 0.0024449877750611247,
            "pseudo_tarantula_susp": 0.0008576329331046312,
            "pseudo_op2_susp": 0.0024449877750611247,
            "pseudo_barinel_susp": 0.0008576329331046312
        }
    },
    {
        "name": "luigi.execution_summary._get_comments#245",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._get_comments(group_tasks)",
        "snippet": "def _get_comments(group_tasks):\n    \"\"\"\n    Get the human readable comments and quantities for the task types.\n    \"\"\"\n    comments = {}\n    for status, human in _COMMENTS:\n        num_tasks = _get_number_of_tasks_for(status, group_tasks)\n        if num_tasks:\n            space = \"    \" if status in _PENDING_SUB_STATUSES else \"\"\n            comments[status] = '{space}* {num_tasks} {human}:\\n'.format(\n                space=space,\n                num_tasks=num_tasks,\n                human=human)\n    return comments",
        "begin_line": 245,
        "end_line": 258,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007451564828614009,
            "pseudo_dstar_susp": 0.0008389261744966443,
            "pseudo_tarantula_susp": 0.00089126559714795,
            "pseudo_op2_susp": 0.0008389261744966443,
            "pseudo_barinel_susp": 0.00089126559714795
        }
    },
    {
        "name": "luigi.execution_summary._get_run_by_other_worker#294",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._get_run_by_other_worker(worker)",
        "snippet": "def _get_run_by_other_worker(worker):\n    \"\"\"\n    This returns a set of the tasks that are being run by other worker\n    \"\"\"\n    task_sets = _get_external_workers(worker).values()\n    return functools.reduce(lambda a, b: a | b, task_sets, set())",
        "begin_line": 294,
        "end_line": 299,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006988120195667365,
            "pseudo_dstar_susp": 0.0007849293563579278,
            "pseudo_tarantula_susp": 0.0008203445447087777,
            "pseudo_op2_susp": 0.0007849293563579278,
            "pseudo_barinel_susp": 0.0008203445447087777
        }
    },
    {
        "name": "luigi.execution_summary._get_external_workers#302",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._get_external_workers(worker)",
        "snippet": "def _get_external_workers(worker):\n    \"\"\"\n    This returns a dict with a set of tasks for all of the other workers\n    \"\"\"\n    worker_that_blocked_task = collections.defaultdict(set)\n    get_work_response_history = worker._get_work_response_history\n    for get_work_response in get_work_response_history:\n        if get_work_response['task_id'] is None:\n            for running_task in get_work_response['running_tasks']:\n                other_worker_id = running_task['worker']\n                other_task_id = running_task['task_id']\n                other_task = worker._scheduled_tasks.get(other_task_id)\n                if other_worker_id == worker._id or not other_task:\n                    continue\n                worker_that_blocked_task[other_worker_id].add(other_task)\n    return worker_that_blocked_task",
        "begin_line": 302,
        "end_line": 317,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007072135785007072,
            "pseudo_dstar_susp": 0.000794912559618442,
            "pseudo_tarantula_susp": 0.0008340283569641367,
            "pseudo_op2_susp": 0.000794912559618442,
            "pseudo_barinel_susp": 0.0008340283569641367
        }
    },
    {
        "name": "luigi.execution_summary._group_tasks_by_name_and_status#320",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._group_tasks_by_name_and_status(task_dict)",
        "snippet": "def _group_tasks_by_name_and_status(task_dict):\n    \"\"\"\n    Takes a dictionary with sets of tasks grouped by their status and\n    returns a dictionary with dictionaries with an array of tasks grouped by\n    their status and task name\n    \"\"\"\n    group_status = {}\n    for task in task_dict:\n        if task.task_family not in group_status:\n            group_status[task.task_family] = []\n        group_status[task.task_family].append(task)\n    return group_status",
        "begin_line": 320,
        "end_line": 331,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007451564828614009,
            "pseudo_dstar_susp": 0.0008389261744966443,
            "pseudo_tarantula_susp": 0.00089126559714795,
            "pseudo_op2_susp": 0.0008389261744966443,
            "pseudo_barinel_susp": 0.00089126559714795
        }
    },
    {
        "name": "luigi.execution_summary._summary_dict#334",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._summary_dict(worker)",
        "snippet": "def _summary_dict(worker):\n    set_tasks = _partition_tasks(worker)\n    set_tasks[\"run_by_other_worker\"] = _get_run_by_other_worker(worker)\n    _populate_unknown_statuses(set_tasks)\n    return set_tasks",
        "begin_line": 334,
        "end_line": 338,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006988120195667365,
            "pseudo_dstar_susp": 0.0007849293563579278,
            "pseudo_tarantula_susp": 0.0008203445447087777,
            "pseudo_op2_susp": 0.0007849293563579278,
            "pseudo_barinel_susp": 0.0008203445447087777
        }
    },
    {
        "name": "luigi.execution_summary._summary_format#341",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._summary_format(set_tasks, worker)",
        "snippet": "def _summary_format(set_tasks, worker):\n    group_tasks = {}\n    for status, task_dict in set_tasks.items():\n        group_tasks[status] = _group_tasks_by_name_and_status(task_dict)\n    comments = _get_comments(group_tasks)\n    num_all_tasks = sum([len(set_tasks[\"already_done\"]),\n                         len(set_tasks[\"completed\"]), len(set_tasks[\"failed\"]),\n                         len(set_tasks[\"scheduling_error\"]),\n                         len(set_tasks[\"still_pending_ext\"]),\n                         len(set_tasks[\"still_pending_not_ext\"])])\n    str_output = ''\n    str_output += 'Scheduled {0} tasks of which:\\n'.format(num_all_tasks)\n    for status in _ORDERED_STATUSES:\n        if status not in comments:\n            continue\n        str_output += '{0}'.format(comments[status])\n        if status != 'still_pending':\n            str_output += '{0}\\n'.format(_get_str(group_tasks[status], status in _PENDING_SUB_STATUSES))\n    ext_workers = _get_external_workers(worker)\n    group_tasks_ext_workers = {}\n    for ext_worker, task_dict in ext_workers.items():\n        group_tasks_ext_workers[ext_worker] = _group_tasks_by_name_and_status(task_dict)\n    if len(ext_workers) > 0:\n        str_output += \"\\nThe other workers were:\\n\"\n        count = 0\n        for ext_worker, task_dict in ext_workers.items():\n            if count > 3 and count < len(ext_workers) - 1:\n                str_output += \"    and {0} other workers\".format(len(ext_workers) - count)\n                break\n            str_output += \"    - {0} ran {1} tasks\\n\".format(ext_worker, len(task_dict))\n            count += 1\n        str_output += '\\n'\n    if num_all_tasks == sum([len(set_tasks[\"already_done\"]),\n                             len(set_tasks[\"scheduling_error\"]),\n                             len(set_tasks[\"still_pending_ext\"]),\n                             len(set_tasks[\"still_pending_not_ext\"])]):\n        if len(ext_workers) == 0:\n            str_output += '\\n'\n        str_output += 'Did not run any tasks'\n    smiley = \"\"\n    reason = \"\"\n    if set_tasks[\"ever_failed\"]:\n        if not set_tasks[\"failed\"]:\n            smiley = \":)\"\n            reason = \"there were failed tasks but they all succeeded in a retry\"\n        else:\n            smiley = \":(\"\n            reason = \"there were failed tasks\"\n            if set_tasks[\"scheduling_error\"]:\n                reason += \" and tasks whose scheduling failed\"\n    elif set_tasks[\"scheduling_error\"]:\n        smiley = \":(\"\n        reason = \"there were tasks whose scheduling failed\"\n    elif set_tasks[\"not_run\"]:\n        smiley = \":|\"\n        reason = \"there were tasks that were not granted run permission by the scheduler\"\n    elif set_tasks[\"still_pending_ext\"]:\n        smiley = \":|\"\n        reason = \"there were missing external dependencies\"\n    else:\n        smiley = \":)\"\n        reason = \"there were no failed tasks or missing dependencies\"\n    str_output += \"\\nThis progress looks {0} because {1}\".format(smiley, reason)\n    if num_all_tasks == 0:\n        str_output = 'Did not schedule any tasks'\n    return str_output",
        "begin_line": 341,
        "end_line": 406,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009871668311944718,
            "pseudo_dstar_susp": 0.0008389261744966443,
            "pseudo_tarantula_susp": 0.0017094017094017094,
            "pseudo_op2_susp": 0.0008389261744966443,
            "pseudo_barinel_susp": 0.0017094017094017094
        }
    },
    {
        "name": "luigi.execution_summary._summary_wrap#409",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._summary_wrap(str_output)",
        "snippet": "def _summary_wrap(str_output):\n    return textwrap.dedent(\"\"\"\n    ===== Luigi Execution Summary =====\n\n    {str_output}\n\n    ===== Luigi Execution Summary =====\n    \"\"\").format(str_output=str_output)",
        "begin_line": 409,
        "end_line": 416,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007230657989877079,
            "pseudo_dstar_susp": 0.0008136696501220504,
            "pseudo_tarantula_susp": 0.0008576329331046312,
            "pseudo_op2_susp": 0.0008136696501220504,
            "pseudo_barinel_susp": 0.0008576329331046312
        }
    },
    {
        "name": "luigi.execution_summary.summary#419",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary.summary(worker)",
        "snippet": "def summary(worker):\n    \"\"\"\n    Given a worker, return a human readable summary of what the worker have\n    done.\n    \"\"\"\n    return _summary_wrap(_summary_format(_summary_dict(worker), worker))",
        "begin_line": 419,
        "end_line": 424,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007230657989877079,
            "pseudo_dstar_susp": 0.0008136696501220504,
            "pseudo_tarantula_susp": 0.0008576329331046312,
            "pseudo_op2_susp": 0.0008136696501220504,
            "pseudo_barinel_susp": 0.0008576329331046312
        }
    },
    {
        "name": "luigi.contrib.hdfs.config.load_hadoop_cmd#64",
        "src_path": "luigi/contrib/hdfs/config.py",
        "class_name": "luigi.contrib.hdfs.config",
        "signature": "luigi.contrib.hdfs.config.load_hadoop_cmd()",
        "snippet": "def load_hadoop_cmd():\n    return hadoopcli().command.split()",
        "begin_line": 64,
        "end_line": 65,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hdfs.config.get_configured_hadoop_version#68",
        "src_path": "luigi/contrib/hdfs/config.py",
        "class_name": "luigi.contrib.hdfs.config",
        "signature": "luigi.contrib.hdfs.config.get_configured_hadoop_version()",
        "snippet": "def get_configured_hadoop_version():\n    \"\"\"\n    CDH4 (hadoop 2+) has a slightly different syntax for interacting with hdfs\n    via the command line.\n\n    The default version is CDH4, but one can override\n    this setting with \"cdh3\" or \"apache1\" in the hadoop section of the config\n    in order to use the old syntax.\n    \"\"\"\n    return hadoopcli().version.lower()",
        "begin_line": 68,
        "end_line": 77,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hdfs.config.get_configured_hdfs_client#80",
        "src_path": "luigi/contrib/hdfs/config.py",
        "class_name": "luigi.contrib.hdfs.config",
        "signature": "luigi.contrib.hdfs.config.get_configured_hdfs_client()",
        "snippet": "def get_configured_hdfs_client():\n    \"\"\"\n    This is a helper that fetches the configuration value for 'client' in\n    the [hdfs] section. It will return the client that retains backwards\n    compatibility when 'client' isn't configured.\n    \"\"\"\n    config = hdfs()\n    custom = config.client\n    conf_usinf_snakebite = [\n        \"snakebite_with_hadoopcli_fallback\",\n        \"snakebite\",\n    ]\n    if six.PY3 and (custom in conf_usinf_snakebite):\n        warnings.warn(\n            \"snakebite client not compatible with python3 at the moment\"\n            \"falling back on hadoopcli\",\n            stacklevel=2\n        )\n        return \"hadoopcli\"\n    return custom",
        "begin_line": 80,
        "end_line": 99,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.s3.S3Client.__init__#104",
        "src_path": "luigi/contrib/s3.py",
        "class_name": "luigi.contrib.s3.S3Client",
        "signature": "luigi.contrib.s3.S3Client.__init__(self, aws_access_key_id=None, aws_secret_access_key=None, **kwargs)",
        "snippet": "    def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,\n                 **kwargs):\n        options = self._get_s3_config()\n        options.update(kwargs)\n        if aws_access_key_id:\n            options['aws_access_key_id'] = aws_access_key_id\n        if aws_secret_access_key:\n            options['aws_secret_access_key'] = aws_secret_access_key\n\n        self._options = options",
        "begin_line": 104,
        "end_line": 113,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.14285714285714285,
            "pseudo_dstar_susp": 0.047619047619047616,
            "pseudo_tarantula_susp": 0.008620689655172414,
            "pseudo_op2_susp": 0.043478260869565216,
            "pseudo_barinel_susp": 0.008620689655172414
        }
    },
    {
        "name": "luigi.contrib.s3.S3Client.s3#116",
        "src_path": "luigi/contrib/s3.py",
        "class_name": "luigi.contrib.s3.S3Client",
        "signature": "luigi.contrib.s3.S3Client.s3(self)",
        "snippet": "    def s3(self):\n        # only import boto3 when needed to allow top-lvl s3 module import\n        import boto3\n\n        options = dict(self._options)\n\n        if self._s3:\n            return self._s3\n\n        aws_access_key_id = options.get('aws_access_key_id')\n        aws_secret_access_key = options.get('aws_secret_access_key')\n\n        # Removing key args would break backwards compability\n        role_arn = options.get('aws_role_arn')\n        role_session_name = options.get('aws_role_session_name')\n\n        aws_session_token = None\n\n        if role_arn and role_session_name:\n            sts_client = boto3.client('sts')\n            assumed_role = sts_client.assume_role(RoleArn=role_arn,\n                                                  RoleSessionName=role_session_name)\n            aws_secret_access_key = assumed_role['Credentials'].get(\n                'SecretAccessKey')\n            aws_access_key_id = assumed_role['Credentials'].get('AccessKeyId')\n            aws_session_token = assumed_role['Credentials'].get('SessionToken')\n            logger.debug('using aws credentials via assumed role {} as defined in luigi config'\n                         .format(role_session_name))\n\n        for key in ['aws_access_key_id', 'aws_secret_access_key',\n                    'aws_role_session_name', 'aws_role_arn']:\n            if key in options:\n                options.pop(key)\n\n        # At this stage, if no credentials provided, boto3 would handle their resolution for us\n        # For finding out about the order in which it tries to find these credentials\n        # please see here details\n        # http://boto3.readthedocs.io/en/latest/guide/configuration.html#configuring-credentials\n\n        if not (aws_access_key_id and aws_secret_access_key):\n            logger.debug('no credentials provided, delegating credentials resolution to boto3')\n\n        try:\n            self._s3 = boto3.resource('s3',\n                                      aws_access_key_id=aws_access_key_id,\n                                      aws_secret_access_key=aws_secret_access_key,\n                                      aws_session_token=aws_session_token,\n                                      **options)\n        except TypeError as e:\n            logger.error(e.args[0])\n            if 'got an unexpected keyword argument' in e.args[0]:\n                raise DeprecatedBotoClientException(\n                    \"Now using boto3. Check that you're passing the correct arguments\")\n            raise\n\n        return self._s3",
        "begin_line": 116,
        "end_line": 171,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.0010799136069114472,
            "pseudo_tarantula_susp": 0.007407407407407408,
            "pseudo_op2_susp": 0.0010799136069114472,
            "pseudo_barinel_susp": 0.007407407407407408
        }
    },
    {
        "name": "luigi.contrib.s3.S3Client.put#256",
        "src_path": "luigi/contrib/s3.py",
        "class_name": "luigi.contrib.s3.S3Client",
        "signature": "luigi.contrib.s3.S3Client.put(self, local_path, destination_s3_path, **kwargs)",
        "snippet": "    def put(self, local_path, destination_s3_path, **kwargs):\n        \"\"\"\n        Put an object stored locally to an S3 path.\n        :param local_path: Path to source local file\n        :param destination_s3_path: URL for target S3 location\n        :param kwargs: Keyword arguments are passed to the boto function `put_object`\n        \"\"\"\n        self._check_deprecated_argument(**kwargs)\n\n        # put the file\n        self.put_multipart(local_path, destination_s3_path, **kwargs)",
        "begin_line": 256,
        "end_line": 266,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.s3.S3Client.put_string#268",
        "src_path": "luigi/contrib/s3.py",
        "class_name": "luigi.contrib.s3.S3Client",
        "signature": "luigi.contrib.s3.S3Client.put_string(self, content, destination_s3_path, **kwargs)",
        "snippet": "    def put_string(self, content, destination_s3_path, **kwargs):\n        \"\"\"\n        Put a string to an S3 path.\n        :param content: Data str\n        :param destination_s3_path: URL for target S3 location\n        :param kwargs: Keyword arguments are passed to the boto3 function `put_object`\n        \"\"\"\n        self._check_deprecated_argument(**kwargs)\n        (bucket, key) = self._path_to_bucket_and_key(destination_s3_path)\n\n        # put the file\n        self.s3.meta.client.put_object(\n            Key=key, Bucket=bucket, Body=content, **kwargs)",
        "begin_line": 268,
        "end_line": 280,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.s3.S3Client.put_multipart#282",
        "src_path": "luigi/contrib/s3.py",
        "class_name": "luigi.contrib.s3.S3Client",
        "signature": "luigi.contrib.s3.S3Client.put_multipart(self, local_path, destination_s3_path, part_size=DEFAULT_PART_SIZE, **kwargs)",
        "snippet": "    def put_multipart(self, local_path, destination_s3_path, part_size=DEFAULT_PART_SIZE, **kwargs):\n        \"\"\"\n        Put an object stored locally to an S3 path\n        using S3 multi-part upload (for files > 8Mb).\n        :param local_path: Path to source local file\n        :param destination_s3_path: URL for target S3 location\n        :param part_size: Part size in bytes. Default: 8388608 (8MB)\n        :param kwargs: Keyword arguments are passed to the boto function `upload_fileobj` as ExtraArgs\n        \"\"\"\n        self._check_deprecated_argument(**kwargs)\n\n        from boto3.s3.transfer import TransferConfig\n        # default part size for boto3 is 8Mb, changing it to fit part_size\n        # provided as a parameter\n        transfer_config = TransferConfig(multipart_chunksize=part_size)\n\n        (bucket, key) = self._path_to_bucket_and_key(destination_s3_path)\n\n        self.s3.meta.client.upload_fileobj(\n            Fileobj=open(local_path, 'rb'), Bucket=bucket, Key=key, Config=transfer_config, ExtraArgs=kwargs)",
        "begin_line": 282,
        "end_line": 301,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.s3.S3Client._get_s3_config#506",
        "src_path": "luigi/contrib/s3.py",
        "class_name": "luigi.contrib.s3.S3Client",
        "signature": "luigi.contrib.s3.S3Client._get_s3_config(key=None)",
        "snippet": "    def _get_s3_config(key=None):\n        defaults = dict(configuration.get_config().defaults())\n        try:\n            config = dict(configuration.get_config().items('s3'))\n        except (NoSectionError, KeyError):\n            return {}\n        # So what ports etc can be read without us having to specify all dtypes\n        for k, v in six.iteritems(config):\n            try:\n                config[k] = int(v)\n            except ValueError:\n                pass\n        if key:\n            return config.get(key)\n        section_only = {k: v for k, v in config.items() if k not in defaults or v != defaults[k]}\n\n        return section_only",
        "begin_line": 506,
        "end_line": 522,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 1.0,
            "pseudo_dstar_susp": 0.06666666666666667,
            "pseudo_tarantula_susp": 0.00847457627118644,
            "pseudo_op2_susp": 0.058823529411764705,
            "pseudo_barinel_susp": 0.00847457627118644
        }
    },
    {
        "name": "luigi.contrib.s3.S3Client._path_to_bucket_and_key#525",
        "src_path": "luigi/contrib/s3.py",
        "class_name": "luigi.contrib.s3.S3Client",
        "signature": "luigi.contrib.s3.S3Client._path_to_bucket_and_key(path)",
        "snippet": "    def _path_to_bucket_and_key(path):\n        (scheme, netloc, path, query, fragment) = urlsplit(path,\n                                                           allow_fragments=False)\n        question_mark_plus_query = '?' + query if query else ''\n        path_without_initial_slash = path[1:] + question_mark_plus_query\n        return netloc, path_without_initial_slash",
        "begin_line": 525,
        "end_line": 530,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.s3.S3Client._check_deprecated_argument#541",
        "src_path": "luigi/contrib/s3.py",
        "class_name": "luigi.contrib.s3.S3Client",
        "signature": "luigi.contrib.s3.S3Client._check_deprecated_argument(**kwargs)",
        "snippet": "    def _check_deprecated_argument(**kwargs):\n        \"\"\"\n        If `encrypt_key` or `host` is part of the arguments raise an exception\n        :return: None\n        \"\"\"\n        if 'encrypt_key' in kwargs:\n            raise DeprecatedBotoClientException(\n                'encrypt_key deprecated in boto3. Please refer to boto3 documentation for encryption details.')\n        if 'host' in kwargs:\n            raise DeprecatedBotoClientException(\n                'host keyword deprecated and is replaced by region_name in boto3.\\n'\n                'example: region_name=us-west-1\\n'\n                'For region names, refer to the amazon S3 region documentation\\n'\n                'https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region')",
        "begin_line": 541,
        "end_line": 554,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.cmdline.luigi_run#8",
        "src_path": "luigi/cmdline.py",
        "class_name": "luigi.cmdline",
        "signature": "luigi.cmdline.luigi_run(argv=sys.argv[1:])",
        "snippet": "def luigi_run(argv=sys.argv[1:]):\n    run_with_retcodes(argv)",
        "begin_line": 8,
        "end_line": 9,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019327406262079628,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.cmdline.luigid#12",
        "src_path": "luigi/cmdline.py",
        "class_name": "luigi.cmdline",
        "signature": "luigi.cmdline.luigid(argv=sys.argv[1:])",
        "snippet": "def luigid(argv=sys.argv[1:]):\n    import luigi.server\n    import luigi.process\n    import luigi.configuration\n    parser = argparse.ArgumentParser(description=u'Central luigi server')\n    parser.add_argument(u'--background', help=u'Run in background mode', action='store_true')\n    parser.add_argument(u'--pidfile', help=u'Write pidfile')\n    parser.add_argument(u'--logdir', help=u'log directory')\n    parser.add_argument(u'--state-path', help=u'Pickled state file')\n    parser.add_argument(u'--address', help=u'Listening interface')\n    parser.add_argument(u'--unix-socket', help=u'Unix socket path')\n    parser.add_argument(u'--port', default=8082, help=u'Listening port')\n\n    opts = parser.parse_args(argv)\n\n    if opts.state_path:\n        config = luigi.configuration.get_config()\n        config.set('scheduler', 'state_path', opts.state_path)\n\n    DaemonLogging.setup(opts)\n    if opts.background:\n        luigi.process.daemonize(luigi.server.run, api_port=opts.port,\n                                address=opts.address, pidfile=opts.pidfile,\n                                logdir=opts.logdir, unix_socket=opts.unix_socket)\n    else:\n        luigi.server.run(api_port=opts.port, address=opts.address, unix_socket=opts.unix_socket)",
        "begin_line": 12,
        "end_line": 37,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0035971223021582736,
            "pseudo_dstar_susp": 0.0006071645415907711,
            "pseudo_tarantula_susp": 0.006756756756756757,
            "pseudo_op2_susp": 0.0006071645415907711,
            "pseudo_barinel_susp": 0.006756756756756757
        }
    },
    {
        "name": "luigi.setup_logging.BaseLogging._section#40",
        "src_path": "luigi/setup_logging.py",
        "class_name": "luigi.setup_logging.BaseLogging",
        "signature": "luigi.setup_logging.BaseLogging._section(cls, opts)",
        "snippet": "    def _section(cls, opts):\n        \"\"\"Get logging settings from config file section \"logging\".\"\"\"\n        if isinstance(cls.config, LuigiConfigParser):\n            return False\n        try:\n            logging_config = cls.config['logging']\n        except (TypeError, KeyError, NoSectionError):\n            return False\n        logging.config.dictConfig(logging_config)\n        return True",
        "begin_line": 40,
        "end_line": 49,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017921146953405018,
            "pseudo_dstar_susp": 0.0005827505827505828,
            "pseudo_tarantula_susp": 0.0026954177897574125,
            "pseudo_op2_susp": 0.0005827505827505828,
            "pseudo_barinel_susp": 0.0026954177897574125
        }
    },
    {
        "name": "luigi.setup_logging.BaseLogging.setup#52",
        "src_path": "luigi/setup_logging.py",
        "class_name": "luigi.setup_logging.BaseLogging",
        "signature": "luigi.setup_logging.BaseLogging.setup(cls, opts=type('opts', (), {'background': None, 'logdir': None, 'logging_conf_file': None, 'log_level': 'DEBUG'}))",
        "snippet": "    def setup(cls,\n              opts=type('opts', (), {\n                  'background': None,\n                  'logdir': None,\n                  'logging_conf_file': None,\n                  'log_level': 'DEBUG'\n              })):\n        \"\"\"Setup logging via CLI params and config.\"\"\"\n        logger = logging.getLogger('luigi')\n\n        if cls._configured:\n            logger.info('logging already configured')\n            return False\n        cls._configured = True\n\n        if cls.config.getboolean('core', 'no_configure_logging', False):\n            logger.info('logging disabled in settings')\n            return False\n\n        configured = cls._cli(opts)\n        if configured:\n            logger = logging.getLogger('luigi')\n            logger.info('logging configured via special settings')\n            return True\n\n        configured = cls._conf(opts)\n        if configured:\n            logger = logging.getLogger('luigi')\n            logger.info('logging configured via *.conf file')\n            return True\n\n        configured = cls._section(opts)\n        if configured:\n            logger = logging.getLogger('luigi')\n            logger.info('logging configured via config section')\n            return True\n\n        configured = cls._default(opts)\n        if configured:\n            logger = logging.getLogger('luigi')\n            logger.info('logging configured by default settings')\n        return configured",
        "begin_line": 52,
        "end_line": 93,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016260162601626016,
            "pseudo_dstar_susp": 0.0018214936247723133,
            "pseudo_tarantula_susp": 0.002577319587628866,
            "pseudo_op2_susp": 0.0018214936247723133,
            "pseudo_barinel_susp": 0.002577319587628866
        }
    },
    {
        "name": "luigi.setup_logging.DaemonLogging._cli#103",
        "src_path": "luigi/setup_logging.py",
        "class_name": "luigi.setup_logging.DaemonLogging",
        "signature": "luigi.setup_logging.DaemonLogging._cli(cls, opts)",
        "snippet": "    def _cli(cls, opts):\n        \"\"\"Setup logging via CLI options\n\n        If `--background` -- set INFO level for root logger.\n        If `--logdir` -- set logging with next params:\n            default Luigi's formatter,\n            INFO level,\n            output in logdir in `luigi-server.log` file\n        \"\"\"\n        if opts.background:\n            logging.getLogger().setLevel(logging.INFO)\n            return True\n\n        if opts.logdir:\n            logging.basicConfig(\n                level=logging.INFO,\n                format=cls._log_format,\n                filename=os.path.join(opts.logdir, \"luigi-server.log\"))\n            return True\n\n        return False",
        "begin_line": 103,
        "end_line": 123,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024630541871921183,
            "pseudo_dstar_susp": 0.0005931198102016608,
            "pseudo_tarantula_susp": 0.0033112582781456954,
            "pseudo_op2_susp": 0.0005931198102016608,
            "pseudo_barinel_susp": 0.0033112582781456954
        }
    },
    {
        "name": "luigi.setup_logging.DaemonLogging._conf#126",
        "src_path": "luigi/setup_logging.py",
        "class_name": "luigi.setup_logging.DaemonLogging",
        "signature": "luigi.setup_logging.DaemonLogging._conf(cls, opts)",
        "snippet": "    def _conf(cls, opts):\n        \"\"\"Setup logging via ini-file from logging_conf_file option.\"\"\"\n        logging_conf = cls.config.get('core', 'logging_conf_file', None)\n        if logging_conf is None:\n            return False\n\n        if not os.path.exists(logging_conf):\n            # FileNotFoundError added only in Python 3.3\n            # https://docs.python.org/3/whatsnew/3.3.html#pep-3151-reworking-the-os-and-io-exception-hierarchy\n            raise OSError(\"Error: Unable to locate specified logging configuration file!\")\n\n        logging.config.fileConfig(logging_conf)\n        return True",
        "begin_line": 126,
        "end_line": 138,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029498525073746312,
            "pseudo_dstar_susp": 0.0006024096385542169,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.0006024096385542169,
            "pseudo_barinel_susp": 0.004629629629629629
        }
    },
    {
        "name": "luigi.setup_logging.DaemonLogging._default#141",
        "src_path": "luigi/setup_logging.py",
        "class_name": "luigi.setup_logging.DaemonLogging",
        "signature": "luigi.setup_logging.DaemonLogging._default(cls, opts)",
        "snippet": "    def _default(cls, opts):\n        \"\"\"Setup default logger\"\"\"\n        logging.basicConfig(level=logging.INFO, format=cls._log_format)\n        return True",
        "begin_line": 141,
        "end_line": 144,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029498525073746312,
            "pseudo_dstar_susp": 0.0006024096385542169,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.0006024096385542169,
            "pseudo_barinel_susp": 0.004629629629629629
        }
    },
    {
        "name": "luigi.setup_logging.InterfaceLogging._cli#153",
        "src_path": "luigi/setup_logging.py",
        "class_name": "luigi.setup_logging.InterfaceLogging",
        "signature": "luigi.setup_logging.InterfaceLogging._cli(cls, opts)",
        "snippet": "    def _cli(cls, opts):\n        return False",
        "begin_line": 153,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.setup_logging.InterfaceLogging._conf#157",
        "src_path": "luigi/setup_logging.py",
        "class_name": "luigi.setup_logging.InterfaceLogging",
        "signature": "luigi.setup_logging.InterfaceLogging._conf(cls, opts)",
        "snippet": "    def _conf(cls, opts):\n        \"\"\"Setup logging via ini-file from logging_conf_file option.\"\"\"\n        if not opts.logging_conf_file:\n            return False\n\n        if not os.path.exists(opts.logging_conf_file):\n            # FileNotFoundError added only in Python 3.3\n            # https://docs.python.org/3/whatsnew/3.3.html#pep-3151-reworking-the-os-and-io-exception-hierarchy\n            raise OSError(\"Error: Unable to locate specified logging configuration file!\")\n\n        logging.config.fileConfig(opts.logging_conf_file, disable_existing_loggers=False)\n        return True",
        "begin_line": 157,
        "end_line": 168,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.setup_logging.InterfaceLogging._default#171",
        "src_path": "luigi/setup_logging.py",
        "class_name": "luigi.setup_logging.InterfaceLogging",
        "signature": "luigi.setup_logging.InterfaceLogging._default(cls, opts)",
        "snippet": "    def _default(cls, opts):\n        \"\"\"Setup default logger\"\"\"\n        level = getattr(logging, opts.log_level, logging.DEBUG)\n\n        logger = logging.getLogger('luigi-interface')\n        logger.setLevel(level)\n\n        stream_handler = logging.StreamHandler()\n        stream_handler.setLevel(level)\n\n        formatter = logging.Formatter('%(levelname)s: %(message)s')\n        stream_handler.setFormatter(formatter)\n\n        logger.addHandler(stream_handler)\n        return True",
        "begin_line": 171,
        "end_line": 185,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.datadog_metric.DatadogMetricsCollector.__init__#26",
        "src_path": "luigi/contrib/datadog_metric.py",
        "class_name": "luigi.contrib.datadog_metric.DatadogMetricsCollector",
        "signature": "luigi.contrib.datadog_metric.DatadogMetricsCollector.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        self._config = datadog(**kwargs)\n\n        initialize(api_key=self._config.api_key,\n                   app_key=self._config.app_key,\n                   statsd_host=self._config.statsd_host,\n                   statsd_port=self._config.statsd_port)",
        "begin_line": 26,
        "end_line": 32,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01818181818181818,
            "pseudo_dstar_susp": 0.0010940919037199124,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.0010940919037199124,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.contrib.opener.OpenerRegistry.get_opener#89",
        "src_path": "luigi/contrib/opener.py",
        "class_name": "luigi.contrib.opener.OpenerRegistry",
        "signature": "luigi.contrib.opener.OpenerRegistry.get_opener(self, name)",
        "snippet": "    def get_opener(self, name):\n        \"\"\"Retrieve an opener for the given protocol\n\n        :param name: name of the opener to open\n        :type name: string\n        :raises NoOpenerError: if no opener has been registered of that name\n\n        \"\"\"\n        if name not in self.registry:\n            raise NoOpenerError(\"No opener for %s\" % name)\n        index = self.registry[name]\n        return self.openers[index]",
        "begin_line": 89,
        "end_line": 100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.opener.OpenerRegistry.open#115",
        "src_path": "luigi/contrib/opener.py",
        "class_name": "luigi.contrib.opener.OpenerRegistry",
        "signature": "luigi.contrib.opener.OpenerRegistry.open(self, target_uri, **kwargs)",
        "snippet": "    def open(self, target_uri, **kwargs):\n        \"\"\"Open target uri.\n\n        :param target_uri: Uri to open\n        :type target_uri: string\n\n        :returns: Target object\n\n        \"\"\"\n        target = urlsplit(target_uri, scheme=self.default_opener)\n\n        opener = self.get_opener(target.scheme)\n        query = opener.conform_query(target.query)\n\n        target = opener.get_target(\n            target.scheme,\n            target.path,\n            target.fragment,\n            target.username,\n            target.password,\n            target.hostname,\n            target.port,\n            query,\n            **kwargs\n        )\n        target.opener_path = target_uri\n\n        return target",
        "begin_line": 115,
        "end_line": 142,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.opener.Opener.conform_query#157",
        "src_path": "luigi/contrib/opener.py",
        "class_name": "luigi.contrib.opener.Opener",
        "signature": "luigi.contrib.opener.Opener.conform_query(cls, query)",
        "snippet": "    def conform_query(cls, query):\n        \"\"\"Converts the query string from a target uri, uses\n        cls.allowed_kwargs, and cls.filter_kwargs to drive logic.\n\n        :param query: Unparsed query string\n        :type query: urllib.parse.unsplit(uri).query\n        :returns: Dictionary of parsed values, everything in cls.allowed_kwargs\n            with values set to True will be parsed as json strings.\n\n        \"\"\"\n        query = parse_qs(query, keep_blank_values=True)\n\n        # Remove any unexpected keywords from the query string.\n        if cls.filter_kwargs:\n            query = {x: y for x, y in query.items() if x in cls.allowed_kwargs}\n\n        for key, vals in query.items():\n            # Multiple values of the same name could be passed use first\n            # Also params without strings will be treated as true values\n            if cls.allowed_kwargs.get(key, False):\n                val = json.loads(vals[0] or 'true')\n            else:\n                val = vals[0] or 'true'\n\n            query[key] = val\n\n        return query",
        "begin_line": 157,
        "end_line": 183,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.opener.MockOpener.get_target#212",
        "src_path": "luigi/contrib/opener.py",
        "class_name": "luigi.contrib.opener.MockOpener",
        "signature": "luigi.contrib.opener.MockOpener.get_target(cls, scheme, path, fragment, username, password, hostname, port, query, **kwargs)",
        "snippet": "    def get_target(cls, scheme, path, fragment, username,\n                   password, hostname, port, query, **kwargs):\n        full_path = (hostname or '') + path\n        query.update(kwargs)\n        return MockTarget(full_path, **query)",
        "begin_line": 212,
        "end_line": 216,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.opener.LocalOpener.get_target#237",
        "src_path": "luigi/contrib/opener.py",
        "class_name": "luigi.contrib.opener.LocalOpener",
        "signature": "luigi.contrib.opener.LocalOpener.get_target(cls, scheme, path, fragment, username, password, hostname, port, query, **kwargs)",
        "snippet": "    def get_target(cls, scheme, path, fragment, username,\n                   password, hostname, port, query, **kwargs):\n        full_path = (hostname or '') + path\n        query.update(kwargs)\n        return LocalTarget(full_path, **query)",
        "begin_line": 237,
        "end_line": 241,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.opener.S3Opener.get_target#261",
        "src_path": "luigi/contrib/opener.py",
        "class_name": "luigi.contrib.opener.S3Opener",
        "signature": "luigi.contrib.opener.S3Opener.get_target(cls, scheme, path, fragment, username, password, hostname, port, query, **kwargs)",
        "snippet": "    def get_target(cls, scheme, path, fragment, username,\n                   password, hostname, port, query, **kwargs):\n        query.update(kwargs)\n        return S3Target('{scheme}://{hostname}{path}'.format(\n            scheme=scheme, hostname=hostname, path=path), **query)",
        "begin_line": 261,
        "end_line": 265,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.bigquery.BQTable.dataset#106",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BQTable",
        "signature": "luigi.contrib.bigquery.BQTable.dataset(self)",
        "snippet": "    def dataset(self):\n        return BQDataset(project_id=self.project_id, dataset_id=self.dataset_id, location=self.location)",
        "begin_line": 106,
        "end_line": 107,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigQueryTarget.__init__#397",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigQueryTarget",
        "signature": "luigi.contrib.bigquery.BigQueryTarget.__init__(self, project_id, dataset_id, table_id, client=None, location=None)",
        "snippet": "    def __init__(self, project_id, dataset_id, table_id, client=None, location=None):\n        self.table = BQTable(project_id=project_id, dataset_id=dataset_id, table_id=table_id, location=location)\n        self.client = client or BigQueryClient()",
        "begin_line": 397,
        "end_line": 399,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00020052135552436334,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigQueryTarget.exists#410",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigQueryTarget",
        "signature": "luigi.contrib.bigquery.BigQueryTarget.exists(self)",
        "snippet": "    def exists(self):\n        return self.client.table_exists(self.table)",
        "begin_line": 410,
        "end_line": 411,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigQueryTarget.__str__#413",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigQueryTarget",
        "signature": "luigi.contrib.bigquery.BigQueryTarget.__str__(self)",
        "snippet": "    def __str__(self):\n        return str(self.table)",
        "begin_line": 413,
        "end_line": 414,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.bigquery.MixinBigQueryBulkComplete.bulk_complete#427",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.MixinBigQueryBulkComplete",
        "signature": "luigi.contrib.bigquery.MixinBigQueryBulkComplete.bulk_complete(cls, parameter_tuples)",
        "snippet": "    def bulk_complete(cls, parameter_tuples):\n        # Instantiate the tasks to inspect them\n        tasks_with_params = [(cls(p), p) for p in parameter_tuples]\n        if not tasks_with_params:\n            return\n\n        # Grab the set of BigQuery datasets we are interested in\n        datasets = {t.output().table.dataset for t, p in tasks_with_params}\n        logger.info('Checking datasets %s for available tables', datasets)\n\n        # Query the available tables for all datasets\n        client = tasks_with_params[0][0].output().client\n        available_datasets = filter(client.dataset_exists, datasets)\n        available_tables = {d: set(client.list_tables(d)) for d in available_datasets}\n\n        # Return parameter_tuples belonging to available tables\n        for t, p in tasks_with_params:\n            table = t.output().table\n            if table.table_id in available_tables.get(table.dataset, []):\n                yield p",
        "begin_line": 427,
        "end_line": 446,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigQueryRunQueryTask.write_disposition#570",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigQueryRunQueryTask",
        "signature": "luigi.contrib.bigquery.BigQueryRunQueryTask.write_disposition(self)",
        "snippet": "    def write_disposition(self):\n        \"\"\"What to do if the table already exists. By default this will fail the job.\n\n           See :py:class:`WriteDisposition`\"\"\"\n        return WriteDisposition.WRITE_TRUNCATE",
        "begin_line": 570,
        "end_line": 574,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigQueryRunQueryTask.create_disposition#577",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigQueryRunQueryTask",
        "signature": "luigi.contrib.bigquery.BigQueryRunQueryTask.create_disposition(self)",
        "snippet": "    def create_disposition(self):\n        \"\"\"Whether to create the table or not. See :py:class:`CreateDisposition`\"\"\"\n        return CreateDisposition.CREATE_IF_NEEDED",
        "begin_line": 577,
        "end_line": 579,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigQueryRunQueryTask.flatten_results#582",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigQueryRunQueryTask",
        "signature": "luigi.contrib.bigquery.BigQueryRunQueryTask.flatten_results(self)",
        "snippet": "    def flatten_results(self):\n        \"\"\"Flattens all nested and repeated fields in the query results.\n        allowLargeResults must be true if this is set to False.\"\"\"\n        return True",
        "begin_line": 582,
        "end_line": 585,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002294630564479119,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigQueryRunQueryTask.query_mode#593",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigQueryRunQueryTask",
        "signature": "luigi.contrib.bigquery.BigQueryRunQueryTask.query_mode(self)",
        "snippet": "    def query_mode(self):\n        \"\"\"The query mode. See :py:class:`QueryMode`.\"\"\"\n        return QueryMode.INTERACTIVE",
        "begin_line": 593,
        "end_line": 595,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigQueryRunQueryTask.udf_resource_uris#598",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigQueryRunQueryTask",
        "signature": "luigi.contrib.bigquery.BigQueryRunQueryTask.udf_resource_uris(self)",
        "snippet": "    def udf_resource_uris(self):\n        \"\"\"Iterator of code resource to load from a Google Cloud Storage URI (gs://bucket/path).\n        \"\"\"\n        return []",
        "begin_line": 598,
        "end_line": 601,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigQueryRunQueryTask.use_legacy_sql#604",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigQueryRunQueryTask",
        "signature": "luigi.contrib.bigquery.BigQueryRunQueryTask.use_legacy_sql(self)",
        "snippet": "    def use_legacy_sql(self):\n        \"\"\"Whether to use legacy SQL\n        \"\"\"\n        return True",
        "begin_line": 604,
        "end_line": 607,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigQueryRunQueryTask.run#609",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigQueryRunQueryTask",
        "signature": "luigi.contrib.bigquery.BigQueryRunQueryTask.run(self)",
        "snippet": "    def run(self):\n        output = self.output()\n        assert isinstance(output, BigQueryTarget), 'Output must be a BigQueryTarget, not %s' % (output)\n\n        query = self.query\n        assert query, 'No query was provided'\n\n        bq_client = output.client\n\n        logger.info('Launching Query')\n        logger.info('Query destination: %s (%s)', output, self.write_disposition)\n        logger.info('Query SQL: %s', query)\n\n        job = {\n            'configuration': {\n                'query': {\n                    'query': query,\n                    'priority': self.query_mode,\n                    'destinationTable': {\n                        'projectId': output.table.project_id,\n                        'datasetId': output.table.dataset_id,\n                        'tableId': output.table.table_id,\n                    },\n                    'allowLargeResults': True,\n                    'createDisposition': self.create_disposition,\n                    'writeDisposition': self.write_disposition,\n                    'flattenResults': self.flatten_results,\n                    'userDefinedFunctionResources': [{\"resourceUri\": v} for v in self.udf_resource_uris],\n                    'useLegacySql': self.use_legacy_sql,\n                }\n            }\n        }\n\n        bq_client.run_job(output.table.project_id, job, dataset=output.table.dataset)",
        "begin_line": 609,
        "end_line": 642,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigQueryCreateViewTask.complete#660",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigQueryCreateViewTask",
        "signature": "luigi.contrib.bigquery.BigQueryCreateViewTask.complete(self)",
        "snippet": "    def complete(self):\n        output = self.output()\n        assert isinstance(output, BigQueryTarget), 'Output must be a BigQueryTarget, not %s' % (output)\n\n        if not output.exists():\n            return False\n\n        existing_view = output.client.get_view(output.table)\n        return existing_view == self.view",
        "begin_line": 660,
        "end_line": 668,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigQueryCreateViewTask.run#670",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigQueryCreateViewTask",
        "signature": "luigi.contrib.bigquery.BigQueryCreateViewTask.run(self)",
        "snippet": "    def run(self):\n        output = self.output()\n        assert isinstance(output, BigQueryTarget), 'Output must be a BigQueryTarget, not %s' % (output)\n\n        view = self.view\n        assert view, 'No view was provided'\n\n        logger.info('Create view')\n        logger.info('Destination: %s', output)\n        logger.info('View SQL: %s', view)\n\n        output.client.update_view(output.table, view)",
        "begin_line": 670,
        "end_line": 681,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigQueryExtractTask.destination_uris#700",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigQueryExtractTask",
        "signature": "luigi.contrib.bigquery.BigQueryExtractTask.destination_uris(self)",
        "snippet": "    def destination_uris(self):\n        \"\"\"\n        The fully-qualified URIs that point to your data in Google Cloud\n        Storage. Each URI can contain one '*' wildcard character and it must\n        come after the 'bucket' name.\n\n        Wildcarded destinationUris in GCSQueryTarget might not be resolved\n        correctly and result in incomplete data. If a GCSQueryTarget is used to\n        pass wildcarded destinationUris be sure to overwrite this property to\n        suppress the warning.\n        \"\"\"\n        return [x.path for x in luigi.task.flatten(self.output())]",
        "begin_line": 700,
        "end_line": 711,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigQueryExtractTask.print_header#714",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigQueryExtractTask",
        "signature": "luigi.contrib.bigquery.BigQueryExtractTask.print_header(self)",
        "snippet": "    def print_header(self):\n        \"\"\"Whether to print the header or not.\"\"\"\n        return PrintHeader.TRUE",
        "begin_line": 714,
        "end_line": 716,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigQueryExtractTask.field_delimiter#719",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigQueryExtractTask",
        "signature": "luigi.contrib.bigquery.BigQueryExtractTask.field_delimiter(self)",
        "snippet": "    def field_delimiter(self):\n        \"\"\"\n        The separator for fields in a CSV file. The separator can be any\n        ISO-8859-1 single-byte character.\n        \"\"\"\n        return FieldDelimiter.COMMA",
        "begin_line": 719,
        "end_line": 724,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigQueryExtractTask.destination_format#727",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigQueryExtractTask",
        "signature": "luigi.contrib.bigquery.BigQueryExtractTask.destination_format(self)",
        "snippet": "    def destination_format(self):\n        \"\"\"\n        The destination format to use (see :py:class:`DestinationFormat`).\n        \"\"\"\n        return DestinationFormat.CSV",
        "begin_line": 727,
        "end_line": 731,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigQueryExtractTask.compression#734",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigQueryExtractTask",
        "signature": "luigi.contrib.bigquery.BigQueryExtractTask.compression(self)",
        "snippet": "    def compression(self):\n        \"\"\"Whether to use compression.\"\"\"\n        return Compression.NONE",
        "begin_line": 734,
        "end_line": 736,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigQueryExtractTask.run#738",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigQueryExtractTask",
        "signature": "luigi.contrib.bigquery.BigQueryExtractTask.run(self)",
        "snippet": "    def run(self):\n        input = luigi.task.flatten(self.input())[0]\n        assert (\n            isinstance(input, BigQueryTarget) or\n            (len(input) == 1 and isinstance(input[0], BigQueryTarget))), \\\n            'Input must be exactly one BigQueryTarget, not %s' % (input)\n        bq_client = input.client\n\n        destination_uris = self.destination_uris\n        assert all(x.startswith('gs://') for x in destination_uris)\n\n        logger.info('Launching Extract Job')\n        logger.info('Extract source: %s', input)\n        logger.info('Extract destination: %s', destination_uris)\n\n        job = {\n            'configuration': {\n                'extract': {\n                    'sourceTable': {\n                        'projectId': input.table.project_id,\n                        'datasetId': input.table.dataset_id,\n                        'tableId': input.table.table_id\n                    },\n                    'destinationUris': destination_uris,\n                    'destinationFormat': self.destination_format,\n                    'compression': self.compression\n                }\n            }\n        }\n\n        if self.destination_format == 'CSV':\n            # \"Only exports to CSV may specify a field delimiter.\"\n            job['configuration']['extract']['printHeader'] = self.print_header\n            job['configuration']['extract']['fieldDelimiter'] = \\\n                self.field_delimiter\n\n        bq_client.run_job(\n            input.table.project_id,\n            job,\n            dataset=input.table.dataset)",
        "begin_line": 738,
        "end_line": 777,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.notifications.generate_email#137",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.generate_email(sender, subject, message, recipients, image_png)",
        "snippet": "def generate_email(sender, subject, message, recipients, image_png):\n    from email.mime.multipart import MIMEMultipart\n    from email.mime.text import MIMEText\n    from email.mime.image import MIMEImage\n\n    msg_root = MIMEMultipart('related')\n\n    msg_text = MIMEText(message, email().format, 'utf-8')\n    msg_root.attach(msg_text)\n\n    if image_png:\n        with open(image_png, 'rb') as fp:\n            msg_image = MIMEImage(fp.read(), 'png')\n        msg_root.attach(msg_image)\n\n    msg_root['Subject'] = subject\n    msg_root['From'] = sender\n    msg_root['To'] = ','.join(recipients)\n\n    return msg_root",
        "begin_line": 137,
        "end_line": 156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00018864365214110544,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.notifications.wrap_traceback#159",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.wrap_traceback(traceback)",
        "snippet": "def wrap_traceback(traceback):\n    \"\"\"\n    For internal use only (until further notice)\n    \"\"\"\n    if email().format == 'html':\n        try:\n            from pygments import highlight\n            from pygments.lexers import PythonTracebackLexer\n            from pygments.formatters import HtmlFormatter\n            with_pygments = True\n        except ImportError:\n            with_pygments = False\n\n        if with_pygments:\n            formatter = HtmlFormatter(noclasses=True)\n            wrapped = highlight(traceback, PythonTracebackLexer(), formatter)\n        else:\n            wrapped = '<pre>%s</pre>' % traceback\n    else:\n        wrapped = traceback\n\n    return wrapped",
        "begin_line": 159,
        "end_line": 180,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005379236148466917,
            "pseudo_dstar_susp": 0.0005060728744939271,
            "pseudo_tarantula_susp": 0.00089126559714795,
            "pseudo_op2_susp": 0.0005060728744939271,
            "pseudo_barinel_susp": 0.00089126559714795
        }
    },
    {
        "name": "luigi.notifications.send_email_smtp#183",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.send_email_smtp(sender, subject, message, recipients, image_png)",
        "snippet": "def send_email_smtp(sender, subject, message, recipients, image_png):\n    import smtplib\n\n    smtp_config = smtp()\n    kwargs = dict(\n        host=smtp_config.host,\n        port=smtp_config.port,\n        local_hostname=smtp_config.local_hostname,\n    )\n    if smtp_config.timeout:\n        kwargs['timeout'] = smtp_config.timeout\n\n    try:\n        smtp_conn = smtplib.SMTP_SSL(**kwargs) if smtp_config.ssl else smtplib.SMTP(**kwargs)\n        smtp_conn.ehlo_or_helo_if_needed()\n        if smtp_conn.has_extn('starttls') and not smtp_config.no_tls:\n            smtp_conn.starttls()\n        if smtp_config.username and smtp_config.password:\n            smtp_conn.login(smtp_config.username, smtp_config.password)\n\n        msg_root = generate_email(sender, subject, message, recipients, image_png)\n\n        smtp_conn.sendmail(sender, recipients, msg_root.as_string())\n    except socket.error as exception:\n        logger.error(\"Not able to connect to smtp server: %s\", exception)",
        "begin_line": 183,
        "end_line": 207,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.notifications.send_email_ses#210",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.send_email_ses(sender, subject, message, recipients, image_png)",
        "snippet": "def send_email_ses(sender, subject, message, recipients, image_png):\n    \"\"\"\n    Sends notification through AWS SES.\n\n    Does not handle access keys.  Use either\n      1/ configuration file\n      2/ EC2 instance profile\n\n    See also https://boto3.readthedocs.io/en/latest/guide/configuration.html.\n    \"\"\"\n    from boto3 import client as boto3_client\n\n    client = boto3_client('ses')\n\n    msg_root = generate_email(sender, subject, message, recipients, image_png)\n    response = client.send_raw_email(Source=sender,\n                                     Destinations=recipients,\n                                     RawMessage={'Data': msg_root.as_string()})\n\n    logger.debug((\"Message sent to SES.\\nMessageId: {},\\nRequestId: {},\\n\"\n                 \"HTTPSStatusCode: {}\").format(response['MessageId'],\n                                               response['ResponseMetadata']['RequestId'],\n                                               response['ResponseMetadata']['HTTPStatusCode']))",
        "begin_line": 210,
        "end_line": 232,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.notifications.send_email_sendgrid#235",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.send_email_sendgrid(sender, subject, message, recipients, image_png)",
        "snippet": "def send_email_sendgrid(sender, subject, message, recipients, image_png):\n    import sendgrid as sendgrid_lib\n    client = sendgrid_lib.SendGridClient(\n        sendgrid().username, sendgrid().password, raise_errors=True)\n    to_send = sendgrid_lib.Mail()\n    to_send.add_to(recipients)\n    to_send.set_from(sender)\n    to_send.set_subject(subject)\n    if email().format == 'html':\n        to_send.set_html(message)\n    else:\n        to_send.set_text(message)\n    if image_png:\n        to_send.add_attachment(image_png)\n\n    client.send(to_send)",
        "begin_line": 235,
        "end_line": 250,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.notifications._email_disabled_reason#253",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications._email_disabled_reason()",
        "snippet": "def _email_disabled_reason():\n    if email().format == 'none':\n        return \"email format is 'none'\"\n    elif email().force_send:\n        return None\n    elif sys.stdout.isatty():\n        return \"running from a tty\"\n    else:\n        return None",
        "begin_line": 253,
        "end_line": 261,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.notifications.send_email_sns#264",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.send_email_sns(sender, subject, message, topic_ARN, image_png)",
        "snippet": "def send_email_sns(sender, subject, message, topic_ARN, image_png):\n    \"\"\"\n    Sends notification through AWS SNS. Takes Topic ARN from recipients.\n\n    Does not handle access keys.  Use either\n      1/ configuration file\n      2/ EC2 instance profile\n\n    See also https://boto3.readthedocs.io/en/latest/guide/configuration.html.\n    \"\"\"\n    from boto3 import resource as boto3_resource\n\n    sns = boto3_resource('sns')\n    topic = sns.Topic(topic_ARN[0])\n\n    # Subject is max 100 chars\n    if len(subject) > 100:\n        subject = subject[0:48] + '...' + subject[-49:]\n\n    response = topic.publish(Subject=subject, Message=message)\n\n    logger.debug((\"Message sent to SNS.\\nMessageId: {},\\nRequestId: {},\\n\"\n                 \"HTTPSStatusCode: {}\").format(response['MessageId'],\n                                               response['ResponseMetadata']['RequestId'],\n                                               response['ResponseMetadata']['HTTPStatusCode']))",
        "begin_line": 264,
        "end_line": 288,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.notifications.send_email#291",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.send_email(subject, message, sender, recipients, image_png=None)",
        "snippet": "def send_email(subject, message, sender, recipients, image_png=None):\n    \"\"\"\n    Decides whether to send notification. Notification is cancelled if there are\n    no recipients or if stdout is onto tty or if in debug mode.\n\n    Dispatches on config value email.method.  Default is 'smtp'.\n    \"\"\"\n    notifiers = {\n        'ses': send_email_ses,\n        'sendgrid': send_email_sendgrid,\n        'smtp': send_email_smtp,\n        'sns': send_email_sns,\n    }\n\n    subject = _prefix(subject)\n    if not recipients or recipients == (None,):\n        return\n\n    if _email_disabled_reason():\n        logger.info(\"Not sending email to %r because %s\",\n                    recipients, _email_disabled_reason())\n        return\n\n    # Clean the recipients lists to allow multiple email addresses, comma\n    # separated in luigi.cfg\n    recipients_tmp = []\n    for r in recipients:\n        recipients_tmp.extend([a.strip() for a in r.split(',') if a.strip()])\n\n    # Replace original recipients with the clean list\n    recipients = recipients_tmp\n\n    logger.info(\"Sending email to %r\", recipients)\n\n    # Get appropriate sender and call it to send the notification\n    email_sender = notifiers[email().method]\n    email_sender(sender, subject, message, recipients, image_png)",
        "begin_line": 291,
        "end_line": 327,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005285412262156448,
            "pseudo_dstar_susp": 0.0005037783375314861,
            "pseudo_tarantula_susp": 0.0008084074373484236,
            "pseudo_op2_susp": 0.0005037783375314861,
            "pseudo_barinel_susp": 0.0008084074373484236
        }
    },
    {
        "name": "luigi.notifications._email_recipients#330",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications._email_recipients(additional_recipients=None)",
        "snippet": "def _email_recipients(additional_recipients=None):\n    receiver = email().receiver\n    recipients = [receiver] if receiver else []\n    if additional_recipients:\n        if isinstance(additional_recipients, str):\n            recipients.append(additional_recipients)\n        else:\n            recipients.extend(additional_recipients)\n    return recipients",
        "begin_line": 330,
        "end_line": 338,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000517063081695967,
            "pseudo_dstar_susp": 0.000499001996007984,
            "pseudo_tarantula_susp": 0.000724112961622013,
            "pseudo_op2_susp": 0.000499001996007984,
            "pseudo_barinel_susp": 0.0007267441860465116
        }
    },
    {
        "name": "luigi.notifications.send_error_email#341",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.send_error_email(subject, message, additional_recipients=None)",
        "snippet": "def send_error_email(subject, message, additional_recipients=None):\n    \"\"\"\n    Sends an email to the configured error email, if it's configured.\n    \"\"\"\n    recipients = _email_recipients(additional_recipients)\n    sender = email().sender\n    send_email(\n        subject=subject,\n        message=message,\n        sender=sender,\n        recipients=recipients\n    )",
        "begin_line": 341,
        "end_line": 352,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005200208008320333,
            "pseudo_dstar_susp": 0.000500751126690035,
            "pseudo_tarantula_susp": 0.0007473841554559044,
            "pseudo_op2_susp": 0.000500751126690035,
            "pseudo_barinel_susp": 0.0007473841554559044
        }
    },
    {
        "name": "luigi.notifications._prefix#355",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications._prefix(subject)",
        "snippet": "def _prefix(subject):\n    \"\"\"\n    If the config has a special prefix for emails then this function adds\n    this prefix.\n    \"\"\"\n    if email().prefix:\n        return \"{} {}\".format(email().prefix, subject)\n    else:\n        return subject",
        "begin_line": 355,
        "end_line": 363,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005120327700972862,
            "pseudo_dstar_susp": 0.0004955401387512388,
            "pseudo_tarantula_susp": 0.0006784260515603799,
            "pseudo_op2_susp": 0.0004955401387512388,
            "pseudo_barinel_susp": 0.0006784260515603799
        }
    },
    {
        "name": "luigi.notifications.format_task_error#366",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.format_task_error(headline, task, command, formatted_exception=None)",
        "snippet": "def format_task_error(headline, task, command, formatted_exception=None):\n    \"\"\"\n    Format a message body for an error email related to a luigi.task.Task\n\n    :param headline: Summary line for the message\n    :param task: `luigi.task.Task` instance where this error occurred\n    :param formatted_exception: optional string showing traceback\n\n    :return: message body\n    \"\"\"\n\n    if formatted_exception:\n        formatted_exception = wrap_traceback(formatted_exception)\n    else:\n        formatted_exception = \"\"\n\n    if email().format == 'html':\n        msg_template = textwrap.dedent('''\n        <html>\n        <body>\n        <h2>{headline}</h2>\n\n        <table style=\"border-top: 1px solid black; border-bottom: 1px solid black\">\n        <thead>\n        <tr><th>name</th><td>{name}</td></tr>\n        </thead>\n        <tbody>\n        {param_rows}\n        </tbody>\n        </table>\n        </pre>\n\n        <h2>Command line</h2>\n        <pre>\n        {command}\n        </pre>\n\n        <h2>Traceback</h2>\n        {traceback}\n        </body>\n        </html>\n        ''')\n\n        str_params = task.to_str_params()\n        params = '\\n'.join('<tr><th>{}</th><td>{}</td></tr>'.format(*items) for items in str_params.items())\n        body = msg_template.format(headline=headline, name=task.task_family, param_rows=params,\n                                   command=command, traceback=formatted_exception)\n    else:\n        msg_template = textwrap.dedent('''\\\n        {headline}\n\n        Name: {name}\n\n        Parameters:\n        {params}\n\n        Command line:\n          {command}\n\n        {traceback}\n        ''')\n\n        str_params = task.to_str_params()\n        max_width = max([0] + [len(x) for x in str_params.keys()])\n        params = '\\n'.join('  {:{width}}: {}'.format(*items, width=max_width) for items in str_params.items())\n        body = msg_template.format(headline=headline, name=task.task_family, params=params,\n                                   command=command, traceback=formatted_exception)\n\n    return body",
        "begin_line": 366,
        "end_line": 434,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007710100231303007,
            "pseudo_dstar_susp": 0.0008481764206955047,
            "pseudo_tarantula_susp": 0.0009643201542912247,
            "pseudo_op2_susp": 0.0008481764206955047,
            "pseudo_barinel_susp": 0.0009643201542912247
        }
    },
    {
        "name": "luigi.contrib.sge._parse_qstat_state#113",
        "src_path": "luigi/contrib/sge.py",
        "class_name": "luigi.contrib.sge",
        "signature": "luigi.contrib.sge._parse_qstat_state(qstat_out, job_id)",
        "snippet": "def _parse_qstat_state(qstat_out, job_id):\n    \"\"\"Parse \"state\" column from `qstat` output for given job_id\n\n    Returns state for the *first* job matching job_id. Returns 'u' if\n    `qstat` output is empty or job_id is not found.\n\n    \"\"\"\n    if qstat_out.strip() == '':\n        return 'u'\n    lines = qstat_out.split('\\n')\n    # skip past header\n    while not lines.pop(0).startswith('---'):\n        pass\n    for line in lines:\n        if line:\n            job, prior, name, user, state = line.strip().split()[0:5]\n            if int(job) == int(job_id):\n                return state\n    return 'u'",
        "begin_line": 113,
        "end_line": 131,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.sge.SGEJobTask.__init__#206",
        "src_path": "luigi/contrib/sge.py",
        "class_name": "luigi.contrib.sge.SGEJobTask",
        "signature": "luigi.contrib.sge.SGEJobTask.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        super(SGEJobTask, self).__init__(*args, **kwargs)\n        if self.job_name:\n            # use explicitly provided job name\n            pass\n        elif self.job_name_format:\n            # define the job name with the provided format\n            self.job_name = self.job_name_format.format(\n                task_family=self.task_family, **self.__dict__)\n        else:\n            # default to the task family\n            self.job_name = self.task_family",
        "begin_line": 206,
        "end_line": 217,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008,
            "pseudo_dstar_susp": 0.0006211180124223603,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.0006211180124223603,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.contrib.sge.SGEJobTask._init_local#231",
        "src_path": "luigi/contrib/sge.py",
        "class_name": "luigi.contrib.sge.SGEJobTask",
        "signature": "luigi.contrib.sge.SGEJobTask._init_local(self)",
        "snippet": "    def _init_local(self):\n\n        # Set up temp folder in shared directory (trim to max filename length)\n        base_tmp_dir = self.shared_tmp_dir\n        random_id = '%016x' % random.getrandbits(64)\n        folder_name = self.task_id + '-' + random_id\n        self.tmp_dir = os.path.join(base_tmp_dir, folder_name)\n        max_filename_length = os.fstatvfs(0).f_namemax\n        self.tmp_dir = self.tmp_dir[:max_filename_length]\n        logger.info(\"Tmp dir: %s\", self.tmp_dir)\n        os.makedirs(self.tmp_dir)\n\n        # Dump the code to be run into a pickle file\n        logging.debug(\"Dumping pickled class\")\n        self._dump(self.tmp_dir)\n\n        if not self.no_tarball:\n            # Make sure that all the class's dependencies are tarred and available\n            # This is not necessary if luigi is importable from the cluster node\n            logging.debug(\"Tarballing dependencies\")\n            # Grab luigi and the module containing the code to be run\n            packages = [luigi] + [__import__(self.__module__, None, None, 'dummy')]\n            create_packages_archive(packages, os.path.join(self.tmp_dir, \"packages.tar\"))",
        "begin_line": 231,
        "end_line": 253,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008,
            "pseudo_dstar_susp": 0.0006211180124223603,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.0006211180124223603,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.contrib.sge.SGEJobTask.run#255",
        "src_path": "luigi/contrib/sge.py",
        "class_name": "luigi.contrib.sge.SGEJobTask",
        "signature": "luigi.contrib.sge.SGEJobTask.run(self)",
        "snippet": "    def run(self):\n        if self.run_locally:\n            self.work()\n        else:\n            self._init_local()\n            self._run_job()",
        "begin_line": 255,
        "end_line": 260,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008,
            "pseudo_dstar_susp": 0.0006211180124223603,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.0006211180124223603,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.contrib.sge.SGEJobTask._dump#273",
        "src_path": "luigi/contrib/sge.py",
        "class_name": "luigi.contrib.sge.SGEJobTask",
        "signature": "luigi.contrib.sge.SGEJobTask._dump(self, out_dir='')",
        "snippet": "    def _dump(self, out_dir=''):\n        \"\"\"Dump instance to file.\"\"\"\n        with self.no_unpicklable_properties():\n            self.job_file = os.path.join(out_dir, 'job-instance.pickle')\n            if self.__module__ == '__main__':\n                d = pickle.dumps(self)\n                module_name = os.path.basename(sys.argv[0]).rsplit('.', 1)[0]\n                d = d.replace('(c__main__', \"(c\" + module_name)\n                open(self.job_file, \"w\").write(d)\n            else:\n                pickle.dump(self, open(self.job_file, \"w\"))",
        "begin_line": 273,
        "end_line": 283,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008,
            "pseudo_dstar_susp": 0.0006211180124223603,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.0006211180124223603,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.cmdline_parser.CmdlineParser.get_instance#38",
        "src_path": "luigi/cmdline_parser.py",
        "class_name": "luigi.cmdline_parser.CmdlineParser",
        "signature": "luigi.cmdline_parser.CmdlineParser.get_instance(cls)",
        "snippet": "    def get_instance(cls):\n        \"\"\" Singleton getter \"\"\"\n        return cls._instance",
        "begin_line": 38,
        "end_line": 40,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018450184501845018,
            "pseudo_dstar_susp": 0.009345794392523364,
            "pseudo_tarantula_susp": 0.0010559662090813093,
            "pseudo_op2_susp": 0.009345794392523364,
            "pseudo_barinel_susp": 0.0010559662090813093
        }
    },
    {
        "name": "luigi.cmdline_parser.CmdlineParser.global_instance#44",
        "src_path": "luigi/cmdline_parser.py",
        "class_name": "luigi.cmdline_parser.CmdlineParser",
        "signature": "luigi.cmdline_parser.CmdlineParser.global_instance(cls, cmdline_args, allow_override=False)",
        "snippet": "    def global_instance(cls, cmdline_args, allow_override=False):\n        \"\"\"\n        Meant to be used as a context manager.\n        \"\"\"\n        orig_value = cls._instance\n        assert (orig_value is None) or allow_override\n        new_value = None\n        try:\n            new_value = CmdlineParser(cmdline_args)\n            cls._instance = new_value\n            yield new_value\n        finally:\n            assert cls._instance is new_value\n            cls._instance = orig_value",
        "begin_line": 44,
        "end_line": 57,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001098901098901099,
            "pseudo_dstar_susp": 0.0008992805755395684,
            "pseudo_tarantula_susp": 0.0014104372355430183,
            "pseudo_op2_susp": 0.0008992805755395684,
            "pseudo_barinel_susp": 0.0014104372355430183
        }
    },
    {
        "name": "luigi.cmdline_parser.CmdlineParser.__init__#59",
        "src_path": "luigi/cmdline_parser.py",
        "class_name": "luigi.cmdline_parser.CmdlineParser",
        "signature": "luigi.cmdline_parser.CmdlineParser.__init__(self, cmdline_args)",
        "snippet": "    def __init__(self, cmdline_args):\n        \"\"\"\n        Initialize cmd line args\n        \"\"\"\n        known_args, _ = self._build_parser().parse_known_args(args=cmdline_args)\n        self._attempt_load_module(known_args)\n        # We have to parse again now. As the positionally first unrecognized\n        # argument (the task) could be different.\n        known_args, _ = self._build_parser().parse_known_args(args=cmdline_args)\n        root_task = known_args.root_task\n        parser = self._build_parser(root_task=root_task,\n                                    help_all=known_args.core_help_all)\n        self._possibly_exit_with_help(parser, known_args)\n        if not root_task:\n            raise SystemExit('No task specified')\n        else:\n            # Check that what we believe to be the task is correctly spelled\n            Register.get_task_cls(root_task)\n        known_args = parser.parse_args(args=cmdline_args)\n        self.known_args = known_args  # Also publically expose parsed arguments",
        "begin_line": 59,
        "end_line": 78,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011363636363636363,
            "pseudo_dstar_susp": 0.0009225092250922509,
            "pseudo_tarantula_susp": 0.0014749262536873156,
            "pseudo_op2_susp": 0.0009225092250922509,
            "pseudo_barinel_susp": 0.0014749262536873156
        }
    },
    {
        "name": "luigi.cmdline_parser.CmdlineParser._build_parser#81",
        "src_path": "luigi/cmdline_parser.py",
        "class_name": "luigi.cmdline_parser.CmdlineParser",
        "signature": "luigi.cmdline_parser.CmdlineParser._build_parser(root_task=None, help_all=False)",
        "snippet": "    def _build_parser(root_task=None, help_all=False):\n        parser = argparse.ArgumentParser(add_help=False)\n\n        # Unfortunately, we have to set it as optional to argparse, so we can\n        # parse out stuff like `--module` before we call for `--help`.\n        parser.add_argument('root_task',\n                            nargs='?',\n                            help='Task family to run. Is not optional.',\n                            metavar='Required root task',\n                            )\n\n        for task_name, is_without_section, param_name, param_obj in Register.get_all_params():\n            is_the_root_task = task_name == root_task\n            help = param_obj.description if any((is_the_root_task, help_all, param_obj.always_in_help)) else argparse.SUPPRESS\n            flag_name_underscores = param_name if is_without_section else task_name + '_' + param_name\n            global_flag_name = '--' + flag_name_underscores.replace('_', '-')\n            parser.add_argument(global_flag_name,\n                                help=help,\n                                **param_obj._parser_kwargs(param_name, task_name)\n                                )\n            if is_the_root_task:\n                local_flag_name = '--' + param_name.replace('_', '-')\n                parser.add_argument(local_flag_name,\n                                    help=help,\n                                    **param_obj._parser_kwargs(param_name)\n                                    )\n\n        return parser",
        "begin_line": 81,
        "end_line": 108,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001098901098901099,
            "pseudo_dstar_susp": 0.0008992805755395684,
            "pseudo_tarantula_susp": 0.0014104372355430183,
            "pseudo_op2_susp": 0.0008992805755395684,
            "pseudo_barinel_susp": 0.0014104372355430183
        }
    },
    {
        "name": "luigi.cmdline_parser.CmdlineParser.get_task_obj#110",
        "src_path": "luigi/cmdline_parser.py",
        "class_name": "luigi.cmdline_parser.CmdlineParser",
        "signature": "luigi.cmdline_parser.CmdlineParser.get_task_obj(self)",
        "snippet": "    def get_task_obj(self):\n        \"\"\"\n        Get the task object\n        \"\"\"\n        return self._get_task_cls()(**self._get_task_kwargs())",
        "begin_line": 110,
        "end_line": 114,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005558643690939411,
            "pseudo_dstar_susp": 0.0005151983513652757,
            "pseudo_tarantula_susp": 0.0010193679918450561,
            "pseudo_op2_susp": 0.0005151983513652757,
            "pseudo_barinel_susp": 0.0010193679918450561
        }
    },
    {
        "name": "luigi.cmdline_parser.CmdlineParser._get_task_cls#116",
        "src_path": "luigi/cmdline_parser.py",
        "class_name": "luigi.cmdline_parser.CmdlineParser",
        "signature": "luigi.cmdline_parser.CmdlineParser._get_task_cls(self)",
        "snippet": "    def _get_task_cls(self):\n        \"\"\"\n        Get the task class\n        \"\"\"\n        return Register.get_task_cls(self.known_args.root_task)",
        "begin_line": 116,
        "end_line": 120,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005558643690939411,
            "pseudo_dstar_susp": 0.0005151983513652757,
            "pseudo_tarantula_susp": 0.0010193679918450561,
            "pseudo_op2_susp": 0.0005151983513652757,
            "pseudo_barinel_susp": 0.0010193679918450561
        }
    },
    {
        "name": "luigi.cmdline_parser.CmdlineParser._get_task_kwargs#122",
        "src_path": "luigi/cmdline_parser.py",
        "class_name": "luigi.cmdline_parser.CmdlineParser",
        "signature": "luigi.cmdline_parser.CmdlineParser._get_task_kwargs(self)",
        "snippet": "    def _get_task_kwargs(self):\n        \"\"\"\n        Get the local task arguments as a dictionary. The return value is in\n        the form ``dict(my_param='my_value', ...)``\n        \"\"\"\n        res = {}\n        for (param_name, param_obj) in self._get_task_cls().get_params():\n            attr = getattr(self.known_args, param_name)\n            if attr:\n                res.update(((param_name, param_obj.parse(attr)),))\n\n        return res",
        "begin_line": 122,
        "end_line": 133,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006798096532970768,
            "pseudo_dstar_susp": 0.0005263157894736842,
            "pseudo_tarantula_susp": 0.0012515644555694619,
            "pseudo_op2_susp": 0.0005263157894736842,
            "pseudo_barinel_susp": 0.0012515644555694619
        }
    },
    {
        "name": "luigi.cmdline_parser.CmdlineParser._attempt_load_module#136",
        "src_path": "luigi/cmdline_parser.py",
        "class_name": "luigi.cmdline_parser.CmdlineParser",
        "signature": "luigi.cmdline_parser.CmdlineParser._attempt_load_module(known_args)",
        "snippet": "    def _attempt_load_module(known_args):\n        \"\"\"\n        Load the --module parameter\n        \"\"\"\n        module = known_args.core_module\n        if module:\n            __import__(module)",
        "begin_line": 136,
        "end_line": 142,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001098901098901099,
            "pseudo_dstar_susp": 0.0008992805755395684,
            "pseudo_tarantula_susp": 0.0014104372355430183,
            "pseudo_op2_susp": 0.0008992805755395684,
            "pseudo_barinel_susp": 0.0014104372355430183
        }
    },
    {
        "name": "luigi.cmdline_parser.CmdlineParser._possibly_exit_with_help#145",
        "src_path": "luigi/cmdline_parser.py",
        "class_name": "luigi.cmdline_parser.CmdlineParser",
        "signature": "luigi.cmdline_parser.CmdlineParser._possibly_exit_with_help(parser, known_args)",
        "snippet": "    def _possibly_exit_with_help(parser, known_args):\n        \"\"\"\n        Check if the user passed --help[-all], if so, print a message and exit.\n        \"\"\"\n        if known_args.core_help or known_args.core_help_all:\n            parser.print_help()\n            sys.exit()",
        "begin_line": 145,
        "end_line": 151,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001098901098901099,
            "pseudo_dstar_susp": 0.0008992805755395684,
            "pseudo_tarantula_susp": 0.0014104372355430183,
            "pseudo_op2_susp": 0.0008992805755395684,
            "pseudo_barinel_susp": 0.0014104372355430183
        }
    },
    {
        "name": "luigi.rpc._urljoin#52",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc",
        "signature": "luigi.rpc._urljoin(base, url)",
        "snippet": "def _urljoin(base, url):\n    \"\"\"\n    Join relative URLs to base URLs like urllib.parse.urljoin but support\n    arbitrary URIs (esp. 'http+unix://').\n    \"\"\"\n    parsed = urlparse(base)\n    scheme = parsed.scheme\n    return urlparse(\n        urljoin(parsed._replace(scheme='http').geturl(), url)\n    )._replace(scheme=scheme).geturl()",
        "begin_line": 52,
        "end_line": 61,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017325017325017325,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.rpc.RPCError.__init__#66",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RPCError",
        "signature": "luigi.rpc.RPCError.__init__(self, message, sub_exception=None)",
        "snippet": "    def __init__(self, message, sub_exception=None):\n        super(RPCError, self).__init__(message)\n        self.sub_exception = sub_exception",
        "begin_line": 66,
        "end_line": 68,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.rpc.URLLibFetcher.fetch#74",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.URLLibFetcher",
        "signature": "luigi.rpc.URLLibFetcher.fetch(self, full_url, body, timeout)",
        "snippet": "    def fetch(self, full_url, body, timeout):\n        body = urlencode(body).encode('utf-8')\n        return urlopen(full_url, body, timeout).read().decode('utf-8')",
        "begin_line": 74,
        "end_line": 76,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.rpc.RequestsFetcher.__init__#80",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RequestsFetcher",
        "signature": "luigi.rpc.RequestsFetcher.__init__(self, session)",
        "snippet": "    def __init__(self, session):\n        from requests import exceptions as requests_exceptions\n        self.raises = requests_exceptions.RequestException\n        self.session = session\n        self.process_id = os.getpid()",
        "begin_line": 80,
        "end_line": 84,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00015903307888040714,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.rpc.RequestsFetcher.check_pid#86",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RequestsFetcher",
        "signature": "luigi.rpc.RequestsFetcher.check_pid(self)",
        "snippet": "    def check_pid(self):\n        # if the process id change changed from when the session was created\n        # a new session needs to be setup since requests isn't multiprocessing safe.\n        if os.getpid() != self.process_id:\n            self.session = requests.Session()\n            self.process_id = os.getpid()",
        "begin_line": 86,
        "end_line": 91,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017966223499820338,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.rpc.RequestsFetcher.fetch#93",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RequestsFetcher",
        "signature": "luigi.rpc.RequestsFetcher.fetch(self, full_url, body, timeout)",
        "snippet": "    def fetch(self, full_url, body, timeout):\n        self.check_pid()\n        resp = self.session.get(full_url, data=body, timeout=timeout)\n        resp.raise_for_status()\n        return resp.text",
        "begin_line": 93,
        "end_line": 97,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00018570102135561745,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler.__init__#105",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler.__init__(self, url='http://localhost:8082/', connect_timeout=None)",
        "snippet": "    def __init__(self, url='http://localhost:8082/', connect_timeout=None):\n        assert not url.startswith('http+unix://') or HAS_UNIX_SOCKET, (\n            'You need to install requests-unixsocket for Unix socket support.'\n        )\n\n        self._url = url.rstrip('/')\n        config = configuration.get_config()\n\n        if connect_timeout is None:\n            connect_timeout = config.getfloat('core', 'rpc-connect-timeout', 10.0)\n        self._connect_timeout = connect_timeout\n\n        self._rpc_retry_attempts = config.getint('core', 'rpc-retry-attempts', 3)\n        self._rpc_retry_wait = config.getint('core', 'rpc-retry-wait', 30)\n        self._rpc_log_retries = config.getboolean('core', 'rpc-log-retries', True)\n\n        if HAS_REQUESTS:\n            self._fetcher = RequestsFetcher(requests.Session())\n        else:\n            self._fetcher = URLLibFetcher()",
        "begin_line": 105,
        "end_line": 124,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.04,
            "pseudo_dstar_susp": 0.004651162790697674,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.004651162790697674,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler._fetch#131",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler._fetch(self, url_suffix, body)",
        "snippet": "    def _fetch(self, url_suffix, body):\n        full_url = _urljoin(self._url, url_suffix)\n        last_exception = None\n        attempt = 0\n        while attempt < self._rpc_retry_attempts:\n            attempt += 1\n            if last_exception:\n                if self._rpc_log_retries:\n                    logger.info(\"Retrying attempt %r of %r (max)\" % (attempt, self._rpc_retry_attempts))\n                self._wait()  # wait for a bit and retry\n            try:\n                response = self._fetcher.fetch(full_url, body, self._connect_timeout)\n                break\n            except self._fetcher.raises as e:\n                last_exception = e\n                if self._rpc_log_retries:\n                    logger.warning(\"Failed connecting to remote scheduler %r\", self._url,\n                                   exc_info=True)\n                continue\n        else:\n            raise RPCError(\n                \"Errors (%d attempts) when connecting to remote scheduler %r\" %\n                (self._rpc_retry_attempts, self._url),\n                last_exception\n            )\n        return response",
        "begin_line": 131,
        "end_line": 156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00022331397945511388,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler._request#158",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler._request(self, url, data, attempts=3, allow_null=True)",
        "snippet": "    def _request(self, url, data, attempts=3, allow_null=True):\n        body = {'data': json.dumps(data)}\n\n        for _ in range(attempts):\n            page = self._fetch(url, body)\n            response = json.loads(page)[\"response\"]\n            if allow_null or response is not None:\n                return response\n        raise RPCError(\"Received null response from remote scheduler %r\" % self._url)",
        "begin_line": 158,
        "end_line": 166,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.metrics.MetricsCollectors.get#13",
        "src_path": "luigi/metrics.py",
        "class_name": "luigi.metrics.MetricsCollectors",
        "signature": "luigi.metrics.MetricsCollectors.get(cls, which)",
        "snippet": "    def get(cls, which):\n        if which == MetricsCollectors.none:\n            return NoMetricsCollector()\n        elif which == MetricsCollectors.datadog:\n            from luigi.contrib.datadog_metric import DatadogMetricsCollector\n            return DatadogMetricsCollector()\n        else:\n            raise ValueError(\"MetricsCollectors value ' {0} ' isn't supported\", which)",
        "begin_line": 13,
        "end_line": 20,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01818181818181818,
            "pseudo_dstar_susp": 0.004784688995215311,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.004784688995215311,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.metrics.NoMetricsCollector.__init__#54",
        "src_path": "luigi/metrics.py",
        "class_name": "luigi.metrics.NoMetricsCollector",
        "signature": "luigi.metrics.NoMetricsCollector.__init__(self)",
        "snippet": "    def __init__(self):\n        pass",
        "begin_line": 54,
        "end_line": 55,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006839945280437756,
            "pseudo_dstar_susp": 0.002325581395348837,
            "pseudo_tarantula_susp": 0.0005333333333333334,
            "pseudo_op2_susp": 0.002325581395348837,
            "pseudo_barinel_susp": 0.0005333333333333334
        }
    },
    {
        "name": "luigi.metrics.NoMetricsCollector.handle_task_started#57",
        "src_path": "luigi/metrics.py",
        "class_name": "luigi.metrics.NoMetricsCollector",
        "signature": "luigi.metrics.NoMetricsCollector.handle_task_started(self, task)",
        "snippet": "    def handle_task_started(self, task):\n        pass",
        "begin_line": 57,
        "end_line": 58,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005268703898840885,
            "pseudo_dstar_susp": 0.0006724949562878278,
            "pseudo_tarantula_susp": 0.0005361930294906167,
            "pseudo_op2_susp": 0.0006724949562878278,
            "pseudo_barinel_susp": 0.0005361930294906167
        }
    },
    {
        "name": "luigi.metrics.NoMetricsCollector.handle_task_failed#60",
        "src_path": "luigi/metrics.py",
        "class_name": "luigi.metrics.NoMetricsCollector",
        "signature": "luigi.metrics.NoMetricsCollector.handle_task_failed(self, task)",
        "snippet": "    def handle_task_failed(self, task):\n        pass",
        "begin_line": 60,
        "end_line": 61,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004909180166912126,
            "pseudo_dstar_susp": 0.0004909180166912126,
            "pseudo_tarantula_susp": 0.0005743825387708214,
            "pseudo_op2_susp": 0.0004909180166912126,
            "pseudo_barinel_susp": 0.0005743825387708214
        }
    },
    {
        "name": "luigi.metrics.NoMetricsCollector.handle_task_disabled#63",
        "src_path": "luigi/metrics.py",
        "class_name": "luigi.metrics.NoMetricsCollector",
        "signature": "luigi.metrics.NoMetricsCollector.handle_task_disabled(self, task, config)",
        "snippet": "    def handle_task_disabled(self, task, config):\n        pass",
        "begin_line": 63,
        "end_line": 64,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0001737921445950643,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.metrics.NoMetricsCollector.handle_task_done#66",
        "src_path": "luigi/metrics.py",
        "class_name": "luigi.metrics.NoMetricsCollector",
        "signature": "luigi.metrics.NoMetricsCollector.handle_task_done(self, task)",
        "snippet": "    def handle_task_done(self, task):\n        pass",
        "begin_line": 66,
        "end_line": 67,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005938242280285036,
            "pseudo_dstar_susp": 0.0007012622720897616,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007012622720897616,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.server.cors.__init__#88",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server.cors",
        "signature": "luigi.server.cors.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        super(cors, self).__init__(*args, **kwargs)\n        self.allowed_origins = set(i for i in self.allowed_origins if i not in ['*', 'null'])",
        "begin_line": 88,
        "end_line": 90,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021101498206372652,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.server.RPCHandler.__init__#98",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server.RPCHandler",
        "signature": "luigi.server.RPCHandler.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        super(RPCHandler, self).__init__(*args, **kwargs)\n        self._cors_config = cors()",
        "begin_line": 98,
        "end_line": 100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016041065126724414,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.server.RPCHandler.initialize#102",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server.RPCHandler",
        "signature": "luigi.server.RPCHandler.initialize(self, scheduler)",
        "snippet": "    def initialize(self, scheduler):\n        self._scheduler = scheduler",
        "begin_line": 102,
        "end_line": 103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016041065126724414,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.server.RPCHandler.options#105",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server.RPCHandler",
        "signature": "luigi.server.RPCHandler.options(self, *args)",
        "snippet": "    def options(self, *args):\n        if self._cors_config.enabled:\n            self._handle_cors_preflight()\n\n        self.set_status(204)\n        self.finish()",
        "begin_line": 105,
        "end_line": 110,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.server.RPCHandler.get#112",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server.RPCHandler",
        "signature": "luigi.server.RPCHandler.get(self, method)",
        "snippet": "    def get(self, method):\n        if method not in RPC_METHODS:\n            self.send_error(404)\n            return\n        payload = self.get_argument('data', default=\"{}\")\n        arguments = json.loads(payload)\n\n        if hasattr(self._scheduler, method):\n            result = getattr(self._scheduler, method)(**arguments)\n\n            if self._cors_config.enabled:\n                self._handle_cors()\n\n            self.write({\"response\": result})  # wrap all json response in a dictionary\n        else:\n            self.send_error(404)",
        "begin_line": 112,
        "end_line": 127,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.server.RPCHandler._handle_cors_preflight#131",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server.RPCHandler",
        "signature": "luigi.server.RPCHandler._handle_cors_preflight(self)",
        "snippet": "    def _handle_cors_preflight(self):\n        origin = self.request.headers.get('Origin')\n        if not origin:\n            return\n\n        if origin == 'null':\n            if self._cors_config.allow_null_origin:\n                self.set_header('Access-Control-Allow-Origin', 'null')\n                self._set_other_cors_headers()\n        else:\n            if self._cors_config.allow_any_origin:\n                self.set_header('Access-Control-Allow-Origin', '*')\n                self._set_other_cors_headers()\n            elif origin in self._cors_config.allowed_origins:\n                self.set_header('Access-Control-Allow-Origin', origin)\n                self._set_other_cors_headers()",
        "begin_line": 131,
        "end_line": 146,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.server.RPCHandler._handle_cors#148",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server.RPCHandler",
        "signature": "luigi.server.RPCHandler._handle_cors(self)",
        "snippet": "    def _handle_cors(self):\n        origin = self.request.headers.get('Origin')\n        if not origin:\n            return\n\n        if origin == 'null':\n            if self._cors_config.allow_null_origin:\n                self.set_header('Access-Control-Allow-Origin', 'null')\n        else:\n            if self._cors_config.allow_any_origin:\n                self.set_header('Access-Control-Allow-Origin', '*')\n            elif origin in self._cors_config.allowed_origins:\n                self.set_header('Access-Control-Allow-Origin', origin)\n                self.set_header('Vary', 'Origin')",
        "begin_line": 148,
        "end_line": 161,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.server.RPCHandler._set_other_cors_headers#163",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server.RPCHandler",
        "signature": "luigi.server.RPCHandler._set_other_cors_headers(self)",
        "snippet": "    def _set_other_cors_headers(self):\n        self.set_header('Access-Control-Max-Age', str(self._cors_config.max_age))\n        self.set_header('Access-Control-Allow-Methods', self._cors_config.allowed_methods)\n        self.set_header('Access-Control-Allow-Headers', self._cors_config.allowed_headers)\n        if self._cors_config.allow_credentials:\n            self.set_header('Access-Control-Allow-Credentials', 'true')\n        if self._cors_config.exposed_headers:\n            self.set_header('Access-Control-Expose-Headers', self._cors_config.exposed_headers)",
        "begin_line": 163,
        "end_line": 170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.server.BaseTaskHistoryHandler.initialize#174",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server.BaseTaskHistoryHandler",
        "signature": "luigi.server.BaseTaskHistoryHandler.initialize(self, scheduler)",
        "snippet": "    def initialize(self, scheduler):\n        self._scheduler = scheduler",
        "begin_line": 174,
        "end_line": 175,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.server.from_utc#227",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server",
        "signature": "luigi.server.from_utc(utcTime, fmt=None)",
        "snippet": "def from_utc(utcTime, fmt=None):\n    \"\"\"convert UTC time string to time.struct_time: change datetime.datetime to time, return time.struct_time type\"\"\"\n    if fmt is None:\n        try_formats = [\"%Y-%m-%d %H:%M:%S.%f\", \"%Y-%m-%d %H:%M:%S\"]\n    else:\n        try_formats = [fmt]\n\n    for fmt in try_formats:\n        try:\n            time_struct = datetime.datetime.strptime(utcTime, fmt)\n        except ValueError:\n            pass\n        else:\n            date = int(time.mktime(time_struct.timetuple()))\n            return date\n    else:\n        raise ValueError(\"No UTC format matches {}\".format(utcTime))",
        "begin_line": 227,
        "end_line": 243,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.server.RootPathHandler.get#273",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server.RootPathHandler",
        "signature": "luigi.server.RootPathHandler.get(self)",
        "snippet": "    def get(self):\n        self.redirect(\"/static/visualiser/index.html\")",
        "begin_line": 273,
        "end_line": 274,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.server.app#277",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server",
        "signature": "luigi.server.app(scheduler)",
        "snippet": "def app(scheduler):\n    settings = {\"static_path\": os.path.join(os.path.dirname(__file__), \"static\"),\n                \"unescape\": tornado.escape.xhtml_unescape,\n                \"compress_response\": True,\n                }\n    handlers = [\n        (r'/api/(.*)', RPCHandler, {\"scheduler\": scheduler}),\n        (r'/', RootPathHandler, {'scheduler': scheduler}),\n        (r'/tasklist', AllRunHandler, {'scheduler': scheduler}),\n        (r'/tasklist/(.*?)', SelectedRunHandler, {'scheduler': scheduler}),\n        (r'/history', RecentRunHandler, {'scheduler': scheduler}),\n        (r'/history/by_name/(.*?)', ByNameHandler, {'scheduler': scheduler}),\n        (r'/history/by_id/(.*?)', ByIdHandler, {'scheduler': scheduler}),\n        (r'/history/by_params/(.*?)', ByParamsHandler, {'scheduler': scheduler})\n    ]\n    api_app = tornado.web.Application(handlers, **settings)\n    return api_app",
        "begin_line": 277,
        "end_line": 293,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00015941335883947074,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.fix_paths#33",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar",
        "signature": "luigi.contrib.hadoop_jar.fix_paths(job)",
        "snippet": "def fix_paths(job):\n    \"\"\"\n    Coerce input arguments to use temporary files when used for output.\n\n    Return a list of temporary file pairs (tmpfile, destination path) and\n    a list of arguments.\n\n    Converts each HdfsTarget to a string for the path.\n    \"\"\"\n    tmp_files = []\n    args = []\n    for x in job.args():\n        if isinstance(x, luigi.contrib.hdfs.HdfsTarget):  # input/output\n            if x.exists() or not job.atomic_output():  # input\n                args.append(x.path)\n            else:  # output\n                x_path_no_slash = x.path[:-1] if x.path[-1] == '/' else x.path\n                y = luigi.contrib.hdfs.HdfsTarget(x_path_no_slash + '-luigi-tmp-%09d' % random.randrange(0, 1e10))\n                tmp_files.append((y, x_path_no_slash))\n                logger.info('Using temp path: %s for path %s', y.path, x.path)\n                args.append(y.path)\n        else:\n            try:\n                # hopefully the target has a path to use\n                args.append(x.path)\n            except AttributeError:\n                # if there's no path then hope converting it to a string will work\n                args.append(str(x))\n\n    return (tmp_files, args)",
        "begin_line": 33,
        "end_line": 62,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.HadoopJarJobRunner.__init__#74",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar.HadoopJarJobRunner",
        "signature": "luigi.contrib.hadoop_jar.HadoopJarJobRunner.__init__(self)",
        "snippet": "    def __init__(self):\n        pass",
        "begin_line": 74,
        "end_line": 75,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.HadoopJarJobRunner.run_job#77",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar.HadoopJarJobRunner",
        "signature": "luigi.contrib.hadoop_jar.HadoopJarJobRunner.run_job(self, job, tracking_url_callback=None)",
        "snippet": "    def run_job(self, job, tracking_url_callback=None):\n        if tracking_url_callback is not None:\n            warnings.warn(\"tracking_url_callback argument is deprecated, task.set_tracking_url is \"\n                          \"used instead.\", DeprecationWarning)\n\n        # TODO(jcrobak): libjars, files, etc. Can refactor out of\n        # hadoop.HadoopJobRunner\n        if not job.jar():\n            raise HadoopJarJobError(\"Jar not defined\")\n\n        hadoop_arglist = luigi.contrib.hdfs.load_hadoop_cmd() + ['jar', job.jar()]\n        if job.main():\n            hadoop_arglist.append(job.main())\n\n        jobconfs = job.jobconfs()\n\n        for jc in jobconfs:\n            hadoop_arglist += ['-D' + jc]\n\n        (tmp_files, job_args) = fix_paths(job)\n\n        hadoop_arglist += job_args\n\n        ssh_config = job.ssh()\n        if ssh_config:\n            host = ssh_config.get(\"host\", None)\n            key_file = ssh_config.get(\"key_file\", None)\n            username = ssh_config.get(\"username\", None)\n            if not host or not key_file or not username:\n                raise HadoopJarJobError(\"missing some config for HadoopRemoteJarJobRunner\")\n            arglist = ['ssh', '-i', key_file,\n                       '-o', 'BatchMode=yes']  # no password prompts etc\n            if ssh_config.get(\"no_host_key_check\", False):\n                arglist += ['-o', 'UserKnownHostsFile=/dev/null',\n                            '-o', 'StrictHostKeyChecking=no']\n            arglist.append('{}@{}'.format(username, host))\n            hadoop_arglist = [pipes.quote(arg) for arg in hadoop_arglist]\n            arglist.append(' '.join(hadoop_arglist))\n        else:\n            if not os.path.exists(job.jar()):\n                logger.error(\"Can't find jar: %s, full path %s\", job.jar(),\n                             os.path.abspath(job.jar()))\n                raise HadoopJarJobError(\"job jar does not exist\")\n            arglist = hadoop_arglist\n\n        luigi.contrib.hadoop.run_and_track_hadoop_job(arglist, job.set_tracking_url)\n\n        for a, b in tmp_files:\n            a.move(b)",
        "begin_line": 77,
        "end_line": 125,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.HadoopJarJobTask.jar#133",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar.HadoopJarJobTask",
        "signature": "luigi.contrib.hadoop_jar.HadoopJarJobTask.jar(self)",
        "snippet": "    def jar(self):\n        \"\"\"\n        Path to the jar for this Hadoop Job.\n        \"\"\"\n        return None",
        "begin_line": 133,
        "end_line": 137,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.HadoopJarJobTask.main#139",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar.HadoopJarJobTask",
        "signature": "luigi.contrib.hadoop_jar.HadoopJarJobTask.main(self)",
        "snippet": "    def main(self):\n        \"\"\"\n        optional main method for this Hadoop Job.\n        \"\"\"\n        return None",
        "begin_line": 139,
        "end_line": 143,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.HadoopJarJobTask.job_runner#145",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar.HadoopJarJobTask",
        "signature": "luigi.contrib.hadoop_jar.HadoopJarJobTask.job_runner(self)",
        "snippet": "    def job_runner(self):\n        # We recommend that you define a subclass, override this method and set up your own config\n        return HadoopJarJobRunner()",
        "begin_line": 145,
        "end_line": 147,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.HadoopJarJobTask.ssh#156",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar.HadoopJarJobTask",
        "signature": "luigi.contrib.hadoop_jar.HadoopJarJobTask.ssh(self)",
        "snippet": "    def ssh(self):\n        \"\"\"\n        Set this to run hadoop command remotely via ssh. It needs to be a dict that looks like\n        {\"host\": \"myhost\", \"key_file\": None, \"username\": None, [\"no_host_key_check\": False]}\n        \"\"\"\n        return None",
        "begin_line": 156,
        "end_line": 161,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.HadoopJarJobTask.args#163",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar.HadoopJarJobTask",
        "signature": "luigi.contrib.hadoop_jar.HadoopJarJobTask.args(self)",
        "snippet": "    def args(self):\n        \"\"\"\n        Returns an array of args to pass to the job (after hadoop jar <jar> <main>).\n        \"\"\"\n        return []",
        "begin_line": 163,
        "end_line": 167,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.configuration.cfg_parser.InterpolationMissingEnvvarError.__init__#53",
        "src_path": "luigi/configuration/cfg_parser.py",
        "class_name": "luigi.configuration.cfg_parser.InterpolationMissingEnvvarError",
        "signature": "luigi.configuration.cfg_parser.InterpolationMissingEnvvarError.__init__(self, option, section, value, envvar)",
        "snippet": "    def __init__(self, option, section, value, envvar):\n        msg = (\n            \"Config refers to a nonexisting environment variable {}. \"\n            \"Section [{}], option {}={}\"\n        ).format(envvar, section, option, value)\n        InterpolationError.__init__(self, option, section, msg)",
        "begin_line": 53,
        "end_line": 58,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.configuration.cfg_parser.EnvironmentInterpolation.before_get#68",
        "src_path": "luigi/configuration/cfg_parser.py",
        "class_name": "luigi.configuration.cfg_parser.EnvironmentInterpolation",
        "signature": "luigi.configuration.cfg_parser.EnvironmentInterpolation.before_get(self, parser, section, option, value, defaults)",
        "snippet": "    def before_get(self, parser, section, option, value, defaults):\n        return self._interpolate_env(option, section, value)",
        "begin_line": 68,
        "end_line": 69,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015527950310559005,
            "pseudo_dstar_susp": 0.005050505050505051,
            "pseudo_tarantula_susp": 0.0013227513227513227,
            "pseudo_op2_susp": 0.005050505050505051,
            "pseudo_barinel_susp": 0.0013227513227513227
        }
    },
    {
        "name": "luigi.configuration.cfg_parser.EnvironmentInterpolation._interpolate_env#71",
        "src_path": "luigi/configuration/cfg_parser.py",
        "class_name": "luigi.configuration.cfg_parser.EnvironmentInterpolation",
        "signature": "luigi.configuration.cfg_parser.EnvironmentInterpolation._interpolate_env(self, option, section, value)",
        "snippet": "    def _interpolate_env(self, option, section, value):\n        rawval = value\n        parts = []\n        while value:\n            match = self._ENVRE.search(value)\n            if match is None:\n                parts.append(value)\n                break\n            envvar = match.groups()[0]\n            try:\n                envval = os.environ[envvar]\n            except KeyError:\n                raise InterpolationMissingEnvvarError(\n                    option, section, rawval, envvar)\n            start, end = match.span()\n            parts.append(value[:start])\n            parts.append(envval)\n            value = value[end:]\n        return \"\".join(parts)",
        "begin_line": 71,
        "end_line": 89,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015723270440251573,
            "pseudo_dstar_susp": 0.005263157894736842,
            "pseudo_tarantula_susp": 0.001336898395721925,
            "pseudo_op2_susp": 0.005263157894736842,
            "pseudo_barinel_susp": 0.001336898395721925
        }
    },
    {
        "name": "luigi.configuration.cfg_parser.CombinedInterpolation.before_get#102",
        "src_path": "luigi/configuration/cfg_parser.py",
        "class_name": "luigi.configuration.cfg_parser.CombinedInterpolation",
        "signature": "luigi.configuration.cfg_parser.CombinedInterpolation.before_get(self, parser, section, option, value, defaults)",
        "snippet": "    def before_get(self, parser, section, option, value, defaults):\n        for interp in self._interpolations:\n            value = interp.before_get(parser, section, option, value, defaults)\n        return value",
        "begin_line": 102,
        "end_line": 105,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015527950310559005,
            "pseudo_dstar_susp": 0.005050505050505051,
            "pseudo_tarantula_susp": 0.0013227513227513227,
            "pseudo_op2_susp": 0.005050505050505051,
            "pseudo_barinel_susp": 0.0013227513227513227
        }
    },
    {
        "name": "luigi.configuration.cfg_parser.CombinedInterpolation.before_set#112",
        "src_path": "luigi/configuration/cfg_parser.py",
        "class_name": "luigi.configuration.cfg_parser.CombinedInterpolation",
        "signature": "luigi.configuration.cfg_parser.CombinedInterpolation.before_set(self, parser, section, option, value)",
        "snippet": "    def before_set(self, parser, section, option, value):\n        for interp in self._interpolations:\n            value = interp.before_set(parser, section, option, value)\n        return value",
        "begin_line": 112,
        "end_line": 115,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0034965034965034965,
            "pseudo_dstar_susp": 0.005988023952095809,
            "pseudo_tarantula_susp": 0.001834862385321101,
            "pseudo_op2_susp": 0.005988023952095809,
            "pseudo_barinel_susp": 0.001834862385321101
        }
    },
    {
        "name": "luigi.configuration.cfg_parser.CombinedInterpolation.before_write#117",
        "src_path": "luigi/configuration/cfg_parser.py",
        "class_name": "luigi.configuration.cfg_parser.CombinedInterpolation",
        "signature": "luigi.configuration.cfg_parser.CombinedInterpolation.before_write(self, parser, section, option, value)",
        "snippet": "    def before_write(self, parser, section, option, value):\n        for interp in self._interpolations:\n            value = interp.before_write(parser, section, option, value)\n        return value",
        "begin_line": 117,
        "end_line": 120,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.configuration.cfg_parser.LuigiConfigParser.reload#146",
        "src_path": "luigi/configuration/cfg_parser.py",
        "class_name": "luigi.configuration.cfg_parser.LuigiConfigParser",
        "signature": "luigi.configuration.cfg_parser.LuigiConfigParser.reload(cls)",
        "snippet": "    def reload(cls):\n        # Warn about deprecated old-style config paths.\n        deprecated_paths = [p for p in cls._config_paths if os.path.basename(p) == 'client.cfg' and os.path.exists(p)]\n        if deprecated_paths:\n            warnings.warn(\"Luigi configuration files named 'client.cfg' are deprecated if favor of 'luigi.cfg'. \" +\n                          \"Found: {paths!r}\".format(paths=deprecated_paths),\n                          DeprecationWarning)\n\n        return cls.instance().read(cls._config_paths)",
        "begin_line": 146,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.configuration.cfg_parser.LuigiConfigParser._get_with_default#156",
        "src_path": "luigi/configuration/cfg_parser.py",
        "class_name": "luigi.configuration.cfg_parser.LuigiConfigParser",
        "signature": "luigi.configuration.cfg_parser.LuigiConfigParser._get_with_default(self, method, section, option, default, expected_type=None, **kwargs)",
        "snippet": "    def _get_with_default(self, method, section, option, default, expected_type=None, **kwargs):\n        \"\"\"\n        Gets the value of the section/option using method.\n\n        Returns default if value is not found.\n\n        Raises an exception if the default value is not None and doesn't match the expected_type.\n        \"\"\"\n        try:\n            return method(self, section, option, **kwargs)\n        except (NoOptionError, NoSectionError):\n            if default is LuigiConfigParser.NO_DEFAULT:\n                raise\n            if expected_type is not None and default is not None and \\\n               not isinstance(default, expected_type):\n                raise\n            return default",
        "begin_line": 156,
        "end_line": 172,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0023094688221709007,
            "pseudo_dstar_susp": 0.030303030303030304,
            "pseudo_tarantula_susp": 0.0011441647597254005,
            "pseudo_op2_susp": 0.030303030303030304,
            "pseudo_barinel_susp": 0.0011441647597254005
        }
    },
    {
        "name": "luigi.configuration.cfg_parser.LuigiConfigParser.get#174",
        "src_path": "luigi/configuration/cfg_parser.py",
        "class_name": "luigi.configuration.cfg_parser.LuigiConfigParser",
        "signature": "luigi.configuration.cfg_parser.LuigiConfigParser.get(self, section, option, default=NO_DEFAULT, **kwargs)",
        "snippet": "    def get(self, section, option, default=NO_DEFAULT, **kwargs):\n        return self._get_with_default(ConfigParser.get, section, option, default, **kwargs)",
        "begin_line": 174,
        "end_line": 175,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0023094688221709007,
            "pseudo_dstar_susp": 0.030303030303030304,
            "pseudo_tarantula_susp": 0.0011441647597254005,
            "pseudo_op2_susp": 0.030303030303030304,
            "pseudo_barinel_susp": 0.0011441647597254005
        }
    },
    {
        "name": "luigi.configuration.cfg_parser.LuigiConfigParser.getboolean#177",
        "src_path": "luigi/configuration/cfg_parser.py",
        "class_name": "luigi.configuration.cfg_parser.LuigiConfigParser",
        "signature": "luigi.configuration.cfg_parser.LuigiConfigParser.getboolean(self, section, option, default=NO_DEFAULT)",
        "snippet": "    def getboolean(self, section, option, default=NO_DEFAULT):\n        return self._get_with_default(ConfigParser.getboolean, section, option, default, bool)",
        "begin_line": 177,
        "end_line": 178,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004757373929590866,
            "pseudo_dstar_susp": 0.0004757373929590866,
            "pseudo_tarantula_susp": 0.00047961630695443646,
            "pseudo_op2_susp": 0.0004757373929590866,
            "pseudo_barinel_susp": 0.00047961630695443646
        }
    },
    {
        "name": "luigi.configuration.cfg_parser.LuigiConfigParser.getint#180",
        "src_path": "luigi/configuration/cfg_parser.py",
        "class_name": "luigi.configuration.cfg_parser.LuigiConfigParser",
        "signature": "luigi.configuration.cfg_parser.LuigiConfigParser.getint(self, section, option, default=NO_DEFAULT)",
        "snippet": "    def getint(self, section, option, default=NO_DEFAULT):\n        return self._get_with_default(ConfigParser.getint, section, option, default, int)",
        "begin_line": 180,
        "end_line": 181,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00015875535799333228,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.configuration.cfg_parser.LuigiConfigParser.getfloat#183",
        "src_path": "luigi/configuration/cfg_parser.py",
        "class_name": "luigi.configuration.cfg_parser.LuigiConfigParser",
        "signature": "luigi.configuration.cfg_parser.LuigiConfigParser.getfloat(self, section, option, default=NO_DEFAULT)",
        "snippet": "    def getfloat(self, section, option, default=NO_DEFAULT):\n        return self._get_with_default(ConfigParser.getfloat, section, option, default, float)",
        "begin_line": 183,
        "end_line": 184,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0001591596371160274,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.configuration.cfg_parser.LuigiConfigParser.getintdict#186",
        "src_path": "luigi/configuration/cfg_parser.py",
        "class_name": "luigi.configuration.cfg_parser.LuigiConfigParser",
        "signature": "luigi.configuration.cfg_parser.LuigiConfigParser.getintdict(self, section)",
        "snippet": "    def getintdict(self, section):\n        try:\n            # Exclude keys from [DEFAULT] section because in general they do not hold int values\n            return dict((key, int(value)) for key, value in self.items(section)\n                        if key not in {k for k, _ in self.items('DEFAULT')})\n        except NoSectionError:\n            return {}",
        "begin_line": 186,
        "end_line": 192,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009784735812133072,
            "pseudo_dstar_susp": 0.003289473684210526,
            "pseudo_tarantula_susp": 0.0005861664712778429,
            "pseudo_op2_susp": 0.003289473684210526,
            "pseudo_barinel_susp": 0.0005861664712778429
        }
    },
    {
        "name": "luigi.configuration.cfg_parser.LuigiConfigParser.set#194",
        "src_path": "luigi/configuration/cfg_parser.py",
        "class_name": "luigi.configuration.cfg_parser.LuigiConfigParser",
        "signature": "luigi.configuration.cfg_parser.LuigiConfigParser.set(self, section, option, value=None)",
        "snippet": "    def set(self, section, option, value=None):\n        if not ConfigParser.has_section(self, section):\n            ConfigParser.add_section(self, section)\n\n        return ConfigParser.set(self, section, option, value)",
        "begin_line": 194,
        "end_line": 198,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0034965034965034965,
            "pseudo_dstar_susp": 0.005988023952095809,
            "pseudo_tarantula_susp": 0.001834862385321101,
            "pseudo_op2_susp": 0.005988023952095809,
            "pseudo_barinel_susp": 0.001834862385321101
        }
    },
    {
        "name": "luigi.contrib.webhdfs.WebHdfsTarget.__init__#42",
        "src_path": "luigi/contrib/webhdfs.py",
        "class_name": "luigi.contrib.webhdfs.WebHdfsTarget",
        "signature": "luigi.contrib.webhdfs.WebHdfsTarget.__init__(self, path, client=None, format=None)",
        "snippet": "    def __init__(self, path, client=None, format=None):\n        super(WebHdfsTarget, self).__init__(path)\n        path = self.path\n        self.fs = client or WebHdfsClient()\n        if format is None:\n            format = get_default_format()\n\n        self.format = format",
        "begin_line": 42,
        "end_line": 49,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02702702702702703,
            "pseudo_dstar_susp": 0.002257336343115124,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.002257336343115124,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.format.FileWrapper.__init__#35",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.FileWrapper",
        "signature": "luigi.format.FileWrapper.__init__(self, file_object)",
        "snippet": "    def __init__(self, file_object):\n        self._subpipe = file_object",
        "begin_line": 35,
        "end_line": 36,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016792611251049538,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.FileWrapper.__getattr__#38",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.FileWrapper",
        "signature": "luigi.format.FileWrapper.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        # forward calls to 'write', 'close' and other methods not defined below\n        return getattr(self._subpipe, name)",
        "begin_line": 38,
        "end_line": 40,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016803898504453034,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.FileWrapper.__enter__#42",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.FileWrapper",
        "signature": "luigi.format.FileWrapper.__enter__(self, *args, **kwargs)",
        "snippet": "    def __enter__(self, *args, **kwargs):\n        # instead of returning whatever is returned by __enter__ on the subpipe\n        # this returns self, so whatever custom injected methods are still available\n        # this might cause problems with custom file_objects, but seems to work\n        # fine with standard python `file` objects which is the only default use\n        return self",
        "begin_line": 42,
        "end_line": 47,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017966223499820338,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.FileWrapper.__exit__#49",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.FileWrapper",
        "signature": "luigi.format.FileWrapper.__exit__(self, *args, **kwargs)",
        "snippet": "    def __exit__(self, *args, **kwargs):\n        return self._subpipe.__exit__(*args, **kwargs)",
        "begin_line": 49,
        "end_line": 50,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017966223499820338,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.__init__#58",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.__init__(self, command, input_pipe=None)",
        "snippet": "    def __init__(self, command, input_pipe=None):\n        \"\"\"\n        Initializes a InputPipeProcessWrapper instance.\n\n        :param command: a subprocess.Popen instance with stdin=input_pipe and\n                        stdout=subprocess.PIPE.\n                        Alternatively, just its args argument as a convenience.\n        \"\"\"\n        self._command = command\n\n        self._input_pipe = input_pipe\n        self._original_input = True\n\n        if input_pipe is not None:\n            try:\n                input_pipe.fileno()\n            except AttributeError:\n                # subprocess require a fileno to work, if not present we copy to disk first\n                self._original_input = False\n                f = tempfile.NamedTemporaryFile('wb', prefix='luigi-process_tmp', delete=False)\n                self._tmp_file = f.name\n                while True:\n                    chunk = input_pipe.read(io.DEFAULT_BUFFER_SIZE)\n                    if not chunk:\n                        break\n                    f.write(chunk)\n                input_pipe.close()\n                f.close()\n                self._input_pipe = FileWrapper(io.BufferedReader(io.FileIO(self._tmp_file, 'r')))\n\n        self._process = command if isinstance(command, subprocess.Popen) else self.create_subprocess(command)\n        # we want to keep a circular reference to avoid garbage collection\n        # when the object is used in, e.g., pipe.read()\n        self._process._selfref = self",
        "begin_line": 58,
        "end_line": 91,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019747235387045813,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.create_subprocess#93",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.create_subprocess(self, command)",
        "snippet": "    def create_subprocess(self, command):\n        \"\"\"\n        http://www.chiark.greenend.org.uk/ucgi/~cjwatson/blosxom/2009-07-02-python-sigpipe.html\n        \"\"\"\n\n        def subprocess_setup():\n            # Python installs a SIGPIPE handler by default. This is usually not what\n            # non-Python subprocesses expect.\n            signal.signal(signal.SIGPIPE, signal.SIG_DFL)\n\n        return subprocess.Popen(command,\n                                stdin=self._input_pipe,\n                                stdout=subprocess.PIPE,\n                                preexec_fn=subprocess_setup,\n                                close_fds=True)",
        "begin_line": 93,
        "end_line": 107,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00018864365214110544,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.subprocess_setup#98",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.subprocess_setup()",
        "snippet": "        def subprocess_setup():\n            # Python installs a SIGPIPE handler by default. This is usually not what\n            # non-Python subprocesses expect.\n            signal.signal(signal.SIGPIPE, signal.SIG_DFL)",
        "begin_line": 98,
        "end_line": 101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00018864365214110544,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper._finish#109",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper._finish(self)",
        "snippet": "    def _finish(self):\n        # Need to close this before input_pipe to get all SIGPIPE messages correctly\n        self._process.stdout.close()\n        if not self._original_input and os.path.exists(self._tmp_file):\n            os.remove(self._tmp_file)\n\n        if self._input_pipe is not None:\n            self._input_pipe.close()\n\n        self._process.wait()  # deadlock?\n        if self._process.returncode not in (0, 141, 128 - 141):\n            # 141 == 128 + 13 == 128 + SIGPIPE - normally processes exit with 128 + {reiceived SIG}\n            # 128 - 141 == -13 == -SIGPIPE, sometimes python receives -13 for some subprocesses\n            raise RuntimeError('Error reading from pipe. Subcommand exited with non-zero exit status %s.' % self._process.returncode)",
        "begin_line": 109,
        "end_line": 122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.close#124",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.close(self)",
        "snippet": "    def close(self):\n        self._finish()",
        "begin_line": 124,
        "end_line": 125,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021101498206372652,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.__del__#127",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.__del__(self)",
        "snippet": "    def __del__(self):\n        self._finish()",
        "begin_line": 127,
        "end_line": 128,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.__enter__#130",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.__enter__(self)",
        "snippet": "    def __enter__(self):\n        return self",
        "begin_line": 130,
        "end_line": 131,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002294630564479119,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.__exit__#144",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.__exit__(self, type, value, traceback)",
        "snippet": "    def __exit__(self, type, value, traceback):\n        if type:\n            self._abort()\n        else:\n            self._finish()",
        "begin_line": 144,
        "end_line": 148,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002294630564479119,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.__getattr__#150",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        if name in ['_process', '_input_pipe']:\n            raise AttributeError(name)\n        try:\n            return getattr(self._process.stdout, name)\n        except AttributeError:\n            return getattr(self._input_pipe, name)",
        "begin_line": 150,
        "end_line": 156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019327406262079628,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.__iter__#158",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.__iter__(self)",
        "snippet": "    def __iter__(self):\n        for line in self._process.stdout:\n            yield line\n        self._finish()",
        "begin_line": 158,
        "end_line": 161,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.readable#163",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.readable(self)",
        "snippet": "    def readable(self):\n        return True",
        "begin_line": 163,
        "end_line": 164,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.writable#166",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.writable(self)",
        "snippet": "    def writable(self):\n        return False",
        "begin_line": 166,
        "end_line": 167,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.seekable#169",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.seekable(self)",
        "snippet": "    def seekable(self):\n        return False",
        "begin_line": 169,
        "end_line": 170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.__init__#176",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.__init__(self, command, output_pipe=None)",
        "snippet": "    def __init__(self, command, output_pipe=None):\n        self.closed = False\n        self._command = command\n        self._output_pipe = output_pipe\n        self._process = subprocess.Popen(command,\n                                         stdin=subprocess.PIPE,\n                                         stdout=output_pipe,\n                                         close_fds=True)\n        self._flushcount = 0",
        "begin_line": 176,
        "end_line": 184,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019102196752626553,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.write#186",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.write(self, *args, **kwargs)",
        "snippet": "    def write(self, *args, **kwargs):\n        self._process.stdin.write(*args, **kwargs)\n        self._flushcount += 1\n        if self._flushcount == self.WRITES_BEFORE_FLUSH:\n            self._process.stdin.flush()\n            self._flushcount = 0",
        "begin_line": 186,
        "end_line": 191,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019102196752626553,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper._finish#197",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper._finish(self)",
        "snippet": "    def _finish(self):\n        \"\"\"\n        Closes and waits for subprocess to exit.\n        \"\"\"\n        if self._process.returncode is None:\n            self._process.stdin.flush()\n            self._process.stdin.close()\n            self._process.wait()\n            self.closed = True",
        "begin_line": 197,
        "end_line": 205,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019102196752626553,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.__del__#207",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.__del__(self)",
        "snippet": "    def __del__(self):\n        if not self.closed:\n            self.abort()",
        "begin_line": 207,
        "end_line": 209,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019102196752626553,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.__exit__#211",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.__exit__(self, type, value, traceback)",
        "snippet": "    def __exit__(self, type, value, traceback):\n        if type is None:\n            self.close()\n        else:\n            self.abort()",
        "begin_line": 211,
        "end_line": 215,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002294630564479119,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.__enter__#217",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.__enter__(self)",
        "snippet": "    def __enter__(self):\n        return self",
        "begin_line": 217,
        "end_line": 218,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002294630564479119,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.close#220",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.close(self)",
        "snippet": "    def close(self):\n        self._finish()\n        if self._process.returncode == 0:\n            if self._output_pipe is not None:\n                self._output_pipe.close()\n        else:\n            raise RuntimeError('Error when executing command %s' % self._command)",
        "begin_line": 220,
        "end_line": 226,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019102196752626553,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.__getattr__#231",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        if name in ['_process', '_output_pipe']:\n            raise AttributeError(name)\n        try:\n            return getattr(self._process.stdin, name)\n        except AttributeError:\n            return getattr(self._output_pipe, name)",
        "begin_line": 231,
        "end_line": 237,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002294630564479119,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.readable#239",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.readable(self)",
        "snippet": "    def readable(self):\n        return False",
        "begin_line": 239,
        "end_line": 240,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.writable#242",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.writable(self)",
        "snippet": "    def writable(self):\n        return True",
        "begin_line": 242,
        "end_line": 243,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.seekable#245",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.seekable(self)",
        "snippet": "    def seekable(self):\n        return False",
        "begin_line": 245,
        "end_line": 246,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.BaseWrapper.__init__#251",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.BaseWrapper",
        "signature": "luigi.format.BaseWrapper.__init__(self, stream, *args, **kwargs)",
        "snippet": "    def __init__(self, stream, *args, **kwargs):\n        self._stream = stream\n        try:\n            super(BaseWrapper, self).__init__(stream, *args, **kwargs)\n        except TypeError:\n            pass",
        "begin_line": 251,
        "end_line": 256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.BaseWrapper.__getattr__#258",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.BaseWrapper",
        "signature": "luigi.format.BaseWrapper.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        if name == '_stream':\n            raise AttributeError(name)\n        return getattr(self._stream, name)",
        "begin_line": 258,
        "end_line": 261,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.BaseWrapper.__enter__#263",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.BaseWrapper",
        "signature": "luigi.format.BaseWrapper.__enter__(self)",
        "snippet": "    def __enter__(self):\n        self._stream.__enter__()\n        return self",
        "begin_line": 263,
        "end_line": 265,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.BaseWrapper.__exit__#267",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.BaseWrapper",
        "signature": "luigi.format.BaseWrapper.__exit__(self, *args)",
        "snippet": "    def __exit__(self, *args):\n        self._stream.__exit__(*args)",
        "begin_line": 267,
        "end_line": 268,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.NewlineWrapper.__init__#280",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.NewlineWrapper",
        "signature": "luigi.format.NewlineWrapper.__init__(self, stream, newline=None)",
        "snippet": "    def __init__(self, stream, newline=None):\n        if newline is None:\n            self.newline = newline\n        else:\n            self.newline = newline.encode('ascii')\n\n        if self.newline not in (b'', b'\\r\\n', b'\\n', b'\\r', None):\n            raise ValueError(\"newline need to be one of {b'', b'\\r\\n', b'\\n', b'\\r', None}\")\n        super(NewlineWrapper, self).__init__(stream)",
        "begin_line": 280,
        "end_line": 288,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.NewlineWrapper.read#290",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.NewlineWrapper",
        "signature": "luigi.format.NewlineWrapper.read(self, n=-1)",
        "snippet": "    def read(self, n=-1):\n        b = self._stream.read(n)\n\n        if self.newline == b'':\n            return b\n\n        if self.newline is None:\n            newline = b'\\n'\n\n        return re.sub(b'(\\n|\\r\\n|\\r)', newline, b)",
        "begin_line": 290,
        "end_line": 299,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.NewlineWrapper.write#311",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.NewlineWrapper",
        "signature": "luigi.format.NewlineWrapper.write(self, b)",
        "snippet": "    def write(self, b):\n        if self.newline is None or self.newline == '':\n            newline = os.linesep.encode('ascii')\n        else:\n            newline = self.newline\n\n        self._stream.write(re.sub(b'(\\n|\\r\\n|\\r)', newline, b))",
        "begin_line": 311,
        "end_line": 317,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.MixedUnicodeBytesWrapper.__init__#324",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.MixedUnicodeBytesWrapper",
        "signature": "luigi.format.MixedUnicodeBytesWrapper.__init__(self, stream, encoding=None)",
        "snippet": "    def __init__(self, stream, encoding=None):\n        if encoding is None:\n            encoding = locale.getpreferredencoding()\n        self.encoding = encoding\n        super(MixedUnicodeBytesWrapper, self).__init__(stream)",
        "begin_line": 324,
        "end_line": 328,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.MixedUnicodeBytesWrapper.write#330",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.MixedUnicodeBytesWrapper",
        "signature": "luigi.format.MixedUnicodeBytesWrapper.write(self, b)",
        "snippet": "    def write(self, b):\n        self._stream.write(self._convert(b))",
        "begin_line": 330,
        "end_line": 331,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.MixedUnicodeBytesWrapper._convert#336",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.MixedUnicodeBytesWrapper",
        "signature": "luigi.format.MixedUnicodeBytesWrapper._convert(self, b)",
        "snippet": "    def _convert(self, b):\n        if isinstance(b, six.text_type):\n            b = b.encode(self.encoding)\n            warnings.warn('Writing unicode to byte stream', stacklevel=2)\n        return b",
        "begin_line": 336,
        "end_line": 340,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.Format.__rshift__#356",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.Format",
        "signature": "luigi.format.Format.__rshift__(a, b)",
        "snippet": "    def __rshift__(a, b):\n        return ChainFormat(a, b)",
        "begin_line": 356,
        "end_line": 357,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002294630564479119,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.ChainFormat.__init__#362",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.ChainFormat",
        "signature": "luigi.format.ChainFormat.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        self.args = args\n        try:\n            self.input = args[0].input\n        except AttributeError:\n            pass\n        try:\n            self.output = args[-1].output\n        except AttributeError:\n            pass\n        if not kwargs.get('check_consistency', True):\n            return\n        for x in range(len(args) - 1):\n            try:\n                if args[x].output != args[x + 1].input:\n                    raise TypeError(\n                        'The format chaining is not valid, %s expect %s'\n                        ' but %s provide %s' % (\n                            args[x + 1].__class__.__name__,\n                            args[x + 1].input,\n                            args[x].__class__.__name__,\n                            args[x].output,\n                        )\n                    )\n            except AttributeError:\n                pass",
        "begin_line": 362,
        "end_line": 387,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002294630564479119,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.ChainFormat.pipe_reader#389",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.ChainFormat",
        "signature": "luigi.format.ChainFormat.pipe_reader(self, input_pipe)",
        "snippet": "    def pipe_reader(self, input_pipe):\n        for x in reversed(self.args):\n            input_pipe = x.pipe_reader(input_pipe)\n        return input_pipe",
        "begin_line": 389,
        "end_line": 392,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.ChainFormat.pipe_writer#394",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.ChainFormat",
        "signature": "luigi.format.ChainFormat.pipe_writer(self, output_pipe)",
        "snippet": "    def pipe_writer(self, output_pipe):\n        for x in reversed(self.args):\n            output_pipe = x.pipe_writer(output_pipe)\n        return output_pipe",
        "begin_line": 394,
        "end_line": 397,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.TextWrapper.__exit__#402",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.TextWrapper",
        "signature": "luigi.format.TextWrapper.__exit__(self, *args)",
        "snippet": "    def __exit__(self, *args):\n        # io.TextIOWrapper close the file on __exit__, let the underlying file decide\n        if not self.closed and self.writable():\n            super(TextWrapper, self).flush()\n\n        self._stream.__exit__(*args)",
        "begin_line": 402,
        "end_line": 407,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016739203213927018,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.TextWrapper.__del__#409",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.TextWrapper",
        "signature": "luigi.format.TextWrapper.__del__(self, *args)",
        "snippet": "    def __del__(self, *args):\n        # io.TextIOWrapper close the file on __del__, let the underlying file decide\n        if not self.closed and self.writable():\n            super(TextWrapper, self).flush()\n\n        try:\n            self._stream.__del__(*args)\n        except AttributeError:\n            pass",
        "begin_line": 409,
        "end_line": 417,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017966223499820338,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.TextWrapper.__init__#419",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.TextWrapper",
        "signature": "luigi.format.TextWrapper.__init__(self, stream, *args, **kwargs)",
        "snippet": "    def __init__(self, stream, *args, **kwargs):\n        self._stream = stream\n        try:\n            super(TextWrapper, self).__init__(stream, *args, **kwargs)\n        except TypeError:\n            pass",
        "begin_line": 419,
        "end_line": 424,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016283992835043154,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.TextWrapper.__getattr__#426",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.TextWrapper",
        "signature": "luigi.format.TextWrapper.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        if name == '_stream':\n            raise AttributeError(name)\n        return getattr(self._stream, name)",
        "begin_line": 426,
        "end_line": 429,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016666666666666666,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.TextWrapper.__enter__#431",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.TextWrapper",
        "signature": "luigi.format.TextWrapper.__enter__(self)",
        "snippet": "    def __enter__(self):\n        self._stream.__enter__()\n        return self",
        "begin_line": 431,
        "end_line": 433,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016652789342214822,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.NopFormat.pipe_reader#437",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.NopFormat",
        "signature": "luigi.format.NopFormat.pipe_reader(self, input_pipe)",
        "snippet": "    def pipe_reader(self, input_pipe):\n        return input_pipe",
        "begin_line": 437,
        "end_line": 438,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.NopFormat.pipe_writer#440",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.NopFormat",
        "signature": "luigi.format.NopFormat.pipe_writer(self, output_pipe)",
        "snippet": "    def pipe_writer(self, output_pipe):\n        return output_pipe",
        "begin_line": 440,
        "end_line": 441,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.WrappedFormat.__init__#446",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.WrappedFormat",
        "signature": "luigi.format.WrappedFormat.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        self.args = args\n        self.kwargs = kwargs",
        "begin_line": 446,
        "end_line": 448,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.WrappedFormat.pipe_reader#450",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.WrappedFormat",
        "signature": "luigi.format.WrappedFormat.pipe_reader(self, input_pipe)",
        "snippet": "    def pipe_reader(self, input_pipe):\n        return self.wrapper_cls(input_pipe, *self.args, **self.kwargs)",
        "begin_line": 450,
        "end_line": 451,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016680567139282736,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.WrappedFormat.pipe_writer#453",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.WrappedFormat",
        "signature": "luigi.format.WrappedFormat.pipe_writer(self, output_pipe)",
        "snippet": "    def pipe_writer(self, output_pipe):\n        return self.wrapper_cls(output_pipe, *self.args, **self.kwargs)",
        "begin_line": 453,
        "end_line": 454,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016299918500407498,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.GzipFormat.pipe_reader#485",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.GzipFormat",
        "signature": "luigi.format.GzipFormat.pipe_reader(self, input_pipe)",
        "snippet": "    def pipe_reader(self, input_pipe):\n        return InputPipeProcessWrapper(['gunzip'], input_pipe)",
        "begin_line": 485,
        "end_line": 486,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021101498206372652,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.GzipFormat.pipe_writer#488",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.GzipFormat",
        "signature": "luigi.format.GzipFormat.pipe_writer(self, output_pipe)",
        "snippet": "    def pipe_writer(self, output_pipe):\n        args = ['gzip']\n        if self.compression_level is not None:\n            args.append('-' + str(int(self.compression_level)))\n        return OutputPipeProcessWrapper(args, output_pipe)",
        "begin_line": 488,
        "end_line": 492,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019747235387045813,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.Bzip2Format.pipe_reader#500",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.Bzip2Format",
        "signature": "luigi.format.Bzip2Format.pipe_reader(self, input_pipe)",
        "snippet": "    def pipe_reader(self, input_pipe):\n        return InputPipeProcessWrapper(['bzcat'], input_pipe)",
        "begin_line": 500,
        "end_line": 501,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.Bzip2Format.pipe_writer#503",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.Bzip2Format",
        "signature": "luigi.format.Bzip2Format.pipe_writer(self, output_pipe)",
        "snippet": "    def pipe_writer(self, output_pipe):\n        return OutputPipeProcessWrapper(['bzip2'], output_pipe)",
        "begin_line": 503,
        "end_line": 504,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.format.get_default_format#516",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format",
        "signature": "luigi.format.get_default_format()",
        "snippet": "def get_default_format():\n    if six.PY3:\n        return Text\n    elif os.linesep == '\\n':\n        return Nop\n    else:\n        return SysNewLine",
        "begin_line": 516,
        "end_line": 522,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015873015873015873,
            "pseudo_dstar_susp": 0.0045871559633027525,
            "pseudo_tarantula_susp": 0.0015337423312883436,
            "pseudo_op2_susp": 0.0045871559633027525,
            "pseudo_barinel_susp": 0.0015337423312883436
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.pig_home#44",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.pig_home(self)",
        "snippet": "    def pig_home(self):\n        return configuration.get_config().get('pig', 'home', '/usr/share/pig')",
        "begin_line": 44,
        "end_line": 45,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.pig_command_path#47",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.pig_command_path(self)",
        "snippet": "    def pig_command_path(self):\n        return os.path.join(self.pig_home(), \"bin/pig\")",
        "begin_line": 47,
        "end_line": 48,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.pig_env_vars#50",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.pig_env_vars(self)",
        "snippet": "    def pig_env_vars(self):\n        \"\"\"\n        Dictionary of environment variables that should be set when running Pig.\n\n        Ex::\n            return { 'PIG_CLASSPATH': '/your/path' }\n        \"\"\"\n        return {}",
        "begin_line": 50,
        "end_line": 57,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.pig_properties#59",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.pig_properties(self)",
        "snippet": "    def pig_properties(self):\n        \"\"\"\n        Dictionary of properties that should be set when running Pig.\n\n        Example::\n\n            return { 'pig.additional.jars':'/path/to/your/jar' }\n        \"\"\"\n        return {}",
        "begin_line": 59,
        "end_line": 67,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.pig_parameters#69",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.pig_parameters(self)",
        "snippet": "    def pig_parameters(self):\n        \"\"\"\n        Dictionary of parameters that should be set for the Pig job.\n\n        Example::\n\n            return { 'YOUR_PARAM_NAME':'Your param value' }\n        \"\"\"\n        return {}",
        "begin_line": 69,
        "end_line": 77,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.pig_options#79",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.pig_options(self)",
        "snippet": "    def pig_options(self):\n        \"\"\"\n        List of options that will be appended to the Pig command.\n\n        Example::\n\n            return ['-x', 'local']\n        \"\"\"\n        return []",
        "begin_line": 79,
        "end_line": 87,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask._build_pig_cmd#99",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask._build_pig_cmd(self)",
        "snippet": "    def _build_pig_cmd(self):\n        opts = self.pig_options()\n\n        def line(k, v):\n            return ('%s=%s%s' % (k, v, os.linesep)).encode('utf-8')\n\n        with tempfile.NamedTemporaryFile() as param_file, tempfile.NamedTemporaryFile() as prop_file:\n            if self.pig_parameters():\n                items = six.iteritems(self.pig_parameters())\n                param_file.writelines(line(k, v) for (k, v) in items)\n                param_file.flush()\n                opts.append('-param_file')\n                opts.append(param_file.name)\n\n            if self.pig_properties():\n                items = six.iteritems(self.pig_properties())\n                prop_file.writelines(line(k, v) for (k, v) in items)\n                prop_file.flush()\n                opts.append('-propertyFile')\n                opts.append(prop_file.name)\n\n            cmd = [self.pig_command_path()] + opts + [\"-f\", self.pig_script_path()]\n\n            logger.info(subprocess.list2cmdline(cmd))\n            yield cmd",
        "begin_line": 99,
        "end_line": 123,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.line#102",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.line(k, v)",
        "snippet": "        def line(k, v):\n            return ('%s=%s%s' % (k, v, os.linesep)).encode('utf-8')",
        "begin_line": 102,
        "end_line": 103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.run#125",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.run(self)",
        "snippet": "    def run(self):\n        with self._build_pig_cmd() as cmd:\n            self.track_and_progress(cmd)",
        "begin_line": 125,
        "end_line": 127,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.track_and_progress#129",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.track_and_progress(self, cmd)",
        "snippet": "    def track_and_progress(self, cmd):\n        temp_stdout = tempfile.TemporaryFile('wb')\n        env = os.environ.copy()\n        env['PIG_HOME'] = self.pig_home()\n        for k, v in six.iteritems(self.pig_env_vars()):\n            env[k] = v\n\n        proc = subprocess.Popen(cmd, shell=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env)\n        reads = [proc.stderr.fileno(), proc.stdout.fileno()]\n        # tracking the possible problems with this job\n        err_lines = []\n        with PigRunContext():\n            while proc.poll() is None:\n                ret = select.select(reads, [], [])\n                for fd in ret[0]:\n                    if fd == proc.stderr.fileno():\n                        line = proc.stderr.readline().decode('utf8')\n                        err_lines.append(line)\n                    if fd == proc.stdout.fileno():\n                        line_bytes = proc.stdout.readline()\n                        temp_stdout.write(line_bytes)\n                        line = line_bytes.decode('utf8')\n\n                err_line = line.lower()\n                if err_line.find('More information at:') != -1:\n                    logger.info(err_line.split('more information at: ')[-1].strip())\n                if err_line.find(' - '):\n                    t = err_line.split(' - ')[-1].strip()\n                    if t != \"\":\n                        logger.info(t)\n\n        # Read the rest + stdout\n        err = ''.join(err_lines + [an_err_line.decode('utf8') for an_err_line in proc.stderr])\n        if proc.returncode == 0:\n            logger.info(\"Job completed successfully!\")\n        else:\n            logger.error(\"Error when running script:\\n%s\", self.pig_script_path())\n            logger.error(err)\n            raise PigJobError(\"Pig script failed with return value: %s\" % (proc.returncode,), err=err)",
        "begin_line": 129,
        "end_line": 167,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.pig.PigRunContext.__init__#171",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigRunContext",
        "signature": "luigi.contrib.pig.PigRunContext.__init__(self)",
        "snippet": "    def __init__(self):\n        self.job_id = None",
        "begin_line": 171,
        "end_line": 172,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.pig.PigRunContext.__enter__#174",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigRunContext",
        "signature": "luigi.contrib.pig.PigRunContext.__enter__(self)",
        "snippet": "    def __enter__(self):\n        self.__old_signal = signal.getsignal(signal.SIGTERM)\n        signal.signal(signal.SIGTERM, self.kill_job)\n        return self",
        "begin_line": 174,
        "end_line": 177,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.pig.PigRunContext.__exit__#187",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigRunContext",
        "signature": "luigi.contrib.pig.PigRunContext.__exit__(self, exc_type, exc_val, exc_tb)",
        "snippet": "    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is KeyboardInterrupt:\n            self.kill_job()\n        signal.signal(signal.SIGTERM, self.__old_signal)",
        "begin_line": 187,
        "end_line": 190,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobError.__init__#194",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobError",
        "signature": "luigi.contrib.pig.PigJobError.__init__(self, message, out=None, err=None)",
        "snippet": "    def __init__(self, message, out=None, err=None):\n        super(PigJobError, self).__init__(message, out, err)\n        self.message = message\n        self.out = out\n        self.err = err",
        "begin_line": 194,
        "end_line": 198,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift._CredentialsMixin.configuration_section#48",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift._CredentialsMixin",
        "signature": "luigi.contrib.redshift._CredentialsMixin.configuration_section(self)",
        "snippet": "    def configuration_section(self):\n        \"\"\"\n        Override to change the configuration section used\n        to obtain default credentials.\n        \"\"\"\n        return 'redshift'",
        "begin_line": 48,
        "end_line": 53,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.000177430801987225,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift._CredentialsMixin.aws_access_key_id#56",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift._CredentialsMixin",
        "signature": "luigi.contrib.redshift._CredentialsMixin.aws_access_key_id(self)",
        "snippet": "    def aws_access_key_id(self):\n        \"\"\"\n        Override to return the key id.\n        \"\"\"\n        return self._get_configuration_attribute('aws_access_key_id')",
        "begin_line": 56,
        "end_line": 60,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift._CredentialsMixin.aws_secret_access_key#63",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift._CredentialsMixin",
        "signature": "luigi.contrib.redshift._CredentialsMixin.aws_secret_access_key(self)",
        "snippet": "    def aws_secret_access_key(self):\n        \"\"\"\n        Override to return the secret access key.\n        \"\"\"\n        return self._get_configuration_attribute('aws_secret_access_key')",
        "begin_line": 63,
        "end_line": 67,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift._CredentialsMixin.aws_account_id#70",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift._CredentialsMixin",
        "signature": "luigi.contrib.redshift._CredentialsMixin.aws_account_id(self)",
        "snippet": "    def aws_account_id(self):\n        \"\"\"\n        Override to return the account id.\n        \"\"\"\n        return self._get_configuration_attribute('aws_account_id')",
        "begin_line": 70,
        "end_line": 74,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017966223499820338,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift._CredentialsMixin.aws_session_token#84",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift._CredentialsMixin",
        "signature": "luigi.contrib.redshift._CredentialsMixin.aws_session_token(self)",
        "snippet": "    def aws_session_token(self):\n        \"\"\"\n        Override to return the session token.\n        \"\"\"\n        return self._get_configuration_attribute('aws_session_token')",
        "begin_line": 84,
        "end_line": 88,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.000181422351233672,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift._CredentialsMixin._get_configuration_attribute#90",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift._CredentialsMixin",
        "signature": "luigi.contrib.redshift._CredentialsMixin._get_configuration_attribute(self, attribute)",
        "snippet": "    def _get_configuration_attribute(self, attribute):\n        config = luigi.configuration.get_config()\n\n        value = config.get(self.configuration_section, attribute, default=None)\n\n        if not value:\n            value = os.environ.get(attribute.upper(), None)\n\n        return value",
        "begin_line": 90,
        "end_line": 98,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0001781895937277263,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift._CredentialsMixin._credentials#100",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift._CredentialsMixin",
        "signature": "luigi.contrib.redshift._CredentialsMixin._credentials(self)",
        "snippet": "    def _credentials(self):\n        \"\"\"\n        Return a credential string for the provided task. If no valid\n        credentials are set, raise a NotImplementedError.\n        \"\"\"\n\n        if self.aws_account_id and self.aws_arn_role_name:\n            return 'aws_iam_role=arn:aws:iam::{id}:role/{role}'.format(\n                id=self.aws_account_id,\n                role=self.aws_arn_role_name\n            )\n        elif self.aws_access_key_id and self.aws_secret_access_key:\n            return 'aws_access_key_id={key};aws_secret_access_key={secret}{opt}'.format(\n                key=self.aws_access_key_id,\n                secret=self.aws_secret_access_key,\n                opt=';token={}'.format(self.aws_session_token) if self.aws_session_token else ''\n            )\n        else:\n            raise NotImplementedError(\"Missing Credentials. \"\n                                      \"Ensure one of the pairs of auth args below are set \"\n                                      \"in a configuration file, environment variables or by \"\n                                      \"being overridden in the task: \"\n                                      \"'aws_access_key_id' AND 'aws_secret_access_key' OR \"\n                                      \"'aws_account_id' AND 'aws_arn_role_name'\")",
        "begin_line": 100,
        "end_line": 123,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.table_attributes#213",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.table_attributes(self)",
        "snippet": "    def table_attributes(self):\n        \"\"\"\n        Add extra table attributes, for example:\n\n        DISTSTYLE KEY\n        DISTKEY (MY_FIELD)\n        SORTKEY (MY_FIELD_2, MY_FIELD_3)\n        \"\"\"\n        return ''",
        "begin_line": 213,
        "end_line": 221,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.do_truncate_table#234",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.do_truncate_table(self)",
        "snippet": "    def do_truncate_table(self):\n        \"\"\"\n        Return True if table should be truncated before copying new data in.\n        \"\"\"\n        return False",
        "begin_line": 234,
        "end_line": 238,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0001781895937277263,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.do_prune#240",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.do_prune(self)",
        "snippet": "    def do_prune(self):\n        \"\"\"\n        Return True if prune_table, prune_column, and prune_date are implemented.\n        If only a subset of prune variables are override, an exception is raised to remind the user to implement all or none.\n        Prune (data newer than prune_date deleted) before copying new data in.\n        \"\"\"\n        if self.prune_table and self.prune_column and self.prune_date:\n            return True\n        elif self.prune_table or self.prune_column or self.prune_date:\n            raise Exception('override zero or all prune variables')\n        else:\n            return False",
        "begin_line": 240,
        "end_line": 251,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.table_type#254",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.table_type(self)",
        "snippet": "    def table_type(self):\n        \"\"\"\n        Return table type (i.e. 'temp').\n        \"\"\"\n        return ''",
        "begin_line": 254,
        "end_line": 258,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.queries#261",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.queries(self)",
        "snippet": "    def queries(self):\n        \"\"\"\n        Override to return a list of queries to be executed in order.\n        \"\"\"\n        return []",
        "begin_line": 261,
        "end_line": 265,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017966223499820338,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.prune#275",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.prune(self, connection)",
        "snippet": "    def prune(self, connection):\n        query = \"delete from %s where %s >= %s\" % (self.prune_table, self.prune_column, self.prune_date)\n        cursor = connection.cursor()\n        try:\n            cursor.execute(query)\n        finally:\n            cursor.close()",
        "begin_line": 275,
        "end_line": 281,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.create_schema#283",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.create_schema(self, connection)",
        "snippet": "    def create_schema(self, connection):\n        \"\"\"\n        Will create the schema in the database\n        \"\"\"\n        if '.' not in self.table:\n            return\n\n        query = 'CREATE SCHEMA IF NOT EXISTS {schema_name};'.format(schema_name=self.table.split('.')[0])\n        connection.cursor().execute(query)",
        "begin_line": 283,
        "end_line": 291,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.create_table#293",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.create_table(self, connection)",
        "snippet": "    def create_table(self, connection):\n        \"\"\"\n        Override to provide code for creating the target table.\n\n        By default it will be created using types (optionally)\n        specified in columns.\n\n        If overridden, use the provided connection object for\n        setting up the table in order to create the table and\n        insert data using the same transaction.\n        \"\"\"\n        if len(self.columns[0]) == 1:\n            # only names of columns specified, no types\n            raise NotImplementedError(\"create_table() not implemented \"\n                                      \"for %r and columns types not \"\n                                      \"specified\" % self.table)\n        elif len(self.columns[0]) == 2:\n            # if columns is specified as (name, type) tuples\n            coldefs = ','.join(\n                '{name} {type}'.format(\n                    name=name,\n                    type=type) for name, type in self.columns\n            )\n\n            table_constraints = ''\n            if self.table_constraints != '':\n                table_constraints = ', ' + self.table_constraints\n\n            query = (\"CREATE {type} TABLE \"\n                     \"{table} ({coldefs} {table_constraints}) \"\n                     \"{table_attributes}\").format(\n                type=self.table_type,\n                table=self.table,\n                coldefs=coldefs,\n                table_constraints=table_constraints,\n                table_attributes=self.table_attributes)\n\n            connection.cursor().execute(query)\n        elif len(self.columns[0]) == 3:\n            # if columns is specified as (name, type, encoding) tuples\n            # possible column encodings: https://docs.aws.amazon.com/redshift/latest/dg/c_Compression_encodings.html\n            coldefs = ','.join(\n                '{name} {type} ENCODE {encoding}'.format(\n                    name=name,\n                    type=type,\n                    encoding=encoding) for name, type, encoding in self.columns\n            )\n\n            table_constraints = ''\n            if self.table_constraints != '':\n                table_constraints = ',' + self.table_constraints\n\n            query = (\"CREATE {type} TABLE \"\n                     \"{table} ({coldefs} {table_constraints}) \"\n                     \"{table_attributes}\").format(\n                type=self.table_type,\n                table=self.table,\n                coldefs=coldefs,\n                table_constraints=table_constraints,\n                table_attributes=self.table_attributes)\n\n            connection.cursor().execute(query)\n        else:\n            raise ValueError(\"create_table() found no columns for %r\"\n                             % self.table)",
        "begin_line": 293,
        "end_line": 357,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.run#359",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.run(self)",
        "snippet": "    def run(self):\n        \"\"\"\n        If the target table doesn't exist, self.create_table\n        will be called to attempt to create the table.\n        \"\"\"\n        if not (self.table):\n            raise Exception(\"table need to be specified\")\n\n        path = self.s3_load_path()\n        output = self.output()\n        connection = output.connect()\n        cursor = connection.cursor()\n\n        self.init_copy(connection)\n        self.copy(cursor, path)\n        self.post_copy(cursor)\n\n        if self.enable_metadata_columns:\n            self.post_copy_metacolumns(cursor)\n\n        # update marker table\n        output.touch(connection)\n        connection.commit()\n\n        # commit and clean up\n        connection.close()",
        "begin_line": 359,
        "end_line": 384,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021101498206372652,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.copy#386",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.copy(self, cursor, f)",
        "snippet": "    def copy(self, cursor, f):\n        \"\"\"\n        Defines copying from s3 into redshift.\n\n        If both key-based and role-based credentials are provided, role-based will be used.\n        \"\"\"\n        logger.info(\"Inserting file: %s\", f)\n        colnames = ''\n        if self.columns and len(self.columns) > 0:\n            colnames = \",\".join([x[0] for x in self.columns])\n            colnames = '({})'.format(colnames)\n\n        cursor.execute(\"\"\"\n         COPY {table} {colnames} from '{source}'\n         CREDENTIALS '{creds}'\n         {options}\n         ;\"\"\".format(\n            table=self.table,\n            colnames=colnames,\n            source=f,\n            creds=self._credentials(),\n            options=self.copy_options)\n        )",
        "begin_line": 386,
        "end_line": 408,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00018712574850299402,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.output#410",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.output(self)",
        "snippet": "    def output(self):\n        \"\"\"\n        Returns a RedshiftTarget representing the inserted dataset.\n\n        Normally you don't override this.\n        \"\"\"\n        return RedshiftTarget(\n            host=self.host,\n            database=self.database,\n            user=self.user,\n            password=self.password,\n            table=self.table,\n            update_id=self.update_id)",
        "begin_line": 410,
        "end_line": 422,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017655367231638418,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.does_schema_exist#424",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.does_schema_exist(self, connection)",
        "snippet": "    def does_schema_exist(self, connection):\n        \"\"\"\n        Determine whether the schema already exists.\n        \"\"\"\n\n        if '.' in self.table:\n            query = (\"select 1 as schema_exists \"\n                     \"from pg_namespace \"\n                     \"where nspname = lower(%s) limit 1\")\n        else:\n            return True\n\n        cursor = connection.cursor()\n        try:\n            schema = self.table.split('.')[0]\n            cursor.execute(query, [schema])\n            result = cursor.fetchone()\n            return bool(result)\n        finally:\n            cursor.close()",
        "begin_line": 424,
        "end_line": 443,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.does_table_exist#445",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.does_table_exist(self, connection)",
        "snippet": "    def does_table_exist(self, connection):\n        \"\"\"\n        Determine whether the table already exists.\n        \"\"\"\n\n        if '.' in self.table:\n            query = (\"select 1 as table_exists \"\n                     \"from information_schema.tables \"\n                     \"where table_schema = lower(%s) and table_name = lower(%s) limit 1\")\n        else:\n            query = (\"select 1 as table_exists \"\n                     \"from pg_table_def \"\n                     \"where tablename = lower(%s) limit 1\")\n        cursor = connection.cursor()\n        try:\n            cursor.execute(query, tuple(self.table.split('.')))\n            result = cursor.fetchone()\n            return bool(result)\n        finally:\n            cursor.close()",
        "begin_line": 445,
        "end_line": 464,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.init_copy#466",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.init_copy(self, connection)",
        "snippet": "    def init_copy(self, connection):\n        \"\"\"\n        Perform pre-copy sql - such as creating table, truncating, or removing data older than x.\n        \"\"\"\n        if not self.does_schema_exist(connection):\n            logger.info(\"Creating schema for %s\", self.table)\n            self.create_schema(connection)\n\n        if not self.does_table_exist(connection):\n            logger.info(\"Creating table %s\", self.table)\n            self.create_table(connection)\n\n        if self.enable_metadata_columns:\n            self._add_metadata_columns(connection)\n\n        if self.do_truncate_table:\n            logger.info(\"Truncating table %s\", self.table)\n            self.truncate_table(connection)\n\n        if self.do_prune():\n            logger.info(\"Removing %s older than %s from %s\", self.prune_column, self.prune_date, self.prune_table)\n            self.prune(connection)",
        "begin_line": 466,
        "end_line": 487,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.post_copy#489",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.post_copy(self, cursor)",
        "snippet": "    def post_copy(self, cursor):\n        \"\"\"\n        Performs post-copy sql - such as cleansing data, inserting into production table (if copied to temp table), etc.\n        \"\"\"\n        logger.info('Executing post copy queries')\n        for query in self.queries:\n            cursor.execute(query)",
        "begin_line": 489,
        "end_line": 495,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyJSONToTable.copy#546",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyJSONToTable",
        "signature": "luigi.contrib.redshift.S3CopyJSONToTable.copy(self, cursor, f)",
        "snippet": "    def copy(self, cursor, f):\n        \"\"\"\n        Defines copying JSON from s3 into redshift.\n        \"\"\"\n\n        logger.info(\"Inserting file: %s\", f)\n        cursor.execute(\"\"\"\n         COPY %s from '%s'\n         CREDENTIALS '%s'\n         JSON AS '%s' %s\n         %s\n         ;\"\"\" % (self.table, f, self._credentials(),\n                 self.jsonpath, self.copy_json_options, self.copy_options))",
        "begin_line": 546,
        "end_line": 558,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift.RedshiftQuery.output#718",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.RedshiftQuery",
        "signature": "luigi.contrib.redshift.RedshiftQuery.output(self)",
        "snippet": "    def output(self):\n        \"\"\"\n        Returns a RedshiftTarget representing the executed query.\n\n        Normally you don't override this.\n        \"\"\"\n        return RedshiftTarget(\n            host=self.host,\n            database=self.database,\n            user=self.user,\n            password=self.password,\n            table=self.table,\n            update_id=self.update_id\n        )",
        "begin_line": 718,
        "end_line": 731,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift.RedshiftUnloadTask.unload_query#762",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.RedshiftUnloadTask",
        "signature": "luigi.contrib.redshift.RedshiftUnloadTask.unload_query(self)",
        "snippet": "    def unload_query(self):\n        \"\"\"\n        Default UNLOAD command\n        \"\"\"\n        return (\"UNLOAD ( '{query}' ) TO '{s3_unload_path}' \"\n                \"credentials '{credentials}' \"\n                \"{unload_options};\")",
        "begin_line": 762,
        "end_line": 768,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift.RedshiftUnloadTask.run#770",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.RedshiftUnloadTask",
        "signature": "luigi.contrib.redshift.RedshiftUnloadTask.run(self)",
        "snippet": "    def run(self):\n        connection = self.output().connect()\n        cursor = connection.cursor()\n\n        unload_query = self.unload_query.format(\n            query=self.query().replace(\"'\", r\"\\'\"),\n            s3_unload_path=self.s3_unload_path,\n            unload_options=self.unload_options,\n            credentials=self._credentials())\n\n        logger.info('Executing unload query from task: {name}'.format(name=self.__class__))\n\n        cursor = connection.cursor()\n        cursor.execute(unload_query)\n        logger.info(cursor.statusmessage)\n\n        # Update marker table\n        self.output().touch(connection)\n        # commit and close connection\n        connection.commit()\n        connection.close()",
        "begin_line": 770,
        "end_line": 790,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.redshift.RedshiftUnloadTask.output#792",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.RedshiftUnloadTask",
        "signature": "luigi.contrib.redshift.RedshiftUnloadTask.output(self)",
        "snippet": "    def output(self):\n        \"\"\"\n        Returns a RedshiftTarget representing the executed query.\n\n        Normally you don't override this.\n        \"\"\"\n        return RedshiftTarget(\n            host=self.host,\n            database=self.database,\n            user=self.user,\n            password=self.password,\n            table=self.table,\n            update_id=self.update_id\n        )",
        "begin_line": 792,
        "end_line": 805,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.sqla.SQLAlchemyTarget.__init__#166",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.SQLAlchemyTarget",
        "signature": "luigi.contrib.sqla.SQLAlchemyTarget.__init__(self, connection_string, target_table, update_id, echo=False, connect_args=None)",
        "snippet": "    def __init__(self, connection_string, target_table, update_id, echo=False, connect_args=None):\n        \"\"\"\n        Constructor for the SQLAlchemyTarget.\n\n        :param connection_string: SQLAlchemy connection string\n        :type connection_string: str\n        :param target_table: The table name for the data\n        :type target_table: str\n        :param update_id: An identifier for this data set\n        :type update_id: str\n        :param echo: Flag to setup SQLAlchemy logging\n        :type echo: bool\n        :param connect_args: A dictionary of connection arguments\n        :type connect_args: dict\n        :return:\n        \"\"\"\n        if connect_args is None:\n            connect_args = {}\n\n        self.target_table = target_table\n        self.update_id = update_id\n        self.connection_string = connection_string\n        self.echo = echo\n        self.connect_args = connect_args\n        self.marker_table_bound = None",
        "begin_line": 166,
        "end_line": 190,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.sqla.SQLAlchemyTarget.engine#193",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.SQLAlchemyTarget",
        "signature": "luigi.contrib.sqla.SQLAlchemyTarget.engine(self)",
        "snippet": "    def engine(self):\n        \"\"\"\n        Return an engine instance, creating it if it doesn't exist.\n\n        Recreate the engine connection if it wasn't originally created\n        by the current process.\n        \"\"\"\n        pid = os.getpid()\n        conn = SQLAlchemyTarget._engine_dict.get(self.connection_string)\n        if not conn or conn.pid != pid:\n            # create and reset connection\n            engine = sqlalchemy.create_engine(\n                self.connection_string,\n                connect_args=self.connect_args,\n                echo=self.echo\n            )\n            SQLAlchemyTarget._engine_dict[self.connection_string] = self.Connection(engine, pid)\n        return SQLAlchemyTarget._engine_dict[self.connection_string].engine",
        "begin_line": 193,
        "end_line": 210,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017966223499820338,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.sqla.SQLAlchemyTarget.touch#212",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.SQLAlchemyTarget",
        "signature": "luigi.contrib.sqla.SQLAlchemyTarget.touch(self)",
        "snippet": "    def touch(self):\n        \"\"\"\n        Mark this update as complete.\n        \"\"\"\n        if self.marker_table_bound is None:\n            self.create_marker_table()\n\n        table = self.marker_table_bound\n        id_exists = self.exists()\n        with self.engine.begin() as conn:\n            if not id_exists:\n                ins = table.insert().values(update_id=self.update_id, target_table=self.target_table,\n                                            inserted=datetime.datetime.now())\n            else:\n                ins = table.update().where(sqlalchemy.and_(table.c.update_id == self.update_id,\n                                                           table.c.target_table == self.target_table)).\\\n                    values(update_id=self.update_id, target_table=self.target_table,\n                           inserted=datetime.datetime.now())\n            conn.execute(ins)\n        assert self.exists()",
        "begin_line": 212,
        "end_line": 231,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.sqla.SQLAlchemyTarget.exists#233",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.SQLAlchemyTarget",
        "signature": "luigi.contrib.sqla.SQLAlchemyTarget.exists(self)",
        "snippet": "    def exists(self):\n        row = None\n        if self.marker_table_bound is None:\n            self.create_marker_table()\n        with self.engine.begin() as conn:\n            table = self.marker_table_bound\n            s = sqlalchemy.select([table]).where(sqlalchemy.and_(table.c.update_id == self.update_id,\n                                                                 table.c.target_table == self.target_table)).limit(1)\n            row = conn.execute(s).fetchone()\n        return row is not None",
        "begin_line": 233,
        "end_line": 242,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00018570102135561745,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.sqla.SQLAlchemyTarget.create_marker_table#244",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.SQLAlchemyTarget",
        "signature": "luigi.contrib.sqla.SQLAlchemyTarget.create_marker_table(self)",
        "snippet": "    def create_marker_table(self):\n        \"\"\"\n        Create marker table if it doesn't exist.\n\n        Using a separate connection since the transaction might have to be reset.\n        \"\"\"\n        if self.marker_table is None:\n            self.marker_table = luigi.configuration.get_config().get('sqlalchemy', 'marker-table', 'table_updates')\n\n        engine = self.engine\n\n        with engine.begin() as con:\n            metadata = sqlalchemy.MetaData()\n            if not con.dialect.has_table(con, self.marker_table):\n                self.marker_table_bound = sqlalchemy.Table(\n                    self.marker_table, metadata,\n                    sqlalchemy.Column(\"update_id\", sqlalchemy.String(128), primary_key=True),\n                    sqlalchemy.Column(\"target_table\", sqlalchemy.String(128)),\n                    sqlalchemy.Column(\"inserted\", sqlalchemy.DateTime, default=datetime.datetime.now()))\n                metadata.create_all(engine)\n            else:\n                metadata.reflect(only=[self.marker_table], bind=engine)\n                self.marker_table_bound = metadata.tables[self.marker_table]",
        "begin_line": 244,
        "end_line": 266,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019508388607101054,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.create_table#318",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.create_table(self, engine)",
        "snippet": "    def create_table(self, engine):\n        \"\"\"\n        Override to provide code for creating the target table.\n\n        By default it will be created using types specified in columns.\n        If the table exists, then it binds to the existing table.\n\n        If overridden, use the provided connection object for setting up the table in order to\n        create the table and insert data using the same transaction.\n        :param engine: The sqlalchemy engine instance\n        :type engine: object\n        \"\"\"\n        def construct_sqla_columns(columns):\n            retval = [sqlalchemy.Column(*c[0], **c[1]) for c in columns]\n            return retval\n\n        needs_setup = (len(self.columns) == 0) or (False in [len(c) == 2 for c in self.columns]) if not self.reflect else False\n        if needs_setup:\n            # only names of columns specified, no types\n            raise NotImplementedError(\"create_table() not implemented for %r and columns types not specified\" % self.table)\n        else:\n            # if columns is specified as (name, type) tuples\n            with engine.begin() as con:\n\n                if self.schema:\n                    metadata = sqlalchemy.MetaData(schema=self.schema)\n                else:\n                    metadata = sqlalchemy.MetaData()\n\n                try:\n                    if not con.dialect.has_table(con, self.table, self.schema or None):\n                        sqla_columns = construct_sqla_columns(self.columns)\n                        self.table_bound = sqlalchemy.Table(self.table, metadata, *sqla_columns)\n                        metadata.create_all(engine)\n                    else:\n                        full_table = '.'.join([self.schema, self.table]) if self.schema else self.table\n                        metadata.reflect(only=[self.table], bind=engine)\n                        self.table_bound = metadata.tables[full_table]\n                except Exception as e:\n                    self._logger.exception(self.table + str(e))",
        "begin_line": 318,
        "end_line": 357,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.construct_sqla_columns#330",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.construct_sqla_columns(columns)",
        "snippet": "        def construct_sqla_columns(columns):\n            retval = [sqlalchemy.Column(*c[0], **c[1]) for c in columns]\n            return retval",
        "begin_line": 330,
        "end_line": 332,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019747235387045813,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.update_id#359",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.update_id(self)",
        "snippet": "    def update_id(self):\n        \"\"\"\n        This update id will be a unique identifier for this insert on this table.\n        \"\"\"\n        return self.task_id",
        "begin_line": 359,
        "end_line": 363,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00018570102135561745,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.output#365",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.output(self)",
        "snippet": "    def output(self):\n        return SQLAlchemyTarget(\n            connection_string=self.connection_string,\n            target_table=self.table,\n            update_id=self.update_id(),\n            connect_args=self.connect_args,\n            echo=self.echo)",
        "begin_line": 365,
        "end_line": 371,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00018570102135561745,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.rows#373",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.rows(self)",
        "snippet": "    def rows(self):\n        \"\"\"\n        Return/yield tuples or lists corresponding to each row to be inserted.\n\n        This method can be overridden for custom file types or formats.\n        \"\"\"\n        with self.input().open('r') as fobj:\n            for line in fobj:\n                yield line.strip(\"\\n\").split(self.column_separator)",
        "begin_line": 373,
        "end_line": 381,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021101498206372652,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.run#383",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.run(self)",
        "snippet": "    def run(self):\n        self._logger.info(\"Running task copy to table for update id %s for table %s\" % (self.update_id(), self.table))\n        output = self.output()\n        engine = output.engine\n        self.create_table(engine)\n        with engine.begin() as conn:\n            rows = iter(self.rows())\n            ins_rows = [dict(zip((\"_\" + c.key for c in self.table_bound.c), row))\n                        for row in itertools.islice(rows, self.chunk_size)]\n            while ins_rows:\n                self.copy(conn, ins_rows, self.table_bound)\n                ins_rows = [dict(zip((\"_\" + c.key for c in self.table_bound.c), row))\n                            for row in itertools.islice(rows, self.chunk_size)]\n                self._logger.info(\"Finished inserting %d rows into SQLAlchemy target\" % len(ins_rows))\n        output.touch()\n        self._logger.info(\"Finished inserting rows into SQLAlchemy target\")",
        "begin_line": 383,
        "end_line": 398,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.copy#400",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.copy(self, conn, ins_rows, table_bound)",
        "snippet": "    def copy(self, conn, ins_rows, table_bound):\n        \"\"\"\n        This method does the actual insertion of the rows of data given by ins_rows into the\n        database. A task that needs row updates instead of insertions should overload this method.\n        :param conn: The sqlalchemy connection object\n        :param ins_rows: The dictionary of rows with the keys in the format _<column_name>. For example\n        if you have a table with a column name \"property\", then the key in the dictionary\n        would be \"_property\". This format is consistent with the bindparam usage in sqlalchemy.\n        :param table_bound: The object referring to the table\n        :return:\n        \"\"\"\n        bound_cols = dict((c, sqlalchemy.bindparam(\"_\" + c.key)) for c in table_bound.columns)\n        ins = table_bound.insert().values(bound_cols)\n        conn.execute(ins, ins_rows)",
        "begin_line": 400,
        "end_line": 413,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler._get_empty_retry_policy#93",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler",
        "signature": "luigi.scheduler._get_empty_retry_policy()",
        "snippet": "def _get_empty_retry_policy():\n    return RetryPolicy(*[None] * len(_retry_policy_fields))",
        "begin_line": 93,
        "end_line": 94,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0036900369003690036,
            "pseudo_dstar_susp": 0.0009794319294809011,
            "pseudo_tarantula_susp": 0.0037735849056603774,
            "pseudo_op2_susp": 0.0009794319294809011,
            "pseudo_barinel_susp": 0.0037735849056603774
        }
    },
    {
        "name": "luigi.scheduler._rpc_method#98",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler",
        "signature": "luigi.scheduler._rpc_method(fn)",
        "snippet": "    def _rpc_method(fn):\n        # If request args are passed, return this function again for use as\n        # the decorator function with the request args attached.\n        fn_args = six.getargspec(fn)\n\n        assert not fn_args.varargs\n        assert fn_args.args[0] == 'self'\n        all_args = fn_args.args[1:]\n        defaults = dict(zip(reversed(all_args), reversed(fn_args.defaults or ())))\n        required_args = frozenset(arg for arg in all_args if arg not in defaults)\n        fn_name = fn.__name__\n\n        @functools.wraps(fn)\n        def rpc_func(self, *args, **kwargs):\n            actual_args = defaults.copy()\n            actual_args.update(dict(zip(all_args, args)))\n            actual_args.update(kwargs)\n            if not all(arg in actual_args for arg in required_args):\n                raise TypeError('{} takes {} arguments ({} given)'.format(\n                    fn_name, len(all_args), len(actual_args)))\n            return self._request('/api/{}'.format(fn_name), actual_args, **request_args)\n\n        RPC_METHODS[fn_name] = rpc_func\n        return fn",
        "begin_line": 98,
        "end_line": 121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016028209648982208,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.rpc_func#111",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler",
        "signature": "luigi.scheduler.rpc_func(self, *args, **kwargs)",
        "snippet": "        def rpc_func(self, *args, **kwargs):\n            actual_args = defaults.copy()\n            actual_args.update(dict(zip(all_args, args)))\n            actual_args.update(kwargs)\n            if not all(arg in actual_args for arg in required_args):\n                raise TypeError('{} takes {} arguments ({} given)'.format(\n                    fn_name, len(all_args), len(actual_args)))\n            return self._request('/api/{}'.format(fn_name), actual_args, **request_args)",
        "begin_line": 111,
        "end_line": 118,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016028209648982208,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.scheduler._get_retry_policy#153",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.scheduler",
        "signature": "luigi.scheduler.scheduler._get_retry_policy(self)",
        "snippet": "    def _get_retry_policy(self):\n        return RetryPolicy(self.retry_count, self.disable_hard_timeout, self.disable_window)",
        "begin_line": 153,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009671179883945841,
            "pseudo_dstar_susp": 0.0031645569620253164,
            "pseudo_tarantula_susp": 0.0005820721769499418,
            "pseudo_op2_susp": 0.0031645569620253164,
            "pseudo_barinel_susp": 0.0005820721769499418
        }
    },
    {
        "name": "luigi.scheduler.Failures.__init__#165",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Failures",
        "signature": "luigi.scheduler.Failures.__init__(self, window)",
        "snippet": "    def __init__(self, window):\n        \"\"\"\n        Initialize with the given window.\n\n        :param window: how long to track failures for, as a float (number of seconds).\n        \"\"\"\n        self.window = window\n        self.failures = collections.deque()\n        self.first_failure_time = None",
        "begin_line": 165,
        "end_line": 173,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010152284263959391,
            "pseudo_dstar_susp": 0.0035714285714285713,
            "pseudo_tarantula_susp": 0.0006165228113440197,
            "pseudo_op2_susp": 0.0035714285714285713,
            "pseudo_barinel_susp": 0.0006165228113440197
        }
    },
    {
        "name": "luigi.scheduler.Failures.add_failure#175",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Failures",
        "signature": "luigi.scheduler.Failures.add_failure(self)",
        "snippet": "    def add_failure(self):\n        \"\"\"\n        Add a failure event with the current timestamp.\n        \"\"\"\n        failure_time = time.time()\n\n        if not self.first_failure_time:\n            self.first_failure_time = failure_time\n\n        self.failures.append(failure_time)",
        "begin_line": 175,
        "end_line": 184,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004861448711716091,
            "pseudo_dstar_susp": 0.0004861448711716091,
            "pseudo_tarantula_susp": 0.0005659309564233164,
            "pseudo_op2_susp": 0.0004861448711716091,
            "pseudo_barinel_susp": 0.0005659309564233164
        }
    },
    {
        "name": "luigi.scheduler.Failures.num_failures#186",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Failures",
        "signature": "luigi.scheduler.Failures.num_failures(self)",
        "snippet": "    def num_failures(self):\n        \"\"\"\n        Return the number of failures in the window.\n        \"\"\"\n        min_time = time.time() - self.window\n\n        while self.failures and self.failures[0] < min_time:\n            self.failures.popleft()\n\n        return len(self.failures)",
        "begin_line": 186,
        "end_line": 195,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004880429477794046,
            "pseudo_dstar_susp": 0.0004880429477794046,
            "pseudo_tarantula_susp": 0.0005688282138794084,
            "pseudo_op2_susp": 0.0004880429477794046,
            "pseudo_barinel_susp": 0.0005688282138794084
        }
    },
    {
        "name": "luigi.scheduler.Failures.clear#197",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Failures",
        "signature": "luigi.scheduler.Failures.clear(self)",
        "snippet": "    def clear(self):\n        \"\"\"\n        Clear the failure queue.\n        \"\"\"\n        self.failures.clear()",
        "begin_line": 197,
        "end_line": 201,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00020052135552436334,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler._get_default#204",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler",
        "signature": "luigi.scheduler._get_default(x, default)",
        "snippet": "def _get_default(x, default):\n    if x is not None:\n        return x\n    else:\n        return default",
        "begin_line": 204,
        "end_line": 208,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010152284263959391,
            "pseudo_dstar_susp": 0.0035714285714285713,
            "pseudo_tarantula_susp": 0.0006165228113440197,
            "pseudo_op2_susp": 0.0035714285714285713,
            "pseudo_barinel_susp": 0.0006165228113440197
        }
    },
    {
        "name": "luigi.scheduler.OrderedSet.__init__#218",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.OrderedSet",
        "signature": "luigi.scheduler.OrderedSet.__init__(self, iterable=None)",
        "snippet": "    def __init__(self, iterable=None):\n        self.end = end = []\n        end += [None, end, end]         # sentinel node for doubly linked list\n        self.map = {}                   # key --> [key, prev, next]\n        if iterable is not None:\n            self |= iterable",
        "begin_line": 218,
        "end_line": 223,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010152284263959391,
            "pseudo_dstar_susp": 0.0035714285714285713,
            "pseudo_tarantula_susp": 0.0006165228113440197,
            "pseudo_op2_susp": 0.0035714285714285713,
            "pseudo_barinel_susp": 0.0006165228113440197
        }
    },
    {
        "name": "luigi.scheduler.OrderedSet.__len__#225",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.OrderedSet",
        "signature": "luigi.scheduler.OrderedSet.__len__(self)",
        "snippet": "    def __len__(self):\n        return len(self.map)",
        "begin_line": 225,
        "end_line": 226,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004955401387512388,
            "pseudo_dstar_susp": 0.0006402048655569782,
            "pseudo_tarantula_susp": 0.0004786979415988511,
            "pseudo_op2_susp": 0.0006402048655569782,
            "pseudo_barinel_susp": 0.0004786979415988511
        }
    },
    {
        "name": "luigi.scheduler.OrderedSet.__contains__#228",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.OrderedSet",
        "signature": "luigi.scheduler.OrderedSet.__contains__(self, key)",
        "snippet": "    def __contains__(self, key):\n        return key in self.map",
        "begin_line": 228,
        "end_line": 229,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005027652086475615,
            "pseudo_dstar_susp": 0.0006472491909385113,
            "pseudo_tarantula_susp": 0.0004833252779120348,
            "pseudo_op2_susp": 0.0006472491909385113,
            "pseudo_barinel_susp": 0.0004833252779120348
        }
    },
    {
        "name": "luigi.scheduler.OrderedSet.add#231",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.OrderedSet",
        "signature": "luigi.scheduler.OrderedSet.add(self, key)",
        "snippet": "    def add(self, key):\n        if key not in self.map:\n            end = self.end\n            curr = end[1]\n            curr[2] = end[1] = self.map[key] = [key, curr, end]",
        "begin_line": 231,
        "end_line": 235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004930966469428008,
            "pseudo_dstar_susp": 0.0006365372374283895,
            "pseudo_tarantula_susp": 0.00047664442326024784,
            "pseudo_op2_susp": 0.0006365372374283895,
            "pseudo_barinel_susp": 0.00047664442326024784
        }
    },
    {
        "name": "luigi.scheduler.OrderedSet.discard#237",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.OrderedSet",
        "signature": "luigi.scheduler.OrderedSet.discard(self, key)",
        "snippet": "    def discard(self, key):\n        if key in self.map:\n            key, prev, next = self.map.pop(key)\n            prev[2] = next\n            next[1] = prev",
        "begin_line": 237,
        "end_line": 241,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016775708773695687,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.OrderedSet.__iter__#243",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.OrderedSet",
        "signature": "luigi.scheduler.OrderedSet.__iter__(self)",
        "snippet": "    def __iter__(self):\n        end = self.end\n        curr = end[2]\n        while curr is not end:\n            yield curr[0]\n            curr = curr[2]",
        "begin_line": 243,
        "end_line": 248,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016233766233766234,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.OrderedSet.peek#257",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.OrderedSet",
        "signature": "luigi.scheduler.OrderedSet.peek(self, last=True)",
        "snippet": "    def peek(self, last=True):\n        if not self:\n            raise KeyError('set is empty')\n        key = self.end[1][0] if last else self.end[2][0]\n        return key",
        "begin_line": 257,
        "end_line": 261,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000505050505050505,
            "pseudo_dstar_susp": 0.0006510416666666666,
            "pseudo_tarantula_susp": 0.0004854368932038835,
            "pseudo_op2_susp": 0.0006510416666666666,
            "pseudo_barinel_susp": 0.0004854368932038835
        }
    },
    {
        "name": "luigi.scheduler.Task.__init__#280",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Task",
        "signature": "luigi.scheduler.Task.__init__(self, task_id, status, deps, resources=None, priority=0, family='', module=None, params=None, param_visibilities=None, accepts_messages=False, tracking_url=None, status_message=None, progress_percentage=None, retry_policy='notoptional')",
        "snippet": "    def __init__(self, task_id, status, deps, resources=None, priority=0, family='', module=None,\n                 params=None, param_visibilities=None, accepts_messages=False, tracking_url=None, status_message=None,\n                 progress_percentage=None, retry_policy='notoptional'):\n        self.id = task_id\n        self.stakeholders = set()  # workers ids that are somehow related to this task (i.e. don't prune while any of these workers are still active)\n        self.workers = OrderedSet()  # workers ids that can perform task - task is 'BROKEN' if none of these workers are active\n        if deps is None:\n            self.deps = set()\n        else:\n            self.deps = set(deps)\n        self.status = status  # PENDING, RUNNING, FAILED or DONE\n        self.time = time.time()  # Timestamp when task was first added\n        self.updated = self.time\n        self.retry = None\n        self.remove = None\n        self.worker_running = None  # the worker id that is currently running the task or None\n        self.time_running = None  # Timestamp when picked up by worker\n        self.expl = None\n        self.priority = priority\n        self.resources = _get_default(resources, {})\n        self.family = family\n        self.module = module\n        self.param_visibilities = _get_default(param_visibilities, {})\n        self.params = {}\n        self.public_params = {}\n        self.hidden_params = {}\n        self.set_params(params)\n        self.accepts_messages = accepts_messages\n        self.retry_policy = retry_policy\n        self.failures = Failures(self.retry_policy.disable_window)\n        self.tracking_url = tracking_url\n        self.status_message = status_message\n        self.progress_percentage = progress_percentage\n        self.scheduler_message_responses = {}\n        self.scheduler_disable_time = None\n        self.runnable = False\n        self.batchable = False\n        self.batch_id = None",
        "begin_line": 280,
        "end_line": 317,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.0035714285714285713,
            "pseudo_tarantula_susp": 0.000968054211035818,
            "pseudo_op2_susp": 0.0035714285714285713,
            "pseudo_barinel_susp": 0.000968054211035818
        }
    },
    {
        "name": "luigi.scheduler.Task.set_params#322",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Task",
        "signature": "luigi.scheduler.Task.set_params(self, params)",
        "snippet": "    def set_params(self, params):\n        self.params = _get_default(params, {})\n        self.public_params = {key: value for key, value in self.params.items() if\n                              self.param_visibilities.get(key, ParameterVisibility.PUBLIC) == ParameterVisibility.PUBLIC}\n        self.hidden_params = {key: value for key, value in self.params.items() if\n                              self.param_visibilities.get(key, ParameterVisibility.PUBLIC) == ParameterVisibility.HIDDEN}",
        "begin_line": 322,
        "end_line": 327,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013333333333333333,
            "pseudo_dstar_susp": 0.006172839506172839,
            "pseudo_tarantula_susp": 0.0010449320794148381,
            "pseudo_op2_susp": 0.006172839506172839,
            "pseudo_barinel_susp": 0.0010449320794148381
        }
    },
    {
        "name": "luigi.scheduler.Task.is_batchable#331",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Task",
        "signature": "luigi.scheduler.Task.is_batchable(self)",
        "snippet": "    def is_batchable(self):\n        try:\n            return self.batchable\n        except AttributeError:\n            return False",
        "begin_line": 331,
        "end_line": 335,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016366612111292964,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Task.add_failure#337",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Task",
        "signature": "luigi.scheduler.Task.add_failure(self)",
        "snippet": "    def add_failure(self):\n        self.failures.add_failure()",
        "begin_line": 337,
        "end_line": 338,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004861448711716091,
            "pseudo_dstar_susp": 0.0004861448711716091,
            "pseudo_tarantula_susp": 0.0005659309564233164,
            "pseudo_op2_susp": 0.0004861448711716091,
            "pseudo_barinel_susp": 0.0005659309564233164
        }
    },
    {
        "name": "luigi.scheduler.Task.has_excessive_failures#340",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Task",
        "signature": "luigi.scheduler.Task.has_excessive_failures(self)",
        "snippet": "    def has_excessive_failures(self):\n        if self.failures.first_failure_time is not None:\n            if (time.time() >= self.failures.first_failure_time + self.retry_policy.disable_hard_timeout):\n                return True\n\n        logger.debug('%s task num failures is %s and limit is %s', self.id, self.failures.num_failures(), self.retry_policy.retry_count)\n        if self.failures.num_failures() >= self.retry_policy.retry_count:\n            logger.debug('%s task num failures limit(%s) is exceeded', self.id, self.retry_policy.retry_count)\n            return True\n\n        return False",
        "begin_line": 340,
        "end_line": 350,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004916420845624386,
            "pseudo_dstar_susp": 0.0004914004914004914,
            "pseudo_tarantula_susp": 0.0005770340450086555,
            "pseudo_op2_susp": 0.0004914004914004914,
            "pseudo_barinel_susp": 0.000578368999421631
        }
    },
    {
        "name": "luigi.scheduler.Task.pretty_id#353",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Task",
        "signature": "luigi.scheduler.Task.pretty_id(self)",
        "snippet": "    def pretty_id(self):\n        param_str = ', '.join(u'{}={}'.format(key, value) for key, value in sorted(self.public_params.items()))\n        return u'{}({})'.format(self.family, param_str)",
        "begin_line": 353,
        "end_line": 355,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016020506247997436,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Worker.__init__#363",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.__init__(self, worker_id, last_active=None)",
        "snippet": "    def __init__(self, worker_id, last_active=None):\n        self.id = worker_id\n        self.reference = None  # reference to the worker in the real world. (Currently a dict containing just the host)\n        self.last_active = last_active or time.time()  # seconds since epoch\n        self.last_get_work = None\n        self.started = time.time()  # seconds since epoch\n        self.tasks = set()  # task objects\n        self.info = {}\n        self.disabled = False\n        self.rpc_messages = []",
        "begin_line": 363,
        "end_line": 372,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005592841163310962,
            "pseudo_dstar_susp": 0.0011111111111111111,
            "pseudo_tarantula_susp": 0.000493339911198816,
            "pseudo_op2_susp": 0.0011111111111111111,
            "pseudo_barinel_susp": 0.000493339911198816
        }
    },
    {
        "name": "luigi.scheduler.Worker.add_info#374",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.add_info(self, info)",
        "snippet": "    def add_info(self, info):\n        self.info.update(info)",
        "begin_line": 374,
        "end_line": 375,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008,
            "pseudo_dstar_susp": 0.001388888888888889,
            "pseudo_tarantula_susp": 0.0006798096532970768,
            "pseudo_op2_susp": 0.001388888888888889,
            "pseudo_barinel_susp": 0.0006798096532970768
        }
    },
    {
        "name": "luigi.scheduler.Worker.update#377",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.update(self, worker_reference, get_work=False)",
        "snippet": "    def update(self, worker_reference, get_work=False):\n        if worker_reference:\n            self.reference = worker_reference\n        self.last_active = time.time()\n        if get_work:\n            self.last_get_work = time.time()",
        "begin_line": 377,
        "end_line": 382,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006414368184733803,
            "pseudo_dstar_susp": 0.0012804097311139564,
            "pseudo_tarantula_susp": 0.0005515719801434088,
            "pseudo_op2_susp": 0.0012804097311139564,
            "pseudo_barinel_susp": 0.0005515719801434088
        }
    },
    {
        "name": "luigi.scheduler.Worker.prune#384",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.prune(self, config)",
        "snippet": "    def prune(self, config):\n        # Delete workers that haven't said anything for a while (probably killed)\n        if self.last_active + config.worker_disconnect_delay < time.time():\n            return True",
        "begin_line": 384,
        "end_line": 387,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005385029617662897,
            "pseudo_dstar_susp": 0.0006858710562414266,
            "pseudo_tarantula_susp": 0.0005605381165919282,
            "pseudo_op2_susp": 0.0006858710562414266,
            "pseudo_barinel_susp": 0.0005605381165919282
        }
    },
    {
        "name": "luigi.scheduler.Worker.get_tasks#389",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.get_tasks(self, state, *statuses)",
        "snippet": "    def get_tasks(self, state, *statuses):\n        num_self_tasks = len(self.tasks)\n        num_state_tasks = sum(len(state._status_tasks[status]) for status in statuses)\n        if num_self_tasks < num_state_tasks:\n            return six.moves.filter(lambda task: task.status in statuses, self.tasks)\n        else:\n            return six.moves.filter(lambda task: self.id in task.workers, state.get_active_tasks_by_status(*statuses))",
        "begin_line": 389,
        "end_line": 395,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009541984732824427,
            "pseudo_dstar_susp": 0.0047169811320754715,
            "pseudo_tarantula_susp": 0.0005387931034482759,
            "pseudo_op2_susp": 0.0047169811320754715,
            "pseudo_barinel_susp": 0.0005387931034482759
        }
    },
    {
        "name": "luigi.scheduler.Worker.is_trivial_worker#397",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.is_trivial_worker(self, state)",
        "snippet": "    def is_trivial_worker(self, state):\n        \"\"\"\n        If it's not an assistant having only tasks that are without\n        requirements.\n\n        We have to pass the state parameter for optimization reasons.\n        \"\"\"\n        if self.assistant:\n            return False\n        return all(not task.resources for task in self.get_tasks(state, PENDING))",
        "begin_line": 397,
        "end_line": 406,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009900990099009901,
            "pseudo_dstar_susp": 0.004739336492890996,
            "pseudo_tarantula_susp": 0.0005672149744753262,
            "pseudo_op2_susp": 0.004739336492890996,
            "pseudo_barinel_susp": 0.0005672149744753262
        }
    },
    {
        "name": "luigi.scheduler.Worker.assistant#409",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.assistant(self)",
        "snippet": "    def assistant(self):\n        return self.info.get('assistant', False)",
        "begin_line": 409,
        "end_line": 410,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006153846153846154,
            "pseudo_dstar_susp": 0.0012376237623762376,
            "pseudo_tarantula_susp": 0.0005271481286241434,
            "pseudo_op2_susp": 0.0012376237623762376,
            "pseudo_barinel_susp": 0.0005271481286241434
        }
    },
    {
        "name": "luigi.scheduler.Worker.enabled#413",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.enabled(self)",
        "snippet": "    def enabled(self):\n        return not self.disabled",
        "begin_line": 413,
        "end_line": 414,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005659309564233164,
            "pseudo_dstar_susp": 0.0011312217194570137,
            "pseudo_tarantula_susp": 0.0004972650422675286,
            "pseudo_op2_susp": 0.0011312217194570137,
            "pseudo_barinel_susp": 0.0004972650422675286
        }
    },
    {
        "name": "luigi.scheduler.Worker.state#417",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.state(self)",
        "snippet": "    def state(self):\n        if self.enabled:\n            return WORKER_STATE_ACTIVE\n        else:\n            return WORKER_STATE_DISABLED",
        "begin_line": 417,
        "end_line": 421,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006195786864931846,
            "pseudo_dstar_susp": 0.0012468827930174563,
            "pseudo_tarantula_susp": 0.0005379236148466917,
            "pseudo_op2_susp": 0.0012468827930174563,
            "pseudo_barinel_susp": 0.0005379236148466917
        }
    },
    {
        "name": "luigi.scheduler.Worker.add_rpc_message#423",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.add_rpc_message(self, name, **kwargs)",
        "snippet": "    def add_rpc_message(self, name, **kwargs):\n        # the message has the format {'name': <function_name>, 'kwargs': <function_kwargs>}\n        self.rpc_messages.append({'name': name, 'kwargs': kwargs})",
        "begin_line": 423,
        "end_line": 425,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Worker.fetch_rpc_messages#427",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.fetch_rpc_messages(self)",
        "snippet": "    def fetch_rpc_messages(self):\n        messages = self.rpc_messages[:]\n        del self.rpc_messages[:]\n        return messages",
        "begin_line": 427,
        "end_line": 430,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016728002676480428,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Worker.__str__#432",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.__str__(self)",
        "snippet": "    def __str__(self):\n        return self.id",
        "begin_line": 432,
        "end_line": 433,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016594756057085962,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.__init__#445",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.__init__(self, state_path)",
        "snippet": "    def __init__(self, state_path):\n        self._state_path = state_path\n        self._tasks = {}  # map from id to a Task object\n        self._status_tasks = collections.defaultdict(dict)\n        self._active_workers = {}  # map from id to a Worker object\n        self._task_batchers = {}\n        self._metrics_collector = None",
        "begin_line": 445,
        "end_line": 451,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009578544061302681,
            "pseudo_dstar_susp": 0.003067484662576687,
            "pseudo_tarantula_susp": 0.0005787037037037037,
            "pseudo_op2_susp": 0.003067484662576687,
            "pseudo_barinel_susp": 0.000578368999421631
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_state#453",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_state(self)",
        "snippet": "    def get_state(self):\n        return self._tasks, self._active_workers, self._task_batchers",
        "begin_line": 453,
        "end_line": 454,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.set_state#456",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.set_state(self, state)",
        "snippet": "    def set_state(self, state):\n        self._tasks, self._active_workers = state[:2]\n        if len(state) >= 3:\n            self._task_batchers = state[2]",
        "begin_line": 456,
        "end_line": 459,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.dump#461",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.dump(self)",
        "snippet": "    def dump(self):\n        try:\n            with open(self._state_path, 'wb') as fobj:\n                pickle.dump(self.get_state(), fobj)\n        except IOError:\n            logger.warning(\"Failed saving scheduler state\", exc_info=1)\n        else:\n            logger.info(\"Saved state in %s\", self._state_path)",
        "begin_line": 461,
        "end_line": 468,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.load#471",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.load(self)",
        "snippet": "    def load(self):\n        if os.path.exists(self._state_path):\n            logger.info(\"Attempting to load state from %s\", self._state_path)\n            try:\n                with open(self._state_path, 'rb') as fobj:\n                    state = pickle.load(fobj)\n            except BaseException:\n                logger.exception(\"Error when loading state. Starting from empty state.\")\n                return\n\n            self.set_state(state)\n            self._status_tasks = collections.defaultdict(dict)\n            for task in six.itervalues(self._tasks):\n                self._status_tasks[task.status][task.id] = task\n        else:\n            logger.info(\"No prior state file exists at %s. Starting with empty state\", self._state_path)",
        "begin_line": 471,
        "end_line": 486,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_active_tasks#488",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_active_tasks(self)",
        "snippet": "    def get_active_tasks(self):\n        return six.itervalues(self._tasks)",
        "begin_line": 488,
        "end_line": 489,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005268703898840885,
            "pseudo_dstar_susp": 0.0006724949562878278,
            "pseudo_tarantula_susp": 0.0005361930294906167,
            "pseudo_op2_susp": 0.0006724949562878278,
            "pseudo_barinel_susp": 0.0005361930294906167
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_active_tasks_by_status#491",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_active_tasks_by_status(self, *statuses)",
        "snippet": "    def get_active_tasks_by_status(self, *statuses):\n        return itertools.chain.from_iterable(six.itervalues(self._status_tasks[status]) for status in statuses)",
        "begin_line": 491,
        "end_line": 492,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008771929824561404,
            "pseudo_dstar_susp": 0.004694835680751174,
            "pseudo_tarantula_susp": 0.0005181347150259067,
            "pseudo_op2_susp": 0.004694835680751174,
            "pseudo_barinel_susp": 0.0005181347150259067
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_active_task_count_for_status#494",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_active_task_count_for_status(self, status)",
        "snippet": "    def get_active_task_count_for_status(self, status):\n        if status:\n            return len(self._status_tasks[status])\n        else:\n            return len(self._tasks)",
        "begin_line": 494,
        "end_line": 498,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017196904557179707,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_batch_running_tasks#500",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_batch_running_tasks(self, batch_id)",
        "snippet": "    def get_batch_running_tasks(self, batch_id):\n        assert batch_id is not None\n        return [\n            task for task in self.get_active_tasks_by_status(BATCH_RUNNING)\n            if task.batch_id == batch_id\n        ]",
        "begin_line": 500,
        "end_line": 505,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016680567139282736,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.set_batcher#507",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.set_batcher(self, worker_id, family, batcher_args, max_batch_size)",
        "snippet": "    def set_batcher(self, worker_id, family, batcher_args, max_batch_size):\n        self._task_batchers.setdefault(worker_id, {})\n        self._task_batchers[worker_id][family] = (batcher_args, max_batch_size)",
        "begin_line": 507,
        "end_line": 509,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0001633986928104575,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_batcher#511",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_batcher(self, worker_id, family)",
        "snippet": "    def get_batcher(self, worker_id, family):\n        return self._task_batchers.get(worker_id, {}).get(family, (None, 1))",
        "begin_line": 511,
        "end_line": 512,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005073566717402334,
            "pseudo_dstar_susp": 0.0006548788474132286,
            "pseudo_tarantula_susp": 0.00048756704046806434,
            "pseudo_op2_susp": 0.0006548788474132286,
            "pseudo_barinel_susp": 0.00048756704046806434
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_task#520",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_task(self, task_id, default=None, setdefault=None)",
        "snippet": "    def get_task(self, task_id, default=None, setdefault=None):\n        if setdefault:\n            task = self._tasks.setdefault(task_id, setdefault)\n            self._status_tasks[task.status][task.id] = task\n            return task\n        else:\n            return self._tasks.get(task_id, default)",
        "begin_line": 520,
        "end_line": 526,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005793742757821553,
            "pseudo_dstar_susp": 0.0011862396204033216,
            "pseudo_tarantula_susp": 0.0005078720162519045,
            "pseudo_op2_susp": 0.0011862396204033216,
            "pseudo_barinel_susp": 0.0005078720162519045
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.has_task#528",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.has_task(self, task_id)",
        "snippet": "    def has_task(self, task_id):\n        return task_id in self._tasks",
        "begin_line": 528,
        "end_line": 529,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000499001996007984,
            "pseudo_dstar_susp": 0.000641025641025641,
            "pseudo_tarantula_susp": 0.0004791566842357451,
            "pseudo_op2_susp": 0.000641025641025641,
            "pseudo_barinel_susp": 0.0004791566842357451
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.re_enable#531",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.re_enable(self, task, config=None)",
        "snippet": "    def re_enable(self, task, config=None):\n        task.scheduler_disable_time = None\n        task.failures.clear()\n        if config:\n            self.set_status(task, FAILED, config)\n            task.failures.clear()",
        "begin_line": 531,
        "end_line": 536,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.set_batch_running#538",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.set_batch_running(self, task, batch_id, worker_id)",
        "snippet": "    def set_batch_running(self, task, batch_id, worker_id):\n        self.set_status(task, BATCH_RUNNING)\n        task.batch_id = batch_id\n        task.worker_running = worker_id\n        task.resources_running = task.resources\n        task.time_running = time.time()",
        "begin_line": 538,
        "end_line": 543,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0001646090534979424,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.set_status#545",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.set_status(self, task, new_status, config=None)",
        "snippet": "    def set_status(self, task, new_status, config=None):\n        if new_status == FAILED:\n            assert config is not None\n\n        if new_status == DISABLED and task.status in (RUNNING, BATCH_RUNNING):\n            return\n\n        remove_on_failure = task.batch_id is not None and not task.batchable\n\n        if task.status == DISABLED:\n            if new_status == DONE:\n                self.re_enable(task)\n\n            # don't allow workers to override a scheduler disable\n            elif task.scheduler_disable_time is not None and new_status != DISABLED:\n                return\n\n        if task.status == RUNNING and task.batch_id is not None and new_status != RUNNING:\n            for batch_task in self.get_batch_running_tasks(task.batch_id):\n                self.set_status(batch_task, new_status, config)\n                batch_task.batch_id = None\n            task.batch_id = None\n\n        if new_status == FAILED and task.status != DISABLED:\n            task.add_failure()\n            self.update_metrics_task_failed(task)\n            if task.has_excessive_failures():\n                task.scheduler_disable_time = time.time()\n                new_status = DISABLED\n                self.update_metrics_task_disabled(task, config)\n                if not config.batch_emails:\n                    notifications.send_error_email(\n                        'Luigi Scheduler: DISABLED {task} due to excessive failures'.format(task=task.id),\n                        '{task} failed {failures} times in the last {window} seconds, so it is being '\n                        'disabled for {persist} seconds'.format(\n                            failures=task.retry_policy.retry_count,\n                            task=task.id,\n                            window=config.disable_window,\n                            persist=config.disable_persist,\n                        ))\n        elif new_status == DISABLED:\n            task.scheduler_disable_time = None\n\n        if new_status != task.status:\n            self._status_tasks[task.status].pop(task.id)\n            self._status_tasks[new_status][task.id] = task\n            task.status = new_status\n            task.updated = time.time()\n\n            if new_status == DONE:\n                self.update_metrics_task_done(task)\n\n        if new_status == FAILED:\n            task.retry = time.time() + config.retry_delay\n            if remove_on_failure:\n                task.remove = time.time()",
        "begin_line": 545,
        "end_line": 600,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006153846153846154,
            "pseudo_dstar_susp": 0.0012376237623762376,
            "pseudo_tarantula_susp": 0.000588235294117647,
            "pseudo_op2_susp": 0.0012376237623762376,
            "pseudo_barinel_susp": 0.000588235294117647
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.fail_dead_worker_task#602",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.fail_dead_worker_task(self, task, config, assistants)",
        "snippet": "    def fail_dead_worker_task(self, task, config, assistants):\n        # If a running worker disconnects, tag all its jobs as FAILED and subject it to the same retry logic\n        if task.status in (BATCH_RUNNING, RUNNING) and task.worker_running and task.worker_running not in task.stakeholders | assistants:\n            logger.info(\"Task %r is marked as running by disconnected worker %r -> marking as \"\n                        \"FAILED with retry delay of %rs\", task.id, task.worker_running,\n                        config.retry_delay)\n            task.worker_running = None\n            self.set_status(task, FAILED, config)\n            task.retry = time.time() + config.retry_delay",
        "begin_line": 602,
        "end_line": 610,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005408328826392645,
            "pseudo_dstar_susp": 0.000689655172413793,
            "pseudo_tarantula_susp": 0.0005630630630630631,
            "pseudo_op2_susp": 0.000689655172413793,
            "pseudo_barinel_susp": 0.0005630630630630631
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.update_status#612",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.update_status(self, task, config)",
        "snippet": "    def update_status(self, task, config):\n        # Mark tasks with no remaining active stakeholders for deletion\n        if (not task.stakeholders) and (task.remove is None) and (task.status != RUNNING):\n            # We don't check for the RUNNING case, because that is already handled\n            # by the fail_dead_worker_task function.\n            logger.debug(\"Task %r has no stakeholders anymore -> might remove \"\n                         \"task in %s seconds\", task.id, config.remove_delay)\n            task.remove = time.time() + config.remove_delay\n\n        # Re-enable task after the disable time expires\n        if task.status == DISABLED and task.scheduler_disable_time is not None:\n            if time.time() - task.scheduler_disable_time > config.disable_persist:\n                self.re_enable(task, config)\n\n        # Reset FAILED tasks to PENDING if max timeout is reached, and retry delay is >= 0\n        if task.status == FAILED and config.retry_delay >= 0 and task.retry < time.time():\n            self.set_status(task, PENDING, config)",
        "begin_line": 612,
        "end_line": 628,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005408328826392645,
            "pseudo_dstar_susp": 0.000689655172413793,
            "pseudo_tarantula_susp": 0.0005630630630630631,
            "pseudo_op2_susp": 0.000689655172413793,
            "pseudo_barinel_susp": 0.0005630630630630631
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.may_prune#630",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.may_prune(self, task)",
        "snippet": "    def may_prune(self, task):\n        return task.remove and time.time() >= task.remove",
        "begin_line": 630,
        "end_line": 631,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005408328826392645,
            "pseudo_dstar_susp": 0.000689655172413793,
            "pseudo_tarantula_susp": 0.0005630630630630631,
            "pseudo_op2_susp": 0.000689655172413793,
            "pseudo_barinel_susp": 0.0005630630630630631
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.inactivate_tasks#633",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.inactivate_tasks(self, delete_tasks)",
        "snippet": "    def inactivate_tasks(self, delete_tasks):\n        # The terminology is a bit confusing: we used to \"delete\" tasks when they became inactive,\n        # but with a pluggable state storage, you might very well want to keep some history of\n        # older tasks as well. That's why we call it \"inactivate\" (as in the verb)\n        for task in delete_tasks:\n            task_obj = self._tasks.pop(task)\n            self._status_tasks[task_obj.status].pop(task)",
        "begin_line": 633,
        "end_line": 639,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005319148936170213,
            "pseudo_dstar_susp": 0.0006793478260869565,
            "pseudo_tarantula_susp": 0.0005461496450027307,
            "pseudo_op2_susp": 0.0006793478260869565,
            "pseudo_barinel_susp": 0.0005461496450027307
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_active_workers#641",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_active_workers(self, last_active_lt=None, last_get_work_gt=None)",
        "snippet": "    def get_active_workers(self, last_active_lt=None, last_get_work_gt=None):\n        for worker in six.itervalues(self._active_workers):\n            if last_active_lt is not None and worker.last_active >= last_active_lt:\n                continue\n            last_get_work = worker.last_get_work\n            if last_get_work_gt is not None and (\n                            last_get_work is None or last_get_work <= last_get_work_gt):\n                continue\n            yield worker",
        "begin_line": 641,
        "end_line": 649,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005184033177812338,
            "pseudo_dstar_susp": 0.0006648936170212766,
            "pseudo_tarantula_susp": 0.0005189413596263622,
            "pseudo_op2_susp": 0.0006648936170212766,
            "pseudo_barinel_susp": 0.0005189413596263622
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_assistants#651",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_assistants(self, last_active_lt=None)",
        "snippet": "    def get_assistants(self, last_active_lt=None):\n        return filter(lambda w: w.assistant, self.get_active_workers(last_active_lt))",
        "begin_line": 651,
        "end_line": 652,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007451564828614009,
            "pseudo_dstar_susp": 0.00234192037470726,
            "pseudo_tarantula_susp": 0.0005599104143337066,
            "pseudo_op2_susp": 0.00234192037470726,
            "pseudo_barinel_susp": 0.0005599104143337066
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_worker_ids#654",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_worker_ids(self)",
        "snippet": "    def get_worker_ids(self):\n        return self._active_workers.keys()  # only used for unit tests",
        "begin_line": 654,
        "end_line": 655,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_worker#657",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_worker(self, worker_id)",
        "snippet": "    def get_worker(self, worker_id):\n        return self._active_workers.setdefault(worker_id, Worker(worker_id))",
        "begin_line": 657,
        "end_line": 658,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005611672278338945,
            "pseudo_dstar_susp": 0.0011185682326621924,
            "pseudo_tarantula_susp": 0.0004948045522018803,
            "pseudo_op2_susp": 0.0011185682326621924,
            "pseudo_barinel_susp": 0.0004948045522018803
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.inactivate_workers#660",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.inactivate_workers(self, delete_workers)",
        "snippet": "    def inactivate_workers(self, delete_workers):\n        # Mark workers as inactive\n        for worker in delete_workers:\n            self._active_workers.pop(worker)\n        self._remove_workers_from_tasks(delete_workers)",
        "begin_line": 660,
        "end_line": 664,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005319148936170213,
            "pseudo_dstar_susp": 0.0006793478260869565,
            "pseudo_tarantula_susp": 0.0005461496450027307,
            "pseudo_op2_susp": 0.0006793478260869565,
            "pseudo_barinel_susp": 0.0005461496450027307
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState._remove_workers_from_tasks#666",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState._remove_workers_from_tasks(self, workers, remove_stakeholders=True)",
        "snippet": "    def _remove_workers_from_tasks(self, workers, remove_stakeholders=True):\n        for task in self.get_active_tasks():\n            if remove_stakeholders:\n                task.stakeholders.difference_update(workers)\n            task.workers -= workers",
        "begin_line": 666,
        "end_line": 670,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005408328826392645,
            "pseudo_dstar_susp": 0.000689655172413793,
            "pseudo_tarantula_susp": 0.0005630630630630631,
            "pseudo_op2_susp": 0.000689655172413793,
            "pseudo_barinel_susp": 0.0005630630630630631
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.disable_workers#672",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.disable_workers(self, worker_ids)",
        "snippet": "    def disable_workers(self, worker_ids):\n        self._remove_workers_from_tasks(worker_ids, remove_stakeholders=False)\n        for worker_id in worker_ids:\n            worker = self.get_worker(worker_id)\n            worker.disabled = True\n            worker.tasks.clear()",
        "begin_line": 672,
        "end_line": 677,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0001756543123133673,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.update_metrics_task_disabled#682",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.update_metrics_task_disabled(self, task, config)",
        "snippet": "    def update_metrics_task_disabled(self, task, config):\n        self._metrics_collector.handle_task_disabled(task, config)",
        "begin_line": 682,
        "end_line": 683,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0001726817475392851,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.update_metrics_task_failed#685",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.update_metrics_task_failed(self, task)",
        "snippet": "    def update_metrics_task_failed(self, task):\n        self._metrics_collector.handle_task_failed(task)",
        "begin_line": 685,
        "end_line": 686,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004899559039686428,
            "pseudo_dstar_susp": 0.0004899559039686428,
            "pseudo_tarantula_susp": 0.0005714285714285715,
            "pseudo_op2_susp": 0.0004899559039686428,
            "pseudo_barinel_susp": 0.0005714285714285715
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.update_metrics_task_done#688",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.update_metrics_task_done(self, task)",
        "snippet": "    def update_metrics_task_done(self, task):\n        self._metrics_collector.handle_task_done(task)",
        "begin_line": 688,
        "end_line": 689,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000591715976331361,
            "pseudo_dstar_susp": 0.0006983240223463687,
            "pseudo_tarantula_susp": 0.000588235294117647,
            "pseudo_op2_susp": 0.0006983240223463687,
            "pseudo_barinel_susp": 0.000588235294117647
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.__init__#699",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.__init__(self, config=None, resources=None, task_history_impl=None, **kwargs)",
        "snippet": "    def __init__(self, config=None, resources=None, task_history_impl=None, **kwargs):\n        \"\"\"\n        Keyword Arguments:\n        :param config: an object of class \"scheduler\" or None (in which the global instance will be used)\n        :param resources: a dict of str->int constraints\n        :param task_history_impl: ignore config and use this object as the task history\n        \"\"\"\n        self._config = config or scheduler(**kwargs)\n        self._state = SimpleTaskState(self._config.state_path)\n\n        if task_history_impl:\n            self._task_history = task_history_impl\n        elif self._config.record_task_history:\n            from luigi import db_task_history  # Needs sqlalchemy, thus imported here\n            self._task_history = db_task_history.DbTaskHistory()\n        else:\n            self._task_history = history.NopHistory()\n        self._resources = resources or configuration.get_config().getintdict('resources')  # TODO: Can we make this a Parameter?\n        self._make_task = functools.partial(Task, retry_policy=self._config._get_retry_policy())\n        self._worker_requests = {}\n        self._paused = False\n\n        if self._config.batch_emails:\n            self._email_batcher = BatchNotifier()\n\n        self._state._metrics_collector = MetricsCollectors.get(self._config.metrics_collector)",
        "begin_line": 699,
        "end_line": 724,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000975609756097561,
            "pseudo_dstar_susp": 0.003257328990228013,
            "pseudo_tarantula_susp": 0.0005851375073142189,
            "pseudo_op2_susp": 0.003257328990228013,
            "pseudo_barinel_susp": 0.0005851375073142189
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.load#726",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.load(self)",
        "snippet": "    def load(self):\n        self._state.load()",
        "begin_line": 726,
        "end_line": 727,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.dump#729",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.dump(self)",
        "snippet": "    def dump(self):\n        self._state.dump()\n        if self._config.batch_emails:\n            self._email_batcher.send_email()",
        "begin_line": 729,
        "end_line": 732,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.prune#735",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.prune(self)",
        "snippet": "    def prune(self):\n        logger.debug(\"Starting pruning of task graph\")\n        self._prune_workers()\n        self._prune_tasks()\n        self._prune_emails()\n        logger.debug(\"Done pruning task graph\")",
        "begin_line": 735,
        "end_line": 740,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005319148936170213,
            "pseudo_dstar_susp": 0.0006793478260869565,
            "pseudo_tarantula_susp": 0.0005461496450027307,
            "pseudo_op2_susp": 0.0006793478260869565,
            "pseudo_barinel_susp": 0.0005461496450027307
        }
    },
    {
        "name": "luigi.scheduler.Scheduler._prune_workers#742",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler._prune_workers(self)",
        "snippet": "    def _prune_workers(self):\n        remove_workers = []\n        for worker in self._state.get_active_workers():\n            if worker.prune(self._config):\n                logger.debug(\"Worker %s timed out (no contact for >=%ss)\", worker, self._config.worker_disconnect_delay)\n                remove_workers.append(worker.id)\n\n        self._state.inactivate_workers(remove_workers)",
        "begin_line": 742,
        "end_line": 749,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005387931034482759,
            "pseudo_dstar_susp": 0.0006863417982155113,
            "pseudo_tarantula_susp": 0.0005608524957936063,
            "pseudo_op2_susp": 0.0006863417982155113,
            "pseudo_barinel_susp": 0.0005608524957936063
        }
    },
    {
        "name": "luigi.scheduler.Scheduler._prune_tasks#751",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler._prune_tasks(self)",
        "snippet": "    def _prune_tasks(self):\n        assistant_ids = {w.id for w in self._state.get_assistants()}\n        remove_tasks = []\n\n        for task in self._state.get_active_tasks():\n            self._state.fail_dead_worker_task(task, self._config, assistant_ids)\n            self._state.update_status(task, self._config)\n            if self._state.may_prune(task):\n                logger.info(\"Removing task %r\", task.id)\n                remove_tasks.append(task.id)\n\n        self._state.inactivate_tasks(remove_tasks)",
        "begin_line": 751,
        "end_line": 762,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006988120195667365,
            "pseudo_dstar_susp": 0.002336448598130841,
            "pseudo_tarantula_susp": 0.0005630630630630631,
            "pseudo_op2_susp": 0.002336448598130841,
            "pseudo_barinel_susp": 0.0005630630630630631
        }
    },
    {
        "name": "luigi.scheduler.Scheduler._prune_emails#764",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler._prune_emails(self)",
        "snippet": "    def _prune_emails(self):\n        if self._config.batch_emails:\n            self._email_batcher.update()",
        "begin_line": 764,
        "end_line": 766,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005319148936170213,
            "pseudo_dstar_susp": 0.0006793478260869565,
            "pseudo_tarantula_susp": 0.0005461496450027307,
            "pseudo_op2_susp": 0.0006793478260869565,
            "pseudo_barinel_susp": 0.0005461496450027307
        }
    },
    {
        "name": "luigi.scheduler.Scheduler._update_worker#768",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler._update_worker(self, worker_id, worker_reference=None, get_work=False)",
        "snippet": "    def _update_worker(self, worker_id, worker_reference=None, get_work=False):\n        # Keep track of whenever the worker was last active.\n        # For convenience also return the worker object.\n        worker = self._state.get_worker(worker_id)\n        worker.update(worker_reference, get_work=get_work)\n        return worker",
        "begin_line": 768,
        "end_line": 773,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000564334085778781,
            "pseudo_dstar_susp": 0.0011248593925759281,
            "pseudo_tarantula_susp": 0.000496031746031746,
            "pseudo_op2_susp": 0.0011248593925759281,
            "pseudo_barinel_susp": 0.000496031746031746
        }
    },
    {
        "name": "luigi.scheduler.Scheduler._update_priority#775",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler._update_priority(self, task, prio, worker)",
        "snippet": "    def _update_priority(self, task, prio, worker):\n        \"\"\"\n        Update priority of the given task.\n\n        Priority can only be increased.\n        If the task doesn't exist, a placeholder task is created to preserve priority when the task is later scheduled.\n        \"\"\"\n        task.priority = prio = max(prio, task.priority)\n        for dep in task.deps or []:\n            t = self._state.get_task(dep)\n            if t is not None and prio > t.priority:\n                self._update_priority(t, prio, worker)",
        "begin_line": 775,
        "end_line": 786,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005793742757821553,
            "pseudo_dstar_susp": 0.0011862396204033216,
            "pseudo_tarantula_susp": 0.0005078720162519045,
            "pseudo_op2_susp": 0.0011862396204033216,
            "pseudo_barinel_susp": 0.0005078720162519045
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.add_task_batcher#789",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.add_task_batcher(self, worker, task_family, batched_args, max_batch_size=float('inf'))",
        "snippet": "    def add_task_batcher(self, worker, task_family, batched_args, max_batch_size=float('inf')):\n        self._state.set_batcher(worker, task_family, batched_args, max_batch_size)",
        "begin_line": 789,
        "end_line": 790,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0001633986928104575,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.forgive_failures#793",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.forgive_failures(self, task_id=None)",
        "snippet": "    def forgive_failures(self, task_id=None):\n        status = PENDING\n        task = self._state.get_task(task_id)\n        if task is None:\n            return {\"task_id\": task_id, \"status\": None}\n\n        # we forgive only failures\n        if task.status == FAILED:\n            # forgive but do not forget\n            self._update_task_history(task, status)\n            self._state.set_status(task, status, self._config)\n        return {\"task_id\": task_id, \"status\": task.status}",
        "begin_line": 793,
        "end_line": 804,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.add_task#807",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.add_task(self, task_id=None, status=PENDING, runnable=True, deps=None, new_deps=None, expl=None, resources=None, priority=0, family='', module=None, params=None, param_visibilities=None, accepts_messages=False, assistant=False, tracking_url=None, worker=None, batchable=None, batch_id=None, retry_policy_dict=None, owners=None, **kwargs)",
        "snippet": "    def add_task(self, task_id=None, status=PENDING, runnable=True,\n                 deps=None, new_deps=None, expl=None, resources=None,\n                 priority=0, family='', module=None, params=None, param_visibilities=None, accepts_messages=False,\n                 assistant=False, tracking_url=None, worker=None, batchable=None,\n                 batch_id=None, retry_policy_dict=None, owners=None, **kwargs):\n        \"\"\"\n        * add task identified by task_id if it doesn't exist\n        * if deps is not None, update dependency list\n        * update status of task\n        * add additional workers/stakeholders\n        * update priority when needed\n        \"\"\"\n        assert worker is not None\n        worker_id = worker\n        worker = self._update_worker(worker_id)\n\n        resources = {} if resources is None else resources.copy()\n\n        if retry_policy_dict is None:\n            retry_policy_dict = {}\n\n        retry_policy = self._generate_retry_policy(retry_policy_dict)\n\n        if worker.enabled:\n            _default_task = self._make_task(\n                task_id=task_id, status=PENDING, deps=deps, resources=resources,\n                priority=priority, family=family, module=module, params=params, param_visibilities=param_visibilities,\n            )\n        else:\n            _default_task = None\n\n        task = self._state.get_task(task_id, setdefault=_default_task)\n\n        if task is None or (task.status != RUNNING and not worker.enabled):\n            return\n\n        # for setting priority, we'll sometimes create tasks with unset family and params\n        if not task.family:\n            task.family = family\n        if not getattr(task, 'module', None):\n            task.module = module\n        if not getattr(task, 'param_visibilities', None):\n            task.param_visibilities = _get_default(param_visibilities, {})\n        if not task.params:\n            task.set_params(params)\n\n        if batch_id is not None:\n            task.batch_id = batch_id\n        if status == RUNNING and not task.worker_running:\n            task.worker_running = worker_id\n            if batch_id:\n                # copy resources_running of the first batch task\n                batch_tasks = self._state.get_batch_running_tasks(batch_id)\n                task.resources_running = batch_tasks[0].resources_running.copy()\n            task.time_running = time.time()\n\n        if accepts_messages is not None:\n            task.accepts_messages = accepts_messages\n\n        if tracking_url is not None or task.status != RUNNING:\n            task.tracking_url = tracking_url\n            if task.batch_id is not None:\n                for batch_task in self._state.get_batch_running_tasks(task.batch_id):\n                    batch_task.tracking_url = tracking_url\n\n        if batchable is not None:\n            task.batchable = batchable\n\n        if task.remove is not None:\n            task.remove = None  # unmark task for removal so it isn't removed after being added\n\n        if expl is not None:\n            task.expl = expl\n            if task.batch_id is not None:\n                for batch_task in self._state.get_batch_running_tasks(task.batch_id):\n                    batch_task.expl = expl\n\n        task_is_not_running = task.status not in (RUNNING, BATCH_RUNNING)\n        task_started_a_run = status in (DONE, FAILED, RUNNING)\n        running_on_this_worker = task.worker_running == worker_id\n        if task_is_not_running or (task_started_a_run and running_on_this_worker) or new_deps:\n            # don't allow re-scheduling of task while it is running, it must either fail or succeed on the worker actually running it\n            if status != task.status or status == PENDING:\n                # Update the DB only if there was a acctual change, to prevent noise.\n                # We also check for status == PENDING b/c that's the default value\n                # (so checking for status != task.status woule lie)\n                self._update_task_history(task, status)\n            self._state.set_status(task, PENDING if status == SUSPENDED else status, self._config)\n\n        if status == FAILED and self._config.batch_emails:\n            batched_params, _ = self._state.get_batcher(worker_id, family)\n            if batched_params:\n                unbatched_params = {\n                    param: value\n                    for param, value in six.iteritems(task.params)\n                    if param not in batched_params\n                }\n            else:\n                unbatched_params = task.params\n            try:\n                expl_raw = json.loads(expl)\n            except ValueError:\n                expl_raw = expl\n\n            self._email_batcher.add_failure(\n                task.pretty_id, task.family, unbatched_params, expl_raw, owners)\n            if task.status == DISABLED:\n                self._email_batcher.add_disable(\n                    task.pretty_id, task.family, unbatched_params, owners)\n\n        if deps is not None:\n            task.deps = set(deps)\n\n        if new_deps is not None:\n            task.deps.update(new_deps)\n\n        if resources is not None:\n            task.resources = resources\n\n        if worker.enabled and not assistant:\n            task.stakeholders.add(worker_id)\n\n            # Task dependencies might not exist yet. Let's create dummy tasks for them for now.\n            # Otherwise the task dependencies might end up being pruned if scheduling takes a long time\n            for dep in task.deps or []:\n                t = self._state.get_task(dep, setdefault=self._make_task(task_id=dep, status=UNKNOWN, deps=None, priority=priority))\n                t.stakeholders.add(worker_id)\n\n        self._update_priority(task, priority, worker_id)\n\n        # Because some tasks (non-dynamic dependencies) are `_make_task`ed\n        # before we know their retry_policy, we always set it here\n        task.retry_policy = retry_policy\n\n        if runnable and status != FAILED and worker.enabled:\n            task.workers.add(worker_id)\n            self._state.get_worker(worker_id).tasks.add(task)\n            task.runnable = runnable",
        "begin_line": 807,
        "end_line": 944,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007524454477050414,
            "pseudo_dstar_susp": 0.0013333333333333333,
            "pseudo_tarantula_susp": 0.000657030223390276,
            "pseudo_op2_susp": 0.0013333333333333333,
            "pseudo_barinel_susp": 0.000657030223390276
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.announce_scheduling_failure#947",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.announce_scheduling_failure(self, task_name, family, params, expl, owners, **kwargs)",
        "snippet": "    def announce_scheduling_failure(self, task_name, family, params, expl, owners, **kwargs):\n        if not self._config.batch_emails:\n            return\n        worker_id = kwargs['worker']\n        batched_params, _ = self._state.get_batcher(worker_id, family)\n        if batched_params:\n            unbatched_params = {\n                param: value\n                for param, value in six.iteritems(params)\n                if param not in batched_params\n            }\n        else:\n            unbatched_params = params\n        self._email_batcher.add_scheduling_fail(task_name, family, unbatched_params, expl, owners)",
        "begin_line": 947,
        "end_line": 960,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.add_worker#963",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.add_worker(self, worker, info, **kwargs)",
        "snippet": "    def add_worker(self, worker, info, **kwargs):\n        self._state.get_worker(worker).add_info(info)",
        "begin_line": 963,
        "end_line": 964,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008,
            "pseudo_dstar_susp": 0.001388888888888889,
            "pseudo_tarantula_susp": 0.0006798096532970768,
            "pseudo_op2_susp": 0.001388888888888889,
            "pseudo_barinel_susp": 0.0006798096532970768
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.disable_worker#967",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.disable_worker(self, worker)",
        "snippet": "    def disable_worker(self, worker):\n        self._state.disable_workers({worker})",
        "begin_line": 967,
        "end_line": 968,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0001756543123133673,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.set_worker_processes#971",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.set_worker_processes(self, worker, n)",
        "snippet": "    def set_worker_processes(self, worker, n):\n        self._state.get_worker(worker).add_rpc_message('set_worker_processes', n=n)",
        "begin_line": 971,
        "end_line": 972,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.send_scheduler_message#975",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.send_scheduler_message(self, worker, task, content)",
        "snippet": "    def send_scheduler_message(self, worker, task, content):\n        if not self._config.send_messages:\n            return {\"message_id\": None}\n\n        message_id = str(uuid.uuid4())\n        self._state.get_worker(worker).add_rpc_message('dispatch_scheduler_message', task_id=task,\n                                                       message_id=message_id, content=content)\n\n        return {\"message_id\": message_id}",
        "begin_line": 975,
        "end_line": 983,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.add_scheduler_message_response#986",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.add_scheduler_message_response(self, task_id, message_id, response)",
        "snippet": "    def add_scheduler_message_response(self, task_id, message_id, response):\n        if self._state.has_task(task_id):\n            task = self._state.get_task(task_id)\n            task.scheduler_message_responses[message_id] = response",
        "begin_line": 986,
        "end_line": 989,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.get_scheduler_message_response#992",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.get_scheduler_message_response(self, task_id, message_id)",
        "snippet": "    def get_scheduler_message_response(self, task_id, message_id):\n        response = None\n        if self._state.has_task(task_id):\n            task = self._state.get_task(task_id)\n            response = task.scheduler_message_responses.pop(message_id, None)\n        return {\"response\": response}",
        "begin_line": 992,
        "end_line": 997,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.is_pause_enabled#1000",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.is_pause_enabled(self)",
        "snippet": "    def is_pause_enabled(self):\n        return {'enabled': self._config.pause_enabled}",
        "begin_line": 1000,
        "end_line": 1001,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.is_paused#1004",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.is_paused(self)",
        "snippet": "    def is_paused(self):\n        return {'paused': self._paused}",
        "begin_line": 1004,
        "end_line": 1005,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.pause#1008",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.pause(self)",
        "snippet": "    def pause(self):\n        if self._config.pause_enabled:\n            self._paused = True",
        "begin_line": 1008,
        "end_line": 1010,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.unpause#1013",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.unpause(self)",
        "snippet": "    def unpause(self):\n        if self._config.pause_enabled:\n            self._paused = False",
        "begin_line": 1013,
        "end_line": 1015,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.update_resources#1018",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.update_resources(self, **resources)",
        "snippet": "    def update_resources(self, **resources):\n        if self._resources is None:\n            self._resources = {}\n        self._resources.update(resources)",
        "begin_line": 1018,
        "end_line": 1021,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017053206002728513,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.update_resource#1024",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.update_resource(self, resource, amount)",
        "snippet": "    def update_resource(self, resource, amount):\n        if not isinstance(amount, int) or amount < 0:\n            return False\n        self._resources[resource] = amount\n        return True",
        "begin_line": 1024,
        "end_line": 1028,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler._generate_retry_policy#1030",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler._generate_retry_policy(self, task_retry_policy_dict)",
        "snippet": "    def _generate_retry_policy(self, task_retry_policy_dict):\n        retry_policy_dict = self._config._get_retry_policy()._asdict()\n        retry_policy_dict.update({k: v for k, v in six.iteritems(task_retry_policy_dict) if v is not None})\n        return RetryPolicy(**retry_policy_dict)",
        "begin_line": 1030,
        "end_line": 1033,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008019246190858059,
            "pseudo_dstar_susp": 0.004672897196261682,
            "pseudo_tarantula_susp": 0.00049800796812749,
            "pseudo_op2_susp": 0.004672897196261682,
            "pseudo_barinel_susp": 0.00049800796812749
        }
    },
    {
        "name": "luigi.scheduler.Scheduler._has_resources#1035",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler._has_resources(self, needed_resources, used_resources)",
        "snippet": "    def _has_resources(self, needed_resources, used_resources):\n        if needed_resources is None:\n            return True\n\n        available_resources = self._resources or {}\n        for resource, amount in six.iteritems(needed_resources):\n            if amount + used_resources[resource] > available_resources.get(resource, 1):\n                return False\n        return True",
        "begin_line": 1035,
        "end_line": 1043,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005096839959225281,
            "pseudo_dstar_susp": 0.0006587615283267457,
            "pseudo_tarantula_susp": 0.0004899559039686428,
            "pseudo_op2_susp": 0.0006587615283267457,
            "pseudo_barinel_susp": 0.0004899559039686428
        }
    },
    {
        "name": "luigi.scheduler.Scheduler._used_resources#1045",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler._used_resources(self)",
        "snippet": "    def _used_resources(self):\n        used_resources = collections.defaultdict(int)\n        if self._resources is not None:\n            for task in self._state.get_active_tasks_by_status(RUNNING):\n                resources_running = getattr(task, \"resources_running\", task.resources)\n                if resources_running:\n                    for resource, amount in six.iteritems(resources_running):\n                        used_resources[resource] += amount\n        return used_resources",
        "begin_line": 1045,
        "end_line": 1053,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0001756543123133673,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler._rank#1055",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler._rank(self, task)",
        "snippet": "    def _rank(self, task):\n        \"\"\"\n        Return worker's rank function for task scheduling.\n\n        :return:\n        \"\"\"\n\n        return task.priority, -task.time",
        "begin_line": 1055,
        "end_line": 1062,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000505050505050505,
            "pseudo_dstar_susp": 0.0006510416666666666,
            "pseudo_tarantula_susp": 0.0004854368932038835,
            "pseudo_op2_susp": 0.0006510416666666666,
            "pseudo_barinel_susp": 0.0004854368932038835
        }
    },
    {
        "name": "luigi.scheduler.Scheduler._schedulable#1064",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler._schedulable(self, task)",
        "snippet": "    def _schedulable(self, task):\n        if task.status != PENDING:\n            return False\n        for dep in task.deps:\n            dep_task = self._state.get_task(dep, default=None)\n            if dep_task is None or dep_task.status != DONE:\n                return False\n        return True",
        "begin_line": 1064,
        "end_line": 1071,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000508646998982706,
            "pseudo_dstar_susp": 0.000657030223390276,
            "pseudo_tarantula_susp": 0.0004889975550122249,
            "pseudo_op2_susp": 0.000657030223390276,
            "pseudo_barinel_susp": 0.0004889975550122249
        }
    },
    {
        "name": "luigi.scheduler.Scheduler._reset_orphaned_batch_running_tasks#1073",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler._reset_orphaned_batch_running_tasks(self, worker_id)",
        "snippet": "    def _reset_orphaned_batch_running_tasks(self, worker_id):\n        running_batch_ids = {\n            task.batch_id\n            for task in self._state.get_active_tasks_by_status(RUNNING)\n            if task.worker_running == worker_id\n        }\n        orphaned_tasks = [\n            task for task in self._state.get_active_tasks_by_status(BATCH_RUNNING)\n            if task.worker_running == worker_id and task.batch_id not in running_batch_ids\n        ]\n        for task in orphaned_tasks:\n            self._state.set_status(task, PENDING)",
        "begin_line": 1073,
        "end_line": 1084,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012330456226880395,
            "pseudo_dstar_susp": 0.004878048780487805,
            "pseudo_tarantula_susp": 0.0007886435331230284,
            "pseudo_op2_susp": 0.004878048780487805,
            "pseudo_barinel_susp": 0.0007886435331230284
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.count_pending#1087",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.count_pending(self, worker)",
        "snippet": "    def count_pending(self, worker):\n        worker_id, worker = worker, self._state.get_worker(worker)\n\n        num_pending, num_unique_pending, num_pending_last_scheduled = 0, 0, 0\n        running_tasks = []\n\n        upstream_status_table = {}\n        for task in worker.get_tasks(self._state, RUNNING):\n            if self._upstream_status(task.id, upstream_status_table) == UPSTREAM_DISABLED:\n                continue\n            # Return a list of currently running tasks to the client,\n            # makes it easier to troubleshoot\n            other_worker = self._state.get_worker(task.worker_running)\n            if other_worker is not None:\n                more_info = {'task_id': task.id, 'worker': str(other_worker)}\n                more_info.update(other_worker.info)\n                running_tasks.append(more_info)\n\n        for task in worker.get_tasks(self._state, PENDING, FAILED):\n            if self._upstream_status(task.id, upstream_status_table) == UPSTREAM_DISABLED:\n                continue\n            num_pending += 1\n            num_unique_pending += int(len(task.workers) == 1)\n            num_pending_last_scheduled += int(task.workers.peek(last=True) == worker_id)\n\n        return {\n            'n_pending_tasks': num_pending,\n            'n_unique_pending': num_unique_pending,\n            'n_pending_last_scheduled': num_pending_last_scheduled,\n            'worker_state': worker.state,\n            'running_tasks': running_tasks,\n        }",
        "begin_line": 1087,
        "end_line": 1118,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006234413965087282,
            "pseudo_dstar_susp": 0.0012626262626262627,
            "pseudo_tarantula_susp": 0.0005411255411255411,
            "pseudo_op2_susp": 0.0012626262626262627,
            "pseudo_barinel_susp": 0.0005411255411255411
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.get_work#1121",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.get_work(self, host=None, assistant=False, current_tasks=None, worker=None, **kwargs)",
        "snippet": "    def get_work(self, host=None, assistant=False, current_tasks=None, worker=None, **kwargs):\n        # TODO: remove any expired nodes\n\n        # Algo: iterate over all nodes, find the highest priority node no dependencies and available\n        # resources.\n\n        # Resource checking looks both at currently available resources and at which resources would\n        # be available if all running tasks died and we rescheduled all workers greedily. We do both\n        # checks in order to prevent a worker with many low-priority tasks from starving other\n        # workers with higher priority tasks that share the same resources.\n\n        # TODO: remove tasks that can't be done, figure out if the worker has absolutely\n        # nothing it can wait for\n\n        if self._config.prune_on_get_work:\n            self.prune()\n\n        assert worker is not None\n        worker_id = worker\n        worker = self._update_worker(\n            worker_id,\n            worker_reference={'host': host},\n            get_work=True)\n        if not worker.enabled:\n            reply = {'n_pending_tasks': 0,\n                     'running_tasks': [],\n                     'task_id': None,\n                     'n_unique_pending': 0,\n                     'worker_state': worker.state,\n                     }\n            return reply\n\n        if assistant:\n            self.add_worker(worker_id, [('assistant', assistant)])\n\n        batched_params, unbatched_params, batched_tasks, max_batch_size = None, None, [], 1\n        best_task = None\n        if current_tasks is not None:\n            ct_set = set(current_tasks)\n            for task in sorted(self._state.get_active_tasks_by_status(RUNNING), key=self._rank):\n                if task.worker_running == worker_id and task.id not in ct_set:\n                    best_task = task\n\n        if current_tasks is not None:\n            # batch running tasks that weren't claimed since the last get_work go back in the pool\n            self._reset_orphaned_batch_running_tasks(worker_id)\n\n        greedy_resources = collections.defaultdict(int)\n\n        worker = self._state.get_worker(worker_id)\n        if self._paused:\n            relevant_tasks = []\n        elif worker.is_trivial_worker(self._state):\n            relevant_tasks = worker.get_tasks(self._state, PENDING, RUNNING)\n            used_resources = collections.defaultdict(int)\n            greedy_workers = dict()  # If there's no resources, then they can grab any task\n        else:\n            relevant_tasks = self._state.get_active_tasks_by_status(PENDING, RUNNING)\n            used_resources = self._used_resources()\n            activity_limit = time.time() - self._config.worker_disconnect_delay\n            active_workers = self._state.get_active_workers(last_get_work_gt=activity_limit)\n            greedy_workers = dict((worker.id, worker.info.get('workers', 1))\n                                  for worker in active_workers)\n        tasks = list(relevant_tasks)\n        tasks.sort(key=self._rank, reverse=True)\n\n        for task in tasks:\n            if (best_task and batched_params and task.family == best_task.family and\n                    len(batched_tasks) < max_batch_size and task.is_batchable() and all(\n                    task.params.get(name) == value for name, value in unbatched_params.items()) and\n                    task.resources == best_task.resources and self._schedulable(task)):\n                for name, params in batched_params.items():\n                    params.append(task.params.get(name))\n                batched_tasks.append(task)\n            if best_task:\n                continue\n\n            if task.status == RUNNING and (task.worker_running in greedy_workers):\n                greedy_workers[task.worker_running] -= 1\n                for resource, amount in six.iteritems((getattr(task, 'resources_running', task.resources) or {})):\n                    greedy_resources[resource] += amount\n\n            if self._schedulable(task) and self._has_resources(task.resources, greedy_resources):\n                in_workers = (assistant and task.runnable) or worker_id in task.workers\n                if in_workers and self._has_resources(task.resources, used_resources):\n                    best_task = task\n                    batch_param_names, max_batch_size = self._state.get_batcher(\n                        worker_id, task.family)\n                    if batch_param_names and task.is_batchable():\n                        try:\n                            batched_params = {\n                                name: [task.params[name]] for name in batch_param_names\n                            }\n                            unbatched_params = {\n                                name: value for name, value in task.params.items()\n                                if name not in batched_params\n                            }\n                            batched_tasks.append(task)\n                        except KeyError:\n                            batched_params, unbatched_params = None, None\n                else:\n                    workers = itertools.chain(task.workers, [worker_id]) if assistant else task.workers\n                    for task_worker in workers:\n                        if greedy_workers.get(task_worker, 0) > 0:\n                            # use up a worker\n                            greedy_workers[task_worker] -= 1\n\n                            # keep track of the resources used in greedy scheduling\n                            for resource, amount in six.iteritems((task.resources or {})):\n                                greedy_resources[resource] += amount\n\n                            break\n\n        reply = self.count_pending(worker_id)\n\n        if len(batched_tasks) > 1:\n            batch_string = '|'.join(task.id for task in batched_tasks)\n            batch_id = hashlib.md5(batch_string.encode('utf-8')).hexdigest()\n            for task in batched_tasks:\n                self._state.set_batch_running(task, batch_id, worker_id)\n\n            combined_params = best_task.params.copy()\n            combined_params.update(batched_params)\n\n            reply['task_id'] = None\n            reply['task_family'] = best_task.family\n            reply['task_module'] = getattr(best_task, 'module', None)\n            reply['task_params'] = combined_params\n            reply['batch_id'] = batch_id\n            reply['batch_task_ids'] = [task.id for task in batched_tasks]\n\n        elif best_task:\n            self.update_metrics_task_started(best_task)\n            self._state.set_status(best_task, RUNNING, self._config)\n            best_task.worker_running = worker_id\n            best_task.resources_running = best_task.resources.copy()\n            best_task.time_running = time.time()\n            self._update_task_history(best_task, RUNNING, host=host)\n\n            reply['task_id'] = best_task.id\n            reply['task_family'] = best_task.family\n            reply['task_module'] = getattr(best_task, 'module', None)\n            reply['task_params'] = best_task.params\n\n        else:\n            reply['task_id'] = None\n\n        return reply",
        "begin_line": 1121,
        "end_line": 1268,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009398496240601503,
            "pseudo_dstar_susp": 0.0017605633802816902,
            "pseudo_tarantula_susp": 0.0011376564277588168,
            "pseudo_op2_susp": 0.0017605633802816902,
            "pseudo_barinel_susp": 0.0011376564277588168
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.ping#1271",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.ping(self, **kwargs)",
        "snippet": "    def ping(self, **kwargs):\n        worker_id = kwargs['worker']\n        worker = self._update_worker(worker_id)\n        return {\"rpc_messages\": worker.fetch_rpc_messages()}",
        "begin_line": 1271,
        "end_line": 1274,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016739203213927018,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler._upstream_status#1276",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler._upstream_status(self, task_id, upstream_status_table)",
        "snippet": "    def _upstream_status(self, task_id, upstream_status_table):\n        if task_id in upstream_status_table:\n            return upstream_status_table[task_id]\n        elif self._state.has_task(task_id):\n            task_stack = [task_id]\n\n            while task_stack:\n                dep_id = task_stack.pop()\n                dep = self._state.get_task(dep_id)\n                if dep:\n                    if dep.status == DONE:\n                        continue\n                    if dep_id not in upstream_status_table:\n                        if dep.status == PENDING and dep.deps:\n                            task_stack += [dep_id] + list(dep.deps)\n                            upstream_status_table[dep_id] = ''  # will be updated postorder\n                        else:\n                            dep_status = STATUS_TO_UPSTREAM_MAP.get(dep.status, '')\n                            upstream_status_table[dep_id] = dep_status\n                    elif upstream_status_table[dep_id] == '' and dep.deps:\n                        # This is the postorder update step when we set the\n                        # status based on the previously calculated child elements\n                        status = max((upstream_status_table.get(a_task_id, '')\n                                      for a_task_id in dep.deps),\n                                     key=UPSTREAM_SEVERITY_KEY)\n                        upstream_status_table[dep_id] = status\n            return upstream_status_table[dep_id]",
        "begin_line": 1276,
        "end_line": 1302,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005078720162519045,
            "pseudo_dstar_susp": 0.0006557377049180328,
            "pseudo_tarantula_susp": 0.0004880429477794046,
            "pseudo_op2_susp": 0.0006557377049180328,
            "pseudo_barinel_susp": 0.0004880429477794046
        }
    },
    {
        "name": "luigi.scheduler.Scheduler._serialize_task#1304",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler._serialize_task(self, task_id, include_deps=True, deps=None)",
        "snippet": "    def _serialize_task(self, task_id, include_deps=True, deps=None):\n        task = self._state.get_task(task_id)\n\n        ret = {\n            'display_name': task.pretty_id,\n            'status': task.status,\n            'workers': list(task.workers),\n            'worker_running': task.worker_running,\n            'time_running': getattr(task, \"time_running\", None),\n            'start_time': task.time,\n            'last_updated': getattr(task, \"updated\", task.time),\n            'params': task.public_params,\n            'name': task.family,\n            'priority': task.priority,\n            'resources': task.resources,\n            'resources_running': getattr(task, \"resources_running\", None),\n            'tracking_url': getattr(task, \"tracking_url\", None),\n            'status_message': getattr(task, \"status_message\", None),\n            'progress_percentage': getattr(task, \"progress_percentage\", None),\n        }\n        if task.status == DISABLED:\n            ret['re_enable_able'] = task.scheduler_disable_time is not None\n        if include_deps:\n            ret['deps'] = list(task.deps if deps is None else deps)\n        if self._config.send_messages and task.status == RUNNING:\n            ret['accepts_messages'] = task.accepts_messages\n        return ret",
        "begin_line": 1304,
        "end_line": 1330,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00018264840182648402,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.graph#1333",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.graph(self, **kwargs)",
        "snippet": "    def graph(self, **kwargs):\n        self.prune()\n        serialized = {}\n        seen = set()\n        for task in self._state.get_active_tasks():\n            serialized.update(self._traverse_graph(task.id, seen))\n        return serialized",
        "begin_line": 1333,
        "end_line": 1339,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler._filter_done#1341",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler._filter_done(self, task_ids)",
        "snippet": "    def _filter_done(self, task_ids):\n        for task_id in task_ids:\n            task = self._state.get_task(task_id)\n            if task is None or task.status != DONE:\n                yield task_id",
        "begin_line": 1341,
        "end_line": 1345,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler._traverse_graph#1347",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler._traverse_graph(self, root_task_id, seen=None, dep_func=None, include_done=True)",
        "snippet": "    def _traverse_graph(self, root_task_id, seen=None, dep_func=None, include_done=True):\n        \"\"\" Returns the dependency graph rooted at task_id\n\n        This does a breadth-first traversal to find the nodes closest to the\n        root before hitting the scheduler.max_graph_nodes limit.\n\n        :param root_task_id: the id of the graph's root\n        :return: A map of task id to serialized node\n        \"\"\"\n\n        if seen is None:\n            seen = set()\n        elif root_task_id in seen:\n            return {}\n\n        if dep_func is None:\n            def dep_func(t):\n                return t.deps\n\n        seen.add(root_task_id)\n        serialized = {}\n        queue = collections.deque([root_task_id])\n        while queue:\n            task_id = queue.popleft()\n\n            task = self._state.get_task(task_id)\n            if task is None or not task.family:\n                logger.debug('Missing task for id [%s]', task_id)\n\n                # NOTE : If a dependency is missing from self._state there is no way to deduce the\n                #        task family and parameters.\n                family_match = TASK_FAMILY_RE.match(task_id)\n                family = family_match.group(1) if family_match else UNKNOWN\n                params = {'task_id': task_id}\n                serialized[task_id] = {\n                    'deps': [],\n                    'status': UNKNOWN,\n                    'workers': [],\n                    'start_time': UNKNOWN,\n                    'params': params,\n                    'name': family,\n                    'display_name': task_id,\n                    'priority': 0,\n                }\n            else:\n                deps = dep_func(task)\n                if not include_done:\n                    deps = list(self._filter_done(deps))\n                serialized[task_id] = self._serialize_task(task_id, deps=deps)\n                for dep in sorted(deps):\n                    if dep not in seen:\n                        seen.add(dep)\n                        queue.append(dep)\n\n            if task_id != root_task_id:\n                del serialized[task_id]['display_name']\n            if len(serialized) >= self._config.max_graph_nodes:\n                break\n\n        return serialized",
        "begin_line": 1347,
        "end_line": 1406,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.dep_func#1363",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.dep_func(t)",
        "snippet": "            def dep_func(t):\n                return t.deps",
        "begin_line": 1363,
        "end_line": 1364,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019508388607101054,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.dep_graph#1409",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.dep_graph(self, task_id, include_done=True, **kwargs)",
        "snippet": "    def dep_graph(self, task_id, include_done=True, **kwargs):\n        self.prune()\n        if not self._state.has_task(task_id):\n            return {}\n        return self._traverse_graph(task_id, include_done=include_done)",
        "begin_line": 1409,
        "end_line": 1413,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.inverse_dep_graph#1416",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.inverse_dep_graph(self, task_id, include_done=True, **kwargs)",
        "snippet": "    def inverse_dep_graph(self, task_id, include_done=True, **kwargs):\n        self.prune()\n        if not self._state.has_task(task_id):\n            return {}\n        inverse_graph = collections.defaultdict(set)\n        for task in self._state.get_active_tasks():\n            for dep in task.deps:\n                inverse_graph[dep].add(task.id)\n        return self._traverse_graph(\n            task_id, dep_func=lambda t: inverse_graph[t.id], include_done=include_done)",
        "begin_line": 1416,
        "end_line": 1425,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.task_list#1428",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.task_list(self, status='', upstream_status='', limit=True, search=None, max_shown_tasks=None, **kwargs)",
        "snippet": "    def task_list(self, status='', upstream_status='', limit=True, search=None, max_shown_tasks=None,\n                  **kwargs):\n        \"\"\"\n        Query for a subset of tasks by status.\n        \"\"\"\n        if not search:\n            count_limit = max_shown_tasks or self._config.max_shown_tasks\n            pre_count = self._state.get_active_task_count_for_status(status)\n            if limit and pre_count > count_limit:\n                return {'num_tasks': -1 if upstream_status else pre_count}\n        self.prune()\n\n        result = {}\n        upstream_status_table = {}  # used to memoize upstream status\n        if search is None:\n            def filter_func(_):\n                return True\n        else:\n            terms = search.split()\n\n            def filter_func(t):\n                return all(term in t.pretty_id for term in terms)\n\n        tasks = self._state.get_active_tasks_by_status(status) if status else self._state.get_active_tasks()\n        for task in filter(filter_func, tasks):\n            if task.status != PENDING or not upstream_status or upstream_status == self._upstream_status(task.id, upstream_status_table):\n                serialized = self._serialize_task(task.id, include_deps=False)\n                result[task.id] = serialized\n        if limit and len(result) > (max_shown_tasks or self._config.max_shown_tasks):\n            return {'num_tasks': len(result)}\n        return result",
        "begin_line": 1428,
        "end_line": 1458,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.filter_func#1443",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.filter_func(_)",
        "snippet": "            def filter_func(_):\n                return True",
        "begin_line": 1443,
        "end_line": 1444,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016289297931259162,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.filter_func#1448",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.filter_func(t)",
        "snippet": "            def filter_func(t):\n                return all(term in t.pretty_id for term in terms)",
        "begin_line": 1448,
        "end_line": 1449,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017053206002728513,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler._first_task_display_name#1460",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler._first_task_display_name(self, worker)",
        "snippet": "    def _first_task_display_name(self, worker):\n        task_id = worker.info.get('first_task', '')\n        if self._state.has_task(task_id):\n            return self._state.get_task(task_id).pretty_id\n        else:\n            return task_id",
        "begin_line": 1460,
        "end_line": 1465,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.worker_list#1468",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.worker_list(self, include_running=True, **kwargs)",
        "snippet": "    def worker_list(self, include_running=True, **kwargs):\n        self.prune()\n        workers = [\n            dict(\n                name=worker.id,\n                last_active=worker.last_active,\n                started=worker.started,\n                state=worker.state,\n                first_task_display_name=self._first_task_display_name(worker),\n                num_unread_rpc_messages=len(worker.rpc_messages),\n                **worker.info\n            ) for worker in self._state.get_active_workers()]\n        workers.sort(key=lambda worker: worker['started'], reverse=True)\n        if include_running:\n            running = collections.defaultdict(dict)\n            for task in self._state.get_active_tasks_by_status(RUNNING):\n                if task.worker_running:\n                    running[task.worker_running][task.id] = self._serialize_task(task.id, include_deps=False)\n\n            num_pending = collections.defaultdict(int)\n            num_uniques = collections.defaultdict(int)\n            for task in self._state.get_active_tasks_by_status(PENDING):\n                for worker in task.workers:\n                    num_pending[worker] += 1\n                if len(task.workers) == 1:\n                    num_uniques[list(task.workers)[0]] += 1\n\n            for worker in workers:\n                tasks = running[worker['name']]\n                worker['num_running'] = len(tasks)\n                worker['num_pending'] = num_pending[worker['name']]\n                worker['num_uniques'] = num_uniques[worker['name']]\n                worker['running'] = tasks\n        return workers",
        "begin_line": 1468,
        "end_line": 1501,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.resource_list#1504",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.resource_list(self)",
        "snippet": "    def resource_list(self):\n        \"\"\"\n        Resources usage info and their consumers (tasks).\n        \"\"\"\n        self.prune()\n        resources = [\n            dict(\n                name=resource,\n                num_total=r_dict['total'],\n                num_used=r_dict['used']\n            ) for resource, r_dict in six.iteritems(self.resources())]\n        if self._resources is not None:\n            consumers = collections.defaultdict(dict)\n            for task in self._state.get_active_tasks_by_status(RUNNING):\n                if task.status == RUNNING and task.resources:\n                    for resource, amount in six.iteritems(task.resources):\n                        consumers[resource][task.id] = self._serialize_task(task.id, include_deps=False)\n            for resource in resources:\n                tasks = consumers[resource['name']]\n                resource['num_consumer'] = len(tasks)\n                resource['running'] = tasks\n        return resources",
        "begin_line": 1504,
        "end_line": 1525,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.resources#1527",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.resources(self)",
        "snippet": "    def resources(self):\n        ''' get total resources and available ones '''\n        used_resources = self._used_resources()\n        ret = collections.defaultdict(dict)\n        for resource, total in six.iteritems(self._resources):\n            ret[resource]['total'] = total\n            if resource in used_resources:\n                ret[resource]['used'] = used_resources[resource]\n            else:\n                ret[resource]['used'] = 0\n        return ret",
        "begin_line": 1527,
        "end_line": 1537,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002054653790836244,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.task_search#1540",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.task_search(self, task_str, **kwargs)",
        "snippet": "    def task_search(self, task_str, **kwargs):\n        \"\"\"\n        Query for a subset of tasks by task_id.\n\n        :param task_str:\n        :return:\n        \"\"\"\n        self.prune()\n        result = collections.defaultdict(dict)\n        for task in self._state.get_active_tasks():\n            if task.id.find(task_str) != -1:\n                serialized = self._serialize_task(task.id, include_deps=False)\n                result[task.status][task.id] = serialized\n        return result",
        "begin_line": 1540,
        "end_line": 1553,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.re_enable_task#1556",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.re_enable_task(self, task_id)",
        "snippet": "    def re_enable_task(self, task_id):\n        serialized = {}\n        task = self._state.get_task(task_id)\n        if task and task.status == DISABLED and task.scheduler_disable_time:\n            self._state.re_enable(task, self._config)\n            serialized = self._serialize_task(task_id)\n        return serialized",
        "begin_line": 1556,
        "end_line": 1562,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00025220680958385876,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.fetch_error#1565",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.fetch_error(self, task_id, **kwargs)",
        "snippet": "    def fetch_error(self, task_id, **kwargs):\n        if self._state.has_task(task_id):\n            task = self._state.get_task(task_id)\n            return {\"taskId\": task_id, \"error\": task.expl, 'displayName': task.pretty_id}\n        else:\n            return {\"taskId\": task_id, \"error\": \"\"}",
        "begin_line": 1565,
        "end_line": 1570,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00022331397945511388,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.set_task_status_message#1573",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.set_task_status_message(self, task_id, status_message)",
        "snippet": "    def set_task_status_message(self, task_id, status_message):\n        if self._state.has_task(task_id):\n            task = self._state.get_task(task_id)\n            task.status_message = status_message\n            if task.status == RUNNING and task.batch_id is not None:\n                for batch_task in self._state.get_batch_running_tasks(task.batch_id):\n                    batch_task.status_message = status_message",
        "begin_line": 1573,
        "end_line": 1579,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.get_task_status_message#1582",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.get_task_status_message(self, task_id)",
        "snippet": "    def get_task_status_message(self, task_id):\n        if self._state.has_task(task_id):\n            task = self._state.get_task(task_id)\n            return {\"taskId\": task_id, \"statusMessage\": task.status_message}\n        else:\n            return {\"taskId\": task_id, \"statusMessage\": \"\"}",
        "begin_line": 1582,
        "end_line": 1587,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.set_task_progress_percentage#1590",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.set_task_progress_percentage(self, task_id, progress_percentage)",
        "snippet": "    def set_task_progress_percentage(self, task_id, progress_percentage):\n        if self._state.has_task(task_id):\n            task = self._state.get_task(task_id)\n            task.progress_percentage = progress_percentage\n            if task.status == RUNNING and task.batch_id is not None:\n                for batch_task in self._state.get_batch_running_tasks(task.batch_id):\n                    batch_task.progress_percentage = progress_percentage",
        "begin_line": 1590,
        "end_line": 1596,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.get_task_progress_percentage#1599",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.get_task_progress_percentage(self, task_id)",
        "snippet": "    def get_task_progress_percentage(self, task_id):\n        if self._state.has_task(task_id):\n            task = self._state.get_task(task_id)\n            return {\"taskId\": task_id, \"progressPercentage\": task.progress_percentage}\n        else:\n            return {\"taskId\": task_id, \"progressPercentage\": None}",
        "begin_line": 1599,
        "end_line": 1604,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.decrease_running_task_resources#1607",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.decrease_running_task_resources(self, task_id, decrease_resources)",
        "snippet": "    def decrease_running_task_resources(self, task_id, decrease_resources):\n        if self._state.has_task(task_id):\n            task = self._state.get_task(task_id)\n            if task.status != RUNNING:\n                return\n\n            def decrease(resources, decrease_resources):\n                for resource, decrease_amount in six.iteritems(decrease_resources):\n                    if decrease_amount > 0 and resource in resources:\n                        resources[resource] = max(0, resources[resource] - decrease_amount)\n\n            decrease(task.resources_running, decrease_resources)\n            if task.batch_id is not None:\n                for batch_task in self._state.get_batch_running_tasks(task.batch_id):\n                    decrease(batch_task.resources_running, decrease_resources)",
        "begin_line": 1607,
        "end_line": 1621,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.decrease#1613",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.decrease(resources, decrease_resources)",
        "snippet": "            def decrease(resources, decrease_resources):\n                for resource, decrease_amount in six.iteritems(decrease_resources):\n                    if decrease_amount > 0 and resource in resources:\n                        resources[resource] = max(0, resources[resource] - decrease_amount)",
        "begin_line": 1613,
        "end_line": 1616,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.get_running_task_resources#1624",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.get_running_task_resources(self, task_id)",
        "snippet": "    def get_running_task_resources(self, task_id):\n        if self._state.has_task(task_id):\n            task = self._state.get_task(task_id)\n            return {\"taskId\": task_id, \"resources\": getattr(task, \"resources_running\", None)}\n        else:\n            return {\"taskId\": task_id, \"resources\": None}",
        "begin_line": 1624,
        "end_line": 1629,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.scheduler.Scheduler._update_task_history#1631",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler._update_task_history(self, task, status, host=None)",
        "snippet": "    def _update_task_history(self, task, status, host=None):\n        try:\n            if status == DONE or status == FAILED:\n                successful = (status == DONE)\n                self._task_history.task_finished(task, successful)\n            elif status == PENDING:\n                self._task_history.task_scheduled(task)\n            elif status == RUNNING:\n                self._task_history.task_started(task, host)\n        except BaseException:\n            logger.warning(\"Error saving Task history\", exc_info=True)",
        "begin_line": 1631,
        "end_line": 1641,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007097232079489,
            "pseudo_dstar_susp": 0.0013280212483399733,
            "pseudo_tarantula_susp": 0.0006269592476489029,
            "pseudo_op2_susp": 0.0013280212483399733,
            "pseudo_barinel_susp": 0.0006269592476489029
        }
    },
    {
        "name": "luigi.scheduler.Scheduler.update_metrics_task_started#1649",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Scheduler",
        "signature": "luigi.scheduler.Scheduler.update_metrics_task_started(self, task)",
        "snippet": "    def update_metrics_task_started(self, task):\n        self._state._metrics_collector.handle_task_started(task)",
        "begin_line": 1649,
        "end_line": 1650,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0006688963210702341,
            "pseudo_tarantula_susp": 0.0005333333333333334,
            "pseudo_op2_susp": 0.0006688963210702341,
            "pseudo_barinel_susp": 0.0005333333333333334
        }
    },
    {
        "name": "luigi.local_target.atomic_file.move_to_final_destination#39",
        "src_path": "luigi/local_target.py",
        "class_name": "luigi.local_target.atomic_file",
        "signature": "luigi.local_target.atomic_file.move_to_final_destination(self)",
        "snippet": "    def move_to_final_destination(self):\n        os.rename(self.tmp_path, self.path)",
        "begin_line": 39,
        "end_line": 40,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016539861065167054,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.local_target.atomic_file.generate_tmp_path#42",
        "src_path": "luigi/local_target.py",
        "class_name": "luigi.local_target.atomic_file",
        "signature": "luigi.local_target.atomic_file.generate_tmp_path(self, path)",
        "snippet": "    def generate_tmp_path(self, path):\n        return path + '-luigi-tmp-%09d' % random.randrange(0, 1e10)",
        "begin_line": 42,
        "end_line": 43,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016409583196586806,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.local_target.LocalFileSystem.copy#53",
        "src_path": "luigi/local_target.py",
        "class_name": "luigi.local_target.LocalFileSystem",
        "signature": "luigi.local_target.LocalFileSystem.copy(self, old_path, new_path, raise_if_exists=False)",
        "snippet": "    def copy(self, old_path, new_path, raise_if_exists=False):\n        if raise_if_exists and os.path.exists(new_path):\n            raise RuntimeError('Destination exists: %s' % new_path)\n        d = os.path.dirname(new_path)\n        if d and not os.path.exists(d):\n            self.mkdir(d)\n        shutil.copy(old_path, new_path)",
        "begin_line": 53,
        "end_line": 59,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.local_target.LocalFileSystem.exists#61",
        "src_path": "luigi/local_target.py",
        "class_name": "luigi.local_target.LocalFileSystem",
        "signature": "luigi.local_target.LocalFileSystem.exists(self, path)",
        "snippet": "    def exists(self, path):\n        return os.path.exists(path)",
        "begin_line": 61,
        "end_line": 62,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005367686527106817,
            "pseudo_dstar_susp": 0.0005053057099545225,
            "pseudo_tarantula_susp": 0.0008787346221441124,
            "pseudo_op2_susp": 0.0005053057099545225,
            "pseudo_barinel_susp": 0.0008787346221441124
        }
    },
    {
        "name": "luigi.local_target.LocalFileSystem.mkdir#64",
        "src_path": "luigi/local_target.py",
        "class_name": "luigi.local_target.LocalFileSystem",
        "signature": "luigi.local_target.LocalFileSystem.mkdir(self, path, parents=True, raise_if_exists=False)",
        "snippet": "    def mkdir(self, path, parents=True, raise_if_exists=False):\n        if self.exists(path):\n            if raise_if_exists:\n                raise FileAlreadyExists()\n            elif not self.isdir(path):\n                raise NotADirectory()\n            else:\n                return\n\n        if parents:\n            try:\n                os.makedirs(path)\n            except OSError as err:\n                # somebody already created the path\n                if err.errno != errno.EEXIST:\n                    raise\n        else:\n            if not os.path.exists(os.path.dirname(path)):\n                raise MissingParentDirectory()\n            os.mkdir(path)",
        "begin_line": 64,
        "end_line": 83,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.local_target.LocalFileSystem.isdir#85",
        "src_path": "luigi/local_target.py",
        "class_name": "luigi.local_target.LocalFileSystem",
        "signature": "luigi.local_target.LocalFileSystem.isdir(self, path)",
        "snippet": "    def isdir(self, path):\n        return os.path.isdir(path)",
        "begin_line": 85,
        "end_line": 86,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019747235387045813,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.local_target.LocalFileSystem.listdir#88",
        "src_path": "luigi/local_target.py",
        "class_name": "luigi.local_target.LocalFileSystem",
        "signature": "luigi.local_target.LocalFileSystem.listdir(self, path)",
        "snippet": "    def listdir(self, path):\n        for dir_, _, files in os.walk(path):\n            assert dir_.startswith(path)\n            for name in files:\n                yield os.path.join(dir_, name)",
        "begin_line": 88,
        "end_line": 92,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.local_target.LocalFileSystem.remove#94",
        "src_path": "luigi/local_target.py",
        "class_name": "luigi.local_target.LocalFileSystem",
        "signature": "luigi.local_target.LocalFileSystem.remove(self, path, recursive=True)",
        "snippet": "    def remove(self, path, recursive=True):\n        if recursive and self.isdir(path):\n            shutil.rmtree(path)\n        else:\n            os.remove(path)",
        "begin_line": 94,
        "end_line": 98,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.local_target.LocalFileSystem.move#100",
        "src_path": "luigi/local_target.py",
        "class_name": "luigi.local_target.LocalFileSystem",
        "signature": "luigi.local_target.LocalFileSystem.move(self, old_path, new_path, raise_if_exists=False)",
        "snippet": "    def move(self, old_path, new_path, raise_if_exists=False):\n        \"\"\"\n        Move file atomically. If source and destination are located\n        on different filesystems, atomicity is approximated\n        but cannot be guaranteed.\n        \"\"\"\n        if raise_if_exists and os.path.exists(new_path):\n            raise FileAlreadyExists('Destination exists: %s' % new_path)\n        d = os.path.dirname(new_path)\n        if d and not os.path.exists(d):\n            self.mkdir(d)\n        try:\n            os.rename(old_path, new_path)\n        except OSError as err:\n            if err.errno == errno.EXDEV:\n                new_path_tmp = '%s-%09d' % (new_path, random.randint(0, 999999999))\n                shutil.copy(old_path, new_path_tmp)\n                os.rename(new_path_tmp, new_path)\n                os.remove(old_path)\n            else:\n                raise err",
        "begin_line": 100,
        "end_line": 120,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.local_target.LocalFileSystem.rename_dont_move#122",
        "src_path": "luigi/local_target.py",
        "class_name": "luigi.local_target.LocalFileSystem",
        "signature": "luigi.local_target.LocalFileSystem.rename_dont_move(self, path, dest)",
        "snippet": "    def rename_dont_move(self, path, dest):\n        \"\"\"\n        Rename ``path`` to ``dest``, but don't move it into the ``dest``\n        folder (if it is a folder). This method is just a wrapper around the\n        ``move`` method of LocalTarget.\n        \"\"\"\n        self.move(path, dest, raise_if_exists=True)",
        "begin_line": 122,
        "end_line": 128,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.local_target.LocalTarget.__init__#134",
        "src_path": "luigi/local_target.py",
        "class_name": "luigi.local_target.LocalTarget",
        "signature": "luigi.local_target.LocalTarget.__init__(self, path=None, format=None, is_tmp=False)",
        "snippet": "    def __init__(self, path=None, format=None, is_tmp=False):\n        if format is None:\n            format = get_default_format()\n\n        if not path:\n            if not is_tmp:\n                raise Exception('path or is_tmp must be set')\n            path = os.path.join(tempfile.gettempdir(), 'luigi-tmp-%09d' % random.randint(0, 999999999))\n        super(LocalTarget, self).__init__(path)\n        self.format = format\n        self.is_tmp = is_tmp",
        "begin_line": 134,
        "end_line": 144,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005277044854881266,
            "pseudo_dstar_susp": 0.0005035246727089627,
            "pseudo_tarantula_susp": 0.000794912559618442,
            "pseudo_op2_susp": 0.0005035246727089627,
            "pseudo_barinel_susp": 0.000794912559618442
        }
    },
    {
        "name": "luigi.local_target.LocalTarget.makedirs#146",
        "src_path": "luigi/local_target.py",
        "class_name": "luigi.local_target.LocalTarget",
        "signature": "luigi.local_target.LocalTarget.makedirs(self)",
        "snippet": "    def makedirs(self):\n        \"\"\"\n        Create all parent folders if they do not exist.\n        \"\"\"\n        normpath = os.path.normpath(self.path)\n        parentfolder = os.path.dirname(normpath)\n        if parentfolder:\n            try:\n                os.makedirs(parentfolder)\n            except OSError:\n                pass",
        "begin_line": 146,
        "end_line": 156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00016515276630883568,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.local_target.LocalTarget.open#158",
        "src_path": "luigi/local_target.py",
        "class_name": "luigi.local_target.LocalTarget",
        "signature": "luigi.local_target.LocalTarget.open(self, mode='r')",
        "snippet": "    def open(self, mode='r'):\n        rwmode = mode.replace('b', '').replace('t', '')\n        if rwmode == 'w':\n            self.makedirs()\n            return self.format.pipe_writer(atomic_file(self.path))\n\n        elif rwmode == 'r':\n            fileobj = FileWrapper(io.BufferedReader(io.FileIO(self.path, mode)))\n            return self.format.pipe_reader(fileobj)\n\n        else:\n            raise Exception(\"mode must be 'r' or 'w' (got: %s)\" % mode)",
        "begin_line": 158,
        "end_line": 169,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.local_target.LocalTarget.move#171",
        "src_path": "luigi/local_target.py",
        "class_name": "luigi.local_target.LocalTarget",
        "signature": "luigi.local_target.LocalTarget.move(self, new_path, raise_if_exists=False)",
        "snippet": "    def move(self, new_path, raise_if_exists=False):\n        self.fs.move(self.path, new_path, raise_if_exists=raise_if_exists)",
        "begin_line": 171,
        "end_line": 172,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002294630564479119,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.local_target.LocalTarget.remove#177",
        "src_path": "luigi/local_target.py",
        "class_name": "luigi.local_target.LocalTarget",
        "signature": "luigi.local_target.LocalTarget.remove(self)",
        "snippet": "    def remove(self):\n        self.fs.remove(self.path)",
        "begin_line": 177,
        "end_line": 178,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00021687269572760788,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.local_target.LocalTarget.copy#180",
        "src_path": "luigi/local_target.py",
        "class_name": "luigi.local_target.LocalTarget",
        "signature": "luigi.local_target.LocalTarget.copy(self, new_path, raise_if_exists=False)",
        "snippet": "    def copy(self, new_path, raise_if_exists=False):\n        self.fs.copy(self.path, new_path, raise_if_exists)",
        "begin_line": 180,
        "end_line": 181,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00027359781121751026,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.local_target.LocalTarget.__del__#188",
        "src_path": "luigi/local_target.py",
        "class_name": "luigi.local_target.LocalTarget",
        "signature": "luigi.local_target.LocalTarget.__del__(self)",
        "snippet": "    def __del__(self):\n        if self.is_tmp and self.exists():\n            self.remove()",
        "begin_line": 188,
        "end_line": 190,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004975124378109452,
            "pseudo_dstar_susp": 0.0004938271604938272,
            "pseudo_tarantula_susp": 0.000630119722747322,
            "pseudo_op2_susp": 0.0004938271604938272,
            "pseudo_barinel_susp": 0.000630119722747322
        }
    },
    {
        "name": "luigi.contrib.hdfs.hadoopcli_clients.create_hadoopcli_client#39",
        "src_path": "luigi/contrib/hdfs/hadoopcli_clients.py",
        "class_name": "luigi.contrib.hdfs.hadoopcli_clients",
        "signature": "luigi.contrib.hdfs.hadoopcli_clients.create_hadoopcli_client()",
        "snippet": "def create_hadoopcli_client():\n    \"\"\"\n    Given that we want one of the hadoop cli clients (unlike snakebite),\n    this one will return the right one.\n    \"\"\"\n    version = hdfs_config.get_configured_hadoop_version()\n    if version == \"cdh4\":\n        return HdfsClient()\n    elif version == \"cdh3\":\n        return HdfsClientCdh3()\n    elif version == \"apache1\":\n        return HdfsClientApache1()\n    else:\n        raise ValueError(\"Error: Unknown version specified in Hadoop version\"\n                         \"configuration parameter\")",
        "begin_line": 39,
        "end_line": 53,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.ssh.RemoteCalledProcessError.__init__#56",
        "src_path": "luigi/contrib/ssh.py",
        "class_name": "luigi.contrib.ssh.RemoteCalledProcessError",
        "signature": "luigi.contrib.ssh.RemoteCalledProcessError.__init__(self, returncode, command, host, output=None)",
        "snippet": "    def __init__(self, returncode, command, host, output=None):\n        super(RemoteCalledProcessError, self).__init__(returncode, command, output)\n        self.host = host",
        "begin_line": 56,
        "end_line": 58,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.ssh.RemoteContext.__init__#67",
        "src_path": "luigi/contrib/ssh.py",
        "class_name": "luigi.contrib.ssh.RemoteContext",
        "signature": "luigi.contrib.ssh.RemoteContext.__init__(self, host, **kwargs)",
        "snippet": "    def __init__(self, host, **kwargs):\n        self.host = host\n        self.username = kwargs.get('username', None)\n        self.key_file = kwargs.get('key_file', None)\n        self.connect_timeout = kwargs.get('connect_timeout', None)\n        self.port = kwargs.get('port', None)\n        self.no_host_key_check = kwargs.get('no_host_key_check', False)\n        self.sshpass = kwargs.get('sshpass', False)\n        self.tty = kwargs.get('tty', False)",
        "begin_line": 67,
        "end_line": 75,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.ssh.RemoteContext._host_ref#87",
        "src_path": "luigi/contrib/ssh.py",
        "class_name": "luigi.contrib.ssh.RemoteContext",
        "signature": "luigi.contrib.ssh.RemoteContext._host_ref(self)",
        "snippet": "    def _host_ref(self):\n        if self.username:\n            return \"{0}@{1}\".format(self.username, self.host)\n        else:\n            return self.host",
        "begin_line": 87,
        "end_line": 91,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.ssh.RemoteContext._prepare_cmd#93",
        "src_path": "luigi/contrib/ssh.py",
        "class_name": "luigi.contrib.ssh.RemoteContext",
        "signature": "luigi.contrib.ssh.RemoteContext._prepare_cmd(self, cmd)",
        "snippet": "    def _prepare_cmd(self, cmd):\n        connection_cmd = [\"ssh\", self._host_ref(), \"-o\", \"ControlMaster=no\"]\n        if self.sshpass:\n            connection_cmd = [\"sshpass\", \"-e\"] + connection_cmd\n        else:\n            connection_cmd += [\"-o\", \"BatchMode=yes\"]  # no password prompts etc\n        if self.port:\n            connection_cmd.extend([\"-p\", self.port])\n\n        if self.connect_timeout is not None:\n            connection_cmd += ['-o', 'ConnectTimeout=%d' % self.connect_timeout]\n\n        if self.no_host_key_check:\n            connection_cmd += ['-o', 'UserKnownHostsFile=/dev/null',\n                               '-o', 'StrictHostKeyChecking=no']\n\n        if self.key_file:\n            connection_cmd.extend([\"-i\", self.key_file])\n\n        if self.tty:\n            connection_cmd.append('-t')\n        return connection_cmd + cmd",
        "begin_line": 93,
        "end_line": 114,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.ssh.RemoteContext.Popen#116",
        "src_path": "luigi/contrib/ssh.py",
        "class_name": "luigi.contrib.ssh.RemoteContext",
        "signature": "luigi.contrib.ssh.RemoteContext.Popen(self, cmd, **kwargs)",
        "snippet": "    def Popen(self, cmd, **kwargs):\n        \"\"\"\n        Remote Popen.\n        \"\"\"\n        prefixed_cmd = self._prepare_cmd(cmd)\n        return subprocess.Popen(prefixed_cmd, **kwargs)",
        "begin_line": 116,
        "end_line": 121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.ssh.RemoteContext.check_output#123",
        "src_path": "luigi/contrib/ssh.py",
        "class_name": "luigi.contrib.ssh.RemoteContext",
        "signature": "luigi.contrib.ssh.RemoteContext.check_output(self, cmd)",
        "snippet": "    def check_output(self, cmd):\n        \"\"\"\n        Execute a shell command remotely and return the output.\n\n        Simplified version of Popen when you only want the output as a string and detect any errors.\n        \"\"\"\n        p = self.Popen(cmd, stdout=subprocess.PIPE)\n        output, _ = p.communicate()\n        if p.returncode != 0:\n            raise RemoteCalledProcessError(p.returncode, cmd, self.host, output=output)\n        return output",
        "begin_line": 123,
        "end_line": 133,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.batch.BatchClient.__init__#90",
        "src_path": "luigi/contrib/batch.py",
        "class_name": "luigi.contrib.batch.BatchClient",
        "signature": "luigi.contrib.batch.BatchClient.__init__(self, poll_time=POLL_TIME)",
        "snippet": "    def __init__(self, poll_time=POLL_TIME):\n        self.poll_time = poll_time\n        self._client = boto3.client('batch')\n        self._log_client = boto3.client('logs')\n        self._queue = self.get_active_queue()",
        "begin_line": 90,
        "end_line": 94,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.047619047619047616,
            "pseudo_dstar_susp": 0.0056179775280898875,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.0056179775280898875,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.contrib.batch.BatchClient.get_active_queue#96",
        "src_path": "luigi/contrib/batch.py",
        "class_name": "luigi.contrib.batch.BatchClient",
        "signature": "luigi.contrib.batch.BatchClient.get_active_queue(self)",
        "snippet": "    def get_active_queue(self):\n        \"\"\"Get name of first active job queue\"\"\"\n\n        # Get dict of active queues keyed by name\n        queues = {q['jobQueueName']: q for q in self._client.describe_job_queues()['jobQueues']\n                  if q['state'] == 'ENABLED' and q['status'] == 'VALID'}\n        if not queues:\n            raise Exception('No job queues with state=ENABLED and status=VALID')\n\n        # Pick the first queue as default\n        return list(queues.keys())[0]",
        "begin_line": 96,
        "end_line": 106,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.047619047619047616,
            "pseudo_dstar_susp": 0.0056179775280898875,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.0056179775280898875,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "luigi.contrib.simulate.RunAnywayTarget.__init__#63",
        "src_path": "luigi/contrib/simulate.py",
        "class_name": "luigi.contrib.simulate.RunAnywayTarget",
        "signature": "luigi.contrib.simulate.RunAnywayTarget.__init__(self, task_obj)",
        "snippet": "    def __init__(self, task_obj):\n        self.task_id = task_obj.task_id\n\n        if self.unique.value == 0:\n            with self.unique.get_lock():\n                if self.unique.value == 0:\n                    self.unique.value = os.getpid()  # The PID will be unique for every execution of the pipeline\n\n        # Deleting old files > temp_time\n        if os.path.isdir(self.temp_dir):\n            import shutil\n            import time\n            limit = time.time() - self.temp_time\n            for fn in os.listdir(self.temp_dir):\n                path = os.path.join(self.temp_dir, fn)\n                if os.path.isdir(path) and os.stat(path).st_mtime < limit:\n                    shutil.rmtree(path)\n                    logger.debug('Deleted temporary directory %s', path)",
        "begin_line": 63,
        "end_line": 80,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.simulate.RunAnywayTarget.get_path#82",
        "src_path": "luigi/contrib/simulate.py",
        "class_name": "luigi.contrib.simulate.RunAnywayTarget",
        "signature": "luigi.contrib.simulate.RunAnywayTarget.get_path(self)",
        "snippet": "    def get_path(self):\n        \"\"\"\n        Returns a temporary file path based on a MD5 hash generated with the task's name and its arguments\n        \"\"\"\n        md5_hash = hashlib.md5(self.task_id.encode()).hexdigest()\n        logger.debug('Hash %s corresponds to task %s', md5_hash, self.task_id)\n\n        return os.path.join(self.temp_dir, str(self.unique.value), md5_hash)",
        "begin_line": 82,
        "end_line": 89,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.simulate.RunAnywayTarget.exists#91",
        "src_path": "luigi/contrib/simulate.py",
        "class_name": "luigi.contrib.simulate.RunAnywayTarget",
        "signature": "luigi.contrib.simulate.RunAnywayTarget.exists(self)",
        "snippet": "    def exists(self):\n        \"\"\"\n        Checks if the file exists\n        \"\"\"\n        return os.path.isfile(self.get_path())",
        "begin_line": 91,
        "end_line": 95,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.simulate.RunAnywayTarget.done#97",
        "src_path": "luigi/contrib/simulate.py",
        "class_name": "luigi.contrib.simulate.RunAnywayTarget",
        "signature": "luigi.contrib.simulate.RunAnywayTarget.done(self)",
        "snippet": "    def done(self):\n        \"\"\"\n        Creates temporary file to mark the task as `done`\n        \"\"\"\n        logger.info('Marking %s as done', self)\n\n        fn = self.get_path()\n        try:\n            os.makedirs(os.path.dirname(fn))\n        except OSError:\n            pass\n        open(fn, 'w').close()",
        "begin_line": 97,
        "end_line": 108,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.interface._WorkerSchedulerFactory.create_local_scheduler#118",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface._WorkerSchedulerFactory",
        "signature": "luigi.interface._WorkerSchedulerFactory.create_local_scheduler(self)",
        "snippet": "    def create_local_scheduler(self):\n        return scheduler.Scheduler(prune_on_get_work=True, record_task_history=False)",
        "begin_line": 118,
        "end_line": 119,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00088261253309797,
            "pseudo_dstar_susp": 0.0008695652173913044,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0008695652173913044,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "luigi.interface._WorkerSchedulerFactory.create_remote_scheduler#121",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface._WorkerSchedulerFactory",
        "signature": "luigi.interface._WorkerSchedulerFactory.create_remote_scheduler(self, url)",
        "snippet": "    def create_remote_scheduler(self, url):\n        return rpc.RemoteScheduler(url)",
        "begin_line": 121,
        "end_line": 122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019747235387045813,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.interface._WorkerSchedulerFactory.create_worker#124",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface._WorkerSchedulerFactory",
        "signature": "luigi.interface._WorkerSchedulerFactory.create_worker(self, scheduler, worker_processes, assistant=False)",
        "snippet": "    def create_worker(self, scheduler, worker_processes, assistant=False):\n        return worker.Worker(\n            scheduler=scheduler, worker_processes=worker_processes, assistant=assistant)",
        "begin_line": 124,
        "end_line": 126,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008143322475570033,
            "pseudo_dstar_susp": 0.0008658008658008658,
            "pseudo_tarantula_susp": 0.0011160714285714285,
            "pseudo_op2_susp": 0.0008658008658008658,
            "pseudo_barinel_susp": 0.0011235955056179776
        }
    },
    {
        "name": "luigi.interface._schedule_and_run#129",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface._schedule_and_run(tasks, worker_scheduler_factory=None, override_defaults=None)",
        "snippet": "def _schedule_and_run(tasks, worker_scheduler_factory=None, override_defaults=None):\n    \"\"\"\n    :param tasks:\n    :param worker_scheduler_factory:\n    :param override_defaults:\n    :return: True if all tasks and their dependencies were successfully run (or already completed);\n             False if any error occurred.\n    \"\"\"\n\n    if worker_scheduler_factory is None:\n        worker_scheduler_factory = _WorkerSchedulerFactory()\n    if override_defaults is None:\n        override_defaults = {}\n    env_params = core(**override_defaults)\n\n    InterfaceLogging.setup(env_params)\n\n    kill_signal = signal.SIGUSR1 if env_params.take_lock else None\n    if (not env_params.no_lock and\n            not(lock.acquire_for(env_params.lock_pid_dir, env_params.lock_size, kill_signal))):\n        raise PidLockAlreadyTakenExit()\n\n    if env_params.local_scheduler:\n        sch = worker_scheduler_factory.create_local_scheduler()\n    else:\n        if env_params.scheduler_url != '':\n            url = env_params.scheduler_url\n        else:\n            url = 'http://{host}:{port:d}/'.format(\n                host=env_params.scheduler_host,\n                port=env_params.scheduler_port,\n            )\n        sch = worker_scheduler_factory.create_remote_scheduler(url=url)\n\n    worker = worker_scheduler_factory.create_worker(\n        scheduler=sch, worker_processes=env_params.workers, assistant=env_params.assistant)\n\n    success = True\n    logger = logging.getLogger('luigi-interface')\n    with worker:\n        for t in tasks:\n            success &= worker.add(t, env_params.parallel_scheduling, env_params.parallel_scheduling_processes)\n        logger.info('Done scheduling tasks')\n        success &= worker.run()\n    logger.info(execution_summary.summary(worker))\n    return dict(success=success, worker=worker)",
        "begin_line": 129,
        "end_line": 174,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008424599831508003,
            "pseudo_dstar_susp": 0.0008680555555555555,
            "pseudo_tarantula_susp": 0.0011547344110854503,
            "pseudo_op2_susp": 0.0008680555555555555,
            "pseudo_barinel_susp": 0.0011547344110854503
        }
    },
    {
        "name": "luigi.interface.run#184",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface.run(*args, **kwargs)",
        "snippet": "def run(*args, **kwargs):\n    \"\"\"\n    Please dont use. Instead use `luigi` binary.\n\n    Run from cmdline using argparse.\n\n    :param use_dynamic_argparse: Deprecated and ignored\n    \"\"\"\n    return _run(*args, **kwargs)['success']",
        "begin_line": 184,
        "end_line": 192,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013054830287206266,
            "pseudo_dstar_susp": 0.0009319664492078285,
            "pseudo_tarantula_susp": 0.0017035775127768314,
            "pseudo_op2_susp": 0.0009319664492078285,
            "pseudo_barinel_susp": 0.0017035775127768314
        }
    },
    {
        "name": "luigi.interface._run#195",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface._run(cmdline_args=None, main_task_cls=None, worker_scheduler_factory=None, use_dynamic_argparse=None, local_scheduler=False)",
        "snippet": "def _run(cmdline_args=None, main_task_cls=None,\n         worker_scheduler_factory=None, use_dynamic_argparse=None, local_scheduler=False):\n    if use_dynamic_argparse is not None:\n        warnings.warn(\"use_dynamic_argparse is deprecated, don't set it.\",\n                      DeprecationWarning, stacklevel=2)\n    if cmdline_args is None:\n        cmdline_args = sys.argv[1:]\n\n    if main_task_cls:\n        cmdline_args.insert(0, main_task_cls.task_family)\n    if local_scheduler:\n        cmdline_args.append('--local-scheduler')\n\n    with CmdlineParser.global_instance(cmdline_args) as cp:\n        return _schedule_and_run([cp.get_task_obj()], worker_scheduler_factory)",
        "begin_line": 195,
        "end_line": 209,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001218026796589525,
            "pseudo_dstar_susp": 0.0009267840593141798,
            "pseudo_tarantula_susp": 0.0015923566878980893,
            "pseudo_op2_susp": 0.0009267840593141798,
            "pseudo_barinel_susp": 0.0015923566878980893
        }
    },
    {
        "name": "luigi.interface.build#212",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface.build(tasks, worker_scheduler_factory=None, **env_params)",
        "snippet": "def build(tasks, worker_scheduler_factory=None, **env_params):\n    \"\"\"\n    Run internally, bypassing the cmdline parsing.\n\n    Useful if you have some luigi code that you want to run internally.\n    Example:\n\n    .. code-block:: python\n\n        luigi.build([MyTask1(), MyTask2()], local_scheduler=True)\n\n    One notable difference is that `build` defaults to not using\n    the identical process lock. Otherwise, `build` would only be\n    callable once from each process.\n\n    :param tasks:\n    :param worker_scheduler_factory:\n    :param env_params:\n    :return: True if there were no scheduling errors, even if tasks may fail.\n    \"\"\"\n    if \"no_lock\" not in env_params:\n        env_params[\"no_lock\"] = True\n\n    return _schedule_and_run(tasks, worker_scheduler_factory, override_defaults=env_params)['success']",
        "begin_line": 212,
        "end_line": 235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000546448087431694,
            "pseudo_dstar_susp": 0.0005096839959225281,
            "pseudo_tarantula_susp": 0.0009487666034155598,
            "pseudo_op2_susp": 0.0005096839959225281,
            "pseudo_barinel_susp": 0.0009487666034155598
        }
    },
    {
        "name": "luigi.contrib.rdbms._MetadataColumnsMixin.metadata_columns#87",
        "src_path": "luigi/contrib/rdbms.py",
        "class_name": "luigi.contrib.rdbms._MetadataColumnsMixin",
        "signature": "luigi.contrib.rdbms._MetadataColumnsMixin.metadata_columns(self)",
        "snippet": "    def metadata_columns(self):\n        \"\"\"Returns the default metadata columns.\n\n        Those columns are columns that we want each tables to have by default.\n        \"\"\"\n        return []",
        "begin_line": 87,
        "end_line": 92,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.rdbms._MetadataColumnsMixin.metadata_queries#95",
        "src_path": "luigi/contrib/rdbms.py",
        "class_name": "luigi.contrib.rdbms._MetadataColumnsMixin",
        "signature": "luigi.contrib.rdbms._MetadataColumnsMixin.metadata_queries(self)",
        "snippet": "    def metadata_queries(self):\n        return []",
        "begin_line": 95,
        "end_line": 96,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002294630564479119,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.rdbms._MetadataColumnsMixin.enable_metadata_columns#99",
        "src_path": "luigi/contrib/rdbms.py",
        "class_name": "luigi.contrib.rdbms._MetadataColumnsMixin",
        "signature": "luigi.contrib.rdbms._MetadataColumnsMixin.enable_metadata_columns(self)",
        "snippet": "    def enable_metadata_columns(self):\n        return False",
        "begin_line": 99,
        "end_line": 100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00019747235387045813,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.rdbms._MetadataColumnsMixin._add_metadata_columns#102",
        "src_path": "luigi/contrib/rdbms.py",
        "class_name": "luigi.contrib.rdbms._MetadataColumnsMixin",
        "signature": "luigi.contrib.rdbms._MetadataColumnsMixin._add_metadata_columns(self, connection)",
        "snippet": "    def _add_metadata_columns(self, connection):\n        cursor = connection.cursor()\n\n        for column in self.metadata_columns:\n            if len(column) == 0:\n                raise ValueError(\"_add_metadata_columns is unable to infer column information from column {column} for {table}\".format(column=column,\n                                                                                                                                       table=self.table))\n\n            column_name = column[0]\n            if not self._column_exists(cursor, column_name):\n                logger.info('Adding missing metadata column {column} to {table}'.format(column=column, table=self.table))\n                self._add_column_to_table(cursor, column)",
        "begin_line": 102,
        "end_line": 113,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002388344877000239,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.rdbms._MetadataColumnsMixin._column_exists#115",
        "src_path": "luigi/contrib/rdbms.py",
        "class_name": "luigi.contrib.rdbms._MetadataColumnsMixin",
        "signature": "luigi.contrib.rdbms._MetadataColumnsMixin._column_exists(self, cursor, column_name)",
        "snippet": "    def _column_exists(self, cursor, column_name):\n        if '.' in self.table:\n            schema, table = self.table.split('.')\n            query = \"SELECT 1 AS column_exists \" \\\n                    \"FROM information_schema.columns \" \\\n                    \"WHERE table_schema = LOWER('{0}') AND table_name = LOWER('{1}') AND column_name = LOWER('{2}') LIMIT 1;\".format(schema, table, column_name)\n        else:\n            query = \"SELECT 1 AS column_exists \" \\\n                    \"FROM information_schema.columns \" \\\n                    \"WHERE table_name = LOWER('{0}') AND column_name = LOWER('{1}') LIMIT 1;\".format(self.table, column_name)\n\n        cursor.execute(query)\n        result = cursor.fetchone()\n        return bool(result)",
        "begin_line": 115,
        "end_line": 128,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.rdbms._MetadataColumnsMixin._add_column_to_table#130",
        "src_path": "luigi/contrib/rdbms.py",
        "class_name": "luigi.contrib.rdbms._MetadataColumnsMixin",
        "signature": "luigi.contrib.rdbms._MetadataColumnsMixin._add_column_to_table(self, cursor, column)",
        "snippet": "    def _add_column_to_table(self, cursor, column):\n        if len(column) == 1:\n            raise ValueError(\"_add_column_to_table() column type not specified for {column}\".format(column=column[0]))\n        elif len(column) == 2:\n            query = \"ALTER TABLE {table} ADD COLUMN {column};\".format(table=self.table, column=' '.join(column))\n        elif len(column) == 3:\n            query = \"ALTER TABLE {table} ADD COLUMN {column} ENCODE {encoding};\".format(table=self.table, column=' '.join(column[0:2]), encoding=column[2])\n        else:\n            raise ValueError(\"_add_column_to_table() found no matching behavior for {column}\".format(column=column))\n\n        cursor.execute(query)",
        "begin_line": 130,
        "end_line": 140,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.rdbms._MetadataColumnsMixin.post_copy_metacolumns#142",
        "src_path": "luigi/contrib/rdbms.py",
        "class_name": "luigi.contrib.rdbms._MetadataColumnsMixin",
        "signature": "luigi.contrib.rdbms._MetadataColumnsMixin.post_copy_metacolumns(self, cursor)",
        "snippet": "    def post_copy_metacolumns(self, cursor):\n        logger.info('Executing post copy metadata queries')\n        for query in self.metadata_queries:\n            cursor.execute(query)",
        "begin_line": 142,
        "end_line": 145,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.rdbms.CopyToTable.update_id#222",
        "src_path": "luigi/contrib/rdbms.py",
        "class_name": "luigi.contrib.rdbms.CopyToTable",
        "signature": "luigi.contrib.rdbms.CopyToTable.update_id(self)",
        "snippet": "    def update_id(self):\n        \"\"\"\n        This update id will be a unique identifier for this insert on this table.\n        \"\"\"\n        return self.task_id",
        "begin_line": 222,
        "end_line": 226,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00017488632388947185,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.rdbms.CopyToTable.init_copy#232",
        "src_path": "luigi/contrib/rdbms.py",
        "class_name": "luigi.contrib.rdbms.CopyToTable",
        "signature": "luigi.contrib.rdbms.CopyToTable.init_copy(self, connection)",
        "snippet": "    def init_copy(self, connection):\n        \"\"\"\n        Override to perform custom queries.\n\n        Any code here will be formed in the same transaction as the main copy, just prior to copying data.\n        Example use cases include truncating the table or removing all data older than X in the database\n        to keep a rolling window of data available in the table.\n        \"\"\"\n\n        # TODO: remove this after sufficient time so most people using the\n        # clear_table attribtue will have noticed it doesn't work anymore\n        if hasattr(self, \"clear_table\"):\n            raise Exception(\"The clear_table attribute has been removed. Override init_copy instead!\")\n\n        if self.enable_metadata_columns:\n            self._add_metadata_columns(connection.cursor())",
        "begin_line": 232,
        "end_line": 247,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.rdbms.CopyToTable.post_copy#249",
        "src_path": "luigi/contrib/rdbms.py",
        "class_name": "luigi.contrib.rdbms.CopyToTable",
        "signature": "luigi.contrib.rdbms.CopyToTable.post_copy(self, connection)",
        "snippet": "    def post_copy(self, connection):\n        \"\"\"\n        Override to perform custom queries.\n\n        Any code here will be formed in the same transaction as the main copy, just after copying data.\n        Example use cases include cleansing data in temp table prior to insertion into real table.\n        \"\"\"\n        pass",
        "begin_line": 249,
        "end_line": 256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.rdbms.Query.update_id#327",
        "src_path": "luigi/contrib/rdbms.py",
        "class_name": "luigi.contrib.rdbms.Query",
        "signature": "luigi.contrib.rdbms.Query.update_id(self)",
        "snippet": "    def update_id(self):\n        \"\"\"\n        Override to create a custom marker table 'update_id' signature for Query subclass task instances\n        \"\"\"\n        return self.task_id",
        "begin_line": 327,
        "end_line": 331,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.00031113876789047915,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.six._import_module#80",
        "src_path": "luigi/six.py",
        "class_name": "luigi.six",
        "signature": "luigi.six._import_module(name)",
        "snippet": "def _import_module(name):\n    \"\"\"Import module, returning the module after the last dot.\"\"\"\n    __import__(name)\n    return sys.modules[name]",
        "begin_line": 80,
        "end_line": 83,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.six._LazyDescr.__get__#91",
        "src_path": "luigi/six.py",
        "class_name": "luigi.six._LazyDescr",
        "signature": "luigi.six._LazyDescr.__get__(self, obj, tp)",
        "snippet": "    def __get__(self, obj, tp):\n        result = self._resolve()\n        setattr(obj, self.name, result)  # Invokes __set__.\n        try:\n            # This is a bit ugly, but it avoids running this again by\n            # removing this descriptor.\n            delattr(obj.__class__, self.name)\n        except AttributeError:\n            pass\n        return result",
        "begin_line": 91,
        "end_line": 100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.six.MovedAttribute._resolve#159",
        "src_path": "luigi/six.py",
        "class_name": "luigi.six.MovedAttribute",
        "signature": "luigi.six.MovedAttribute._resolve(self)",
        "snippet": "    def _resolve(self):\n        module = _import_module(self.mod)\n        return getattr(module, self.attr)",
        "begin_line": 159,
        "end_line": 161,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.six._SixMetaPathImporter.find_module#184",
        "src_path": "luigi/six.py",
        "class_name": "luigi.six._SixMetaPathImporter",
        "signature": "luigi.six._SixMetaPathImporter.find_module(self, fullname, path=None)",
        "snippet": "    def find_module(self, fullname, path=None):\n        if fullname in self.known_modules:\n            return self\n        return None",
        "begin_line": 184,
        "end_line": 187,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0625,
            "pseudo_dstar_susp": 0.012345679012345678,
            "pseudo_tarantula_susp": 0.008771929824561403,
            "pseudo_op2_susp": 0.012345679012345678,
            "pseudo_barinel_susp": 0.008771929824561403
        }
    },
    {
        "name": "luigi.six.itervalues#577",
        "src_path": "luigi/six.py",
        "class_name": "luigi.six",
        "signature": "luigi.six.itervalues(d, **kw)",
        "snippet": "    def itervalues(d, **kw):\n        return iter(d.values(**kw))",
        "begin_line": 577,
        "end_line": 578,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005574136008918618,
            "pseudo_dstar_susp": 0.0011037527593818985,
            "pseudo_tarantula_susp": 0.0004918839153959665,
            "pseudo_op2_susp": 0.0011037527593818985,
            "pseudo_barinel_susp": 0.0004918839153959665
        }
    },
    {
        "name": "luigi.six.iteritems#580",
        "src_path": "luigi/six.py",
        "class_name": "luigi.six",
        "signature": "luigi.six.iteritems(d, **kw)",
        "snippet": "    def iteritems(d, **kw):\n        return iter(d.items(**kw))",
        "begin_line": 580,
        "end_line": 581,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.01282051282051282,
            "pseudo_tarantula_susp": 0.0009606147934678194,
            "pseudo_op2_susp": 0.01282051282051282,
            "pseudo_barinel_susp": 0.0009606147934678194
        }
    },
    {
        "name": "luigi.six.b#619",
        "src_path": "luigi/six.py",
        "class_name": "luigi.six",
        "signature": "luigi.six.b(s)",
        "snippet": "    def b(s):\n        return s.encode(\"latin-1\")",
        "begin_line": 619,
        "end_line": 620,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.six.u#622",
        "src_path": "luigi/six.py",
        "class_name": "luigi.six",
        "signature": "luigi.six.u(s)",
        "snippet": "    def u(s):\n        return s",
        "begin_line": 622,
        "end_line": 623,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0001684352366515075,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.six.assertCountEqual#666",
        "src_path": "luigi/six.py",
        "class_name": "luigi.six",
        "signature": "luigi.six.assertCountEqual(self, *args, **kwargs)",
        "snippet": "def assertCountEqual(self, *args, **kwargs):\n    return getattr(self, _assertCountEqual)(*args, **kwargs)",
        "begin_line": 666,
        "end_line": 667,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0002294630564479119,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    },
    {
        "name": "luigi.contrib.postgres.PostgresQuery.run#367",
        "src_path": "luigi/contrib/postgres.py",
        "class_name": "luigi.contrib.postgres.PostgresQuery",
        "signature": "luigi.contrib.postgres.PostgresQuery.run(self)",
        "snippet": "    def run(self):\n        connection = self.output().connect()\n        connection.autocommit = self.autocommit\n        cursor = connection.cursor()\n        sql = self.query\n\n        logger.info('Executing query from task: {name}'.format(name=self.__class__))\n        cursor.execute(sql)\n\n        # Update marker table\n        self.output().touch(connection)\n\n        # commit and close connection\n        connection.commit()\n        connection.close()",
        "begin_line": 367,
        "end_line": 381,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002376990729736154,
            "pseudo_dstar_susp": 0.0002376990729736154,
            "pseudo_tarantula_susp": 0.0002376990729736154,
            "pseudo_op2_susp": 0.0003944773175542406,
            "pseudo_barinel_susp": 0.0002376990729736154
        }
    }
]