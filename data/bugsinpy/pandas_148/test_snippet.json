[
    {
        "name": "pandas.tests.frame.conftest.float_frame_with_na#9",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.float_frame_with_na()",
        "snippet": "def float_frame_with_na():\n    \"\"\"\n    Fixture for DataFrame of floats with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D']; some entries are missing\n\n                       A         B         C         D\n    ABwBzA0ljw -1.128865 -0.897161  0.046603  0.274997\n    DJiRzmbyQF  0.728869  0.233502  0.722431 -0.890872\n    neMgPD5UBF  0.486072 -1.027393 -0.031553  1.449522\n    0yWA4n8VeX -1.937191 -1.142531  0.805215 -0.462018\n    3slYUbbqU1  0.153260  1.164691  1.489795 -0.545826\n    soujjZ0A08       NaN       NaN       NaN       NaN\n    7W6NLGsjB9       NaN       NaN       NaN       NaN\n    ...              ...       ...       ...       ...\n    uhfeaNkCR1 -0.231210 -0.340472  0.244717 -0.901590\n    n6p7GYuBIV -0.419052  1.922721 -0.125361 -0.727717\n    ZhzAeY6p1y  1.234374 -1.425359 -0.827038 -0.633189\n    uWdPsORyUh  0.046738 -0.980445 -1.102965  0.605503\n    3DJA6aN590 -0.091018 -1.684734 -1.100900  0.215947\n    2GBPAzdbMk -2.883405 -1.021071  1.209877  1.633083\n    sHadBoyVHw -2.223032 -0.326384  0.258931  0.245517\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData())\n    # set some NAs\n    df.loc[5:10] = np.nan\n    df.loc[15:20, -2:] = np.nan\n    return df",
        "begin_line": 9,
        "end_line": 38,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.bool_frame_with_na#42",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.bool_frame_with_na()",
        "snippet": "def bool_frame_with_na():\n    \"\"\"\n    Fixture for DataFrame of booleans with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D']; some entries are missing\n\n                    A      B      C      D\n    zBZxY2IDGd  False  False  False  False\n    IhBWBMWllt  False   True   True   True\n    ctjdvZSR6R   True  False   True   True\n    AVTujptmxb  False   True  False   True\n    G9lrImrSWq  False  False  False   True\n    sFFwdIUfz2    NaN    NaN    NaN    NaN\n    s15ptEJnRb    NaN    NaN    NaN    NaN\n    ...           ...    ...    ...    ...\n    UW41KkDyZ4   True   True  False  False\n    l9l6XkOdqV   True  False  False  False\n    X2MeZfzDYA  False   True  False  False\n    xWkIKU7vfX  False   True  False   True\n    QOhL6VmpGU  False  False  False   True\n    22PwkRJdat  False   True  False  False\n    kfboQ3VeIK   True  False   True  False\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData()) > 0\n    df = df.astype(object)\n    # set some NAs\n    df.loc[5:10] = np.nan\n    df.loc[15:20, -2:] = np.nan\n    return df",
        "begin_line": 42,
        "end_line": 72,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.int_frame#76",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.int_frame()",
        "snippet": "def int_frame():\n    \"\"\"\n    Fixture for DataFrame of ints with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D']\n\n                A  B  C  D\n    vpBeWjM651  1  0  1  0\n    5JyxmrP1En -1  0  0  0\n    qEDaoD49U2 -1  1  0  0\n    m66TkTfsFe  0  0  0  0\n    EHPaNzEUFm -1  0 -1  0\n    fpRJCevQhi  2  0  0  0\n    OlQvnmfi3Q  0  0 -2  0\n    ...        .. .. .. ..\n    uB1FPlz4uP  0  0  0  1\n    EcSe6yNzCU  0  0 -1  0\n    L50VudaiI8 -1  1 -2  0\n    y3bpw4nwIp  0 -1  0  0\n    H0RdLLwrCT  1  1  0  0\n    rY82K0vMwm  0  0  0  0\n    1OPIUjnkjk  2  0  0  0\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame({k: v.astype(int) for k, v in tm.getSeriesData().items()})\n    # force these all to int64 to avoid platform testing issues\n    return DataFrame({c: s for c, s in df.items()}, dtype=np.int64)",
        "begin_line": 76,
        "end_line": 103,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.datetime_frame#107",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.datetime_frame()",
        "snippet": "def datetime_frame():\n    \"\"\"\n    Fixture for DataFrame of floats with DatetimeIndex\n\n    Columns are ['A', 'B', 'C', 'D']\n\n                       A         B         C         D\n    2000-01-03 -1.122153  0.468535  0.122226  1.693711\n    2000-01-04  0.189378  0.486100  0.007864 -1.216052\n    2000-01-05  0.041401 -0.835752 -0.035279 -0.414357\n    2000-01-06  0.430050  0.894352  0.090719  0.036939\n    2000-01-07 -0.620982 -0.668211 -0.706153  1.466335\n    2000-01-10 -0.752633  0.328434 -0.815325  0.699674\n    2000-01-11 -2.236969  0.615737 -0.829076 -1.196106\n    ...              ...       ...       ...       ...\n    2000-02-03  1.642618 -0.579288  0.046005  1.385249\n    2000-02-04 -0.544873 -1.160962 -0.284071 -1.418351\n    2000-02-07 -2.656149 -0.601387  1.410148  0.444150\n    2000-02-08 -1.201881 -1.289040  0.772992 -1.445300\n    2000-02-09  1.377373  0.398619  1.008453 -0.928207\n    2000-02-10  0.473194 -0.636677  0.984058  0.511519\n    2000-02-11 -0.965556  0.408313 -1.312844 -0.381948\n\n    [30 rows x 4 columns]\n    \"\"\"\n    return DataFrame(tm.getTimeSeriesData())",
        "begin_line": 107,
        "end_line": 132,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.float_string_frame#136",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.float_string_frame()",
        "snippet": "def float_string_frame():\n    \"\"\"\n    Fixture for DataFrame of floats and strings with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D', 'foo'].\n\n                       A         B         C         D  foo\n    w3orJvq07g -1.594062 -1.084273 -1.252457  0.356460  bar\n    PeukuVdmz2  0.109855 -0.955086 -0.809485  0.409747  bar\n    ahp2KvwiM8 -1.533729 -0.142519 -0.154666  1.302623  bar\n    3WSJ7BUCGd  2.484964  0.213829  0.034778 -2.327831  bar\n    khdAmufk0U -0.193480 -0.743518 -0.077987  0.153646  bar\n    LE2DZiFlrE -0.193566 -1.343194 -0.107321  0.959978  bar\n    HJXSJhVn7b  0.142590  1.257603 -0.659409 -0.223844  bar\n    ...              ...       ...       ...       ...  ...\n    9a1Vypttgw -1.316394  1.601354  0.173596  1.213196  bar\n    h5d1gVFbEy  0.609475  1.106738 -0.155271  0.294630  bar\n    mK9LsTQG92  1.303613  0.857040 -1.019153  0.369468  bar\n    oOLksd9gKH  0.558219 -0.134491 -0.289869 -0.951033  bar\n    9jgoOjKyHg  0.058270 -0.496110 -0.413212 -0.852659  bar\n    jZLDHclHAO  0.096298  1.267510  0.549206 -0.005235  bar\n    lR0nxDp1C2 -2.119350 -0.794384  0.544118  0.145849  bar\n\n    [30 rows x 5 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData())\n    df[\"foo\"] = \"bar\"\n    return df",
        "begin_line": 136,
        "end_line": 163,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.mixed_float_frame#167",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.mixed_float_frame()",
        "snippet": "def mixed_float_frame():\n    \"\"\"\n    Fixture for DataFrame of different float types with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D'].\n\n                       A         B         C         D\n    GI7bbDaEZe -0.237908 -0.246225 -0.468506  0.752993\n    KGp9mFepzA -1.140809 -0.644046 -1.225586  0.801588\n    VeVYLAb1l2 -1.154013 -1.677615  0.690430 -0.003731\n    kmPME4WKhO  0.979578  0.998274 -0.776367  0.897607\n    CPyopdXTiz  0.048119 -0.257174  0.836426  0.111266\n    0kJZQndAj0  0.274357 -0.281135 -0.344238  0.834541\n    tqdwQsaHG8 -0.979716 -0.519897  0.582031  0.144710\n    ...              ...       ...       ...       ...\n    7FhZTWILQj -2.906357  1.261039 -0.780273 -0.537237\n    4pUDPM4eGq -2.042512 -0.464382 -0.382080  1.132612\n    B8dUgUzwTi -1.506637 -0.364435  1.087891  0.297653\n    hErlVYjVv9  1.477453 -0.495515 -0.713867  1.438427\n    1BKN3o7YLs  0.127535 -0.349812 -0.881836  0.489827\n    9S4Ekn7zga  1.445518 -2.095149  0.031982  0.373204\n    xN1dNn6OV6  1.425017 -0.983995 -0.363281 -0.224502\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData())\n    df.A = df.A.astype(\"float32\")\n    df.B = df.B.astype(\"float32\")\n    df.C = df.C.astype(\"float16\")\n    df.D = df.D.astype(\"float64\")\n    return df",
        "begin_line": 167,
        "end_line": 197,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.mixed_int_frame#201",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.mixed_int_frame()",
        "snippet": "def mixed_int_frame():\n    \"\"\"\n    Fixture for DataFrame of different int types with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D'].\n\n                A  B    C    D\n    mUrCZ67juP  0  1    2    2\n    rw99ACYaKS  0  1    0    0\n    7QsEcpaaVU  0  1    1    1\n    xkrimI2pcE  0  1    0    0\n    dz01SuzoS8  0  1  255  255\n    ccQkqOHX75 -1  1    0    0\n    DN0iXaoDLd  0  1    0    0\n    ...        .. ..  ...  ...\n    Dfb141wAaQ  1  1  254  254\n    IPD8eQOVu5  0  1    0    0\n    CcaKulsCmv  0  1    0    0\n    rIBa8gu7E5  0  1    0    0\n    RP6peZmh5o  0  1    1    1\n    NMb9pipQWQ  0  1    0    0\n    PqgbJEzjib  0  1    3    3\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame({k: v.astype(int) for k, v in tm.getSeriesData().items()})\n    df.A = df.A.astype(\"int32\")\n    df.B = np.ones(len(df.B), dtype=\"uint64\")\n    df.C = df.C.astype(\"uint8\")\n    df.D = df.C.astype(\"int64\")\n    return df",
        "begin_line": 201,
        "end_line": 231,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.mixed_type_frame#235",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.mixed_type_frame()",
        "snippet": "def mixed_type_frame():\n    \"\"\"\n    Fixture for DataFrame of float/int/string columns with RangeIndex\n    Columns are ['a', 'b', 'c', 'float32', 'int32'].\n    \"\"\"\n    return DataFrame(\n        {\n            \"a\": 1.0,\n            \"b\": 2,\n            \"c\": \"foo\",\n            \"float32\": np.array([1.0] * 10, dtype=\"float32\"),\n            \"int32\": np.array([1] * 10, dtype=\"int32\"),\n        },\n        index=np.arange(10),\n    )",
        "begin_line": 235,
        "end_line": 249,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.timezone_frame#253",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.timezone_frame()",
        "snippet": "def timezone_frame():\n    \"\"\"\n    Fixture for DataFrame of date_range Series with different time zones\n\n    Columns are ['A', 'B', 'C']; some entries are missing\n\n               A                         B                         C\n    0 2013-01-01 2013-01-01 00:00:00-05:00 2013-01-01 00:00:00+01:00\n    1 2013-01-02                       NaT                       NaT\n    2 2013-01-03 2013-01-03 00:00:00-05:00 2013-01-03 00:00:00+01:00\n    \"\"\"\n    df = DataFrame(\n        {\n            \"A\": date_range(\"20130101\", periods=3),\n            \"B\": date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n            \"C\": date_range(\"20130101\", periods=3, tz=\"CET\"),\n        }\n    )\n    df.iloc[1, 1] = NaT\n    df.iloc[1, 2] = NaT\n    return df",
        "begin_line": 253,
        "end_line": 273,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.uint64_frame#277",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.uint64_frame()",
        "snippet": "def uint64_frame():\n    \"\"\"\n    Fixture for DataFrame with uint64 values\n\n    Columns are ['A', 'B']\n    \"\"\"\n    return DataFrame(\n        {\"A\": np.arange(3), \"B\": [2 ** 63, 2 ** 63 + 5, 2 ** 63 + 10]}, dtype=np.uint64\n    )",
        "begin_line": 277,
        "end_line": 285,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.simple_frame#289",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.simple_frame()",
        "snippet": "def simple_frame():\n    \"\"\"\n    Fixture for simple 3x3 DataFrame\n\n    Columns are ['one', 'two', 'three'], index is ['a', 'b', 'c'].\n\n       one  two  three\n    a  1.0  2.0    3.0\n    b  4.0  5.0    6.0\n    c  7.0  8.0    9.0\n    \"\"\"\n    arr = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])\n\n    return DataFrame(arr, columns=[\"one\", \"two\", \"three\"], index=[\"a\", \"b\", \"c\"])",
        "begin_line": 289,
        "end_line": 302,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.frame_of_index_cols#306",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.frame_of_index_cols()",
        "snippet": "def frame_of_index_cols():\n    \"\"\"\n    Fixture for DataFrame of columns that can be used for indexing\n\n    Columns are ['A', 'B', 'C', 'D', 'E', ('tuple', 'as', 'label')];\n    'A' & 'B' contain duplicates (but are jointly unique), the rest are unique.\n\n         A      B  C         D         E  (tuple, as, label)\n    0  foo    one  a  0.608477 -0.012500           -1.664297\n    1  foo    two  b -0.633460  0.249614           -0.364411\n    2  foo  three  c  0.615256  2.154968           -0.834666\n    3  bar    one  d  0.234246  1.085675            0.718445\n    4  bar    two  e  0.533841 -0.005702           -3.533912\n    \"\"\"\n    df = DataFrame(\n        {\n            \"A\": [\"foo\", \"foo\", \"foo\", \"bar\", \"bar\"],\n            \"B\": [\"one\", \"two\", \"three\", \"one\", \"two\"],\n            \"C\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n            \"D\": np.random.randn(5),\n            \"E\": np.random.randn(5),\n            (\"tuple\", \"as\", \"label\"): np.random.randn(5),\n        }\n    )\n    return df",
        "begin_line": 306,
        "end_line": 330,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.int_frame_const_col#21",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply",
        "signature": "pandas.tests.frame.test_apply.int_frame_const_col()",
        "snippet": "def int_frame_const_col():\n    \"\"\"\n    Fixture for DataFrame of ints which are constant per column\n\n    Columns are ['A', 'B', 'C'], with values (per column): [1, 2, 3]\n    \"\"\"\n    df = DataFrame(\n        np.tile(np.arange(3, dtype=\"int64\"), 6).reshape(6, -1) + 1,\n        columns=[\"A\", \"B\", \"C\"],\n    )\n    return df",
        "begin_line": 21,
        "end_line": 31,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply#35",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply(self, float_frame)",
        "snippet": "    def test_apply(self, float_frame):\n        with np.errstate(all=\"ignore\"):\n            # ufunc\n            applied = float_frame.apply(np.sqrt)\n            tm.assert_series_equal(np.sqrt(float_frame[\"A\"]), applied[\"A\"])\n\n            # aggregator\n            applied = float_frame.apply(np.mean)\n            assert applied[\"A\"] == np.mean(float_frame[\"A\"])\n\n            d = float_frame.index[0]\n            applied = float_frame.apply(np.mean, axis=1)\n            assert applied[d] == np.mean(float_frame.xs(d))\n            assert applied.index is float_frame.index  # want this\n\n        # invalid axis\n        df = DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]], index=[\"a\", \"a\", \"c\"])\n        with pytest.raises(ValueError):\n            df.apply(lambda x: x, 2)\n\n        # GH 9573\n        df = DataFrame({\"c0\": [\"A\", \"A\", \"B\", \"B\"], \"c1\": [\"C\", \"C\", \"D\", \"D\"]})\n        df = df.apply(lambda ts: ts.astype(\"category\"))\n\n        assert df.shape == (4, 2)\n        assert isinstance(df[\"c0\"].dtype, CategoricalDtype)\n        assert isinstance(df[\"c1\"].dtype, CategoricalDtype)",
        "begin_line": 35,
        "end_line": 61,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_mixed_datetimelike#63",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_mixed_datetimelike(self)",
        "snippet": "    def test_apply_mixed_datetimelike(self):\n        # mixed datetimelike\n        # GH 7778\n        df = DataFrame(\n            {\n                \"A\": date_range(\"20130101\", periods=3),\n                \"B\": pd.to_timedelta(np.arange(3), unit=\"s\"),\n            }\n        )\n        result = df.apply(lambda x: x, axis=1)\n        assert_frame_equal(result, df)",
        "begin_line": 63,
        "end_line": 73,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_empty#75",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_empty(self, float_frame)",
        "snippet": "    def test_apply_empty(self, float_frame):\n        # empty\n        empty_frame = DataFrame()\n\n        applied = empty_frame.apply(np.sqrt)\n        assert applied.empty\n\n        applied = empty_frame.apply(np.mean)\n        assert applied.empty\n\n        no_rows = float_frame[:0]\n        result = no_rows.apply(lambda x: x.mean())\n        expected = Series(np.nan, index=float_frame.columns)\n        assert_series_equal(result, expected)\n\n        no_cols = float_frame.loc[:, []]\n        result = no_cols.apply(lambda x: x.mean(), axis=1)\n        expected = Series(np.nan, index=float_frame.index)\n        assert_series_equal(result, expected)\n\n        # GH 2476\n        expected = DataFrame(index=[\"a\"])\n        result = expected.apply(lambda x: x[\"a\"], axis=1)\n        assert_frame_equal(expected, result)",
        "begin_line": 75,
        "end_line": 98,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_with_reduce_empty#100",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_with_reduce_empty(self)",
        "snippet": "    def test_apply_with_reduce_empty(self):\n        # reduce with an empty DataFrame\n        empty_frame = DataFrame()\n\n        x = []\n        result = empty_frame.apply(x.append, axis=1, result_type=\"expand\")\n        assert_frame_equal(result, empty_frame)\n        result = empty_frame.apply(x.append, axis=1, result_type=\"reduce\")\n        assert_series_equal(result, Series([], index=pd.Index([], dtype=object)))\n\n        empty_with_cols = DataFrame(columns=[\"a\", \"b\", \"c\"])\n        result = empty_with_cols.apply(x.append, axis=1, result_type=\"expand\")\n        assert_frame_equal(result, empty_with_cols)\n        result = empty_with_cols.apply(x.append, axis=1, result_type=\"reduce\")\n        assert_series_equal(result, Series([], index=pd.Index([], dtype=object)))\n\n        # Ensure that x.append hasn't been called\n        assert x == []",
        "begin_line": 100,
        "end_line": 117,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_funcs_over_empty#120",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_funcs_over_empty(self, func)",
        "snippet": "    def test_apply_funcs_over_empty(self, func):\n        # GH 28213\n        df = DataFrame(columns=[\"a\", \"b\", \"c\"])\n\n        result = df.apply(getattr(np, func))\n        expected = getattr(df, func)()\n        assert_series_equal(result, expected)",
        "begin_line": 120,
        "end_line": 126,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_nunique_empty#128",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_nunique_empty(self)",
        "snippet": "    def test_nunique_empty(self):\n        # GH 28213\n        df = DataFrame(columns=[\"a\", \"b\", \"c\"])\n\n        result = df.nunique()\n        expected = Series(0, index=df.columns)\n        assert_series_equal(result, expected)\n\n        result = df.T.nunique()\n        expected = Series([], index=pd.Index([]))\n        assert_series_equal(result, expected)",
        "begin_line": 128,
        "end_line": 138,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_deprecate_reduce#140",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_deprecate_reduce(self)",
        "snippet": "    def test_apply_deprecate_reduce(self):\n        empty_frame = DataFrame()\n\n        x = []\n        with tm.assert_produces_warning(FutureWarning):\n            empty_frame.apply(x.append, axis=1, reduce=True)",
        "begin_line": 140,
        "end_line": 145,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_standard_nonunique#147",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_standard_nonunique(self)",
        "snippet": "    def test_apply_standard_nonunique(self):\n        df = DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]], index=[\"a\", \"a\", \"c\"])\n\n        result = df.apply(lambda s: s[0], axis=1)\n        expected = Series([1, 4, 7], [\"a\", \"a\", \"c\"])\n        assert_series_equal(result, expected)\n\n        result = df.T.apply(lambda s: s[0], axis=0)\n        assert_series_equal(result, expected)",
        "begin_line": 147,
        "end_line": 155,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_with_string_funcs#168",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_with_string_funcs(self, float_frame, func, args, kwds)",
        "snippet": "    def test_apply_with_string_funcs(self, float_frame, func, args, kwds):\n        result = float_frame.apply(func, *args, **kwds)\n        expected = getattr(float_frame, func)(*args, **kwds)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 168,
        "end_line": 171,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_broadcast_deprecated#173",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_broadcast_deprecated(self, float_frame)",
        "snippet": "    def test_apply_broadcast_deprecated(self, float_frame):\n        with tm.assert_produces_warning(FutureWarning):\n            float_frame.apply(np.mean, broadcast=True)",
        "begin_line": 173,
        "end_line": 175,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_broadcast#177",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_broadcast(self, float_frame, int_frame_const_col)",
        "snippet": "    def test_apply_broadcast(self, float_frame, int_frame_const_col):\n\n        # scalars\n        result = float_frame.apply(np.mean, result_type=\"broadcast\")\n        expected = DataFrame([float_frame.mean()], index=float_frame.index)\n        tm.assert_frame_equal(result, expected)\n\n        result = float_frame.apply(np.mean, axis=1, result_type=\"broadcast\")\n        m = float_frame.mean(axis=1)\n        expected = DataFrame({c: m for c in float_frame.columns})\n        tm.assert_frame_equal(result, expected)\n\n        # lists\n        result = float_frame.apply(\n            lambda x: list(range(len(float_frame.columns))),\n            axis=1,\n            result_type=\"broadcast\",\n        )\n        m = list(range(len(float_frame.columns)))\n        expected = DataFrame(\n            [m] * len(float_frame.index),\n            dtype=\"float64\",\n            index=float_frame.index,\n            columns=float_frame.columns,\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = float_frame.apply(\n            lambda x: list(range(len(float_frame.index))), result_type=\"broadcast\"\n        )\n        m = list(range(len(float_frame.index)))\n        expected = DataFrame(\n            {c: m for c in float_frame.columns},\n            dtype=\"float64\",\n            index=float_frame.index,\n        )\n        tm.assert_frame_equal(result, expected)\n\n        # preserve columns\n        df = int_frame_const_col\n        result = df.apply(lambda x: [1, 2, 3], axis=1, result_type=\"broadcast\")\n        tm.assert_frame_equal(result, df)\n\n        df = int_frame_const_col\n        result = df.apply(\n            lambda x: Series([1, 2, 3], index=list(\"abc\")),\n            axis=1,\n            result_type=\"broadcast\",\n        )\n        expected = df.copy()\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 177,
        "end_line": 227,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_broadcast_error#229",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_broadcast_error(self, int_frame_const_col)",
        "snippet": "    def test_apply_broadcast_error(self, int_frame_const_col):\n        df = int_frame_const_col\n\n        # > 1 ndim\n        with pytest.raises(ValueError):\n            df.apply(\n                lambda x: np.array([1, 2]).reshape(-1, 2),\n                axis=1,\n                result_type=\"broadcast\",\n            )\n\n        # cannot broadcast\n        with pytest.raises(ValueError):\n            df.apply(lambda x: [1, 2], axis=1, result_type=\"broadcast\")\n\n        with pytest.raises(ValueError):\n            df.apply(lambda x: Series([1, 2]), axis=1, result_type=\"broadcast\")",
        "begin_line": 229,
        "end_line": 245,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_raw#247",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_raw(self, float_frame)",
        "snippet": "    def test_apply_raw(self, float_frame):\n        result0 = float_frame.apply(np.mean, raw=True)\n        result1 = float_frame.apply(np.mean, axis=1, raw=True)\n\n        expected0 = float_frame.apply(lambda x: x.values.mean())\n        expected1 = float_frame.apply(lambda x: x.values.mean(), axis=1)\n\n        assert_series_equal(result0, expected0)\n        assert_series_equal(result1, expected1)\n\n        # no reduction\n        result = float_frame.apply(lambda x: x * 2, raw=True)\n        expected = float_frame * 2\n        assert_frame_equal(result, expected)",
        "begin_line": 247,
        "end_line": 260,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_axis1#262",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_axis1(self, float_frame)",
        "snippet": "    def test_apply_axis1(self, float_frame):\n        d = float_frame.index[0]\n        tapplied = float_frame.apply(np.mean, axis=1)\n        assert tapplied[d] == np.mean(float_frame.xs(d))",
        "begin_line": 262,
        "end_line": 265,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_ignore_failures#267",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_ignore_failures(self, float_string_frame)",
        "snippet": "    def test_apply_ignore_failures(self, float_string_frame):\n        result = frame_apply(\n            float_string_frame, np.mean, 0, ignore_failures=True\n        ).apply_standard()\n        expected = float_string_frame._get_numeric_data().apply(np.mean)\n        assert_series_equal(result, expected)",
        "begin_line": 267,
        "end_line": 272,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_mixed_dtype_corner#274",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_mixed_dtype_corner(self)",
        "snippet": "    def test_apply_mixed_dtype_corner(self):\n        df = DataFrame({\"A\": [\"foo\"], \"B\": [1.0]})\n        result = df[:0].apply(np.mean, axis=1)\n        # the result here is actually kind of ambiguous, should it be a Series\n        # or a DataFrame?\n        expected = Series(np.nan, index=pd.Index([], dtype=\"int64\"))\n        assert_series_equal(result, expected)\n\n        df = DataFrame({\"A\": [\"foo\"], \"B\": [1.0]})\n        result = df.apply(lambda x: x[\"A\"], axis=1)\n        expected = Series([\"foo\"], index=[0])\n        assert_series_equal(result, expected)\n\n        result = df.apply(lambda x: x[\"B\"], axis=1)\n        expected = Series([1.0], index=[0])\n        assert_series_equal(result, expected)",
        "begin_line": 274,
        "end_line": 289,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_empty_infer_type#291",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_empty_infer_type(self)",
        "snippet": "    def test_apply_empty_infer_type(self):\n        no_cols = DataFrame(index=[\"a\", \"b\", \"c\"])\n        no_index = DataFrame(columns=[\"a\", \"b\", \"c\"])\n\n        def _check(df, f):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"ignore\", RuntimeWarning)\n                test_res = f(np.array([], dtype=\"f8\"))\n            is_reduction = not isinstance(test_res, np.ndarray)\n\n            def _checkit(axis=0, raw=False):\n                result = df.apply(f, axis=axis, raw=raw)\n                if is_reduction:\n                    agg_axis = df._get_agg_axis(axis)\n                    assert isinstance(result, Series)\n                    assert result.index is agg_axis\n                else:\n                    assert isinstance(result, DataFrame)\n\n            _checkit()\n            _checkit(axis=1)\n            _checkit(raw=True)\n            _checkit(axis=0, raw=True)\n\n        with np.errstate(all=\"ignore\"):\n            _check(no_cols, lambda x: x)\n            _check(no_cols, lambda x: x.mean())\n            _check(no_index, lambda x: x)\n            _check(no_index, lambda x: x.mean())\n\n        result = no_cols.apply(lambda x: x.mean(), result_type=\"broadcast\")\n        assert isinstance(result, DataFrame)",
        "begin_line": 291,
        "end_line": 322,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply._check#295",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply._check(df, f)",
        "snippet": "        def _check(df, f):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"ignore\", RuntimeWarning)\n                test_res = f(np.array([], dtype=\"f8\"))\n            is_reduction = not isinstance(test_res, np.ndarray)\n\n            def _checkit(axis=0, raw=False):\n                result = df.apply(f, axis=axis, raw=raw)\n                if is_reduction:\n                    agg_axis = df._get_agg_axis(axis)\n                    assert isinstance(result, Series)\n                    assert result.index is agg_axis\n                else:\n                    assert isinstance(result, DataFrame)\n\n            _checkit()\n            _checkit(axis=1)\n            _checkit(raw=True)\n            _checkit(axis=0, raw=True)",
        "begin_line": 295,
        "end_line": 313,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply._checkit#301",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply._checkit(axis=0, raw=False)",
        "snippet": "            def _checkit(axis=0, raw=False):\n                result = df.apply(f, axis=axis, raw=raw)\n                if is_reduction:\n                    agg_axis = df._get_agg_axis(axis)\n                    assert isinstance(result, Series)\n                    assert result.index is agg_axis\n                else:\n                    assert isinstance(result, DataFrame)",
        "begin_line": 301,
        "end_line": 308,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_with_args_kwds#324",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_with_args_kwds(self, float_frame)",
        "snippet": "    def test_apply_with_args_kwds(self, float_frame):\n        def add_some(x, howmuch=0):\n            return x + howmuch\n\n        def agg_and_add(x, howmuch=0):\n            return x.mean() + howmuch\n\n        def subtract_and_divide(x, sub, divide=1):\n            return (x - sub) / divide\n\n        result = float_frame.apply(add_some, howmuch=2)\n        expected = float_frame.apply(lambda x: x + 2)\n        assert_frame_equal(result, expected)\n\n        result = float_frame.apply(agg_and_add, howmuch=2)\n        expected = float_frame.apply(lambda x: x.mean() + 2)\n        assert_series_equal(result, expected)\n\n        result = float_frame.apply(subtract_and_divide, args=(2,), divide=2)\n        expected = float_frame.apply(lambda x: (x - 2.0) / 2.0)\n        assert_frame_equal(result, expected)",
        "begin_line": 324,
        "end_line": 344,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.add_some#325",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.add_some(x, howmuch=0)",
        "snippet": "        def add_some(x, howmuch=0):\n            return x + howmuch",
        "begin_line": 325,
        "end_line": 326,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.agg_and_add#328",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.agg_and_add(x, howmuch=0)",
        "snippet": "        def agg_and_add(x, howmuch=0):\n            return x.mean() + howmuch",
        "begin_line": 328,
        "end_line": 329,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.subtract_and_divide#331",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.subtract_and_divide(x, sub, divide=1)",
        "snippet": "        def subtract_and_divide(x, sub, divide=1):\n            return (x - sub) / divide",
        "begin_line": 331,
        "end_line": 332,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_yield_list#346",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_yield_list(self, float_frame)",
        "snippet": "    def test_apply_yield_list(self, float_frame):\n        result = float_frame.apply(list)\n        assert_frame_equal(result, float_frame)",
        "begin_line": 346,
        "end_line": 348,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_reduce_Series#350",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_reduce_Series(self, float_frame)",
        "snippet": "    def test_apply_reduce_Series(self, float_frame):\n        float_frame.loc[::2, \"A\"] = np.nan\n        expected = float_frame.mean(1)\n        result = float_frame.apply(np.mean, axis=1)\n        assert_series_equal(result, expected)",
        "begin_line": 350,
        "end_line": 354,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_reduce_rows_to_dict#356",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_reduce_rows_to_dict(self)",
        "snippet": "    def test_apply_reduce_rows_to_dict(self):\n        # GH 25196\n        data = pd.DataFrame([[1, 2], [3, 4]])\n        expected = pd.Series([{0: 1, 1: 3}, {0: 2, 1: 4}])\n        result = data.apply(dict)\n        assert_series_equal(result, expected)",
        "begin_line": 356,
        "end_line": 361,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_differently_indexed#363",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_differently_indexed(self)",
        "snippet": "    def test_apply_differently_indexed(self):\n        df = DataFrame(np.random.randn(20, 10))\n\n        result0 = df.apply(Series.describe, axis=0)\n        expected0 = DataFrame(\n            {i: v.describe() for i, v in df.items()}, columns=df.columns\n        )\n        assert_frame_equal(result0, expected0)\n\n        result1 = df.apply(Series.describe, axis=1)\n        expected1 = DataFrame(\n            {i: v.describe() for i, v in df.T.items()}, columns=df.index\n        ).T\n        assert_frame_equal(result1, expected1)",
        "begin_line": 363,
        "end_line": 376,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_modify_traceback#378",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_modify_traceback(self)",
        "snippet": "    def test_apply_modify_traceback(self):\n        data = DataFrame(\n            {\n                \"A\": [\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                ],\n                \"B\": [\n                    \"one\",\n                    \"one\",\n                    \"one\",\n                    \"two\",\n                    \"one\",\n                    \"one\",\n                    \"one\",\n                    \"two\",\n                    \"two\",\n                    \"two\",\n                    \"one\",\n                ],\n                \"C\": [\n                    \"dull\",\n                    \"dull\",\n                    \"shiny\",\n                    \"dull\",\n                    \"dull\",\n                    \"shiny\",\n                    \"shiny\",\n                    \"dull\",\n                    \"shiny\",\n                    \"shiny\",\n                    \"shiny\",\n                ],\n                \"D\": np.random.randn(11),\n                \"E\": np.random.randn(11),\n                \"F\": np.random.randn(11),\n            }\n        )\n\n        data.loc[4, \"C\"] = np.nan\n\n        def transform(row):\n            if row[\"C\"].startswith(\"shin\") and row[\"A\"] == \"foo\":\n                row[\"D\"] = 7\n            return row\n\n        def transform2(row):\n            if notna(row[\"C\"]) and row[\"C\"].startswith(\"shin\") and row[\"A\"] == \"foo\":\n                row[\"D\"] = 7\n            return row\n\n        try:\n            data.apply(transform, axis=1)\n        except AttributeError as e:\n            assert len(e.args) == 2\n            assert e.args[1] == \"occurred at index 4\"\n            assert e.args[0] == \"'float' object has no attribute 'startswith'\"",
        "begin_line": 378,
        "end_line": 443,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.transform#428",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.transform(row)",
        "snippet": "        def transform(row):\n            if row[\"C\"].startswith(\"shin\") and row[\"A\"] == \"foo\":\n                row[\"D\"] = 7\n            return row",
        "begin_line": 428,
        "end_line": 431,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.transform2#433",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.transform2(row)",
        "snippet": "        def transform2(row):\n            if notna(row[\"C\"]) and row[\"C\"].startswith(\"shin\") and row[\"A\"] == \"foo\":\n                row[\"D\"] = 7\n            return row",
        "begin_line": 433,
        "end_line": 436,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_bug#445",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_bug(self)",
        "snippet": "    def test_apply_bug(self):\n\n        # GH 6125\n        positions = pd.DataFrame(\n            [\n                [1, \"ABC0\", 50],\n                [1, \"YUM0\", 20],\n                [1, \"DEF0\", 20],\n                [2, \"ABC1\", 50],\n                [2, \"YUM1\", 20],\n                [2, \"DEF1\", 20],\n            ],\n            columns=[\"a\", \"market\", \"position\"],\n        )\n\n        def f(r):\n            return r[\"market\"]\n\n        expected = positions.apply(f, axis=1)\n\n        positions = DataFrame(\n            [\n                [datetime(2013, 1, 1), \"ABC0\", 50],\n                [datetime(2013, 1, 2), \"YUM0\", 20],\n                [datetime(2013, 1, 3), \"DEF0\", 20],\n                [datetime(2013, 1, 4), \"ABC1\", 50],\n                [datetime(2013, 1, 5), \"YUM1\", 20],\n                [datetime(2013, 1, 6), \"DEF1\", 20],\n            ],\n            columns=[\"a\", \"market\", \"position\"],\n        )\n        result = positions.apply(f, axis=1)\n        assert_series_equal(result, expected)",
        "begin_line": 445,
        "end_line": 477,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.f#460",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.f(r)",
        "snippet": "        def f(r):\n            return r[\"market\"]",
        "begin_line": 460,
        "end_line": 461,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_convert_objects#479",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_convert_objects(self)",
        "snippet": "    def test_apply_convert_objects(self):\n        data = DataFrame(\n            {\n                \"A\": [\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"bar\",\n                    \"foo\",\n                    \"foo\",\n                    \"foo\",\n                ],\n                \"B\": [\n                    \"one\",\n                    \"one\",\n                    \"one\",\n                    \"two\",\n                    \"one\",\n                    \"one\",\n                    \"one\",\n                    \"two\",\n                    \"two\",\n                    \"two\",\n                    \"one\",\n                ],\n                \"C\": [\n                    \"dull\",\n                    \"dull\",\n                    \"shiny\",\n                    \"dull\",\n                    \"dull\",\n                    \"shiny\",\n                    \"shiny\",\n                    \"dull\",\n                    \"shiny\",\n                    \"shiny\",\n                    \"shiny\",\n                ],\n                \"D\": np.random.randn(11),\n                \"E\": np.random.randn(11),\n                \"F\": np.random.randn(11),\n            }\n        )\n\n        result = data.apply(lambda x: x, axis=1)\n        assert_frame_equal(result._convert(datetime=True), data)",
        "begin_line": 479,
        "end_line": 528,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_attach_name#530",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_attach_name(self, float_frame)",
        "snippet": "    def test_apply_attach_name(self, float_frame):\n        result = float_frame.apply(lambda x: x.name)\n        expected = Series(float_frame.columns, index=float_frame.columns)\n        assert_series_equal(result, expected)\n\n        result = float_frame.apply(lambda x: x.name, axis=1)\n        expected = Series(float_frame.index, index=float_frame.index)\n        assert_series_equal(result, expected)\n\n        # non-reductions\n        result = float_frame.apply(lambda x: np.repeat(x.name, len(x)))\n        expected = DataFrame(\n            np.tile(float_frame.columns, (len(float_frame.index), 1)),\n            index=float_frame.index,\n            columns=float_frame.columns,\n        )\n        assert_frame_equal(result, expected)\n\n        result = float_frame.apply(lambda x: np.repeat(x.name, len(x)), axis=1)\n        expected = Series(\n            np.repeat(t[0], len(float_frame.columns)) for t in float_frame.itertuples()\n        )\n        expected.index = float_frame.index\n        assert_series_equal(result, expected)",
        "begin_line": 530,
        "end_line": 553,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_multi_index#555",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_multi_index(self, float_frame)",
        "snippet": "    def test_apply_multi_index(self, float_frame):\n        index = MultiIndex.from_arrays([[\"a\", \"a\", \"b\"], [\"c\", \"d\", \"d\"]])\n        s = DataFrame([[1, 2], [3, 4], [5, 6]], index=index, columns=[\"col1\", \"col2\"])\n        result = s.apply(lambda x: Series({\"min\": min(x), \"max\": max(x)}), 1)\n        expected = DataFrame(\n            [[1, 2], [3, 4], [5, 6]], index=index, columns=[\"min\", \"max\"]\n        )\n        assert_frame_equal(result, expected, check_like=True)",
        "begin_line": 555,
        "end_line": 562,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_dict#564",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_dict(self)",
        "snippet": "    def test_apply_dict(self):\n\n        # GH 8735\n        A = DataFrame([[\"foo\", \"bar\"], [\"spam\", \"eggs\"]])\n        A_dicts = Series(\n            [dict([(0, \"foo\"), (1, \"spam\")]), dict([(0, \"bar\"), (1, \"eggs\")])]\n        )\n        B = DataFrame([[0, 1], [2, 3]])\n        B_dicts = Series([dict([(0, 0), (1, 2)]), dict([(0, 1), (1, 3)])])\n        fn = lambda x: x.to_dict()\n\n        for df, dicts in [(A, A_dicts), (B, B_dicts)]:\n            reduce_true = df.apply(fn, result_type=\"reduce\")\n            reduce_false = df.apply(fn, result_type=\"expand\")\n            reduce_none = df.apply(fn)\n\n            assert_series_equal(reduce_true, dicts)\n            assert_frame_equal(reduce_false, df)\n            assert_series_equal(reduce_none, dicts)",
        "begin_line": 564,
        "end_line": 582,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_applymap#584",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_applymap(self, float_frame)",
        "snippet": "    def test_applymap(self, float_frame):\n        applied = float_frame.applymap(lambda x: x * 2)\n        tm.assert_frame_equal(applied, float_frame * 2)\n        float_frame.applymap(type)\n\n        # GH 465: function returning tuples\n        result = float_frame.applymap(lambda x: (x, x))\n        assert isinstance(result[\"A\"][0], tuple)\n\n        # GH 2909: object conversion to float in constructor?\n        df = DataFrame(data=[1, \"a\"])\n        result = df.applymap(lambda x: x)\n        assert result.dtypes[0] == object\n\n        df = DataFrame(data=[1.0, \"a\"])\n        result = df.applymap(lambda x: x)\n        assert result.dtypes[0] == object\n\n        # GH 2786\n        df = DataFrame(np.random.random((3, 4)))\n        df2 = df.copy()\n        cols = [\"a\", \"a\", \"a\", \"a\"]\n        df.columns = cols\n\n        expected = df2.applymap(str)\n        expected.columns = cols\n        result = df.applymap(str)\n        tm.assert_frame_equal(result, expected)\n\n        # datetime/timedelta\n        df[\"datetime\"] = Timestamp(\"20130101\")\n        df[\"timedelta\"] = pd.Timedelta(\"1 min\")\n        result = df.applymap(str)\n        for f in [\"datetime\", \"timedelta\"]:\n            assert result.loc[0, f] == str(df.loc[0, f])\n\n        # GH 8222\n        empty_frames = [\n            pd.DataFrame(),\n            pd.DataFrame(columns=list(\"ABC\")),\n            pd.DataFrame(index=list(\"ABC\")),\n            pd.DataFrame({\"A\": [], \"B\": [], \"C\": []}),\n        ]\n        for frame in empty_frames:\n            for func in [round, lambda x: x]:\n                result = frame.applymap(func)\n                tm.assert_frame_equal(result, frame)",
        "begin_line": 584,
        "end_line": 630,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_applymap_box_timestamps#632",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_applymap_box_timestamps(self)",
        "snippet": "    def test_applymap_box_timestamps(self):\n        # GH 2689, GH 2627\n        ser = pd.Series(date_range(\"1/1/2000\", periods=10))\n\n        def func(x):\n            return (x.hour, x.day, x.month)\n\n        # it works!\n        pd.DataFrame(ser).applymap(func)",
        "begin_line": 632,
        "end_line": 640,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.func#636",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.func(x)",
        "snippet": "        def func(x):\n            return (x.hour, x.day, x.month)",
        "begin_line": 636,
        "end_line": 637,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_applymap_box#642",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_applymap_box(self)",
        "snippet": "    def test_applymap_box(self):\n        # ufunc will not be boxed. Same test cases as the test_map_box\n        df = pd.DataFrame(\n            {\n                \"a\": [pd.Timestamp(\"2011-01-01\"), pd.Timestamp(\"2011-01-02\")],\n                \"b\": [\n                    pd.Timestamp(\"2011-01-01\", tz=\"US/Eastern\"),\n                    pd.Timestamp(\"2011-01-02\", tz=\"US/Eastern\"),\n                ],\n                \"c\": [pd.Timedelta(\"1 days\"), pd.Timedelta(\"2 days\")],\n                \"d\": [\n                    pd.Period(\"2011-01-01\", freq=\"M\"),\n                    pd.Period(\"2011-01-02\", freq=\"M\"),\n                ],\n            }\n        )\n\n        result = df.applymap(lambda x: \"{0}\".format(x.__class__.__name__))\n        expected = pd.DataFrame(\n            {\n                \"a\": [\"Timestamp\", \"Timestamp\"],\n                \"b\": [\"Timestamp\", \"Timestamp\"],\n                \"c\": [\"Timedelta\", \"Timedelta\"],\n                \"d\": [\"Period\", \"Period\"],\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 642,
        "end_line": 668,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_frame_apply_dont_convert_datetime64#670",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_frame_apply_dont_convert_datetime64(self)",
        "snippet": "    def test_frame_apply_dont_convert_datetime64(self):\n        from pandas.tseries.offsets import BDay\n\n        df = DataFrame({\"x1\": [datetime(1996, 1, 1)]})\n\n        df = df.applymap(lambda x: x + BDay())\n        df = df.applymap(lambda x: x + BDay())\n\n        assert df.x1.dtype == \"M8[ns]\"",
        "begin_line": 670,
        "end_line": 678,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_non_numpy_dtype#680",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_non_numpy_dtype(self)",
        "snippet": "    def test_apply_non_numpy_dtype(self):\n        # GH 12244\n        df = DataFrame(\n            {\"dt\": pd.date_range(\"2015-01-01\", periods=3, tz=\"Europe/Brussels\")}\n        )\n        result = df.apply(lambda x: x)\n        assert_frame_equal(result, df)\n\n        result = df.apply(lambda x: x + pd.Timedelta(\"1day\"))\n        expected = DataFrame(\n            {\"dt\": pd.date_range(\"2015-01-02\", periods=3, tz=\"Europe/Brussels\")}\n        )\n        assert_frame_equal(result, expected)\n\n        df = DataFrame({\"dt\": [\"a\", \"b\", \"c\", \"a\"]}, dtype=\"category\")\n        result = df.apply(lambda x: x)\n        assert_frame_equal(result, df)",
        "begin_line": 680,
        "end_line": 696,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_dup_names_multi_agg#698",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameApply",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameApply.test_apply_dup_names_multi_agg(self)",
        "snippet": "    def test_apply_dup_names_multi_agg(self):\n        # GH 21063\n        df = pd.DataFrame([[0, 1], [2, 3]], columns=[\"a\", \"a\"])\n        expected = pd.DataFrame([[0, 1]], columns=[\"a\", \"a\"], index=[\"min\"])\n        result = df.agg([\"min\"])\n\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 698,
        "end_line": 704,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestInferOutputShape.test_infer_row_shape#712",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestInferOutputShape",
        "signature": "pandas.tests.frame.test_apply.TestInferOutputShape.test_infer_row_shape(self)",
        "snippet": "    def test_infer_row_shape(self):\n        # GH 17437\n        # if row shape is changing, infer it\n        df = pd.DataFrame(np.random.rand(10, 2))\n        result = df.apply(np.fft.fft, axis=0)\n        assert result.shape == (10, 2)\n\n        result = df.apply(np.fft.rfft, axis=0)\n        assert result.shape == (6, 2)",
        "begin_line": 712,
        "end_line": 720,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestInferOutputShape.test_with_dictlike_columns#722",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestInferOutputShape",
        "signature": "pandas.tests.frame.test_apply.TestInferOutputShape.test_with_dictlike_columns(self)",
        "snippet": "    def test_with_dictlike_columns(self):\n        # GH 17602\n        df = DataFrame([[1, 2], [1, 2]], columns=[\"a\", \"b\"])\n        result = df.apply(lambda x: {\"s\": x[\"a\"] + x[\"b\"]}, axis=1)\n        expected = Series([{\"s\": 3} for t in df.itertuples()])\n        assert_series_equal(result, expected)\n\n        df[\"tm\"] = [\n            pd.Timestamp(\"2017-05-01 00:00:00\"),\n            pd.Timestamp(\"2017-05-02 00:00:00\"),\n        ]\n        result = df.apply(lambda x: {\"s\": x[\"a\"] + x[\"b\"]}, axis=1)\n        assert_series_equal(result, expected)\n\n        # compose a series\n        result = (df[\"a\"] + df[\"b\"]).apply(lambda x: {\"s\": x})\n        expected = Series([{\"s\": 3}, {\"s\": 3}])\n        assert_series_equal(result, expected)\n\n        # GH 18775\n        df = DataFrame()\n        df[\"author\"] = [\"X\", \"Y\", \"Z\"]\n        df[\"publisher\"] = [\"BBC\", \"NBC\", \"N24\"]\n        df[\"date\"] = pd.to_datetime(\n            [\"17-10-2010 07:15:30\", \"13-05-2011 08:20:35\", \"15-01-2013 09:09:09\"]\n        )\n        result = df.apply(lambda x: {}, axis=1)\n        expected = Series([{}, {}, {}])\n        assert_series_equal(result, expected)",
        "begin_line": 722,
        "end_line": 750,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestInferOutputShape.test_with_dictlike_columns_with_infer#752",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestInferOutputShape",
        "signature": "pandas.tests.frame.test_apply.TestInferOutputShape.test_with_dictlike_columns_with_infer(self)",
        "snippet": "    def test_with_dictlike_columns_with_infer(self):\n        # GH 17602\n        df = DataFrame([[1, 2], [1, 2]], columns=[\"a\", \"b\"])\n        result = df.apply(\n            lambda x: {\"s\": x[\"a\"] + x[\"b\"]}, axis=1, result_type=\"expand\"\n        )\n        expected = DataFrame({\"s\": [3, 3]})\n        assert_frame_equal(result, expected)\n\n        df[\"tm\"] = [\n            pd.Timestamp(\"2017-05-01 00:00:00\"),\n            pd.Timestamp(\"2017-05-02 00:00:00\"),\n        ]\n        result = df.apply(\n            lambda x: {\"s\": x[\"a\"] + x[\"b\"]}, axis=1, result_type=\"expand\"\n        )\n        assert_frame_equal(result, expected)",
        "begin_line": 752,
        "end_line": 768,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestInferOutputShape.test_with_listlike_columns#770",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestInferOutputShape",
        "signature": "pandas.tests.frame.test_apply.TestInferOutputShape.test_with_listlike_columns(self)",
        "snippet": "    def test_with_listlike_columns(self):\n        # GH 17348\n        df = DataFrame(\n            {\n                \"a\": Series(np.random.randn(4)),\n                \"b\": [\"a\", \"list\", \"of\", \"words\"],\n                \"ts\": date_range(\"2016-10-01\", periods=4, freq=\"H\"),\n            }\n        )\n\n        result = df[[\"a\", \"b\"]].apply(tuple, axis=1)\n        expected = Series([t[1:] for t in df[[\"a\", \"b\"]].itertuples()])\n        assert_series_equal(result, expected)\n\n        result = df[[\"a\", \"ts\"]].apply(tuple, axis=1)\n        expected = Series([t[1:] for t in df[[\"a\", \"ts\"]].itertuples()])\n        assert_series_equal(result, expected)\n\n        # GH 18919\n        df = DataFrame(\n            {\"x\": Series([[\"a\", \"b\"], [\"q\"]]), \"y\": Series([[\"z\"], [\"q\", \"t\"]])}\n        )\n        df.index = MultiIndex.from_tuples([(\"i0\", \"j0\"), (\"i1\", \"j1\")])\n\n        result = df.apply(lambda row: [el for el in row[\"x\"] if el in row[\"y\"]], axis=1)\n        expected = Series([[], [\"q\"]], index=df.index)\n        assert_series_equal(result, expected)",
        "begin_line": 770,
        "end_line": 796,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestInferOutputShape.test_infer_output_shape_columns#798",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestInferOutputShape",
        "signature": "pandas.tests.frame.test_apply.TestInferOutputShape.test_infer_output_shape_columns(self)",
        "snippet": "    def test_infer_output_shape_columns(self):\n        # GH 18573\n\n        df = DataFrame(\n            {\n                \"number\": [1.0, 2.0],\n                \"string\": [\"foo\", \"bar\"],\n                \"datetime\": [\n                    pd.Timestamp(\"2017-11-29 03:30:00\"),\n                    pd.Timestamp(\"2017-11-29 03:45:00\"),\n                ],\n            }\n        )\n        result = df.apply(lambda row: (row.number, row.string), axis=1)\n        expected = Series([(t.number, t.string) for t in df.itertuples()])\n        assert_series_equal(result, expected)",
        "begin_line": 798,
        "end_line": 813,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestInferOutputShape.test_infer_output_shape_listlike_columns#815",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestInferOutputShape",
        "signature": "pandas.tests.frame.test_apply.TestInferOutputShape.test_infer_output_shape_listlike_columns(self)",
        "snippet": "    def test_infer_output_shape_listlike_columns(self):\n        # GH 16353\n\n        df = DataFrame(np.random.randn(6, 3), columns=[\"A\", \"B\", \"C\"])\n\n        result = df.apply(lambda x: [1, 2, 3], axis=1)\n        expected = Series([[1, 2, 3] for t in df.itertuples()])\n        assert_series_equal(result, expected)\n\n        result = df.apply(lambda x: [1, 2], axis=1)\n        expected = Series([[1, 2] for t in df.itertuples()])\n        assert_series_equal(result, expected)\n\n        # GH 17970\n        df = DataFrame({\"a\": [1, 2, 3]}, index=list(\"abc\"))\n\n        result = df.apply(lambda row: np.ones(1), axis=1)\n        expected = Series([np.ones(1) for t in df.itertuples()], index=df.index)\n        assert_series_equal(result, expected)\n\n        result = df.apply(lambda row: np.ones(2), axis=1)\n        expected = Series([np.ones(2) for t in df.itertuples()], index=df.index)\n        assert_series_equal(result, expected)\n\n        # GH 17892\n        df = pd.DataFrame(\n            {\n                \"a\": [\n                    pd.Timestamp(\"2010-02-01\"),\n                    pd.Timestamp(\"2010-02-04\"),\n                    pd.Timestamp(\"2010-02-05\"),\n                    pd.Timestamp(\"2010-02-06\"),\n                ],\n                \"b\": [9, 5, 4, 3],\n                \"c\": [5, 3, 4, 2],\n                \"d\": [1, 2, 3, 4],\n            }\n        )\n\n        def fun(x):\n            return (1, 2)\n\n        result = df.apply(fun, axis=1)\n        expected = Series([(1, 2) for t in df.itertuples()])\n        assert_series_equal(result, expected)",
        "begin_line": 815,
        "end_line": 859,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestInferOutputShape.fun#854",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestInferOutputShape",
        "signature": "pandas.tests.frame.test_apply.TestInferOutputShape.fun(x)",
        "snippet": "        def fun(x):\n            return (1, 2)",
        "begin_line": 854,
        "end_line": 855,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestInferOutputShape.test_consistent_coerce_for_shapes#861",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestInferOutputShape",
        "signature": "pandas.tests.frame.test_apply.TestInferOutputShape.test_consistent_coerce_for_shapes(self)",
        "snippet": "    def test_consistent_coerce_for_shapes(self):\n        # we want column names to NOT be propagated\n        # just because the shape matches the input shape\n        df = DataFrame(np.random.randn(4, 3), columns=[\"A\", \"B\", \"C\"])\n\n        result = df.apply(lambda x: [1, 2, 3], axis=1)\n        expected = Series([[1, 2, 3] for t in df.itertuples()])\n        assert_series_equal(result, expected)\n\n        result = df.apply(lambda x: [1, 2], axis=1)\n        expected = Series([[1, 2] for t in df.itertuples()])\n        assert_series_equal(result, expected)",
        "begin_line": 861,
        "end_line": 872,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestInferOutputShape.test_consistent_names#874",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestInferOutputShape",
        "signature": "pandas.tests.frame.test_apply.TestInferOutputShape.test_consistent_names(self, int_frame_const_col)",
        "snippet": "    def test_consistent_names(self, int_frame_const_col):\n        # if a Series is returned, we should use the resulting index names\n        df = int_frame_const_col\n\n        result = df.apply(\n            lambda x: Series([1, 2, 3], index=[\"test\", \"other\", \"cols\"]), axis=1\n        )\n        expected = int_frame_const_col.rename(\n            columns={\"A\": \"test\", \"B\": \"other\", \"C\": \"cols\"}\n        )\n        assert_frame_equal(result, expected)\n\n        result = df.apply(lambda x: Series([1, 2], index=[\"test\", \"other\"]), axis=1)\n        expected = expected[[\"test\", \"other\"]]\n        assert_frame_equal(result, expected)",
        "begin_line": 874,
        "end_line": 888,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestInferOutputShape.test_result_type#890",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestInferOutputShape",
        "signature": "pandas.tests.frame.test_apply.TestInferOutputShape.test_result_type(self, int_frame_const_col)",
        "snippet": "    def test_result_type(self, int_frame_const_col):\n        # result_type should be consistent no matter which\n        # path we take in the code\n        df = int_frame_const_col\n\n        result = df.apply(lambda x: [1, 2, 3], axis=1, result_type=\"expand\")\n        expected = df.copy()\n        expected.columns = [0, 1, 2]\n        assert_frame_equal(result, expected)\n\n        result = df.apply(lambda x: [1, 2], axis=1, result_type=\"expand\")\n        expected = df[[\"A\", \"B\"]].copy()\n        expected.columns = [0, 1]\n        assert_frame_equal(result, expected)\n\n        # broadcast result\n        result = df.apply(lambda x: [1, 2, 3], axis=1, result_type=\"broadcast\")\n        expected = df.copy()\n        assert_frame_equal(result, expected)\n\n        columns = [\"other\", \"col\", \"names\"]\n        result = df.apply(\n            lambda x: Series([1, 2, 3], index=columns), axis=1, result_type=\"broadcast\"\n        )\n        expected = df.copy()\n        assert_frame_equal(result, expected)\n\n        # series result\n        result = df.apply(lambda x: Series([1, 2, 3], index=x.index), axis=1)\n        expected = df.copy()\n        assert_frame_equal(result, expected)\n\n        # series result with other index\n        columns = [\"other\", \"col\", \"names\"]\n        result = df.apply(lambda x: Series([1, 2, 3], index=columns), axis=1)\n        expected = df.copy()\n        expected.columns = columns\n        assert_frame_equal(result, expected)",
        "begin_line": 890,
        "end_line": 927,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestInferOutputShape.test_result_type_error#930",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestInferOutputShape",
        "signature": "pandas.tests.frame.test_apply.TestInferOutputShape.test_result_type_error(self, result_type, int_frame_const_col)",
        "snippet": "    def test_result_type_error(self, result_type, int_frame_const_col):\n        # allowed result_type\n        df = int_frame_const_col\n\n        with pytest.raises(ValueError):\n            df.apply(lambda x: [1, 2, 3], axis=1, result_type=result_type)",
        "begin_line": 930,
        "end_line": 935,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestInferOutputShape.test_consistency_for_boxed#942",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestInferOutputShape",
        "signature": "pandas.tests.frame.test_apply.TestInferOutputShape.test_consistency_for_boxed(self, box, int_frame_const_col)",
        "snippet": "    def test_consistency_for_boxed(self, box, int_frame_const_col):\n        # passing an array or list should not affect the output shape\n        df = int_frame_const_col\n\n        result = df.apply(lambda x: box([1, 2]), axis=1)\n        expected = Series([box([1, 2]) for t in df.itertuples()])\n        assert_series_equal(result, expected)\n\n        result = df.apply(lambda x: box([1, 2]), axis=1, result_type=\"expand\")\n        expected = int_frame_const_col[[\"A\", \"B\"]].rename(columns={\"A\": 0, \"B\": 1})\n        assert_frame_equal(result, expected)",
        "begin_line": 942,
        "end_line": 952,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.zip_frames#955",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply",
        "signature": "pandas.tests.frame.test_apply.zip_frames(frames, axis=1)",
        "snippet": "def zip_frames(frames, axis=1):\n    \"\"\"\n    take a list of frames, zip them together under the\n    assumption that these all have the first frames' index/columns.\n\n    Returns\n    -------\n    new_frame : DataFrame\n    \"\"\"\n    if axis == 1:\n        columns = frames[0].columns\n        zipped = [f.loc[:, c] for c in columns for f in frames]\n        return pd.concat(zipped, axis=1)\n    else:\n        index = frames[0].index\n        zipped = [f.loc[i, :] for i in index for f in frames]\n        return pd.DataFrame(zipped)",
        "begin_line": 955,
        "end_line": 971,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_agg_transform#975",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameAggregate",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_agg_transform(self, axis, float_frame)",
        "snippet": "    def test_agg_transform(self, axis, float_frame):\n        other_axis = 1 if axis in {0, \"index\"} else 0\n\n        with np.errstate(all=\"ignore\"):\n\n            f_abs = np.abs(float_frame)\n            f_sqrt = np.sqrt(float_frame)\n\n            # ufunc\n            result = float_frame.transform(np.sqrt, axis=axis)\n            expected = f_sqrt.copy()\n            assert_frame_equal(result, expected)\n\n            result = float_frame.apply(np.sqrt, axis=axis)\n            assert_frame_equal(result, expected)\n\n            result = float_frame.transform(np.sqrt, axis=axis)\n            assert_frame_equal(result, expected)\n\n            # list-like\n            result = float_frame.apply([np.sqrt], axis=axis)\n            expected = f_sqrt.copy()\n            if axis in {0, \"index\"}:\n                expected.columns = pd.MultiIndex.from_product(\n                    [float_frame.columns, [\"sqrt\"]]\n                )\n            else:\n                expected.index = pd.MultiIndex.from_product(\n                    [float_frame.index, [\"sqrt\"]]\n                )\n            assert_frame_equal(result, expected)\n\n            result = float_frame.transform([np.sqrt], axis=axis)\n            assert_frame_equal(result, expected)\n\n            # multiple items in list\n            # these are in the order as if we are applying both\n            # functions per series and then concatting\n            result = float_frame.apply([np.abs, np.sqrt], axis=axis)\n            expected = zip_frames([f_abs, f_sqrt], axis=other_axis)\n            if axis in {0, \"index\"}:\n                expected.columns = pd.MultiIndex.from_product(\n                    [float_frame.columns, [\"absolute\", \"sqrt\"]]\n                )\n            else:\n                expected.index = pd.MultiIndex.from_product(\n                    [float_frame.index, [\"absolute\", \"sqrt\"]]\n                )\n            assert_frame_equal(result, expected)\n\n            result = float_frame.transform([np.abs, \"sqrt\"], axis=axis)\n            assert_frame_equal(result, expected)",
        "begin_line": 975,
        "end_line": 1026,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_transform_and_agg_err#1028",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameAggregate",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_transform_and_agg_err(self, axis, float_frame)",
        "snippet": "    def test_transform_and_agg_err(self, axis, float_frame):\n        # cannot both transform and agg\n        with pytest.raises(ValueError):\n            float_frame.transform([\"max\", \"min\"], axis=axis)\n\n        with pytest.raises(ValueError):\n            with np.errstate(all=\"ignore\"):\n                float_frame.agg([\"max\", \"sqrt\"], axis=axis)\n\n        with pytest.raises(ValueError):\n            with np.errstate(all=\"ignore\"):\n                float_frame.transform([\"max\", \"sqrt\"], axis=axis)\n\n        df = pd.DataFrame({\"A\": range(5), \"B\": 5})\n\n        def f():\n            with np.errstate(all=\"ignore\"):\n                df.agg({\"A\": [\"abs\", \"sum\"], \"B\": [\"mean\", \"max\"]}, axis=axis)",
        "begin_line": 1028,
        "end_line": 1045,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameAggregate.f#1043",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameAggregate",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameAggregate.f()",
        "snippet": "        def f():\n            with np.errstate(all=\"ignore\"):\n                df.agg({\"A\": [\"abs\", \"sum\"], \"B\": [\"mean\", \"max\"]}, axis=axis)",
        "begin_line": 1043,
        "end_line": 1045,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_transform_method_name#1048",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameAggregate",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_transform_method_name(self, method)",
        "snippet": "    def test_transform_method_name(self, method):\n        # GH 19760\n        df = pd.DataFrame({\"A\": [-1, 2]})\n        result = df.transform(method)\n        expected = operator.methodcaller(method)(df)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1048,
        "end_line": 1053,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_demo#1055",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameAggregate",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_demo(self)",
        "snippet": "    def test_demo(self):\n        # demonstration tests\n        df = pd.DataFrame({\"A\": range(5), \"B\": 5})\n\n        result = df.agg([\"min\", \"max\"])\n        expected = DataFrame(\n            {\"A\": [0, 4], \"B\": [5, 5]}, columns=[\"A\", \"B\"], index=[\"min\", \"max\"]\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = df.agg({\"A\": [\"min\", \"max\"], \"B\": [\"sum\", \"max\"]})\n        expected = DataFrame(\n            {\"A\": [4.0, 0.0, np.nan], \"B\": [5.0, np.nan, 25.0]},\n            columns=[\"A\", \"B\"],\n            index=[\"max\", \"min\", \"sum\"],\n        )\n        tm.assert_frame_equal(result.reindex_like(expected), expected)",
        "begin_line": 1055,
        "end_line": 1071,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_agg_multiple_mixed_no_warning#1073",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameAggregate",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_agg_multiple_mixed_no_warning(self)",
        "snippet": "    def test_agg_multiple_mixed_no_warning(self):\n        # GH 20909\n        mdf = pd.DataFrame(\n            {\n                \"A\": [1, 2, 3],\n                \"B\": [1.0, 2.0, 3.0],\n                \"C\": [\"foo\", \"bar\", \"baz\"],\n                \"D\": pd.date_range(\"20130101\", periods=3),\n            }\n        )\n        expected = pd.DataFrame(\n            {\n                \"A\": [1, 6],\n                \"B\": [1.0, 6.0],\n                \"C\": [\"bar\", \"foobarbaz\"],\n                \"D\": [pd.Timestamp(\"2013-01-01\"), pd.NaT],\n            },\n            index=[\"min\", \"sum\"],\n        )\n        # sorted index\n        with tm.assert_produces_warning(None):\n            result = mdf.agg([\"min\", \"sum\"])\n\n        tm.assert_frame_equal(result, expected)\n\n        with tm.assert_produces_warning(None):\n            result = mdf[[\"D\", \"C\", \"B\", \"A\"]].agg([\"sum\", \"min\"])\n\n        # For backwards compatibility, the result's index is\n        # still sorted by function name, so it's ['min', 'sum']\n        # not ['sum', 'min'].\n        expected = expected[[\"D\", \"C\", \"B\", \"A\"]]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1073,
        "end_line": 1105,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_agg_dict_nested_renaming_depr#1107",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameAggregate",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_agg_dict_nested_renaming_depr(self)",
        "snippet": "    def test_agg_dict_nested_renaming_depr(self):\n\n        df = pd.DataFrame({\"A\": range(5), \"B\": 5})\n\n        # nested renaming\n        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n            df.agg({\"A\": {\"foo\": \"min\"}, \"B\": {\"bar\": \"max\"}})",
        "begin_line": 1107,
        "end_line": 1113,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_agg_reduce#1115",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameAggregate",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_agg_reduce(self, axis, float_frame)",
        "snippet": "    def test_agg_reduce(self, axis, float_frame):\n        other_axis = 1 if axis in {0, \"index\"} else 0\n        name1, name2 = float_frame.axes[other_axis].unique()[:2].sort_values()\n\n        # all reducers\n        expected = pd.concat(\n            [\n                float_frame.mean(axis=axis),\n                float_frame.max(axis=axis),\n                float_frame.sum(axis=axis),\n            ],\n            axis=1,\n        )\n        expected.columns = [\"mean\", \"max\", \"sum\"]\n        expected = expected.T if axis in {0, \"index\"} else expected\n\n        result = float_frame.agg([\"mean\", \"max\", \"sum\"], axis=axis)\n        assert_frame_equal(result, expected)\n\n        # dict input with scalars\n        func = OrderedDict([(name1, \"mean\"), (name2, \"sum\")])\n        result = float_frame.agg(func, axis=axis)\n        expected = Series(\n            [\n                float_frame.loc(other_axis)[name1].mean(),\n                float_frame.loc(other_axis)[name2].sum(),\n            ],\n            index=[name1, name2],\n        )\n        assert_series_equal(result, expected)\n\n        # dict input with lists\n        func = OrderedDict([(name1, [\"mean\"]), (name2, [\"sum\"])])\n        result = float_frame.agg(func, axis=axis)\n        expected = DataFrame(\n            {\n                name1: Series(\n                    [float_frame.loc(other_axis)[name1].mean()], index=[\"mean\"]\n                ),\n                name2: Series(\n                    [float_frame.loc(other_axis)[name2].sum()], index=[\"sum\"]\n                ),\n            }\n        )\n        expected = expected.T if axis in {1, \"columns\"} else expected\n        assert_frame_equal(result, expected)\n\n        # dict input with lists with multiple\n        func = OrderedDict([(name1, [\"mean\", \"sum\"]), (name2, [\"sum\", \"max\"])])\n        result = float_frame.agg(func, axis=axis)\n        expected = DataFrame(\n            OrderedDict(\n                [\n                    (\n                        name1,\n                        Series(\n                            [\n                                float_frame.loc(other_axis)[name1].mean(),\n                                float_frame.loc(other_axis)[name1].sum(),\n                            ],\n                            index=[\"mean\", \"sum\"],\n                        ),\n                    ),\n                    (\n                        name2,\n                        Series(\n                            [\n                                float_frame.loc(other_axis)[name2].sum(),\n                                float_frame.loc(other_axis)[name2].max(),\n                            ],\n                            index=[\"sum\", \"max\"],\n                        ),\n                    ),\n                ]\n            )\n        )\n        expected = expected.T if axis in {1, \"columns\"} else expected\n        assert_frame_equal(result, expected)",
        "begin_line": 1115,
        "end_line": 1192,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_nuiscance_columns#1194",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameAggregate",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_nuiscance_columns(self)",
        "snippet": "    def test_nuiscance_columns(self):\n\n        # GH 15015\n        df = DataFrame(\n            {\n                \"A\": [1, 2, 3],\n                \"B\": [1.0, 2.0, 3.0],\n                \"C\": [\"foo\", \"bar\", \"baz\"],\n                \"D\": pd.date_range(\"20130101\", periods=3),\n            }\n        )\n\n        result = df.agg(\"min\")\n        expected = Series([1, 1.0, \"bar\", pd.Timestamp(\"20130101\")], index=df.columns)\n        assert_series_equal(result, expected)\n\n        result = df.agg([\"min\"])\n        expected = DataFrame(\n            [[1, 1.0, \"bar\", pd.Timestamp(\"20130101\")]],\n            index=[\"min\"],\n            columns=df.columns,\n        )\n        assert_frame_equal(result, expected)\n\n        result = df.agg(\"sum\")\n        expected = Series([6, 6.0, \"foobarbaz\"], index=[\"A\", \"B\", \"C\"])\n        assert_series_equal(result, expected)\n\n        result = df.agg([\"sum\"])\n        expected = DataFrame(\n            [[6, 6.0, \"foobarbaz\"]], index=[\"sum\"], columns=[\"A\", \"B\", \"C\"]\n        )\n        assert_frame_equal(result, expected)",
        "begin_line": 1194,
        "end_line": 1226,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_non_callable_aggregates#1228",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameAggregate",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_non_callable_aggregates(self)",
        "snippet": "    def test_non_callable_aggregates(self):\n\n        # GH 16405\n        # 'size' is a property of frame/series\n        # validate that this is working\n        df = DataFrame(\n            {\"A\": [None, 2, 3], \"B\": [1.0, np.nan, 3.0], \"C\": [\"foo\", None, \"bar\"]}\n        )\n\n        # Function aggregate\n        result = df.agg({\"A\": \"count\"})\n        expected = Series({\"A\": 2})\n\n        assert_series_equal(result, expected)\n\n        # Non-function aggregate\n        result = df.agg({\"A\": \"size\"})\n        expected = Series({\"A\": 3})\n\n        assert_series_equal(result, expected)\n\n        # Mix function and non-function aggs\n        result1 = df.agg([\"count\", \"size\"])\n        result2 = df.agg(\n            {\"A\": [\"count\", \"size\"], \"B\": [\"count\", \"size\"], \"C\": [\"count\", \"size\"]}\n        )\n        expected = pd.DataFrame(\n            {\n                \"A\": {\"count\": 2, \"size\": 3},\n                \"B\": {\"count\": 2, \"size\": 3},\n                \"C\": {\"count\": 2, \"size\": 3},\n            }\n        )\n\n        assert_frame_equal(result1, result2, check_like=True)\n        assert_frame_equal(result2, expected, check_like=True)\n\n        # Just functional string arg is same as calling df.arg()\n        result = df.agg(\"count\")\n        expected = df.count()\n\n        assert_series_equal(result, expected)\n\n        # Just a string attribute arg same as calling df.arg\n        result = df.agg(\"size\")\n        expected = df.size\n\n        assert result == expected",
        "begin_line": 1228,
        "end_line": 1275,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_agg_cython_table#1312",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameAggregate",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_agg_cython_table(self, df, func, expected, axis)",
        "snippet": "    def test_agg_cython_table(self, df, func, expected, axis):\n        # GH 21224\n        # test reducing functions in\n        # pandas.core.base.SelectionMixin._cython_table\n        result = df.agg(func, axis=axis)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1312,
        "end_line": 1317,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_agg_cython_table_transform#1334",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameAggregate",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_agg_cython_table_transform(self, df, func, expected, axis)",
        "snippet": "    def test_agg_cython_table_transform(self, df, func, expected, axis):\n        # GH 21224\n        # test transforming functions in\n        # pandas.core.base.SelectionMixin._cython_table (cumprod, cumsum)\n        result = df.agg(func, axis=axis)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1334,
        "end_line": 1339,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_agg_cython_table_raises#1347",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameAggregate",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_agg_cython_table_raises(self, df, func, expected, axis)",
        "snippet": "    def test_agg_cython_table_raises(self, df, func, expected, axis):\n        # GH 21224\n        with pytest.raises(expected):\n            df.agg(func, axis=axis)",
        "begin_line": 1347,
        "end_line": 1350,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_frequency_is_original#1353",
        "src_path": "pandas/tests/frame/test_apply.py",
        "class_name": "pandas.tests.frame.test_apply.TestDataFrameAggregate",
        "signature": "pandas.tests.frame.test_apply.TestDataFrameAggregate.test_frequency_is_original(self, num_cols)",
        "snippet": "    def test_frequency_is_original(self, num_cols):\n        # GH 22150\n        index = pd.DatetimeIndex([\"1950-06-30\", \"1952-10-24\", \"1953-05-29\"])\n        original = index.copy()\n        df = DataFrame(1, index=index, columns=range(num_cols))\n        df.apply(lambda x: x)\n        assert index.freq == original.freq",
        "begin_line": 1353,
        "end_line": 1359,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common.TestData.frame#23",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common.TestData",
        "signature": "pandas.tests.frame.common.TestData.frame(self)",
        "snippet": "    def frame(self):\n        return _frame.copy()",
        "begin_line": 23,
        "end_line": 24,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common.TestData.frame2#27",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common.TestData",
        "signature": "pandas.tests.frame.common.TestData.frame2(self)",
        "snippet": "    def frame2(self):\n        return _frame2.copy()",
        "begin_line": 27,
        "end_line": 28,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common.TestData.intframe#31",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common.TestData",
        "signature": "pandas.tests.frame.common.TestData.intframe(self)",
        "snippet": "    def intframe(self):\n        # force these all to int64 to avoid platform testing issues\n        return pd.DataFrame({c: s for c, s in _intframe.items()}, dtype=np.int64)",
        "begin_line": 31,
        "end_line": 33,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common.TestData.tsframe#36",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common.TestData",
        "signature": "pandas.tests.frame.common.TestData.tsframe(self)",
        "snippet": "    def tsframe(self):\n        return _tsframe.copy()",
        "begin_line": 36,
        "end_line": 37,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common.TestData.mixed_frame#40",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common.TestData",
        "signature": "pandas.tests.frame.common.TestData.mixed_frame(self)",
        "snippet": "    def mixed_frame(self):\n        return _mixed_frame.copy()",
        "begin_line": 40,
        "end_line": 41,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common.TestData.tzframe#90",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common.TestData",
        "signature": "pandas.tests.frame.common.TestData.tzframe(self)",
        "snippet": "    def tzframe(self):\n        result = pd.DataFrame(\n            {\n                \"A\": pd.date_range(\"20130101\", periods=3),\n                \"B\": pd.date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n                \"C\": pd.date_range(\"20130101\", periods=3, tz=\"CET\"),\n            }\n        )\n        result.iloc[1, 1] = pd.NaT\n        result.iloc[1, 2] = pd.NaT\n        return result",
        "begin_line": 90,
        "end_line": 100,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common.TestData.empty#103",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common.TestData",
        "signature": "pandas.tests.frame.common.TestData.empty(self)",
        "snippet": "    def empty(self):\n        return pd.DataFrame()",
        "begin_line": 103,
        "end_line": 104,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common._check_mixed_float#125",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common",
        "signature": "pandas.tests.frame.common._check_mixed_float(df, dtype=None)",
        "snippet": "def _check_mixed_float(df, dtype=None):\n    # float16 are most likely to be upcasted to float32\n    dtypes = dict(A=\"float32\", B=\"float32\", C=\"float16\", D=\"float64\")\n    if isinstance(dtype, str):\n        dtypes = {k: dtype for k, v in dtypes.items()}\n    elif isinstance(dtype, dict):\n        dtypes.update(dtype)\n    if dtypes.get(\"A\"):\n        assert df.dtypes[\"A\"] == dtypes[\"A\"]\n    if dtypes.get(\"B\"):\n        assert df.dtypes[\"B\"] == dtypes[\"B\"]\n    if dtypes.get(\"C\"):\n        assert df.dtypes[\"C\"] == dtypes[\"C\"]\n    if dtypes.get(\"D\"):\n        assert df.dtypes[\"D\"] == dtypes[\"D\"]",
        "begin_line": 125,
        "end_line": 139,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common._check_mixed_int#142",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common",
        "signature": "pandas.tests.frame.common._check_mixed_int(df, dtype=None)",
        "snippet": "def _check_mixed_int(df, dtype=None):\n    dtypes = dict(A=\"int32\", B=\"uint64\", C=\"uint8\", D=\"int64\")\n    if isinstance(dtype, str):\n        dtypes = {k: dtype for k, v in dtypes.items()}\n    elif isinstance(dtype, dict):\n        dtypes.update(dtype)\n    if dtypes.get(\"A\"):\n        assert df.dtypes[\"A\"] == dtypes[\"A\"]\n    if dtypes.get(\"B\"):\n        assert df.dtypes[\"B\"] == dtypes[\"B\"]\n    if dtypes.get(\"C\"):\n        assert df.dtypes[\"C\"] == dtypes[\"C\"]\n    if dtypes.get(\"D\"):\n        assert df.dtypes[\"D\"] == dtypes[\"D\"]",
        "begin_line": 142,
        "end_line": 155,
        "comment": "",
        "is_bug": false
    }
]