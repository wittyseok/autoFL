[
    {
        "name": "blib2to3.pytree.type_repr#21",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree",
        "signature": "blib2to3.pytree.type_repr(type_num)",
        "snippet": "def type_repr(type_num):\n    global _type_reprs\n    if not _type_reprs:\n        from .pygram import python_symbols\n        # printing tokens is possible but not as useful\n        # from .pgen2 import token // token.__dict__.items():\n        for name, val in python_symbols.__dict__.items():\n            if type(val) == int: _type_reprs[val] = name\n    return _type_reprs.setdefault(type_num, type_num)",
        "begin_line": 21,
        "end_line": 29,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011389521640091116,
            "pseudo_dstar_susp": 0.0011389521640091116,
            "pseudo_tarantula_susp": 0.0011389521640091116,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0011389521640091116
        }
    },
    {
        "name": "blib2to3.pytree.Base.__new__#49",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Base",
        "signature": "blib2to3.pytree.Base.__new__(cls, *args, **kwds)",
        "snippet": "    def __new__(cls, *args, **kwds):\n        \"\"\"Constructor that prevents Base from being instantiated.\"\"\"\n        assert cls is not Base, \"Cannot instantiate Base\"\n        return object.__new__(cls)",
        "begin_line": 49,
        "end_line": 52,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009891196834817012,
            "pseudo_dstar_susp": 0.0009891196834817012,
            "pseudo_tarantula_susp": 0.0009891196834817012,
            "pseudo_op2_susp": 0.0009891196834817012,
            "pseudo_barinel_susp": 0.0009891196834817012
        }
    },
    {
        "name": "blib2to3.pytree.Base.changed#133",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Base",
        "signature": "blib2to3.pytree.Base.changed(self)",
        "snippet": "    def changed(self):\n        if self.parent:\n            self.parent.changed()\n        self.was_changed = True",
        "begin_line": 133,
        "end_line": 136,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013458950201884253,
            "pseudo_dstar_susp": 0.0013458950201884253,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0013458950201884253,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "blib2to3.pytree.Base.remove#138",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Base",
        "signature": "blib2to3.pytree.Base.remove(self)",
        "snippet": "    def remove(self):\n        \"\"\"\n        Remove the node from the tree. Returns the position of the node in its\n        parent's children before it was removed.\n        \"\"\"\n        if self.parent:\n            for i, node in enumerate(self.parent.children):\n                if node is self:\n                    self.parent.changed()\n                    del self.parent.children[i]\n                    self.parent = None\n                    return i",
        "begin_line": 138,
        "end_line": 149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004405286343612335,
            "pseudo_dstar_susp": 0.004405286343612335,
            "pseudo_tarantula_susp": 0.0044444444444444444,
            "pseudo_op2_susp": 0.004405286343612335,
            "pseudo_barinel_susp": 0.0044444444444444444
        }
    },
    {
        "name": "blib2to3.pytree.Base.prev_sibling#169",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Base",
        "signature": "blib2to3.pytree.Base.prev_sibling(self)",
        "snippet": "    def prev_sibling(self):\n        \"\"\"\n        The node immediately preceding the invocant in their parent's children\n        list. If the invocant does not have a previous sibling, it is None.\n        \"\"\"\n        if self.parent is None:\n            return None\n\n        # Can't use index(); we need to test by identity\n        for i, child in enumerate(self.parent.children):\n            if child is self:\n                if i == 0:\n                    return None\n                return self.parent.children[i-1]",
        "begin_line": 169,
        "end_line": 182,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001658374792703151,
            "pseudo_dstar_susp": 0.001658374792703151,
            "pseudo_tarantula_susp": 0.001658374792703151,
            "pseudo_op2_susp": 0.001658374792703151,
            "pseudo_barinel_susp": 0.001658374792703151
        }
    },
    {
        "name": "blib2to3.pytree.Base.leaves#184",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Base",
        "signature": "blib2to3.pytree.Base.leaves(self)",
        "snippet": "    def leaves(self):\n        for child in self.children:\n            yield from child.leaves()",
        "begin_line": 184,
        "end_line": 186,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029850746268656717,
            "pseudo_dstar_susp": 0.0029850746268656717,
            "pseudo_tarantula_susp": 0.0029940119760479044,
            "pseudo_op2_susp": 0.0029850746268656717,
            "pseudo_barinel_susp": 0.0029940119760479044
        }
    },
    {
        "name": "blib2to3.pytree.Node.__init__#211",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Node",
        "signature": "blib2to3.pytree.Node.__init__(self, type, children, context=None, prefix=None, fixers_applied=None)",
        "snippet": "    def __init__(self,type, children,\n                 context=None,\n                 prefix=None,\n                 fixers_applied=None):\n        \"\"\"\n        Initializer.\n\n        Takes a type constant (a symbol number >= 256), a sequence of\n        child nodes, and an optional context keyword argument.\n\n        As a side effect, the parent pointers of the children are updated.\n        \"\"\"\n        assert type >= 256, type\n        self.type = type\n        self.children = list(children)\n        for ch in self.children:\n            assert ch.parent is None, repr(ch)\n            ch.parent = self\n        if prefix is not None:\n            self.prefix = prefix\n        if fixers_applied:\n            self.fixers_applied = fixers_applied[:]\n        else:\n            self.fixers_applied = None",
        "begin_line": 211,
        "end_line": 234,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009891196834817012,
            "pseudo_dstar_susp": 0.0009891196834817012,
            "pseudo_tarantula_susp": 0.0009891196834817012,
            "pseudo_op2_susp": 0.0009891196834817012,
            "pseudo_barinel_susp": 0.0009891196834817012
        }
    },
    {
        "name": "blib2to3.pytree.Node.pre_order#268",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Node",
        "signature": "blib2to3.pytree.Node.pre_order(self)",
        "snippet": "    def pre_order(self):\n        \"\"\"Return a pre-order iterator for the tree.\"\"\"\n        yield self\n        for child in self.children:\n            yield from child.pre_order()",
        "begin_line": 268,
        "end_line": 272,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011641443538998836,
            "pseudo_dstar_susp": 0.0011641443538998836,
            "pseudo_tarantula_susp": 0.0011641443538998836,
            "pseudo_op2_susp": 0.0011641443538998836,
            "pseudo_barinel_susp": 0.0011641443538998836
        }
    },
    {
        "name": "blib2to3.pytree.Node.insert_child#298",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Node",
        "signature": "blib2to3.pytree.Node.insert_child(self, i, child)",
        "snippet": "    def insert_child(self, i, child):\n        \"\"\"\n        Equivalent to 'node.children.insert(i, child)'. This method also sets\n        the child's parent attribute appropriately.\n        \"\"\"\n        child.parent = self\n        self.children.insert(i, child)\n        self.changed()",
        "begin_line": 298,
        "end_line": 305,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00392156862745098,
            "pseudo_dstar_susp": 0.00392156862745098,
            "pseudo_tarantula_susp": 0.003952569169960474,
            "pseudo_op2_susp": 0.00392156862745098,
            "pseudo_barinel_susp": 0.003952569169960474
        }
    },
    {
        "name": "blib2to3.pytree.Node.append_child#307",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Node",
        "signature": "blib2to3.pytree.Node.append_child(self, child)",
        "snippet": "    def append_child(self, child):\n        \"\"\"\n        Equivalent to 'node.children.append(child)'. This method also sets the\n        child's parent attribute appropriately.\n        \"\"\"\n        child.parent = self\n        self.children.append(child)\n        self.changed()",
        "begin_line": 307,
        "end_line": 314,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0006657789613848203,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "blib2to3.pytree.Leaf.__init__#326",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Leaf",
        "signature": "blib2to3.pytree.Leaf.__init__(self, type, value, context=None, prefix=None, fixers_applied=[])",
        "snippet": "    def __init__(self, type, value,\n                 context=None,\n                 prefix=None,\n                 fixers_applied=[]):\n        \"\"\"\n        Initializer.\n\n        Takes a type constant (a token number < 256), a string value, and an\n        optional context keyword argument.\n        \"\"\"\n        assert 0 <= type < 256, type\n        if context is not None:\n            self._prefix, (self.lineno, self.column) = context\n        self.type = type\n        self.value = value\n        if prefix is not None:\n            self._prefix = prefix\n        self.fixers_applied = fixers_applied[:]",
        "begin_line": 326,
        "end_line": 343,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002232142857142857,
            "pseudo_dstar_susp": 0.002232142857142857,
            "pseudo_tarantula_susp": 0.002232142857142857,
            "pseudo_op2_susp": 0.002232142857142857,
            "pseudo_barinel_susp": 0.002232142857142857
        }
    },
    {
        "name": "blib2to3.pytree.Leaf.__unicode__#352",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Leaf",
        "signature": "blib2to3.pytree.Leaf.__unicode__(self)",
        "snippet": "    def __unicode__(self):\n        \"\"\"\n        Return a pretty string representation.\n\n        This reproduces the input source exactly.\n        \"\"\"\n        return self.prefix + str(self.value)",
        "begin_line": 352,
        "end_line": 358,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001658374792703151,
            "pseudo_dstar_susp": 0.001658374792703151,
            "pseudo_tarantula_susp": 0.001658374792703151,
            "pseudo_op2_susp": 0.001658374792703151,
            "pseudo_barinel_susp": 0.001658374792703151
        }
    },
    {
        "name": "blib2to3.pytree.Leaf.leaves#373",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Leaf",
        "signature": "blib2to3.pytree.Leaf.leaves(self)",
        "snippet": "    def leaves(self):\n        yield self",
        "begin_line": 373,
        "end_line": 374,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029850746268656717,
            "pseudo_dstar_susp": 0.0029850746268656717,
            "pseudo_tarantula_susp": 0.0029940119760479044,
            "pseudo_op2_susp": 0.0029850746268656717,
            "pseudo_barinel_susp": 0.0029940119760479044
        }
    },
    {
        "name": "blib2to3.pytree.Leaf.pre_order#380",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Leaf",
        "signature": "blib2to3.pytree.Leaf.pre_order(self)",
        "snippet": "    def pre_order(self):\n        \"\"\"Return a pre-order iterator for the tree.\"\"\"\n        yield self",
        "begin_line": 380,
        "end_line": 382,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011641443538998836,
            "pseudo_dstar_susp": 0.0011641443538998836,
            "pseudo_tarantula_susp": 0.0011641443538998836,
            "pseudo_op2_susp": 0.0011641443538998836,
            "pseudo_barinel_susp": 0.0011641443538998836
        }
    },
    {
        "name": "blib2to3.pytree.Leaf.prefix#385",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Leaf",
        "signature": "blib2to3.pytree.Leaf.prefix(self)",
        "snippet": "    def prefix(self):\n        \"\"\"\n        The whitespace and comments preceding this token in the input.\n        \"\"\"\n        return self._prefix",
        "begin_line": 385,
        "end_line": 389,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011389521640091116,
            "pseudo_dstar_susp": 0.0011389521640091116,
            "pseudo_tarantula_susp": 0.0011389521640091116,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0011389521640091116
        }
    },
    {
        "name": "blib2to3.pytree.Leaf.prefix#392",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Leaf",
        "signature": "blib2to3.pytree.Leaf.prefix(self, prefix)",
        "snippet": "    def prefix(self, prefix):\n        self.changed()\n        self._prefix = prefix",
        "begin_line": 392,
        "end_line": 394,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013458950201884253,
            "pseudo_dstar_susp": 0.0013458950201884253,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0013458950201884253,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "blib2to3.pytree.convert#396",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree",
        "signature": "blib2to3.pytree.convert(gr, raw_node)",
        "snippet": "def convert(gr, raw_node):\n    \"\"\"\n    Convert raw node information to a Node or Leaf instance.\n\n    This is passed to the parser driver which calls it whenever a reduction of a\n    grammar rule produces a new complete node, so that the tree is build\n    strictly bottom-up.\n    \"\"\"\n    type, value, context, children = raw_node\n    if children or type in gr.number2symbol:\n        # If there's exactly one child, return that child instead of\n        # creating a new node.\n        if len(children) == 1:\n            return children[0]\n        return Node(type, children, context=context)\n    else:\n        return Leaf(type, value, context=context)",
        "begin_line": 396,
        "end_line": 412,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010905125408942203,
            "pseudo_dstar_susp": 0.0010905125408942203,
            "pseudo_tarantula_susp": 0.0010905125408942203,
            "pseudo_op2_susp": 0.0010905125408942203,
            "pseudo_barinel_susp": 0.0010905125408942203
        }
    },
    {
        "name": "blib2to3.pgen2.parse.ParseError.__init__#19",
        "src_path": "blib2to3/pgen2/parse.py",
        "class_name": "blib2to3.pgen2.parse.ParseError",
        "signature": "blib2to3.pgen2.parse.ParseError.__init__(self, msg, type, value, context)",
        "snippet": "    def __init__(self, msg, type, value, context):\n        Exception.__init__(self, \"%s: type=%r, value=%r, context=%r\" %\n                           (msg, type, value, context))\n        self.msg = msg\n        self.type = type\n        self.value = value\n        self.context = context",
        "begin_line": 19,
        "end_line": 25,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0007782101167315176,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "blib2to3.pgen2.parse.Parser.__init__#57",
        "src_path": "blib2to3/pgen2/parse.py",
        "class_name": "blib2to3.pgen2.parse.Parser",
        "signature": "blib2to3.pgen2.parse.Parser.__init__(self, grammar, convert=None)",
        "snippet": "    def __init__(self, grammar, convert=None):\n        \"\"\"Constructor.\n\n        The grammar argument is a grammar.Grammar instance; see the\n        grammar module for more information.\n\n        The parser is not ready yet for parsing; you must call the\n        setup() method to get it started.\n\n        The optional convert argument is a function mapping concrete\n        syntax tree nodes to abstract syntax tree nodes.  If not\n        given, no conversion is done and the syntax tree produced is\n        the concrete syntax tree.  If given, it must be a function of\n        two arguments, the first being the grammar (a grammar.Grammar\n        instance), and the second being the concrete syntax tree node\n        to be converted.  The syntax tree is converted from the bottom\n        up.\n\n        A concrete syntax tree node is a (type, value, context, nodes)\n        tuple, where type is the node type (a token or symbol number),\n        value is None for symbols and a string for tokens, context is\n        None or an opaque value used for error reporting (typically a\n        (lineno, offset) pair), and nodes is a list of children for\n        symbols, and None for tokens.\n\n        An abstract syntax tree node may be anything; this is entirely\n        up to the converter function.\n\n        \"\"\"\n        self.grammar = grammar\n        self.convert = convert or (lambda grammar, node: node)",
        "begin_line": 57,
        "end_line": 87,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009891196834817012,
            "pseudo_dstar_susp": 0.0009891196834817012,
            "pseudo_tarantula_susp": 0.0009891196834817012,
            "pseudo_op2_susp": 0.0009891196834817012,
            "pseudo_barinel_susp": 0.0009891196834817012
        }
    },
    {
        "name": "blib2to3.pgen2.parse.Parser.setup#89",
        "src_path": "blib2to3/pgen2/parse.py",
        "class_name": "blib2to3.pgen2.parse.Parser",
        "signature": "blib2to3.pgen2.parse.Parser.setup(self, start=None)",
        "snippet": "    def setup(self, start=None):\n        \"\"\"Prepare for parsing.\n\n        This *must* be called before starting to parse.\n\n        The optional argument is an alternative start symbol; it\n        defaults to the grammar's start symbol.\n\n        You can use a Parser instance to parse any number of programs;\n        each time you call setup() the parser is reset to an initial\n        state determined by the (implicit or explicit) start symbol.\n\n        \"\"\"\n        if start is None:\n            start = self.grammar.start\n        # Each stack entry is a tuple: (dfa, state, node).\n        # A node is a tuple: (type, value, context, children),\n        # where children is a list of nodes or None, and context may be None.\n        newnode = (start, None, None, [])\n        stackentry = (self.grammar.dfas[start], 0, newnode)\n        self.stack = [stackentry]\n        self.rootnode = None\n        self.used_names = set() # Aliased to self.rootnode.used_names in pop()",
        "begin_line": 89,
        "end_line": 111,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009891196834817012,
            "pseudo_dstar_susp": 0.0009891196834817012,
            "pseudo_tarantula_susp": 0.0009891196834817012,
            "pseudo_op2_susp": 0.0009891196834817012,
            "pseudo_barinel_susp": 0.0009891196834817012
        }
    },
    {
        "name": "blib2to3.pgen2.parse.Parser.addtoken#113",
        "src_path": "blib2to3/pgen2/parse.py",
        "class_name": "blib2to3.pgen2.parse.Parser",
        "signature": "blib2to3.pgen2.parse.Parser.addtoken(self, type, value, context)",
        "snippet": "    def addtoken(self, type, value, context):\n        \"\"\"Add a token; return True iff this is the end of the program.\"\"\"\n        # Map from token to label\n        ilabel = self.classify(type, value, context)\n        # Loop until the token is shifted; may raise exceptions\n        while True:\n            dfa, state, node = self.stack[-1]\n            states, first = dfa\n            arcs = states[state]\n            # Look for a state with this label\n            for i, newstate in arcs:\n                t, v = self.grammar.labels[i]\n                if ilabel == i:\n                    # Look it up in the list of labels\n                    assert t < 256\n                    # Shift a token; we're done with it\n                    self.shift(type, value, newstate, context)\n                    # Pop while we are in an accept-only state\n                    state = newstate\n                    while states[state] == [(0, state)]:\n                        self.pop()\n                        if not self.stack:\n                            # Done parsing!\n                            return True\n                        dfa, state, node = self.stack[-1]\n                        states, first = dfa\n                    # Done with this token\n                    return False\n                elif t >= 256:\n                    # See if it's a symbol and if we're in its first set\n                    itsdfa = self.grammar.dfas[t]\n                    itsstates, itsfirst = itsdfa\n                    if ilabel in itsfirst:\n                        # Push a symbol\n                        self.push(t, self.grammar.dfas[t], newstate, context)\n                        break # To continue the outer while loop\n            else:\n                if (0, state) in arcs:\n                    # An accepting state, pop it and try something else\n                    self.pop()\n                    if not self.stack:\n                        # Done parsing, but another token is input\n                        raise ParseError(\"too much input\",\n                                         type, value, context)\n                else:\n                    # No success finding a transition\n                    raise ParseError(\"bad input\", type, value, context)",
        "begin_line": 113,
        "end_line": 159,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010905125408942203,
            "pseudo_dstar_susp": 0.0010905125408942203,
            "pseudo_tarantula_susp": 0.0010905125408942203,
            "pseudo_op2_susp": 0.0010905125408942203,
            "pseudo_barinel_susp": 0.0010905125408942203
        }
    },
    {
        "name": "blib2to3.pgen2.parse.Parser.classify#161",
        "src_path": "blib2to3/pgen2/parse.py",
        "class_name": "blib2to3.pgen2.parse.Parser",
        "signature": "blib2to3.pgen2.parse.Parser.classify(self, type, value, context)",
        "snippet": "    def classify(self, type, value, context):\n        \"\"\"Turn a token into a label.  (Internal)\"\"\"\n        if type == token.NAME:\n            # Keep a listing of all used names\n            self.used_names.add(value)\n            # Check for reserved words\n            ilabel = self.grammar.keywords.get(value)\n            if ilabel is not None:\n                return ilabel\n        ilabel = self.grammar.tokens.get(type)\n        if ilabel is None:\n            raise ParseError(\"bad token\", type, value, context)\n        return ilabel",
        "begin_line": 161,
        "end_line": 173,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018867924528301887,
            "pseudo_dstar_susp": 0.0018867924528301887,
            "pseudo_tarantula_susp": 0.0018867924528301887,
            "pseudo_op2_susp": 0.0018867924528301887,
            "pseudo_barinel_susp": 0.0018867924528301887
        }
    },
    {
        "name": "blib2to3.pgen2.parse.Parser.shift#175",
        "src_path": "blib2to3/pgen2/parse.py",
        "class_name": "blib2to3.pgen2.parse.Parser",
        "signature": "blib2to3.pgen2.parse.Parser.shift(self, type, value, newstate, context)",
        "snippet": "    def shift(self, type, value, newstate, context):\n        \"\"\"Shift a token.  (Internal)\"\"\"\n        dfa, state, node = self.stack[-1]\n        newnode = (type, value, context, None)\n        newnode = self.convert(self.grammar, newnode)\n        if newnode is not None:\n            node[-1].append(newnode)\n        self.stack[-1] = (dfa, newstate, node)",
        "begin_line": 175,
        "end_line": 182,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009891196834817012,
            "pseudo_dstar_susp": 0.0009891196834817012,
            "pseudo_tarantula_susp": 0.0009891196834817012,
            "pseudo_op2_susp": 0.0009891196834817012,
            "pseudo_barinel_susp": 0.0009891196834817012
        }
    },
    {
        "name": "blib2to3.pgen2.parse.Parser.push#184",
        "src_path": "blib2to3/pgen2/parse.py",
        "class_name": "blib2to3.pgen2.parse.Parser",
        "signature": "blib2to3.pgen2.parse.Parser.push(self, type, newdfa, newstate, context)",
        "snippet": "    def push(self, type, newdfa, newstate, context):\n        \"\"\"Push a nonterminal.  (Internal)\"\"\"\n        dfa, state, node = self.stack[-1]\n        newnode = (type, None, context, [])\n        self.stack[-1] = (dfa, newstate, node)\n        self.stack.append((newdfa, 0, newnode))",
        "begin_line": 184,
        "end_line": 189,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010905125408942203,
            "pseudo_dstar_susp": 0.0010905125408942203,
            "pseudo_tarantula_susp": 0.0010905125408942203,
            "pseudo_op2_susp": 0.0010905125408942203,
            "pseudo_barinel_susp": 0.0010905125408942203
        }
    },
    {
        "name": "blib2to3.pgen2.parse.Parser.pop#191",
        "src_path": "blib2to3/pgen2/parse.py",
        "class_name": "blib2to3.pgen2.parse.Parser",
        "signature": "blib2to3.pgen2.parse.Parser.pop(self)",
        "snippet": "    def pop(self):\n        \"\"\"Pop a nonterminal.  (Internal)\"\"\"\n        popdfa, popstate, popnode = self.stack.pop()\n        newnode = self.convert(self.grammar, popnode)\n        if newnode is not None:\n            if self.stack:\n                dfa, state, node = self.stack[-1]\n                node[-1].append(newnode)\n            else:\n                self.rootnode = newnode\n                self.rootnode.used_names = self.used_names",
        "begin_line": 191,
        "end_line": 201,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010905125408942203,
            "pseudo_dstar_susp": 0.0010905125408942203,
            "pseudo_tarantula_susp": 0.0010905125408942203,
            "pseudo_op2_susp": 0.0010905125408942203,
            "pseudo_barinel_susp": 0.0010905125408942203
        }
    },
    {
        "name": "black.FormatError.__init__#86",
        "src_path": "black.py",
        "class_name": "black.FormatError",
        "signature": "black.FormatError.__init__(self, consumed: int)",
        "snippet": "    def __init__(self, consumed: int) -> None:\n        super().__init__(consumed)\n        self.consumed = consumed",
        "begin_line": 86,
        "end_line": 88,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0008298755186721991,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.FormatError.trim_prefix#90",
        "src_path": "black.py",
        "class_name": "black.FormatError",
        "signature": "black.FormatError.trim_prefix(self, leaf: Leaf)",
        "snippet": "    def trim_prefix(self, leaf: Leaf) -> None:\n        leaf.prefix = leaf.prefix[self.consumed:]",
        "begin_line": 90,
        "end_line": 91,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0008298755186721991,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.FormatError.leaf_from_consumed#93",
        "src_path": "black.py",
        "class_name": "black.FormatError",
        "signature": "black.FormatError.leaf_from_consumed(self, leaf: Leaf)",
        "snippet": "    def leaf_from_consumed(self, leaf: Leaf) -> Leaf:\n        \"\"\"Returns a new Leaf from the consumed part of the prefix.\"\"\"\n        unformatted_prefix = leaf.prefix[:self.consumed]\n        return Leaf(token.NEWLINE, unformatted_prefix)",
        "begin_line": 93,
        "end_line": 96,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0008880994671403197,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.main#165",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.main(ctx: click.Context, line_length: int, check: bool, diff: bool, fast: bool, quiet: bool, src: List[str])",
        "snippet": "def main(\n    ctx: click.Context,\n    line_length: int,\n    check: bool,\n    diff: bool,\n    fast: bool,\n    quiet: bool,\n    src: List[str],\n) -> None:\n    \"\"\"The uncompromising code formatter.\"\"\"\n    sources: List[Path] = []\n    for s in src:\n        p = Path(s)\n        if p.is_dir():\n            sources.extend(gen_python_files_in_dir(p))\n        elif p.is_file():\n            # if a file was explicitly given, we don't care about its extension\n            sources.append(p)\n        elif s == \"-\":\n            sources.append(Path(\"-\"))\n        else:\n            err(f\"invalid path: {s}\")\n\n    if check and not diff:\n        write_back = WriteBack.NO\n    elif diff:\n        write_back = WriteBack.DIFF\n    else:\n        write_back = WriteBack.YES\n    report = Report(check=check, quiet=quiet)\n    if len(sources) == 0:\n        ctx.exit(0)\n        return\n\n    elif len(sources) == 1:\n        reformat_one(sources[0], line_length, fast, write_back, report)\n    else:\n        loop = asyncio.get_event_loop()\n        executor = ProcessPoolExecutor(max_workers=os.cpu_count())\n        try:\n            loop.run_until_complete(\n                schedule_formatting(\n                    sources, line_length, fast, write_back, report, loop, executor\n                )\n            )\n        finally:\n            shutdown(loop)\n        if not quiet:\n            out(\"All done! \u2728 \ud83c\udf70 \u2728\")\n            click.echo(str(report))\n    ctx.exit(report.return_code)",
        "begin_line": 165,
        "end_line": 215,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0008880994671403197,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.reformat_one#218",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.reformat_one(src: Path, line_length: int, fast: bool, write_back: WriteBack, report: 'Report')",
        "snippet": "def reformat_one(\n    src: Path, line_length: int, fast: bool, write_back: WriteBack, report: \"Report\"\n) -> None:\n    \"\"\"Reformat a single file under `src` without spawning child processes.\n\n    If `quiet` is True, non-error messages are not output. `line_length`,\n    `write_back`, and `fast` options are passed to :func:`format_file_in_place`.\n    \"\"\"\n    try:\n        changed = Changed.NO\n        if not src.is_file() and str(src) == \"-\":\n            if format_stdin_to_stdout(\n                line_length=line_length, fast=fast, write_back=write_back\n            ):\n                changed = Changed.YES\n        else:\n            cache: Cache = {}\n            if write_back != WriteBack.DIFF:\n                cache = read_cache()\n                src = src.resolve()\n                if src in cache and cache[src] == get_cache_info(src):\n                    changed = Changed.CACHED\n            if (\n                changed is not Changed.CACHED\n                and format_file_in_place(\n                    src, line_length=line_length, fast=fast, write_back=write_back\n                )\n            ):\n                changed = Changed.YES\n            if write_back != WriteBack.DIFF and changed is not Changed.NO:\n                write_cache(cache, [src])\n        report.done(src, changed)\n    except Exception as exc:\n        report.failed(src, str(exc))",
        "begin_line": 218,
        "end_line": 251,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0008880994671403197,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.schedule_formatting#254",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.schedule_formatting(sources: List[Path], line_length: int, fast: bool, write_back: WriteBack, report: 'Report', loop: BaseEventLoop, executor: Executor)",
        "snippet": "async def schedule_formatting(\n    sources: List[Path],\n    line_length: int,\n    fast: bool,\n    write_back: WriteBack,\n    report: \"Report\",\n    loop: BaseEventLoop,\n    executor: Executor,\n) -> None:\n    \"\"\"Run formatting of `sources` in parallel using the provided `executor`.\n\n    (Use ProcessPoolExecutors for actual parallelism.)\n\n    `line_length`, `write_back`, and `fast` options are passed to\n    :func:`format_file_in_place`.\n    \"\"\"\n    cache: Cache = {}\n    if write_back != WriteBack.DIFF:\n        cache = read_cache()\n        sources, cached = filter_cached(cache, sources)\n        for src in cached:\n            report.done(src, Changed.CACHED)\n    cancelled = []\n    formatted = []\n    if sources:\n        lock = None\n        if write_back == WriteBack.DIFF:\n            # For diff output, we need locks to ensure we don't interleave output\n            # from different processes.\n            manager = Manager()\n            lock = manager.Lock()\n        tasks = {\n            src: loop.run_in_executor(\n                executor, format_file_in_place, src, line_length, fast, write_back, lock\n            )\n            for src in sources\n        }\n        _task_values = list(tasks.values())\n        try:\n            loop.add_signal_handler(signal.SIGINT, cancel, _task_values)\n            loop.add_signal_handler(signal.SIGTERM, cancel, _task_values)\n        except NotImplementedError:\n            # There are no good alternatives for these on Windows\n            pass\n        await asyncio.wait(_task_values)\n        for src, task in tasks.items():\n            if not task.done():\n                report.failed(src, \"timed out, cancelling\")\n                task.cancel()\n                cancelled.append(task)\n            elif task.cancelled():\n                cancelled.append(task)\n            elif task.exception():\n                report.failed(src, str(task.exception()))\n            else:\n                formatted.append(src)\n                report.done(src, Changed.YES if task.result() else Changed.NO)\n\n    if cancelled:\n        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)\n    if write_back != WriteBack.DIFF and formatted:\n        write_cache(cache, formatted)",
        "begin_line": 254,
        "end_line": 315,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0008880994671403197,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.format_file_in_place#318",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.format_file_in_place(src: Path, line_length: int, fast: bool, write_back: WriteBack=WriteBack.NO, lock: Any=None)",
        "snippet": "def format_file_in_place(\n    src: Path,\n    line_length: int,\n    fast: bool,\n    write_back: WriteBack = WriteBack.NO,\n    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy\n) -> bool:\n    \"\"\"Format file under `src` path. Return True if changed.\n\n    If `write_back` is True, write reformatted code back to stdout.\n    `line_length` and `fast` options are passed to :func:`format_file_contents`.\n    \"\"\"\n\n    with tokenize.open(src) as src_buffer:\n        src_contents = src_buffer.read()\n    try:\n        dst_contents = format_file_contents(\n            src_contents, line_length=line_length, fast=fast\n        )\n    except NothingChanged:\n        return False\n\n    if write_back == write_back.YES:\n        with open(src, \"w\", encoding=src_buffer.encoding) as f:\n            f.write(dst_contents)\n    elif write_back == write_back.DIFF:\n        src_name = f\"{src.name}  (original)\"\n        dst_name = f\"{src.name}  (formatted)\"\n        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)\n        if lock:\n            lock.acquire()\n        try:\n            sys.stdout.write(diff_contents)\n        finally:\n            if lock:\n                lock.release()\n    return True",
        "begin_line": 318,
        "end_line": 354,
        "comment": "",
        "is_bug": true,
        "susp": {
            "pseudo_ochiai_susp": 0.06666666666666667,
            "pseudo_dstar_susp": 0.058823529411764705,
            "pseudo_tarantula_susp": 0.07692307692307693,
            "pseudo_op2_susp": 0.058823529411764705,
            "pseudo_barinel_susp": 0.07692307692307693
        }
    },
    {
        "name": "black.format_stdin_to_stdout#357",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.format_stdin_to_stdout(line_length: int, fast: bool, write_back: WriteBack=WriteBack.NO)",
        "snippet": "def format_stdin_to_stdout(\n    line_length: int, fast: bool, write_back: WriteBack = WriteBack.NO\n) -> bool:\n    \"\"\"Format file on stdin. Return True if changed.\n\n    If `write_back` is True, write reformatted code back to stdout.\n    `line_length` and `fast` arguments are passed to :func:`format_file_contents`.\n    \"\"\"\n    src = sys.stdin.read()\n    dst = src\n    try:\n        dst = format_file_contents(src, line_length=line_length, fast=fast)\n        return True\n\n    except NothingChanged:\n        return False\n\n    finally:\n        if write_back == WriteBack.YES:\n            sys.stdout.write(dst)\n        elif write_back == WriteBack.DIFF:\n            src_name = \"<stdin>  (original)\"\n            dst_name = \"<stdin>  (formatted)\"\n            sys.stdout.write(diff(src, dst, src_name, dst_name))",
        "begin_line": 357,
        "end_line": 380,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0008880994671403197,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.format_file_contents#383",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.format_file_contents(src_contents: str, line_length: int, fast: bool)",
        "snippet": "def format_file_contents(\n    src_contents: str, line_length: int, fast: bool\n) -> FileContent:\n    \"\"\"Reformat contents a file and return new contents.\n\n    If `fast` is False, additionally confirm that the reformatted code is\n    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.\n    `line_length` is passed to :func:`format_str`.\n    \"\"\"\n    if src_contents.strip() == \"\":\n        raise NothingChanged\n\n    dst_contents = format_str(src_contents, line_length=line_length)\n    if src_contents == dst_contents:\n        raise NothingChanged\n\n    if not fast:\n        assert_equivalent(src_contents, dst_contents)\n        assert_stable(src_contents, dst_contents, line_length=line_length)\n    return dst_contents",
        "begin_line": 383,
        "end_line": 402,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00980392156862745,
            "pseudo_dstar_susp": 0.009708737864077669,
            "pseudo_tarantula_susp": 0.009900990099009901,
            "pseudo_op2_susp": 0.009708737864077669,
            "pseudo_barinel_susp": 0.009900990099009901
        }
    },
    {
        "name": "black.format_str#405",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.format_str(src_contents: str, line_length: int)",
        "snippet": "def format_str(src_contents: str, line_length: int) -> FileContent:\n    \"\"\"Reformat a string and return new contents.\n\n    `line_length` determines how many characters per line are allowed.\n    \"\"\"\n    src_node = lib2to3_parse(src_contents)\n    dst_contents = \"\"\n    lines = LineGenerator()\n    elt = EmptyLineTracker()\n    py36 = is_python36(src_node)\n    empty_line = Line()\n    after = 0\n    for current_line in lines.visit(src_node):\n        for _ in range(after):\n            dst_contents += str(empty_line)\n        before, after = elt.maybe_empty_lines(current_line)\n        for _ in range(before):\n            dst_contents += str(empty_line)\n        for line in split_line(current_line, line_length=line_length, py36=py36):\n            dst_contents += str(line)\n    return dst_contents",
        "begin_line": 405,
        "end_line": 425,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00558659217877095,
            "pseudo_dstar_susp": 0.00558659217877095,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.00558659217877095,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "black.lib2to3_parse#436",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.lib2to3_parse(src_txt: str)",
        "snippet": "def lib2to3_parse(src_txt: str) -> Node:\n    \"\"\"Given a string with source, return the lib2to3 Node.\"\"\"\n    grammar = pygram.python_grammar_no_print_statement\n    if src_txt[-1] != \"\\n\":\n        nl = \"\\r\\n\" if \"\\r\\n\" in src_txt[:1024] else \"\\n\"\n        src_txt += nl\n    for grammar in GRAMMARS:\n        drv = driver.Driver(grammar, pytree.convert)\n        try:\n            result = drv.parse_string(src_txt, True)\n            break\n\n        except ParseError as pe:\n            lineno, column = pe.context[1]\n            lines = src_txt.splitlines()\n            try:\n                faulty_line = lines[lineno - 1]\n            except IndexError:\n                faulty_line = \"<line number missing in source>\"\n            exc = ValueError(f\"Cannot parse: {lineno}:{column}: {faulty_line}\")\n    else:\n        raise exc from None\n\n    if isinstance(result, Leaf):\n        result = Node(syms.file_input, [result])\n    return result",
        "begin_line": 436,
        "end_line": 461,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009891196834817012,
            "pseudo_dstar_susp": 0.0009891196834817012,
            "pseudo_tarantula_susp": 0.0009891196834817012,
            "pseudo_op2_susp": 0.0009891196834817012,
            "pseudo_barinel_susp": 0.0009891196834817012
        }
    },
    {
        "name": "black.Visitor.visit#476",
        "src_path": "black.py",
        "class_name": "black.Visitor",
        "signature": "black.Visitor.visit(self, node: LN)",
        "snippet": "    def visit(self, node: LN) -> Iterator[T]:\n        \"\"\"Main method to visit `node` and its children.\n\n        It tries to find a `visit_*()` method for the given `node.type`, like\n        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.\n        If no dedicated `visit_*()` method is found, chooses `visit_default()`\n        instead.\n\n        Then yields objects of type `T` from the selected visitor.\n        \"\"\"\n        if node.type < 256:\n            name = token.tok_name[node.type]\n        else:\n            name = type_repr(node.type)\n        yield from getattr(self, f\"visit_{name}\", self.visit_default)(node)",
        "begin_line": 476,
        "end_line": 490,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011389521640091116,
            "pseudo_dstar_susp": 0.0011389521640091116,
            "pseudo_tarantula_susp": 0.0011389521640091116,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0011389521640091116
        }
    },
    {
        "name": "black.Visitor.visit_default#492",
        "src_path": "black.py",
        "class_name": "black.Visitor",
        "signature": "black.Visitor.visit_default(self, node: LN)",
        "snippet": "    def visit_default(self, node: LN) -> Iterator[T]:\n        \"\"\"Default `visit_*()` implementation. Recurses to children of `node`.\"\"\"\n        if isinstance(node, Node):\n            for child in node.children:\n                yield from self.visit(child)",
        "begin_line": 492,
        "end_line": 496,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013458950201884253,
            "pseudo_dstar_susp": 0.0013458950201884253,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0013458950201884253,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "black.DebugVisitor.visit_default#503",
        "src_path": "black.py",
        "class_name": "black.DebugVisitor",
        "signature": "black.DebugVisitor.visit_default(self, node: LN)",
        "snippet": "    def visit_default(self, node: LN) -> Iterator[T]:\n        indent = \" \" * (2 * self.tree_depth)\n        if isinstance(node, Node):\n            _type = type_repr(node.type)\n            out(f\"{indent}{_type}\", fg=\"yellow\")\n            self.tree_depth += 1\n            for child in node.children:\n                yield from self.visit(child)\n\n            self.tree_depth -= 1\n            out(f\"{indent}/{_type}\", fg=\"yellow\", bold=False)\n        else:\n            _type = token.tok_name.get(node.type, str(node.type))\n            out(f\"{indent}{_type}\", fg=\"blue\", nl=False)\n            if node.prefix:\n                # We don't have to handle prefixes for `Node` objects since\n                # that delegates to the first child anyway.\n                out(f\" {node.prefix!r}\", fg=\"green\", bold=False, nl=False)\n            out(f\" {node.value!r}\", fg=\"blue\", bold=False)",
        "begin_line": 503,
        "end_line": 521,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0008298755186721991,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.DebugVisitor.show#524",
        "src_path": "black.py",
        "class_name": "black.DebugVisitor",
        "signature": "black.DebugVisitor.show(cls, code: str)",
        "snippet": "    def show(cls, code: str) -> None:\n        \"\"\"Pretty-print the lib2to3 AST of a given string of `code`.\n\n        Convenience method for debugging.\n        \"\"\"\n        v: DebugVisitor[None] = DebugVisitor()\n        list(v.visit(lib2to3_parse(code)))",
        "begin_line": 524,
        "end_line": 530,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0008880994671403197,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.BracketTracker.mark#604",
        "src_path": "black.py",
        "class_name": "black.BracketTracker",
        "signature": "black.BracketTracker.mark(self, leaf: Leaf)",
        "snippet": "    def mark(self, leaf: Leaf) -> None:\n        \"\"\"Mark `leaf` with bracket-related metadata. Keep track of delimiters.\n\n        All leaves receive an int `bracket_depth` field that stores how deep\n        within brackets a given leaf is. 0 means there are no enclosing brackets\n        that started on this line.\n\n        If a leaf is itself a closing bracket, it receives an `opening_bracket`\n        field that it forms a pair with. This is a one-directional link to\n        avoid reference cycles.\n\n        If a leaf is a delimiter (a token on which Black can split the line if\n        needed) and it's on depth 0, its `id()` is stored in the tracker's\n        `delimiters` field.\n        \"\"\"\n        if leaf.type == token.COMMENT:\n            return\n\n        self.maybe_decrement_after_for_loop_variable(leaf)\n        self.maybe_decrement_after_lambda_arguments(leaf)\n        if leaf.type in CLOSING_BRACKETS:\n            self.depth -= 1\n            opening_bracket = self.bracket_match.pop((self.depth, leaf.type))\n            leaf.opening_bracket = opening_bracket\n        leaf.bracket_depth = self.depth\n        if self.depth == 0:\n            delim = is_split_before_delimiter(leaf, self.previous)\n            if delim and self.previous is not None:\n                self.delimiters[id(self.previous)] = delim\n            else:\n                delim = is_split_after_delimiter(leaf, self.previous)\n                if delim:\n                    self.delimiters[id(leaf)] = delim\n        if leaf.type in OPENING_BRACKETS:\n            self.bracket_match[self.depth, BRACKET[leaf.type]] = leaf\n            self.depth += 1\n        self.previous = leaf\n        self.maybe_increment_lambda_arguments(leaf)\n        self.maybe_increment_for_loop_variable(leaf)",
        "begin_line": 604,
        "end_line": 642,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029850746268656717,
            "pseudo_dstar_susp": 0.0029850746268656717,
            "pseudo_tarantula_susp": 0.0029940119760479044,
            "pseudo_op2_susp": 0.0029850746268656717,
            "pseudo_barinel_susp": 0.0029940119760479044
        }
    },
    {
        "name": "black.BracketTracker.any_open_brackets#644",
        "src_path": "black.py",
        "class_name": "black.BracketTracker",
        "signature": "black.BracketTracker.any_open_brackets(self)",
        "snippet": "    def any_open_brackets(self) -> bool:\n        \"\"\"Return True if there is an yet unmatched open bracket on the line.\"\"\"\n        return bool(self.bracket_match)",
        "begin_line": 644,
        "end_line": 646,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013458950201884253,
            "pseudo_dstar_susp": 0.0013458950201884253,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0013458950201884253,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "black.BracketTracker.max_delimiter_priority#648",
        "src_path": "black.py",
        "class_name": "black.BracketTracker",
        "signature": "black.BracketTracker.max_delimiter_priority(self, exclude: Iterable[LeafID]=())",
        "snippet": "    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> int:\n        \"\"\"Return the highest priority of a delimiter found on the line.\n\n        Values are consistent with what `is_split_*_delimiter()` return.\n        Raises ValueError on no delimiters.\n        \"\"\"\n        return max(v for k, v in self.delimiters.items() if k not in exclude)",
        "begin_line": 648,
        "end_line": 654,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00980392156862745,
            "pseudo_dstar_susp": 0.3333333333333333,
            "pseudo_tarantula_susp": 0.0029940119760479044,
            "pseudo_op2_susp": 0.3333333333333333,
            "pseudo_barinel_susp": 0.0029940119760479044
        }
    },
    {
        "name": "black.BracketTracker.maybe_increment_for_loop_variable#656",
        "src_path": "black.py",
        "class_name": "black.BracketTracker",
        "signature": "black.BracketTracker.maybe_increment_for_loop_variable(self, leaf: Leaf)",
        "snippet": "    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:\n        \"\"\"In a for loop, or comprehension, the variables are often unpacks.\n\n        To avoid splitting on the comma in this situation, increase the depth of\n        tokens between `for` and `in`.\n        \"\"\"\n        if leaf.type == token.NAME and leaf.value == \"for\":\n            self.depth += 1\n            self._for_loop_variable = True\n            return True\n\n        return False",
        "begin_line": 656,
        "end_line": 667,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00558659217877095,
            "pseudo_dstar_susp": 0.00558659217877095,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.00558659217877095,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "black.BracketTracker.maybe_decrement_after_for_loop_variable#669",
        "src_path": "black.py",
        "class_name": "black.BracketTracker",
        "signature": "black.BracketTracker.maybe_decrement_after_for_loop_variable(self, leaf: Leaf)",
        "snippet": "    def maybe_decrement_after_for_loop_variable(self, leaf: Leaf) -> bool:\n        \"\"\"See `maybe_increment_for_loop_variable` above for explanation.\"\"\"\n        if self._for_loop_variable and leaf.type == token.NAME and leaf.value == \"in\":\n            self.depth -= 1\n            self._for_loop_variable = False\n            return True\n\n        return False",
        "begin_line": 669,
        "end_line": 676,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00558659217877095,
            "pseudo_dstar_susp": 0.00558659217877095,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.00558659217877095,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "black.BracketTracker.maybe_increment_lambda_arguments#678",
        "src_path": "black.py",
        "class_name": "black.BracketTracker",
        "signature": "black.BracketTracker.maybe_increment_lambda_arguments(self, leaf: Leaf)",
        "snippet": "    def maybe_increment_lambda_arguments(self, leaf: Leaf) -> bool:\n        \"\"\"In a lambda expression, there might be more than one argument.\n\n        To avoid splitting on the comma in this situation, increase the depth of\n        tokens between `lambda` and `:`.\n        \"\"\"\n        if leaf.type == token.NAME and leaf.value == \"lambda\":\n            self.depth += 1\n            self._lambda_arguments = True\n            return True\n\n        return False",
        "begin_line": 678,
        "end_line": 689,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.018518518518518517,
            "pseudo_dstar_susp": 0.017857142857142856,
            "pseudo_tarantula_susp": 0.018518518518518517,
            "pseudo_op2_susp": 0.017857142857142856,
            "pseudo_barinel_susp": 0.018518518518518517
        }
    },
    {
        "name": "black.BracketTracker.maybe_decrement_after_lambda_arguments#691",
        "src_path": "black.py",
        "class_name": "black.BracketTracker",
        "signature": "black.BracketTracker.maybe_decrement_after_lambda_arguments(self, leaf: Leaf)",
        "snippet": "    def maybe_decrement_after_lambda_arguments(self, leaf: Leaf) -> bool:\n        \"\"\"See `maybe_increment_lambda_arguments` above for explanation.\"\"\"\n        if self._lambda_arguments and leaf.type == token.COLON:\n            self.depth -= 1\n            self._lambda_arguments = False\n            return True\n\n        return False",
        "begin_line": 691,
        "end_line": 698,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.018518518518518517,
            "pseudo_dstar_susp": 0.017857142857142856,
            "pseudo_tarantula_susp": 0.018518518518518517,
            "pseudo_op2_susp": 0.017857142857142856,
            "pseudo_barinel_susp": 0.018518518518518517
        }
    },
    {
        "name": "black.Line.append#711",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.append(self, leaf: Leaf, preformatted: bool=False)",
        "snippet": "    def append(self, leaf: Leaf, preformatted: bool = False) -> None:\n        \"\"\"Add a new `leaf` to the end of the line.\n\n        Unless `preformatted` is True, the `leaf` will receive a new consistent\n        whitespace prefix and metadata applied by :class:`BracketTracker`.\n        Trailing commas are maybe removed, unpacked for loop variables are\n        demoted from being delimiters.\n\n        Inline comments are put aside.\n        \"\"\"\n        has_value = leaf.type in BRACKETS or bool(leaf.value.strip())\n        if not has_value:\n            return\n\n        if self.leaves and not preformatted:\n            # Note: at this point leaf.prefix should be empty except for\n            # imports, for which we only preserve newlines.\n            leaf.prefix += whitespace(leaf)\n        if self.inside_brackets or not preformatted:\n            self.bracket_tracker.mark(leaf)\n            self.maybe_remove_trailing_comma(leaf)\n\n        if not self.append_comment(leaf):\n            self.leaves.append(leaf)",
        "begin_line": 711,
        "end_line": 734,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001658374792703151,
            "pseudo_dstar_susp": 0.001658374792703151,
            "pseudo_tarantula_susp": 0.001658374792703151,
            "pseudo_op2_susp": 0.001658374792703151,
            "pseudo_barinel_susp": 0.001658374792703151
        }
    },
    {
        "name": "black.Line.append_safe#736",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.append_safe(self, leaf: Leaf, preformatted: bool=False)",
        "snippet": "    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:\n        \"\"\"Like :func:`append()` but disallow invalid standalone comment structure.\n\n        Raises ValueError when any `leaf` is appended after a standalone comment\n        or when a standalone comment is not the first leaf on the line.\n        \"\"\"\n        if self.bracket_tracker.depth == 0:\n            if self.is_comment:\n                raise ValueError(\"cannot append to standalone comments\")\n\n            if self.leaves and leaf.type == STANDALONE_COMMENT:\n                raise ValueError(\n                    \"cannot append standalone comments to a populated line\"\n                )\n\n        self.append(leaf, preformatted=preformatted)",
        "begin_line": 736,
        "end_line": 751,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029850746268656717,
            "pseudo_dstar_susp": 0.0029850746268656717,
            "pseudo_tarantula_susp": 0.0029940119760479044,
            "pseudo_op2_susp": 0.0029850746268656717,
            "pseudo_barinel_susp": 0.0029940119760479044
        }
    },
    {
        "name": "black.Line.is_comment#754",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.is_comment(self)",
        "snippet": "    def is_comment(self) -> bool:\n        \"\"\"Is this line a standalone comment?\"\"\"\n        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT",
        "begin_line": 754,
        "end_line": 756,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013458950201884253,
            "pseudo_dstar_susp": 0.0013458950201884253,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0013458950201884253,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "black.Line.is_decorator#759",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.is_decorator(self)",
        "snippet": "    def is_decorator(self) -> bool:\n        \"\"\"Is this line a decorator?\"\"\"\n        return bool(self) and self.leaves[0].type == token.AT",
        "begin_line": 759,
        "end_line": 761,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013458950201884253,
            "pseudo_dstar_susp": 0.0013458950201884253,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0013458950201884253,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "black.Line.is_import#764",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.is_import(self)",
        "snippet": "    def is_import(self) -> bool:\n        \"\"\"Is this an import line?\"\"\"\n        return bool(self) and is_import(self.leaves[0])",
        "begin_line": 764,
        "end_line": 766,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0019305019305019305,
            "pseudo_dstar_susp": 0.0019305019305019305,
            "pseudo_tarantula_susp": 0.0019305019305019305,
            "pseudo_op2_susp": 0.0019305019305019305,
            "pseudo_barinel_susp": 0.0019305019305019305
        }
    },
    {
        "name": "black.Line.is_class#769",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.is_class(self)",
        "snippet": "    def is_class(self) -> bool:\n        \"\"\"Is this line a class definition?\"\"\"\n        return (\n            bool(self)\n            and self.leaves[0].type == token.NAME\n            and self.leaves[0].value == \"class\"\n        )",
        "begin_line": 769,
        "end_line": 775,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001658374792703151,
            "pseudo_dstar_susp": 0.001658374792703151,
            "pseudo_tarantula_susp": 0.001658374792703151,
            "pseudo_op2_susp": 0.001658374792703151,
            "pseudo_barinel_susp": 0.001658374792703151
        }
    },
    {
        "name": "black.Line.is_def#778",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.is_def(self)",
        "snippet": "    def is_def(self) -> bool:\n        \"\"\"Is this a function definition? (Also returns True for async defs.)\"\"\"\n        try:\n            first_leaf = self.leaves[0]\n        except IndexError:\n            return False\n\n        try:\n            second_leaf: Optional[Leaf] = self.leaves[1]\n        except IndexError:\n            second_leaf = None\n        return (\n            (first_leaf.type == token.NAME and first_leaf.value == \"def\")\n            or (\n                first_leaf.type == token.ASYNC\n                and second_leaf is not None\n                and second_leaf.type == token.NAME\n                and second_leaf.value == \"def\"\n            )\n        )",
        "begin_line": 778,
        "end_line": 797,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012048192771084338,
            "pseudo_dstar_susp": 0.011764705882352941,
            "pseudo_tarantula_susp": 0.012048192771084338,
            "pseudo_op2_susp": 0.011764705882352941,
            "pseudo_barinel_susp": 0.012048192771084338
        }
    },
    {
        "name": "black.Line.is_flow_control#800",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.is_flow_control(self)",
        "snippet": "    def is_flow_control(self) -> bool:\n        \"\"\"Is this line a flow control statement?\n\n        Those are `return`, `raise`, `break`, and `continue`.\n        \"\"\"\n        return (\n            bool(self)\n            and self.leaves[0].type == token.NAME\n            and self.leaves[0].value in FLOW_CONTROL\n        )",
        "begin_line": 800,
        "end_line": 809,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001658374792703151,
            "pseudo_dstar_susp": 0.001658374792703151,
            "pseudo_tarantula_susp": 0.001658374792703151,
            "pseudo_op2_susp": 0.001658374792703151,
            "pseudo_barinel_susp": 0.001658374792703151
        }
    },
    {
        "name": "black.Line.is_yield#812",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.is_yield(self)",
        "snippet": "    def is_yield(self) -> bool:\n        \"\"\"Is this line a yield statement?\"\"\"\n        return (\n            bool(self)\n            and self.leaves[0].type == token.NAME\n            and self.leaves[0].value == \"yield\"\n        )",
        "begin_line": 812,
        "end_line": 818,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002004008016032064,
            "pseudo_dstar_susp": 0.002004008016032064,
            "pseudo_tarantula_susp": 0.002004008016032064,
            "pseudo_op2_susp": 0.002004008016032064,
            "pseudo_barinel_susp": 0.002004008016032064
        }
    },
    {
        "name": "black.Line.contains_standalone_comments#820",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.contains_standalone_comments(self, depth_limit: int=sys.maxsize)",
        "snippet": "    def contains_standalone_comments(self, depth_limit: int = sys.maxsize) -> bool:\n        \"\"\"If so, needs to be split before emitting.\"\"\"\n        for leaf in self.leaves:\n            if leaf.type == STANDALONE_COMMENT:\n                if leaf.bracket_depth <= depth_limit:\n                    return True\n\n        return False",
        "begin_line": 820,
        "end_line": 827,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013458950201884253,
            "pseudo_dstar_susp": 0.0013458950201884253,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0013458950201884253,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "black.Line.maybe_remove_trailing_comma#829",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.maybe_remove_trailing_comma(self, closing: Leaf)",
        "snippet": "    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:\n        \"\"\"Remove trailing comma if there is one and it's safe.\"\"\"\n        if not (\n            self.leaves\n            and self.leaves[-1].type == token.COMMA\n            and closing.type in CLOSING_BRACKETS\n        ):\n            return False\n\n        if closing.type == token.RBRACE:\n            self.remove_trailing_comma()\n            return True\n\n        if closing.type == token.RSQB:\n            comma = self.leaves[-1]\n            if comma.parent and comma.parent.type == syms.listmaker:\n                self.remove_trailing_comma()\n                return True\n\n        # For parens let's check if it's safe to remove the comma.  If the\n        # trailing one is the only one, we might mistakenly change a tuple\n        # into a different type by removing the comma.\n        depth = closing.bracket_depth + 1\n        commas = 0\n        opening = closing.opening_bracket\n        for _opening_index, leaf in enumerate(self.leaves):\n            if leaf is opening:\n                break\n\n        else:\n            return False\n\n        for leaf in self.leaves[_opening_index + 1:]:\n            if leaf is closing:\n                break\n\n            bracket_depth = leaf.bracket_depth\n            if bracket_depth == depth and leaf.type == token.COMMA:\n                commas += 1\n                if leaf.parent and leaf.parent.type == syms.arglist:\n                    commas += 1\n                    break\n\n        if commas > 1:\n            self.remove_trailing_comma()\n            return True\n\n        return False",
        "begin_line": 829,
        "end_line": 876,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.018518518518518517,
            "pseudo_dstar_susp": 0.017857142857142856,
            "pseudo_tarantula_susp": 0.018518518518518517,
            "pseudo_op2_susp": 0.017857142857142856,
            "pseudo_barinel_susp": 0.018518518518518517
        }
    },
    {
        "name": "black.Line.append_comment#878",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.append_comment(self, comment: Leaf)",
        "snippet": "    def append_comment(self, comment: Leaf) -> bool:\n        \"\"\"Add an inline or standalone comment to the line.\"\"\"\n        if (\n            comment.type == STANDALONE_COMMENT\n            and self.bracket_tracker.any_open_brackets()\n        ):\n            comment.prefix = \"\"\n            return False\n\n        if comment.type != token.COMMENT:\n            return False\n\n        after = len(self.leaves) - 1\n        if after == -1:\n            comment.type = STANDALONE_COMMENT\n            comment.prefix = \"\"\n            return False\n\n        else:\n            self.comments.append((after, comment))\n            return True",
        "begin_line": 878,
        "end_line": 898,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004784688995215311,
            "pseudo_dstar_susp": 0.004784688995215311,
            "pseudo_tarantula_susp": 0.004830917874396135,
            "pseudo_op2_susp": 0.004784688995215311,
            "pseudo_barinel_susp": 0.004830917874396135
        }
    },
    {
        "name": "black.Line.comments_after#900",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.comments_after(self, leaf: Leaf)",
        "snippet": "    def comments_after(self, leaf: Leaf) -> Iterator[Leaf]:\n        \"\"\"Generate comments that should appear directly after `leaf`.\"\"\"\n        for _leaf_index, _leaf in enumerate(self.leaves):\n            if leaf is _leaf:\n                break\n\n        else:\n            return\n\n        for index, comment_after in self.comments:\n            if _leaf_index == index:\n                yield comment_after",
        "begin_line": 900,
        "end_line": 911,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012048192771084338,
            "pseudo_dstar_susp": 0.011764705882352941,
            "pseudo_tarantula_susp": 0.012048192771084338,
            "pseudo_op2_susp": 0.011764705882352941,
            "pseudo_barinel_susp": 0.012048192771084338
        }
    },
    {
        "name": "black.Line.remove_trailing_comma#913",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.remove_trailing_comma(self)",
        "snippet": "    def remove_trailing_comma(self) -> None:\n        \"\"\"Remove the trailing comma and moves the comments attached to it.\"\"\"\n        comma_index = len(self.leaves) - 1\n        for i in range(len(self.comments)):\n            comment_index, comment = self.comments[i]\n            if comment_index == comma_index:\n                self.comments[i] = (comma_index - 1, comment)\n        self.leaves.pop()",
        "begin_line": 913,
        "end_line": 920,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029850746268656717,
            "pseudo_dstar_susp": 0.0029850746268656717,
            "pseudo_tarantula_susp": 0.0029940119760479044,
            "pseudo_op2_susp": 0.0029850746268656717,
            "pseudo_barinel_susp": 0.0029940119760479044
        }
    },
    {
        "name": "black.Line.__str__#922",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.__str__(self)",
        "snippet": "    def __str__(self) -> str:\n        \"\"\"Render the line.\"\"\"\n        if not self:\n            return \"\\n\"\n\n        indent = \"    \" * self.depth\n        leaves = iter(self.leaves)\n        first = next(leaves)\n        res = f\"{first.prefix}{indent}{first.value}\"\n        for leaf in leaves:\n            res += str(leaf)\n        for _, comment in self.comments:\n            res += str(comment)\n        return res + \"\\n\"",
        "begin_line": 922,
        "end_line": 935,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004784688995215311,
            "pseudo_dstar_susp": 0.004784688995215311,
            "pseudo_tarantula_susp": 0.004830917874396135,
            "pseudo_op2_susp": 0.004784688995215311,
            "pseudo_barinel_susp": 0.004830917874396135
        }
    },
    {
        "name": "black.Line.__bool__#937",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.__bool__(self)",
        "snippet": "    def __bool__(self) -> bool:\n        \"\"\"Return True if the line has leaves or comments.\"\"\"\n        return bool(self.leaves or self.comments)",
        "begin_line": 937,
        "end_line": 939,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013458950201884253,
            "pseudo_dstar_susp": 0.0013458950201884253,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0013458950201884253,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "black.UnformattedLines.append#945",
        "src_path": "black.py",
        "class_name": "black.UnformattedLines",
        "signature": "black.UnformattedLines.append(self, leaf: Leaf, preformatted: bool=True)",
        "snippet": "    def append(self, leaf: Leaf, preformatted: bool = True) -> None:\n        \"\"\"Just add a new `leaf` to the end of the lines.\n\n        The `preformatted` argument is ignored.\n\n        Keeps track of indentation `depth`, which is useful when the user\n        says `# fmt: on`. Otherwise, doesn't do anything with the `leaf`.\n        \"\"\"\n        try:\n            list(generate_comments(leaf))\n        except FormatOn as f_on:\n            self.leaves.append(f_on.leaf_from_consumed(leaf))\n            raise\n\n        self.leaves.append(leaf)\n        if leaf.type == token.INDENT:\n            self.depth += 1\n        elif leaf.type == token.DEDENT:\n            self.depth -= 1",
        "begin_line": 945,
        "end_line": 963,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0008880994671403197,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.UnformattedLines.__str__#965",
        "src_path": "black.py",
        "class_name": "black.UnformattedLines",
        "signature": "black.UnformattedLines.__str__(self)",
        "snippet": "    def __str__(self) -> str:\n        \"\"\"Render unformatted lines from leaves which were added with `append()`.\n\n        `depth` is not used for indentation in this case.\n        \"\"\"\n        if not self:\n            return \"\\n\"\n\n        res = \"\"\n        for leaf in self.leaves:\n            res += str(leaf)\n        return res",
        "begin_line": 965,
        "end_line": 976,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0008880994671403197,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.EmptyLineTracker.maybe_empty_lines#1004",
        "src_path": "black.py",
        "class_name": "black.EmptyLineTracker",
        "signature": "black.EmptyLineTracker.maybe_empty_lines(self, current_line: Line)",
        "snippet": "    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n        \"\"\"Return the number of extra empty lines before and after the `current_line`.\n\n        This is for separating `def`, `async def` and `class` with extra empty\n        lines (two on module-level), as well as providing an extra empty line\n        after flow control keywords to make them more prominent.\n        \"\"\"\n        if isinstance(current_line, UnformattedLines):\n            return 0, 0\n\n        before, after = self._maybe_empty_lines(current_line)\n        before -= self.previous_after\n        self.previous_after = after\n        self.previous_line = current_line\n        return before, after",
        "begin_line": 1004,
        "end_line": 1018,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013458950201884253,
            "pseudo_dstar_susp": 0.0013458950201884253,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0013458950201884253,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "black.EmptyLineTracker._maybe_empty_lines#1020",
        "src_path": "black.py",
        "class_name": "black.EmptyLineTracker",
        "signature": "black.EmptyLineTracker._maybe_empty_lines(self, current_line: Line)",
        "snippet": "    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n        max_allowed = 1\n        if current_line.depth == 0:\n            max_allowed = 2\n        if current_line.leaves:\n            # Consume the first leaf's extra newlines.\n            first_leaf = current_line.leaves[0]\n            before = first_leaf.prefix.count(\"\\n\")\n            before = min(before, max_allowed)\n            first_leaf.prefix = \"\"\n        else:\n            before = 0\n        depth = current_line.depth\n        while self.previous_defs and self.previous_defs[-1] >= depth:\n            self.previous_defs.pop()\n            before = 1 if depth else 2\n        is_decorator = current_line.is_decorator\n        if is_decorator or current_line.is_def or current_line.is_class:\n            if not is_decorator:\n                self.previous_defs.append(depth)\n            if self.previous_line is None:\n                # Don't insert empty lines before the first line in the file.\n                return 0, 0\n\n            if self.previous_line and self.previous_line.is_decorator:\n                # Don't insert empty lines between decorators.\n                return 0, 0\n\n            newlines = 2\n            if current_line.depth:\n                newlines -= 1\n            return newlines, 0\n\n        if current_line.is_flow_control:\n            return before, 1\n\n        if (\n            self.previous_line\n            and self.previous_line.is_import\n            and not current_line.is_import\n            and depth == self.previous_line.depth\n        ):\n            return (before or 1), 0\n\n        if (\n            self.previous_line\n            and self.previous_line.is_yield\n            and (not current_line.is_yield or depth != self.previous_line.depth)\n        ):\n            return (before or 1), 0\n\n        return before, 0",
        "begin_line": 1020,
        "end_line": 1071,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.014285714285714285,
            "pseudo_dstar_susp": 0.013888888888888888,
            "pseudo_tarantula_susp": 0.014285714285714285,
            "pseudo_op2_susp": 0.013888888888888888,
            "pseudo_barinel_susp": 0.014285714285714285
        }
    },
    {
        "name": "black.LineGenerator.line#1083",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.line(self, indent: int=0, type: Type[Line]=Line)",
        "snippet": "    def line(self, indent: int = 0, type: Type[Line] = Line) -> Iterator[Line]:\n        \"\"\"Generate a line.\n\n        If the line is empty, only emit if it makes sense.\n        If the line is too long, split it first and then generate.\n\n        If any lines were generated, set up a new current_line.\n        \"\"\"\n        if not self.current_line:\n            if self.current_line.__class__ == type:\n                self.current_line.depth += indent\n            else:\n                self.current_line = type(depth=self.current_line.depth + indent)\n            return  # Line is empty, don't emit. Creating a new one unnecessary.\n\n        complete_line = self.current_line\n        self.current_line = type(depth=complete_line.depth + indent)\n        yield complete_line",
        "begin_line": 1083,
        "end_line": 1100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013458950201884253,
            "pseudo_dstar_susp": 0.0013458950201884253,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0013458950201884253,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "black.LineGenerator.visit#1102",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit(self, node: LN)",
        "snippet": "    def visit(self, node: LN) -> Iterator[Line]:\n        \"\"\"Main method to visit `node` and its children.\n\n        Yields :class:`Line` objects.\n        \"\"\"\n        if isinstance(self.current_line, UnformattedLines):\n            # File contained `# fmt: off`\n            yield from self.visit_unformatted(node)\n\n        else:\n            yield from super().visit(node)",
        "begin_line": 1102,
        "end_line": 1112,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013458950201884253,
            "pseudo_dstar_susp": 0.0013458950201884253,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0013458950201884253,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "black.LineGenerator.visit_default#1114",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_default(self, node: LN)",
        "snippet": "    def visit_default(self, node: LN) -> Iterator[Line]:\n        \"\"\"Default `visit_*()` implementation. Recurses to children of `node`.\"\"\"\n        if isinstance(node, Leaf):\n            any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()\n            try:\n                for comment in generate_comments(node):\n                    if any_open_brackets:\n                        # any comment within brackets is subject to splitting\n                        self.current_line.append(comment)\n                    elif comment.type == token.COMMENT:\n                        # regular trailing comment\n                        self.current_line.append(comment)\n                        yield from self.line()\n\n                    else:\n                        # regular standalone comment\n                        yield from self.line()\n\n                        self.current_line.append(comment)\n                        yield from self.line()\n\n            except FormatOff as f_off:\n                f_off.trim_prefix(node)\n                yield from self.line(type=UnformattedLines)\n                yield from self.visit(node)\n\n            except FormatOn as f_on:\n                # This only happens here if somebody says \"fmt: on\" multiple\n                # times in a row.\n                f_on.trim_prefix(node)\n                yield from self.visit_default(node)\n\n            else:\n                normalize_prefix(node, inside_brackets=any_open_brackets)\n                if node.type == token.STRING:\n                    normalize_string_quotes(node)\n                if node.type not in WHITESPACE:\n                    self.current_line.append(node)\n        yield from super().visit_default(node)",
        "begin_line": 1114,
        "end_line": 1152,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005128205128205128,
            "pseudo_dstar_susp": 0.005128205128205128,
            "pseudo_tarantula_susp": 0.0051813471502590676,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0051813471502590676
        }
    },
    {
        "name": "black.LineGenerator.visit_INDENT#1154",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_INDENT(self, node: Node)",
        "snippet": "    def visit_INDENT(self, node: Node) -> Iterator[Line]:\n        \"\"\"Increase indentation level, maybe yield a line.\"\"\"\n        # In blib2to3 INDENT never holds comments.\n        yield from self.line(+1)\n        yield from self.visit_default(node)",
        "begin_line": 1154,
        "end_line": 1158,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029850746268656717,
            "pseudo_dstar_susp": 0.0029850746268656717,
            "pseudo_tarantula_susp": 0.0029940119760479044,
            "pseudo_op2_susp": 0.0029850746268656717,
            "pseudo_barinel_susp": 0.0029940119760479044
        }
    },
    {
        "name": "black.LineGenerator.visit_DEDENT#1160",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_DEDENT(self, node: Node)",
        "snippet": "    def visit_DEDENT(self, node: Node) -> Iterator[Line]:\n        \"\"\"Decrease indentation level, maybe yield a line.\"\"\"\n        # DEDENT has no value. Additionally, in blib2to3 it never holds comments.\n        yield from self.line(-1)",
        "begin_line": 1160,
        "end_line": 1163,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029850746268656717,
            "pseudo_dstar_susp": 0.0029850746268656717,
            "pseudo_tarantula_susp": 0.0029940119760479044,
            "pseudo_op2_susp": 0.0029850746268656717,
            "pseudo_barinel_susp": 0.0029940119760479044
        }
    },
    {
        "name": "black.LineGenerator.visit_stmt#1165",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_stmt(self, node: Node, keywords: Set[str], parens: Set[str])",
        "snippet": "    def visit_stmt(\n        self, node: Node, keywords: Set[str], parens: Set[str]\n    ) -> Iterator[Line]:\n        \"\"\"Visit a statement.\n\n        This implementation is shared for `if`, `while`, `for`, `try`, `except`,\n        `def`, `with`, `class`, and `assert`.\n\n        The relevant Python language `keywords` for a given statement will be\n        NAME leaves within it. This methods puts those on a separate line.\n\n        `parens` holds pairs of nodes where invisible parentheses should be put.\n        Keys hold nodes after which opening parentheses should be put, values\n        hold nodes before which closing parentheses should be put.\n        \"\"\"\n        normalize_invisible_parens(node, parens_after=parens)\n        for child in node.children:\n            if child.type == token.NAME and child.value in keywords:  # type: ignore\n                yield from self.line()\n\n            yield from self.visit(child)",
        "begin_line": 1165,
        "end_line": 1185,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029850746268656717,
            "pseudo_dstar_susp": 0.0029850746268656717,
            "pseudo_tarantula_susp": 0.0029940119760479044,
            "pseudo_op2_susp": 0.0029850746268656717,
            "pseudo_barinel_susp": 0.0029940119760479044
        }
    },
    {
        "name": "black.LineGenerator.visit_simple_stmt#1187",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_simple_stmt(self, node: Node)",
        "snippet": "    def visit_simple_stmt(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visit a statement without nested statements.\"\"\"\n        is_suite_like = node.parent and node.parent.type in STATEMENT\n        if is_suite_like:\n            yield from self.line(+1)\n            yield from self.visit_default(node)\n            yield from self.line(-1)\n\n        else:\n            yield from self.line()\n            yield from self.visit_default(node)",
        "begin_line": 1187,
        "end_line": 1197,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.018518518518518517,
            "pseudo_dstar_susp": 0.017857142857142856,
            "pseudo_tarantula_susp": 0.018518518518518517,
            "pseudo_op2_susp": 0.017857142857142856,
            "pseudo_barinel_susp": 0.018518518518518517
        }
    },
    {
        "name": "black.LineGenerator.visit_async_stmt#1199",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_async_stmt(self, node: Node)",
        "snippet": "    def visit_async_stmt(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visit `async def`, `async for`, `async with`.\"\"\"\n        yield from self.line()\n\n        children = iter(node.children)\n        for child in children:\n            yield from self.visit(child)\n\n            if child.type == token.ASYNC:\n                break\n\n        internal_stmt = next(children)\n        for child in internal_stmt.children:\n            yield from self.visit(child)",
        "begin_line": 1199,
        "end_line": 1212,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012048192771084338,
            "pseudo_dstar_susp": 0.011764705882352941,
            "pseudo_tarantula_susp": 0.012048192771084338,
            "pseudo_op2_susp": 0.011764705882352941,
            "pseudo_barinel_susp": 0.012048192771084338
        }
    },
    {
        "name": "black.LineGenerator.visit_decorators#1214",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_decorators(self, node: Node)",
        "snippet": "    def visit_decorators(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visit decorators.\"\"\"\n        for child in node.children:\n            yield from self.line()\n            yield from self.visit(child)",
        "begin_line": 1214,
        "end_line": 1218,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0006954102920723226,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.LineGenerator.visit_import_from#1220",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_import_from(self, node: Node)",
        "snippet": "    def visit_import_from(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visit import_from and maybe put invisible parentheses.\n\n        This is separate from `visit_stmt` because import statements don't\n        support arbitrary atoms and thus handling of parentheses is custom.\n        \"\"\"\n        check_lpar = False\n        for index, child in enumerate(node.children):\n            if check_lpar:\n                if child.type == token.LPAR:\n                    # make parentheses invisible\n                    child.value = \"\"  # type: ignore\n                    node.children[-1].value = \"\"  # type: ignore\n                else:\n                    # insert invisible parentheses\n                    node.insert_child(index, Leaf(token.LPAR, \"\"))\n                    node.append_child(Leaf(token.RPAR, \"\"))\n                break\n\n            check_lpar = (\n                child.type == token.NAME and child.value == \"import\"  # type: ignore\n            )\n\n        for child in node.children:\n            yield from self.visit(child)",
        "begin_line": 1220,
        "end_line": 1244,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0007782101167315176,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.LineGenerator.visit_SEMI#1246",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_SEMI(self, leaf: Leaf)",
        "snippet": "    def visit_SEMI(self, leaf: Leaf) -> Iterator[Line]:\n        \"\"\"Remove a semicolon and put the other statement on a separate line.\"\"\"\n        yield from self.line()",
        "begin_line": 1246,
        "end_line": 1248,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0008880994671403197,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.LineGenerator.visit_ENDMARKER#1250",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_ENDMARKER(self, leaf: Leaf)",
        "snippet": "    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:\n        \"\"\"End of file. Process outstanding comments and end with a newline.\"\"\"\n        yield from self.visit_default(leaf)\n        yield from self.line()",
        "begin_line": 1250,
        "end_line": 1253,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001658374792703151,
            "pseudo_dstar_susp": 0.001658374792703151,
            "pseudo_tarantula_susp": 0.001658374792703151,
            "pseudo_op2_susp": 0.001658374792703151,
            "pseudo_barinel_susp": 0.001658374792703151
        }
    },
    {
        "name": "black.LineGenerator.visit_unformatted#1255",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_unformatted(self, node: LN)",
        "snippet": "    def visit_unformatted(self, node: LN) -> Iterator[Line]:\n        \"\"\"Used when file contained a `# fmt: off`.\"\"\"\n        if isinstance(node, Node):\n            for child in node.children:\n                yield from self.visit(child)\n\n        else:\n            try:\n                self.current_line.append(node)\n            except FormatOn as f_on:\n                f_on.trim_prefix(node)\n                yield from self.line()\n                yield from self.visit(node)\n\n            if node.type == token.ENDMARKER:\n                # somebody decided not to put a final `# fmt: on`\n                yield from self.line()",
        "begin_line": 1255,
        "end_line": 1271,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0008880994671403197,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.LineGenerator.__attrs_post_init__#1273",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.__attrs_post_init__(self)",
        "snippet": "    def __attrs_post_init__(self) -> None:\n        \"\"\"You are in a twisty little maze of passages.\"\"\"\n        v = self.visit_stmt\n        \u00d8: Set[str] = set()\n        self.visit_assert_stmt = partial(v, keywords={\"assert\"}, parens={\"assert\", \",\"})\n        self.visit_if_stmt = partial(v, keywords={\"if\", \"else\", \"elif\"}, parens={\"if\"})\n        self.visit_while_stmt = partial(v, keywords={\"while\", \"else\"}, parens={\"while\"})\n        self.visit_for_stmt = partial(v, keywords={\"for\", \"else\"}, parens={\"for\", \"in\"})\n        self.visit_try_stmt = partial(\n            v, keywords={\"try\", \"except\", \"else\", \"finally\"}, parens=\u00d8\n        )\n        self.visit_except_clause = partial(v, keywords={\"except\"}, parens=\u00d8)\n        self.visit_with_stmt = partial(v, keywords={\"with\"}, parens=\u00d8)\n        self.visit_funcdef = partial(v, keywords={\"def\"}, parens=\u00d8)\n        self.visit_classdef = partial(v, keywords={\"class\"}, parens=\u00d8)\n        self.visit_async_funcdef = self.visit_async_stmt\n        self.visit_decorated = self.visit_decorators",
        "begin_line": 1273,
        "end_line": 1289,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013458950201884253,
            "pseudo_dstar_susp": 0.0013458950201884253,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0013458950201884253,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "black.whitespace#1300",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.whitespace(leaf: Leaf)",
        "snippet": "def whitespace(leaf: Leaf) -> str:  # noqa C901\n    \"\"\"Return whitespace prefix if needed for the given `leaf`.\"\"\"\n    NO = \"\"\n    SPACE = \" \"\n    DOUBLESPACE = \"  \"\n    t = leaf.type\n    p = leaf.parent\n    v = leaf.value\n    if t in ALWAYS_NO_SPACE:\n        return NO\n\n    if t == token.COMMENT:\n        return DOUBLESPACE\n\n    assert p is not None, f\"INTERNAL ERROR: hand-made leaf without parent: {leaf!r}\"\n    if t == token.COLON and p.type not in {syms.subscript, syms.subscriptlist}:\n        return NO\n\n    prev = leaf.prev_sibling\n    if not prev:\n        prevp = preceding_leaf(p)\n        if not prevp or prevp.type in OPENING_BRACKETS:\n            return NO\n\n        if t == token.COLON:\n            return SPACE if prevp.type == token.COMMA else NO\n\n        if prevp.type == token.EQUAL:\n            if prevp.parent:\n                if prevp.parent.type in {\n                    syms.arglist, syms.argument, syms.parameters, syms.varargslist\n                }:\n                    return NO\n\n                elif prevp.parent.type == syms.typedargslist:\n                    # A bit hacky: if the equal sign has whitespace, it means we\n                    # previously found it's a typed argument.  So, we're using\n                    # that, too.\n                    return prevp.prefix\n\n        elif prevp.type in STARS:\n            if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS):\n                return NO\n\n        elif prevp.type == token.COLON:\n            if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}:\n                return NO\n\n        elif (\n            prevp.parent\n            and prevp.parent.type == syms.factor\n            and prevp.type in MATH_OPERATORS\n        ):\n            return NO\n\n        elif (\n            prevp.type == token.RIGHTSHIFT\n            and prevp.parent\n            and prevp.parent.type == syms.shift_expr\n            and prevp.prev_sibling\n            and prevp.prev_sibling.type == token.NAME\n            and prevp.prev_sibling.value == \"print\"  # type: ignore\n        ):\n            # Python 2 print chevron\n            return NO\n\n    elif prev.type in OPENING_BRACKETS:\n        return NO\n\n    if p.type in {syms.parameters, syms.arglist}:\n        # untyped function signatures or calls\n        if not prev or prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.varargslist:\n        # lambdas\n        if prev and prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.typedargslist:\n        # typed function signatures\n        if not prev:\n            return NO\n\n        if t == token.EQUAL:\n            if prev.type != syms.tname:\n                return NO\n\n        elif prev.type == token.EQUAL:\n            # A bit hacky: if the equal sign has whitespace, it means we\n            # previously found it's a typed argument.  So, we're using that, too.\n            return prev.prefix\n\n        elif prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.tname:\n        # type names\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type != token.COMMA:\n                return NO\n\n    elif p.type == syms.trailer:\n        # attributes and calls\n        if t == token.LPAR or t == token.RPAR:\n            return NO\n\n        if not prev:\n            if t == token.DOT:\n                prevp = preceding_leaf(p)\n                if not prevp or prevp.type != token.NUMBER:\n                    return NO\n\n            elif t == token.LSQB:\n                return NO\n\n        elif prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.argument:\n        # single argument\n        if t == token.EQUAL:\n            return NO\n\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type == token.LPAR:\n                return NO\n\n        elif prev.type in {token.EQUAL} | STARS:\n            return NO\n\n    elif p.type == syms.decorator:\n        # decorators\n        return NO\n\n    elif p.type == syms.dotted_name:\n        if prev:\n            return NO\n\n        prevp = preceding_leaf(p)\n        if not prevp or prevp.type == token.AT or prevp.type == token.DOT:\n            return NO\n\n    elif p.type == syms.classdef:\n        if t == token.LPAR:\n            return NO\n\n        if prev and prev.type == token.LPAR:\n            return NO\n\n    elif p.type == syms.subscript:\n        # indexing\n        if not prev:\n            assert p.parent is not None, \"subscripts are always parented\"\n            if p.parent.type == syms.subscriptlist:\n                return SPACE\n\n            return NO\n\n        else:\n            return NO\n\n    elif p.type == syms.atom:\n        if prev and t == token.DOT:\n            # dots, but not the first one.\n            return NO\n\n    elif p.type == syms.dictsetmaker:\n        # dict unpacking\n        if prev and prev.type == token.DOUBLESTAR:\n            return NO\n\n    elif p.type in {syms.factor, syms.star_expr}:\n        # unary ops\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type in OPENING_BRACKETS:\n                return NO\n\n            prevp_parent = prevp.parent\n            assert prevp_parent is not None\n            if (\n                prevp.type == token.COLON\n                and prevp_parent.type in {syms.subscript, syms.sliceop}\n            ):\n                return NO\n\n            elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument:\n                return NO\n\n        elif t == token.NAME or t == token.NUMBER:\n            return NO\n\n    elif p.type == syms.import_from:\n        if t == token.DOT:\n            if prev and prev.type == token.DOT:\n                return NO\n\n        elif t == token.NAME:\n            if v == \"import\":\n                return SPACE\n\n            if prev and prev.type == token.DOT:\n                return NO\n\n    elif p.type == syms.sliceop:\n        return NO\n\n    return SPACE",
        "begin_line": 1300,
        "end_line": 1510,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.034482758620689655,
            "pseudo_dstar_susp": 0.03225806451612903,
            "pseudo_tarantula_susp": 0.03571428571428571,
            "pseudo_op2_susp": 0.03225806451612903,
            "pseudo_barinel_susp": 0.03571428571428571
        }
    },
    {
        "name": "black.preceding_leaf#1513",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.preceding_leaf(node: Optional[LN])",
        "snippet": "def preceding_leaf(node: Optional[LN]) -> Optional[Leaf]:\n    \"\"\"Return the first leaf that precedes `node`, if any.\"\"\"\n    while node:\n        res = node.prev_sibling\n        if res:\n            if isinstance(res, Leaf):\n                return res\n\n            try:\n                return list(res.leaves())[-1]\n\n            except IndexError:\n                return None\n\n        node = node.parent\n    return None",
        "begin_line": 1513,
        "end_line": 1528,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029850746268656717,
            "pseudo_dstar_susp": 0.0029850746268656717,
            "pseudo_tarantula_susp": 0.0029940119760479044,
            "pseudo_op2_susp": 0.0029850746268656717,
            "pseudo_barinel_susp": 0.0029940119760479044
        }
    },
    {
        "name": "black.is_split_after_delimiter#1531",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_split_after_delimiter(leaf: Leaf, previous: Leaf=None)",
        "snippet": "def is_split_after_delimiter(leaf: Leaf, previous: Leaf = None) -> int:\n    \"\"\"Return the priority of the `leaf` delimiter, given a line break after it.\n\n    The delimiter priorities returned here are from those delimiters that would\n    cause a line break after themselves.\n\n    Higher numbers are higher priority.\n    \"\"\"\n    if leaf.type == token.COMMA:\n        return COMMA_PRIORITY\n\n    return 0",
        "begin_line": 1531,
        "end_line": 1542,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024752475247524753,
            "pseudo_dstar_susp": 0.0024752475247524753,
            "pseudo_tarantula_susp": 0.0024752475247524753,
            "pseudo_op2_susp": 0.0024752475247524753,
            "pseudo_barinel_susp": 0.0024752475247524753
        }
    },
    {
        "name": "black.is_split_before_delimiter#1545",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_split_before_delimiter(leaf: Leaf, previous: Leaf=None)",
        "snippet": "def is_split_before_delimiter(leaf: Leaf, previous: Leaf = None) -> int:\n    \"\"\"Return the priority of the `leaf` delimiter, given a line before after it.\n\n    The delimiter priorities returned here are from those delimiters that would\n    cause a line break before themselves.\n\n    Higher numbers are higher priority.\n    \"\"\"\n    if is_vararg(leaf, within=VARARGS_PARENTS | UNPACKING_PARENTS):\n        # * and ** might also be MATH_OPERATORS but in this case they are not.\n        # Don't treat them as a delimiter.\n        return 0\n\n    if (\n        leaf.type in MATH_OPERATORS\n        and leaf.parent\n        and leaf.parent.type not in {syms.factor, syms.star_expr}\n    ):\n        return MATH_PRIORITY\n\n    if leaf.type in COMPARATORS:\n        return COMPARATOR_PRIORITY\n\n    if (\n        leaf.type == token.STRING\n        and previous is not None\n        and previous.type == token.STRING\n    ):\n        return STRING_PRIORITY\n\n    if (\n        leaf.type == token.NAME\n        and leaf.value == \"for\"\n        and leaf.parent\n        and leaf.parent.type in {syms.comp_for, syms.old_comp_for}\n    ):\n        return COMPREHENSION_PRIORITY\n\n    if (\n        leaf.type == token.NAME\n        and leaf.value == \"if\"\n        and leaf.parent\n        and leaf.parent.type in {syms.comp_if, syms.old_comp_if}\n    ):\n        return COMPREHENSION_PRIORITY\n\n    if leaf.type == token.NAME and leaf.value in LOGIC_OPERATORS and leaf.parent:\n        return LOGIC_PRIORITY\n\n    return 0",
        "begin_line": 1545,
        "end_line": 1594,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.025,
            "pseudo_dstar_susp": 0.023809523809523808,
            "pseudo_tarantula_susp": 0.025,
            "pseudo_op2_susp": 0.023809523809523808,
            "pseudo_barinel_susp": 0.025
        }
    },
    {
        "name": "black.generate_comments#1597",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.generate_comments(leaf: Leaf)",
        "snippet": "def generate_comments(leaf: Leaf) -> Iterator[Leaf]:\n    \"\"\"Clean the prefix of the `leaf` and generate comments from it, if any.\n\n    Comments in lib2to3 are shoved into the whitespace prefix.  This happens\n    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation\n    move because it does away with modifying the grammar to include all the\n    possible places in which comments can be placed.\n\n    The sad consequence for us though is that comments don't \"belong\" anywhere.\n    This is why this function generates simple parentless Leaf objects for\n    comments.  We simply don't know what the correct parent should be.\n\n    No matter though, we can live without this.  We really only need to\n    differentiate between inline and standalone comments.  The latter don't\n    share the line with any code.\n\n    Inline comments are emitted as regular token.COMMENT leaves.  Standalone\n    are emitted with a fake STANDALONE_COMMENT token identifier.\n    \"\"\"\n    p = leaf.prefix\n    if not p:\n        return\n\n    if \"#\" not in p:\n        return\n\n    consumed = 0\n    nlines = 0\n    for index, line in enumerate(p.split(\"\\n\")):\n        consumed += len(line) + 1  # adding the length of the split '\\n'\n        line = line.lstrip()\n        if not line:\n            nlines += 1\n        if not line.startswith(\"#\"):\n            continue\n\n        if index == 0 and leaf.type != token.ENDMARKER:\n            comment_type = token.COMMENT  # simple trailing comment\n        else:\n            comment_type = STANDALONE_COMMENT\n        comment = make_comment(line)\n        yield Leaf(comment_type, comment, prefix=\"\\n\" * nlines)\n\n        if comment in {\"# fmt: on\", \"# yapf: enable\"}:\n            raise FormatOn(consumed)\n\n        if comment in {\"# fmt: off\", \"# yapf: disable\"}:\n            if comment_type == STANDALONE_COMMENT:\n                raise FormatOff(consumed)\n\n            prev = preceding_leaf(leaf)\n            if not prev or prev.type in WHITESPACE:  # standalone comment in disguise\n                raise FormatOff(consumed)\n\n        nlines = 0",
        "begin_line": 1597,
        "end_line": 1651,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00392156862745098,
            "pseudo_dstar_susp": 0.00392156862745098,
            "pseudo_tarantula_susp": 0.003952569169960474,
            "pseudo_op2_susp": 0.00392156862745098,
            "pseudo_barinel_susp": 0.003952569169960474
        }
    },
    {
        "name": "black.make_comment#1654",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.make_comment(content: str)",
        "snippet": "def make_comment(content: str) -> str:\n    \"\"\"Return a consistently formatted comment from the given `content` string.\n\n    All comments (except for \"##\", \"#!\", \"#:\") should have a single space between\n    the hash sign and the content.\n\n    If `content` didn't start with a hash sign, one is provided.\n    \"\"\"\n    content = content.rstrip()\n    if not content:\n        return \"#\"\n\n    if content[0] == \"#\":\n        content = content[1:]\n    if content and content[0] not in \" !:#\":\n        content = \" \" + content\n    return \"#\" + content",
        "begin_line": 1654,
        "end_line": 1670,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002232142857142857,
            "pseudo_dstar_susp": 0.002232142857142857,
            "pseudo_tarantula_susp": 0.002232142857142857,
            "pseudo_op2_susp": 0.002232142857142857,
            "pseudo_barinel_susp": 0.002232142857142857
        }
    },
    {
        "name": "black.split_line#1673",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.split_line(line: Line, line_length: int, inner: bool=False, py36: bool=False)",
        "snippet": "def split_line(\n    line: Line, line_length: int, inner: bool = False, py36: bool = False\n) -> Iterator[Line]:\n    \"\"\"Split a `line` into potentially many lines.\n\n    They should fit in the allotted `line_length` but might not be able to.\n    `inner` signifies that there were a pair of brackets somewhere around the\n    current `line`, possibly transitively. This means we can fallback to splitting\n    by delimiters if the LHS/RHS don't yield any results.\n\n    If `py36` is True, splitting may generate syntax that is only compatible\n    with Python 3.6 and later.\n    \"\"\"\n    if isinstance(line, UnformattedLines) or line.is_comment:\n        yield line\n        return\n\n    line_str = str(line).strip(\"\\n\")\n    if (\n        len(line_str) <= line_length\n        and \"\\n\" not in line_str  # multiline strings\n        and not line.contains_standalone_comments()\n    ):\n        yield line\n        return\n\n    split_funcs: List[SplitFunc]\n    if line.is_def:\n        split_funcs = [left_hand_split]\n    elif line.inside_brackets:\n        split_funcs = [delimiter_split, standalone_comment_split, right_hand_split]\n    else:\n        split_funcs = [right_hand_split]\n    for split_func in split_funcs:\n        # We are accumulating lines in `result` because we might want to abort\n        # mission and return the original line in the end, or attempt a different\n        # split altogether.\n        result: List[Line] = []\n        try:\n            for l in split_func(line, py36):\n                if str(l).strip(\"\\n\") == line_str:\n                    raise CannotSplit(\"Split function returned an unchanged result\")\n\n                result.extend(\n                    split_line(l, line_length=line_length, inner=True, py36=py36)\n                )\n        except CannotSplit as cs:\n            continue\n\n        else:\n            yield from result\n            break\n\n    else:\n        yield line",
        "begin_line": 1673,
        "end_line": 1727,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005376344086021506,
            "pseudo_dstar_susp": 0.005376344086021506,
            "pseudo_tarantula_susp": 0.005434782608695652,
            "pseudo_op2_susp": 0.005376344086021506,
            "pseudo_barinel_susp": 0.005434782608695652
        }
    },
    {
        "name": "black.left_hand_split#1730",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.left_hand_split(line: Line, py36: bool=False)",
        "snippet": "def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:\n    \"\"\"Split line into many lines, starting with the first matching bracket pair.\n\n    Note: this usually looks weird, only use this for function definitions.\n    Prefer RHS otherwise.\n    \"\"\"\n    head = Line(depth=line.depth)\n    body = Line(depth=line.depth + 1, inside_brackets=True)\n    tail = Line(depth=line.depth)\n    tail_leaves: List[Leaf] = []\n    body_leaves: List[Leaf] = []\n    head_leaves: List[Leaf] = []\n    current_leaves = head_leaves\n    matching_bracket = None\n    for leaf in line.leaves:\n        if (\n            current_leaves is body_leaves\n            and leaf.type in CLOSING_BRACKETS\n            and leaf.opening_bracket is matching_bracket\n        ):\n            current_leaves = tail_leaves if body_leaves else head_leaves\n        current_leaves.append(leaf)\n        if current_leaves is head_leaves:\n            if leaf.type in OPENING_BRACKETS:\n                matching_bracket = leaf\n                current_leaves = body_leaves\n    # Since body is a new indent level, remove spurious leading whitespace.\n    if body_leaves:\n        normalize_prefix(body_leaves[0], inside_brackets=True)\n    # Build the new lines.\n    for result, leaves in (head, head_leaves), (body, body_leaves), (tail, tail_leaves):\n        for leaf in leaves:\n            result.append(leaf, preformatted=True)\n            for comment_after in line.comments_after(leaf):\n                result.append(comment_after, preformatted=True)\n    bracket_split_succeeded_or_raise(head, body, tail)\n    for result in (head, body, tail):\n        if result:\n            yield result",
        "begin_line": 1730,
        "end_line": 1768,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0008298755186721991,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.right_hand_split#1771",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.right_hand_split(line: Line, py36: bool=False, omit: Collection[LeafID]=())",
        "snippet": "def right_hand_split(\n    line: Line, py36: bool = False, omit: Collection[LeafID] = ()\n) -> Iterator[Line]:\n    \"\"\"Split line into many lines, starting with the last matching bracket pair.\"\"\"\n    head = Line(depth=line.depth)\n    body = Line(depth=line.depth + 1, inside_brackets=True)\n    tail = Line(depth=line.depth)\n    tail_leaves: List[Leaf] = []\n    body_leaves: List[Leaf] = []\n    head_leaves: List[Leaf] = []\n    current_leaves = tail_leaves\n    opening_bracket = None\n    closing_bracket = None\n    for leaf in reversed(line.leaves):\n        if current_leaves is body_leaves:\n            if leaf is opening_bracket:\n                current_leaves = head_leaves if body_leaves else tail_leaves\n        current_leaves.append(leaf)\n        if current_leaves is tail_leaves:\n            if leaf.type in CLOSING_BRACKETS and id(leaf) not in omit:\n                opening_bracket = leaf.opening_bracket\n                closing_bracket = leaf\n                current_leaves = body_leaves\n    tail_leaves.reverse()\n    body_leaves.reverse()\n    head_leaves.reverse()\n    # Since body is a new indent level, remove spurious leading whitespace.\n    if body_leaves:\n        normalize_prefix(body_leaves[0], inside_brackets=True)\n    elif not head_leaves:\n        # No `head` and no `body` means the split failed. `tail` has all content.\n        raise CannotSplit(\"No brackets found\")\n\n    # Build the new lines.\n    for result, leaves in (head, head_leaves), (body, body_leaves), (tail, tail_leaves):\n        for leaf in leaves:\n            result.append(leaf, preformatted=True)\n            for comment_after in line.comments_after(leaf):\n                result.append(comment_after, preformatted=True)\n    bracket_split_succeeded_or_raise(head, body, tail)\n    assert opening_bracket and closing_bracket\n    if (\n        opening_bracket.type == token.LPAR\n        and not opening_bracket.value\n        and closing_bracket.type == token.RPAR\n        and not closing_bracket.value\n    ):\n        # These parens were optional. If there aren't any delimiters or standalone\n        # comments in the body, they were unnecessary and another split without\n        # them should be attempted.\n        if not (\n            body.bracket_tracker.delimiters or line.contains_standalone_comments(0)\n        ):\n            omit = {id(closing_bracket), *omit}\n            yield from right_hand_split(line, py36=py36, omit=omit)\n            return\n\n    ensure_visible(opening_bracket)\n    ensure_visible(closing_bracket)\n    for result in (head, body, tail):\n        if result:\n            yield result",
        "begin_line": 1771,
        "end_line": 1832,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012048192771084338,
            "pseudo_dstar_susp": 0.011764705882352941,
            "pseudo_tarantula_susp": 0.012048192771084338,
            "pseudo_op2_susp": 0.011764705882352941,
            "pseudo_barinel_susp": 0.012048192771084338
        }
    },
    {
        "name": "black.bracket_split_succeeded_or_raise#1835",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line)",
        "snippet": "def bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None:\n    \"\"\"Raise :exc:`CannotSplit` if the last left- or right-hand split failed.\n\n    Do nothing otherwise.\n\n    A left- or right-hand split is based on a pair of brackets. Content before\n    (and including) the opening bracket is left on one line, content inside the\n    brackets is put on a separate line, and finally content starting with and\n    following the closing bracket is put on a separate line.\n\n    Those are called `head`, `body`, and `tail`, respectively. If the split\n    produced the same line (all content in `head`) or ended up with an empty `body`\n    and the `tail` is just the closing bracket, then it's considered failed.\n    \"\"\"\n    tail_len = len(str(tail).strip())\n    if not body:\n        if tail_len == 0:\n            raise CannotSplit(\"Splitting brackets produced the same line\")\n\n        elif tail_len < 3:\n            raise CannotSplit(\n                f\"Splitting brackets on an empty body to save \"\n                f\"{tail_len} characters is not worth it\"\n            )",
        "begin_line": 1835,
        "end_line": 1858,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029850746268656717,
            "pseudo_dstar_susp": 0.0029850746268656717,
            "pseudo_tarantula_susp": 0.0029940119760479044,
            "pseudo_op2_susp": 0.0029850746268656717,
            "pseudo_barinel_susp": 0.0029940119760479044
        }
    },
    {
        "name": "black.dont_increase_indentation#1861",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.dont_increase_indentation(split_func: SplitFunc)",
        "snippet": "def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:\n    \"\"\"Normalize prefix of the first leaf in every line returned by `split_func`.\n\n    This is a decorator over relevant split functions.\n    \"\"\"\n\n    @wraps(split_func)\n    def split_wrapper(line: Line, py36: bool = False) -> Iterator[Line]:\n        for l in split_func(line, py36):\n            normalize_prefix(l.leaves[0], inside_brackets=True)\n            yield l\n\n    return split_wrapper",
        "begin_line": 1861,
        "end_line": 1873,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029850746268656717,
            "pseudo_dstar_susp": 0.0029850746268656717,
            "pseudo_tarantula_susp": 0.0029940119760479044,
            "pseudo_op2_susp": 0.0029850746268656717,
            "pseudo_barinel_susp": 0.0029940119760479044
        }
    },
    {
        "name": "black.split_wrapper#1868",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.split_wrapper(line: Line, py36: bool=False)",
        "snippet": "    def split_wrapper(line: Line, py36: bool = False) -> Iterator[Line]:\n        for l in split_func(line, py36):\n            normalize_prefix(l.leaves[0], inside_brackets=True)\n            yield l",
        "begin_line": 1868,
        "end_line": 1871,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029850746268656717,
            "pseudo_dstar_susp": 0.0029850746268656717,
            "pseudo_tarantula_susp": 0.0029940119760479044,
            "pseudo_op2_susp": 0.0029850746268656717,
            "pseudo_barinel_susp": 0.0029940119760479044
        }
    },
    {
        "name": "black.delimiter_split#1877",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.delimiter_split(line: Line, py36: bool=False)",
        "snippet": "def delimiter_split(line: Line, py36: bool = False) -> Iterator[Line]:\n    \"\"\"Split according to delimiters of the highest priority.\n\n    If `py36` is True, the split will add trailing commas also in function\n    signatures that contain `*` and `**`.\n    \"\"\"\n    try:\n        last_leaf = line.leaves[-1]\n    except IndexError:\n        raise CannotSplit(\"Line empty\")\n\n    delimiters = line.bracket_tracker.delimiters\n    try:\n        delimiter_priority = line.bracket_tracker.max_delimiter_priority(\n            exclude={id(last_leaf)}\n        )\n    except ValueError:\n        raise CannotSplit(\"No delimiters found\")\n\n    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n    lowest_depth = sys.maxsize\n    trailing_comma_safe = True\n\n    def append_to_line(leaf: Leaf) -> Iterator[Line]:\n        \"\"\"Append `leaf` to current line or to new line if appending impossible.\"\"\"\n        nonlocal current_line\n        try:\n            current_line.append_safe(leaf, preformatted=True)\n        except ValueError as ve:\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n            current_line.append(leaf)\n\n    for leaf in line.leaves:\n        yield from append_to_line(leaf)\n\n        for comment_after in line.comments_after(leaf):\n            yield from append_to_line(comment_after)\n\n        lowest_depth = min(lowest_depth, leaf.bracket_depth)\n        if (\n            leaf.bracket_depth == lowest_depth\n            and is_vararg(leaf, within=VARARGS_PARENTS)\n        ):\n            trailing_comma_safe = trailing_comma_safe and py36\n        leaf_priority = delimiters.get(id(leaf))\n        if leaf_priority == delimiter_priority:\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n    if current_line:\n        if (\n            trailing_comma_safe\n            and delimiter_priority == COMMA_PRIORITY\n            and current_line.leaves[-1].type != token.COMMA\n            and current_line.leaves[-1].type != STANDALONE_COMMENT\n        ):\n            current_line.append(Leaf(token.COMMA, \",\"))\n        yield current_line",
        "begin_line": 1877,
        "end_line": 1936,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.025,
            "pseudo_dstar_susp": 0.023809523809523808,
            "pseudo_tarantula_susp": 0.025,
            "pseudo_op2_susp": 0.023809523809523808,
            "pseudo_barinel_susp": 0.025
        }
    },
    {
        "name": "black.append_to_line#1900",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.append_to_line(leaf: Leaf)",
        "snippet": "    def append_to_line(leaf: Leaf) -> Iterator[Line]:\n        \"\"\"Append `leaf` to current line or to new line if appending impossible.\"\"\"\n        nonlocal current_line\n        try:\n            current_line.append_safe(leaf, preformatted=True)\n        except ValueError as ve:\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n            current_line.append(leaf)",
        "begin_line": 1900,
        "end_line": 1909,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00980392156862745,
            "pseudo_dstar_susp": 0.3333333333333333,
            "pseudo_tarantula_susp": 0.0029940119760479044,
            "pseudo_op2_susp": 0.3333333333333333,
            "pseudo_barinel_susp": 0.0029940119760479044
        }
    },
    {
        "name": "black.standalone_comment_split#1940",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.standalone_comment_split(line: Line, py36: bool=False)",
        "snippet": "def standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:\n    \"\"\"Split standalone comments from the rest of the line.\"\"\"\n    if not line.contains_standalone_comments(0):\n        raise CannotSplit(\"Line does not have any standalone comments\")\n\n    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n\n    def append_to_line(leaf: Leaf) -> Iterator[Line]:\n        \"\"\"Append `leaf` to current line or to new line if appending impossible.\"\"\"\n        nonlocal current_line\n        try:\n            current_line.append_safe(leaf, preformatted=True)\n        except ValueError as ve:\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n            current_line.append(leaf)\n\n    for leaf in line.leaves:\n        yield from append_to_line(leaf)\n\n        for comment_after in line.comments_after(leaf):\n            yield from append_to_line(comment_after)\n\n    if current_line:\n        yield current_line",
        "begin_line": 1940,
        "end_line": 1965,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005128205128205128,
            "pseudo_dstar_susp": 0.005128205128205128,
            "pseudo_tarantula_susp": 0.0051813471502590676,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0051813471502590676
        }
    },
    {
        "name": "black.append_to_line#1947",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.append_to_line(leaf: Leaf)",
        "snippet": "    def append_to_line(leaf: Leaf) -> Iterator[Line]:\n        \"\"\"Append `leaf` to current line or to new line if appending impossible.\"\"\"\n        nonlocal current_line\n        try:\n            current_line.append_safe(leaf, preformatted=True)\n        except ValueError as ve:\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n            current_line.append(leaf)",
        "begin_line": 1947,
        "end_line": 1956,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00980392156862745,
            "pseudo_dstar_susp": 0.3333333333333333,
            "pseudo_tarantula_susp": 0.0029940119760479044,
            "pseudo_op2_susp": 0.3333333333333333,
            "pseudo_barinel_susp": 0.0029940119760479044
        }
    },
    {
        "name": "black.is_import#1968",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_import(leaf: Leaf)",
        "snippet": "def is_import(leaf: Leaf) -> bool:\n    \"\"\"Return True if the given leaf starts an import statement.\"\"\"\n    p = leaf.parent\n    t = leaf.type\n    v = leaf.value\n    return bool(\n        t == token.NAME\n        and (\n            (v == \"import\" and p and p.type == syms.import_name)\n            or (v == \"from\" and p and p.type == syms.import_from)\n        )\n    )",
        "begin_line": 1968,
        "end_line": 1979,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002004008016032064,
            "pseudo_dstar_susp": 0.002004008016032064,
            "pseudo_tarantula_susp": 0.002004008016032064,
            "pseudo_op2_susp": 0.002004008016032064,
            "pseudo_barinel_susp": 0.002004008016032064
        }
    },
    {
        "name": "black.normalize_prefix#1982",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.normalize_prefix(leaf: Leaf, *, inside_brackets: bool)",
        "snippet": "def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:\n    \"\"\"Leave existing extra newlines if not `inside_brackets`. Remove everything\n    else.\n\n    Note: don't use backslashes for formatting or you'll lose your voting rights.\n    \"\"\"\n    if not inside_brackets:\n        spl = leaf.prefix.split(\"#\")\n        if \"\\\\\" not in spl[0]:\n            nl_count = spl[-1].count(\"\\n\")\n            if len(spl) > 1:\n                nl_count -= 1\n            leaf.prefix = \"\\n\" * nl_count\n            return\n\n    leaf.prefix = \"\"",
        "begin_line": 1982,
        "end_line": 1997,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029850746268656717,
            "pseudo_dstar_susp": 0.0029850746268656717,
            "pseudo_tarantula_susp": 0.0029940119760479044,
            "pseudo_op2_susp": 0.0029850746268656717,
            "pseudo_barinel_susp": 0.0029940119760479044
        }
    },
    {
        "name": "black.normalize_string_quotes#2000",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.normalize_string_quotes(leaf: Leaf)",
        "snippet": "def normalize_string_quotes(leaf: Leaf) -> None:\n    \"\"\"Prefer double quotes but only if it doesn't cause more escaping.\n\n    Adds or removes backslashes as appropriate. Doesn't parse and fix\n    strings nested in f-strings (yet).\n\n    Note: Mutates its argument.\n    \"\"\"\n    value = leaf.value.lstrip(\"furbFURB\")\n    if value[:3] == '\"\"\"':\n        return\n\n    elif value[:3] == \"'''\":\n        orig_quote = \"'''\"\n        new_quote = '\"\"\"'\n    elif value[0] == '\"':\n        orig_quote = '\"'\n        new_quote = \"'\"\n    else:\n        orig_quote = \"'\"\n        new_quote = '\"'\n    first_quote_pos = leaf.value.find(orig_quote)\n    if first_quote_pos == -1:\n        return  # There's an internal error\n\n    prefix = leaf.value[:first_quote_pos]\n    unescaped_new_quote = re.compile(rf\"(([^\\\\]|^)(\\\\\\\\)*){new_quote}\")\n    escaped_new_quote = re.compile(rf\"([^\\\\]|^)\\\\(\\\\\\\\)*{new_quote}\")\n    escaped_orig_quote = re.compile(rf\"([^\\\\]|^)\\\\(\\\\\\\\)*{orig_quote}\")\n    body = leaf.value[first_quote_pos + len(orig_quote):-len(orig_quote)]\n    if \"r\" in prefix.casefold():\n        if unescaped_new_quote.search(body):\n            # There's at least one unescaped new_quote in this raw string\n            # so converting is impossible\n            return\n\n        # Do not introduce or remove backslashes in raw strings\n        new_body = body\n    else:\n        # remove unnecessary quotes\n        new_body = sub_twice(escaped_new_quote, rf\"\\1\\2{new_quote}\", body)\n        if body != new_body:\n            # Consider the string without unnecessary quotes as the original\n            body = new_body\n            leaf.value = f\"{prefix}{orig_quote}{body}{orig_quote}\"\n        new_body = sub_twice(escaped_orig_quote, rf\"\\1\\2{orig_quote}\", new_body)\n        new_body = sub_twice(unescaped_new_quote, rf\"\\1\\\\{new_quote}\", new_body)\n    if new_quote == '\"\"\"' and new_body[-1] == '\"':\n        # edge case:\n        new_body = new_body[:-1] + '\\\\\"'\n    orig_escape_count = body.count(\"\\\\\")\n    new_escape_count = new_body.count(\"\\\\\")\n    if new_escape_count > orig_escape_count:\n        return  # Do not introduce more escaping\n\n    if new_escape_count == orig_escape_count and orig_quote == '\"':\n        return  # Prefer double quotes\n\n    leaf.value = f\"{prefix}{new_quote}{new_body}{new_quote}\"",
        "begin_line": 2000,
        "end_line": 2058,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005128205128205128,
            "pseudo_dstar_susp": 0.005128205128205128,
            "pseudo_tarantula_susp": 0.0051813471502590676,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0051813471502590676
        }
    },
    {
        "name": "black.normalize_invisible_parens#2061",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.normalize_invisible_parens(node: Node, parens_after: Set[str])",
        "snippet": "def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:\n    \"\"\"Make existing optional parentheses invisible or create new ones.\n\n    Standardizes on visible parentheses for single-element tuples, and keeps\n    existing visible parentheses for other tuples and generator expressions.\n    \"\"\"\n    check_lpar = False\n    for child in list(node.children):\n        if check_lpar:\n            if child.type == syms.atom:\n                if not (\n                    is_empty_tuple(child)\n                    or is_one_tuple(child)\n                    or max_delimiter_priority_in_atom(child) >= COMMA_PRIORITY\n                ):\n                    first = child.children[0]\n                    last = child.children[-1]\n                    if first.type == token.LPAR and last.type == token.RPAR:\n                        # make parentheses invisible\n                        first.value = \"\"  # type: ignore\n                        last.value = \"\"  # type: ignore\n            elif is_one_tuple(child):\n                # wrap child in visible parentheses\n                lpar = Leaf(token.LPAR, \"(\")\n                rpar = Leaf(token.RPAR, \")\")\n                index = child.remove() or 0\n                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))\n            else:\n                # wrap child in invisible parentheses\n                lpar = Leaf(token.LPAR, \"\")\n                rpar = Leaf(token.RPAR, \"\")\n                index = child.remove() or 0\n                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))\n\n        check_lpar = isinstance(child, Leaf) and child.value in parens_after",
        "begin_line": 2061,
        "end_line": 2095,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.034482758620689655,
            "pseudo_dstar_susp": 0.03225806451612903,
            "pseudo_tarantula_susp": 0.03571428571428571,
            "pseudo_op2_susp": 0.03225806451612903,
            "pseudo_barinel_susp": 0.03571428571428571
        }
    },
    {
        "name": "black.is_empty_tuple#2098",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_empty_tuple(node: LN)",
        "snippet": "def is_empty_tuple(node: LN) -> bool:\n    \"\"\"Return True if `node` holds an empty tuple.\"\"\"\n    return (\n        node.type == syms.atom\n        and len(node.children) == 2\n        and node.children[0].type == token.LPAR\n        and node.children[1].type == token.RPAR\n    )",
        "begin_line": 2098,
        "end_line": 2105,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.034482758620689655,
            "pseudo_dstar_susp": 0.03225806451612903,
            "pseudo_tarantula_susp": 0.03571428571428571,
            "pseudo_op2_susp": 0.03225806451612903,
            "pseudo_barinel_susp": 0.03571428571428571
        }
    },
    {
        "name": "black.is_one_tuple#2108",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_one_tuple(node: LN)",
        "snippet": "def is_one_tuple(node: LN) -> bool:\n    \"\"\"Return True if `node` holds a tuple with one element, with or without parens.\"\"\"\n    if node.type == syms.atom:\n        if len(node.children) != 3:\n            return False\n\n        lpar, gexp, rpar = node.children\n        if not (\n            lpar.type == token.LPAR\n            and gexp.type == syms.testlist_gexp\n            and rpar.type == token.RPAR\n        ):\n            return False\n\n        return len(gexp.children) == 2 and gexp.children[1].type == token.COMMA\n\n    return (\n        node.type in IMPLICIT_TUPLE\n        and len(node.children) == 2\n        and node.children[1].type == token.COMMA\n    )",
        "begin_line": 2108,
        "end_line": 2128,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.034482758620689655,
            "pseudo_dstar_susp": 0.03225806451612903,
            "pseudo_tarantula_susp": 0.03571428571428571,
            "pseudo_op2_susp": 0.03225806451612903,
            "pseudo_barinel_susp": 0.03571428571428571
        }
    },
    {
        "name": "black.is_vararg#2131",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_vararg(leaf: Leaf, within: Set[NodeType])",
        "snippet": "def is_vararg(leaf: Leaf, within: Set[NodeType]) -> bool:\n    \"\"\"Return True if `leaf` is a star or double star in a vararg or kwarg.\n\n    If `within` includes VARARGS_PARENTS, this applies to function signatures.\n    If `within` includes COLLECTION_LIBERALS_PARENTS, it applies to right\n    hand-side extended iterable unpacking (PEP 3132) and additional unpacking\n    generalizations (PEP 448).\n    \"\"\"\n    if leaf.type not in STARS or not leaf.parent:\n        return False\n\n    p = leaf.parent\n    if p.type == syms.star_expr:\n        # Star expressions are also used as assignment targets in extended\n        # iterable unpacking (PEP 3132).  See what its parent is instead.\n        if not p.parent:\n            return False\n\n        p = p.parent\n\n    return p.type in within",
        "begin_line": 2131,
        "end_line": 2151,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.034482758620689655,
            "pseudo_dstar_susp": 0.03225806451612903,
            "pseudo_tarantula_susp": 0.03571428571428571,
            "pseudo_op2_susp": 0.03225806451612903,
            "pseudo_barinel_susp": 0.03571428571428571
        }
    },
    {
        "name": "black.max_delimiter_priority_in_atom#2154",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.max_delimiter_priority_in_atom(node: LN)",
        "snippet": "def max_delimiter_priority_in_atom(node: LN) -> int:\n    \"\"\"Return maximum delimiter priority inside `node`.\n\n    This is specific to atoms with contents contained in a pair of parentheses.\n    If `node` isn't an atom or there are no enclosing parentheses, returns 0.\n    \"\"\"\n    if node.type != syms.atom:\n        return 0\n\n    first = node.children[0]\n    last = node.children[-1]\n    if not (first.type == token.LPAR and last.type == token.RPAR):\n        return 0\n\n    bt = BracketTracker()\n    for c in node.children[1:-1]:\n        if isinstance(c, Leaf):\n            bt.mark(c)\n        else:\n            for leaf in c.leaves():\n                bt.mark(leaf)\n    try:\n        return bt.max_delimiter_priority()\n\n    except ValueError:\n        return 0",
        "begin_line": 2154,
        "end_line": 2179,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.018518518518518517,
            "pseudo_dstar_susp": 0.017857142857142856,
            "pseudo_tarantula_susp": 0.018518518518518517,
            "pseudo_op2_susp": 0.017857142857142856,
            "pseudo_barinel_susp": 0.018518518518518517
        }
    },
    {
        "name": "black.ensure_visible#2182",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.ensure_visible(leaf: Leaf)",
        "snippet": "def ensure_visible(leaf: Leaf) -> None:\n    \"\"\"Make sure parentheses are visible.\n\n    They could be invisible as part of some statements (see\n    :func:`normalize_invible_parens` and :func:`visit_import_from`).\n    \"\"\"\n    if leaf.type == token.LPAR:\n        leaf.value = \"(\"\n    elif leaf.type == token.RPAR:\n        leaf.value = \")\"",
        "begin_line": 2182,
        "end_line": 2191,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029850746268656717,
            "pseudo_dstar_susp": 0.0029850746268656717,
            "pseudo_tarantula_susp": 0.0029940119760479044,
            "pseudo_op2_susp": 0.0029850746268656717,
            "pseudo_barinel_susp": 0.0029940119760479044
        }
    },
    {
        "name": "black.is_python36#2194",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_python36(node: Node)",
        "snippet": "def is_python36(node: Node) -> bool:\n    \"\"\"Return True if the current file is using Python 3.6+ features.\n\n    Currently looking for:\n    - f-strings; and\n    - trailing commas after * or ** in function signatures.\n    \"\"\"\n    for n in node.pre_order():\n        if n.type == token.STRING:\n            value_head = n.value[:2]  # type: ignore\n            if value_head in {'f\"', 'F\"', \"f'\", \"F'\", \"rf\", \"fr\", \"RF\", \"FR\"}:\n                return True\n\n        elif (\n            n.type == syms.typedargslist\n            and n.children\n            and n.children[-1].type == token.COMMA\n        ):\n            for ch in n.children:\n                if ch.type in STARS:\n                    return True\n\n    return False",
        "begin_line": 2194,
        "end_line": 2216,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002004008016032064,
            "pseudo_dstar_susp": 0.002004008016032064,
            "pseudo_tarantula_susp": 0.002004008016032064,
            "pseudo_op2_susp": 0.002004008016032064,
            "pseudo_barinel_susp": 0.002004008016032064
        }
    },
    {
        "name": "black.gen_python_files_in_dir#2225",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.gen_python_files_in_dir(path: Path)",
        "snippet": "def gen_python_files_in_dir(path: Path) -> Iterator[Path]:\n    \"\"\"Generate all files under `path` which aren't under BLACKLISTED_DIRECTORIES\n    and have one of the PYTHON_EXTENSIONS.\n    \"\"\"\n    for child in path.iterdir():\n        if child.is_dir():\n            if child.name in BLACKLISTED_DIRECTORIES:\n                continue\n\n            yield from gen_python_files_in_dir(child)\n\n        elif child.suffix in PYTHON_EXTENSIONS:\n            yield child",
        "begin_line": 2225,
        "end_line": 2237,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0008298755186721991,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.Report.done#2249",
        "src_path": "black.py",
        "class_name": "black.Report",
        "signature": "black.Report.done(self, src: Path, changed: Changed)",
        "snippet": "    def done(self, src: Path, changed: Changed) -> None:\n        \"\"\"Increment the counter for successful reformatting. Write out a message.\"\"\"\n        if changed is Changed.YES:\n            reformatted = \"would reformat\" if self.check else \"reformatted\"\n            if not self.quiet:\n                out(f\"{reformatted} {src}\")\n            self.change_count += 1\n        else:\n            if not self.quiet:\n                if changed is Changed.NO:\n                    msg = f\"{src} already well formatted, good job.\"\n                else:\n                    msg = f\"{src} wasn't modified on disk since last run.\"\n                out(msg, bold=False)\n            self.same_count += 1",
        "begin_line": 2249,
        "end_line": 2263,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0007782101167315176,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.Report.failed#2265",
        "src_path": "black.py",
        "class_name": "black.Report",
        "signature": "black.Report.failed(self, src: Path, message: str)",
        "snippet": "    def failed(self, src: Path, message: str) -> None:\n        \"\"\"Increment the counter for failed reformatting. Write out a message.\"\"\"\n        err(f\"error: cannot format {src}: {message}\")\n        self.failure_count += 1",
        "begin_line": 2265,
        "end_line": 2268,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0008298755186721991,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.Report.return_code#2271",
        "src_path": "black.py",
        "class_name": "black.Report",
        "signature": "black.Report.return_code(self)",
        "snippet": "    def return_code(self) -> int:\n        \"\"\"Return the exit code that the app should use.\n\n        This considers the current state of changed files and failures:\n        - if there were any failures, return 123;\n        - if any files were changed and --check is being used, return 1;\n        - otherwise return 0.\n        \"\"\"\n        # According to http://tldp.org/LDP/abs/html/exitcodes.html starting with\n        # 126 we have special returncodes reserved by the shell.\n        if self.failure_count:\n            return 123\n\n        elif self.change_count and self.check:\n            return 1\n\n        return 0",
        "begin_line": 2271,
        "end_line": 2287,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0008298755186721991,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.Report.__str__#2289",
        "src_path": "black.py",
        "class_name": "black.Report",
        "signature": "black.Report.__str__(self)",
        "snippet": "    def __str__(self) -> str:\n        \"\"\"Render a color report of the current state.\n\n        Use `click.unstyle` to remove colors.\n        \"\"\"\n        if self.check:\n            reformatted = \"would be reformatted\"\n            unchanged = \"would be left unchanged\"\n            failed = \"would fail to reformat\"\n        else:\n            reformatted = \"reformatted\"\n            unchanged = \"left unchanged\"\n            failed = \"failed to reformat\"\n        report = []\n        if self.change_count:\n            s = \"s\" if self.change_count > 1 else \"\"\n            report.append(\n                click.style(f\"{self.change_count} file{s} {reformatted}\", bold=True)\n            )\n        if self.same_count:\n            s = \"s\" if self.same_count > 1 else \"\"\n            report.append(f\"{self.same_count} file{s} {unchanged}\")\n        if self.failure_count:\n            s = \"s\" if self.failure_count > 1 else \"\"\n            report.append(\n                click.style(f\"{self.failure_count} file{s} {failed}\", fg=\"red\")\n            )\n        return \", \".join(report) + \".\"",
        "begin_line": 2289,
        "end_line": 2316,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0008298755186721991,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.assert_equivalent#2319",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.assert_equivalent(src: str, dst: str)",
        "snippet": "def assert_equivalent(src: str, dst: str) -> None:\n    \"\"\"Raise AssertionError if `src` and `dst` aren't equivalent.\"\"\"\n\n    import ast\n    import traceback\n\n    def _v(node: ast.AST, depth: int = 0) -> Iterator[str]:\n        \"\"\"Simple visitor generating strings to compare ASTs by content.\"\"\"\n        yield f\"{'  ' * depth}{node.__class__.__name__}(\"\n\n        for field in sorted(node._fields):\n            try:\n                value = getattr(node, field)\n            except AttributeError:\n                continue\n\n            yield f\"{'  ' * (depth+1)}{field}=\"\n\n            if isinstance(value, list):\n                for item in value:\n                    if isinstance(item, ast.AST):\n                        yield from _v(item, depth + 2)\n\n            elif isinstance(value, ast.AST):\n                yield from _v(value, depth + 2)\n\n            else:\n                yield f\"{'  ' * (depth+2)}{value!r},  # {value.__class__.__name__}\"\n\n        yield f\"{'  ' * depth})  # /{node.__class__.__name__}\"\n\n    try:\n        src_ast = ast.parse(src)\n    except Exception as exc:\n        major, minor = sys.version_info[:2]\n        raise AssertionError(\n            f\"cannot use --safe with this file; failed to parse source file \"\n            f\"with Python {major}.{minor}'s builtin AST. Re-run with --fast \"\n            f\"or stop using deprecated Python 2 syntax. AST error message: {exc}\"\n        )\n\n    try:\n        dst_ast = ast.parse(dst)\n    except Exception as exc:\n        log = dump_to_file(\"\".join(traceback.format_tb(exc.__traceback__)), dst)\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced invalid code: {exc}. \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This invalid output might be helpful: {log}\"\n        ) from None\n\n    src_ast_str = \"\\n\".join(_v(src_ast))\n    dst_ast_str = \"\\n\".join(_v(dst_ast))\n    if src_ast_str != dst_ast_str:\n        log = dump_to_file(diff(src_ast_str, dst_ast_str, \"src\", \"dst\"))\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced code that is not equivalent to \"\n            f\"the source.  \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This diff might be helpful: {log}\"\n        ) from None",
        "begin_line": 2319,
        "end_line": 2379,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0006414368184733803,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black._v#2325",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black._v(node: ast.AST, depth: int=0)",
        "snippet": "    def _v(node: ast.AST, depth: int = 0) -> Iterator[str]:\n        \"\"\"Simple visitor generating strings to compare ASTs by content.\"\"\"\n        yield f\"{'  ' * depth}{node.__class__.__name__}(\"\n\n        for field in sorted(node._fields):\n            try:\n                value = getattr(node, field)\n            except AttributeError:\n                continue\n\n            yield f\"{'  ' * (depth+1)}{field}=\"\n\n            if isinstance(value, list):\n                for item in value:\n                    if isinstance(item, ast.AST):\n                        yield from _v(item, depth + 2)\n\n            elif isinstance(value, ast.AST):\n                yield from _v(value, depth + 2)\n\n            else:\n                yield f\"{'  ' * (depth+2)}{value!r},  # {value.__class__.__name__}\"\n\n        yield f\"{'  ' * depth})  # /{node.__class__.__name__}\"",
        "begin_line": 2325,
        "end_line": 2348,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0006414368184733803,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.assert_stable#2382",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.assert_stable(src: str, dst: str, line_length: int)",
        "snippet": "def assert_stable(src: str, dst: str, line_length: int) -> None:\n    \"\"\"Raise AssertionError if `dst` reformats differently the second time.\"\"\"\n    newdst = format_str(dst, line_length=line_length)\n    if dst != newdst:\n        log = dump_to_file(\n            diff(src, dst, \"source\", \"first pass\"),\n            diff(dst, newdst, \"first pass\", \"second pass\"),\n        )\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced different code on the second pass \"\n            f\"of the formatter.  \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This diff might be helpful: {log}\"\n        ) from None",
        "begin_line": 2382,
        "end_line": 2395,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0006361323155216285,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.dump_to_file#2398",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.dump_to_file(*output: str)",
        "snippet": "def dump_to_file(*output: str) -> str:\n    \"\"\"Dump `output` to a temporary file. Return path to the file.\"\"\"\n    import tempfile\n\n    with tempfile.NamedTemporaryFile(\n        mode=\"w\", prefix=\"blk_\", suffix=\".log\", delete=False, encoding=\"utf8\"\n    ) as f:\n        for lines in output:\n            f.write(lines)\n            if lines and lines[-1] != \"\\n\":\n                f.write(\"\\n\")\n    return f.name",
        "begin_line": 2398,
        "end_line": 2409,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.16666666666666666,
            "pseudo_dstar_susp": 0.1111111111111111,
            "pseudo_tarantula_susp": 0.2,
            "pseudo_op2_susp": 0.1111111111111111,
            "pseudo_barinel_susp": 0.2
        }
    },
    {
        "name": "black.diff#2412",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.diff(a: str, b: str, a_name: str, b_name: str)",
        "snippet": "def diff(a: str, b: str, a_name: str, b_name: str) -> str:\n    \"\"\"Return a unified diff string between strings `a` and `b`.\"\"\"\n    import difflib\n\n    a_lines = [line + \"\\n\" for line in a.split(\"\\n\")]\n    b_lines = [line + \"\\n\" for line in b.split(\"\\n\")]\n    return \"\".join(\n        difflib.unified_diff(a_lines, b_lines, fromfile=a_name, tofile=b_name, n=5)\n    )",
        "begin_line": 2412,
        "end_line": 2420,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.16666666666666666,
            "pseudo_dstar_susp": 1.0,
            "pseudo_tarantula_susp": 0.03571428571428571,
            "pseudo_op2_susp": 1.0,
            "pseudo_barinel_susp": 0.03571428571428571
        }
    },
    {
        "name": "black.shutdown#2430",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.shutdown(loop: BaseEventLoop)",
        "snippet": "def shutdown(loop: BaseEventLoop) -> None:\n    \"\"\"Cancel all pending tasks on `loop`, wait for them, and close the loop.\"\"\"\n    try:\n        # This part is borrowed from asyncio/runners.py in Python 3.7b2.\n        to_cancel = [task for task in asyncio.Task.all_tasks(loop) if not task.done()]\n        if not to_cancel:\n            return\n\n        for task in to_cancel:\n            task.cancel()\n        loop.run_until_complete(\n            asyncio.gather(*to_cancel, loop=loop, return_exceptions=True)\n        )\n    finally:\n        # `concurrent.futures.Future` objects cannot be cancelled once they\n        # are already running. There might be some when the `shutdown()` happened.\n        # Silence their logger's spew about the event loop being closed.\n        cf_logger = logging.getLogger(\"concurrent.futures\")\n        cf_logger.setLevel(logging.CRITICAL)\n        loop.close()",
        "begin_line": 2430,
        "end_line": 2449,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0007782101167315176,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.sub_twice#2452",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.sub_twice(regex: Pattern[str], replacement: str, original: str)",
        "snippet": "def sub_twice(regex: Pattern[str], replacement: str, original: str) -> str:\n    \"\"\"Replace `regex` with `replacement` twice on `original`.\n\n    This is used by string normalization to perform replaces on\n    overlapping matches.\n    \"\"\"\n    return regex.sub(replacement, regex.sub(replacement, original))",
        "begin_line": 2452,
        "end_line": 2458,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017953321364452424,
            "pseudo_dstar_susp": 0.0017953321364452424,
            "pseudo_tarantula_susp": 0.0017953321364452424,
            "pseudo_op2_susp": 0.0017953321364452424,
            "pseudo_barinel_susp": 0.0017953321364452424
        }
    },
    {
        "name": "black.read_cache#2465",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.read_cache()",
        "snippet": "def read_cache() -> Cache:\n    \"\"\"Read the cache if it exists and is well formed.\n\n    If it is not well formed, the call to write_cache later should resolve the issue.\n    \"\"\"\n    if not CACHE_FILE.exists():\n        return {}\n\n    with CACHE_FILE.open(\"rb\") as fobj:\n        try:\n            cache: Cache = pickle.load(fobj)\n        except pickle.UnpicklingError:\n            return {}\n\n    return cache",
        "begin_line": 2465,
        "end_line": 2479,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0008880994671403197,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.get_cache_info#2482",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.get_cache_info(path: Path)",
        "snippet": "def get_cache_info(path: Path) -> CacheInfo:\n    \"\"\"Return the information used to check if a file is already formatted or not.\"\"\"\n    stat = path.stat()\n    return stat.st_mtime, stat.st_size",
        "begin_line": 2482,
        "end_line": 2485,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0006954102920723226,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.filter_cached#2488",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.filter_cached(cache: Cache, sources: Iterable[Path])",
        "snippet": "def filter_cached(\n    cache: Cache, sources: Iterable[Path]\n) -> Tuple[List[Path], List[Path]]:\n    \"\"\"Split a list of paths into two.\n\n    The first list contains paths of files that modified on disk or are not in the\n    cache. The other list contains paths to non-modified files.\n    \"\"\"\n    todo, done = [], []\n    for src in sources:\n        src = src.resolve()\n        if cache.get(src) != get_cache_info(src):\n            todo.append(src)\n        else:\n            done.append(src)\n    return todo, done",
        "begin_line": 2488,
        "end_line": 2503,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0008298755186721991,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "black.write_cache#2506",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.write_cache(cache: Cache, sources: List[Path])",
        "snippet": "def write_cache(cache: Cache, sources: List[Path]) -> None:\n    \"\"\"Update the cache file.\"\"\"\n    try:\n        if not CACHE_DIR.exists():\n            CACHE_DIR.mkdir(parents=True)\n        new_cache = {**cache, **{src.resolve(): get_cache_info(src) for src in sources}}\n        with CACHE_FILE.open(\"wb\") as fobj:\n            pickle.dump(new_cache, fobj, protocol=pickle.HIGHEST_PROTOCOL)\n    except OSError:\n        pass",
        "begin_line": 2506,
        "end_line": 2515,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007530120481927711,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0007530120481927711,
            "pseudo_op2_susp": 0.0008880994671403197,
            "pseudo_barinel_susp": 0.0007530120481927711
        }
    },
    {
        "name": "blib2to3.pgen2.driver.Driver.__init__#32",
        "src_path": "blib2to3/pgen2/driver.py",
        "class_name": "blib2to3.pgen2.driver.Driver",
        "signature": "blib2to3.pgen2.driver.Driver.__init__(self, grammar, convert=None, logger=None)",
        "snippet": "    def __init__(self, grammar, convert=None, logger=None):\n        self.grammar = grammar\n        if logger is None:\n            logger = logging.getLogger()\n        self.logger = logger\n        self.convert = convert",
        "begin_line": 32,
        "end_line": 37,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009891196834817012,
            "pseudo_dstar_susp": 0.0009891196834817012,
            "pseudo_tarantula_susp": 0.0009891196834817012,
            "pseudo_op2_susp": 0.0009891196834817012,
            "pseudo_barinel_susp": 0.0009891196834817012
        }
    },
    {
        "name": "blib2to3.pgen2.driver.Driver.parse_tokens#39",
        "src_path": "blib2to3/pgen2/driver.py",
        "class_name": "blib2to3.pgen2.driver.Driver",
        "signature": "blib2to3.pgen2.driver.Driver.parse_tokens(self, tokens, debug=False)",
        "snippet": "    def parse_tokens(self, tokens, debug=False):\n        \"\"\"Parse a series of tokens and return the syntax tree.\"\"\"\n        # XXX Move the prefix computation into a wrapper around tokenize.\n        p = parse.Parser(self.grammar, self.convert)\n        p.setup()\n        lineno = 1\n        column = 0\n        type = value = start = end = line_text = None\n        prefix = \"\"\n        for quintuple in tokens:\n            type, value, start, end, line_text = quintuple\n            if start != (lineno, column):\n                assert (lineno, column) <= start, ((lineno, column), start)\n                s_lineno, s_column = start\n                if lineno < s_lineno:\n                    prefix += \"\\n\" * (s_lineno - lineno)\n                    lineno = s_lineno\n                    column = 0\n                if column < s_column:\n                    prefix += line_text[column:s_column]\n                    column = s_column\n            if type in (tokenize.COMMENT, tokenize.NL):\n                prefix += value\n                lineno, column = end\n                if value.endswith(\"\\n\"):\n                    lineno += 1\n                    column = 0\n                continue\n            if type == token.OP:\n                type = grammar.opmap[value]\n            if debug:\n                self.logger.debug(\"%s %r (prefix=%r)\",\n                                  token.tok_name[type], value, prefix)\n            if type in {token.INDENT, token.DEDENT}:\n                _prefix = prefix\n                prefix = \"\"\n            if p.addtoken(type, value, (prefix, start)):\n                if debug:\n                    self.logger.debug(\"Stop.\")\n                break\n            prefix = \"\"\n            if type == token.INDENT:\n                if _prefix.startswith(value):\n                    # Don't double-indent.  Since we're delaying the prefix that\n                    # would normally belong to INDENT, we need to put the value\n                    # at the end versus at the beginning.\n                    _prefix = _prefix[len(value):] + value\n            if type in {token.INDENT, token.DEDENT}:\n                prefix = _prefix\n            lineno, column = end\n            if value.endswith(\"\\n\"):\n                lineno += 1\n                column = 0\n        else:\n            # We never broke out -- EOF is too soon (how can this happen???)\n            raise parse.ParseError(\"incomplete input\",\n                                   type, value, (prefix, start))\n        return p.rootnode",
        "begin_line": 39,
        "end_line": 96,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002232142857142857,
            "pseudo_dstar_susp": 0.002232142857142857,
            "pseudo_tarantula_susp": 0.002232142857142857,
            "pseudo_op2_susp": 0.002232142857142857,
            "pseudo_barinel_susp": 0.002232142857142857
        }
    },
    {
        "name": "blib2to3.pgen2.driver.Driver.parse_string#112",
        "src_path": "blib2to3/pgen2/driver.py",
        "class_name": "blib2to3.pgen2.driver.Driver",
        "signature": "blib2to3.pgen2.driver.Driver.parse_string(self, text, debug=False)",
        "snippet": "    def parse_string(self, text, debug=False):\n        \"\"\"Parse a string and return the syntax tree.\"\"\"\n        tokens = tokenize.generate_tokens(io.StringIO(text).readline)\n        return self.parse_tokens(tokens, debug)",
        "begin_line": 112,
        "end_line": 115,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009891196834817012,
            "pseudo_dstar_susp": 0.0009891196834817012,
            "pseudo_tarantula_susp": 0.0009891196834817012,
            "pseudo_op2_susp": 0.0009891196834817012,
            "pseudo_barinel_susp": 0.0009891196834817012
        }
    },
    {
        "name": "blib2to3.pgen2.tokenize.generate_tokens#339",
        "src_path": "blib2to3/pgen2/tokenize.py",
        "class_name": "blib2to3.pgen2.tokenize",
        "signature": "blib2to3.pgen2.tokenize.generate_tokens(readline)",
        "snippet": "def generate_tokens(readline):\n    \"\"\"\n    The generate_tokens() generator requires one argument, readline, which\n    must be a callable object which provides the same interface as the\n    readline() method of built-in file objects. Each call to the function\n    should return one line of input as a string.  Alternately, readline\n    can be a callable function terminating with StopIteration:\n        readline = open(myfile).next    # Example of alternate readline\n\n    The generator produces 5-tuples with these members: the token type; the\n    token string; a 2-tuple (srow, scol) of ints specifying the row and\n    column where the token begins in the source; a 2-tuple (erow, ecol) of\n    ints specifying the row and column where the token ends in the source;\n    and the line on which the token was found. The line passed is the\n    logical line; continuation lines are included.\n    \"\"\"\n    lnum = parenlev = continued = 0\n    namechars, numchars = string.ascii_letters + '_', '0123456789'\n    contstr, needcont = '', 0\n    contline = None\n    indents = [0]\n\n    # 'stashed' and 'async_*' are used for async/await parsing\n    stashed = None\n    async_def = False\n    async_def_indent = 0\n    async_def_nl = False\n\n    while 1:                                   # loop over lines in stream\n        try:\n            line = readline()\n        except StopIteration:\n            line = ''\n        lnum = lnum + 1\n        pos, max = 0, len(line)\n\n        if contstr:                            # continued string\n            if not line:\n                raise TokenError(\"EOF in multi-line string\", strstart)\n            endmatch = endprog.match(line)\n            if endmatch:\n                pos = end = endmatch.end(0)\n                yield (STRING, contstr + line[:end],\n                       strstart, (lnum, end), contline + line)\n                contstr, needcont = '', 0\n                contline = None\n            elif needcont and line[-2:] != '\\\\\\n' and line[-3:] != '\\\\\\r\\n':\n                yield (ERRORTOKEN, contstr + line,\n                           strstart, (lnum, len(line)), contline)\n                contstr = ''\n                contline = None\n                continue\n            else:\n                contstr = contstr + line\n                contline = contline + line\n                continue\n\n        elif parenlev == 0 and not continued:  # new statement\n            if not line: break\n            column = 0\n            while pos < max:                   # measure leading whitespace\n                if line[pos] == ' ': column = column + 1\n                elif line[pos] == '\\t': column = (column//tabsize + 1)*tabsize\n                elif line[pos] == '\\f': column = 0\n                else: break\n                pos = pos + 1\n            if pos == max: break\n\n            if stashed:\n                yield stashed\n                stashed = None\n\n            if line[pos] in '\\r\\n':            # skip blank lines\n                yield (NL, line[pos:], (lnum, pos), (lnum, len(line)), line)\n                continue\n\n            if line[pos] == '#':               # skip comments\n                comment_token = line[pos:].rstrip('\\r\\n')\n                nl_pos = pos + len(comment_token)\n                yield (COMMENT, comment_token,\n                        (lnum, pos), (lnum, pos + len(comment_token)), line)\n                yield (NL, line[nl_pos:],\n                        (lnum, nl_pos), (lnum, len(line)), line)\n                continue\n\n            if column > indents[-1]:           # count indents\n                indents.append(column)\n                yield (INDENT, line[:pos], (lnum, 0), (lnum, pos), line)\n\n            while column < indents[-1]:        # count dedents\n                if column not in indents:\n                    raise IndentationError(\n                        \"unindent does not match any outer indentation level\",\n                        (\"<tokenize>\", lnum, pos, line))\n                indents = indents[:-1]\n\n                if async_def and async_def_indent >= indents[-1]:\n                    async_def = False\n                    async_def_nl = False\n                    async_def_indent = 0\n\n                yield (DEDENT, '', (lnum, pos), (lnum, pos), line)\n\n            if async_def and async_def_nl and async_def_indent >= indents[-1]:\n                async_def = False\n                async_def_nl = False\n                async_def_indent = 0\n\n        else:                                  # continued statement\n            if not line:\n                raise TokenError(\"EOF in multi-line statement\", (lnum, 0))\n            continued = 0\n\n        while pos < max:\n            pseudomatch = pseudoprog.match(line, pos)\n            if pseudomatch:                                # scan for tokens\n                start, end = pseudomatch.span(1)\n                spos, epos, pos = (lnum, start), (lnum, end), end\n                token, initial = line[start:end], line[start]\n\n                if initial in numchars or \\\n                   (initial == '.' and token != '.'):      # ordinary number\n                    yield (NUMBER, token, spos, epos, line)\n                elif initial in '\\r\\n':\n                    newline = NEWLINE\n                    if parenlev > 0:\n                        newline = NL\n                    elif async_def:\n                        async_def_nl = True\n                    if stashed:\n                        yield stashed\n                        stashed = None\n                    yield (newline, token, spos, epos, line)\n\n                elif initial == '#':\n                    assert not token.endswith(\"\\n\")\n                    if stashed:\n                        yield stashed\n                        stashed = None\n                    yield (COMMENT, token, spos, epos, line)\n                elif token in triple_quoted:\n                    endprog = endprogs[token]\n                    endmatch = endprog.match(line, pos)\n                    if endmatch:                           # all on one line\n                        pos = endmatch.end(0)\n                        token = line[start:pos]\n                        if stashed:\n                            yield stashed\n                            stashed = None\n                        yield (STRING, token, spos, (lnum, pos), line)\n                    else:\n                        strstart = (lnum, start)           # multiple lines\n                        contstr = line[start:]\n                        contline = line\n                        break\n                elif initial in single_quoted or \\\n                    token[:2] in single_quoted or \\\n                    token[:3] in single_quoted:\n                    if token[-1] == '\\n':                  # continued string\n                        strstart = (lnum, start)\n                        endprog = (endprogs[initial] or endprogs[token[1]] or\n                                   endprogs[token[2]])\n                        contstr, needcont = line[start:], 1\n                        contline = line\n                        break\n                    else:                                  # ordinary string\n                        if stashed:\n                            yield stashed\n                            stashed = None\n                        yield (STRING, token, spos, epos, line)\n                elif (initial in namechars or              # ordinary name\n                      unicodedata.category(initial) in InitialCategories):\n                    if token in ('async', 'await'):\n                        if async_def:\n                            yield (ASYNC if token == 'async' else AWAIT,\n                                   token, spos, epos, line)\n                            continue\n\n                    tok = (NAME, token, spos, epos, line)\n                    if token == 'async' and not stashed:\n                        stashed = tok\n                        continue\n\n                    if token == 'def':\n                        if (stashed\n                                and stashed[0] == NAME\n                                and stashed[1] == 'async'):\n\n                            async_def = True\n                            async_def_indent = indents[-1]\n\n                            yield (ASYNC, stashed[1],\n                                   stashed[2], stashed[3],\n                                   stashed[4])\n                            stashed = None\n\n                    if stashed:\n                        yield stashed\n                        stashed = None\n\n                    yield tok\n                elif initial == '\\\\':                      # continued stmt\n                    # This yield is new; needed for better idempotency:\n                    if stashed:\n                        yield stashed\n                        stashed = None\n                    yield (NL, token, spos, (lnum, pos), line)\n                    continued = 1\n                else:\n                    if initial in '([{': parenlev = parenlev + 1\n                    elif initial in ')]}': parenlev = parenlev - 1\n                    if stashed:\n                        yield stashed\n                        stashed = None\n                    yield (OP, token, spos, epos, line)\n            else:\n                yield (ERRORTOKEN, line[pos],\n                           (lnum, pos), (lnum, pos+1), line)\n                pos = pos + 1\n\n    if stashed:\n        yield stashed\n        stashed = None\n\n    for indent in indents[1:]:                 # pop remaining indent levels\n        yield (DEDENT, '', (lnum, 0), (lnum, 0), '')\n    yield (ENDMARKER, '', (lnum, 0), (lnum, 0), '')",
        "begin_line": 339,
        "end_line": 565,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00980392156862745,
            "pseudo_dstar_susp": 0.009708737864077669,
            "pseudo_tarantula_susp": 0.009900990099009901,
            "pseudo_op2_susp": 0.009708737864077669,
            "pseudo_barinel_susp": 0.009900990099009901
        }
    }
]