[
    {
        "name": "luigi.date_interval.DateInterval.__init__#30",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__init__(self, date_a, date_b)",
        "snippet": "    def __init__(self, date_a, date_b):\n        # Represents all date d such that date_a <= d < date_b\n        self.date_a = date_a\n        self.date_b = date_b",
        "begin_line": 30,
        "end_line": 33,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012300123001230013,
            "pseudo_dstar_susp": 0.0012165450121654502,
            "pseudo_tarantula_susp": 0.0018832391713747645,
            "pseudo_op2_susp": 0.0012165450121654502,
            "pseudo_barinel_susp": 0.0018832391713747645
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.dates#35",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.dates(self)",
        "snippet": "    def dates(self):\n        dates = []\n        d = self.date_a\n        while d < self.date_b:\n            dates.append(d)\n            d += datetime.timedelta(1)\n\n        return dates",
        "begin_line": 35,
        "end_line": 42,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__str__#49",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__str__(self)",
        "snippet": "    def __str__(self):\n        return self.to_string()",
        "begin_line": 49,
        "end_line": 50,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005488474204171241,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__repr__#52",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__repr__(self)",
        "snippet": "    def __repr__(self):\n        return self.to_string()",
        "begin_line": 52,
        "end_line": 53,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005379236148466917,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.prev#55",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.prev(self)",
        "snippet": "    def prev(self):\n        return self.from_date(self.date_a - datetime.timedelta(1))",
        "begin_line": 55,
        "end_line": 56,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005488474204171241,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.next#58",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.next(self)",
        "snippet": "    def next(self):\n        return self.from_date(self.date_b)",
        "begin_line": 58,
        "end_line": 59,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.from_date#65",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.from_date(cls, d)",
        "snippet": "    def from_date(cls, d):\n        raise NotImplementedError",
        "begin_line": 65,
        "end_line": 66,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__hash__#79",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__hash__(self)",
        "snippet": "    def __hash__(self):\n        return hash(repr(self))",
        "begin_line": 79,
        "end_line": 80,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.00051440329218107,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__lt__#88",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__lt__(self, other)",
        "snippet": "    def __lt__(self, other):\n        if not isinstance(self, type(other)):\n            raise TypeError('Date interval type mismatch')\n        return (self.date_a, self.date_b) < (other.date_a, other.date_b)",
        "begin_line": 88,
        "end_line": 91,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__gt__#98",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__gt__(self, other)",
        "snippet": "    def __gt__(self, other):\n        if not isinstance(self, type(other)):\n            raise TypeError('Date interval type mismatch')\n        return (self.date_a, self.date_b) > (other.date_a, other.date_b)",
        "begin_line": 98,
        "end_line": 101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__eq__#108",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__eq__(self, other)",
        "snippet": "    def __eq__(self, other):\n        if not isinstance(other, DateInterval):\n            return False\n        if not isinstance(self, type(other)):\n            raise TypeError('Date interval type mismatch')\n        else:\n            return (self.date_a, self.date_b) == (other.date_a, other.date_b)",
        "begin_line": 108,
        "end_line": 114,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__ne__#116",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__ne__(self, other)",
        "snippet": "    def __ne__(self, other):\n        return not self.__eq__(other)",
        "begin_line": 116,
        "end_line": 117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.date_interval.Date.__init__#122",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Date",
        "signature": "luigi.date_interval.Date.__init__(self, y, m, d)",
        "snippet": "    def __init__(self, y, m, d):\n        a = datetime.date(y, m, d)\n        b = datetime.date(y, m, d) + datetime.timedelta(1)\n        super(Date, self).__init__(a, b)",
        "begin_line": 122,
        "end_line": 125,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.date_interval.Date.to_string#127",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Date",
        "signature": "luigi.date_interval.Date.to_string(self)",
        "snippet": "    def to_string(self):\n        return self.date_a.strftime('%Y-%m-%d')",
        "begin_line": 127,
        "end_line": 128,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.date_interval.Date.parse#135",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Date",
        "signature": "luigi.date_interval.Date.parse(cls, s)",
        "snippet": "    def parse(cls, s):\n        if re.match(r'\\d\\d\\d\\d\\-\\d\\d\\-\\d\\d$', s):\n            return Date(*map(int, s.split('-')))",
        "begin_line": 135,
        "end_line": 137,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.date_interval.Week.__init__#142",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Week",
        "signature": "luigi.date_interval.Week.__init__(self, y, w)",
        "snippet": "    def __init__(self, y, w):\n        # Python datetime does not have a method to convert from ISO weeks!\n        for d in xrange(-10, 370):\n            date = datetime.date(y, 1, 1) + datetime.timedelta(d)\n            if date.isocalendar() == (y, w, 1):\n                date_a = date\n                break\n        else:\n            raise ValueError('Invalid week')\n        date_b = date_a + datetime.timedelta(7)\n        super(Week, self).__init__(date_a, date_b)",
        "begin_line": 142,
        "end_line": 152,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.date_interval.Week.to_string#154",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Week",
        "signature": "luigi.date_interval.Week.to_string(self)",
        "snippet": "    def to_string(self):\n        return '%d-W%02d' % self.date_a.isocalendar()[:2]",
        "begin_line": 154,
        "end_line": 155,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.date_interval.Week.from_date#158",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Week",
        "signature": "luigi.date_interval.Week.from_date(cls, d)",
        "snippet": "    def from_date(cls, d):\n        return Week(*d.isocalendar()[:2])",
        "begin_line": 158,
        "end_line": 159,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.date_interval.Week.parse#162",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Week",
        "signature": "luigi.date_interval.Week.parse(cls, s)",
        "snippet": "    def parse(cls, s):\n        if re.match(r'\\d\\d\\d\\d\\-W\\d\\d$', s):\n            y, w = map(int, s.split('-W'))\n            return Week(y, w)",
        "begin_line": 162,
        "end_line": 165,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.date_interval.Month.__init__#170",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Month",
        "signature": "luigi.date_interval.Month.__init__(self, y, m)",
        "snippet": "    def __init__(self, y, m):\n        date_a = datetime.date(y, m, 1)\n        date_b = datetime.date(y + m // 12, 1 + m % 12, 1)\n        super(Month, self).__init__(date_a, date_b)",
        "begin_line": 170,
        "end_line": 173,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00423728813559322,
            "pseudo_dstar_susp": 0.001639344262295082,
            "pseudo_tarantula_susp": 0.0064516129032258064,
            "pseudo_op2_susp": 0.001639344262295082,
            "pseudo_barinel_susp": 0.0064516129032258064
        }
    },
    {
        "name": "luigi.date_interval.Month.to_string#175",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Month",
        "signature": "luigi.date_interval.Month.to_string(self)",
        "snippet": "    def to_string(self):\n        return self.date_a.strftime('%Y-%m')",
        "begin_line": 175,
        "end_line": 176,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.date_interval.Month.parse#183",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Month",
        "signature": "luigi.date_interval.Month.parse(cls, s)",
        "snippet": "    def parse(cls, s):\n        if re.match(r'\\d\\d\\d\\d\\-\\d\\d$', s):\n            y, m = map(int, s.split('-'))\n            return Month(y, m)",
        "begin_line": 183,
        "end_line": 186,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.date_interval.Year.__init__#191",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Year",
        "signature": "luigi.date_interval.Year.__init__(self, y)",
        "snippet": "    def __init__(self, y):\n        date_a = datetime.date(y, 1, 1)\n        date_b = datetime.date(y + 1, 1, 1)\n        super(Year, self).__init__(date_a, date_b)",
        "begin_line": 191,
        "end_line": 194,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.date_interval.Year.to_string#196",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Year",
        "signature": "luigi.date_interval.Year.to_string(self)",
        "snippet": "    def to_string(self):\n        return self.date_a.strftime('%Y')",
        "begin_line": 196,
        "end_line": 197,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.date_interval.Year.parse#204",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Year",
        "signature": "luigi.date_interval.Year.parse(cls, s)",
        "snippet": "    def parse(cls, s):\n        if re.match(r'\\d\\d\\d\\d$', s):\n            return Year(int(s))",
        "begin_line": 204,
        "end_line": 206,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.date_interval.Custom.parse#215",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Custom",
        "signature": "luigi.date_interval.Custom.parse(cls, s)",
        "snippet": "    def parse(cls, s):\n        if re.match('\\d\\d\\d\\d\\-\\d\\d\\-\\d\\d\\-\\d\\d\\d\\d\\-\\d\\d\\-\\d\\d$', s):\n            # Actually the ISO 8601 specifies <start>/<end> as the time interval format\n            # Not sure if this goes for date intervals as well. In any case slashes will\n            # most likely cause problems with paths etc.\n            x = list(map(int, s.split('-')))\n            date_a = datetime.date(*x[:3])\n            date_b = datetime.date(*x[3:])\n            return Custom(date_a, date_b)",
        "begin_line": 215,
        "end_line": 223,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.get_all_data#38",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.get_all_data(self)",
        "snippet": "    def get_all_data(self):\n        # This starts a server in the background, so we don't want to do it in the global scope\n        if MockFileSystem._data is None:\n            MockFileSystem._data = multiprocessing.Manager().dict()\n        return MockFileSystem._data",
        "begin_line": 38,
        "end_line": 42,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005379236148466917,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.get_data#44",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.get_data(self, fn)",
        "snippet": "    def get_data(self, fn):\n        return self.get_all_data()[fn]",
        "begin_line": 44,
        "end_line": 45,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.exists#47",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.exists(self, path)",
        "snippet": "    def exists(self, path):\n        return MockFile(path).exists()",
        "begin_line": 47,
        "end_line": 48,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.remove#50",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.remove(self, path, recursive=True, skip_trash=True)",
        "snippet": "    def remove(self, path, recursive=True, skip_trash=True):\n        \"\"\"\n        Removes the given mockfile. skip_trash doesn't have any meaning.\n        \"\"\"\n        if recursive:\n            to_delete = []\n            for s in self.get_all_data().keys():\n                if s.startswith(path):\n                    to_delete.append(s)\n            for s in to_delete:\n                self.get_all_data().pop(s)\n        else:\n            self.get_all_data().pop(path)",
        "begin_line": 50,
        "end_line": 62,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.listdir#64",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.listdir(self, path)",
        "snippet": "    def listdir(self, path):\n        \"\"\"\n        listdir does a prefix match of self.get_all_data(), but doesn't yet support globs.\n        \"\"\"\n        return [s for s in self.get_all_data().keys()\n                if s.startswith(path)]",
        "begin_line": 64,
        "end_line": 69,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.clear#77",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.clear(self)",
        "snippet": "    def clear(self):\n        self.get_all_data().clear()",
        "begin_line": 77,
        "end_line": 78,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004478280340349306,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.mock.MockFile.__init__#84",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFile",
        "signature": "luigi.mock.MockFile.__init__(self, fn, is_tmp=None, mirror_on_stderr=False)",
        "snippet": "    def __init__(self, fn, is_tmp=None, mirror_on_stderr=False):\n        self._mirror_on_stderr = mirror_on_stderr\n        self._fn = fn",
        "begin_line": 84,
        "end_line": 86,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004284490145672665,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.mock.MockFile.exists#88",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFile",
        "signature": "luigi.mock.MockFile.exists(self)",
        "snippet": "    def exists(self,):\n        return self._fn in self.fs.get_all_data()",
        "begin_line": 88,
        "end_line": 89,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.00043271311120726956,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.mock.MockFile.path#99",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFile",
        "signature": "luigi.mock.MockFile.path(self)",
        "snippet": "    def path(self):\n        return self._fn",
        "begin_line": 99,
        "end_line": 100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.mock.MockFile.open#102",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFile",
        "signature": "luigi.mock.MockFile.open(self, mode)",
        "snippet": "    def open(self, mode):\n        fn = self._fn\n\n        class StringBuffer(StringIO):\n            # Just to be able to do writing + reading from the same buffer\n\n            _write_line = True\n\n            def write(self2, data):\n                if self._mirror_on_stderr:\n                    if self2._write_line:\n                        sys.stderr.write(fn + \": \")\n                    sys.stderr.write(data)\n                    if (data[-1]) == '\\n':\n                        self2._write_line = True\n                    else:\n                        self2._write_line = False\n                StringIO.write(self2, data)\n\n            def close(self2):\n                if 'w' in mode:\n                    self.fs.get_all_data()[fn] = self2.getvalue()\n                StringIO.close(self2)\n\n            def __exit__(self, exc_type, exc_val, exc_tb):\n                if not exc_type:\n                    self.close()\n\n            def __enter__(self):\n                return self\n\n        class BinaryBuffer(BytesIO):\n            # Just to be able to do writing + reading from the same buffer\n\n            def write(self2, data):\n                if self._mirror_on_stderr:\n                    self2.seek(-1, os.SEEK_END)\n                    if self2.tell() <= 0 or self2.read(1) == '\\n':\n                        sys.stderr.write(fn + \": \")\n                    sys.stderr.write(data)\n                BytesIO.write(self2, data)\n\n            def close(self2):\n                if 'w' in mode:\n                    self.fs.get_all_data()[fn] = self2.getvalue()\n                BytesIO.close(self2)\n\n            def __exit__(self, exc_type, exc_val, exc_tb):\n                if not exc_type:\n                    self.close()\n\n            def __enter__(self):\n                return self\n\n        char_mode = target.get_char_mode(mode)\n        if char_mode == 't':\n            atomic_type = StringBuffer\n        else:\n            atomic_type = BinaryBuffer\n\n        if 'w' in mode:\n            return atomic_type()\n        else:\n            return atomic_type(self.fs.get_all_data()[fn])",
        "begin_line": 102,
        "end_line": 165,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005488474204171241,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.mock.StringBuffer.open#102",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.StringBuffer",
        "signature": "luigi.mock.StringBuffer.open(self, mode)",
        "snippet": "    def open(self, mode):\n        fn = self._fn\n\n        class StringBuffer(StringIO):\n            # Just to be able to do writing + reading from the same buffer\n\n            _write_line = True\n\n            def write(self2, data):\n                if self._mirror_on_stderr:\n                    if self2._write_line:\n                        sys.stderr.write(fn + \": \")\n                    sys.stderr.write(data)\n                    if (data[-1]) == '\\n':\n                        self2._write_line = True\n                    else:\n                        self2._write_line = False\n                StringIO.write(self2, data)\n\n            def close(self2):\n                if 'w' in mode:\n                    self.fs.get_all_data()[fn] = self2.getvalue()\n                StringIO.close(self2)\n\n            def __exit__(self, exc_type, exc_val, exc_tb):\n                if not exc_type:\n                    self.close()\n\n            def __enter__(self):\n                return self\n\n        class BinaryBuffer(BytesIO):\n            # Just to be able to do writing + reading from the same buffer\n\n            def write(self2, data):\n                if self._mirror_on_stderr:\n                    self2.seek(-1, os.SEEK_END)\n                    if self2.tell() <= 0 or self2.read(1) == '\\n':\n                        sys.stderr.write(fn + \": \")\n                    sys.stderr.write(data)\n                BytesIO.write(self2, data)\n\n            def close(self2):\n                if 'w' in mode:\n                    self.fs.get_all_data()[fn] = self2.getvalue()\n                BytesIO.close(self2)\n\n            def __exit__(self, exc_type, exc_val, exc_tb):\n                if not exc_type:\n                    self.close()\n\n            def __enter__(self):\n                return self\n\n        char_mode = target.get_char_mode(mode)\n        if char_mode == 't':\n            atomic_type = StringBuffer\n        else:\n            atomic_type = BinaryBuffer\n\n        if 'w' in mode:\n            return atomic_type()\n        else:\n            return atomic_type(self.fs.get_all_data()[fn])",
        "begin_line": 102,
        "end_line": 165,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004314063848144953,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.mock.StringBuffer.write#110",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.StringBuffer",
        "signature": "luigi.mock.StringBuffer.write(self2, data)",
        "snippet": "            def write(self2, data):\n                if self._mirror_on_stderr:\n                    if self2._write_line:\n                        sys.stderr.write(fn + \": \")\n                    sys.stderr.write(data)\n                    if (data[-1]) == '\\n':\n                        self2._write_line = True\n                    else:\n                        self2._write_line = False\n                StringIO.write(self2, data)",
        "begin_line": 110,
        "end_line": 119,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.mock.StringBuffer.close#121",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.StringBuffer",
        "signature": "luigi.mock.StringBuffer.close(self2)",
        "snippet": "            def close(self2):\n                if 'w' in mode:\n                    self.fs.get_all_data()[fn] = self2.getvalue()\n                StringIO.close(self2)",
        "begin_line": 121,
        "end_line": 124,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004657661853749418,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.mock.StringBuffer.__exit__#126",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.StringBuffer",
        "signature": "luigi.mock.StringBuffer.__exit__(self, exc_type, exc_val, exc_tb)",
        "snippet": "            def __exit__(self, exc_type, exc_val, exc_tb):\n                if not exc_type:\n                    self.close()",
        "begin_line": 126,
        "end_line": 128,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004784688995215311,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.mock.StringBuffer.__enter__#130",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.StringBuffer",
        "signature": "luigi.mock.StringBuffer.__enter__(self)",
        "snippet": "            def __enter__(self):\n                return self",
        "begin_line": 130,
        "end_line": 131,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005652911249293386,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.mock.BinaryBuffer.open#102",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.BinaryBuffer",
        "signature": "luigi.mock.BinaryBuffer.open(self, mode)",
        "snippet": "    def open(self, mode):\n        fn = self._fn\n\n        class StringBuffer(StringIO):\n            # Just to be able to do writing + reading from the same buffer\n\n            _write_line = True\n\n            def write(self2, data):\n                if self._mirror_on_stderr:\n                    if self2._write_line:\n                        sys.stderr.write(fn + \": \")\n                    sys.stderr.write(data)\n                    if (data[-1]) == '\\n':\n                        self2._write_line = True\n                    else:\n                        self2._write_line = False\n                StringIO.write(self2, data)\n\n            def close(self2):\n                if 'w' in mode:\n                    self.fs.get_all_data()[fn] = self2.getvalue()\n                StringIO.close(self2)\n\n            def __exit__(self, exc_type, exc_val, exc_tb):\n                if not exc_type:\n                    self.close()\n\n            def __enter__(self):\n                return self\n\n        class BinaryBuffer(BytesIO):\n            # Just to be able to do writing + reading from the same buffer\n\n            def write(self2, data):\n                if self._mirror_on_stderr:\n                    self2.seek(-1, os.SEEK_END)\n                    if self2.tell() <= 0 or self2.read(1) == '\\n':\n                        sys.stderr.write(fn + \": \")\n                    sys.stderr.write(data)\n                BytesIO.write(self2, data)\n\n            def close(self2):\n                if 'w' in mode:\n                    self.fs.get_all_data()[fn] = self2.getvalue()\n                BytesIO.close(self2)\n\n            def __exit__(self, exc_type, exc_val, exc_tb):\n                if not exc_type:\n                    self.close()\n\n            def __enter__(self):\n                return self\n\n        char_mode = target.get_char_mode(mode)\n        if char_mode == 't':\n            atomic_type = StringBuffer\n        else:\n            atomic_type = BinaryBuffer\n\n        if 'w' in mode:\n            return atomic_type()\n        else:\n            return atomic_type(self.fs.get_all_data()[fn])",
        "begin_line": 102,
        "end_line": 165,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.00043346337234503684,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.mock.BinaryBuffer.write#136",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.BinaryBuffer",
        "signature": "luigi.mock.BinaryBuffer.write(self2, data)",
        "snippet": "            def write(self2, data):\n                if self._mirror_on_stderr:\n                    self2.seek(-1, os.SEEK_END)\n                    if self2.tell() <= 0 or self2.read(1) == '\\n':\n                        sys.stderr.write(fn + \": \")\n                    sys.stderr.write(data)\n                BytesIO.write(self2, data)",
        "begin_line": 136,
        "end_line": 142,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004409171075837742,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.mock.BinaryBuffer.close#144",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.BinaryBuffer",
        "signature": "luigi.mock.BinaryBuffer.close(self2)",
        "snippet": "            def close(self2):\n                if 'w' in mode:\n                    self.fs.get_all_data()[fn] = self2.getvalue()\n                BytesIO.close(self2)",
        "begin_line": 144,
        "end_line": 147,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005488474204171241,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.mock.BinaryBuffer.__exit__#149",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.BinaryBuffer",
        "signature": "luigi.mock.BinaryBuffer.__exit__(self, exc_type, exc_val, exc_tb)",
        "snippet": "            def __exit__(self, exc_type, exc_val, exc_tb):\n                if not exc_type:\n                    self.close()",
        "begin_line": 149,
        "end_line": 151,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004332755632582322,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.mock.BinaryBuffer.__enter__#153",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.BinaryBuffer",
        "signature": "luigi.mock.BinaryBuffer.__enter__(self)",
        "snippet": "            def __enter__(self):\n                return self",
        "begin_line": 153,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005488474204171241,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.spark.SparkRunContext.__init__#56",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkRunContext",
        "signature": "luigi.contrib.spark.SparkRunContext.__init__(self)",
        "snippet": "    def __init__(self):\n        self.app_id = None",
        "begin_line": 56,
        "end_line": 57,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005652911249293386,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.spark.SparkRunContext.__enter__#59",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkRunContext",
        "signature": "luigi.contrib.spark.SparkRunContext.__enter__(self)",
        "snippet": "    def __enter__(self):\n        self.__old_signal = signal.getsignal(signal.SIGTERM)\n        signal.signal(signal.SIGTERM, self.kill_job)\n        return self",
        "begin_line": 59,
        "end_line": 62,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005652911249293386,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.spark.SparkRunContext.__exit__#79",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkRunContext",
        "signature": "luigi.contrib.spark.SparkRunContext.__exit__(self, exc_type, exc_val, exc_tb)",
        "snippet": "    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is KeyboardInterrupt:\n            self.kill_job()\n        signal.signal(signal.SIGTERM, self.__old_signal)",
        "begin_line": 79,
        "end_line": 82,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005488474204171241,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.spark.SparkJobError.__init__#87",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkJobError",
        "signature": "luigi.contrib.spark.SparkJobError.__init__(self, message, out=None, err=None)",
        "snippet": "    def __init__(self, message, out=None, err=None):\n        super(SparkJobError, self).__init__(message, out, err)\n        self.message = message\n        self.out = out\n        self.err = err",
        "begin_line": 87,
        "end_line": 91,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.spark.SparkJob.run#140",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkJob",
        "signature": "luigi.contrib.spark.SparkJob.run(self)",
        "snippet": "    def run(self):\n        original_output_path = self.output().path\n        path_no_slash = original_output_path[:-2] if original_output_path.endswith('/*') else original_output_path\n        path_no_slash = original_output_path[:-1] if original_output_path[-1] == '/' else path_no_slash\n        tmp_output = luigi.hdfs.HdfsTarget(path_no_slash + '-luigi-tmp-%09d' % random.randrange(0, 1e10))\n\n        args = ['org.apache.spark.deploy.yarn.Client']\n        args += ['--jar', self.jar()]\n        args += ['--class', self.job_class()]\n\n        for a in self.job_args():\n            if a == self.output().path:\n                # pass temporary output path to job args\n                logger.info('Using temp path: %s for path %s', tmp_output.path, original_output_path)\n                args += ['--args', tmp_output.path]\n            else:\n                args += ['--args', str(a)]\n\n        if self.spark_workers is not None:\n            args += ['--num-workers', self.spark_workers]\n\n        if self.spark_master_memory is not None:\n            args += ['--master-memory', self.spark_master_memory]\n\n        if self.spark_worker_memory is not None:\n            args += ['--worker-memory', self.spark_worker_memory]\n\n        queue = self.queue\n        if queue is not None:\n            args += ['--queue', queue]\n\n        env = os.environ.copy()\n        env['SPARK_JAR'] = configuration.get_config().get('spark', 'spark-jar')\n        env['HADOOP_CONF_DIR'] = configuration.get_config().get('spark', 'hadoop-conf-dir')\n        env['MASTER'] = 'yarn-client'\n        spark_class = configuration.get_config().get('spark', 'spark-class')\n\n        temp_stderr = tempfile.TemporaryFile()\n        logger.info('Running: %s %s', spark_class, ' '.join(args))\n        proc = subprocess.Popen([spark_class] + args, stdout=subprocess.PIPE,\n                                stderr=temp_stderr, env=env, close_fds=True)\n\n        return_code, final_state, app_id = self.track_progress(proc)\n        if return_code == 0 and final_state != 'FAILED':\n            tmp_output.move(path_no_slash)\n        elif final_state == 'FAILED':\n            raise SparkJobError('Spark job failed: see yarn logs for %s' % app_id)\n        else:\n            temp_stderr.seek(0)\n            errors = \"\".join((x.decode('utf8') for x in temp_stderr.readlines()))\n            logger.error(errors)\n            raise SparkJobError('Spark job failed', err=errors)",
        "begin_line": 140,
        "end_line": 191,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.spark.SparkJob.track_progress#193",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkJob",
        "signature": "luigi.contrib.spark.SparkJob.track_progress(self, proc)",
        "snippet": "    def track_progress(self, proc):\n        # The Spark client currently outputs a multiline status to stdout every second\n        # while the application is running.  This instead captures status data and updates\n        # a single line of output until the application finishes.\n        app_id = None\n        app_status = 'N/A'\n        url = 'N/A'\n        final_state = None\n        start = time.time()\n        with SparkRunContext() as context:\n            while proc.poll() is None:\n                s = proc.stdout.readline()\n                app_id_s = re.compile('application identifier: (\\w+)').search(s)\n                if app_id_s:\n                    app_id = app_id_s.group(1)\n                    context.app_id = app_id\n                app_status_s = re.compile('yarnAppState: (\\w+)').search(s)\n                if app_status_s:\n                    app_status = app_status_s.group(1)\n                url_s = re.compile('appTrackingUrl: (.+)').search(s)\n                if url_s:\n                    url = url_s.group(1)\n                final_state_s = re.compile('distributedFinalState: (\\w+)').search(s)\n                if final_state_s:\n                    final_state = final_state_s.group(1)\n                if not app_id:\n                    logger.info(s.strip())\n                else:\n                    elapsed_mins, elapsed_secs = divmod(datetime.timedelta(seconds=time.time() - start).seconds, 60)\n                    status = '[%0d:%02d] Status: %s Tracking: %s' % (elapsed_mins, elapsed_secs, app_status, url)\n                    sys.stdout.write(\"\\r\\x1b[K\" + status)\n                    sys.stdout.flush()\n        logger.info(proc.communicate()[0])\n        return proc.returncode, final_state, app_id",
        "begin_line": 193,
        "end_line": 226,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.spark.Spark1xJob.dependency_jars#243",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.Spark1xJob",
        "signature": "luigi.contrib.spark.Spark1xJob.dependency_jars(self)",
        "snippet": "    def dependency_jars(self):\n        \"\"\"\n        Override to provide a list of dependency jars.\n        \"\"\"\n        return []",
        "begin_line": 243,
        "end_line": 247,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.spark.Spark1xJob.spark_options#252",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.Spark1xJob",
        "signature": "luigi.contrib.spark.Spark1xJob.spark_options(self)",
        "snippet": "    def spark_options(self):\n        return []",
        "begin_line": 252,
        "end_line": 253,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.spark.Spark1xJob.job_args#255",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.Spark1xJob",
        "signature": "luigi.contrib.spark.Spark1xJob.job_args(self)",
        "snippet": "    def job_args(self):\n        return []",
        "begin_line": 255,
        "end_line": 256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.spark.Spark1xJob.run#264",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.Spark1xJob",
        "signature": "luigi.contrib.spark.Spark1xJob.run(self)",
        "snippet": "    def run(self):\n        spark_submit = configuration.get_config().get('spark', 'spark-submit',\n                                                      'spark-submit')\n        options = [\n            '--class', self.job_class(),\n        ]\n        if self.num_executors is not None:\n            options += ['--num-executors', self.num_executors]\n        if self.driver_memory is not None:\n            options += ['--driver-memory', self.driver_memory]\n        if self.executor_memory is not None:\n            options += ['--executor-memory', self.executor_memory]\n        if self.executor_cores is not None:\n            options += ['--executor-cores', self.executor_cores]\n        if self.deploy_mode is not None:\n            options += ['--deploy-mode', self.deploy_mode]\n        if self.queue is not None:\n            options += ['--queue', self.queue]\n        if self.spark_master is not None:\n            options += ['--master', self.spark_master]\n        dependency_jars = self.dependency_jars()\n        if dependency_jars != []:\n            options += ['--jars', ','.join(dependency_jars)]\n        args = [spark_submit] + options + self.spark_options() + \\\n            [self.jar()] + list(self.job_args())\n        args = map(str, args)\n        env = os.environ.copy()\n        temp_stderr = tempfile.TemporaryFile()\n        logger.info('Running: %s', repr(args))\n        proc = subprocess.Popen(args, stdout=subprocess.PIPE,\n                                stderr=temp_stderr, env=env, close_fds=True)\n        return_code, final_state, app_id = self.track_progress(proc)\n        if final_state == 'FAILED':\n            raise SparkJobError('Spark job failed: see yarn logs for {0}'\n                                .format(app_id))\n        elif return_code != 0:\n            temp_stderr.seek(0)\n            errors = \"\".join((x.decode('utf8') for x in temp_stderr.readlines()))\n            logger.error(errors)\n            raise SparkJobError('Spark job failed', err=errors)",
        "begin_line": 264,
        "end_line": 303,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.spark.Spark1xJob.track_progress#305",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.Spark1xJob",
        "signature": "luigi.contrib.spark.Spark1xJob.track_progress(self, proc)",
        "snippet": "    def track_progress(self, proc):\n        \"\"\"\n        The Spark client currently outputs a multiline status to stdout every second while the application is running.\n\n        This instead captures status data and updates a single line of output until the application finishes.\n        \"\"\"\n        app_id = None\n        app_status = 'N/A'\n        url = 'N/A'\n        final_state = None\n        start = time.time()\n        re_app_id = re.compile('application identifier: (\\w+)')\n        re_app_status = re.compile('yarnAppState: (\\w+)')\n        re_url = re.compile('appTrackingUrl: (.+)')\n        re_final_state = re.compile('distributedFinalState: (\\w+)')\n        with SparkRunContext() as context:\n            while proc.poll() is None:\n                s = proc.stdout.readline()\n                app_id_s = re_app_id.search(s)\n                if app_id_s:\n                    app_id = app_id_s.group(1)\n                    context.app_id = app_id\n                app_status_s = re_app_status.search(s)\n                if app_status_s:\n                    app_status = app_status_s.group(1)\n                url_s = re_url.search(s)\n                if url_s:\n                    url = url_s.group(1)\n                final_state_s = re_final_state.search(s)\n                if final_state_s:\n                    final_state = final_state_s.group(1)\n                if not app_id:\n                    logger.info(s.strip())\n                else:\n                    t_diff = time.time() - start\n                    elapsed_mins, elapsed_secs = divmod(t_diff, 60)\n                    status = ('[%0d:%02d] Status: %s Tracking: %s' %\n                              (elapsed_mins, elapsed_secs, app_status, url))\n                    sys.stdout.write(\"\\r\\x1b[K\" + status)\n                    sys.stdout.flush()\n                self.spark_heartbeat(s, context)\n        logger.info(proc.communicate()[0])\n        return proc.returncode, final_state, app_id",
        "begin_line": 305,
        "end_line": 347,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.spark.PySpark1xJob.py_files#360",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySpark1xJob",
        "signature": "luigi.contrib.spark.PySpark1xJob.py_files(self)",
        "snippet": "    def py_files(self):\n        \"\"\"\n        Override to provide a list of py files.\n        \"\"\"\n        return []",
        "begin_line": 360,
        "end_line": 364,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.spark.PySpark1xJob.run#366",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySpark1xJob",
        "signature": "luigi.contrib.spark.PySpark1xJob.run(self)",
        "snippet": "    def run(self):\n        spark_submit = configuration.get_config().get('spark', 'spark-submit',\n                                                      'spark-submit')\n        options = ['--master', 'yarn-client']\n        if self.num_executors is not None:\n            options += ['--num-executors', self.num_executors]\n        if self.driver_memory is not None:\n            options += ['--driver-memory', self.driver_memory]\n        if self.executor_memory is not None:\n            options += ['--executor-memory', self.executor_memory]\n        if self.executor_cores is not None:\n            options += ['--executor-cores', self.executor_cores]\n        py_files = self.py_files()\n        if py_files != []:\n            options += ['--py-files', ','.join(py_files)]\n        args = [spark_submit] + options + self.spark_options() + \\\n            [self.program()] + list(self.job_args())\n        args = map(str, args)\n        env = os.environ.copy()\n        temp_stderr = tempfile.TemporaryFile()\n        logger.info('Running: %s', repr(args))\n        proc = subprocess.Popen(args, stdout=subprocess.PIPE,\n                                stderr=temp_stderr, env=env, close_fds=True)\n        return_code, final_state, app_id = self.track_progress(proc)\n        if final_state == 'FAILED':\n            raise SparkJobError('Spark job failed: see yarn logs for %s', app_id)\n        elif return_code != 0:\n            temp_stderr.seek(0)\n            errors = \"\".join((x.decode('utf8') for x in temp_stderr.readlines()))\n            logger.error(errors)\n            raise SparkJobError('Spark job failed', err=errors)",
        "begin_line": 366,
        "end_line": 396,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.s3.S3Client.__init__#72",
        "src_path": "luigi/s3.py",
        "class_name": "luigi.s3.S3Client",
        "signature": "luigi.s3.S3Client.__init__(self, aws_access_key_id=None, aws_secret_access_key=None, **kwargs)",
        "snippet": "    def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,\n                 **kwargs):\n        options = self._get_s3_config()\n        options.update(kwargs)\n        # Removing key args would break backwards compability\n        if not aws_access_key_id:\n            aws_access_key_id = options.get('aws_access_key_id')\n        if not aws_secret_access_key:\n            aws_secret_access_key = options.get('aws_secret_access_key')\n        for key in ['aws_access_key_id', 'aws_secret_access_key']:\n            if key in options:\n                options.pop(key)\n        self.s3 = boto.connect_s3(aws_access_key_id,\n                                  aws_secret_access_key,\n                                  **options)",
        "begin_line": 72,
        "end_line": 86,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005076142131979695,
            "pseudo_dstar_susp": 0.0017006802721088435,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.0017006802721088435,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.s3.S3Client._get_s3_config#311",
        "src_path": "luigi/s3.py",
        "class_name": "luigi.s3.S3Client",
        "signature": "luigi.s3.S3Client._get_s3_config(self, key=None)",
        "snippet": "    def _get_s3_config(self, key=None):\n        try:\n            config = dict(configuration.get_config().items('s3'))\n        except NoSectionError:\n            return {}\n        # So what ports etc can be read without us having to specify all dtypes\n        for k, v in six.iteritems(config):\n            try:\n                config[k] = int(v)\n            except ValueError:\n                pass\n        if key:\n            return config.get(key)\n        return config",
        "begin_line": 311,
        "end_line": 324,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005076142131979695,
            "pseudo_dstar_susp": 0.0017006802721088435,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.0017006802721088435,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.process.check_pid#30",
        "src_path": "luigi/process.py",
        "class_name": "luigi.process",
        "signature": "luigi.process.check_pid(pidfile)",
        "snippet": "def check_pid(pidfile):\n    if pidfile and os.path.exists(pidfile):\n        try:\n            pid = int(open(pidfile).read().strip())\n            os.kill(pid, 0)\n            return pid\n        except BaseException:\n            return 0\n    return 0",
        "begin_line": 30,
        "end_line": 38,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006993006993006993,
            "pseudo_dstar_susp": 0.0019193857965451055,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.0019193857965451055,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.process.get_log_format#51",
        "src_path": "luigi/process.py",
        "class_name": "luigi.process",
        "signature": "luigi.process.get_log_format()",
        "snippet": "def get_log_format():\n    return \"%(asctime)s %(name)s[%(process)s] %(levelname)s: %(message)s\"",
        "begin_line": 51,
        "end_line": 52,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.018867924528301886,
            "pseudo_dstar_susp": 0.0034602076124567475,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.0034602076124567475,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.process.get_spool_handler#55",
        "src_path": "luigi/process.py",
        "class_name": "luigi.process",
        "signature": "luigi.process.get_spool_handler(filename)",
        "snippet": "def get_spool_handler(filename):\n    handler = logging.handlers.TimedRotatingFileHandler(\n        filename=filename,\n        when='d',\n        encoding='utf8',\n        backupCount=7  # keep one week of historical logs\n    )\n    formatter = logging.Formatter(get_log_format())\n    handler.setFormatter(formatter)\n    return handler",
        "begin_line": 55,
        "end_line": 64,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006993006993006993,
            "pseudo_dstar_susp": 0.0019193857965451055,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.0019193857965451055,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.process.daemonize#74",
        "src_path": "luigi/process.py",
        "class_name": "luigi.process",
        "signature": "luigi.process.daemonize(cmd, pidfile=None, logdir=None, api_port=8082, address=None)",
        "snippet": "def daemonize(cmd, pidfile=None, logdir=None, api_port=8082, address=None):\n    import daemon\n\n    logdir = logdir or \"/var/log/luigi\"\n    if not os.path.exists(logdir):\n        os.makedirs(logdir)\n\n    log_path = os.path.join(logdir, \"luigi-server.log\")\n\n    # redirect stdout/stderr\n    today = datetime.date.today()\n    stdout_path = os.path.join(\n        logdir,\n        \"luigi-server-{0:%Y-%m-%d}.out\".format(today)\n    )\n    stderr_path = os.path.join(\n        logdir,\n        \"luigi-server-{0:%Y-%m-%d}.err\".format(today)\n    )\n    stdout_proxy = open(stdout_path, 'a+')\n    stderr_proxy = open(stderr_path, 'a+')\n\n    ctx = daemon.DaemonContext(\n        stdout=stdout_proxy,\n        stderr=stderr_proxy,\n        working_directory='.'\n    )\n\n    with ctx:\n        loghandler = get_spool_handler(log_path)\n        rootlogger.addHandler(loghandler)\n\n        if pidfile:\n            server_logger.info(\"Checking pid file\")\n            existing_pid = check_pid(pidfile)\n            if pidfile and existing_pid:\n                server_logger.info(\"Server already running (pid=%s)\", existing_pid)\n                return\n            write_pid(pidfile)\n\n        cmd(api_port=api_port, address=address)",
        "begin_line": 74,
        "end_line": 114,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006993006993006993,
            "pseudo_dstar_susp": 0.0019193857965451055,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.0019193857965451055,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.process.fork_linked_workers#117",
        "src_path": "luigi/process.py",
        "class_name": "luigi.process",
        "signature": "luigi.process.fork_linked_workers(num_processes)",
        "snippet": "def fork_linked_workers(num_processes):\n    \"\"\"\n    Forks num_processes child processes.\n\n    Returns an id between 0 and num_processes - 1 for each child process.\n    Will consume the parent process and kill it and all child processes as soon as one child exits with status 0\n\n    If a child dies with exist status != 0 it will be restarted.\n    TODO: If the parent is force-terminated (kill -9) the child processes will terminate after a while when they notice it.\n    \"\"\"\n\n    children = {}  # keep child indices\n\n    def shutdown_handler(signum=None, frame=None):\n        print(\"Parent shutting down. Killing ALL THE children\")\n        if not signum:\n            signum = signal.SIGTERM\n        for c in children:\n            print(\"Killing child %d\" % c)\n            try:\n                os.kill(c, signum)\n                os.waitpid(c, 0)\n            except OSError:\n                print(\"Child %d is already dead\" % c)\n        os._exit(0)  # exit without calling exit handler again...\n\n    sigs = [signal.SIGINT, signal.SIGTERM, signal.SIGQUIT]\n    for s in sigs:\n        signal.signal(s, shutdown_handler)\n        signal.signal(s, shutdown_handler)\n        signal.signal(s, shutdown_handler)\n    # haven't found a way to unregister: atexit.register(shutdown_handler) #\n\n    def fork_child(child_id, attempt):\n        child_pid = os.fork()\n\n        if not child_pid:\n            random.seed(os.getpid())\n            for s in sigs:\n                signal.signal(s, signal.SIG_DFL)  # only want these signal handlers in the parent process\n            return True  # in child\n\n        children[child_pid] = (child_id, attempt)\n        return False  # in parent\n\n    for i in xrange(num_processes):\n        child_id = len(children)\n        if fork_child(child_id, 0):\n            return child_id, 0\n\n    assert len(children) == num_processes\n\n    while True:\n        pid, status = os.wait()\n        if status != 0:\n            # unclean exit, restart process\n            child_id, last_attempt = children.pop(pid)\n            attempt = last_attempt + 1\n            if fork_child(child_id, attempt):\n                return child_id, attempt\n        else:\n            shutdown_handler()\n            exit(0)",
        "begin_line": 117,
        "end_line": 179,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002770083102493075,
            "pseudo_dstar_susp": 0.0013157894736842105,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.0013157894736842105,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory._session#43",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory._session(self, session=None)",
        "snippet": "    def _session(self, session=None):\n        if session:\n            yield session\n        else:\n            session = self.session_factory()\n            try:\n                yield session\n            except:\n                session.rollback()\n                raise\n            else:\n                session.commit()",
        "begin_line": 43,
        "end_line": 54,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0045871559633027525,
            "pseudo_dstar_susp": 0.005747126436781609,
            "pseudo_tarantula_susp": 0.003787878787878788,
            "pseudo_op2_susp": 0.005747126436781609,
            "pseudo_barinel_susp": 0.003787878787878788
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory.__init__#56",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory.__init__(self)",
        "snippet": "    def __init__(self):\n        config = configuration.get_config()\n        connection_string = config.get('task_history', 'db_connection')\n        self.engine = sqlalchemy.create_engine(connection_string)\n        self.session_factory = sqlalchemy.orm.sessionmaker(bind=self.engine, expire_on_commit=False)\n        Base.metadata.create_all(self.engine)\n        self.tasks = {}  # task_id -> TaskRecord",
        "begin_line": 56,
        "end_line": 62,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0038461538461538464,
            "pseudo_dstar_susp": 0.004878048780487805,
            "pseudo_tarantula_susp": 0.003663003663003663,
            "pseudo_op2_susp": 0.004878048780487805,
            "pseudo_barinel_susp": 0.003663003663003663
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory.task_scheduled#64",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory.task_scheduled(self, task_id)",
        "snippet": "    def task_scheduled(self, task_id):\n        task = self._get_task(task_id, status=PENDING)\n        self._add_task_event(task, TaskEvent(event_name=PENDING, ts=datetime.datetime.now()))",
        "begin_line": 64,
        "end_line": 66,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003663003663003663,
            "pseudo_dstar_susp": 0.004807692307692308,
            "pseudo_tarantula_susp": 0.0035460992907801418,
            "pseudo_op2_susp": 0.004807692307692308,
            "pseudo_barinel_susp": 0.0035460992907801418
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory.task_finished#68",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory.task_finished(self, task_id, successful)",
        "snippet": "    def task_finished(self, task_id, successful):\n        event_name = DONE if successful else FAILED\n        task = self._get_task(task_id, status=event_name)\n        self._add_task_event(task, TaskEvent(event_name=event_name, ts=datetime.datetime.now()))",
        "begin_line": 68,
        "end_line": 71,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002770083102493075,
            "pseudo_dstar_susp": 0.0025575447570332483,
            "pseudo_tarantula_susp": 0.003115264797507788,
            "pseudo_op2_susp": 0.0025575447570332483,
            "pseudo_barinel_susp": 0.003115264797507788
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory.task_started#73",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory.task_started(self, task_id, worker_host)",
        "snippet": "    def task_started(self, task_id, worker_host):\n        task = self._get_task(task_id, status=RUNNING, host=worker_host)\n        self._add_task_event(task, TaskEvent(event_name=RUNNING, ts=datetime.datetime.now()))",
        "begin_line": 73,
        "end_line": 75,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024691358024691358,
            "pseudo_dstar_susp": 0.0015723270440251573,
            "pseudo_tarantula_susp": 0.00398406374501992,
            "pseudo_op2_susp": 0.0015723270440251573,
            "pseudo_barinel_susp": 0.00398406374501992
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory._get_task#77",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory._get_task(self, task_id, status, host=None)",
        "snippet": "    def _get_task(self, task_id, status, host=None):\n        if task_id in self.tasks:\n            task = self.tasks[task_id]\n            task.status = status\n            if host:\n                task.host = host\n        else:\n            task = self.tasks[task_id] = task_history.Task(task_id, status, host)\n        return task",
        "begin_line": 77,
        "end_line": 85,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024096385542168677,
            "pseudo_dstar_susp": 0.0015600624024961,
            "pseudo_tarantula_susp": 0.0035971223021582736,
            "pseudo_op2_susp": 0.0015600624024961,
            "pseudo_barinel_susp": 0.0035971223021582736
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory._add_task_event#87",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory._add_task_event(self, task, event)",
        "snippet": "    def _add_task_event(self, task, event):\n        for (task_record, session) in self._find_or_create_task(task):\n            task_record.events.append(event)",
        "begin_line": 87,
        "end_line": 89,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003703703703703704,
            "pseudo_dstar_susp": 0.00267379679144385,
            "pseudo_tarantula_susp": 0.0044444444444444444,
            "pseudo_op2_susp": 0.00267379679144385,
            "pseudo_barinel_susp": 0.0044444444444444444
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory._find_or_create_task#91",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory._find_or_create_task(self, task)",
        "snippet": "    def _find_or_create_task(self, task):\n        with self._session() as session:\n            if task.record_id is not None:\n                logger.debug(\"Finding task with record_id [%d]\", task.record_id)\n                task_record = session.query(TaskRecord).get(task.record_id)\n                if not task_record:\n                    raise Exception(\"Task with record_id, but no matching Task record!\")\n                yield (task_record, session)\n            else:\n                task_record = TaskRecord(name=task.task_family, host=task.host)\n                for (k, v) in six.iteritems(task.parameters):\n                    task_record.parameters[k] = TaskParameter(name=k, value=v)\n                session.add(task_record)\n                yield (task_record, session)\n            if task.host:\n                task_record.host = task.host\n        task.record_id = task_record.id",
        "begin_line": 91,
        "end_line": 107,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0035587188612099642,
            "pseudo_dstar_susp": 0.0047169811320754715,
            "pseudo_tarantula_susp": 0.004366812227074236,
            "pseudo_op2_susp": 0.0047169811320754715,
            "pseudo_barinel_susp": 0.004366812227074236
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory.find_all_by_parameters#109",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory.find_all_by_parameters(self, task_name, session=None, **task_params)",
        "snippet": "    def find_all_by_parameters(self, task_name, session=None, **task_params):\n        \"\"\"\n        Find tasks with the given task_name and the same parameters as the kwargs.\n        \"\"\"\n        with self._session(session) as session:\n            tasks = session.query(TaskRecord).join(TaskEvent).filter(TaskRecord.name == task_name).order_by(TaskEvent.ts).all()\n            for task in tasks:\n                if all(k in task.parameters and v == str(task.parameters[k].value) for (k, v) in six.iteritems(task_params)):\n                    yield task",
        "begin_line": 109,
        "end_line": 117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0035087719298245615,
            "pseudo_dstar_susp": 0.004694835680751174,
            "pseudo_tarantula_susp": 0.004201680672268907,
            "pseudo_op2_susp": 0.004694835680751174,
            "pseudo_barinel_susp": 0.004201680672268907
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory.find_all_by_name#119",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory.find_all_by_name(self, task_name, session=None)",
        "snippet": "    def find_all_by_name(self, task_name, session=None):\n        \"\"\"\n        Find all tasks with the given task_name.\n        \"\"\"\n        return self.find_all_by_parameters(task_name, session)",
        "begin_line": 119,
        "end_line": 123,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0033444816053511705,
            "pseudo_dstar_susp": 0.0016181229773462784,
            "pseudo_tarantula_susp": 0.005263157894736842,
            "pseudo_op2_susp": 0.0016181229773462784,
            "pseudo_barinel_susp": 0.005263157894736842
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler.__init__#47",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler.__init__(self, host='localhost', port=8082, connect_timeout=None)",
        "snippet": "    def __init__(self, host='localhost', port=8082, connect_timeout=None):\n        self._host = host\n        self._port = port\n\n        config = configuration.get_config()\n\n        if connect_timeout is None:\n            connect_timeout = config.getfloat('core', 'rpc-connect-timeout', 10.0)\n        self._connect_timeout = connect_timeout",
        "begin_line": 47,
        "end_line": 55,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0044444444444444444,
            "pseudo_dstar_susp": 0.001893939393939394,
            "pseudo_tarantula_susp": 0.0058823529411764705,
            "pseudo_op2_susp": 0.001893939393939394,
            "pseudo_barinel_susp": 0.0058823529411764705
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler._post#65",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler._post(self, url, data)",
        "snippet": "    def _post(self, url, data):\n        url = 'http://%s:%d%s' % (self._host, self._port, url)\n        return Request(url, urlencode(data).encode('utf8'))",
        "begin_line": 65,
        "end_line": 67,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.023255813953488372,
            "pseudo_dstar_susp": 0.00392156862745098,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.00392156862745098,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler._request#69",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler._request(self, url, data, log_exceptions=True, attempts=3)",
        "snippet": "    def _request(self, url, data, log_exceptions=True, attempts=3):\n        data = {'data': json.dumps(data)}\n\n        req = self._post(url, data)\n        last_exception = None\n        attempt = 0\n        while attempt < attempts:\n            attempt += 1\n            if last_exception:\n                logger.info(\"Retrying...\")\n                self._wait()  # wait for a bit and retry\n            try:\n                response = urlopen(req, None, self._connect_timeout)\n                break\n            except URLError as e:\n                last_exception = e\n                if isinstance(last_exception, HTTPError) and last_exception.code == 405:\n                    # TODO(f355): 2014-08-29 Remove this fallback after several weeks\n                    logger.warning(\"POST requests are unsupported. Please upgrade scheduler ASAP. Falling back to GET for now.\")\n                    req = self._get(url, data)\n                    last_exception = None\n                    attempt -= 1\n                elif log_exceptions:\n                    logger.exception(\"Failed connecting to remote scheduler %r\", self._host)\n                continue\n        else:\n            raise RPCError(\n                \"Errors (%d attempts) when connecting to remote scheduler %r\" %\n                (attempts, self._host),\n                last_exception\n            )\n        page = response.read().decode('utf8')\n        result = json.loads(page)\n        return result[\"response\"]",
        "begin_line": 69,
        "end_line": 102,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.023255813953488372,
            "pseudo_dstar_susp": 0.00392156862745098,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.00392156862745098,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler.ping#104",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler.ping(self, worker)",
        "snippet": "    def ping(self, worker):\n        # just one attemtps, keep-alive thread will keep trying anyway\n        self._request('/api/ping', {'worker': worker}, attempts=1)",
        "begin_line": 104,
        "end_line": 106,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002770083102493075,
            "pseudo_dstar_susp": 0.0013157894736842105,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.0013157894736842105,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.task_history.Task.__init__#33",
        "src_path": "luigi/task_history.py",
        "class_name": "luigi.task_history.Task",
        "signature": "luigi.task_history.Task.__init__(self, task_id, status, host=None)",
        "snippet": "    def __init__(self, task_id, status, host=None):\n        self.task_family, self.parameters = task.id_to_name_and_params(task_id)\n        self.status = status\n        self.record_id = None\n        self.host = host",
        "begin_line": 33,
        "end_line": 37,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003436426116838488,
            "pseudo_dstar_susp": 0.0026455026455026454,
            "pseudo_tarantula_susp": 0.004132231404958678,
            "pseudo_op2_susp": 0.0026455026455026454,
            "pseudo_barinel_susp": 0.004132231404958678
        }
    },
    {
        "name": "luigi.task_history.NopHistory.task_scheduled#63",
        "src_path": "luigi/task_history.py",
        "class_name": "luigi.task_history.NopHistory",
        "signature": "luigi.task_history.NopHistory.task_scheduled(self, task_id)",
        "snippet": "    def task_scheduled(self, task_id):\n        pass",
        "begin_line": 63,
        "end_line": 64,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004187604690117253,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.task_history.NopHistory.task_finished#66",
        "src_path": "luigi/task_history.py",
        "class_name": "luigi.task_history.NopHistory",
        "signature": "luigi.task_history.NopHistory.task_finished(self, task_id, successful)",
        "snippet": "    def task_finished(self, task_id, successful):\n        pass",
        "begin_line": 66,
        "end_line": 67,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004551661356395084,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.task_history.NopHistory.task_started#69",
        "src_path": "luigi/task_history.py",
        "class_name": "luigi.task_history.NopHistory",
        "signature": "luigi.task_history.NopHistory.task_started(self, task_id, worker_host)",
        "snippet": "    def task_started(self, task_id, worker_host):\n        pass",
        "begin_line": 69,
        "end_line": 70,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.00044603033006244426,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.lock.getpcmd#23",
        "src_path": "luigi/lock.py",
        "class_name": "luigi.lock",
        "signature": "luigi.lock.getpcmd(pid)",
        "snippet": "def getpcmd(pid):\n    \"\"\"\n    Returns command of process.\n\n    :param pid:\n    \"\"\"\n    cmd = 'ps -p %s -o command=' % (pid,)\n    p = os.popen(cmd, 'r')\n    return p.readline().strip()",
        "begin_line": 23,
        "end_line": 31,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.lock.get_info#34",
        "src_path": "luigi/lock.py",
        "class_name": "luigi.lock",
        "signature": "luigi.lock.get_info(pid_dir)",
        "snippet": "def get_info(pid_dir):\n    # Check the name and pid of this process\n    my_pid = os.getpid()\n    my_cmd = getpcmd(my_pid)\n\n    pid_file = os.path.join(pid_dir, hashlib.md5(my_cmd.encode('utf8')).hexdigest()) + '.pid'\n\n    return my_pid, my_cmd, pid_file",
        "begin_line": 34,
        "end_line": 41,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.lock.acquire_for#44",
        "src_path": "luigi/lock.py",
        "class_name": "luigi.lock",
        "signature": "luigi.lock.acquire_for(pid_dir, num_available=1)",
        "snippet": "def acquire_for(pid_dir, num_available=1):\n    \"\"\"\n    Makes sure the process is only run once at the same time with the same name.\n\n    Notice that we since we check the process name, different parameters to the same\n    command can spawn multiple processes at the same time, i.e. running\n    \"/usr/bin/my_process\" does not prevent anyone from launching\n    \"/usr/bin/my_process --foo bar\".\n    \"\"\"\n\n    my_pid, my_cmd, pid_file = get_info(pid_dir)\n\n    # Check if there is a pid file corresponding to this name\n    if not os.path.exists(pid_dir):\n        os.mkdir(pid_dir)\n        os.chmod(pid_dir, 0o777)\n\n    pids = set()\n    pid_cmds = {}\n    if os.path.exists(pid_file):\n        # There is such a file - read the pid and look up its process name\n        pids.update(filter(None, map(str.strip, open(pid_file))))\n        pid_cmds = dict((pid, getpcmd(pid)) for pid in pids)\n        matching_pids = list(filter(lambda pid: pid_cmds[pid] == my_cmd, pids))\n\n        if len(matching_pids) >= num_available:\n            # We are already running under a different pid\n            print('Pid(s)', ', '.join(matching_pids), 'already running')\n            return False\n        else:\n            # The pid belongs to something else, we could\n            pass\n    pid_cmds[str(my_pid)] = my_cmd\n\n    # Write pids\n    pids.add(str(my_pid))\n    with open(pid_file, 'w') as f:\n        f.writelines('%s\\n' % (pid, ) for pid in filter(pid_cmds.__getitem__, pids))\n\n    # Make the file writable by all\n    if os.name == 'nt':\n        pass\n    else:\n        s = os.stat(pid_file)\n        if os.getuid() == s.st_uid:\n            os.chmod(pid_file, s.st_mode | 0o777)\n\n    return True",
        "begin_line": 44,
        "end_line": 91,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.worker.AbstractTaskProcess.__init__#65",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.AbstractTaskProcess",
        "signature": "luigi.worker.AbstractTaskProcess.__init__(self, task, worker_id, result_queue, random_seed=False, worker_timeout=0)",
        "snippet": "    def __init__(self, task, worker_id, result_queue, random_seed=False, worker_timeout=0):\n        super(AbstractTaskProcess, self).__init__()\n        self.task = task\n        self.worker_id = worker_id\n        self.result_queue = result_queue\n        self.random_seed = random_seed\n        if task.worker_timeout is not None:\n            worker_timeout = task.worker_timeout\n        self.timeout_time = time.time() + worker_timeout if worker_timeout else None",
        "begin_line": 65,
        "end_line": 73,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.00041999160016799666,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.worker.ExternalTaskProcess.run#86",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.ExternalTaskProcess",
        "signature": "luigi.worker.ExternalTaskProcess.run(self)",
        "snippet": "    def run(self):\n        logger.info('[pid %s] Worker %s running   %s', os.getpid(), self.worker_id, self.task.task_id)\n\n        if self.random_seed:\n            # Need to have different random seeds if running in separate processes\n            random.seed((os.getpid(), time.time()))\n\n        status = FAILED\n        error_message = ''\n        try:\n            self.task.trigger_event(Event.START, self.task)\n            t0 = time.time()\n            status = None\n            try:\n                status = DONE if self.task.complete() else FAILED\n                logger.debug('[pid %s] Task %s has status %s', os.getpid(), self.task, status)\n            finally:\n                self.task.trigger_event(\n                    Event.PROCESSING_TIME, self.task, time.time() - t0)\n\n            error_message = json.dumps(self.task.on_success())\n            logger.info('[pid %s] Worker %s done      %s', os.getpid(),\n                        self.worker_id, self.task.task_id)\n            self.task.trigger_event(Event.SUCCESS, self.task)\n\n        except KeyboardInterrupt:\n            raise\n        except BaseException as ex:\n            status = FAILED\n            logger.exception('[pid %s] Worker %s failed    %s', os.getpid(), self.worker_id, self.task)\n            error_message = notifications.wrap_traceback(self.task.on_failure(ex))\n            self.task.trigger_event(Event.FAILURE, self.task, ex)\n            subject = \"Luigi: %s FAILED\" % self.task\n            notifications.send_error_email(subject, error_message)\n        finally:\n            logger.debug('Putting result into queue: %s %s %s', self.task.task_id, status, error_message)\n            self.result_queue.put(\n                (self.task.task_id, status, error_message, [], []))",
        "begin_line": 86,
        "end_line": 123,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.worker.TaskProcess.run#134",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.TaskProcess",
        "signature": "luigi.worker.TaskProcess.run(self)",
        "snippet": "    def run(self):\n        logger.info('[pid %s] Worker %s running   %s', os.getpid(), self.worker_id, self.task.task_id)\n\n        if self.random_seed:\n            # Need to have different random seeds if running in separate processes\n            random.seed((os.getpid(), time.time()))\n\n        status = FAILED\n        error_message = ''\n        missing = []\n        new_deps = []\n        try:\n            # Verify that all the tasks are fulfilled!\n            missing = [dep.task_id for dep in self.task.deps() if not dep.complete()]\n            if missing:\n                deps = 'dependency' if len(missing) == 1 else 'dependencies'\n                raise RuntimeError('Unfulfilled %s at run time: %s' % (deps, ', '.join(missing)))\n            self.task.trigger_event(Event.START, self.task)\n            t0 = time.time()\n            status = None\n            try:\n                task_gen = self.task.run()\n                if isinstance(task_gen, types.GeneratorType):  # new deps\n                    next_send = None\n                    while True:\n                        try:\n                            if next_send is None:\n                                requires = six.next(task_gen)\n                            else:\n                                requires = task_gen.send(next_send)\n                        except StopIteration:\n                            break\n\n                        new_req = flatten(requires)\n                        status = (RUNNING if all(t.complete() for t in new_req)\n                                  else SUSPENDED)\n                        new_deps = [(t.task_module, t.task_family, t.to_str_params())\n                                    for t in new_req]\n                        if status == RUNNING:\n                            self.result_queue.put(\n                                (self.task.task_id, status, '', missing,\n                                 new_deps))\n                            next_send = getpaths(requires)\n                            new_deps = []\n                        else:\n                            logger.info(\n                                '[pid %s] Worker %s new requirements      %s',\n                                os.getpid(), self.worker_id, self.task.task_id)\n                            return\n            finally:\n                if status != SUSPENDED:\n                    self.task.trigger_event(\n                        Event.PROCESSING_TIME, self.task, time.time() - t0)\n            error_message = json.dumps(self.task.on_success())\n            logger.info('[pid %s] Worker %s done      %s', os.getpid(),\n                        self.worker_id, self.task.task_id)\n            self.task.trigger_event(Event.SUCCESS, self.task)\n            status = DONE\n\n        except KeyboardInterrupt:\n            raise\n        except BaseException as ex:\n            status = FAILED\n            logger.exception(\"[pid %s] Worker %s failed    %s\", os.getpid(), self.worker_id, self.task)\n            error_message = notifications.wrap_traceback(self.task.on_failure(ex))\n            self.task.trigger_event(Event.FAILURE, self.task, ex)\n            subject = \"Luigi: %s FAILED\" % self.task\n            notifications.send_error_email(subject, error_message)\n        finally:\n            self.result_queue.put(\n                (self.task.task_id, status, error_message, missing, new_deps))",
        "begin_line": 134,
        "end_line": 204,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005291005291005291,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.worker.SingleProcessPool.apply_async#216",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.SingleProcessPool",
        "signature": "luigi.worker.SingleProcessPool.apply_async(self, function, args)",
        "snippet": "    def apply_async(self, function, args):\n        return function(*args)",
        "begin_line": 216,
        "end_line": 217,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001644736842105263,
            "pseudo_dstar_susp": 0.0024509803921568627,
            "pseudo_tarantula_susp": 0.0014792899408284023,
            "pseudo_op2_susp": 0.0024509803921568627,
            "pseudo_barinel_susp": 0.0014792899408284023
        }
    },
    {
        "name": "luigi.worker.AsyncCompletionException.__init__#234",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.AsyncCompletionException",
        "signature": "luigi.worker.AsyncCompletionException.__init__(self, trace)",
        "snippet": "    def __init__(self, trace):\n        self.trace = trace",
        "begin_line": 234,
        "end_line": 235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.016129032258064516,
            "pseudo_dstar_susp": 0.003424657534246575,
            "pseudo_tarantula_susp": 0.0070921985815602835,
            "pseudo_op2_susp": 0.003424657534246575,
            "pseudo_barinel_susp": 0.0070921985815602835
        }
    },
    {
        "name": "luigi.worker.TracebackWrapper.__init__#243",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.TracebackWrapper",
        "signature": "luigi.worker.TracebackWrapper.__init__(self, trace)",
        "snippet": "    def __init__(self, trace):\n        self.trace = trace",
        "begin_line": 243,
        "end_line": 244,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0033444816053511705,
            "pseudo_dstar_susp": 0.0016181229773462784,
            "pseudo_tarantula_susp": 0.005263157894736842,
            "pseudo_op2_susp": 0.0016181229773462784,
            "pseudo_barinel_susp": 0.005263157894736842
        }
    },
    {
        "name": "luigi.worker.check_complete#247",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker",
        "signature": "luigi.worker.check_complete(task, out_queue)",
        "snippet": "def check_complete(task, out_queue):\n    \"\"\"\n    Checks if task is complete, puts the result to out_queue.\n    \"\"\"\n    logger.debug(\"Checking if %s is complete\", task)\n    try:\n        is_complete = task.complete()\n    except BaseException:\n        is_complete = TracebackWrapper(traceback.format_exc())\n    out_queue.put((task, is_complete))",
        "begin_line": 247,
        "end_line": 256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0033444816053511705,
            "pseudo_dstar_susp": 0.0022123893805309734,
            "pseudo_tarantula_susp": 0.005263157894736842,
            "pseudo_op2_susp": 0.0022123893805309734,
            "pseudo_barinel_susp": 0.005263157894736842
        }
    },
    {
        "name": "luigi.worker.Worker.__init__#269",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker.__init__(self, scheduler=None, worker_id=None, worker_processes=1, ping_interval=None, keep_alive=None, wait_interval=None, max_reschedules=None, count_uniques=None, worker_timeout=None)",
        "snippet": "    def __init__(self, scheduler=None, worker_id=None,\n                 worker_processes=1, ping_interval=None, keep_alive=None,\n                 wait_interval=None, max_reschedules=None, count_uniques=None,\n                 worker_timeout=None):\n\n        if scheduler is None:\n            scheduler = CentralPlannerScheduler()\n\n        self.worker_processes = int(worker_processes)\n        self._worker_info = self._generate_worker_info()\n\n        if not worker_id:\n            worker_id = 'Worker(%s)' % ', '.join(['%s=%s' % (k, v) for k, v in self._worker_info])\n\n        config = configuration.get_config()\n\n        if ping_interval is None:\n            ping_interval = config.getfloat('core', 'worker-ping-interval', 1.0)\n\n        if keep_alive is None:\n            keep_alive = config.getboolean('core', 'worker-keep-alive', False)\n        self.__keep_alive = keep_alive\n\n        # worker-count-uniques means that we will keep a worker alive only if it has a unique\n        # pending task, as well as having keep-alive true\n        if count_uniques is None:\n            count_uniques = config.getboolean('core', 'worker-count-uniques', False)\n        self.__count_uniques = count_uniques\n\n        if wait_interval is None:\n            wait_interval = config.getint('core', 'worker-wait-interval', 1)\n        self.__wait_interval = wait_interval\n\n        if max_reschedules is None:\n            max_reschedules = config.getint('core', 'max-reschedules', 1)\n        self.__max_reschedules = max_reschedules\n\n        if worker_timeout is None:\n            worker_timeout = configuration.get_config().getint('core', 'worker-timeout', 0)\n        self.__worker_timeout = worker_timeout\n\n        self._id = worker_id\n        self._scheduler = scheduler\n\n        self.host = socket.gethostname()\n        self._scheduled_tasks = {}\n        self._suspended_tasks = {}\n\n        self._first_task = None\n\n        self.add_succeeded = True\n        self.run_succeeded = True\n        self.unfulfilled_counts = collections.defaultdict(int)\n\n        class KeepAliveThread(threading.Thread):\n            \"\"\"\n            Periodically tell the scheduler that the worker still lives.\n            \"\"\"\n\n            def __init__(self):\n                super(KeepAliveThread, self).__init__()\n                self._should_stop = threading.Event()\n\n            def stop(self):\n                self._should_stop.set()\n\n            def run(self):\n                while True:\n                    self._should_stop.wait(ping_interval)\n                    if self._should_stop.is_set():\n                        logger.info(\"Worker %s was stopped. Shutting down Keep-Alive thread\" % worker_id)\n                        break\n                    fork_lock.acquire()\n                    try:\n                        scheduler.ping(worker=worker_id)\n                    except:  # httplib.BadStatusLine:\n                        logger.warning('Failed pinging scheduler')\n                    finally:\n                        fork_lock.release()\n\n        self._keep_alive_thread = KeepAliveThread()\n        self._keep_alive_thread.daemon = True\n        self._keep_alive_thread.start()\n\n        # Keep info about what tasks are running (could be in other processes)\n        self._task_result_queue = multiprocessing.Queue()\n        self._running_tasks = {}",
        "begin_line": 269,
        "end_line": 355,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022371364653243847,
            "pseudo_dstar_susp": 0.0045871559633027525,
            "pseudo_tarantula_susp": 0.002976190476190476,
            "pseudo_op2_susp": 0.0045871559633027525,
            "pseudo_barinel_susp": 0.002976190476190476
        }
    },
    {
        "name": "luigi.worker.KeepAliveThread.__init__#269",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.KeepAliveThread",
        "signature": "luigi.worker.KeepAliveThread.__init__(self, scheduler=None, worker_id=None, worker_processes=1, ping_interval=None, keep_alive=None, wait_interval=None, max_reschedules=None, count_uniques=None, worker_timeout=None)",
        "snippet": "    def __init__(self, scheduler=None, worker_id=None,\n                 worker_processes=1, ping_interval=None, keep_alive=None,\n                 wait_interval=None, max_reschedules=None, count_uniques=None,\n                 worker_timeout=None):\n\n        if scheduler is None:\n            scheduler = CentralPlannerScheduler()\n\n        self.worker_processes = int(worker_processes)\n        self._worker_info = self._generate_worker_info()\n\n        if not worker_id:\n            worker_id = 'Worker(%s)' % ', '.join(['%s=%s' % (k, v) for k, v in self._worker_info])\n\n        config = configuration.get_config()\n\n        if ping_interval is None:\n            ping_interval = config.getfloat('core', 'worker-ping-interval', 1.0)\n\n        if keep_alive is None:\n            keep_alive = config.getboolean('core', 'worker-keep-alive', False)\n        self.__keep_alive = keep_alive\n\n        # worker-count-uniques means that we will keep a worker alive only if it has a unique\n        # pending task, as well as having keep-alive true\n        if count_uniques is None:\n            count_uniques = config.getboolean('core', 'worker-count-uniques', False)\n        self.__count_uniques = count_uniques\n\n        if wait_interval is None:\n            wait_interval = config.getint('core', 'worker-wait-interval', 1)\n        self.__wait_interval = wait_interval\n\n        if max_reschedules is None:\n            max_reschedules = config.getint('core', 'max-reschedules', 1)\n        self.__max_reschedules = max_reschedules\n\n        if worker_timeout is None:\n            worker_timeout = configuration.get_config().getint('core', 'worker-timeout', 0)\n        self.__worker_timeout = worker_timeout\n\n        self._id = worker_id\n        self._scheduler = scheduler\n\n        self.host = socket.gethostname()\n        self._scheduled_tasks = {}\n        self._suspended_tasks = {}\n\n        self._first_task = None\n\n        self.add_succeeded = True\n        self.run_succeeded = True\n        self.unfulfilled_counts = collections.defaultdict(int)\n\n        class KeepAliveThread(threading.Thread):\n            \"\"\"\n            Periodically tell the scheduler that the worker still lives.\n            \"\"\"\n\n            def __init__(self):\n                super(KeepAliveThread, self).__init__()\n                self._should_stop = threading.Event()\n\n            def stop(self):\n                self._should_stop.set()\n\n            def run(self):\n                while True:\n                    self._should_stop.wait(ping_interval)\n                    if self._should_stop.is_set():\n                        logger.info(\"Worker %s was stopped. Shutting down Keep-Alive thread\" % worker_id)\n                        break\n                    fork_lock.acquire()\n                    try:\n                        scheduler.ping(worker=worker_id)\n                    except:  # httplib.BadStatusLine:\n                        logger.warning('Failed pinging scheduler')\n                    finally:\n                        fork_lock.release()\n\n        self._keep_alive_thread = KeepAliveThread()\n        self._keep_alive_thread.daemon = True\n        self._keep_alive_thread.start()\n\n        # Keep info about what tasks are running (could be in other processes)\n        self._task_result_queue = multiprocessing.Queue()\n        self._running_tasks = {}",
        "begin_line": 269,
        "end_line": 355,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024330900243309003,
            "pseudo_dstar_susp": 0.004545454545454545,
            "pseudo_tarantula_susp": 0.003115264797507788,
            "pseudo_op2_susp": 0.004545454545454545,
            "pseudo_barinel_susp": 0.003115264797507788
        }
    },
    {
        "name": "luigi.worker.KeepAliveThread.__init__#328",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.KeepAliveThread",
        "signature": "luigi.worker.KeepAliveThread.__init__(self)",
        "snippet": "            def __init__(self):\n                super(KeepAliveThread, self).__init__()\n                self._should_stop = threading.Event()",
        "begin_line": 328,
        "end_line": 330,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002583979328165375,
            "pseudo_dstar_susp": 0.004545454545454545,
            "pseudo_tarantula_susp": 0.0031545741324921135,
            "pseudo_op2_susp": 0.004545454545454545,
            "pseudo_barinel_susp": 0.0031545741324921135
        }
    },
    {
        "name": "luigi.worker.KeepAliveThread.stop#332",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.KeepAliveThread",
        "signature": "luigi.worker.KeepAliveThread.stop(self)",
        "snippet": "            def stop(self):\n                self._should_stop.set()",
        "begin_line": 332,
        "end_line": 333,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002183406113537118,
            "pseudo_dstar_susp": 0.002512562814070352,
            "pseudo_tarantula_susp": 0.0020491803278688526,
            "pseudo_op2_susp": 0.002512562814070352,
            "pseudo_barinel_susp": 0.0020491803278688526
        }
    },
    {
        "name": "luigi.worker.KeepAliveThread.run#335",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.KeepAliveThread",
        "signature": "luigi.worker.KeepAliveThread.run(self)",
        "snippet": "            def run(self):\n                while True:\n                    self._should_stop.wait(ping_interval)\n                    if self._should_stop.is_set():\n                        logger.info(\"Worker %s was stopped. Shutting down Keep-Alive thread\" % worker_id)\n                        break\n                    fork_lock.acquire()\n                    try:\n                        scheduler.ping(worker=worker_id)\n                    except:  # httplib.BadStatusLine:\n                        logger.warning('Failed pinging scheduler')\n                    finally:\n                        fork_lock.release()",
        "begin_line": 335,
        "end_line": 347,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009433962264150943,
            "pseudo_dstar_susp": 0.022222222222222223,
            "pseudo_tarantula_susp": 0.004273504273504274,
            "pseudo_op2_susp": 0.022222222222222223,
            "pseudo_barinel_susp": 0.004273504273504274
        }
    },
    {
        "name": "luigi.worker.Worker.stop#357",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker.stop(self)",
        "snippet": "    def stop(self):\n        \"\"\"\n        Stop the KeepAliveThread associated with this Worker.\n\n        This should be called whenever you are done with a worker instance to clean up.\n\n        Warning: this should _only_ be performed if you are sure this worker\n        is not performing any work or will perform any work after this has been called\n\n        TODO: also kill all currently running tasks\n\n        TODO (maybe): Worker should be/have a context manager to enforce calling this\n            whenever you stop using a Worker instance\n        \"\"\"\n        self._keep_alive_thread.stop()\n        self._keep_alive_thread.join()",
        "begin_line": 357,
        "end_line": 372,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0019157088122605363,
            "pseudo_dstar_susp": 0.002331002331002331,
            "pseudo_tarantula_susp": 0.0026455026455026454,
            "pseudo_op2_susp": 0.002331002331002331,
            "pseudo_barinel_susp": 0.0026455026455026454
        }
    },
    {
        "name": "luigi.worker.Worker._generate_worker_info#374",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._generate_worker_info(self)",
        "snippet": "    def _generate_worker_info(self):\n        # Generate as much info as possible about the worker\n        # Some of these calls might not be available on all OS's\n        args = [('salt', '%09d' % random.randrange(0, 999999999)),\n                ('workers', self.worker_processes)]\n        try:\n            args += [('host', socket.gethostname())]\n        except BaseException:\n            pass\n        try:\n            args += [('username', getpass.getuser())]\n        except BaseException:\n            pass\n        try:\n            args += [('pid', os.getpid())]\n        except BaseException:\n            pass\n        try:\n            sudo_user = os.getenv(\"SUDO_USER\")\n            if sudo_user:\n                args.append(('sudo_user', sudo_user))\n        except BaseException:\n            pass\n        return args",
        "begin_line": 374,
        "end_line": 397,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002506265664160401,
            "pseudo_dstar_susp": 0.00425531914893617,
            "pseudo_tarantula_susp": 0.003048780487804878,
            "pseudo_op2_susp": 0.00425531914893617,
            "pseudo_barinel_susp": 0.003048780487804878
        }
    },
    {
        "name": "luigi.worker.Worker._validate_task#399",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._validate_task(self, task)",
        "snippet": "    def _validate_task(self, task):\n        if not isinstance(task, Task):\n            raise TaskException('Can not schedule non-task %s' % task)\n\n        if not task.initialized():\n            # we can't get the repr of it since it's not initialized...\n            raise TaskException('Task of class %s not initialized. Did you override __init__ and forget to call super(...).__init__?' % task.__class__.__name__)",
        "begin_line": 399,
        "end_line": 405,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014858841010401188,
            "pseudo_dstar_susp": 0.002183406113537118,
            "pseudo_tarantula_susp": 0.0021598272138228943,
            "pseudo_op2_susp": 0.002183406113537118,
            "pseudo_barinel_susp": 0.0021598272138228943
        }
    },
    {
        "name": "luigi.worker.Worker._log_complete_error#407",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._log_complete_error(self, task, tb)",
        "snippet": "    def _log_complete_error(self, task, tb):\n        log_msg = \"Will not schedule {task} or any dependencies due to error in complete() method:\\n{tb}\".format(task=task, tb=tb)\n        logger.warning(log_msg)",
        "begin_line": 407,
        "end_line": 409,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00423728813559322,
            "pseudo_dstar_susp": 0.001639344262295082,
            "pseudo_tarantula_susp": 0.0064516129032258064,
            "pseudo_op2_susp": 0.001639344262295082,
            "pseudo_barinel_susp": 0.0064516129032258064
        }
    },
    {
        "name": "luigi.worker.Worker._log_unexpected_error#411",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._log_unexpected_error(self, task)",
        "snippet": "    def _log_unexpected_error(self, task):\n        logger.exception(\"Luigi unexpected framework error while scheduling %s\", task)  # needs to be called from within except clause",
        "begin_line": 411,
        "end_line": 412,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016129032258064516,
            "pseudo_dstar_susp": 0.0012642225031605564,
            "pseudo_tarantula_susp": 0.003389830508474576,
            "pseudo_op2_susp": 0.0012642225031605564,
            "pseudo_barinel_susp": 0.003401360544217687
        }
    },
    {
        "name": "luigi.worker.Worker._email_complete_error#414",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._email_complete_error(self, task, formatted_traceback)",
        "snippet": "    def _email_complete_error(self, task, formatted_traceback):\n        # like logger.exception but with WARNING level\n        formatted_traceback = notifications.wrap_traceback(formatted_traceback)\n        subject = \"Luigi: {task} failed scheduling. Host: {host}\".format(task=task, host=self.host)\n        message = \"Will not schedule {task} or any dependencies due to error in complete() method:\\n{traceback}\".format(task=task, traceback=formatted_traceback)\n        notifications.send_error_email(subject, message)",
        "begin_line": 414,
        "end_line": 419,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029239766081871343,
            "pseudo_dstar_susp": 0.0016025641025641025,
            "pseudo_tarantula_susp": 0.004608294930875576,
            "pseudo_op2_susp": 0.0016025641025641025,
            "pseudo_barinel_susp": 0.004608294930875576
        }
    },
    {
        "name": "luigi.worker.Worker._email_unexpected_error#421",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._email_unexpected_error(self, task, formatted_traceback)",
        "snippet": "    def _email_unexpected_error(self, task, formatted_traceback):\n        formatted_traceback = notifications.wrap_traceback(formatted_traceback)\n        subject = \"Luigi: Framework error while scheduling {task}. Host: {host}\".format(task=task, host=self.host)\n        message = \"Luigi framework error:\\n{traceback}\".format(traceback=formatted_traceback)\n        notifications.send_error_email(subject, message)",
        "begin_line": 421,
        "end_line": 425,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002770083102493075,
            "pseudo_dstar_susp": 0.0014064697609001407,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.0014064697609001407,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.worker.Worker.add#427",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker.add(self, task, multiprocess=False)",
        "snippet": "    def add(self, task, multiprocess=False):\n        \"\"\"\n        Add a Task for the worker to check and possibly schedule and run.\n\n        Returns True if task and its dependencies were successfully scheduled or completed before.\n        \"\"\"\n        if self._first_task is None and hasattr(task, 'task_id'):\n            self._first_task = task.task_id\n        self.add_succeeded = True\n        if multiprocess:\n            queue = multiprocessing.Manager().Queue()\n            pool = multiprocessing.Pool()\n        else:\n            queue = DequeQueue()\n            pool = SingleProcessPool()\n        self._validate_task(task)\n        pool.apply_async(check_complete, [task, queue])\n\n        # we track queue size ourselves because len(queue) won't work for multiprocessing\n        queue_size = 1\n        try:\n            seen = set([task.task_id])\n            while queue_size:\n                current = queue.get()\n                queue_size -= 1\n                item, is_complete = current\n                for next in self._add(item, is_complete):\n                    if next.task_id not in seen:\n                        self._validate_task(next)\n                        seen.add(next.task_id)\n                        pool.apply_async(check_complete, [next, queue])\n                        queue_size += 1\n        except (KeyboardInterrupt, TaskException):\n            raise\n        except Exception as ex:\n            self.add_succeeded = False\n            formatted_traceback = traceback.format_exc()\n            self._log_unexpected_error(task)\n            task.trigger_event(Event.BROKEN_TASK, task, ex)\n            self._email_unexpected_error(task, formatted_traceback)\n        return self.add_succeeded",
        "begin_line": 427,
        "end_line": 467,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002770083102493075,
            "pseudo_dstar_susp": 0.002232142857142857,
            "pseudo_tarantula_susp": 0.005263157894736842,
            "pseudo_op2_susp": 0.002232142857142857,
            "pseudo_barinel_susp": 0.005263157894736842
        }
    },
    {
        "name": "luigi.worker.Worker._add#469",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._add(self, task, is_complete)",
        "snippet": "    def _add(self, task, is_complete):\n        formatted_traceback = None\n        try:\n            self._check_complete_value(is_complete)\n        except KeyboardInterrupt:\n            raise\n        except AsyncCompletionException as ex:\n            formatted_traceback = ex.trace\n        except BaseException:\n            formatted_traceback = traceback.format_exc()\n\n        if formatted_traceback is not None:\n            self.add_succeeded = False\n            self._log_complete_error(task, formatted_traceback)\n            task.trigger_event(Event.DEPENDENCY_MISSING, task)\n            self._email_complete_error(task, formatted_traceback)\n            # abort, i.e. don't schedule any subtasks of a task with\n            # failing complete()-method since we don't know if the task\n            # is complete and subtasks might not be desirable to run if\n            # they have already ran before\n            return\n\n        if is_complete:\n            deps = None\n            status = DONE\n            runnable = False\n\n            task.trigger_event(Event.DEPENDENCY_PRESENT, task)\n        elif task.run == NotImplemented:\n            deps = None\n            status = PENDING\n            runnable = configuration.get_config().getboolean('core', 'retry-external-tasks', False)\n\n            task.trigger_event(Event.DEPENDENCY_MISSING, task)\n            logger.warning('Task %s is not complete and run() is not implemented. Probably a missing external dependency.', task.task_id)\n\n        else:\n            deps = task.deps()\n            status = PENDING\n            runnable = True\n\n        if task.disabled:\n            status = DISABLED\n\n        if deps:\n            for d in deps:\n                self._validate_dependency(d)\n                task.trigger_event(Event.DEPENDENCY_DISCOVERED, task, d)\n                yield d  # return additional tasks to add\n\n            deps = [d.task_id for d in deps]\n\n        self._scheduled_tasks[task.task_id] = task\n        self._scheduler.add_task(self._id, task.task_id, status=status,\n                                 deps=deps, runnable=runnable, priority=task.priority,\n                                 resources=task.process_resources(),\n                                 params=task.to_str_params(),\n                                 family=task.task_family)\n\n        logger.info('Scheduled %s (%s)', task.task_id, status)",
        "begin_line": 469,
        "end_line": 528,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00423728813559322,
            "pseudo_dstar_susp": 0.002183406113537118,
            "pseudo_tarantula_susp": 0.0064516129032258064,
            "pseudo_op2_susp": 0.002183406113537118,
            "pseudo_barinel_susp": 0.0064516129032258064
        }
    },
    {
        "name": "luigi.worker.Worker._validate_dependency#530",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._validate_dependency(self, dependency)",
        "snippet": "    def _validate_dependency(self, dependency):\n        if isinstance(dependency, Target):\n            raise Exception('requires() can not return Target objects. Wrap it in an ExternalTask class')\n        elif not isinstance(dependency, Task):\n            raise Exception('requires() must return Task objects')",
        "begin_line": 530,
        "end_line": 534,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004894762604013706,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.worker.Worker._check_complete_value#536",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._check_complete_value(self, is_complete)",
        "snippet": "    def _check_complete_value(self, is_complete):\n        if is_complete not in (True, False):\n            if isinstance(is_complete, TracebackWrapper):\n                raise AsyncCompletionException(is_complete.trace)\n            raise Exception(\"Return value of Task.complete() must be boolean (was %r)\" % is_complete)",
        "begin_line": 536,
        "end_line": 540,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005076142131979695,
            "pseudo_dstar_susp": 0.002183406113537118,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.002183406113537118,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.worker.Worker._add_worker#542",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._add_worker(self)",
        "snippet": "    def _add_worker(self):\n        self._worker_info.append(('first_task', self._first_task))\n        try:\n            self._scheduler.add_worker(self._id, self._worker_info)\n        except BaseException:\n            logger.exception('Exception adding worker - scheduler might be running an older version')",
        "begin_line": 542,
        "end_line": 547,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018214936247723133,
            "pseudo_dstar_susp": 0.002331002331002331,
            "pseudo_tarantula_susp": 0.002577319587628866,
            "pseudo_op2_susp": 0.002331002331002331,
            "pseudo_barinel_susp": 0.002577319587628866
        }
    },
    {
        "name": "luigi.worker.Worker._log_remote_tasks#549",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._log_remote_tasks(self, running_tasks, n_pending_tasks, n_unique_pending)",
        "snippet": "    def _log_remote_tasks(self, running_tasks, n_pending_tasks, n_unique_pending):\n        logger.info(\"Done\")\n        logger.info(\"There are no more tasks to run at this time\")\n        if running_tasks:\n            for r in running_tasks:\n                logger.info('%s is currently run by worker %s', r['task_id'], r['worker'])\n        elif n_pending_tasks:\n            logger.info(\"There are %s pending tasks possibly being run by other workers\", n_pending_tasks)\n            if n_unique_pending:\n                logger.info(\"There are %i pending tasks unique to this worker\", n_unique_pending)",
        "begin_line": 549,
        "end_line": 558,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018214936247723133,
            "pseudo_dstar_susp": 0.002398081534772182,
            "pseudo_tarantula_susp": 0.002577319587628866,
            "pseudo_op2_susp": 0.002398081534772182,
            "pseudo_barinel_susp": 0.002577319587628866
        }
    },
    {
        "name": "luigi.worker.Worker._get_work#560",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._get_work(self)",
        "snippet": "    def _get_work(self):\n        logger.debug(\"Asking scheduler for work...\")\n        r = self._scheduler.get_work(worker=self._id, host=self.host)\n        # Support old version of scheduler\n        if isinstance(r, tuple) or isinstance(r, list):\n            n_pending_tasks, task_id = r\n            running_tasks = []\n            n_unique_pending = 0\n        else:\n            n_pending_tasks = r['n_pending_tasks']\n            task_id = r['task_id']\n            running_tasks = r['running_tasks']\n            # support old version of scheduler\n            n_unique_pending = r.get('n_unique_pending', 0)\n        return task_id, running_tasks, n_pending_tasks, n_unique_pending",
        "begin_line": 560,
        "end_line": 574,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018214936247723133,
            "pseudo_dstar_susp": 0.0024154589371980675,
            "pseudo_tarantula_susp": 0.002577319587628866,
            "pseudo_op2_susp": 0.0024154589371980675,
            "pseudo_barinel_susp": 0.002577319587628866
        }
    },
    {
        "name": "luigi.worker.Worker._run_task#576",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._run_task(self, task_id)",
        "snippet": "    def _run_task(self, task_id):\n        task = self._scheduled_tasks[task_id]\n\n        if task.run == NotImplemented:\n            p = ExternalTaskProcess(task, self._id, self._task_result_queue,\n                                    random_seed=bool(self.worker_processes > 1),\n                                    worker_timeout=self.__worker_timeout)\n        else:\n            p = TaskProcess(task, self._id, self._task_result_queue,\n                            random_seed=bool(self.worker_processes > 1),\n                            worker_timeout=self.__worker_timeout)\n\n        self._running_tasks[task_id] = p\n\n        if self.worker_processes > 1:\n            fork_lock.acquire()\n            try:\n                p.start()\n            finally:\n                fork_lock.release()\n        else:\n            # Run in the same process\n            p.run()",
        "begin_line": 576,
        "end_line": 598,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001226993865030675,
            "pseudo_dstar_susp": 0.0012135922330097086,
            "pseudo_tarantula_susp": 0.001834862385321101,
            "pseudo_op2_susp": 0.0012135922330097086,
            "pseudo_barinel_susp": 0.001834862385321101
        }
    },
    {
        "name": "luigi.worker.Worker._purge_children#600",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._purge_children(self)",
        "snippet": "    def _purge_children(self):\n        \"\"\"\n        Find dead children and put a response on the result queue.\n\n        :return:\n        \"\"\"\n        for task_id, p in six.iteritems(self._running_tasks):\n            if not p.is_alive() and p.exitcode:\n                error_msg = 'Worker task %s died unexpectedly with exit code %s' % (task_id, p.exitcode)\n            elif p.timeout_time is not None and time.time() > float(p.timeout_time) and p.is_alive():\n                p.terminate()\n                error_msg = 'Worker task %s timed out and was terminated.' % task_id\n            else:\n                continue\n\n            logger.info(error_msg)\n            self._task_result_queue.put((task_id, FAILED, error_msg, [], []))",
        "begin_line": 600,
        "end_line": 616,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012004801920768306,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.0014792899408284023,
            "pseudo_op2_susp": 0.001199040767386091,
            "pseudo_barinel_susp": 0.0014792899408284023
        }
    },
    {
        "name": "luigi.worker.Worker._handle_next_task#618",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._handle_next_task(self)",
        "snippet": "    def _handle_next_task(self):\n        \"\"\"\n        We have to catch three ways a task can be \"done\":\n\n        1. normal execution: the task runs/fails and puts a result back on the queue,\n        2. new dependencies: the task yielded new deps that were not complete and\n           will be rescheduled and dependencies added,\n        3. child process dies: we need to catch this separately.\n        \"\"\"\n        from luigi import interface\n        while True:\n            self._purge_children()  # Deal with subprocess failures\n\n            try:\n                task_id, status, error_message, missing, new_requirements = (\n                    self._task_result_queue.get(\n                        timeout=float(self.__wait_interval)))\n            except Queue.Empty:\n                return\n\n            task = self._scheduled_tasks[task_id]\n            if not task or task_id not in self._running_tasks:\n                continue\n                # Not a running task. Probably already removed.\n                # Maybe it yielded something?\n            new_deps = []\n            if new_requirements:\n                new_req = [interface.load_task(module, name, params)\n                           for module, name, params in new_requirements]\n                for t in new_req:\n                    self.add(t)\n                new_deps = [t.task_id for t in new_req]\n\n            self._scheduler.add_task(self._id,\n                                     task_id,\n                                     status=status,\n                                     expl=error_message,\n                                     resources=task.process_resources(),\n                                     runnable=None,\n                                     params=task.to_str_params(),\n                                     family=task.task_family,\n                                     new_deps=new_deps)\n\n            if status == RUNNING:\n                continue\n            self._running_tasks.pop(task_id)\n\n            # re-add task to reschedule missing dependencies\n            if missing:\n                reschedule = True\n\n                # keep out of infinite loops by not rescheduling too many times\n                for task_id in missing:\n                    self.unfulfilled_counts[task_id] += 1\n                    if (self.unfulfilled_counts[task_id] >\n                            self.__max_reschedules):\n                        reschedule = False\n                if reschedule:\n                    self.add(task)\n\n            self.run_succeeded &= status in (DONE, SUSPENDED)\n            return",
        "begin_line": 618,
        "end_line": 679,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012091898428053204,
            "pseudo_dstar_susp": 0.0012062726176115801,
            "pseudo_tarantula_susp": 0.0015174506828528073,
            "pseudo_op2_susp": 0.0012062726176115801,
            "pseudo_barinel_susp": 0.0015174506828528073
        }
    },
    {
        "name": "luigi.worker.Worker._sleeper#681",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._sleeper(self)",
        "snippet": "    def _sleeper(self):\n        # TODO is exponential backoff necessary?\n        while True:\n            wait_interval = self.__wait_interval + random.randint(1, 5)\n            logger.debug('Sleeping for %d seconds', wait_interval)\n            time.sleep(wait_interval)\n            yield",
        "begin_line": 681,
        "end_line": 687,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018214936247723133,
            "pseudo_dstar_susp": 0.0015082956259426848,
            "pseudo_tarantula_susp": 0.002577319587628866,
            "pseudo_op2_susp": 0.0015082956259426848,
            "pseudo_barinel_susp": 0.002577319587628866
        }
    },
    {
        "name": "luigi.worker.Worker._keep_alive#689",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._keep_alive(self, n_pending_tasks, n_unique_pending)",
        "snippet": "    def _keep_alive(self, n_pending_tasks, n_unique_pending):\n        \"\"\"\n        Returns true if a worker should stay alive given.\n\n        If worker-keep-alive is not set, this will always return false.\n        Otherwise, it will return true for nonzero n_pending_tasks.\n\n        If worker-count-uniques is true, it will also\n        require that one of the tasks is unique to this worker.\n        \"\"\"\n        return (self.__keep_alive and n_pending_tasks and\n                (n_unique_pending or not self.__count_uniques))",
        "begin_line": 689,
        "end_line": 700,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0019157088122605363,
            "pseudo_dstar_susp": 0.002398081534772182,
            "pseudo_tarantula_susp": 0.0026455026455026454,
            "pseudo_op2_susp": 0.002398081534772182,
            "pseudo_barinel_susp": 0.0026455026455026454
        }
    },
    {
        "name": "luigi.worker.Worker.run#702",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker.run(self)",
        "snippet": "    def run(self):\n        \"\"\"\n        Returns True if all scheduled tasks were executed successfully.\n        \"\"\"\n        logger.info('Running Worker with %d processes', self.worker_processes)\n\n        sleeper = self._sleeper()\n        self.run_succeeded = True\n\n        self._add_worker()\n\n        while True:\n            while len(self._running_tasks) >= self.worker_processes:\n                logger.debug('%d running tasks, waiting for next task to finish', len(self._running_tasks))\n                self._handle_next_task()\n\n            task_id, running_tasks, n_pending_tasks, n_unique_pending = self._get_work()\n\n            if task_id is None:\n                self._log_remote_tasks(running_tasks, n_pending_tasks, n_unique_pending)\n                if len(self._running_tasks) == 0:\n                    if self._keep_alive(n_pending_tasks, n_unique_pending):\n                        six.next(sleeper)\n                        continue\n                    else:\n                        break\n                else:\n                    self._handle_next_task()\n                    continue\n\n            # task_id is not None:\n            logger.debug(\"Pending tasks: %s\", n_pending_tasks)\n            self._run_task(task_id)\n\n        while len(self._running_tasks):\n            logger.debug('Shut down Worker, %d more tasks to go', len(self._running_tasks))\n            self._handle_next_task()\n\n        return self.run_succeeded",
        "begin_line": 702,
        "end_line": 740,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0019157088122605363,
            "pseudo_dstar_susp": 0.002331002331002331,
            "pseudo_tarantula_susp": 0.0026455026455026454,
            "pseudo_op2_susp": 0.002331002331002331,
            "pseudo_barinel_susp": 0.0026455026455026454
        }
    },
    {
        "name": "luigi.server.app#125",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server",
        "signature": "luigi.server.app(scheduler)",
        "snippet": "def app(scheduler):\n    handlers = [\n        (r'/api/(.*)', RPCHandler, {\"scheduler\": scheduler}),\n        (r'/static/(.*)', StaticFileHandler),\n        (r'/', RootPathHandler),\n        (r'/history', RecentRunHandler, {'scheduler': scheduler}),\n        (r'/history/by_name/(.*?)', ByNameHandler, {'scheduler': scheduler}),\n        (r'/history/by_id/(.*?)', ByIdHandler, {'scheduler': scheduler}),\n        (r'/history/by_params/(.*?)', ByParamsHandler, {'scheduler': scheduler})\n    ]\n    api_app = tornado.web.Application(handlers)\n    return api_app",
        "begin_line": 125,
        "end_line": 136,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.16666666666666666,
            "pseudo_dstar_susp": 0.029411764705882353,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.029411764705882353,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.server._init_api#139",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server",
        "signature": "luigi.server._init_api(scheduler, responder=None, api_port=None, address=None)",
        "snippet": "def _init_api(scheduler, responder=None, api_port=None, address=None):\n    if responder:\n        raise Exception('The \"responder\" argument is no longer supported')\n    api_app = app(scheduler)\n    api_sockets = tornado.netutil.bind_sockets(api_port, address=address)\n    server = tornado.httpserver.HTTPServer(api_app)\n    server.add_sockets(api_sockets)\n\n    # Return the bound socket names.  Useful for connecting client in test scenarios.\n    return [s.getsockname() for s in api_sockets]",
        "begin_line": 139,
        "end_line": 148,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.1,
            "pseudo_dstar_susp": 0.02857142857142857,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.02857142857142857,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.server.run#151",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server",
        "signature": "luigi.server.run(api_port=8082, address=None, scheduler=None, responder=None)",
        "snippet": "def run(api_port=8082, address=None, scheduler=None, responder=None):\n    \"\"\"\n    Runs one instance of the API server.\n    \"\"\"\n    if scheduler is None:\n        scheduler = CentralPlannerScheduler()\n\n    # load scheduler state\n    scheduler.load()\n\n    _init_api(scheduler, responder, api_port, address)\n\n    # prune work DAG every 60 seconds\n    pruner = tornado.ioloop.PeriodicCallback(scheduler.prune, 60000)\n    pruner.start()\n\n    def shutdown_handler(foo=None, bar=None):\n        logger.info(\"Scheduler instance shutting down\")\n        scheduler.dump()\n        os._exit(0)\n\n    signal.signal(signal.SIGINT, shutdown_handler)\n    signal.signal(signal.SIGTERM, shutdown_handler)\n    if os.name == 'nt':\n        signal.signal(signal.SIGBREAK, shutdown_handler)\n    else:\n        signal.signal(signal.SIGQUIT, shutdown_handler)\n    atexit.register(shutdown_handler)\n\n    logger.info(\"Scheduler starting up\")\n\n    tornado.ioloop.IOLoop.instance().start()",
        "begin_line": 151,
        "end_line": 182,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.017543859649122806,
            "pseudo_dstar_susp": 0.007352941176470588,
            "pseudo_tarantula_susp": 0.004901960784313725,
            "pseudo_op2_susp": 0.007352941176470588,
            "pseudo_barinel_susp": 0.004901960784313725
        }
    },
    {
        "name": "luigi.server.stop#185",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server",
        "signature": "luigi.server.stop()",
        "snippet": "def stop():\n    tornado.ioloop.IOLoop.instance().stop()",
        "begin_line": 185,
        "end_line": 186,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02040816326530612,
            "pseudo_dstar_susp": 0.007518796992481203,
            "pseudo_tarantula_susp": 0.005050505050505051,
            "pseudo_op2_susp": 0.007518796992481203,
            "pseudo_barinel_susp": 0.005050505050505051
        }
    },
    {
        "name": "luigi.contrib.webhdfs.WebHdfsClient.__init__#157",
        "src_path": "luigi/contrib/webhdfs.py",
        "class_name": "luigi.contrib.webhdfs.WebHdfsClient",
        "signature": "luigi.contrib.webhdfs.WebHdfsClient.__init__(self, host=None, port=None, user=None)",
        "snippet": "    def __init__(self, host=None, port=None, user=None):\n        host = self.get_config('namenode_host') if host is None else host\n        port = self.get_config('namenode_port') if port is None else port\n        user = self.get_config('user') if user is None else os.environ['USER']\n\n        url = 'http://' + host + ':' + port\n        self.webhdfs = webhdfs.InsecureClient(url=url, user=user)",
        "begin_line": 157,
        "end_line": 163,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02,
            "pseudo_dstar_susp": 0.0038314176245210726,
            "pseudo_tarantula_susp": 0.007142857142857143,
            "pseudo_op2_susp": 0.0038314176245210726,
            "pseudo_barinel_susp": 0.007142857142857143
        }
    },
    {
        "name": "luigi.contrib.webhdfs.WebHdfsClient.get_config#165",
        "src_path": "luigi/contrib/webhdfs.py",
        "class_name": "luigi.contrib.webhdfs.WebHdfsClient",
        "signature": "luigi.contrib.webhdfs.WebHdfsClient.get_config(self, key)",
        "snippet": "    def get_config(self, key):\n        config = configuration.get_config()\n        try:\n            return config.get('hdfs', key)\n        except:\n            raise RuntimeError(\"You must specify %s in the [hdfs] section of \"\n                               \"the luigi client.cfg file\" % key)",
        "begin_line": 165,
        "end_line": 171,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.023255813953488372,
            "pseudo_dstar_susp": 0.00392156862745098,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.00392156862745098,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.task.Register.__new__#71",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Register",
        "signature": "luigi.task.Register.__new__(metacls, classname, bases, classdict)",
        "snippet": "    def __new__(metacls, classname, bases, classdict):\n        \"\"\"\n        Custom class creation for namespacing.\n\n        Also register all subclasses.\n\n        Set the task namespace to whatever the currently declared namespace is.\n        \"\"\"\n        if \"task_namespace\" not in classdict:\n            classdict[\"task_namespace\"] = metacls._default_namespace\n\n        cls = super(Register, metacls).__new__(metacls, classname, bases, classdict)\n        metacls._reg.append(cls)\n\n        return cls",
        "begin_line": 71,
        "end_line": 85,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0031645569620253164,
            "pseudo_dstar_susp": 0.006060606060606061,
            "pseudo_tarantula_susp": 0.0027624309392265192,
            "pseudo_op2_susp": 0.006060606060606061,
            "pseudo_barinel_susp": 0.0027624309392265192
        }
    },
    {
        "name": "luigi.task.Register.__call__#87",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Register",
        "signature": "luigi.task.Register.__call__(cls, *args, **kwargs)",
        "snippet": "    def __call__(cls, *args, **kwargs):\n        \"\"\"\n        Custom class instantiation utilizing instance cache.\n\n        If a Task has already been instantiated with the same parameters,\n        the previous instance is returned to reduce number of object instances.\n        \"\"\"\n        def instantiate():\n            return super(Register, cls).__call__(*args, **kwargs)\n\n        h = Register.__instance_cache\n\n        if h is None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        try:\n            hash(k)\n        except TypeError:\n            logger.debug(\"Not all parameter values are hashable so instance isn't coming from the cache\")\n            return instantiate()  # unhashable types in parameters\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]",
        "begin_line": 87,
        "end_line": 116,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008771929824561403,
            "pseudo_dstar_susp": 0.16666666666666666,
            "pseudo_tarantula_susp": 0.002531645569620253,
            "pseudo_op2_susp": 0.25,
            "pseudo_barinel_susp": 0.002531645569620253
        }
    },
    {
        "name": "luigi.task.Register.instantiate#94",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Register",
        "signature": "luigi.task.Register.instantiate()",
        "snippet": "        def instantiate():\n            return super(Register, cls).__call__(*args, **kwargs)",
        "begin_line": 94,
        "end_line": 95,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008928571428571428,
            "pseudo_dstar_susp": 0.3333333333333333,
            "pseudo_tarantula_susp": 0.0023148148148148147,
            "pseudo_op2_susp": 0.3333333333333333,
            "pseudo_barinel_susp": 0.0023148148148148147
        }
    },
    {
        "name": "luigi.task.Register.task_family#133",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Register",
        "signature": "luigi.task.Register.task_family(cls)",
        "snippet": "    def task_family(cls):\n        \"\"\"\n        The task family for the given class.\n\n        If ``cls.task_namespace is None`` then it's the name of the class.\n        Otherwise, ``<task_namespace>.`` is prefixed to the class name.\n        \"\"\"\n        if cls.task_namespace is None:\n            return cls.__name__\n        else:\n            return \"%s.%s\" % (cls.task_namespace, cls.__name__)",
        "begin_line": 133,
        "end_line": 143,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004545454545454545,
            "pseudo_dstar_susp": 0.05,
            "pseudo_tarantula_susp": 0.0032258064516129032,
            "pseudo_op2_susp": 0.05,
            "pseudo_barinel_susp": 0.0032258064516129032
        }
    },
    {
        "name": "luigi.task.Register.get_reg#146",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Register",
        "signature": "luigi.task.Register.get_reg(cls, include_config_without_section=False)",
        "snippet": "    def get_reg(cls, include_config_without_section=False):\n        \"\"\"Return all of the registery classes.\n\n        :return:  a ``dict`` of task_family -> class\n        \"\"\"\n        # We have to do this on-demand in case task names have changed later\n        reg = {}\n        for cls in cls._reg:\n            if cls.run == NotImplemented:\n                continue\n            if issubclass(cls, ConfigWithoutSection) and not include_config_without_section:\n                continue\n            name = cls.task_family\n\n            if name in reg and reg[name] != cls and \\\n                    reg[name] != cls.AMBIGUOUS_CLASS and \\\n                    not issubclass(cls, reg[name]):\n                # Registering two different classes - this means we can't instantiate them by name\n                # The only exception is if one class is a subclass of the other. In that case, we\n                # instantiate the most-derived class (this fixes some issues with decorator wrappers).\n                reg[name] = cls.AMBIGUOUS_CLASS\n            else:\n                reg[name] = cls\n\n        return reg",
        "begin_line": 146,
        "end_line": 170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001949317738791423,
            "pseudo_dstar_susp": 0.0018248175182481751,
            "pseudo_tarantula_susp": 0.004524886877828055,
            "pseudo_op2_susp": 0.0018248175182481751,
            "pseudo_barinel_susp": 0.0045045045045045045
        }
    },
    {
        "name": "luigi.task.Register.tasks_str#173",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Register",
        "signature": "luigi.task.Register.tasks_str(cls)",
        "snippet": "    def tasks_str(cls):\n        \"\"\"\n        Human-readable register contents dump.\n        \"\"\"\n        return repr(sorted(Register.get_reg().keys()))",
        "begin_line": 173,
        "end_line": 177,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002770083102493075,
            "pseudo_dstar_susp": 0.0013157894736842105,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.0013157894736842105,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.task.Register.get_task_cls#180",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Register",
        "signature": "luigi.task.Register.get_task_cls(cls, name)",
        "snippet": "    def get_task_cls(cls, name):\n        \"\"\"\n        Returns an unambiguous class or raises an exception.\n        \"\"\"\n        task_cls = Register.get_reg().get(name)\n        if not task_cls:\n            raise Exception('Task %r not found. Candidates are: %s' % (name, Register.tasks_str()))\n        if task_cls == Register.AMBIGUOUS_CLASS:\n            raise Exception('Task %r is ambiguous' % name)\n        return task_cls",
        "begin_line": 180,
        "end_line": 189,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013404825737265416,
            "pseudo_dstar_susp": 0.0017985611510791368,
            "pseudo_tarantula_susp": 0.0013245033112582781,
            "pseudo_op2_susp": 0.0017985611510791368,
            "pseudo_barinel_susp": 0.0013245033112582781
        }
    },
    {
        "name": "luigi.task.Register.get_all_params#192",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Register",
        "signature": "luigi.task.Register.get_all_params(cls)",
        "snippet": "    def get_all_params(cls):\n        \"\"\"\n        Compiles and returns all parameters for all :py:class:`Task`.\n\n        :return: a ``dict`` of parameter name -> parameter.\n        \"\"\"\n        for task_name, task_cls in six.iteritems(cls.get_reg(include_config_without_section=True)):\n            if task_cls == cls.AMBIGUOUS_CLASS:\n                continue\n            for param_name, param_obj in task_cls.get_params():\n                yield task_name, issubclass(task_cls, ConfigWithoutSection), param_name, param_obj",
        "begin_line": 192,
        "end_line": 202,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017543859649122807,
            "pseudo_dstar_susp": 0.0018726591760299626,
            "pseudo_tarantula_susp": 0.0019801980198019802,
            "pseudo_op2_susp": 0.0018726591760299626,
            "pseudo_barinel_susp": 0.0019801980198019802
        }
    },
    {
        "name": "luigi.task.Task.wrapped#261",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.wrapped(callback)",
        "snippet": "        def wrapped(callback):\n            cls._event_callbacks.setdefault(cls, {}).setdefault(event, set()).add(callback)\n            return callback",
        "begin_line": 261,
        "end_line": 263,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.task.Task.event_handler#257",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.event_handler(cls, event)",
        "snippet": "    def event_handler(cls, event):\n        \"\"\"\n        Decorator for adding event handlers.\n        \"\"\"\n        def wrapped(callback):\n            cls._event_callbacks.setdefault(cls, {}).setdefault(event, set()).add(callback)\n            return callback\n        return wrapped",
        "begin_line": 257,
        "end_line": 264,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004894762604013706,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.task.Task.trigger_event#266",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.trigger_event(self, event, *args, **kwargs)",
        "snippet": "    def trigger_event(self, event, *args, **kwargs):\n        \"\"\"\n        Trigger that calls all of the specified events associated with this class.\n        \"\"\"\n        for event_class, event_callbacks in six.iteritems(self._event_callbacks):\n            if not isinstance(self, event_class):\n                continue\n            for callback in event_callbacks.get(event, []):\n                try:\n                    # callbacks are protected\n                    callback(*args, **kwargs)\n                except KeyboardInterrupt:\n                    return\n                except BaseException:\n                    logger.exception(\"Error in event callback for %r\", event)",
        "begin_line": 266,
        "end_line": 280,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001287001287001287,
            "pseudo_dstar_susp": 0.001445086705202312,
            "pseudo_tarantula_susp": 0.0016863406408094434,
            "pseudo_op2_susp": 0.001445086705202312,
            "pseudo_barinel_susp": 0.0016863406408094434
        }
    },
    {
        "name": "luigi.task.Task.task_family#289",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.task_family(self)",
        "snippet": "    def task_family(self):\n        \"\"\"\n        Convenience method since a property on the metaclass isn't directly accessible through the class instances.\n        \"\"\"\n        return self.__class__.task_family",
        "begin_line": 289,
        "end_line": 293,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003484320557491289,
            "pseudo_dstar_susp": 0.010869565217391304,
            "pseudo_tarantula_susp": 0.0021691973969631237,
            "pseudo_op2_susp": 0.010869565217391304,
            "pseudo_barinel_susp": 0.0021691973969631237
        }
    },
    {
        "name": "luigi.task.Task.get_params#296",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.get_params(cls)",
        "snippet": "    def get_params(cls):\n        \"\"\"\n        Returns all of the Parameters for this Task.\n        \"\"\"\n        # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter):\n                continue\n\n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1].counter)\n        return params",
        "begin_line": 296,
        "end_line": 311,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007352941176470588,
            "pseudo_dstar_susp": 0.1111111111111111,
            "pseudo_tarantula_susp": 0.004694835680751174,
            "pseudo_op2_susp": 0.1111111111111111,
            "pseudo_barinel_susp": 0.004694835680751174
        }
    },
    {
        "name": "luigi.task.Task.get_param_values#314",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.get_param_values(cls, params, args, kwargs)",
        "snippet": "    def get_param_values(cls, params, args, kwargs):\n        \"\"\"\n        Get the values of the parameters from the args and kwargs.\n\n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n        result = {}\n\n        params_dict = dict(params)\n\n        task_name = cls.task_family\n\n        # In case any exceptions are thrown, create a helpful description of how the Task was invoked\n        # TODO: should we detect non-reprable arguments? These will lead to mysterious errors\n        exc_desc = '%s[args=%s, kwargs=%s]' % (task_name, args, kwargs)\n\n        # Fill in the positional arguments\n        positional_params = [(n, p) for n, p in params if p.significant]\n        for i, arg in enumerate(args):\n            if i >= len(positional_params):\n                raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n            param_name, param_obj = positional_params[i]\n            result[param_name] = arg\n\n        # Then the optional arguments\n        for param_name, arg in six.iteritems(kwargs):\n            if param_name in result:\n                raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n            if param_name not in params_dict:\n                raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n            result[param_name] = arg\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_task_value(task_name, param_name):\n                    raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n                result[param_name] = param_obj.task_value(task_name, param_name)\n\n        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n            if isinstance(x, list) or isinstance(x, set):\n                return tuple(x)\n            else:\n                return x\n        # Sort it by the correct order and make a list\n        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]",
        "begin_line": 314,
        "end_line": 363,
        "comment": "",
        "is_bug": true,
        "susp": {
            "pseudo_ochiai_susp": 0.007518796992481203,
            "pseudo_dstar_susp": 0.08333333333333333,
            "pseudo_tarantula_susp": 0.004784688995215311,
            "pseudo_op2_susp": 0.08333333333333333,
            "pseudo_barinel_susp": 0.004784688995215311
        }
    },
    {
        "name": "luigi.task.Task.list_to_tuple#356",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.list_to_tuple(x)",
        "snippet": "        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n            if isinstance(x, list) or isinstance(x, set):\n                return tuple(x)\n            else:\n                return x",
        "begin_line": 356,
        "end_line": 361,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004347826086956522,
            "pseudo_dstar_susp": 0.02127659574468085,
            "pseudo_tarantula_susp": 0.0029498525073746312,
            "pseudo_op2_susp": 0.02127659574468085,
            "pseudo_barinel_susp": 0.0029498525073746312
        }
    },
    {
        "name": "luigi.task.Task.__init__#365",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Constructor to resolve values for all Parameters.\n\n        For example, the Task:\n\n        .. code-block:: python\n\n            class MyTask(luigi.Task):\n                count = luigi.IntParameter()\n\n        can be instantiated as ``MyTask(count=10)``.\n        \"\"\"\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        # Register args and kwargs as an attribute on the class. Might be useful\n        self.param_args = tuple(value for key, value in param_values)\n        self.param_kwargs = dict(param_values)\n\n        # Build up task id\n        task_id_parts = []\n        param_objs = dict(params)\n        for param_name, param_value in param_values:\n            if dict(params)[param_name].significant:\n                task_id_parts.append('%s=%s' % (param_name, param_objs[param_name].serialize(param_value)))\n\n        self.task_id = '%s(%s)' % (self.task_family, ', '.join(task_id_parts))\n        self.__hash = hash(self.task_id)",
        "begin_line": 365,
        "end_line": 397,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0040650406504065045,
            "pseudo_dstar_susp": 0.011111111111111112,
            "pseudo_tarantula_susp": 0.0038314176245210726,
            "pseudo_op2_susp": 0.011111111111111112,
            "pseudo_barinel_susp": 0.0038314176245210726
        }
    },
    {
        "name": "luigi.task.Task.from_str_params#406",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.from_str_params(cls, params_str=None)",
        "snippet": "    def from_str_params(cls, params_str=None):\n        \"\"\"\n        Creates an instance from a str->str hash.\n\n        :param params_str: dict of param name -> value.\n        \"\"\"\n        if params_str is None:\n            params_str = {}\n        kwargs = {}\n        for param_name, param in cls.get_params():\n            value = param.parse_from_input(param_name, params_str[param_name])\n            kwargs[param_name] = value\n\n        return cls(**kwargs)",
        "begin_line": 406,
        "end_line": 419,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.task.Task.to_str_params#421",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.to_str_params(self)",
        "snippet": "    def to_str_params(self):\n        # Convert all parameters to a str->str hash\n        params_str = {}\n        params = dict(self.get_params())\n        for param_name, param_value in six.iteritems(self.param_kwargs):\n            params_str[param_name] = params[param_name].serialize(param_value)\n\n        return params_str",
        "begin_line": 421,
        "end_line": 428,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012091898428053204,
            "pseudo_dstar_susp": 0.0012062726176115801,
            "pseudo_tarantula_susp": 0.0015174506828528073,
            "pseudo_op2_susp": 0.0012062726176115801,
            "pseudo_barinel_susp": 0.0015174506828528073
        }
    },
    {
        "name": "luigi.task.Task.clone#430",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.clone(self, cls=None, **kwargs)",
        "snippet": "    def clone(self, cls=None, **kwargs):\n        \"\"\"\n        Creates a new instance from an existing instance where some of the args have changed.\n\n        There's at least two scenarios where this is useful (see test/clone_test.py):\n\n        * remove a lot of boiler plate when you have recursive dependencies and lots of args\n        * there's task inheritance and some logic is on the base class\n\n        :param cls:\n        :param kwargs:\n        :return:\n        \"\"\"\n        k = self.param_kwargs.copy()\n        k.update(six.iteritems(kwargs))\n\n        if cls is None:\n            cls = self.__class__\n\n        new_k = {}\n        for param_name, param_class in cls.get_params():\n            if param_name in k:\n                new_k[param_name] = k[param_name]\n\n        return cls(**new_k)",
        "begin_line": 430,
        "end_line": 454,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.task.Task.__repr__#459",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.__repr__(self)",
        "snippet": "    def __repr__(self):\n        return self.task_id",
        "begin_line": 459,
        "end_line": 460,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00145985401459854,
            "pseudo_dstar_susp": 0.002127659574468085,
            "pseudo_tarantula_susp": 0.00196078431372549,
            "pseudo_op2_susp": 0.002127659574468085,
            "pseudo_barinel_susp": 0.00196078431372549
        }
    },
    {
        "name": "luigi.task.Task.__eq__#462",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.__eq__(self, other)",
        "snippet": "    def __eq__(self, other):\n        return self.__class__ == other.__class__ and self.param_args == other.param_args",
        "begin_line": 462,
        "end_line": 463,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.task.Task.complete#465",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.complete(self)",
        "snippet": "    def complete(self):\n        \"\"\"\n        If the task has any outputs, return ``True`` if all outputs exists.\n        Otherwise, return ``False``.\n\n        However, you may freely override this method with custom logic.\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            warnings.warn(\n                \"Task %r without outputs has no custom complete() method\" % self,\n                stacklevel=2\n            )\n            return False\n\n        return all(map(lambda output: output.exists(), outputs))",
        "begin_line": 465,
        "end_line": 480,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001669449081803005,
            "pseudo_dstar_susp": 0.001488095238095238,
            "pseudo_tarantula_susp": 0.002347417840375587,
            "pseudo_op2_susp": 0.001488095238095238,
            "pseudo_barinel_susp": 0.002352941176470588
        }
    },
    {
        "name": "luigi.task.Task.bulk_complete#483",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.bulk_complete(cls, parameter_tuples)",
        "snippet": "    def bulk_complete(cls, parameter_tuples):\n        \"\"\"\n        Returns those of parameter_tuples for which this Task is complete.\n\n        Override (with an efficient implementation) for efficient scheduling\n        with range tools. Keep the logic consistent with that of complete().\n        \"\"\"\n        raise NotImplementedError",
        "begin_line": 483,
        "end_line": 490,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.task.Task.output#492",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.output(self)",
        "snippet": "    def output(self):\n        \"\"\"\n        The output that this Task produces.\n\n        The output of the Task determines if the Task needs to be run--the task\n        is considered finished iff the outputs all exist. Subclasses should\n        override this method to return a single :py:class:`Target` or a list of\n        :py:class:`Target` instances.\n\n        Implementation note\n          If running multiple workers, the output must be a resource that is accessible\n          by all workers, such as a DFS or database. Otherwise, workers might compute\n          the same output since they don't see the work done by other workers.\n        \"\"\"\n        return []  # default impl",
        "begin_line": 492,
        "end_line": 506,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001949317738791423,
            "pseudo_dstar_susp": 0.0013850415512465374,
            "pseudo_tarantula_susp": 0.003115264797507788,
            "pseudo_op2_susp": 0.0013850415512465374,
            "pseudo_barinel_susp": 0.003115264797507788
        }
    },
    {
        "name": "luigi.task.Task.requires#508",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.requires(self)",
        "snippet": "    def requires(self):\n        \"\"\"\n        The Tasks that this Task depends on.\n\n        A Task will only run if all of the Tasks that it requires are completed.\n        If your Task does not require any other Tasks, then you don't need to\n        override this method. Otherwise, a Subclasses can override this method\n        to return a single Task, a list of Task instances, or a dict whose\n        values are Task instances.\n        \"\"\"\n        return []  # default impl",
        "begin_line": 508,
        "end_line": 518,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011668611435239206,
            "pseudo_dstar_susp": 0.0011668611435239206,
            "pseudo_tarantula_susp": 0.0011682242990654205,
            "pseudo_op2_susp": 0.0011668611435239206,
            "pseudo_barinel_susp": 0.0011682242990654205
        }
    },
    {
        "name": "luigi.task.Task._requires#520",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task._requires(self)",
        "snippet": "    def _requires(self):\n        \"\"\"\n        Override in \"template\" tasks which themselves are supposed to be\n        subclassed and thus have their requires() overridden (name preserved to\n        provide consistent end-user experience), yet need to introduce\n        (non-input) dependencies.\n\n        Must return an iterable which among others contains the _requires() of\n        the superclass.\n        \"\"\"\n        return flatten(self.requires())  # base impl",
        "begin_line": 520,
        "end_line": 530,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014388489208633094,
            "pseudo_dstar_susp": 0.001443001443001443,
            "pseudo_tarantula_susp": 0.0022172949002217295,
            "pseudo_op2_susp": 0.001443001443001443,
            "pseudo_barinel_susp": 0.0022172949002217295
        }
    },
    {
        "name": "luigi.task.Task.process_resources#532",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.process_resources(self)",
        "snippet": "    def process_resources(self):\n        \"\"\"\n        Override in \"template\" tasks which provide common resource functionality\n        but allow subclasses to specify additional resources while preserving\n        the name for consistent end-user experience.\n        \"\"\"\n        return self.resources  # default impl",
        "begin_line": 532,
        "end_line": 538,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011918951132300357,
            "pseudo_dstar_susp": 0.0011904761904761906,
            "pseudo_tarantula_susp": 0.0014388489208633094,
            "pseudo_op2_susp": 0.0011904761904761906,
            "pseudo_barinel_susp": 0.0014388489208633094
        }
    },
    {
        "name": "luigi.task.Task.input#540",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.input(self)",
        "snippet": "    def input(self):\n        \"\"\"\n        Returns the outputs of the Tasks returned by :py:meth:`requires`\n\n        :return: a list of :py:class:`Target` objects which are specified as\n                 outputs of all required Tasks.\n        \"\"\"\n        return getpaths(self.requires())",
        "begin_line": 540,
        "end_line": 547,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005488474204171241,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.task.Task.deps#549",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.deps(self)",
        "snippet": "    def deps(self):\n        \"\"\"\n        Internal method used by the scheduler.\n\n        Returns the flattened list of requires.\n        \"\"\"\n        # used by scheduler\n        return flatten(self._requires())",
        "begin_line": 549,
        "end_line": 556,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001221001221001221,
            "pseudo_dstar_susp": 0.0014347202295552368,
            "pseudo_tarantula_susp": 0.001184834123222749,
            "pseudo_op2_susp": 0.0014347202295552368,
            "pseudo_barinel_susp": 0.001184834123222749
        }
    },
    {
        "name": "luigi.task.Task.run#558",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.run(self)",
        "snippet": "    def run(self):\n        \"\"\"\n        The task run method, to be overridden in a subclass.\n        \"\"\"\n        pass  # default impl",
        "begin_line": 558,
        "end_line": 562,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.task.Task.on_failure#564",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.on_failure(self, exception)",
        "snippet": "    def on_failure(self, exception):\n        \"\"\"\n        Override for custom error handling.\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        Return value of this method is json encoded and sent to the scheduler as the `expl` argument. Its string representation will be used as the body of the error email sent out if any.\n\n        Default behavior is to return a string representation of the stack trace.\n        \"\"\"\n\n        traceback_string = traceback.format_exc()\n        return \"Runtime error:\\n%s\" % traceback_string",
        "begin_line": 564,
        "end_line": 575,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004657661853749418,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.task.WrapperTask.complete#628",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.WrapperTask",
        "signature": "luigi.task.WrapperTask.complete(self)",
        "snippet": "    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))",
        "begin_line": 628,
        "end_line": 629,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.task.getpaths#651",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task",
        "signature": "luigi.task.getpaths(struct)",
        "snippet": "def getpaths(struct):\n    \"\"\"\n    Maps all Tasks in a structured data object to their .output().\n    \"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in six.iteritems(struct):\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n\n        return [getpaths(r) for r in s]",
        "begin_line": 651,
        "end_line": 669,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.task.flatten#672",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task",
        "signature": "luigi.task.flatten(struct)",
        "snippet": "def flatten(struct):\n    \"\"\"\n    Creates a flat list of all all items in structured output (dicts, lists, items):\n\n    .. code-block:: python\n\n        >>> flatten({'a': 'foo', 'b': 'bar'})\n        ['foo', 'bar']\n        >>> flatten(['foo', ['bar', 'troll']])\n        ['foo', 'bar', 'troll']\n        >>> flatten('foo')\n        ['foo']\n        >>> flatten(42)\n        [42]\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for _, result in six.iteritems(struct):\n            flat += flatten(result)\n        return flat\n    if isinstance(struct, six.string_types):\n        return [struct]\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]",
        "begin_line": 672,
        "end_line": 705,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002074688796680498,
            "pseudo_dstar_susp": 0.004405286343612335,
            "pseudo_tarantula_susp": 0.0026455026455026454,
            "pseudo_op2_susp": 0.004405286343612335,
            "pseudo_barinel_susp": 0.0026455026455026454
        }
    },
    {
        "name": "luigi.task.flatten_output#708",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task",
        "signature": "luigi.task.flatten_output(task)",
        "snippet": "def flatten_output(task):\n    \"\"\"\n    Lists all output targets by recursively walking output-less (wrapper) tasks.\n\n    FIXME order consistently.\n    \"\"\"\n    r = flatten(task.output())\n    if not r:\n        for dep in flatten(task.requires()):\n            r += flatten_output(dep)\n    return r",
        "begin_line": 708,
        "end_line": 718,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.target.get_char_mode#25",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target",
        "signature": "luigi.target.get_char_mode(mode)",
        "snippet": "def get_char_mode(mode):\n    \"\"\"determine if a target should be open in text or binary mode\n    \"\"\"\n    if 'b' in mode:\n        return 'b'\n    if 't' in mode:\n        return 't'\n    if six.PY2:\n        # support mixed mode (binary but \\n is converted to platform newline)\n        # retrocompatibility with python2 on windows\n        return 'm'\n    return 't'",
        "begin_line": 25,
        "end_line": 36,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.00043956043956043956,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.target.FileSystemTarget.__init__#159",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.FileSystemTarget",
        "signature": "luigi.target.FileSystemTarget.__init__(self, path)",
        "snippet": "    def __init__(self, path):\n        \"\"\"\n        Initializes a FileSystemTarget instance.\n\n        :param str path: the path associated with this FileSystemTarget.\n        \"\"\"\n        self.path = path",
        "begin_line": 159,
        "end_line": 165,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.00044863167339614175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.target.FileSystemTarget.exists#188",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.FileSystemTarget",
        "signature": "luigi.target.FileSystemTarget.exists(self)",
        "snippet": "    def exists(self):\n        \"\"\"\n        Returns ``True`` if the path for this FileSystemTarget exists; ``False`` otherwise.\n\n        This method is implemented by using :py:meth:`fs`.\n        \"\"\"\n        path = self.path\n        if '*' in path or '?' in path or '[' in path or '{' in path:\n            logger.warning(\"Using wildcards in path %s might lead to processing of an incomplete dataset; \"\n                           \"override exists() to suppress the warning.\", path)\n        return self.fs.exists(path)",
        "begin_line": 188,
        "end_line": 198,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.00043956043956043956,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.parameter.Parameter.__init__#100",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.__init__(self, default=_no_value, is_list=False, is_boolean=False, is_global=False, significant=True, description=None, config_path=None)",
        "snippet": "    def __init__(self, default=_no_value, is_list=False, is_boolean=False, is_global=False, significant=True, description=None,\n                 config_path=None):\n        \"\"\"\n        :param default: the default value for this parameter. This should match the type of the\n                        Parameter, i.e. ``datetime.date`` for ``DateParameter`` or ``int`` for\n                        ``IntParameter``. By default, no default is stored and\n                        the value must be specified at runtime.\n        :param bool is_list: specify ``True`` if the parameter should allow a list of values rather\n                             than a single value. Default: ``False``. A list has an implicit default\n                             value of ``[]``.\n        :param bool is_bool: specify ``True`` if the parameter is a bool value. Default:\n                                ``False``. Bool's have an implicit default value of ``False``.\n        :param bool is_global: specify ``True`` if the parameter is global (i.e. used by multiple\n                               Tasks). Default: ``False``. DEPRECATED.\n        :param bool significant: specify ``False`` if the parameter should not be treated as part of\n                                 the unique identifier for a Task. An insignificant Parameter might\n                                 also be used to specify a password or other sensitive information\n                                 that should not be made public via the scheduler. Default:\n                                 ``True``.\n        :param str description: A human-readable string describing the purpose of this Parameter.\n                                For command-line invocations, this will be used as the `help` string\n                                shown to users. Default: ``None``.\n        :param dict config_path: a dictionary with entries ``section`` and ``name``\n                                 specifying a config file entry from which to read the\n                                 default value for this parameter. DEPRECATED.\n                                 Default: ``None``.\n        \"\"\"\n        # The default default is no default\n        self.__default = default\n        self.__global = _no_value\n\n        self.is_list = is_list\n        self.is_bool = is_boolean and not is_list  # Only BoolParameter should ever use this. TODO(erikbern): should we raise some kind of exception?\n        self.is_global = is_global  # It just means that the default value is exposed and you can override it\n        self.significant = significant  # Whether different values for this parameter will differentiate otherwise equal tasks\n\n        if is_global:\n            warnings.warn(\n                'is_global is deprecated and will be removed. Please use either '\n                ' (a) class level config (eg. --MyTask-my-param 42)'\n                ' (b) a separate Config class with global settings on it',\n                DeprecationWarning,\n                stacklevel=2)\n\n        if is_global and default == _no_value and config_path is None:\n            raise ParameterException('Global parameters need default values')\n\n        self.description = description\n\n        if config_path is not None and ('section' not in config_path or 'name' not in config_path):\n            raise ParameterException('config_path must be a hash containing entries for section and name')\n        self.__config = config_path\n\n        self.counter = Parameter.counter  # We need to keep track of this to get the order right (see Task class)\n        Parameter.counter += 1",
        "begin_line": 100,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0038910505836575876,
            "pseudo_dstar_susp": 0.006756756756756757,
            "pseudo_tarantula_susp": 0.005263157894736842,
            "pseudo_op2_susp": 0.006756756756756757,
            "pseudo_barinel_susp": 0.005263157894736842
        }
    },
    {
        "name": "luigi.parameter.Parameter._get_value_from_config#156",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter._get_value_from_config(self, section, name)",
        "snippet": "    def _get_value_from_config(self, section, name):\n        \"\"\"Loads the default from the config. Returns _no_value if it doesn't exist\"\"\"\n\n        conf = configuration.get_config()\n\n        try:\n            value = conf.get(section, name)\n        except (NoSectionError, NoOptionError):\n            return _no_value\n\n        if self.is_list:\n            return tuple(self.parse(p.strip()) for p in value.strip().split('\\n'))\n        else:\n            return self.parse(value)",
        "begin_line": 156,
        "end_line": 169,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02702702702702703,
            "pseudo_dstar_susp": 0.1,
            "pseudo_tarantula_susp": 0.003676470588235294,
            "pseudo_op2_susp": 0.1,
            "pseudo_barinel_susp": 0.003676470588235294
        }
    },
    {
        "name": "luigi.parameter.Parameter._get_value#171",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter._get_value(self, task_name=None, param_name=None)",
        "snippet": "    def _get_value(self, task_name=None, param_name=None):\n        if self.__global != _no_value:\n            return self.__global\n        if task_name and param_name:\n            v = self._get_value_from_config(task_name, param_name)\n            if v != _no_value:\n                return v\n        if self.__config:\n            v = self._get_value_from_config(self.__config['section'], self.__config['name'])\n            if v != _no_value and task_name and param_name:\n                warnings.warn(\n                    'The use of the configuration %s>%s is deprecated. Please use %s>%s' %\n                    (self.__config['section'], self.__config['name'], task_name, param_name),\n                    DeprecationWarning, stacklevel=2)\n            if v != _no_value:\n                return v\n        if self.__default != _no_value:\n            return self.__default\n\n        return _no_value",
        "begin_line": 171,
        "end_line": 190,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008064516129032258,
            "pseudo_dstar_susp": 0.14285714285714285,
            "pseudo_tarantula_susp": 0.0025380710659898475,
            "pseudo_op2_susp": 0.14285714285714285,
            "pseudo_barinel_susp": 0.0025380710659898475
        }
    },
    {
        "name": "luigi.parameter.Parameter.has_value#193",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.has_value(self)",
        "snippet": "    def has_value(self):\n        \"\"\"\n        ``True`` if a default was specified or if config_path references a valid entry in the conf.\n\n        Note that \"value\" refers to the Parameter object itself - it can be either\n\n        1. The default value for this parameter\n        2. A value read from the config\n        3. A global value\n\n        Any Task instance can have its own value set that overrides this.\n        \"\"\"\n        return self._get_value() != _no_value",
        "begin_line": 193,
        "end_line": 205,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013003901170351106,
            "pseudo_dstar_susp": 0.0013531799729364006,
            "pseudo_tarantula_susp": 0.0016420361247947454,
            "pseudo_op2_susp": 0.0013531799729364006,
            "pseudo_barinel_susp": 0.0016420361247947454
        }
    },
    {
        "name": "luigi.parameter.Parameter.value#208",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.value(self)",
        "snippet": "    def value(self):\n        \"\"\"\n        The value for this Parameter.\n\n        This refers to any value defined by a default, a config option, or\n        a global value.\n\n        :raises MissingParameterException: if a value is not set.\n        :return: the parsed value.\n        \"\"\"\n        value = self._get_value()\n        if value == _no_value:\n            raise MissingParameterException(\"No default specified\")\n        else:\n            return value",
        "begin_line": 208,
        "end_line": 222,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013812154696132596,
            "pseudo_dstar_susp": 0.0018148820326678765,
            "pseudo_tarantula_susp": 0.0014705882352941176,
            "pseudo_op2_susp": 0.0018148820326678765,
            "pseudo_barinel_susp": 0.0014705882352941176
        }
    },
    {
        "name": "luigi.parameter.Parameter.has_task_value#224",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.has_task_value(self, task_name, param_name)",
        "snippet": "    def has_task_value(self, task_name, param_name):\n        return self._get_value(task_name, param_name) != _no_value",
        "begin_line": 224,
        "end_line": 225,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003937007874015748,
            "pseudo_dstar_susp": 0.015873015873015872,
            "pseudo_tarantula_susp": 0.0023094688221709007,
            "pseudo_op2_susp": 0.015873015873015872,
            "pseudo_barinel_susp": 0.0023094688221709007
        }
    },
    {
        "name": "luigi.parameter.Parameter.task_value#227",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.task_value(self, task_name, param_name)",
        "snippet": "    def task_value(self, task_name, param_name):\n        value = self._get_value(task_name, param_name)\n        if value == _no_value:\n            raise MissingParameterException(\"No default specified\")\n        else:\n            return value",
        "begin_line": 227,
        "end_line": 232,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00411522633744856,
            "pseudo_dstar_susp": 0.014285714285714285,
            "pseudo_tarantula_susp": 0.0023752969121140144,
            "pseudo_op2_susp": 0.014285714285714285,
            "pseudo_barinel_susp": 0.0023752969121140144
        }
    },
    {
        "name": "luigi.parameter.Parameter.set_global#234",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.set_global(self, value)",
        "snippet": "    def set_global(self, value):\n        \"\"\"\n        Set the global value of this Parameter.\n\n        :param value: the new global value.\n        \"\"\"\n        self.__global = value",
        "begin_line": 234,
        "end_line": 240,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002145922746781116,
            "pseudo_dstar_susp": 0.0036231884057971015,
            "pseudo_tarantula_susp": 0.0018083182640144665,
            "pseudo_op2_susp": 0.0036231884057971015,
            "pseudo_barinel_susp": 0.0018083182640144665
        }
    },
    {
        "name": "luigi.parameter.Parameter.reset_global#242",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.reset_global(self)",
        "snippet": "    def reset_global(self):\n        self.__global = _no_value",
        "begin_line": 242,
        "end_line": 243,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0019723865877712033,
            "pseudo_dstar_susp": 0.0025,
            "pseudo_tarantula_susp": 0.0019267822736030828,
            "pseudo_op2_susp": 0.0025,
            "pseudo_barinel_susp": 0.0019267822736030828
        }
    },
    {
        "name": "luigi.parameter.Parameter.parse#245",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.parse(self, x)",
        "snippet": "    def parse(self, x):\n        \"\"\"\n        Parse an individual value from the input.\n\n        The default implementation is an identify (it returns ``x``), but subclasses should override\n        this method for specialized parsing. This method is called by :py:meth:`parse_from_input`\n        if ``x`` exists. If this Parameter was specified with ``is_list=True``, then ``parse`` is\n        called once for each item in the list.\n\n        :param str x: the value to parse.\n        :return: the parsed value.\n        \"\"\"\n        return x  # default impl",
        "begin_line": 245,
        "end_line": 257,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.00043782837127845885,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.parameter.Parameter.serialize#259",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.serialize(self, x)",
        "snippet": "    def serialize(self, x):  # opposite of parse\n        \"\"\"\n        Opposite of :py:meth:`parse`.\n\n        Converts the value ``x`` to a string.\n\n        :param x: the value to serialize.\n        \"\"\"\n        if self.is_list:\n            return [str(v) for v in x]\n        return str(x)",
        "begin_line": 259,
        "end_line": 269,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0038022813688212928,
            "pseudo_dstar_susp": 0.005291005291005291,
            "pseudo_tarantula_susp": 0.003816793893129771,
            "pseudo_op2_susp": 0.005291005291005291,
            "pseudo_barinel_susp": 0.003816793893129771
        }
    },
    {
        "name": "luigi.parameter.Parameter.parse_from_input#271",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.parse_from_input(self, param_name, x)",
        "snippet": "    def parse_from_input(self, param_name, x):\n        \"\"\"\n        Parses the parameter value from input ``x``, handling defaults and is_list.\n\n        :param param_name: the name of the parameter. This is used for the message in\n                           ``MissingParameterException``.\n        :param x: the input value to parse.\n        :raises MissingParameterException: if x is false-y and no default is specified.\n        \"\"\"\n        if not x:\n            if self.has_value:\n                return self.value\n            elif self.is_bool:\n                return False\n            elif self.is_list:\n                return []\n            else:\n                raise MissingParameterException(\"No value for '%s' (%s) submitted and no default value has been assigned.\" %\n                                                (param_name, \"--\" + param_name.replace('_', '-')))\n        elif self.is_list:\n            return tuple(self.parse(p) for p in x)\n        else:\n            return self.parse(x)",
        "begin_line": 271,
        "end_line": 293,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001314060446780552,
            "pseudo_dstar_susp": 0.001256281407035176,
            "pseudo_tarantula_susp": 0.0024813895781637717,
            "pseudo_op2_susp": 0.001256281407035176,
            "pseudo_barinel_susp": 0.0024813895781637717
        }
    },
    {
        "name": "luigi.parameter.Parameter.parser_dest#301",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.parser_dest(self, param_name, task_name, glob=False, is_without_section=False)",
        "snippet": "    def parser_dest(self, param_name, task_name, glob=False, is_without_section=False):\n        if self.is_global or is_without_section:\n            if glob:\n                return param_name\n            else:\n                return None\n        else:\n            if glob:\n                return task_name + '_' + param_name\n            else:\n                return param_name",
        "begin_line": 301,
        "end_line": 311,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002145922746781116,
            "pseudo_dstar_susp": 0.001869158878504673,
            "pseudo_tarantula_susp": 0.003389830508474576,
            "pseudo_op2_susp": 0.001869158878504673,
            "pseudo_barinel_susp": 0.003401360544217687
        }
    },
    {
        "name": "luigi.parameter.Parameter.add_to_cmdline_parser#313",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.add_to_cmdline_parser(self, parser, param_name, task_name, optparse=False, glob=False, is_without_section=False)",
        "snippet": "    def add_to_cmdline_parser(self, parser, param_name, task_name, optparse=False, glob=False, is_without_section=False):\n        dest = self.parser_dest(param_name, task_name, glob, is_without_section=is_without_section)\n        if not dest:\n            return\n        flag = '--' + dest.replace('_', '-')\n\n        description = []\n        description.append('%s.%s' % (task_name, param_name))\n        if self.description:\n            description.append(self.description)\n        if self.has_value:\n            description.append(\" [default: %s]\" % (self.value,))\n\n        if self.is_list:\n            action = \"append\"\n        elif self.is_bool:\n            action = \"store_true\"\n        else:\n            action = \"store\"\n        if optparse:\n            f = parser.add_option\n        else:\n            f = parser.add_argument\n        f(flag,\n          help=' '.join(description),\n          action=action,\n          dest=dest)",
        "begin_line": 313,
        "end_line": 339,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018050541516245488,
            "pseudo_dstar_susp": 0.00186219739292365,
            "pseudo_tarantula_susp": 0.00398406374501992,
            "pseudo_op2_susp": 0.00186219739292365,
            "pseudo_barinel_susp": 0.00398406374501992
        }
    },
    {
        "name": "luigi.parameter.Parameter.parse_from_args#341",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.parse_from_args(self, param_name, task_name, args, params)",
        "snippet": "    def parse_from_args(self, param_name, task_name, args, params):\n        # Note: modifies arguments\n        dest = self.parser_dest(param_name, task_name, glob=False)\n        if dest is not None:\n            value = getattr(args, dest, None)\n            params[param_name] = self.parse_from_input(param_name, value)",
        "begin_line": 341,
        "end_line": 346,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.parameter.Parameter.set_global_from_args#348",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.set_global_from_args(self, param_name, task_name, args, is_without_section=False)",
        "snippet": "    def set_global_from_args(self, param_name, task_name, args, is_without_section=False):\n        # Note: side effects\n        dest = self.parser_dest(param_name, task_name, glob=True, is_without_section=is_without_section)\n        if dest is not None:\n            value = getattr(args, dest, None)\n            if value:\n                self.set_global(self.parse_from_input(param_name, value))\n            else:  # either False (bools) or None (everything else)\n                self.reset_global()",
        "begin_line": 348,
        "end_line": 356,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013315579227696406,
            "pseudo_dstar_susp": 0.0013351134846461949,
            "pseudo_tarantula_susp": 0.002717391304347826,
            "pseudo_op2_susp": 0.0013351134846461949,
            "pseudo_barinel_susp": 0.0027100271002710027
        }
    },
    {
        "name": "luigi.parameter.DateHourParameter.parse#370",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.DateHourParameter",
        "signature": "luigi.parameter.DateHourParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        \"\"\"\n        Parses a string to a :py:class:`~datetime.datetime` using the format string ``%Y-%m-%dT%H``.\n        \"\"\"\n        # TODO(erikbern): we should probably use an internal class for arbitary\n        # time intervals (similar to date_interval). Or what do you think?\n        return datetime.datetime.strptime(s, self.date_format)",
        "begin_line": 370,
        "end_line": 376,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.parameter.DateHourParameter.serialize#378",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.DateHourParameter",
        "signature": "luigi.parameter.DateHourParameter.serialize(self, dt)",
        "snippet": "    def serialize(self, dt):\n        \"\"\"\n        Converts the datetime to a string usnig the format string ``%Y-%m-%dT%H``.\n        \"\"\"\n        if dt is None:\n            return str(dt)\n        return dt.strftime(self.date_format)",
        "begin_line": 378,
        "end_line": 384,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.parameter.IntParameter.parse#417",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.IntParameter",
        "signature": "luigi.parameter.IntParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        \"\"\"\n        Parses an ``int`` from the string using ``int()``.\n        \"\"\"\n        return int(s)",
        "begin_line": 417,
        "end_line": 421,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005488474204171241,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.parameter.FloatParameter.parse#429",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.FloatParameter",
        "signature": "luigi.parameter.FloatParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        \"\"\"\n        Parses a ``float`` from the string using ``float()``.\n        \"\"\"\n        return float(s)",
        "begin_line": 429,
        "end_line": 433,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.parameter.DateIntervalParameter.parse#476",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.DateIntervalParameter",
        "signature": "luigi.parameter.DateIntervalParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        \"\"\"\n        Parses a `:py:class:`~luigi.date_interval.DateInterval` from the input.\n\n        see :py:mod:`luigi.date_interval`\n          for details on the parsing of DateIntervals.\n        \"\"\"\n        # TODO: can we use xml.utils.iso8601 or something similar?\n\n        from luigi import date_interval as d\n\n        for cls in [d.Year, d.Month, d.Week, d.Date, d.Custom]:\n            i = cls.parse(s)\n            if i:\n                return i\n        else:\n            raise ValueError('Invalid date interval - could not be parsed')",
        "begin_line": 476,
        "end_line": 492,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.parameter.TimeDeltaParameter._apply_regex#507",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TimeDeltaParameter",
        "signature": "luigi.parameter.TimeDeltaParameter._apply_regex(self, regex, input)",
        "snippet": "    def _apply_regex(self, regex, input):\n        from datetime import timedelta\n        import re\n        re_match = re.match(regex, input)\n        if re_match:\n            kwargs = {}\n            has_val = False\n            for k, v in six.iteritems(re_match.groupdict(default=\"0\")):\n                val = int(v)\n                has_val = has_val or val != 0\n                kwargs[k] = val\n            if has_val:\n                return timedelta(**kwargs)",
        "begin_line": 507,
        "end_line": 519,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.parameter.TimeDeltaParameter._parseSimple#531",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TimeDeltaParameter",
        "signature": "luigi.parameter.TimeDeltaParameter._parseSimple(self, input)",
        "snippet": "    def _parseSimple(self, input):\n        keys = [\"weeks\", \"days\", \"hours\", \"minutes\", \"seconds\"]\n        # Give the digits a regex group name from the keys, then look for text with the first letter of the key,\n        # optionally followed by the rest of the word, with final char (the \"s\") optional\n        regex = \"\".join([\"((?P<%s>\\d+) ?%s(%s)?(%s)? ?)?\" % (k, k[0], k[1:-1], k[-1]) for k in keys])\n        return self._apply_regex(regex, input)",
        "begin_line": 531,
        "end_line": 536,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.parameter.TimeDeltaParameter.parse#538",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TimeDeltaParameter",
        "signature": "luigi.parameter.TimeDeltaParameter.parse(self, input)",
        "snippet": "    def parse(self, input):\n        \"\"\"\n        Parses a time delta from the input.\n\n        See :py:class:`TimeDeltaParameter` for details on supported formats.\n        \"\"\"\n        result = self._parseIso8601(input)\n        if not result:\n            result = self._parseSimple(input)\n        if result:\n            return result\n        else:\n            raise ParameterException(\"Invalid time delta - could not parse %s\" % input)",
        "begin_line": 538,
        "end_line": 550,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004828585224529213,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.FileWrapper.__init__#28",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.FileWrapper",
        "signature": "luigi.format.FileWrapper.__init__(self, file_object)",
        "snippet": "    def __init__(self, file_object):\n        self._subpipe = file_object",
        "begin_line": 28,
        "end_line": 29,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.00045599635202918376,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.FileWrapper.__getattr__#31",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.FileWrapper",
        "signature": "luigi.format.FileWrapper.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        # forward calls to 'write', 'close' and other methods not defined below\n        return getattr(self._subpipe, name)",
        "begin_line": 31,
        "end_line": 33,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.00046882325363338024,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.FileWrapper.__enter__#35",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.FileWrapper",
        "signature": "luigi.format.FileWrapper.__enter__(self, *args, **kwargs)",
        "snippet": "    def __enter__(self, *args, **kwargs):\n        # instead of returning whatever is returned by __enter__ on the subpipe\n        # this returns self, so whatever custom injected methods are still available\n        # this might cause problems with custom file_objects, but seems to work\n        # fine with standard python `file` objects which is the only default use\n        return self",
        "begin_line": 35,
        "end_line": 40,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.__init__#51",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.__init__(self, command, input_pipe=None)",
        "snippet": "    def __init__(self, command, input_pipe=None):\n        \"\"\"\n        Initializes a InputPipeProcessWrapper instance.\n\n        :param command: a subprocess.Popen instance with stdin=input_pipe and\n                        stdout=subprocess.PIPE.\n                        Alternatively, just its args argument as a convenience.\n        \"\"\"\n        self._command = command\n        self._input_pipe = input_pipe\n        self._process = command if isinstance(command, subprocess.Popen) else self.create_subprocess(command)\n        # we want to keep a circular reference to avoid garbage collection\n        # when the object is used in, e.g., pipe.read()\n        self._process._selfref = self",
        "begin_line": 51,
        "end_line": 64,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.create_subprocess#66",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.create_subprocess(self, command)",
        "snippet": "    def create_subprocess(self, command):\n        \"\"\"\n        http://www.chiark.greenend.org.uk/ucgi/~cjwatson/blosxom/2009-07-02-python-sigpipe.html\n        \"\"\"\n\n        def subprocess_setup():\n            # Python installs a SIGPIPE handler by default. This is usually not what\n            # non-Python subprocesses expect.\n            signal.signal(signal.SIGPIPE, signal.SIG_DFL)\n\n        return subprocess.Popen(command,\n                                stdin=self._input_pipe,\n                                stdout=subprocess.PIPE,\n                                preexec_fn=subprocess_setup,\n                                close_fds=True)",
        "begin_line": 66,
        "end_line": 80,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004816955684007707,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.subprocess_setup#71",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.subprocess_setup()",
        "snippet": "        def subprocess_setup():\n            # Python installs a SIGPIPE handler by default. This is usually not what\n            # non-Python subprocesses expect.\n            signal.signal(signal.SIGPIPE, signal.SIG_DFL)",
        "begin_line": 71,
        "end_line": 74,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.000471253534401508,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper._finish#82",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper._finish(self)",
        "snippet": "    def _finish(self):\n        # Need to close this before input_pipe to get all SIGPIPE messages correctly\n        self._process.stdout.close()\n\n        if self._input_pipe is not None:\n            self._input_pipe.close()\n\n        self._process.wait()  # deadlock?\n        if self._process.returncode not in (0, 141, 128 - 141):\n            # 141 == 128 + 13 == 128 + SIGPIPE - normally processes exit with 128 + {reiceived SIG}\n            # 128 - 141 == -13 == -SIGPIPE, sometimes python receives -13 for some subprocesses\n            raise RuntimeError('Error reading from pipe. Subcommand exited with non-zero exit status %s.' % self._process.returncode)",
        "begin_line": 82,
        "end_line": 93,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005291005291005291,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.close#95",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.close(self)",
        "snippet": "    def close(self):\n        self._finish()",
        "begin_line": 95,
        "end_line": 96,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004894762604013706,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.__del__#98",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.__del__(self)",
        "snippet": "    def __del__(self):\n        self._finish()",
        "begin_line": 98,
        "end_line": 99,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005488474204171241,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.__getattr__#121",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        if name == '_process':\n            raise AttributeError(name)\n        return getattr(self._process.stdout, name)",
        "begin_line": 121,
        "end_line": 124,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.__iter__#126",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.__iter__(self)",
        "snippet": "    def __iter__(self):\n        for line in self._process.stdout:\n            yield line\n        self._finish()",
        "begin_line": 126,
        "end_line": 129,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.seekable#137",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.seekable(self)",
        "snippet": "    def seekable(self):\n        return False",
        "begin_line": 137,
        "end_line": 138,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005652911249293386,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.__init__#144",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.__init__(self, command, output_pipe=None)",
        "snippet": "    def __init__(self, command, output_pipe=None):\n        self.closed = False\n        self._command = command\n        self._output_pipe = output_pipe\n        self._process = subprocess.Popen(command,\n                                         stdin=subprocess.PIPE,\n                                         stdout=output_pipe,\n                                         close_fds=True)\n        self._flushcount = 0",
        "begin_line": 144,
        "end_line": 152,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005070993914807302,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.write#154",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.write(self, *args, **kwargs)",
        "snippet": "    def write(self, *args, **kwargs):\n        self._process.stdin.write(*args, **kwargs)\n        self._flushcount += 1\n        if self._flushcount == self.WRITES_BEFORE_FLUSH:\n            self._process.stdin.flush()\n            self._flushcount = 0",
        "begin_line": 154,
        "end_line": 159,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005070993914807302,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper._finish#165",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper._finish(self)",
        "snippet": "    def _finish(self):\n        \"\"\"\n        Closes and waits for subprocess to exit.\n        \"\"\"\n        if self._process.returncode is None:\n            self._process.stdin.flush()\n            self._process.stdin.close()\n            self._process.wait()\n            self.closed = True",
        "begin_line": 165,
        "end_line": 173,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005070993914807302,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.__del__#175",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.__del__(self)",
        "snippet": "    def __del__(self):\n        if not self.closed:\n            self.abort()",
        "begin_line": 175,
        "end_line": 177,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005070993914807302,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.close#188",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.close(self)",
        "snippet": "    def close(self):\n        self._finish()\n        if self._process.returncode == 0:\n            if self._output_pipe is not None:\n                self._output_pipe.close()\n        else:\n            raise RuntimeError('Error when executing command %s' % self._command)",
        "begin_line": 188,
        "end_line": 194,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005213764337851929,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.__getattr__#199",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        if name == '_process':\n            raise AttributeError(name)\n        return getattr(self._process.stdin, name)",
        "begin_line": 199,
        "end_line": 202,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.readable#204",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.readable(self)",
        "snippet": "    def readable(self):\n        return False",
        "begin_line": 204,
        "end_line": 205,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.writable#207",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.writable(self)",
        "snippet": "    def writable(self):\n        return True",
        "begin_line": 207,
        "end_line": 208,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.seekable#210",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.seekable(self)",
        "snippet": "    def seekable(self):\n        return False",
        "begin_line": 210,
        "end_line": 211,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.Format.__rshift__#237",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.Format",
        "signature": "luigi.format.Format.__rshift__(a, b)",
        "snippet": "    def __rshift__(a, b):\n        return Chain(a, b)",
        "begin_line": 237,
        "end_line": 238,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005291005291005291,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.Chain.__init__#243",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.Chain",
        "signature": "luigi.format.Chain.__init__(self, *args)",
        "snippet": "    def __init__(self, *args):\n        self.args = args",
        "begin_line": 243,
        "end_line": 244,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005291005291005291,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.Chain.pipe_reader#246",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.Chain",
        "signature": "luigi.format.Chain.pipe_reader(self, input_pipe)",
        "snippet": "    def pipe_reader(self, input_pipe):\n        for x in reversed(self.args):\n            input_pipe = x.pipe_reader(input_pipe)\n        return input_pipe",
        "begin_line": 246,
        "end_line": 249,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005652911249293386,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.Chain.pipe_writer#251",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.Chain",
        "signature": "luigi.format.Chain.pipe_writer(self, output_pipe)",
        "snippet": "    def pipe_writer(self, output_pipe):\n        for x in reversed(self.args):\n            output_pipe = x.pipe_writer(output_pipe)\n        return output_pipe",
        "begin_line": 251,
        "end_line": 254,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.TextWrapper.__init__#259",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.TextWrapper",
        "signature": "luigi.format.TextWrapper.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        self.args = args\n        self.kwargs = kwargs",
        "begin_line": 259,
        "end_line": 261,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.TextWrapper.pipe_reader#263",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.TextWrapper",
        "signature": "luigi.format.TextWrapper.pipe_reader(self, input_pipe)",
        "snippet": "    def pipe_reader(self, input_pipe):\n        return io.TextIOWrapper(input_pipe, *self.args, **self.kwargs)",
        "begin_line": 263,
        "end_line": 264,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.TextWrapper.pipe_writer#266",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.TextWrapper",
        "signature": "luigi.format.TextWrapper.pipe_writer(self, output_pipe)",
        "snippet": "    def pipe_writer(self, output_pipe):\n        return io.TextIOWrapper(output_pipe, *self.args, **self.kwargs)",
        "begin_line": 266,
        "end_line": 267,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.GzipWrapper.pipe_reader#275",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.GzipWrapper",
        "signature": "luigi.format.GzipWrapper.pipe_reader(self, input_pipe)",
        "snippet": "    def pipe_reader(self, input_pipe):\n        return InputPipeProcessWrapper(['gunzip'], input_pipe)",
        "begin_line": 275,
        "end_line": 276,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.GzipWrapper.pipe_writer#278",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.GzipWrapper",
        "signature": "luigi.format.GzipWrapper.pipe_writer(self, output_pipe)",
        "snippet": "    def pipe_writer(self, output_pipe):\n        args = ['gzip']\n        if self.compression_level is not None:\n            args.append('-' + str(int(self.compression_level)))\n        return OutputPipeProcessWrapper(args, output_pipe)",
        "begin_line": 278,
        "end_line": 282,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.Bzip2Wrapper.pipe_reader#287",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.Bzip2Wrapper",
        "signature": "luigi.format.Bzip2Wrapper.pipe_reader(self, input_pipe)",
        "snippet": "    def pipe_reader(self, input_pipe):\n        return InputPipeProcessWrapper(['bzcat'], input_pipe)",
        "begin_line": 287,
        "end_line": 288,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.format.Bzip2Wrapper.pipe_writer#290",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.Bzip2Wrapper",
        "signature": "luigi.format.Bzip2Wrapper.pipe_writer(self, output_pipe)",
        "snippet": "    def pipe_writer(self, output_pipe):\n        return OutputPipeProcessWrapper(['bzip2'], output_pipe)",
        "begin_line": 290,
        "end_line": 291,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.pig_home#43",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.pig_home(self)",
        "snippet": "    def pig_home(self):\n        return configuration.get_config().get('pig', 'home', '/usr/share/pig')",
        "begin_line": 43,
        "end_line": 44,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005652911249293386,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.pig_command_path#46",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.pig_command_path(self)",
        "snippet": "    def pig_command_path(self):\n        return os.path.join(self.pig_home(), \"bin/pig\")",
        "begin_line": 46,
        "end_line": 47,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005652911249293386,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.pig_env_vars#49",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.pig_env_vars(self)",
        "snippet": "    def pig_env_vars(self):\n        \"\"\"\n        Dictionary of environment variables that should be set when running Pig.\n\n        Ex:\n            return { 'PIG_CLASSPATH': '/your/path' }\n        \"\"\"\n        return {}",
        "begin_line": 49,
        "end_line": 56,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.pig_properties#58",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.pig_properties(self)",
        "snippet": "    def pig_properties(self):\n        \"\"\"\n        Dictionary of properties that should be set when running Pig.\n\n        Ex:\n            return { 'pig.additional.jars':'/path/to/your/jar' }\n        \"\"\"\n        return {}",
        "begin_line": 58,
        "end_line": 65,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005488474204171241,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.pig_parameters#67",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.pig_parameters(self)",
        "snippet": "    def pig_parameters(self):\n        \"\"\"\n        Dictionary of parameters that should be set for the Pig job.\n        Ex:\n            return { 'YOUR_PARAM_NAME':'Your param value' }\n        \"\"\"\n        return {}",
        "begin_line": 67,
        "end_line": 73,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask._build_pig_cmd#92",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask._build_pig_cmd(self)",
        "snippet": "    def _build_pig_cmd(self):\n        opts = self.pig_options()\n\n        for k, v in six.iteritems(self.pig_parameters()):\n            opts.append(\"-p\")\n            opts.append(\"%s=%s\" % (k, v))\n\n        if self.pig_properties():\n            with open('pig_property_file', 'w') as prop_file:\n                prop_file.writelines([\"%s=%s%s\" % (k, v, os.linesep) for (k, v) in six.iteritems(self.pig_properties())])\n            opts.append('-propertyFile')\n            opts.append('pig_property_file')\n\n        cmd = [self.pig_command_path()] + opts + [\"-f\", self.pig_script_path()]\n\n        logger.info(' '.join(cmd))\n        return cmd",
        "begin_line": 92,
        "end_line": 108,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.run#110",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.run(self)",
        "snippet": "    def run(self):\n        cmd = self._build_pig_cmd()\n        self.track_and_progress(cmd)",
        "begin_line": 110,
        "end_line": 112,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.track_and_progress#114",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.track_and_progress(self, cmd)",
        "snippet": "    def track_and_progress(self, cmd):\n        temp_stdout = tempfile.TemporaryFile()\n        env = os.environ.copy()\n        env['PIG_HOME'] = self.pig_home()\n        for k, v in six.iteritems(self.pig_env_vars()):\n            env[k] = v\n\n        proc = subprocess.Popen(cmd, shell=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env)\n        reads = [proc.stderr.fileno(), proc.stdout.fileno()]\n        # tracking the possible problems with this job\n        err_lines = []\n        with PigRunContext():\n            while proc.poll() is None:\n                ret = select.select(reads, [], [])\n                for fd in ret[0]:\n                    if fd == proc.stderr.fileno():\n                        line = proc.stderr.readline().decode('utf8')\n                        err_lines.append(line)\n                    if fd == proc.stdout.fileno():\n                        line = proc.stdout.readline().decode('utf8')\n                        temp_stdout.write(line)\n\n                err_line = line.lower()\n                if err_line.find('More information at:') != -1:\n                    logger.info(err_line.split('more information at: ')[-1].strip())\n                if err_line.find(' - '):\n                    t = err_line.split(' - ')[-1].strip()\n                    if t != \"\":\n                        logger.info(t)\n\n        # Read the rest + stdout\n        err = ''.join(err_lines + [err_line.decode('utf8') for err_line in proc.stderr])\n        if proc.returncode == 0:\n            logger.info(\"Job completed successfully!\")\n        else:\n            logger.error(\"Error when running script:\\n%s\", self.pig_script_path())\n            logger.error(err)\n            raise PigJobError(\"Pig script failed with return value: %s\" % (proc.returncode,), err=err)",
        "begin_line": 114,
        "end_line": 151,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.pig.PigRunContext.__init__#155",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigRunContext",
        "signature": "luigi.contrib.pig.PigRunContext.__init__(self)",
        "snippet": "    def __init__(self):\n        self.job_id = None",
        "begin_line": 155,
        "end_line": 156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.pig.PigRunContext.__enter__#158",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigRunContext",
        "signature": "luigi.contrib.pig.PigRunContext.__enter__(self)",
        "snippet": "    def __enter__(self):\n        self.__old_signal = signal.getsignal(signal.SIGTERM)\n        signal.signal(signal.SIGTERM, self.kill_job)\n        return self",
        "begin_line": 158,
        "end_line": 161,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.pig.PigRunContext.__exit__#171",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigRunContext",
        "signature": "luigi.contrib.pig.PigRunContext.__exit__(self, exc_type, exc_val, exc_tb)",
        "snippet": "    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is KeyboardInterrupt:\n            self.kill_job()\n        signal.signal(signal.SIGTERM, self.__old_signal)",
        "begin_line": 171,
        "end_line": 174,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobError.__init__#178",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobError",
        "signature": "luigi.contrib.pig.PigJobError.__init__(self, message, out=None, err=None)",
        "snippet": "    def __init__(self, message, out=None, err=None):\n        super(PigJobError, self).__init__(message, out, err)\n        self.message = message\n        self.out = out\n        self.err = err",
        "begin_line": 178,
        "end_line": 182,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.add#105",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop",
        "signature": "luigi.hadoop.add(src, dst)",
        "snippet": "    def add(src, dst):\n        logger.debug('adding to tar: %s -> %s', src, dst)\n        tar.add(src, dst)",
        "begin_line": 105,
        "end_line": 107,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004894762604013706,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.add_files_for_package#109",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop",
        "signature": "luigi.hadoop.add_files_for_package(sub_package_path, root_package_path, root_package_name)",
        "snippet": "    def add_files_for_package(sub_package_path, root_package_path, root_package_name):\n        for root, dirs, files in os.walk(sub_package_path):\n            if '.svn' in dirs:\n                dirs.remove('.svn')\n            for f in files:\n                if not f.endswith(\".pyc\") and not f.startswith(\".\"):\n                    add(dereference(root + \"/\" + f), root.replace(root_package_path, root_package_name) + \"/\" + f)",
        "begin_line": 109,
        "end_line": 115,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004597701149425287,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.flatten#171",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop",
        "signature": "luigi.hadoop.flatten(sequence)",
        "snippet": "def flatten(sequence):\n    \"\"\"\n    A simple generator which flattens a sequence.\n\n    Only one level is flattened.\n\n    .. code-block:: python\n\n        (1, (2, 3), 4) -> (1, 2, 3, 4)\n\n    \"\"\"\n    for item in sequence:\n        if hasattr(item, \"__iter__\") and not isinstance(item, str) and not isinstance(item, bytes):\n            for i in item:\n                yield i\n        else:\n            yield item",
        "begin_line": 171,
        "end_line": 187,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.LocalJobRunner.__init__#530",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.LocalJobRunner",
        "signature": "luigi.hadoop.LocalJobRunner.__init__(self, samplelines=None)",
        "snippet": "    def __init__(self, samplelines=None):\n        self.samplelines = samplelines",
        "begin_line": 530,
        "end_line": 531,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.LocalJobRunner.sample#533",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.LocalJobRunner",
        "signature": "luigi.hadoop.LocalJobRunner.sample(self, input_stream, n, output)",
        "snippet": "    def sample(self, input_stream, n, output):\n        for i, line in enumerate(input_stream):\n            if n is not None and i >= n:\n                break\n            output.write(line)",
        "begin_line": 533,
        "end_line": 537,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.LocalJobRunner.group#539",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.LocalJobRunner",
        "signature": "luigi.hadoop.LocalJobRunner.group(self, input_stream)",
        "snippet": "    def group(self, input_stream):\n        output = StringIO()\n        lines = []\n        for i, line in enumerate(input_stream):\n            parts = line.rstrip('\\n').split('\\t')\n            blob = md5(str(i).encode('ascii')).hexdigest()  # pseudo-random blob to make sure the input isn't sorted\n            lines.append((parts[:-1], blob, line))\n        for _, _, line in sorted(lines):\n            output.write(line)\n        output.seek(0)\n        return output",
        "begin_line": 539,
        "end_line": 549,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.LocalJobRunner.run_job#551",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.LocalJobRunner",
        "signature": "luigi.hadoop.LocalJobRunner.run_job(self, job)",
        "snippet": "    def run_job(self, job):\n        map_input = StringIO()\n\n        for i in luigi.task.flatten(job.input_hadoop()):\n            self.sample(i.open('r'), self.samplelines, map_input)\n\n        map_input.seek(0)\n\n        if job.reducer == NotImplemented:\n            # Map only job; no combiner, no reducer\n            map_output = job.output().open('w')\n            job.run_mapper(map_input, map_output)\n            map_output.close()\n            return\n\n        job.init_mapper()\n        # run job now...\n        map_output = StringIO()\n        job.run_mapper(map_input, map_output)\n        map_output.seek(0)\n\n        if job.combiner == NotImplemented:\n            reduce_input = self.group(map_output)\n        else:\n            combine_input = self.group(map_output)\n            combine_output = StringIO()\n            job.run_combiner(combine_input, combine_output)\n            combine_output.seek(0)\n            reduce_input = self.group(combine_output)\n\n        job.init_reducer()\n        reduce_output = job.output().open('w')\n        job.run_reducer(reduce_input, reduce_output)\n        reduce_output.close()",
        "begin_line": 551,
        "end_line": 584,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.BaseHadoopJobTask.init_local#620",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.BaseHadoopJobTask",
        "signature": "luigi.hadoop.BaseHadoopJobTask.init_local(self)",
        "snippet": "    def init_local(self):\n        \"\"\"\n        Implement any work to setup any internal datastructure etc here.\n\n        You can add extra input using the requires_local/input_local methods.\n\n        Anything you set on the object will be pickled and available on the Hadoop nodes.\n        \"\"\"\n        pass",
        "begin_line": 620,
        "end_line": 628,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.BaseHadoopJobTask.run#633",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.BaseHadoopJobTask",
        "signature": "luigi.hadoop.BaseHadoopJobTask.run(self)",
        "snippet": "    def run(self):\n        self.init_local()\n        self.job_runner().run_job(self)",
        "begin_line": 633,
        "end_line": 635,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005488474204171241,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.BaseHadoopJobTask.requires_local#637",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.BaseHadoopJobTask",
        "signature": "luigi.hadoop.BaseHadoopJobTask.requires_local(self)",
        "snippet": "    def requires_local(self):\n        \"\"\"\n        Default impl - override this method if you need any local input to be accessible in init().\n        \"\"\"\n        return []",
        "begin_line": 637,
        "end_line": 641,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.BaseHadoopJobTask.input_local#646",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.BaseHadoopJobTask",
        "signature": "luigi.hadoop.BaseHadoopJobTask.input_local(self)",
        "snippet": "    def input_local(self):\n        return luigi.task.getpaths(self.requires_local())",
        "begin_line": 646,
        "end_line": 647,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.BaseHadoopJobTask.input_hadoop#649",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.BaseHadoopJobTask",
        "signature": "luigi.hadoop.BaseHadoopJobTask.input_hadoop(self)",
        "snippet": "    def input_hadoop(self):\n        return luigi.task.getpaths(self.requires_hadoop())",
        "begin_line": 649,
        "end_line": 650,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.BaseHadoopJobTask.on_failure#656",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.BaseHadoopJobTask",
        "signature": "luigi.hadoop.BaseHadoopJobTask.on_failure(self, exception)",
        "snippet": "    def on_failure(self, exception):\n        if isinstance(exception, HadoopJobError):\n            return \"\"\"Hadoop job failed with message: {message}\n\n    stdout:\n    {stdout}\n\n\n    stderr:\n    {stderr}\n      \"\"\".format(message=exception.message, stdout=exception.out, stderr=exception.err)\n        else:\n            return super(BaseHadoopJobTask, self).on_failure(exception)",
        "begin_line": 656,
        "end_line": 668,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.JobTask.init_mapper#683",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.JobTask",
        "signature": "luigi.hadoop.JobTask.init_mapper(self)",
        "snippet": "    def init_mapper(self):\n        pass",
        "begin_line": 683,
        "end_line": 684,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.JobTask.init_combiner#686",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.JobTask",
        "signature": "luigi.hadoop.JobTask.init_combiner(self)",
        "snippet": "    def init_combiner(self):\n        pass",
        "begin_line": 686,
        "end_line": 687,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.JobTask.reader#713",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.JobTask",
        "signature": "luigi.hadoop.JobTask.reader(self, input_stream)",
        "snippet": "    def reader(self, input_stream):\n        \"\"\"\n        Reader is a method which iterates over input lines and outputs records.\n\n        The default implementation yields one argument containing the line for each line in the input.\"\"\"\n        for line in input_stream:\n            yield line,",
        "begin_line": 713,
        "end_line": 719,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.JobTask.writer#721",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.JobTask",
        "signature": "luigi.hadoop.JobTask.writer(self, outputs, stdout, stderr=sys.stderr)",
        "snippet": "    def writer(self, outputs, stdout, stderr=sys.stderr):\n        \"\"\"\n        Writer format is a method which iterates over the output records\n        from the reducer and formats them for output.\n\n        The default implementation outputs tab separated items.\n        \"\"\"\n        for output in outputs:\n            try:\n                print(\"\\t\".join(map(str, flatten(output))), file=stdout)\n            except:\n                print(output, file=stderr)\n                raise",
        "begin_line": 721,
        "end_line": 733,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.JobTask.incr_counter#745",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.JobTask",
        "signature": "luigi.hadoop.JobTask.incr_counter(self, *args, **kwargs)",
        "snippet": "    def incr_counter(self, *args, **kwargs):\n        \"\"\"\n        Increments a Hadoop counter.\n\n        Since counters can be a bit slow to update, this batches the updates.\n        \"\"\"\n        threshold = kwargs.get(\"threshold\", self.batch_counter_default)\n        if len(args) == 2:\n            # backwards compatibility with existing hadoop jobs\n            group_name, count = args\n            key = (group_name,)\n        else:\n            group, name, count = args\n            key = (group, name)\n\n        ct = self._counter_dict.get(key, 0)\n        ct += count\n        if ct >= threshold:\n            new_arg = list(key) + [ct]\n            self._incr_counter(*new_arg)\n            ct = 0\n        self._counter_dict[key] = ct",
        "begin_line": 745,
        "end_line": 766,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.JobTask._flush_batch_incr_counter#768",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.JobTask",
        "signature": "luigi.hadoop.JobTask._flush_batch_incr_counter(self)",
        "snippet": "    def _flush_batch_incr_counter(self):\n        \"\"\"\n        Increments any unflushed counter values.\n        \"\"\"\n        for key, count in six.iteritems(self._counter_dict):\n            if count == 0:\n                continue\n            args = list(key) + [count]\n            self._incr_counter(*args)",
        "begin_line": 768,
        "end_line": 776,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.JobTask._incr_counter#778",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.JobTask",
        "signature": "luigi.hadoop.JobTask._incr_counter(self, *args)",
        "snippet": "    def _incr_counter(self, *args):\n        \"\"\"\n        Increments a Hadoop counter.\n\n        Note that this seems to be a bit slow, ~1 ms\n\n        Don't overuse this function by updating very frequently.\n        \"\"\"\n        if len(args) == 2:\n            # backwards compatibility with existing hadoop jobs\n            group_name, count = args\n            print('reporter:counter:%s,%s' % (group_name, count), file=sys.stderr)\n        else:\n            group, name, count = args\n            print('reporter:counter:%s,%s,%s' % (group, name, count), file=sys.stderr)",
        "begin_line": 778,
        "end_line": 792,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.JobTask._map_input#848",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.JobTask",
        "signature": "luigi.hadoop.JobTask._map_input(self, input_stream)",
        "snippet": "    def _map_input(self, input_stream):\n        \"\"\"\n        Iterate over input and call the mapper for each item.\n        If the job has a parser defined, the return values from the parser will\n        be passed as arguments to the mapper.\n\n        If the input is coded output from a previous run,\n        the arguments will be splitted in key and value.\n        \"\"\"\n        for record in self.reader(input_stream):\n            for output in self.mapper(*record):\n                yield output\n        if self.final_mapper != NotImplemented:\n            for output in self.final_mapper():\n                yield output\n        self._flush_batch_incr_counter()",
        "begin_line": 848,
        "end_line": 863,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.JobTask._reduce_input#865",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.JobTask",
        "signature": "luigi.hadoop.JobTask._reduce_input(self, inputs, reducer, final=NotImplemented)",
        "snippet": "    def _reduce_input(self, inputs, reducer, final=NotImplemented):\n        \"\"\"\n        Iterate over input, collect values with the same key, and call the reducer for each unique key.\n        \"\"\"\n        for key, values in groupby(inputs, key=lambda x: repr(x[0])):\n            for output in reducer(eval(key), (v[1] for v in values)):\n                yield output\n        if final != NotImplemented:\n            for output in final():\n                yield output\n        self._flush_batch_incr_counter()",
        "begin_line": 865,
        "end_line": 875,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.JobTask.run_mapper#877",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.JobTask",
        "signature": "luigi.hadoop.JobTask.run_mapper(self, stdin=sys.stdin, stdout=sys.stdout)",
        "snippet": "    def run_mapper(self, stdin=sys.stdin, stdout=sys.stdout):\n        \"\"\"\n        Run the mapper on the hadoop node.\n        \"\"\"\n        self.init_hadoop()\n        self.init_mapper()\n        outputs = self._map_input((line[:-1] for line in stdin))\n        if self.reducer == NotImplemented:\n            self.writer(outputs, stdout)\n        else:\n            self.internal_writer(outputs, stdout)",
        "begin_line": 877,
        "end_line": 887,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.JobTask.run_reducer#889",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.JobTask",
        "signature": "luigi.hadoop.JobTask.run_reducer(self, stdin=sys.stdin, stdout=sys.stdout)",
        "snippet": "    def run_reducer(self, stdin=sys.stdin, stdout=sys.stdout):\n        \"\"\"\n        Run the reducer on the hadoop node.\n        \"\"\"\n        self.init_hadoop()\n        self.init_reducer()\n        outputs = self._reduce_input(self.internal_reader((line[:-1] for line in stdin)), self.reducer, self.final_reducer)\n        self.writer(outputs, stdout)",
        "begin_line": 889,
        "end_line": 896,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.JobTask.run_combiner#898",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.JobTask",
        "signature": "luigi.hadoop.JobTask.run_combiner(self, stdin=sys.stdin, stdout=sys.stdout)",
        "snippet": "    def run_combiner(self, stdin=sys.stdin, stdout=sys.stdout):\n        self.init_hadoop()\n        self.init_combiner()\n        outputs = self._reduce_input(self.internal_reader((line[:-1] for line in stdin)), self.combiner, self.final_combiner)\n        self.internal_writer(outputs, stdout)",
        "begin_line": 898,
        "end_line": 902,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.JobTask.internal_reader#904",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.JobTask",
        "signature": "luigi.hadoop.JobTask.internal_reader(self, input_stream)",
        "snippet": "    def internal_reader(self, input_stream):\n        \"\"\"\n        Reader which uses python eval on each part of a tab separated string.\n        Yields a tuple of python objects.\n        \"\"\"\n        for input_line in input_stream:\n            yield list(map(eval, input_line.split(\"\\t\")))",
        "begin_line": 904,
        "end_line": 910,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hadoop.JobTask.internal_writer#912",
        "src_path": "luigi/hadoop.py",
        "class_name": "luigi.hadoop.JobTask",
        "signature": "luigi.hadoop.JobTask.internal_writer(self, outputs, stdout)",
        "snippet": "    def internal_writer(self, outputs, stdout):\n        \"\"\"\n        Writer which outputs the python repr for each item.\n        \"\"\"\n        for output in outputs:\n            print(\"\\t\".join(map(repr, output)), file=stdout)",
        "begin_line": 912,
        "end_line": 917,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.hive.HiveCommandError.__init__#40",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveCommandError",
        "signature": "luigi.contrib.hive.HiveCommandError.__init__(self, message, out=None, err=None)",
        "snippet": "    def __init__(self, message, out=None, err=None):\n        super(HiveCommandError, self).__init__(message, out, err)\n        self.message = message\n        self.out = out\n        self.err = err",
        "begin_line": 40,
        "end_line": 44,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.hive.get_hive_syntax#51",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive",
        "signature": "luigi.contrib.hive.get_hive_syntax()",
        "snippet": "def get_hive_syntax():\n    return luigi.configuration.get_config().get('hive', 'release', 'cdh4')",
        "begin_line": 51,
        "end_line": 52,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.hive.run_hive#55",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive",
        "signature": "luigi.contrib.hive.run_hive(args, check_return_code=True)",
        "snippet": "def run_hive(args, check_return_code=True):\n    \"\"\"\n    Runs the `hive` from the command line, passing in the given args, and\n    returning stdout.\n\n    With the apache release of Hive, so of the table existence checks\n    (which are done using DESCRIBE do not exit with a return code of 0\n    so we need an option to ignore the return code and just return stdout for parsing\n    \"\"\"\n    cmd = [load_hive_cmd()] + args\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    stdout, stderr = p.communicate()\n    if check_return_code and p.returncode != 0:\n        raise HiveCommandError(\"Hive command: {0} failed with error code: {1}\".format(\" \".join(cmd), p.returncode),\n                               stdout, stderr)\n    return stdout",
        "begin_line": 55,
        "end_line": 70,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.hive.run_hive_cmd#73",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive",
        "signature": "luigi.contrib.hive.run_hive_cmd(hivecmd, check_return_code=True)",
        "snippet": "def run_hive_cmd(hivecmd, check_return_code=True):\n    \"\"\"\n    Runs the given hive query and returns stdout.\n    \"\"\"\n    return run_hive(['-e', hivecmd], check_return_code)",
        "begin_line": 73,
        "end_line": 77,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.hive.run_hive_script#80",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive",
        "signature": "luigi.contrib.hive.run_hive_script(script)",
        "snippet": "def run_hive_script(script):\n    \"\"\"\n    Runs the contents of the given script in hive and returns stdout.\n    \"\"\"\n    if not os.path.isfile(script):\n        raise RuntimeError(\"Hive script: {0} does not exist.\".format(script))\n    return run_hive(['-f', script])",
        "begin_line": 80,
        "end_line": 86,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.hive.HiveCommandClient.table_location#126",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveCommandClient",
        "signature": "luigi.contrib.hive.HiveCommandClient.table_location(self, table, database='default', partition=None)",
        "snippet": "    def table_location(self, table, database='default', partition=None):\n        cmd = \"use {0}; describe formatted {1}\".format(database, table)\n        if partition is not None:\n            cmd += \" PARTITION ({0})\".format(self.partition_spec(partition))\n\n        stdout = run_hive_cmd(cmd)\n\n        for line in stdout.split(\"\\n\"):\n            if \"Location:\" in line:\n                return line.split(\"\\t\")[1]",
        "begin_line": 126,
        "end_line": 135,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.hive.HiveCommandClient.table_exists#137",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveCommandClient",
        "signature": "luigi.contrib.hive.HiveCommandClient.table_exists(self, table, database='default', partition=None)",
        "snippet": "    def table_exists(self, table, database='default', partition=None):\n        if partition is None:\n            stdout = run_hive_cmd('use {0}; show tables like \"{1}\";'.format(database, table))\n\n            return stdout and table in stdout\n        else:\n            stdout = run_hive_cmd(\"\"\"use %s; show partitions %s partition\n                                (%s)\"\"\" % (database, table, self.partition_spec(partition)))\n\n            if stdout:\n                return True\n            else:\n                return False",
        "begin_line": 137,
        "end_line": 149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.hive.HiveCommandClient.table_schema#151",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveCommandClient",
        "signature": "luigi.contrib.hive.HiveCommandClient.table_schema(self, table, database='default')",
        "snippet": "    def table_schema(self, table, database='default'):\n        describe = run_hive_cmd(\"use {0}; describe {1}\".format(database, table))\n        if not describe or \"does not exist\" in describe:\n            return None\n        return [tuple([x.strip() for x in line.strip().split(\"\\t\")]) for line in describe.strip().split(\"\\n\")]",
        "begin_line": 151,
        "end_line": 155,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.hive.HiveCommandClient.partition_spec#157",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveCommandClient",
        "signature": "luigi.contrib.hive.HiveCommandClient.partition_spec(self, partition)",
        "snippet": "    def partition_spec(self, partition):\n        \"\"\"\n        Turns a dict into the a Hive partition specification string.\n        \"\"\"\n        return ','.join([\"{0}='{1}'\".format(k, v) for (k, v) in\n                         sorted(six.iteritems(partition), key=operator.itemgetter(0))])",
        "begin_line": 157,
        "end_line": 162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.hive.ApacheHiveCommandClient.table_schema#171",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.ApacheHiveCommandClient",
        "signature": "luigi.contrib.hive.ApacheHiveCommandClient.table_schema(self, table, database='default')",
        "snippet": "    def table_schema(self, table, database='default'):\n        describe = run_hive_cmd(\"use {0}; describe {1}\".format(database, table), False)\n        if not describe or \"Table not found\" in describe:\n            return None\n        return [tuple([x.strip() for x in line.strip().split(\"\\t\")]) for line in describe.strip().split(\"\\n\")]",
        "begin_line": 171,
        "end_line": 175,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.hive.MetastoreClient.table_exists#189",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.MetastoreClient",
        "signature": "luigi.contrib.hive.MetastoreClient.table_exists(self, table, database='default', partition=None)",
        "snippet": "    def table_exists(self, table, database='default', partition=None):\n        with HiveThriftContext() as client:\n            if partition is None:\n                return table in client.get_all_tables(database)\n            else:\n                return partition in self._existing_partitions(table, database, client)",
        "begin_line": 189,
        "end_line": 194,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.hive.MetastoreClient._existing_partitions#196",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.MetastoreClient",
        "signature": "luigi.contrib.hive.MetastoreClient._existing_partitions(self, table, database, client)",
        "snippet": "    def _existing_partitions(self, table, database, client):\n        def _parse_partition_string(partition_string):\n            partition_def = {}\n            for part in partition_string.split(\"/\"):\n                name, value = part.split(\"=\")\n                partition_def[name] = value\n            return partition_def\n\n        # -1 is max_parts, the # of partition names to return (-1 = unlimited)\n        partition_strings = client.get_partition_names(database, table, -1)\n        return [_parse_partition_string(existing_partition) for existing_partition in partition_strings]",
        "begin_line": 196,
        "end_line": 206,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.hive.MetastoreClient._parse_partition_string#197",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.MetastoreClient",
        "signature": "luigi.contrib.hive.MetastoreClient._parse_partition_string(partition_string)",
        "snippet": "        def _parse_partition_string(partition_string):\n            partition_def = {}\n            for part in partition_string.split(\"/\"):\n                name, value = part.split(\"=\")\n                partition_def[name] = value\n            return partition_def",
        "begin_line": 197,
        "end_line": 202,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.hive.get_default_client#247",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive",
        "signature": "luigi.contrib.hive.get_default_client()",
        "snippet": "def get_default_client():\n    if get_hive_syntax() == \"apache\":\n        return ApacheHiveCommandClient()\n    else:\n        return HiveCommandClient()",
        "begin_line": 247,
        "end_line": 251,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.hive.HiveQueryTask.hiverc#272",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveQueryTask",
        "signature": "luigi.contrib.hive.HiveQueryTask.hiverc(self)",
        "snippet": "    def hiverc(self):\n        \"\"\"\n        Location of an rc file to run before the query\n        if hiverc-location key is specified in client.cfg, will default to the value there\n        otherwise returns None.\n\n        Returning a list of rc files will load all of them in order.\n        \"\"\"\n        return luigi.configuration.get_config().get('hive', 'hiverc-location', default=None)",
        "begin_line": 272,
        "end_line": 280,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.hive.HiveQueryTask.hiveconfs#282",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveQueryTask",
        "signature": "luigi.contrib.hive.HiveQueryTask.hiveconfs(self)",
        "snippet": "    def hiveconfs(self):\n        \"\"\"\n        Returns an dict of key=value settings to be passed along\n        to the hive command line via --hiveconf. By default, sets\n        mapred.job.name to task_id and if not None, sets:\n\n        * mapred.reduce.tasks (n_reduce_tasks)\n        * mapred.fairscheduler.pool (pool) or mapred.job.queue.name (pool)\n        * hive.exec.reducers.bytes.per.reducer (bytes_per_reducer)\n        * hive.exec.reducers.max (reducers_max)\n        \"\"\"\n        jcs = {}\n        jcs['mapred.job.name'] = self.task_id\n        if self.n_reduce_tasks is not None:\n            jcs['mapred.reduce.tasks'] = self.n_reduce_tasks\n        if self.pool is not None:\n            # Supporting two schedulers: fair (default) and capacity using the same option\n            scheduler_type = luigi.configuration.get_config().get('hadoop', 'scheduler', 'fair')\n            if scheduler_type == 'fair':\n                jcs['mapred.fairscheduler.pool'] = self.pool\n            elif scheduler_type == 'capacity':\n                jcs['mapred.job.queue.name'] = self.pool\n        if self.bytes_per_reducer is not None:\n            jcs['hive.exec.reducers.bytes.per.reducer'] = self.bytes_per_reducer\n        if self.reducers_max is not None:\n            jcs['hive.exec.reducers.max'] = self.reducers_max\n        return jcs",
        "begin_line": 282,
        "end_line": 308,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.hive.HiveQueryRunner.prepare_outputs#319",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveQueryRunner",
        "signature": "luigi.contrib.hive.HiveQueryRunner.prepare_outputs(self, job)",
        "snippet": "    def prepare_outputs(self, job):\n        \"\"\"\n        Called before job is started.\n\n        If output is a `FileSystemTarget`, create parent directories so the hive command won't fail\n        \"\"\"\n        outputs = flatten(job.output())\n        for o in outputs:\n            if isinstance(o, FileSystemTarget):\n                parent_dir = os.path.dirname(o.path)\n                if parent_dir and not o.fs.exists(parent_dir):\n                    logger.info(\"Creating parent directory %r\", parent_dir)\n                    try:\n                        # there is a possible race condition\n                        # which needs to be handled here\n                        o.fs.mkdir(parent_dir)\n                    except FileAlreadyExists:\n                        pass",
        "begin_line": 319,
        "end_line": 336,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.hive.HiveQueryRunner.run_job#338",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveQueryRunner",
        "signature": "luigi.contrib.hive.HiveQueryRunner.run_job(self, job)",
        "snippet": "    def run_job(self, job):\n        self.prepare_outputs(job)\n        with tempfile.NamedTemporaryFile() as f:\n            query = job.query()\n            if isinstance(query, unicode):\n                query = query.encode('utf8')\n            f.write(query)\n            f.flush()\n            arglist = [load_hive_cmd(), '-f', f.name]\n            hiverc = job.hiverc()\n            if hiverc:\n                if isinstance(hiverc, str):\n                    hiverc = [hiverc]\n                for rcfile in hiverc:\n                    arglist += ['-i', rcfile]\n            if job.hiveconfs():\n                for k, v in six.iteritems(job.hiveconfs()):\n                    arglist += ['--hiveconf', '{0}={1}'.format(k, v)]\n\n            logger.info(arglist)\n            return luigi.hadoop.run_and_track_hadoop_job(arglist)",
        "begin_line": 338,
        "end_line": 358,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.configuration.LuigiConfigParser.instance#39",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration.LuigiConfigParser",
        "signature": "luigi.configuration.LuigiConfigParser.instance(cls, *args, **kwargs)",
        "snippet": "    def instance(cls, *args, **kwargs):\n        \"\"\" Singleton getter \"\"\"\n        if cls._instance is None:\n            cls._instance = cls(*args, **kwargs)\n            loaded = cls._instance.reload()\n            logging.getLogger('luigi-interface').info('Loaded %r', loaded)\n\n        return cls._instance",
        "begin_line": 39,
        "end_line": 46,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029850746268656717,
            "pseudo_dstar_susp": 0.010752688172043012,
            "pseudo_tarantula_susp": 0.0018450184501845018,
            "pseudo_op2_susp": 0.010752688172043012,
            "pseudo_barinel_susp": 0.0018450184501845018
        }
    },
    {
        "name": "luigi.configuration.LuigiConfigParser._get_with_default#52",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration.LuigiConfigParser",
        "signature": "luigi.configuration.LuigiConfigParser._get_with_default(self, method, section, option, default, expected_type=None, **kwargs)",
        "snippet": "    def _get_with_default(self, method, section, option, default, expected_type=None, **kwargs):\n        \"\"\"\n        Gets the value of the section/option using method.\n\n        Returns default if value is not found.\n\n        Raises an exception if the default value is not None and doesn't match the expected_type.\n        \"\"\"\n        try:\n            return method(self, section, option, **kwargs)\n        except (NoOptionError, NoSectionError):\n            if default is LuigiConfigParser.NO_DEFAULT:\n                raise\n            if expected_type is not None and default is not None and \\\n               not isinstance(default, expected_type):\n                raise\n            return default",
        "begin_line": 52,
        "end_line": 68,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008695652173913044,
            "pseudo_dstar_susp": 0.05555555555555555,
            "pseudo_tarantula_susp": 0.0030120481927710845,
            "pseudo_op2_susp": 0.05555555555555555,
            "pseudo_barinel_susp": 0.0030120481927710845
        }
    },
    {
        "name": "luigi.configuration.LuigiConfigParser.get#70",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration.LuigiConfigParser",
        "signature": "luigi.configuration.LuigiConfigParser.get(self, section, option, default=NO_DEFAULT, **kwargs)",
        "snippet": "    def get(self, section, option, default=NO_DEFAULT, **kwargs):\n        return self._get_with_default(ConfigParser.get, section, option, default, **kwargs)",
        "begin_line": 70,
        "end_line": 71,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0035460992907801418,
            "pseudo_dstar_susp": 0.010526315789473684,
            "pseudo_tarantula_susp": 0.0022727272727272726,
            "pseudo_op2_susp": 0.010526315789473684,
            "pseudo_barinel_susp": 0.002277904328018223
        }
    },
    {
        "name": "luigi.configuration.LuigiConfigParser.getboolean#73",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration.LuigiConfigParser",
        "signature": "luigi.configuration.LuigiConfigParser.getboolean(self, section, option, default=NO_DEFAULT)",
        "snippet": "    def getboolean(self, section, option, default=NO_DEFAULT):\n        return self._get_with_default(ConfigParser.getboolean, section, option, default, bool)",
        "begin_line": 73,
        "end_line": 74,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001694915254237288,
            "pseudo_dstar_susp": 0.0030303030303030303,
            "pseudo_tarantula_susp": 0.0014534883720930232,
            "pseudo_op2_susp": 0.0030303030303030303,
            "pseudo_barinel_susp": 0.0014534883720930232
        }
    },
    {
        "name": "luigi.configuration.LuigiConfigParser.getint#76",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration.LuigiConfigParser",
        "signature": "luigi.configuration.LuigiConfigParser.getint(self, section, option, default=NO_DEFAULT)",
        "snippet": "    def getint(self, section, option, default=NO_DEFAULT):\n        return self._get_with_default(ConfigParser.getint, section, option, default, int)",
        "begin_line": 76,
        "end_line": 77,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00186219739292365,
            "pseudo_dstar_susp": 0.0035335689045936395,
            "pseudo_tarantula_susp": 0.0015082956259426848,
            "pseudo_op2_susp": 0.0035335689045936395,
            "pseudo_barinel_susp": 0.0015082956259426848
        }
    },
    {
        "name": "luigi.configuration.LuigiConfigParser.getfloat#79",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration.LuigiConfigParser",
        "signature": "luigi.configuration.LuigiConfigParser.getfloat(self, section, option, default=NO_DEFAULT)",
        "snippet": "    def getfloat(self, section, option, default=NO_DEFAULT):\n        return self._get_with_default(ConfigParser.getfloat, section, option, default, float)",
        "begin_line": 79,
        "end_line": 80,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024691358024691358,
            "pseudo_dstar_susp": 0.0056179775280898875,
            "pseudo_tarantula_susp": 0.00196078431372549,
            "pseudo_op2_susp": 0.0056179775280898875,
            "pseudo_barinel_susp": 0.00196078431372549
        }
    },
    {
        "name": "luigi.configuration.LuigiConfigParser.getintdict#82",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration.LuigiConfigParser",
        "signature": "luigi.configuration.LuigiConfigParser.getintdict(self, section)",
        "snippet": "    def getintdict(self, section):\n        try:\n            return dict((key, int(value)) for key, value in self.items(section))\n        except NoSectionError:\n            return {}",
        "begin_line": 82,
        "end_line": 86,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005813953488372093,
            "pseudo_dstar_susp": 0.012048192771084338,
            "pseudo_tarantula_susp": 0.003003003003003003,
            "pseudo_op2_susp": 0.012048192771084338,
            "pseudo_barinel_susp": 0.003003003003003003
        }
    },
    {
        "name": "luigi.configuration.LuigiConfigParser.set#88",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration.LuigiConfigParser",
        "signature": "luigi.configuration.LuigiConfigParser.set(self, section, option, value=None)",
        "snippet": "    def set(self, section, option, value=None):\n        if not ConfigParser.has_section(self, section):\n            ConfigParser.add_section(self, section)\n\n        return ConfigParser.set(self, section, option, value)",
        "begin_line": 88,
        "end_line": 92,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.00043497172683775554,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.configuration.get_config#95",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration",
        "signature": "luigi.configuration.get_config()",
        "snippet": "def get_config():\n    \"\"\"\n    Convenience method (for backwards compatibility) for accessing config singleton.\n    \"\"\"\n    return LuigiConfigParser.instance()",
        "begin_line": 95,
        "end_line": 99,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.2,
            "pseudo_dstar_susp": 0.017543859649122806,
            "pseudo_tarantula_susp": 0.006211180124223602,
            "pseudo_op2_susp": 0.017241379310344827,
            "pseudo_barinel_susp": 0.006211180124223602
        }
    },
    {
        "name": "luigi.contrib.mysqldb.MySqlTarget.touch#66",
        "src_path": "luigi/contrib/mysqldb.py",
        "class_name": "luigi.contrib.mysqldb.MySqlTarget",
        "signature": "luigi.contrib.mysqldb.MySqlTarget.touch(self, connection=None)",
        "snippet": "    def touch(self, connection=None):\n        \"\"\"\n        Mark this update as complete.\n\n        IMPORTANT, If the marker table doesn't exist,\n        the connection transaction will be aborted and the connection reset.\n        Then the marker table will be created.\n        \"\"\"\n        self.create_marker_table()\n\n        if connection is None:\n            connection = self.connect()\n            connection.autocommit = True  # if connection created here, we commit it here\n\n        connection.cursor().execute(\n            \"\"\"INSERT INTO {marker_table} (update_id, target_table)\n               VALUES (%s, %s)\n               ON DUPLICATE KEY UPDATE\n               update_id = VALUES(update_id)\n            \"\"\".format(marker_table=self.marker_table),\n            (self.update_id, self.table)\n        )\n        # make sure update is properly marked\n        assert self.exists(connection)",
        "begin_line": 66,
        "end_line": 89,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.mysqldb.MySqlTarget.exists#91",
        "src_path": "luigi/contrib/mysqldb.py",
        "class_name": "luigi.contrib.mysqldb.MySqlTarget",
        "signature": "luigi.contrib.mysqldb.MySqlTarget.exists(self, connection=None)",
        "snippet": "    def exists(self, connection=None):\n        if connection is None:\n            connection = self.connect()\n            connection.autocommit = True\n        cursor = connection.cursor()\n        try:\n            cursor.execute(\"\"\"SELECT 1 FROM {marker_table}\n                WHERE update_id = %s\n                LIMIT 1\"\"\".format(marker_table=self.marker_table),\n                           (self.update_id,)\n                           )\n            row = cursor.fetchone()\n        except mysql.connector.Error as e:\n            if e.errno == errorcode.ER_NO_SUCH_TABLE:\n                row = None\n            else:\n                raise\n        return row is not None",
        "begin_line": 91,
        "end_line": 108,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.mysqldb.MySqlTarget.connect#110",
        "src_path": "luigi/contrib/mysqldb.py",
        "class_name": "luigi.contrib.mysqldb.MySqlTarget",
        "signature": "luigi.contrib.mysqldb.MySqlTarget.connect(self, autocommit=False)",
        "snippet": "    def connect(self, autocommit=False):\n        connection = mysql.connector.connect(user=self.user,\n                                             password=self.password,\n                                             host=self.host,\n                                             port=self.port,\n                                             database=self.database,\n                                             autocommit=autocommit)\n        return connection",
        "begin_line": 110,
        "end_line": 117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.mysqldb.MySqlTarget.create_marker_table#119",
        "src_path": "luigi/contrib/mysqldb.py",
        "class_name": "luigi.contrib.mysqldb.MySqlTarget",
        "signature": "luigi.contrib.mysqldb.MySqlTarget.create_marker_table(self)",
        "snippet": "    def create_marker_table(self):\n        \"\"\"\n        Create marker table if it doesn't exist.\n\n        Using a separate connection since the transaction might have to be reset.\n        \"\"\"\n        connection = self.connect(autocommit=True)\n        cursor = connection.cursor()\n        try:\n            cursor.execute(\n                \"\"\" CREATE TABLE {marker_table} (\n                        id            BIGINT(20)    NOT NULL AUTO_INCREMENT,\n                        update_id     VARCHAR(128)  NOT NULL,\n                        target_table  VARCHAR(128),\n                        inserted      TIMESTAMP DEFAULT NOW(),\n                        PRIMARY KEY (update_id),\n                        KEY id (id)\n                    )\n                \"\"\"\n                .format(marker_table=self.marker_table)\n            )\n        except mysql.connector.Error as e:\n            if e.errno == errorcode.ER_TABLE_EXISTS_ERROR:\n                pass\n            else:\n                raise\n        connection.close()",
        "begin_line": 119,
        "end_line": 145,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.sqla.SQLAlchemyTarget.engine#182",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.SQLAlchemyTarget",
        "signature": "luigi.contrib.sqla.SQLAlchemyTarget.engine(self)",
        "snippet": "    def engine(self):\n        pid = os.getpid()\n        if (SQLAlchemyTarget._engine is None) or (SQLAlchemyTarget._pid != pid):\n            SQLAlchemyTarget._engine = sqlalchemy.create_engine(self.connection_string, echo=self.echo)\n            SQLAlchemyTarget._pid = pid\n        return SQLAlchemyTarget._engine",
        "begin_line": 182,
        "end_line": 187,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004616805170821791,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.sqla.SQLAlchemyTarget.touch#189",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.SQLAlchemyTarget",
        "signature": "luigi.contrib.sqla.SQLAlchemyTarget.touch(self)",
        "snippet": "    def touch(self):\n        \"\"\"\n        Mark this update as complete.\n        \"\"\"\n        if self.marker_table_bound is None:\n            self.create_marker_table()\n\n        table = self.marker_table_bound\n        id_exists = self.exists()\n        with self.engine.begin() as conn:\n            if not id_exists:\n                ins = table.insert().values(update_id=self.update_id, target_table=self.target_table,\n                                            inserted=datetime.datetime.now())\n            else:\n                ins = table.update().where(sqlalchemy.and_(table.c.update_id == self.update_id,\n                                                           table.c.target_table == self.target_table)).\\\n                    values(update_id=self.update_id, target_table=self.target_table,\n                           inserted=datetime.datetime.now())\n            conn.execute(ins)\n        assert self.exists()",
        "begin_line": 189,
        "end_line": 208,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005070993914807302,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.sqla.SQLAlchemyTarget.exists#210",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.SQLAlchemyTarget",
        "signature": "luigi.contrib.sqla.SQLAlchemyTarget.exists(self)",
        "snippet": "    def exists(self):\n        row = None\n        if self.marker_table_bound is None:\n            self.create_marker_table()\n        with self.engine.begin() as conn:\n            table = self.marker_table_bound\n            s = sqlalchemy.select([table]).where(sqlalchemy.and_(table.c.update_id == self.update_id,\n                                                                 table.c.target_table == self.target_table)).limit(1)\n            row = conn.execute(s).fetchone()\n        return row is not None",
        "begin_line": 210,
        "end_line": 219,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004743833017077799,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.sqla.SQLAlchemyTarget.create_marker_table#221",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.SQLAlchemyTarget",
        "signature": "luigi.contrib.sqla.SQLAlchemyTarget.create_marker_table(self)",
        "snippet": "    def create_marker_table(self):\n        \"\"\"\n        Create marker table if it doesn't exist.\n\n        Using a separate connection since the transaction might have to be reset.\n        \"\"\"\n        if self.marker_table is None:\n            self.marker_table = luigi.configuration.get_config().get('sqlalchemy', 'marker-table', 'table_updates')\n\n        engine = self.engine\n\n        with engine.begin() as con:\n            metadata = sqlalchemy.MetaData()\n            if not con.dialect.has_table(con, self.marker_table):\n                self.marker_table_bound = sqlalchemy.Table(\n                    self.marker_table, metadata,\n                    sqlalchemy.Column(\"update_id\", sqlalchemy.String(128), primary_key=True),\n                    sqlalchemy.Column(\"target_table\", sqlalchemy.String(128)),\n                    sqlalchemy.Column(\"inserted\", sqlalchemy.DateTime, default=datetime.datetime.now()))\n                metadata.create_all(engine)\n            else:\n                metadata.reflect(bind=engine)\n                self.marker_table_bound = metadata.tables[self.marker_table]",
        "begin_line": 221,
        "end_line": 243,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004997501249375312,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.create_table#287",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.create_table(self, engine)",
        "snippet": "    def create_table(self, engine):\n        \"\"\"\n        Override to provide code for creating the target table.\n\n        By default it will be created using types specified in columns.\n        If the table exists, then it binds to the existing table.\n\n        If overridden, use the provided connection object for setting up the table in order to\n        create the table and insert data using the same transaction.\n        :param engine: The sqlalchemy engine instance\n        :type engine: object\n        \"\"\"\n        def construct_sqla_columns(columns):\n            retval = [sqlalchemy.Column(*c[0], **c[1]) for c in columns]\n            return retval\n\n        needs_setup = (len(self.columns) == 0) or (False in [len(c) == 2 for c in self.columns]) if not self.reflect else False\n        if needs_setup:\n            # only names of columns specified, no types\n            raise NotImplementedError(\"create_table() not implemented for %r and columns types not specified\" % self.table)\n        else:\n            # if columns is specified as (name, type) tuples\n            with engine.begin() as con:\n                metadata = sqlalchemy.MetaData()\n                try:\n                    if not con.dialect.has_table(con, self.table):\n                        sqla_columns = construct_sqla_columns(self.columns)\n                        self.table_bound = sqlalchemy.Table(self.table, metadata, *sqla_columns)\n                        metadata.create_all(engine)\n                    else:\n                        metadata.reflect(bind=engine)\n                        self.table_bound = metadata.tables[self.table]\n                except Exception as e:\n                    self._logger.exception(self.table + str(e))",
        "begin_line": 287,
        "end_line": 320,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.update_id#322",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.update_id(self)",
        "snippet": "    def update_id(self):\n        \"\"\"\n        This update id will be a unique identifier for this insert on this table.\n        \"\"\"\n        return self.task_id",
        "begin_line": 322,
        "end_line": 326,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.run#345",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.run(self)",
        "snippet": "    def run(self):\n        self._logger.info(\"Running task copy to table for update id %s for table %s\" % (self.update_id(), self.table))\n        output = self.output()\n        engine = output.engine\n        self.create_table(engine)\n        with engine.begin() as conn:\n            rows = iter(self.rows())\n            ins_rows = [dict(zip((\"_\" + c.key for c in self.table_bound.c), row))\n                        for row in itertools.islice(rows, self.chunk_size)]\n            while ins_rows:\n                self.copy(conn, ins_rows, self.table_bound)\n                ins_rows = [dict(zip((\"_\" + c.key for c in self.table_bound.c), row))\n                            for row in itertools.islice(rows, self.chunk_size)]\n                self._logger.info(\"Finished inserting %d rows into SQLAlchemy target\" % len(ins_rows))\n        output.touch()\n        self._logger.info(\"Finished inserting rows into SQLAlchemy target\")",
        "begin_line": 345,
        "end_line": 360,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005213764337851929,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.copy#362",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.copy(self, conn, ins_rows, table_bound)",
        "snippet": "    def copy(self, conn, ins_rows, table_bound):\n        \"\"\"\n        This method does the actual insertion of the rows of data given by ins_rows into the\n        database. A task that needs row updates instead of insertions should overload this method.\n        :param conn: The sqlalchemy connection object\n        :param ins_rows: The dictionary of rows with the keys in the format _<column_name>. For example\n        if you have a table with a column name \"property\", then the key in the dictionary\n        would be \"_property\". This format is consistent with the bindparam usage in sqlalchemy.\n        :param table_bound: The object referring to the table\n        :return:\n        \"\"\"\n        bound_cols = dict((c, sqlalchemy.bindparam(\"_\" + c.key)) for c in table_bound.columns)\n        ins = table_bound.insert().values(bound_cols)\n        conn.execute(ins, ins_rows)",
        "begin_line": 362,
        "end_line": 375,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.target.CascadingClient.__init__#43",
        "src_path": "luigi/contrib/target.py",
        "class_name": "luigi.contrib.target.CascadingClient",
        "signature": "luigi.contrib.target.CascadingClient.__init__(self, clients, method_names=None)",
        "snippet": "    def __init__(self, clients, method_names=None):\n        self.clients = clients\n        if method_names is None:\n            method_names = self.ALL_METHOD_NAMES\n\n        for method_name in method_names:\n            new_method = self._make_method(method_name)\n            real_method = six.create_bound_method(new_method, self)\n            setattr(self, method_name, real_method)",
        "begin_line": 43,
        "end_line": 51,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005652911249293386,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.target.CascadingClient.new_method#55",
        "src_path": "luigi/contrib/target.py",
        "class_name": "luigi.contrib.target.CascadingClient",
        "signature": "luigi.contrib.target.CascadingClient.new_method(self, *args, **kwargs)",
        "snippet": "        def new_method(self, *args, **kwargs):\n            return self._chained_call(method_name, *args, **kwargs)",
        "begin_line": 55,
        "end_line": 56,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.target.CascadingClient._make_method#54",
        "src_path": "luigi/contrib/target.py",
        "class_name": "luigi.contrib.target.CascadingClient",
        "signature": "luigi.contrib.target.CascadingClient._make_method(cls, method_name)",
        "snippet": "    def _make_method(cls, method_name):\n        def new_method(self, *args, **kwargs):\n            return self._chained_call(method_name, *args, **kwargs)\n        return new_method",
        "begin_line": 54,
        "end_line": 57,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005652911249293386,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.target.CascadingClient._chained_call#59",
        "src_path": "luigi/contrib/target.py",
        "class_name": "luigi.contrib.target.CascadingClient",
        "signature": "luigi.contrib.target.CascadingClient._chained_call(self, method_name, *args, **kwargs)",
        "snippet": "    def _chained_call(self, method_name, *args, **kwargs):\n        for i in range(len(self.clients)):\n            client = self.clients[i]\n            try:\n                result = getattr(client, method_name)(*args, **kwargs)\n                return result\n            except luigi.target.FileSystemException:\n                # For exceptions that are semantical, we must throw along\n                raise\n            except BaseException:\n                is_last_iteration = (i + 1) >= len(self.clients)\n                if is_last_iteration:\n                    raise\n                else:\n                    logger.exception('The %s failed to %s, using fallback class %s',\n                                     client.__class__.__name__, method_name, self.clients[i + 1].__class__.__name__)",
        "begin_line": 59,
        "end_line": 74,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.Failures.__init__#116",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Failures",
        "signature": "luigi.scheduler.Failures.__init__(self, window)",
        "snippet": "    def __init__(self, window):\n        \"\"\"\n        Initialize with the given window.\n\n        :param window: how long to track failures for, as a float (number of seconds).\n        \"\"\"\n        self.window = window\n        self.failures = collections.deque()",
        "begin_line": 116,
        "end_line": 123,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004366812227074236,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.Failures.add_failure#125",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Failures",
        "signature": "luigi.scheduler.Failures.add_failure(self)",
        "snippet": "    def add_failure(self):\n        \"\"\"\n        Add a failure event with the current timestamp.\n        \"\"\"\n        self.failures.append(time.time())",
        "begin_line": 125,
        "end_line": 129,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004943153732081067,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.Failures.num_failures#131",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Failures",
        "signature": "luigi.scheduler.Failures.num_failures(self)",
        "snippet": "    def num_failures(self):\n        \"\"\"\n        Return the number of failures in the window.\n        \"\"\"\n        min_time = time.time() - self.window\n\n        while self.failures and fix_time(self.failures[0]) < min_time:\n            self.failures.popleft()\n\n        return len(self.failures)",
        "begin_line": 131,
        "end_line": 140,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.00051440329218107,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.Failures.clear#142",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Failures",
        "signature": "luigi.scheduler.Failures.clear(self)",
        "snippet": "    def clear(self):\n        \"\"\"\n        Clear the failure queue.\n        \"\"\"\n        self.failures.clear()",
        "begin_line": 142,
        "end_line": 146,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005379236148466917,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler._get_default#149",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler",
        "signature": "luigi.scheduler._get_default(x, default)",
        "snippet": "def _get_default(x, default):\n    if x is not None:\n        return x\n    else:\n        return default",
        "begin_line": 149,
        "end_line": 153,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010845986984815619,
            "pseudo_dstar_susp": 0.0010845986984815619,
            "pseudo_tarantula_susp": 0.0010845986984815619,
            "pseudo_op2_susp": 0.0010845986984815619,
            "pseudo_barinel_susp": 0.0010845986984815619
        }
    },
    {
        "name": "luigi.scheduler.Task.__init__#158",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Task",
        "signature": "luigi.scheduler.Task.__init__(self, task_id, status, deps, resources=None, priority=0, family='', params=None, disable_failures=None, disable_window=None)",
        "snippet": "    def __init__(self, task_id, status, deps, resources=None, priority=0, family='', params=None,\n                 disable_failures=None, disable_window=None):\n        self.id = task_id\n        self.stakeholders = set()  # workers ids that are somehow related to this task (i.e. don't prune while any of these workers are still active)\n        self.workers = set()  # workers ids that can perform task - task is 'BROKEN' if none of these workers are active\n        if deps is None:\n            self.deps = set()\n        else:\n            self.deps = set(deps)\n        self.status = status  # PENDING, RUNNING, FAILED or DONE\n        self.time = time.time()  # Timestamp when task was first added\n        self.retry = None\n        self.remove = None\n        self.worker_running = None  # the worker id that is currently running the task or None\n        self.time_running = None  # Timestamp when picked up by worker\n        self.expl = None\n        self.priority = priority\n        self.resources = _get_default(resources, {})\n        self.family = family\n        self.params = _get_default(params, {})\n        self.disable_failures = disable_failures\n        self.failures = Failures(disable_window)\n        self.scheduler_disable_time = None",
        "begin_line": 158,
        "end_line": 180,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011574074074074073,
            "pseudo_dstar_susp": 0.0011574074074074073,
            "pseudo_tarantula_susp": 0.0011574074074074073,
            "pseudo_op2_susp": 0.0011574074074074073,
            "pseudo_barinel_susp": 0.0011574074074074073
        }
    },
    {
        "name": "luigi.scheduler.Task.add_failure#185",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Task",
        "signature": "luigi.scheduler.Task.add_failure(self)",
        "snippet": "    def add_failure(self):\n        self.failures.add_failure()",
        "begin_line": 185,
        "end_line": 186,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005070993914807302,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.Task.has_excessive_failures#188",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Task",
        "signature": "luigi.scheduler.Task.has_excessive_failures(self)",
        "snippet": "    def has_excessive_failures(self):\n        return self.failures.num_failures() >= self.disable_failures",
        "begin_line": 188,
        "end_line": 189,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005070993914807302,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.Task.can_disable#191",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Task",
        "signature": "luigi.scheduler.Task.can_disable(self)",
        "snippet": "    def can_disable(self):\n        return self.disable_failures is not None",
        "begin_line": 191,
        "end_line": 192,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004784688995215311,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.Worker.__init__#200",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.__init__(self, worker_id, last_active=None)",
        "snippet": "    def __init__(self, worker_id, last_active=None):\n        self.id = worker_id\n        self.reference = None  # reference to the worker in the real world. (Currently a dict containing just the host)\n        self.last_active = last_active  # seconds since epoch\n        self.started = time.time()  # seconds since epoch\n        self.info = {}",
        "begin_line": 200,
        "end_line": 205,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006369426751592357,
            "pseudo_dstar_susp": 0.04,
            "pseudo_tarantula_susp": 0.002717391304347826,
            "pseudo_op2_susp": 0.04,
            "pseudo_barinel_susp": 0.0027100271002710027
        }
    },
    {
        "name": "luigi.scheduler.Worker.add_info#207",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.add_info(self, info)",
        "snippet": "    def add_info(self, info):\n        self.info.update(info)",
        "begin_line": 207,
        "end_line": 208,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016207455429497568,
            "pseudo_dstar_susp": 0.0024271844660194173,
            "pseudo_tarantula_susp": 0.0015723270440251573,
            "pseudo_op2_susp": 0.0024271844660194173,
            "pseudo_barinel_susp": 0.001584786053882726
        }
    },
    {
        "name": "luigi.scheduler.Worker.update#210",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.update(self, worker_reference)",
        "snippet": "    def update(self, worker_reference):\n        if worker_reference:\n            self.reference = worker_reference\n        self.last_active = time.time()",
        "begin_line": 210,
        "end_line": 213,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006369426751592357,
            "pseudo_dstar_susp": 0.04,
            "pseudo_tarantula_susp": 0.002717391304347826,
            "pseudo_op2_susp": 0.04,
            "pseudo_barinel_susp": 0.0027100271002710027
        }
    },
    {
        "name": "luigi.scheduler.Worker.prune#215",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.prune(self, config)",
        "snippet": "    def prune(self, config):\n        # Delete workers that haven't said anything for a while (probably killed)\n        if self.last_active + config.worker_disconnect_delay < time.time():\n            return True",
        "begin_line": 215,
        "end_line": 218,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.Worker.__str__#220",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.__str__(self)",
        "snippet": "    def __str__(self):\n        return self.id",
        "begin_line": 220,
        "end_line": 221,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011961722488038277,
            "pseudo_dstar_susp": 0.0011947431302270011,
            "pseudo_tarantula_susp": 0.00145985401459854,
            "pseudo_op2_susp": 0.0011947431302270011,
            "pseudo_barinel_susp": 0.00145985401459854
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.__init__#233",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.__init__(self, state_path)",
        "snippet": "    def __init__(self, state_path):\n        self._state_path = state_path\n        self._tasks = {}  # map from id to a Task object\n        self._status_tasks = collections.defaultdict(dict)\n        self._active_workers = {}  # map from id to a Worker object",
        "begin_line": 233,
        "end_line": 237,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004098360655737705,
            "pseudo_dstar_susp": 0.01282051282051282,
            "pseudo_tarantula_susp": 0.002380952380952381,
            "pseudo_op2_susp": 0.01282051282051282,
            "pseudo_barinel_susp": 0.002380952380952381
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.load#250",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.load(self)",
        "snippet": "    def load(self):\n        if os.path.exists(self._state_path):\n            logger.info(\"Attempting to load state from %s\", self._state_path)\n            try:\n                with open(self._state_path, 'rb') as fobj:\n                    state = pickle.load(fobj)\n            except BaseException:\n                logger.exception(\"Error when loading state. Starting from clean slate.\")\n                return\n\n            self._tasks, self._active_workers = state\n            self._status_tasks = collections.defaultdict(dict)\n            for task in six.itervalues(self._tasks):\n                self._status_tasks[task.status][task.id] = task\n\n            # Convert from old format\n            # TODO: this is really ugly, we need something more future-proof\n            # Every time we add an attribute to the Worker class, this code needs to be updated\n            for k, v in six.iteritems(self._active_workers):\n                if isinstance(v, float):\n                    self._active_workers[k] = Worker(worker_id=k, last_active=v)\n        else:\n            logger.info(\"No prior state file exists at %s. Starting with clean slate\", self._state_path)",
        "begin_line": 250,
        "end_line": 272,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.1,
            "pseudo_dstar_susp": 0.008333333333333333,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.008333333333333333,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_active_tasks#274",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_active_tasks(self, status=None)",
        "snippet": "    def get_active_tasks(self, status=None):\n        if status:\n            for task in six.itervalues(self._status_tasks[status]):\n                yield task\n        else:\n            for task in six.itervalues(self._tasks):\n                yield task",
        "begin_line": 274,
        "end_line": 280,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001310615989515072,
            "pseudo_dstar_susp": 0.0017730496453900709,
            "pseudo_tarantula_susp": 0.0012300123001230013,
            "pseudo_op2_susp": 0.0017730496453900709,
            "pseudo_barinel_susp": 0.0012300123001230013
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_pending_tasks#285",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_pending_tasks(self)",
        "snippet": "    def get_pending_tasks(self):\n        return itertools.chain.from_iterable(six.itervalues(self._status_tasks[status])\n                                             for status in [PENDING, RUNNING])",
        "begin_line": 285,
        "end_line": 287,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00130718954248366,
            "pseudo_dstar_susp": 0.0017667844522968198,
            "pseudo_tarantula_susp": 0.0012077294685990338,
            "pseudo_op2_susp": 0.0017667844522968198,
            "pseudo_barinel_susp": 0.0012077294685990338
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_task#289",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_task(self, task_id, default=None, setdefault=None)",
        "snippet": "    def get_task(self, task_id, default=None, setdefault=None):\n        if setdefault:\n            task = self._tasks.setdefault(task_id, setdefault)\n            self._status_tasks[task.status][task.id] = task\n            return task\n        else:\n            return self._tasks.get(task_id, default)",
        "begin_line": 289,
        "end_line": 295,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011086474501108647,
            "pseudo_dstar_susp": 0.0011086474501108647,
            "pseudo_tarantula_susp": 0.0011086474501108647,
            "pseudo_op2_susp": 0.0011086474501108647,
            "pseudo_barinel_susp": 0.0011086474501108647
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.has_task#297",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.has_task(self, task_id)",
        "snippet": "    def has_task(self, task_id):\n        return task_id in self._tasks",
        "begin_line": 297,
        "end_line": 298,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.re_enable#300",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.re_enable(self, task, config=None)",
        "snippet": "    def re_enable(self, task, config=None):\n        task.scheduler_disable_time = None\n        task.failures.clear()\n        if config:\n            self.set_status(task, FAILED, config)\n            task.failures.clear()",
        "begin_line": 300,
        "end_line": 305,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.set_status#307",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.set_status(self, task, new_status, config=None)",
        "snippet": "    def set_status(self, task, new_status, config=None):\n        if new_status == FAILED:\n            assert config is not None\n\n        # not sure why we have SUSPENDED, as it can never be set\n        if new_status == SUSPENDED:\n            new_status = PENDING\n\n        if new_status == DISABLED and task.status == RUNNING:\n            return\n\n        if task.status == DISABLED:\n            if new_status == DONE:\n                self.re_enable(task)\n\n            # don't allow workers to override a scheduler disable\n            elif task.scheduler_disable_time is not None:\n                return\n\n        if new_status == FAILED and task.can_disable():\n            task.add_failure()\n            if task.has_excessive_failures():\n                task.scheduler_disable_time = time.time()\n                new_status = DISABLED\n                notifications.send_error_email(\n                    'Luigi Scheduler: DISABLED {task} due to excessive failures'.format(task=task.id),\n                    '{task} failed {failures} times in the last {window} seconds, so it is being '\n                    'disabled for {persist} seconds'.format(\n                        failures=config.disable_failures,\n                        task=task.id,\n                        window=config.disable_window,\n                        persist=config.disable_persist,\n                    ))\n        elif new_status == DISABLED:\n            task.scheduler_disable_time = None\n\n        self._status_tasks[task.status].pop(task.id)\n        self._status_tasks[new_status][task.id] = task\n        task.status = new_status",
        "begin_line": 307,
        "end_line": 345,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011049723756906078,
            "pseudo_dstar_susp": 0.0011049723756906078,
            "pseudo_tarantula_susp": 0.0011049723756906078,
            "pseudo_op2_susp": 0.0011049723756906078,
            "pseudo_barinel_susp": 0.0011049723756906078
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.prune#347",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.prune(self, task, config)",
        "snippet": "    def prune(self, task, config):\n        remove = False\n\n        # Mark tasks with no remaining active stakeholders for deletion\n        if not task.stakeholders:\n            if task.remove is None:\n                logger.info(\"Task %r has stakeholders %r but none remain connected -> will remove \"\n                            \"task in %s seconds\", task.id, task.stakeholders, config.remove_delay)\n                task.remove = time.time() + config.remove_delay\n\n        # If a running worker disconnects, tag all its jobs as FAILED and subject it to the same retry logic\n        if task.status == RUNNING and task.worker_running and task.worker_running not in task.stakeholders:\n            logger.info(\"Task %r is marked as running by disconnected worker %r -> marking as \"\n                        \"FAILED with retry delay of %rs\", task.id, task.worker_running,\n                        config.retry_delay)\n            task.worker_running = None\n            self.set_status(task, FAILED, config)\n            task.retry = time.time() + config.retry_delay\n\n        # Re-enable task after the disable time expires\n        if task.status == DISABLED and task.scheduler_disable_time:\n            if time.time() - fix_time(task.scheduler_disable_time) > config.disable_persist:\n                self.re_enable(task, config)\n\n        # Remove tasks that have no stakeholders\n        if task.remove and time.time() > task.remove:\n            logger.info(\"Removing task %r (no connected stakeholders)\", task.id)\n            remove = True\n\n        # Reset FAILED tasks to PENDING if max timeout is reached, and retry delay is >= 0\n        if task.status == FAILED and config.retry_delay >= 0 and task.retry < time.time():\n            self.set_status(task, PENDING, config)\n\n        return remove",
        "begin_line": 347,
        "end_line": 380,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_active_workers#390",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_active_workers(self, last_active_lt=None)",
        "snippet": "    def get_active_workers(self, last_active_lt=None):\n        for worker in six.itervalues(self._active_workers):\n            if last_active_lt is not None and worker.last_active >= last_active_lt:\n                continue\n            yield worker",
        "begin_line": 390,
        "end_line": 394,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_worker#399",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_worker(self, worker_id)",
        "snippet": "    def get_worker(self, worker_id):\n        return self._active_workers.setdefault(worker_id, Worker(worker_id))",
        "begin_line": 399,
        "end_line": 400,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00819672131147541,
            "pseudo_dstar_susp": 0.015625,
            "pseudo_tarantula_susp": 0.004739336492890996,
            "pseudo_op2_susp": 0.015625,
            "pseudo_barinel_susp": 0.004739336492890996
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.inactivate_workers#402",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.inactivate_workers(self, delete_workers)",
        "snippet": "    def inactivate_workers(self, delete_workers):\n        # Mark workers as inactive\n        for worker in delete_workers:\n            self._active_workers.pop(worker)\n\n        # remove workers from tasks\n        for task in self.get_active_tasks():\n            task.stakeholders.difference_update(delete_workers)\n            task.workers.difference_update(delete_workers)",
        "begin_line": 402,
        "end_line": 410,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.__init__#420",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.__init__(self, config=None, resources=None, task_history_impl=None, **kwargs)",
        "snippet": "    def __init__(self, config=None, resources=None, task_history_impl=None, **kwargs):\n        \"\"\"\n        Keyword Arguments:\n        :param config: an object of class \"scheduler\" or None (in which the global instance will be used)\n        :param resources: a dict of str->int constraints\n        :param task_history_override: ignore config and use this object as the task history\n        \"\"\"\n        self._config = config or scheduler(**kwargs)\n        self._state = SimpleTaskState(self._config.state_path)\n\n        if task_history_impl:\n            self._task_history = task_history_impl\n        elif self._config.record_task_history:\n            import db_task_history  # Needs sqlalchemy, thus imported here\n            self._task_history = db_task_history.DbTaskHistory()\n        else:\n            self._task_history = history.NopHistory()\n        self._resources = resources or configuration.get_config().getintdict('resources')  # TODO: Can we make this a Parameter?\n        self._make_task = functools.partial(\n            Task, disable_failures=self._config.disable_failures,\n            disable_window=self._config.disable_window)",
        "begin_line": 420,
        "end_line": 440,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008403361344537815,
            "pseudo_dstar_susp": 0.011764705882352941,
            "pseudo_tarantula_susp": 0.0038461538461538464,
            "pseudo_op2_susp": 0.011764705882352941,
            "pseudo_barinel_susp": 0.0038461538461538464
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.load#442",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.load(self)",
        "snippet": "    def load(self):\n        self._state.load()",
        "begin_line": 442,
        "end_line": 443,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.1,
            "pseudo_dstar_susp": 0.008333333333333333,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.008333333333333333,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.prune#448",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.prune(self)",
        "snippet": "    def prune(self):\n        logger.info(\"Starting pruning of task graph\")\n        remove_workers = []\n        for worker in self._state.get_active_workers():\n            if worker.prune(self._config):\n                logger.info(\"Worker %s timed out (no contact for >=%ss)\", worker, self._config.worker_disconnect_delay)\n                remove_workers.append(worker.id)\n\n        self._state.inactivate_workers(remove_workers)\n\n        remove_tasks = []\n        for task in self._state.get_active_tasks():\n            if self._state.prune(task, self._config):\n                remove_tasks.append(task.id)\n\n        self._state.inactivate_tasks(remove_tasks)\n\n        logger.info(\"Done pruning task graph\")",
        "begin_line": 448,
        "end_line": 465,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.update#467",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.update(self, worker_id, worker_reference=None)",
        "snippet": "    def update(self, worker_id, worker_reference=None):\n        \"\"\"\n        Keep track of whenever the worker was last active.\n        \"\"\"\n        worker = self._state.get_worker(worker_id)\n        worker.update(worker_reference)",
        "begin_line": 467,
        "end_line": 472,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00819672131147541,
            "pseudo_dstar_susp": 0.015625,
            "pseudo_tarantula_susp": 0.004739336492890996,
            "pseudo_op2_susp": 0.015625,
            "pseudo_barinel_susp": 0.004739336492890996
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._update_priority#474",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._update_priority(self, task, prio, worker)",
        "snippet": "    def _update_priority(self, task, prio, worker):\n        \"\"\"\n        Update priority of the given task.\n\n        Priority can only be increased.\n        If the task doesn't exist, a placeholder task is created to preserve priority when the task is later scheduled.\n        \"\"\"\n        task.priority = prio = max(prio, task.priority)\n        for dep in task.deps or []:\n            t = self._state.get_task(dep)\n            if t is not None and prio > t.priority:\n                self._update_priority(t, prio, worker)",
        "begin_line": 474,
        "end_line": 485,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010615711252653928,
            "pseudo_dstar_susp": 0.0010615711252653928,
            "pseudo_tarantula_susp": 0.0010615711252653928,
            "pseudo_op2_susp": 0.0010615711252653928,
            "pseudo_barinel_susp": 0.0010615711252653928
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.add_task#487",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.add_task(self, worker, task_id, status=PENDING, runnable=True, deps=None, new_deps=None, expl=None, resources=None, priority=0, family='', params=None, **kwargs)",
        "snippet": "    def add_task(self, worker, task_id, status=PENDING, runnable=True,\n                 deps=None, new_deps=None, expl=None, resources=None,\n                 priority=0, family='', params=None, **kwargs):\n        \"\"\"\n        * add task identified by task_id if it doesn't exist\n        * if deps is not None, update dependency list\n        * update status of task\n        * add additional workers/stakeholders\n        * update priority when needed\n        \"\"\"\n        self.update(worker)\n\n        task = self._state.get_task(task_id, setdefault=self._make_task(\n            task_id=task_id, status=PENDING, deps=deps, resources=resources,\n            priority=priority, family=family, params=params))\n\n        # for setting priority, we'll sometimes create tasks with unset family and params\n        if not task.family:\n            task.family = family\n        if not task.params:\n            task.params = _get_default(params, {})\n\n        if task.remove is not None:\n            task.remove = None  # unmark task for removal so it isn't removed after being added\n\n        if not (task.status == RUNNING and status == PENDING):\n            # don't allow re-scheduling of task while it is running, it must either fail or succeed first\n            if status == PENDING or status != task.status:\n                # Update the DB only if there was a acctual change, to prevent noise.\n                # We also check for status == PENDING b/c that's the default value\n                # (so checking for status != task.status woule lie)\n                self._update_task_history(task_id, status)\n            self._state.set_status(task, PENDING if status == SUSPENDED else status, self._config)\n            if status == FAILED:\n                task.retry = time.time() + self._config.retry_delay\n\n        if deps is not None:\n            task.deps = set(deps)\n\n        if new_deps is not None:\n            task.deps.update(new_deps)\n\n        task.stakeholders.add(worker)\n        task.resources = resources\n\n        # Task dependencies might not exist yet. Let's create dummy tasks for them for now.\n        # Otherwise the task dependencies might end up being pruned if scheduling takes a long time\n        for dep in task.deps or []:\n            t = self._state.get_task(dep, setdefault=self._make_task(task_id=dep, status=UNKNOWN, deps=None, priority=priority))\n            t.stakeholders.add(worker)\n\n        self._update_priority(task, priority, worker)\n\n        if runnable:\n            task.workers.add(worker)\n\n        if expl is not None:\n            task.expl = expl",
        "begin_line": 487,
        "end_line": 544,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011961722488038277,
            "pseudo_dstar_susp": 0.0011947431302270011,
            "pseudo_tarantula_susp": 0.00145985401459854,
            "pseudo_op2_susp": 0.0011947431302270011,
            "pseudo_barinel_susp": 0.00145985401459854
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.add_worker#546",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.add_worker(self, worker, info, **kwargs)",
        "snippet": "    def add_worker(self, worker, info, **kwargs):\n        self._state.get_worker(worker).add_info(info)",
        "begin_line": 546,
        "end_line": 547,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018214936247723133,
            "pseudo_dstar_susp": 0.002457002457002457,
            "pseudo_tarantula_susp": 0.002577319587628866,
            "pseudo_op2_susp": 0.002457002457002457,
            "pseudo_barinel_susp": 0.002577319587628866
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.update_resources#549",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.update_resources(self, **resources)",
        "snippet": "    def update_resources(self, **resources):\n        if self._resources is None:\n            self._resources = {}\n        self._resources.update(resources)",
        "begin_line": 549,
        "end_line": 552,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._has_resources#554",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._has_resources(self, needed_resources, used_resources)",
        "snippet": "    def _has_resources(self, needed_resources, used_resources):\n        if needed_resources is None:\n            return True\n\n        available_resources = self._resources or {}\n        for resource, amount in six.iteritems(needed_resources):\n            if amount + used_resources[resource] > available_resources.get(resource, 1):\n                return False\n        return True",
        "begin_line": 554,
        "end_line": 562,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011061946902654867,
            "pseudo_dstar_susp": 0.0011061946902654867,
            "pseudo_tarantula_susp": 0.0011061946902654867,
            "pseudo_op2_susp": 0.0011061946902654867,
            "pseudo_barinel_susp": 0.0011061946902654867
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._used_resources#564",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._used_resources(self)",
        "snippet": "    def _used_resources(self):\n        used_resources = collections.defaultdict(int)\n        if self._resources is not None:\n            for task in self._state.get_active_tasks():\n                if task.status == RUNNING and task.resources:\n                    for resource, amount in six.iteritems(task.resources):\n                        used_resources[resource] += amount\n        return used_resources",
        "begin_line": 564,
        "end_line": 571,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001394700139470014,
            "pseudo_dstar_susp": 0.002066115702479339,
            "pseudo_tarantula_susp": 0.001218026796589525,
            "pseudo_op2_susp": 0.002066115702479339,
            "pseudo_barinel_susp": 0.001218026796589525
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._rank#573",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._rank(self)",
        "snippet": "    def _rank(self):\n        \"\"\"\n        Return worker's rank function for task scheduling.\n\n        :return:\n        \"\"\"\n        dependents = collections.defaultdict(int)\n\n        def not_done(t):\n            task = self._state.get_task(t, default=None)\n            return task is None or task.status != DONE\n        for task in self._state.get_pending_tasks():\n            if task.status != DONE:\n                deps = list(filter(not_done, task.deps))\n                inverse_num_deps = 1.0 / max(len(deps), 1)\n                for dep in deps:\n                    dependents[dep] += inverse_num_deps\n\n        return lambda task: (task.priority, dependents[task.id], -task.time)",
        "begin_line": 573,
        "end_line": 591,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0019305019305019305,
            "pseudo_dstar_susp": 0.002,
            "pseudo_tarantula_susp": 0.00199203187250996,
            "pseudo_op2_susp": 0.002,
            "pseudo_barinel_susp": 0.00199203187250996
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.not_done#581",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.not_done(t)",
        "snippet": "        def not_done(t):\n            task = self._state.get_task(t, default=None)\n            return task is None or task.status != DONE",
        "begin_line": 581,
        "end_line": 583,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001394700139470014,
            "pseudo_dstar_susp": 0.002066115702479339,
            "pseudo_tarantula_susp": 0.001218026796589525,
            "pseudo_op2_susp": 0.002066115702479339,
            "pseudo_barinel_susp": 0.001218026796589525
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._schedulable#593",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._schedulable(self, task)",
        "snippet": "    def _schedulable(self, task):\n        if task.status != PENDING:\n            return False\n        for dep in task.deps:\n            dep_task = self._state.get_task(dep, default=None)\n            if dep_task is None or dep_task.status != DONE:\n                return False\n        return True",
        "begin_line": 593,
        "end_line": 600,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001076426264800861,
            "pseudo_dstar_susp": 0.001076426264800861,
            "pseudo_tarantula_susp": 0.001076426264800861,
            "pseudo_op2_susp": 0.001076426264800861,
            "pseudo_barinel_susp": 0.001076426264800861
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.get_work#602",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.get_work(self, worker, host=None, **kwargs)",
        "snippet": "    def get_work(self, worker, host=None, **kwargs):\n        # TODO: remove any expired nodes\n\n        # Algo: iterate over all nodes, find the highest priority node no dependencies and available\n        # resources.\n\n        # Resource checking looks both at currently available resources and at which resources would\n        # be available if all running tasks died and we rescheduled all workers greedily. We do both\n        # checks in order to prevent a worker with many low-priority tasks from starving other\n        # workers with higher priority tasks that share the same resources.\n\n        # TODO: remove tasks that can't be done, figure out if the worker has absolutely\n        # nothing it can wait for\n\n        # Return remaining tasks that have no FAILED descendents\n        self.update(worker, {'host': host})\n        best_task = None\n        best_task_id = None\n        locally_pending_tasks = 0\n        running_tasks = []\n\n        used_resources = self._used_resources()\n        greedy_resources = collections.defaultdict(int)\n        n_unique_pending = 0\n        greedy_workers = dict((worker.id, worker.info.get('workers', 1))\n                              for worker in self._state.get_active_workers())\n\n        tasks = list(self._state.get_pending_tasks())\n        tasks.sort(key=self._rank(), reverse=True)\n\n        for task in tasks:\n            if task.status == 'RUNNING' and worker in task.workers:\n                # Return a list of currently running tasks to the client,\n                # makes it easier to troubleshoot\n                other_worker = self._state.get_worker(task.worker_running)\n                more_info = {'task_id': task.id, 'worker': str(other_worker)}\n                if other_worker is not None:\n                    more_info.update(other_worker.info)\n                    running_tasks.append(more_info)\n\n            if task.status == PENDING and worker in task.workers:\n                locally_pending_tasks += 1\n                if len(task.workers) == 1:\n                    n_unique_pending += 1\n\n            if task.status == RUNNING and task.worker_running in greedy_workers:\n                greedy_workers[task.worker_running] -= 1\n                for resource, amount in six.iteritems((task.resources or {})):\n                    greedy_resources[resource] += amount\n\n            if not best_task and self._schedulable(task) and self._has_resources(task.resources, greedy_resources):\n                if worker in task.workers and self._has_resources(task.resources, used_resources):\n                    best_task = task\n                    best_task_id = task.id\n                else:\n                    for task_worker in task.workers:\n                        if greedy_workers.get(task_worker, 0) > 0:\n                            # use up a worker\n                            greedy_workers[task_worker] -= 1\n\n                            # keep track of the resources used in greedy scheduling\n                            for resource, amount in six.iteritems((task.resources or {})):\n                                greedy_resources[resource] += amount\n\n                            break\n\n        if best_task:\n            self._state.set_status(best_task, RUNNING, self._config)\n            best_task.worker_running = worker\n            best_task.time_running = time.time()\n            self._update_task_history(best_task.id, RUNNING, host=host)\n\n        return {'n_pending_tasks': locally_pending_tasks,\n                'n_unique_pending': n_unique_pending,\n                'task_id': best_task_id,\n                'running_tasks': running_tasks}",
        "begin_line": 602,
        "end_line": 677,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018214936247723133,
            "pseudo_dstar_susp": 0.002109704641350211,
            "pseudo_tarantula_susp": 0.002577319587628866,
            "pseudo_op2_susp": 0.002109704641350211,
            "pseudo_barinel_susp": 0.002577319587628866
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.ping#679",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.ping(self, worker, **kwargs)",
        "snippet": "    def ping(self, worker, **kwargs):\n        self.update(worker)",
        "begin_line": 679,
        "end_line": 680,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009345794392523364,
            "pseudo_dstar_susp": 0.01639344262295082,
            "pseudo_tarantula_susp": 0.004464285714285714,
            "pseudo_op2_susp": 0.01639344262295082,
            "pseudo_barinel_susp": 0.0045045045045045045
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._upstream_status#682",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._upstream_status(self, task_id, upstream_status_table)",
        "snippet": "    def _upstream_status(self, task_id, upstream_status_table):\n        if task_id in upstream_status_table:\n            return upstream_status_table[task_id]\n        elif self._state.has_task(task_id):\n            task_stack = [task_id]\n\n            while task_stack:\n                dep_id = task_stack.pop()\n                if self._state.has_task(dep_id):\n                    dep = self._state.get_task(dep_id)\n                    if dep_id not in upstream_status_table:\n                        if dep.status == PENDING and dep.deps:\n                            task_stack = task_stack + [dep_id] + list(dep.deps)\n                            upstream_status_table[dep_id] = ''  # will be updated postorder\n                        else:\n                            dep_status = STATUS_TO_UPSTREAM_MAP.get(dep.status, '')\n                            upstream_status_table[dep_id] = dep_status\n                    elif upstream_status_table[dep_id] == '' and dep.deps:\n                        # This is the postorder update step when we set the\n                        # status based on the previously calculated child elements\n                        upstream_status = [upstream_status_table.get(task_id, '') for task_id in dep.deps]\n                        upstream_status.append('')  # to handle empty list\n                        status = max(upstream_status, key=UPSTREAM_SEVERITY_KEY)\n                        upstream_status_table[dep_id] = status\n            return upstream_status_table[dep_id]",
        "begin_line": 682,
        "end_line": 706,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._serialize_task#708",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._serialize_task(self, task_id, include_deps=True)",
        "snippet": "    def _serialize_task(self, task_id, include_deps=True):\n        task = self._state.get_task(task_id)\n        ret = {\n            'deps': list(task.deps),\n            'status': task.status,\n            'workers': list(task.workers),\n            'worker_running': task.worker_running,\n            'time_running': getattr(task, \"time_running\", None),\n            'start_time': task.time,\n            'params': task.params,\n            'name': task.family,\n            'priority': task.priority,\n            'resources': task.resources,\n        }\n        if include_deps:\n            ret['deps'] = list(task.deps)\n        return ret",
        "begin_line": 708,
        "end_line": 724,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.graph#726",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.graph(self, **kwargs)",
        "snippet": "    def graph(self, **kwargs):\n        self.prune()\n        serialized = {}\n        for task in self._state.get_active_tasks():\n            serialized[task.id] = self._serialize_task(task.id)\n        return serialized",
        "begin_line": 726,
        "end_line": 731,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._recurse_deps#733",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._recurse_deps(self, task_id, serialized)",
        "snippet": "    def _recurse_deps(self, task_id, serialized):\n        if task_id not in serialized:\n            task = self._state.get_task(task_id)\n            if task is None or not task.family:\n                logger.warn('Missing task for id [%s]', task_id)\n\n                # try to infer family and params from task_id\n                try:\n                    family, _, param_str = task_id.rstrip(')').partition('(')\n                    params = dict(param.split('=') for param in param_str.split(', '))\n                except BaseException:\n                    family, params = '', {}\n                serialized[task_id] = {\n                    'deps': [],\n                    'status': UNKNOWN,\n                    'workers': [],\n                    'start_time': UNKNOWN,\n                    'params': params,\n                    'name': family,\n                    'priority': 0,\n                }\n            else:\n                serialized[task_id] = self._serialize_task(task_id)\n                for dep in task.deps:\n                    self._recurse_deps(dep, serialized)",
        "begin_line": 733,
        "end_line": 757,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.dep_graph#759",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.dep_graph(self, task_id, **kwargs)",
        "snippet": "    def dep_graph(self, task_id, **kwargs):\n        self.prune()\n        serialized = {}\n        if self._state.has_task(task_id):\n            self._recurse_deps(task_id, serialized)\n        return serialized",
        "begin_line": 759,
        "end_line": 764,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.task_list#766",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.task_list(self, status, upstream_status, limit=True, **kwargs)",
        "snippet": "    def task_list(self, status, upstream_status, limit=True, **kwargs):\n        \"\"\"\n        Query for a subset of tasks by status.\n        \"\"\"\n        self.prune()\n        result = {}\n        upstream_status_table = {}  # used to memoize upstream status\n        for task in self._state.get_active_tasks(status):\n            if (task.status != PENDING or not upstream_status or\n                    upstream_status == self._upstream_status(task.id, upstream_status_table)):\n                serialized = self._serialize_task(task.id, False)\n                result[task.id] = serialized\n        if limit and len(result) > self._config.max_shown_tasks:\n            return {'num_tasks': len(result)}\n        return result",
        "begin_line": 766,
        "end_line": 780,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.worker_list#782",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.worker_list(self, include_running=True, **kwargs)",
        "snippet": "    def worker_list(self, include_running=True, **kwargs):\n        self.prune()\n        workers = [\n            dict(\n                name=worker.id,\n                last_active=worker.last_active,\n                started=getattr(worker, 'started', None),\n                **worker.info\n            ) for worker in self._state.get_active_workers()]\n        workers.sort(key=lambda worker: worker['started'], reverse=True)\n        if include_running:\n            running = collections.defaultdict(dict)\n            num_pending = collections.defaultdict(int)\n            num_uniques = collections.defaultdict(int)\n            for task in self._state.get_pending_tasks():\n                if task.status == RUNNING and task.worker_running:\n                    running[task.worker_running][task.id] = self._serialize_task(task.id, False)\n                elif task.status == PENDING:\n                    for worker in task.workers:\n                        num_pending[worker] += 1\n                    if len(task.workers) == 1:\n                        num_uniques[list(task.workers)[0]] += 1\n            for worker in workers:\n                tasks = running[worker['name']]\n                worker['num_running'] = len(tasks)\n                worker['num_pending'] = num_pending[worker['name']]\n                worker['num_uniques'] = num_uniques[worker['name']]\n                worker['running'] = tasks\n        return workers",
        "begin_line": 782,
        "end_line": 810,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.inverse_dep_graph#812",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.inverse_dep_graph(self, task_id, **kwargs)",
        "snippet": "    def inverse_dep_graph(self, task_id, **kwargs):\n        self.prune()\n        serialized = {}\n        if self._state.has_task(task_id):\n            self._traverse_inverse_deps(task_id, serialized)\n        return serialized",
        "begin_line": 812,
        "end_line": 817,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._traverse_inverse_deps#819",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._traverse_inverse_deps(self, task_id, serialized)",
        "snippet": "    def _traverse_inverse_deps(self, task_id, serialized):\n        stack = [task_id]\n        serialized[task_id] = self._serialize_task(task_id)\n        while len(stack) > 0:\n            curr_id = stack.pop()\n            for task in self._state.get_active_tasks():\n                if curr_id in task.deps:\n                    serialized[curr_id][\"deps\"].append(task.id)\n                    if task.id not in serialized:\n                        serialized[task.id] = self._serialize_task(task.id)\n                        serialized[task.id][\"deps\"] = []\n                        stack.append(task.id)",
        "begin_line": 819,
        "end_line": 830,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.task_search#832",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.task_search(self, task_str, **kwargs)",
        "snippet": "    def task_search(self, task_str, **kwargs):\n        \"\"\"\n        Query for a subset of tasks by task_id.\n\n        :param task_str:\n        :return:\n        \"\"\"\n        self.prune()\n        result = collections.defaultdict(dict)\n        for task in self._state.get_active_tasks():\n            if task.id.find(task_str) != -1:\n                serialized = self._serialize_task(task.id, False)\n                result[task.status][task.id] = serialized\n        return result",
        "begin_line": 832,
        "end_line": 845,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.re_enable_task#847",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.re_enable_task(self, task_id)",
        "snippet": "    def re_enable_task(self, task_id):\n        serialized = {}\n        task = self._state.get_task(task_id)\n        if task and task.status == DISABLED and task.scheduler_disable_time:\n            self._state.re_enable(task, self._config)\n            serialized = self._serialize_task(task_id)\n        return serialized",
        "begin_line": 847,
        "end_line": 853,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.fetch_error#855",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.fetch_error(self, task_id, **kwargs)",
        "snippet": "    def fetch_error(self, task_id, **kwargs):\n        if self._state.has_task(task_id):\n            return {\"taskId\": task_id, \"error\": self._state.get_task(task_id).expl}\n        else:\n            return {\"taskId\": task_id, \"error\": \"\"}",
        "begin_line": 855,
        "end_line": 859,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._update_task_history#861",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._update_task_history(self, task_id, status, host=None)",
        "snippet": "    def _update_task_history(self, task_id, status, host=None):\n        try:\n            if status == DONE or status == FAILED:\n                successful = (status == DONE)\n                self._task_history.task_finished(task_id, successful)\n            elif status == PENDING:\n                self._task_history.task_scheduled(task_id)\n            elif status == RUNNING:\n                self._task_history.task_started(task_id, host)\n        except BaseException:\n            logger.warning(\"Error saving Task history\", exc_info=True)",
        "begin_line": 861,
        "end_line": 871,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011961722488038277,
            "pseudo_dstar_susp": 0.0011947431302270011,
            "pseudo_tarantula_susp": 0.00145985401459854,
            "pseudo_op2_susp": 0.0011947431302270011,
            "pseudo_barinel_susp": 0.00145985401459854
        }
    },
    {
        "name": "luigi.tools.range.RangeBase._format_datetime#151",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeBase",
        "signature": "luigi.tools.range.RangeBase._format_datetime(self, dt)",
        "snippet": "    def _format_datetime(self, dt):\n        return self.datetime_to_parameter(dt)",
        "begin_line": 151,
        "end_line": 152,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005070993914807302,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.tools.range.RangeBase.requires#159",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeBase",
        "signature": "luigi.tools.range.RangeBase.requires(self)",
        "snippet": "    def requires(self):\n        # cache because we anticipate a fair amount of computation\n        if hasattr(self, '_cached_requires'):\n            return self._cached_requires\n\n        if not self.start and not self.stop:\n            raise ParameterException(\"At least one of start and stop needs to be specified\")\n        if not self.start and not self.reverse:\n            raise ParameterException(\"Either start needs to be specified or reverse needs to be True\")\n        if self.start and self.stop and self.start > self.stop:\n            raise ParameterException(\"Can't have start > stop\")\n        # TODO check overridden complete() and exists()\n\n        now = datetime.utcfromtimestamp(time.time() if self.now is None else self.now)\n\n        moving_start = self.moving_start(now)\n        finite_start = moving_start if self.start is None else max(self.parameter_to_datetime(self.start), moving_start)\n        moving_stop = self.moving_stop(now)\n        finite_stop = moving_stop if self.stop is None else min(self.parameter_to_datetime(self.stop), moving_stop)\n\n        datetimes = self.finite_datetimes(finite_start, finite_stop) if finite_start <= finite_stop else []\n\n        task_cls = Register.get_task_cls(self.of)\n        if datetimes:\n            logger.debug('Actually checking if range %s of %s is complete',\n                         self._format_range(datetimes), self.of)\n            missing_datetimes = sorted(self.missing_datetimes(task_cls, datetimes))\n            logger.debug('Range %s lacked %d of expected %d %s instances',\n                         self._format_range(datetimes), len(missing_datetimes), len(datetimes), self.of)\n        else:\n            missing_datetimes = []\n            logger.debug('Empty range. No %s instances expected', self.of)\n\n        self._emit_metrics(missing_datetimes, finite_start, finite_stop)\n\n        if self.reverse:\n            required_datetimes = missing_datetimes[-self.task_limit:]\n        else:\n            required_datetimes = missing_datetimes[:self.task_limit]\n        if required_datetimes:\n            logger.debug('Requiring %d missing %s instances in range %s',\n                         len(required_datetimes), self.of, self._format_range(required_datetimes))\n        if self.reverse:\n            required_datetimes.reverse()  # TODO priorities, so that within the batch tasks are ordered too\n\n        self._cached_requires = [task_cls(self.datetime_to_parameter(d)) for d in required_datetimes]\n        return self._cached_requires",
        "begin_line": 159,
        "end_line": 205,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005488474204171241,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.tools.range.RangeDailyBase.datetime_to_parameter#237",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeDailyBase",
        "signature": "luigi.tools.range.RangeDailyBase.datetime_to_parameter(self, dt)",
        "snippet": "    def datetime_to_parameter(self, dt):\n        return dt.date()",
        "begin_line": 237,
        "end_line": 238,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.tools.range.RangeDailyBase.parameter_to_datetime#240",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeDailyBase",
        "signature": "luigi.tools.range.RangeDailyBase.parameter_to_datetime(self, p)",
        "snippet": "    def parameter_to_datetime(self, p):\n        return datetime(p.year, p.month, p.day)",
        "begin_line": 240,
        "end_line": 241,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.tools.range.RangeDailyBase.moving_start#243",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeDailyBase",
        "signature": "luigi.tools.range.RangeDailyBase.moving_start(self, now)",
        "snippet": "    def moving_start(self, now):\n        return now - timedelta(days=self.days_back)",
        "begin_line": 243,
        "end_line": 244,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.tools.range.RangeDailyBase.moving_stop#246",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeDailyBase",
        "signature": "luigi.tools.range.RangeDailyBase.moving_stop(self, now)",
        "snippet": "    def moving_stop(self, now):\n        return now + timedelta(days=self.days_forward)",
        "begin_line": 246,
        "end_line": 247,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.tools.range.RangeDailyBase.finite_datetimes#249",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeDailyBase",
        "signature": "luigi.tools.range.RangeDailyBase.finite_datetimes(self, finite_start, finite_stop)",
        "snippet": "    def finite_datetimes(self, finite_start, finite_stop):\n        \"\"\"\n        Simply returns the points in time that correspond to turn of day.\n        \"\"\"\n        date_start = datetime(finite_start.year, finite_start.month, finite_start.day)\n        dates = []\n        for i in itertools.count():\n            t = date_start + timedelta(days=i)\n            if t >= finite_stop:\n                return dates\n            if t >= finite_start:\n                dates.append(t)",
        "begin_line": 249,
        "end_line": 260,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase.datetime_to_parameter#281",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase.datetime_to_parameter(self, dt)",
        "snippet": "    def datetime_to_parameter(self, dt):\n        return dt",
        "begin_line": 281,
        "end_line": 282,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase.parameter_to_datetime#284",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase.parameter_to_datetime(self, p)",
        "snippet": "    def parameter_to_datetime(self, p):\n        return p",
        "begin_line": 284,
        "end_line": 285,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase.moving_start#287",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase.moving_start(self, now)",
        "snippet": "    def moving_start(self, now):\n        return now - timedelta(hours=self.hours_back)",
        "begin_line": 287,
        "end_line": 288,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase.moving_stop#290",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase.moving_stop(self, now)",
        "snippet": "    def moving_stop(self, now):\n        return now + timedelta(hours=self.hours_forward)",
        "begin_line": 290,
        "end_line": 291,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase.finite_datetimes#293",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase.finite_datetimes(self, finite_start, finite_stop)",
        "snippet": "    def finite_datetimes(self, finite_start, finite_stop):\n        \"\"\"\n        Simply returns the points in time that correspond to whole hours.\n        \"\"\"\n        datehour_start = datetime(finite_start.year, finite_start.month, finite_start.day, finite_start.hour)\n        datehours = []\n        for i in itertools.count():\n            t = datehour_start + timedelta(hours=i)\n            if t >= finite_stop:\n                return datehours\n            if t >= finite_start:\n                datehours.append(t)",
        "begin_line": 293,
        "end_line": 304,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005379236148466917,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase._format_datetime#306",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase._format_datetime(self, dt)",
        "snippet": "    def _format_datetime(self, dt):\n        return luigi.DateHourParameter().serialize(dt)",
        "begin_line": 306,
        "end_line": 307,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.tools.range._constrain_glob#310",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range._constrain_glob(glob, paths, limit=5)",
        "snippet": "def _constrain_glob(glob, paths, limit=5):\n    \"\"\"\n    Tweaks glob into a list of more specific globs that together still cover paths and not too much extra.\n\n    Saves us minutes long listings for long dataset histories.\n\n    Specifically, in this implementation the leftmost occurrences of \"[0-9]\"\n    give rise to a few separate globs that each specialize the expression to\n    digits that actually occur in paths.\n    \"\"\"\n\n    def digit_set_wildcard(chars):\n        \"\"\"\n        Makes a wildcard expression for the set, a bit readable, e.g. [1-5].\n        \"\"\"\n        chars = sorted(chars)\n        if len(chars) > 1 and ord(chars[-1]) - ord(chars[0]) == len(chars) - 1:\n            return '[%s-%s]' % (chars[0], chars[-1])\n        else:\n            return '[%s]' % ''.join(chars)\n\n    current = {glob: paths}\n    while True:\n        pos = list(current.keys())[0].find('[0-9]')\n        if pos == -1:\n            # no wildcard expressions left to specialize in the glob\n            return list(current.keys())\n        char_sets = {}\n        for g, p in six.iteritems(current):\n            char_sets[g] = sorted(set(path[pos] for path in p))\n        if sum(len(s) for s in char_sets.values()) > limit:\n            return [g.replace('[0-9]', digit_set_wildcard(char_sets[g]), 1) for g in current]\n        for g, s in six.iteritems(char_sets):\n            for c in s:\n                new_glob = g.replace('[0-9]', c, 1)\n                new_paths = list(filter(lambda p: p[pos] == c, current[g]))\n                current[new_glob] = new_paths\n            del current[g]",
        "begin_line": 310,
        "end_line": 347,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.tools.range.digit_set_wildcard#321",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range.digit_set_wildcard(chars)",
        "snippet": "    def digit_set_wildcard(chars):\n        \"\"\"\n        Makes a wildcard expression for the set, a bit readable, e.g. [1-5].\n        \"\"\"\n        chars = sorted(chars)\n        if len(chars) > 1 and ord(chars[-1]) - ord(chars[0]) == len(chars) - 1:\n            return '[%s-%s]' % (chars[0], chars[-1])\n        else:\n            return '[%s]' % ''.join(chars)",
        "begin_line": 321,
        "end_line": 329,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.tools.range.most_common#350",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range.most_common(items)",
        "snippet": "def most_common(items):\n    \"\"\"\n    Wanted functionality from Counters (new in Python 2.7).\n    \"\"\"\n    counts = {}\n    for i in items:\n        counts.setdefault(i, 0)\n        counts[i] += 1\n    return max(six.iteritems(counts), key=operator.itemgetter(1))",
        "begin_line": 350,
        "end_line": 358,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.tools.range._get_per_location_glob#361",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range._get_per_location_glob(tasks, outputs, regexes)",
        "snippet": "def _get_per_location_glob(tasks, outputs, regexes):\n    \"\"\"\n    Builds a glob listing existing output paths.\n\n    Esoteric reverse engineering, but worth it given that (compared to an\n    equivalent contiguousness guarantee by naive complete() checks)\n    requests to the filesystem are cut by orders of magnitude, and users\n    don't even have to retrofit existing tasks anyhow.\n    \"\"\"\n    paths = [o.path for o in outputs]\n    matches = [r.search(p) for r, p in zip(regexes, paths)]  # naive, because some matches could be confused by numbers earlier in path, e.g. /foo/fifa2000k/bar/2000-12-31/00\n\n    for m, p, t in zip(matches, paths, tasks):\n        if m is None:\n            raise NotImplementedError(\"Couldn't deduce datehour representation in output path %r of task %s\" % (p, t))\n\n    positions = [most_common((m.start(i), m.end(i)) for m in matches)[0] for i in range(1, 5)]  # the most common position of every group is likely to be conclusive hit or miss\n\n    glob = list(paths[0])  # TODO sanity check that it's the same for all paths?\n    for start, end in positions:\n        glob = glob[:start] + ['[0-9]'] * (end - start) + glob[end:]\n    return ''.join(glob).rsplit('/', 1)[0]  # chop off the last path item (wouldn't need to if `hadoop fs -ls -d` equivalent were available)",
        "begin_line": 361,
        "end_line": 382,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.tools.range._get_filesystems_and_globs#385",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range._get_filesystems_and_globs(task_cls)",
        "snippet": "def _get_filesystems_and_globs(task_cls):\n    \"\"\"\n    Yields a (filesystem, glob) tuple per every output location of task_cls.\n\n    task_cls can have one or several FileSystemTarget outputs.\n\n    For convenience, task_cls can be a wrapper task,\n    in which case outputs of all its dependencies are considered.\n    \"\"\"\n    # probe some scattered datehours unlikely to all occur in paths, other than by being sincere datehour parameter's representations\n    # TODO limit to [self.start, self.stop) so messages are less confusing? Done trivially it can kill correctness\n    sample_datehours = [datetime(y, m, d, h) for y in range(2000, 2050, 10) for m in range(1, 4) for d in range(5, 8) for h in range(21, 24)]\n    regexes = [re.compile('(%04d).*(%02d).*(%02d).*(%02d)' % (d.year, d.month, d.day, d.hour)) for d in sample_datehours]\n    sample_tasks = [task_cls(d) for d in sample_datehours]\n    sample_outputs = [flatten_output(t) for t in sample_tasks]\n\n    for o, t in zip(sample_outputs, sample_tasks):\n        if len(o) != len(sample_outputs[0]):\n            raise NotImplementedError(\"Outputs must be consistent over time, sorry; was %r for %r and %r for %r\" % (o, t, sample_outputs[0], sample_tasks[0]))\n            # TODO fall back on requiring last couple of days? to avoid astonishing blocking when changes like that are deployed\n            # erm, actually it's not hard to test entire hours_back..hours_forward and split into consistent subranges FIXME?\n        for target in o:\n            if not isinstance(target, FileSystemTarget):\n                raise NotImplementedError(\"Output targets must be instances of FileSystemTarget; was %r for %r\" % (target, t))\n\n    for o in zip(*sample_outputs):  # transposed, so here we're iterating over logical outputs, not datehours\n        glob = _get_per_location_glob(sample_tasks, o, regexes)\n        yield o[0].fs, glob",
        "begin_line": 385,
        "end_line": 412,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.tools.range._list_existing#415",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range._list_existing(filesystem, glob, paths)",
        "snippet": "def _list_existing(filesystem, glob, paths):\n    \"\"\"\n    Get all the paths that do in fact exist. Returns a set of all existing paths.\n\n    Takes a luigi.target.FileSystem object, a str which represents a glob and\n    a list of strings representing paths.\n    \"\"\"\n    globs = _constrain_glob(glob, paths)\n    time_start = time.time()\n    listing = []\n    for g in sorted(globs):\n        logger.debug('Listing %s', g)\n        if filesystem.exists(g):\n            listing.extend(filesystem.listdir(g))\n    logger.debug('%d %s listings took %f s to return %d items',\n                 len(globs), filesystem.__class__.__name__, time.time() - time_start, len(listing))\n    return set(listing)",
        "begin_line": 415,
        "end_line": 431,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.tools.range.infer_bulk_complete_from_fs#434",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range.infer_bulk_complete_from_fs(task_cls, finite_datehours)",
        "snippet": "def infer_bulk_complete_from_fs(task_cls, finite_datehours):\n    \"\"\"\n    Efficiently determines missing datehours by filesystem listing.\n\n    The current implementation works for the common case of a task writing\n    output to a FileSystemTarget whose path is built using strftime with format\n    like '...%Y...%m...%d...%H...', without custom complete() or exists().\n\n    (Eventually Luigi could have ranges of completion as first-class citizens.\n    Then this listing business could be factored away/be provided for\n    explicitly in target API or some kind of a history server.)\n\n    TODO support RangeDaily\n    \"\"\"\n    filesystems_and_globs_by_location = _get_filesystems_and_globs(task_cls)\n    paths_by_datehour = [[o.path for o in flatten_output(task_cls(d))] for d in finite_datehours]\n    listing = set()\n    for (f, g), p in zip(filesystems_and_globs_by_location, zip(*paths_by_datehour)):  # transposed, so here we're iterating over logical outputs, not datehours\n        listing |= _list_existing(f, g, p)\n\n    # quickly learn everything that's missing\n    missing_datehours = []\n    for d, p in zip(finite_datehours, paths_by_datehour):\n        if not set(p) <= listing:\n            missing_datehours.append(d)\n\n    return missing_datehours",
        "begin_line": 434,
        "end_line": 460,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.tools.range.RangeDaily.missing_datetimes#478",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeDaily",
        "signature": "luigi.tools.range.RangeDaily.missing_datetimes(self, task_cls, finite_datetimes)",
        "snippet": "    def missing_datetimes(self, task_cls, finite_datetimes):\n        return set(finite_datetimes) - set(map(self.parameter_to_datetime, task_cls.bulk_complete(list(map(self.datetime_to_parameter, finite_datetimes)))))",
        "begin_line": 478,
        "end_line": 479,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.tools.range.RangeHourly.missing_datetimes#497",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourly",
        "signature": "luigi.tools.range.RangeHourly.missing_datetimes(self, task_cls, finite_datetimes)",
        "snippet": "    def missing_datetimes(self, task_cls, finite_datetimes):\n        try:\n            return set(finite_datetimes) - set(map(self.parameter_to_datetime, task_cls.bulk_complete(list(map(self.datetime_to_parameter, finite_datetimes)))))\n        except NotImplementedError:\n            return infer_bulk_complete_from_fs(task_cls, finite_datetimes)",
        "begin_line": 497,
        "end_line": 501,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.util.common_params#34",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util",
        "signature": "luigi.util.common_params(task_instance, task_cls)",
        "snippet": "def common_params(task_instance, task_cls):\n    \"\"\"\n    Grab all the values in task_instance that are found in task_cls.\n    \"\"\"\n    if not isinstance(task_cls, task.Register):\n        raise TypeError(\"task_cls must be an uninstantiated Task\")\n\n    task_instance_param_names = dict(task_instance.get_params()).keys()\n    task_cls_param_names = dict(task_cls.get_params()).keys()\n    common_param_names = list(set.intersection(set(task_instance_param_names), set(task_cls_param_names)))\n    common_param_vals = [(key, dict(task_cls.get_params())[key]) for key in common_param_names]\n    common_kwargs = dict([(key, task_instance.param_kwargs[key]) for key in common_param_names])\n    vals = dict(task_instance.get_param_values(common_param_vals, [], common_kwargs))\n    return vals",
        "begin_line": 34,
        "end_line": 47,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.util.Wrapped.requires#116",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util.Wrapped",
        "signature": "luigi.util.Wrapped.requires(_self)",
        "snippet": "            def requires(_self):\n                return _self.clone_parent()",
        "begin_line": 116,
        "end_line": 117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.util.Wrapped.run#147",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util.Wrapped",
        "signature": "luigi.util.Wrapped.run(_self)",
        "snippet": "            def run(_self):\n                i, o = _self.input(), _self.output()\n                f = o.open('w')  # TODO: assert that i, o are Target objects and not complex datastructures\n                for line in i.open('r'):\n                    f.write(line)\n                f.close()",
        "begin_line": 147,
        "end_line": 152,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.util.previous#199",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util",
        "signature": "luigi.util.previous(task)",
        "snippet": "def previous(task):\n    \"\"\"\n    Return a previous Task of the same family.\n\n    By default checks if this task family only has one non-global parameter and if\n    it is a DateParameter, DateHourParameter or DateIntervalParameter in which case\n    it returns with the time decremented by 1 (hour, day or interval)\n    \"\"\"\n    params = task.get_params()\n    previous_params = {}\n    previous_date_params = {}\n\n    for param_name, param_obj in params:\n        param_value = getattr(task, param_name)\n\n        if isinstance(param_obj, parameter.DateParameter):\n            previous_date_params[param_name] = param_value - datetime.timedelta(days=1)\n        elif isinstance(param_obj, parameter.DateMinuteParameter):\n            previous_date_params[param_name] = param_value - datetime.timedelta(minutes=1)\n        elif isinstance(param_obj, parameter.DateHourParameter):\n            previous_date_params[param_name] = param_value - datetime.timedelta(hours=1)\n        elif isinstance(param_obj, parameter.DateIntervalParameter):\n            previous_date_params[param_name] = param_value.prev()\n        else:\n            previous_params[param_name] = param_value\n\n    previous_params.update(previous_date_params)\n\n    if len(previous_date_params) == 0:\n        raise NotImplementedError(\"No task parameter - can't determine previous task\")\n    elif len(previous_date_params) > 1:\n        raise NotImplementedError(\"Too many date-related task parameters - can't determine previous task\")\n    else:\n        return task.clone(**previous_params)",
        "begin_line": 199,
        "end_line": 232,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.util.get_previous_completed#235",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util",
        "signature": "luigi.util.get_previous_completed(task, max_steps=10)",
        "snippet": "def get_previous_completed(task, max_steps=10):\n    prev = task\n    for _ in xrange(max_steps):\n        prev = previous(prev)\n        logger.debug(\"Checking if %s is complete\", prev.task_id)\n        if prev.complete():\n            return prev\n    return None",
        "begin_line": 235,
        "end_line": 242,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "bin.luigid.main#11",
        "src_path": "bin/luigid",
        "class_name": "bin.luigid",
        "signature": "bin.luigid.main(argv)",
        "snippet": "def main(argv):\n    parser = optparse.OptionParser()\n    parser.add_option(u'--background', help=u'Run in background mode', action='store_true')\n    parser.add_option(u'--pidfile', help=u'Write pidfile')\n    parser.add_option(u'--logdir', help=u'log directory')\n    parser.add_option(u'--state-path', help=u'Pickled state file')\n    parser.add_option(u'--address', help=u'Listening interface')\n    parser.add_option(u'--port', default=8082, help=u'Listening port')\n        \n    opts, args = parser.parse_args(argv)\n\n    if opts.state_path:\n        config = luigi.configuration.get_config()\n        config.set('scheduler', 'state-path', opts.state_path)\n\n    if opts.background:\n        # daemonize sets up logging to spooled log files\n        logging.getLogger().setLevel(logging.INFO)\n        luigi.process.daemonize(luigi.server.run, api_port=opts.port,\n                                address=opts.address, pidfile=opts.pidfile,\n                                logdir=opts.logdir)\n    else:\n        if opts.logdir:\n            logging.basicConfig(level=logging.INFO, format=luigi.process.get_log_format(), filename=os.path.join(opts.logdir, \"luigi-server.log\"))\n        else:\n            logging.basicConfig(level=logging.INFO, format=luigi.process.get_log_format())\n        luigi.server.run(api_port=opts.port, address=opts.address)",
        "begin_line": 11,
        "end_line": 37,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.05555555555555555,
            "pseudo_dstar_susp": 0.005847953216374269,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.005847953216374269,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.contrib.ssh.RemoteContext.__init__#51",
        "src_path": "luigi/contrib/ssh.py",
        "class_name": "luigi.contrib.ssh.RemoteContext",
        "signature": "luigi.contrib.ssh.RemoteContext.__init__(self, host, username=None, key_file=None, connect_timeout=None)",
        "snippet": "    def __init__(self, host, username=None, key_file=None, connect_timeout=None):\n        self.host = host\n        self.username = username\n        self.key_file = key_file\n        self.connect_timeout = connect_timeout",
        "begin_line": 51,
        "end_line": 55,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.ssh.RemoteContext._host_ref#67",
        "src_path": "luigi/contrib/ssh.py",
        "class_name": "luigi.contrib.ssh.RemoteContext",
        "signature": "luigi.contrib.ssh.RemoteContext._host_ref(self)",
        "snippet": "    def _host_ref(self):\n        if self.username:\n            return \"{0}@{1}\".format(self.username, self.host)\n        else:\n            return self.host",
        "begin_line": 67,
        "end_line": 71,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.ssh.RemoteContext._prepare_cmd#73",
        "src_path": "luigi/contrib/ssh.py",
        "class_name": "luigi.contrib.ssh.RemoteContext",
        "signature": "luigi.contrib.ssh.RemoteContext._prepare_cmd(self, cmd)",
        "snippet": "    def _prepare_cmd(self, cmd):\n        connection_cmd = [\"ssh\", self._host_ref(),\n                          \"-S\", \"none\",  # disable ControlMaster since it causes all sorts of weird behaviour with subprocesses...\n                          \"-o\", \"BatchMode=yes\",  # no password prompts etc\n                          ]\n\n        if self.connect_timeout is not None:\n            connection_cmd += ['-o', 'ConnectTimeout=%d' % self.connect_timeout]\n\n        if self.key_file:\n            connection_cmd.extend([\"-i\", self.key_file])\n        return connection_cmd + cmd",
        "begin_line": 73,
        "end_line": 84,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.ssh.RemoteContext.Popen#86",
        "src_path": "luigi/contrib/ssh.py",
        "class_name": "luigi.contrib.ssh.RemoteContext",
        "signature": "luigi.contrib.ssh.RemoteContext.Popen(self, cmd, **kwargs)",
        "snippet": "    def Popen(self, cmd, **kwargs):\n        \"\"\"\n        Remote Popen.\n        \"\"\"\n        prefixed_cmd = self._prepare_cmd(cmd)\n        return subprocess.Popen(prefixed_cmd, **kwargs)",
        "begin_line": 86,
        "end_line": 91,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.ssh.RemoteContext.check_output#93",
        "src_path": "luigi/contrib/ssh.py",
        "class_name": "luigi.contrib.ssh.RemoteContext",
        "signature": "luigi.contrib.ssh.RemoteContext.check_output(self, cmd)",
        "snippet": "    def check_output(self, cmd):\n        \"\"\"\n        Execute a shell command remotely and return the output.\n\n        Simplified version of Popen when you only want the output as a string and detect any errors.\n        \"\"\"\n        p = self.Popen(cmd, stdout=subprocess.PIPE)\n        output, _ = p.communicate()\n        if p.returncode != 0:\n            raise subprocess.CalledProcessError(p.returncode, cmd)\n        return output",
        "begin_line": 93,
        "end_line": 103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.deprecate_kwarg.new_function#42",
        "src_path": "luigi/deprecate_kwarg.py",
        "class_name": "luigi.deprecate_kwarg",
        "signature": "luigi.deprecate_kwarg.new_function(*args, **kwargs)",
        "snippet": "        def new_function(*args, **kwargs):\n            value = kw_value\n            if old_name in kwargs:\n                warnings.warn('Keyword argument {0} is deprecated, use {1}'\n                              .format(old_name, new_name))\n                value = kwargs[old_name]\n            if new_name in kwargs:\n                value = kwargs[new_name]\n                del kwargs[new_name]\n            kwargs[old_name] = value\n            return function(*args, **kwargs)",
        "begin_line": 42,
        "end_line": 52,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002325581395348837,
            "pseudo_dstar_susp": 0.005263157894736842,
            "pseudo_tarantula_susp": 0.0019801980198019802,
            "pseudo_op2_susp": 0.005263157894736842,
            "pseudo_barinel_susp": 0.0019801980198019802
        }
    },
    {
        "name": "luigi.hdfs.get_configured_hadoop_version#599",
        "src_path": "luigi/hdfs.py",
        "class_name": "luigi.hdfs",
        "signature": "luigi.hdfs.get_configured_hadoop_version()",
        "snippet": "def get_configured_hadoop_version():\n    \"\"\"\n    CDH4 (hadoop 2+) has a slightly different syntax for interacting with hdfs\n    via the command line.\n\n    The default version is CDH4, but one can override\n    this setting with \"cdh3\" or \"apache1\" in the hadoop section of the config\n    in order to use the old syntax.\n    \"\"\"\n    return luigi.configuration.get_config().get(\"hadoop\", \"version\", \"cdh4\").lower()",
        "begin_line": 599,
        "end_line": 608,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hdfs.get_configured_hdfs_client#611",
        "src_path": "luigi/hdfs.py",
        "class_name": "luigi.hdfs",
        "signature": "luigi.hdfs.get_configured_hdfs_client(show_warnings=True)",
        "snippet": "def get_configured_hdfs_client(show_warnings=True):\n    \"\"\"\n    This is a helper that fetches the configuration value for 'client' in\n    the [hdfs] section. It will return the client that retains backwards\n    compatibility when 'client' isn't configured.\n    \"\"\"\n    config = hdfs()\n    custom = config.client\n    if six.PY3 and (custom == \"snakebite\" or config.use_snakebite):\n        if show_warnings:\n            warnings.warn(\n                \"snakebite client not compatible with python3 at the moment\"\n                \"falling back on hadoopcli\",\n                stacklevle=2\n            )\n        return \"hadoopcli\"\n    if custom:\n        # Eventually this should be the only valid code path\n        return custom\n    if config.use_snakebite:\n        if show_warnings:\n            warnings.warn(\"Deprecated: Just specify 'client: snakebite' in config\")\n        return \"snakebite\"\n    if show_warnings:\n        warnings.warn(\"Deprecated: Specify 'client: hadoopcli' in config\")\n    return \"hadoopcli\"  # The old default when not specified",
        "begin_line": 611,
        "end_line": 636,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hdfs.create_hadoopcli_client#639",
        "src_path": "luigi/hdfs.py",
        "class_name": "luigi.hdfs",
        "signature": "luigi.hdfs.create_hadoopcli_client()",
        "snippet": "def create_hadoopcli_client():\n    \"\"\"\n    Given that we want one of the hadoop cli clients (unlike snakebite),\n    this one will return the right one.\n    \"\"\"\n    version = get_configured_hadoop_version()\n    if version == \"cdh4\":\n        return HdfsClient()\n    elif version == \"cdh3\":\n        return HdfsClientCdh3()\n    elif version == \"apache1\":\n        return HdfsClientApache1()\n    else:\n        raise Exception(\"Error: Unknown version specified in Hadoop version\"\n                        \"configuration parameter\")",
        "begin_line": 639,
        "end_line": 653,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hdfs.get_autoconfig_client#656",
        "src_path": "luigi/hdfs.py",
        "class_name": "luigi.hdfs",
        "signature": "luigi.hdfs.get_autoconfig_client(show_warnings=True)",
        "snippet": "def get_autoconfig_client(show_warnings=True):\n    \"\"\"\n    Creates the client as specified in the `client.cfg` configuration.\n    \"\"\"\n    configured_client = get_configured_hdfs_client(show_warnings=show_warnings)\n    if configured_client == \"snakebite\":\n        return SnakebiteHdfsClient()\n    if configured_client == \"snakebite_with_hadoopcli_fallback\":\n        return luigi.contrib.target.CascadingClient([SnakebiteHdfsClient(),\n                                                     create_hadoopcli_client()])\n    if configured_client == \"hadoopcli\":\n        return create_hadoopcli_client()\n    raise Exception(\"Unknown hdfs client \" + get_configured_hdfs_client())",
        "begin_line": 656,
        "end_line": 668,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hdfs.HdfsTarget.__init__#763",
        "src_path": "luigi/hdfs.py",
        "class_name": "luigi.hdfs.HdfsTarget",
        "signature": "luigi.hdfs.HdfsTarget.__init__(self, path=None, format=Plain, is_tmp=False, fs=None)",
        "snippet": "    def __init__(self, path=None, format=Plain, is_tmp=False, fs=None):\n        if path is None:\n            assert is_tmp\n            path = tmppath()\n        super(HdfsTarget, self).__init__(path)\n        self.format = format\n        self.is_tmp = is_tmp\n        (scheme, netloc, path, query, fragment) = urlsplit(path)\n        if \":\" in path:\n            raise ValueError('colon is not allowed in hdfs filenames')\n        self._fs = fs or get_autoconfig_client()",
        "begin_line": 763,
        "end_line": 773,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.hdfs.HdfsTarget.__del__#775",
        "src_path": "luigi/hdfs.py",
        "class_name": "luigi.hdfs.HdfsTarget",
        "signature": "luigi.hdfs.HdfsTarget.__del__(self)",
        "snippet": "    def __del__(self):\n        # TODO: not sure is_tmp belongs in Targets construction arguments\n        if self.is_tmp and self.exists():\n            self.remove()",
        "begin_line": 775,
        "end_line": 778,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.contrib.esindex.ElasticsearchTarget.__init__#114",
        "src_path": "luigi/contrib/esindex.py",
        "class_name": "luigi.contrib.esindex.ElasticsearchTarget",
        "signature": "luigi.contrib.esindex.ElasticsearchTarget.__init__(self, host, port, index, doc_type, update_id, marker_index_hist_size=0, http_auth=None)",
        "snippet": "    def __init__(self, host, port, index, doc_type, update_id,\n                 marker_index_hist_size=0, http_auth=None):\n        \"\"\"\n        :param host: Elasticsearch server host\n        :type host: str\n        :param port: Elasticsearch server port\n        :type port: int\n        :param index: index name\n        :type index: str\n        :param doc_type: doctype name\n        :type doc_type: str\n        :param update_id: an identifier for this data set\n        :type update_id: str\n        :param marker_index_hist_size: list of changes to the index to remember\n        :type marker_index_hist_size: int\n        \"\"\"\n        self.host = host\n        self.port = port\n        self.http_auth = http_auth\n        self.index = index\n        self.doc_type = doc_type\n        self.update_id = update_id\n        self.marker_index_hist_size = marker_index_hist_size\n\n        self.es = elasticsearch.Elasticsearch(\n            connection_class=Urllib3HttpConnection,\n            host=self.host,\n            port=self.port,\n            http_auth=self.http_auth\n        )",
        "begin_line": 114,
        "end_line": 143,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.0028328611898017,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.0028328611898017,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.contrib.esindex.ElasticsearchTarget.marker_index_document_id#145",
        "src_path": "luigi/contrib/esindex.py",
        "class_name": "luigi.contrib.esindex.ElasticsearchTarget",
        "signature": "luigi.contrib.esindex.ElasticsearchTarget.marker_index_document_id(self)",
        "snippet": "    def marker_index_document_id(self):\n        \"\"\"\n        Generate an id for the indicator document.\n        \"\"\"\n        params = '%s:%s:%s' % (self.index, self.doc_type, self.update_id)\n        return hashlib.sha1(params).hexdigest()",
        "begin_line": 145,
        "end_line": 150,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.037037037037037035,
            "pseudo_dstar_susp": 0.0051813471502590676,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.0051813471502590676,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.contrib.esindex.ElasticsearchTarget.touch#152",
        "src_path": "luigi/contrib/esindex.py",
        "class_name": "luigi.contrib.esindex.ElasticsearchTarget",
        "signature": "luigi.contrib.esindex.ElasticsearchTarget.touch(self)",
        "snippet": "    def touch(self):\n        \"\"\"\n        Mark this update as complete.\n\n        The document id would be sufficent but,\n        for documentation,\n        we index the parameters `update_id`, `target_index`, `target_doc_type` and `date` as well.\n        \"\"\"\n        self.create_marker_index()\n        self.es.index(index=self.marker_index, doc_type=self.marker_doc_type,\n                      id=self.marker_index_document_id(), body={\n                          'update_id': self.update_id,\n                          'target_index': self.index,\n                          'target_doc_type': self.doc_type,\n                          'date': datetime.datetime.now()})\n        self.es.indices.flush(index=self.marker_index)\n        self.ensure_hist_size()",
        "begin_line": 152,
        "end_line": 168,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.14285714285714285,
            "pseudo_dstar_susp": 0.008849557522123894,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.008849557522123894,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.contrib.esindex.ElasticsearchTarget.exists#170",
        "src_path": "luigi/contrib/esindex.py",
        "class_name": "luigi.contrib.esindex.ElasticsearchTarget",
        "signature": "luigi.contrib.esindex.ElasticsearchTarget.exists(self)",
        "snippet": "    def exists(self):\n        \"\"\"\n        Test, if this task has been run.\n        \"\"\"\n        try:\n            self.es.get(index=self.marker_index, doc_type=self.marker_doc_type, id=self.marker_index_document_id())\n            return True\n        except elasticsearch.NotFoundError:\n            logger.debug('Marker document not found.')\n        except elasticsearch.ElasticsearchException as err:\n            logger.warn(err)\n        return False",
        "begin_line": 170,
        "end_line": 181,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.037037037037037035,
            "pseudo_dstar_susp": 0.0051813471502590676,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.0051813471502590676,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.contrib.esindex.CopyToIndex.update_id#387",
        "src_path": "luigi/contrib/esindex.py",
        "class_name": "luigi.contrib.esindex.CopyToIndex",
        "signature": "luigi.contrib.esindex.CopyToIndex.update_id(self)",
        "snippet": "    def update_id(self):\n        \"\"\"\n        This id will be a unique identifier for this indexing task.\n        \"\"\"\n        return self.task_id",
        "begin_line": 387,
        "end_line": 391,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002770083102493075,
            "pseudo_dstar_susp": 0.0013157894736842105,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.0013157894736842105,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.contrib.esindex.CopyToIndex.output#393",
        "src_path": "luigi/contrib/esindex.py",
        "class_name": "luigi.contrib.esindex.CopyToIndex",
        "signature": "luigi.contrib.esindex.CopyToIndex.output(self)",
        "snippet": "    def output(self):\n        \"\"\"\n        Returns a ElasticsearchTarget representing the inserted dataset.\n\n        Normally you don't override this.\n        \"\"\"\n        return ElasticsearchTarget(\n            host=self.host,\n            port=self.port,\n            http_auth=self.http_auth,\n            index=self.index,\n            doc_type=self.doc_type,\n            update_id=self.update_id(),\n            marker_index_hist_size=self.marker_index_hist_size\n        )",
        "begin_line": 393,
        "end_line": 407,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.0028328611898017,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.0028328611898017,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.interface.setup_interface_logging#45",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface.setup_interface_logging(conf_file=None)",
        "snippet": "def setup_interface_logging(conf_file=None):\n    # use a variable in the function object to determine if it has run before\n    if getattr(setup_interface_logging, \"has_run\", False):\n        return\n\n    if conf_file is None:\n        logger = logging.getLogger('luigi-interface')\n        logger.setLevel(logging.DEBUG)\n\n        stream_handler = logging.StreamHandler()\n        stream_handler.setLevel(logging.DEBUG)\n\n        formatter = logging.Formatter('%(levelname)s: %(message)s')\n        stream_handler.setFormatter(formatter)\n\n        logger.addHandler(stream_handler)\n    else:\n        logging.config.fileConfig(conf_file, disable_existing_loggers=False)\n\n    setup_interface_logging.has_run = True",
        "begin_line": 45,
        "end_line": 64,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.023255813953488372,
            "pseudo_dstar_susp": 0.00392156862745098,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.00392156862745098,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.interface.WorkerSchedulerFactory.create_local_scheduler#115",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface.WorkerSchedulerFactory",
        "signature": "luigi.interface.WorkerSchedulerFactory.create_local_scheduler(self)",
        "snippet": "    def create_local_scheduler(self):\n        return scheduler.CentralPlannerScheduler()",
        "begin_line": 115,
        "end_line": 116,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002074688796680498,
            "pseudo_dstar_susp": 0.004405286343612335,
            "pseudo_tarantula_susp": 0.0015873015873015873,
            "pseudo_op2_susp": 0.004405286343612335,
            "pseudo_barinel_susp": 0.001584786053882726
        }
    },
    {
        "name": "luigi.interface.WorkerSchedulerFactory.create_worker#121",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface.WorkerSchedulerFactory",
        "signature": "luigi.interface.WorkerSchedulerFactory.create_worker(self, scheduler, worker_processes)",
        "snippet": "    def create_worker(self, scheduler, worker_processes):\n        return worker.Worker(\n            scheduler=scheduler, worker_processes=worker_processes)",
        "begin_line": 121,
        "end_line": 123,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001366120218579235,
            "pseudo_dstar_susp": 0.0030120481927710845,
            "pseudo_tarantula_susp": 0.0012048192771084338,
            "pseudo_op2_susp": 0.0030120481927710845,
            "pseudo_barinel_susp": 0.0012048192771084338
        }
    },
    {
        "name": "luigi.interface.Interface.run#132",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface.Interface",
        "signature": "luigi.interface.Interface.run(tasks, worker_scheduler_factory=None, override_defaults=None)",
        "snippet": "    def run(tasks, worker_scheduler_factory=None, override_defaults=None):\n        \"\"\"\n        :param tasks:\n        :param worker_scheduler_factory:\n        :param override_defaults:\n        :return: True if all tasks and their dependencies were successfully run (or already completed);\n                 False if any error occurred.\n        \"\"\"\n\n        if worker_scheduler_factory is None:\n            worker_scheduler_factory = WorkerSchedulerFactory()\n        env_params = core(**override_defaults)\n        # search for logging configuration path first on the command line, then\n        # in the application config file\n        logging_conf = env_params.logging_conf_file\n        if logging_conf is not None and not os.path.exists(logging_conf):\n            raise Exception(\n                \"Error: Unable to locate specified logging configuration file!\"\n            )\n\n        if not configuration.get_config().getboolean(\n                'core', 'no_configure_logging', False):\n            setup_interface_logging(logging_conf)\n\n        if (not env_params.no_lock and\n                not(lock.acquire_for(env_params.lock_pid_dir, env_params.lock_size))):\n            sys.exit(1)\n\n        if env_params.local_scheduler:\n            sch = worker_scheduler_factory.create_local_scheduler()\n        else:\n            sch = worker_scheduler_factory.create_remote_scheduler(\n                host=env_params.scheduler_host,\n                port=env_params.scheduler_port)\n\n        w = worker_scheduler_factory.create_worker(\n            scheduler=sch, worker_processes=env_params.workers)\n\n        success = True\n        for t in tasks:\n            success &= w.add(t, env_params.parallel_scheduling)\n        logger = logging.getLogger('luigi-interface')\n        logger.info('Done scheduling tasks')\n        success &= w.run()\n        w.stop()\n        return success",
        "begin_line": 132,
        "end_line": 177,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0026954177897574125,
            "pseudo_dstar_susp": 0.009433962264150943,
            "pseudo_tarantula_susp": 0.0020161290322580645,
            "pseudo_op2_susp": 0.009433962264150943,
            "pseudo_barinel_susp": 0.0020161290322580645
        }
    },
    {
        "name": "luigi.interface._editdistance#181",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface._editdistance(a, b)",
        "snippet": "def _editdistance(a, b):\n    r0 = range(0, len(b) + 1)\n    r1 = [0] * (len(b) + 1)\n\n    for i in range(0, len(a)):\n        r1[0] = i + 1\n\n        for j in range(0, len(b)):\n            c = 0 if a[i] is b[j] else 1\n            r1[j + 1] = min(r1[j] + 1, r0[j + 1] + 1, r0[j] + c)\n\n        r0 = r1[:]\n\n    return r1[len(b)]",
        "begin_line": 181,
        "end_line": 194,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.interface.error_task_names#197",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface.error_task_names(task_name, task_names)",
        "snippet": "def error_task_names(task_name, task_names):\n    weighted_tasks = [(_editdistance(task_name, task_name_2), task_name_2) for task_name_2 in task_names]\n    ordered_tasks = sorted(weighted_tasks, key=lambda pair: pair[0])\n    candidates = [task for (dist, task) in ordered_tasks if dist <= 5 and dist < len(task)]\n    display_string = \"\"\n    if candidates:\n        display_string = \"No task %s. Did you mean:\\n%s\" % (task_name, '\\n'.join(candidates))\n    else:\n        display_string = \"No task %s.\" % task_name\n\n    raise SystemExit(display_string)",
        "begin_line": 197,
        "end_line": 207,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.interface.add_task_parameters#210",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface.add_task_parameters(parser, task_cls, optparse=False)",
        "snippet": "def add_task_parameters(parser, task_cls, optparse=False):\n    for param_name, param in task_cls.get_params():\n        param.add_to_cmdline_parser(parser, param_name, task_cls.task_family, optparse=optparse, glob=False)",
        "begin_line": 210,
        "end_line": 212,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001218026796589525,
            "pseudo_dstar_susp": 0.0012106537530266344,
            "pseudo_tarantula_susp": 0.0016863406408094434,
            "pseudo_op2_susp": 0.0012106537530266344,
            "pseudo_barinel_susp": 0.0016863406408094434
        }
    },
    {
        "name": "luigi.interface.add_global_parameters#215",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface.add_global_parameters(parser, optparse=False)",
        "snippet": "def add_global_parameters(parser, optparse=False):\n    seen_params = set()\n    for task_name, is_without_section, param_name, param in Register.get_all_params():\n        if param in seen_params:\n            continue\n        seen_params.add(param)\n        param.add_to_cmdline_parser(parser, param_name, task_name, optparse=optparse, glob=True, is_without_section=is_without_section)",
        "begin_line": 215,
        "end_line": 221,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00199203187250996,
            "pseudo_dstar_susp": 0.0036101083032490976,
            "pseudo_tarantula_susp": 0.001869158878504673,
            "pseudo_op2_susp": 0.0036101083032490976,
            "pseudo_barinel_susp": 0.001869158878504673
        }
    },
    {
        "name": "luigi.interface.get_task_parameters#224",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface.get_task_parameters(task_cls, args)",
        "snippet": "def get_task_parameters(task_cls, args):\n    # Parse a str->str dict to the correct types\n    params = {}\n    for param_name, param in task_cls.get_params():\n        param.parse_from_args(param_name, task_cls.task_family, args, params)\n    return params",
        "begin_line": 224,
        "end_line": 229,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015015015015015015,
            "pseudo_dstar_susp": 0.0019646365422396855,
            "pseudo_tarantula_susp": 0.0014492753623188406,
            "pseudo_op2_susp": 0.0019646365422396855,
            "pseudo_barinel_susp": 0.0014492753623188406
        }
    },
    {
        "name": "luigi.interface.set_global_parameters#232",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface.set_global_parameters(args)",
        "snippet": "def set_global_parameters(args):\n    # Note that this is not side effect free\n    for task_name, is_without_section, param_name, param in Register.get_all_params():\n        param.set_global_from_args(param_name, task_name, args, is_without_section=is_without_section)",
        "begin_line": 232,
        "end_line": 235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013458950201884253,
            "pseudo_dstar_susp": 0.0018050541516245488,
            "pseudo_tarantula_susp": 0.0013831258644536654,
            "pseudo_op2_susp": 0.0018050541516245488,
            "pseudo_barinel_susp": 0.0013812154696132596
        }
    },
    {
        "name": "luigi.interface.ArgParseInterface.parse_task#243",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface.ArgParseInterface",
        "signature": "luigi.interface.ArgParseInterface.parse_task(self, cmdline_args=None, main_task_cls=None)",
        "snippet": "    def parse_task(self, cmdline_args=None, main_task_cls=None):\n        parser = argparse.ArgumentParser()\n\n        add_global_parameters(parser)\n\n        if main_task_cls:\n            add_task_parameters(parser, main_task_cls)\n\n            args = parser.parse_args(args=cmdline_args)\n            task_cls = main_task_cls\n        else:\n            task_names = sorted(Register.get_reg().keys())\n\n            # Parse global arguments and pull out the task name.\n            # We used to do this using subparsers+command, but some issues with\n            # argparse across different versions of Python (2.7.9) made it hard.\n            args, unknown = parser.parse_known_args(args=cmdline_args)\n            if len(unknown) == 0:\n                raise SystemExit('No task specified')\n            task_name = unknown[0]\n            if task_name not in task_names:\n                error_task_names(task_name, task_names)\n\n            task_cls = Register.get_task_cls(task_name)\n\n            # Add a subparser to parse task-specific arguments\n            subparsers = parser.add_subparsers(dest='command')\n            subparser = subparsers.add_parser(task_name)\n\n            # Add both task and global params here so that we can support both:\n            # test.py --global-param xyz Test --n 42\n            # test.py Test --n 42 --global-param xyz\n            add_global_parameters(subparser)\n            add_task_parameters(subparser, task_cls)\n\n            # Workaround for bug in argparse for Python 2.7.9\n            # See https://mail.python.org/pipermail/python-dev/2015-January/137699.html\n            subargs = parser.parse_args(args=cmdline_args)\n            for key, value in vars(subargs).items():\n                if value:  # Either True (for boolean args) or non-None (everything else)\n                    setattr(args, key, value)\n\n        # Notice that this is not side effect free because it might set global params\n        set_global_parameters(args)\n        task_params = get_task_parameters(task_cls, args)\n\n        return [task_cls(**task_params)]",
        "begin_line": 243,
        "end_line": 289,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014204545454545455,
            "pseudo_dstar_susp": 0.0014792899408284023,
            "pseudo_tarantula_susp": 0.0022727272727272726,
            "pseudo_op2_susp": 0.0014792899408284023,
            "pseudo_barinel_susp": 0.002277904328018223
        }
    },
    {
        "name": "luigi.interface.ArgParseInterface.parse#291",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface.ArgParseInterface",
        "signature": "luigi.interface.ArgParseInterface.parse(self, cmdline_args=None, main_task_cls=None)",
        "snippet": "    def parse(self, cmdline_args=None, main_task_cls=None):\n        return self.parse_task(cmdline_args, main_task_cls)",
        "begin_line": 291,
        "end_line": 292,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002145922746781116,
            "pseudo_dstar_susp": 0.001466275659824047,
            "pseudo_tarantula_susp": 0.003389830508474576,
            "pseudo_op2_susp": 0.001466275659824047,
            "pseudo_barinel_susp": 0.003401360544217687
        }
    },
    {
        "name": "luigi.interface.DynamicArgParseInterface.parse#308",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface.DynamicArgParseInterface",
        "signature": "luigi.interface.DynamicArgParseInterface.parse(self, cmdline_args=None, main_task_cls=None)",
        "snippet": "    def parse(self, cmdline_args=None, main_task_cls=None):\n        parser = argparse.ArgumentParser()\n\n        add_global_parameters(parser)\n\n        args, unknown = parser.parse_known_args(args=cmdline_args)\n        module = args.module\n\n        __import__(module)\n\n        return self.parse_task(cmdline_args, main_task_cls)",
        "begin_line": 308,
        "end_line": 318,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.interface.PassThroughOptionParser._process_args#331",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface.PassThroughOptionParser",
        "signature": "luigi.interface.PassThroughOptionParser._process_args(self, largs, rargs, values)",
        "snippet": "    def _process_args(self, largs, rargs, values):\n        while rargs:\n            try:\n                optparse.OptionParser._process_args(self, largs, rargs, values)\n            except (optparse.BadOptionError, optparse.AmbiguousOptionError) as e:\n                largs.append(e.opt_str)",
        "begin_line": 331,
        "end_line": 336,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022988505747126436,
            "pseudo_dstar_susp": 0.0012987012987012987,
            "pseudo_tarantula_susp": 0.005263157894736842,
            "pseudo_op2_susp": 0.0012987012987012987,
            "pseudo_barinel_susp": 0.005263157894736842
        }
    },
    {
        "name": "luigi.interface.OptParseInterface.__init__#347",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface.OptParseInterface",
        "signature": "luigi.interface.OptParseInterface.__init__(self, existing_optparse)",
        "snippet": "    def __init__(self, existing_optparse):\n        self.__existing_optparse = existing_optparse",
        "begin_line": 347,
        "end_line": 348,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022988505747126436,
            "pseudo_dstar_susp": 0.0012987012987012987,
            "pseudo_tarantula_susp": 0.005263157894736842,
            "pseudo_op2_susp": 0.0012987012987012987,
            "pseudo_barinel_susp": 0.005263157894736842
        }
    },
    {
        "name": "luigi.interface.OptParseInterface.parse#350",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface.OptParseInterface",
        "signature": "luigi.interface.OptParseInterface.parse(self, cmdline_args=None, main_task_cls=None)",
        "snippet": "    def parse(self, cmdline_args=None, main_task_cls=None):\n        parser = PassThroughOptionParser()\n\n        def add_task_option(p):\n            if main_task_cls:\n                p.add_option('--task', help='Task to run (one of ' + Register.tasks_str() + ') [default: %default]', default=main_task_cls.task_family)\n            else:\n                p.add_option('--task', help='Task to run (one of %s)' % Register.tasks_str())\n\n        add_global_parameters(parser, optparse=True)\n\n        add_task_option(parser)\n        options, args = parser.parse_args(args=cmdline_args)\n\n        task_cls_name = options.task\n        if self.__existing_optparse:\n            parser = self.__existing_optparse\n        else:\n            parser = optparse.OptionParser()\n        add_task_option(parser)\n\n        task_cls = Register.get_task_cls(task_cls_name)\n\n        # Register all parameters as a big mess\n        add_global_parameters(parser, optparse=True)\n        add_task_parameters(parser, task_cls, optparse=True)\n\n        # Parse and run\n        options, args = parser.parse_args(args=cmdline_args)\n\n        set_global_parameters(options)\n        task_params = get_task_parameters(task_cls, options)\n\n        return [task_cls(**task_params)]",
        "begin_line": 350,
        "end_line": 383,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022988505747126436,
            "pseudo_dstar_susp": 0.0012987012987012987,
            "pseudo_tarantula_susp": 0.005263157894736842,
            "pseudo_op2_susp": 0.0012987012987012987,
            "pseudo_barinel_susp": 0.005263157894736842
        }
    },
    {
        "name": "luigi.interface.OptParseInterface.add_task_option#353",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface.OptParseInterface",
        "signature": "luigi.interface.OptParseInterface.add_task_option(p)",
        "snippet": "        def add_task_option(p):\n            if main_task_cls:\n                p.add_option('--task', help='Task to run (one of ' + Register.tasks_str() + ') [default: %default]', default=main_task_cls.task_family)\n            else:\n                p.add_option('--task', help='Task to run (one of %s)' % Register.tasks_str())",
        "begin_line": 353,
        "end_line": 357,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022988505747126436,
            "pseudo_dstar_susp": 0.0012987012987012987,
            "pseudo_tarantula_susp": 0.005263157894736842,
            "pseudo_op2_susp": 0.0012987012987012987,
            "pseudo_barinel_susp": 0.005263157894736842
        }
    },
    {
        "name": "luigi.interface.run#386",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface.run(cmdline_args=None, existing_optparse=None, use_optparse=False, main_task_cls=None, worker_scheduler_factory=None, use_dynamic_argparse=False, local_scheduler=False)",
        "snippet": "def run(cmdline_args=None, existing_optparse=None, use_optparse=False, main_task_cls=None,\n        worker_scheduler_factory=None, use_dynamic_argparse=False, local_scheduler=False):\n    \"\"\"\n    Run from cmdline.\n\n    The default parser uses argparse however, for legacy reasons,\n    we support optparse that optionally allows for overriding an existing option parser with new args.\n\n    :param cmdline_args:\n    :param existing_optparse:\n    :param use_optparse:\n    :param main_task_cls:\n    :param worker_scheduler_factory:\n    :param use_dynamic_argparse:\n    :param local_scheduler:\n    \"\"\"\n    if use_optparse:\n        interface = OptParseInterface(existing_optparse)\n    elif use_dynamic_argparse:\n        interface = DynamicArgParseInterface()\n    else:\n        interface = ArgParseInterface()\n    tasks = interface.parse(cmdline_args, main_task_cls=main_task_cls)\n    override_defaults = {}\n    if local_scheduler:\n        override_defaults['local_scheduler'] = True\n    return interface.run(tasks, worker_scheduler_factory, override_defaults=override_defaults)",
        "begin_line": 386,
        "end_line": 412,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001455604075691412,
            "pseudo_dstar_susp": 0.0014792899408284023,
            "pseudo_tarantula_susp": 0.003115264797507788,
            "pseudo_op2_susp": 0.0014792899408284023,
            "pseudo_barinel_susp": 0.003115264797507788
        }
    },
    {
        "name": "luigi.interface.build#415",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface.build(tasks, worker_scheduler_factory=None, **env_params)",
        "snippet": "def build(tasks, worker_scheduler_factory=None, **env_params):\n    \"\"\"\n    Run internally, bypassing the cmdline parsing.\n\n    Useful if you have some luigi code that you want to run internally.\n    Example:\n\n    .. code-block:: python\n\n        luigi.build([MyTask1(), MyTask2()], local_scheduler=True)\n\n    One notable difference is that `build` defaults to not using\n    the identical process lock. Otherwise, `build` would only be\n    callable once from each process.\n\n    :param tasks:\n    :param worker_scheduler_factory:\n    :param env_params:\n    :return:\n    \"\"\"\n    if \"no_lock\" not in env_params:\n        # TODO(erikbern): should we really override args here?\n        env_params[\"no_lock\"] = True\n\n    Interface.run(tasks, worker_scheduler_factory, env_params)",
        "begin_line": 415,
        "end_line": 439,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017271157167530224,
            "pseudo_dstar_susp": 0.00186219739292365,
            "pseudo_tarantula_susp": 0.002849002849002849,
            "pseudo_op2_susp": 0.00186219739292365,
            "pseudo_barinel_susp": 0.002849002849002849
        }
    },
    {
        "name": "luigi.file.abstract_atomic_file.__init__#41",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.abstract_atomic_file",
        "signature": "luigi.file.abstract_atomic_file.__init__(self, path)",
        "snippet": "    def __init__(self, path):\n        self.__tmp_path = path + '-luigi-tmp-%09d' % random.randrange(0, 1e10)\n        self.path = path\n        init_args = self.get_init_args(self.__tmp_path)\n        super(abstract_atomic_file, self).__init__(*init_args)",
        "begin_line": 41,
        "end_line": 45,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005652911249293386,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.file.abstract_atomic_file.get_init_args#47",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.abstract_atomic_file",
        "signature": "luigi.file.abstract_atomic_file.get_init_args(self, path)",
        "snippet": "    def get_init_args(self, path):\n        return (io.FileIO(path, 'w'),)",
        "begin_line": 47,
        "end_line": 48,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004520795660036166,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.file.abstract_atomic_file.close#50",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.abstract_atomic_file",
        "signature": "luigi.file.abstract_atomic_file.close(self)",
        "snippet": "    def close(self):\n        super(abstract_atomic_file, self).close()\n        os.rename(self.__tmp_path, self.path)",
        "begin_line": 50,
        "end_line": 52,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.00046040515653775324,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.file.abstract_atomic_file.__del__#54",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.abstract_atomic_file",
        "signature": "luigi.file.abstract_atomic_file.__del__(self)",
        "snippet": "    def __del__(self):\n        if os.path.exists(self.__tmp_path):\n            os.remove(self.__tmp_path)",
        "begin_line": 54,
        "end_line": 56,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005291005291005291,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.file.LocalFileSystem.exists#91",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalFileSystem",
        "signature": "luigi.file.LocalFileSystem.exists(self, path)",
        "snippet": "    def exists(self, path):\n        return os.path.exists(path)",
        "begin_line": 91,
        "end_line": 92,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004411116012351125,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.file.LocalFileSystem.isdir#97",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalFileSystem",
        "signature": "luigi.file.LocalFileSystem.isdir(self, path)",
        "snippet": "    def isdir(self, path):\n        return os.path.isdir(path)",
        "begin_line": 97,
        "end_line": 98,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.file.LocalFileSystem.remove#100",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalFileSystem",
        "signature": "luigi.file.LocalFileSystem.remove(self, path, recursive=True)",
        "snippet": "    def remove(self, path, recursive=True):\n        if recursive and self.isdir(path):\n            shutil.rmtree(path)\n        else:\n            os.remove(path)",
        "begin_line": 100,
        "end_line": 104,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.file.File.__init__#110",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.File",
        "signature": "luigi.file.File.__init__(self, path=None, format=None, is_tmp=False)",
        "snippet": "    def __init__(self, path=None, format=None, is_tmp=False):\n        if not path:\n            if not is_tmp:\n                raise Exception('path or is_tmp must be set')\n            path = os.path.join(tempfile.gettempdir(), 'luigi-tmp-%09d' % random.randint(0, 999999999))\n        super(File, self).__init__(path)\n        self.format = format\n        self.is_tmp = is_tmp",
        "begin_line": 110,
        "end_line": 117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.file.File.makedirs#119",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.File",
        "signature": "luigi.file.File.makedirs(self)",
        "snippet": "    def makedirs(self):\n        \"\"\"\n        Create all parent folders if they do not exist.\n        \"\"\"\n        normpath = os.path.normpath(self.path)\n        parentfolder = os.path.dirname(normpath)\n        if parentfolder and not os.path.exists(parentfolder):\n            os.makedirs(parentfolder)",
        "begin_line": 119,
        "end_line": 126,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004943153732081067,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.file.File.open#128",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.File",
        "signature": "luigi.file.File.open(self, mode='r')",
        "snippet": "    def open(self, mode='r'):\n        char_mode = get_char_mode(mode)\n        if 'w' in mode:\n            self.makedirs()\n\n            if char_mode == 'b':\n                atomic_type = atomic_binary_file\n            elif char_mode == 't':\n                atomic_type = atomic_text_file\n            else:\n                atomic_type = atomic_file\n\n            if self.format:\n                return self.format.pipe_writer(atomic_type(self.path))\n            else:\n                return atomic_type(self.path)\n\n        elif 'r' in mode:\n            if char_mode == 't':\n                fileobj = FileWrapper(io.TextIOWrapper(io.FileIO(self.path, 'r')))\n            elif char_mode == 'b':\n                fileobj = FileWrapper(io.BufferedReader(io.FileIO(self.path, 'r')))\n            else:\n                fileobj = FileWrapper(open(self.path, 'r'))\n\n            if self.format:\n                return self.format.pipe_reader(fileobj)\n\n            return fileobj\n        else:\n            raise Exception('mode must be r/w')",
        "begin_line": 128,
        "end_line": 158,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004894762604013706,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.file.File.move#161",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.File",
        "signature": "luigi.file.File.move(self, new_path, fail_if_exists=False)",
        "snippet": "    def move(self, new_path, fail_if_exists=False):\n        if fail_if_exists and os.path.exists(new_path):\n            raise RuntimeError('Destination exists: %s' % new_path)\n        d = os.path.dirname(new_path)\n        if d and not os.path.exists(d):\n            self.fs.mkdir(d)\n        os.rename(self.path, new_path)",
        "begin_line": 161,
        "end_line": 167,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005291005291005291,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.file.File.remove#172",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.File",
        "signature": "luigi.file.File.remove(self)",
        "snippet": "    def remove(self):\n        self.fs.remove(self.path)",
        "begin_line": 172,
        "end_line": 173,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004894762604013706,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.file.File.copy#176",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.File",
        "signature": "luigi.file.File.copy(self, new_path, fail_if_exists=False)",
        "snippet": "    def copy(self, new_path, fail_if_exists=False):\n        if fail_if_exists and os.path.exists(new_path):\n            raise RuntimeError('Destination exists: %s' % new_path)\n        tmp = File(new_path + '-luigi-tmp-%09d' % random.randrange(0, 1e10), is_tmp=True)\n        tmp.makedirs()\n        shutil.copy(self.path, tmp.fn)\n        tmp.move(new_path)",
        "begin_line": 176,
        "end_line": 182,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0006830601092896175,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.file.File.fn#185",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.File",
        "signature": "luigi.file.File.fn(self)",
        "snippet": "    def fn(self):\n        return self.path",
        "begin_line": 185,
        "end_line": 186,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0005652911249293386,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.file.File.__del__#188",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.File",
        "signature": "luigi.file.File.__del__(self)",
        "snippet": "    def __del__(self):\n        if self.is_tmp and self.exists():\n            self.remove()",
        "begin_line": 188,
        "end_line": 190,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0004997501249375312,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.postgres.MultiReplacer._replacer#76",
        "src_path": "luigi/postgres.py",
        "class_name": "luigi.postgres.MultiReplacer",
        "signature": "luigi.postgres.MultiReplacer._replacer(self, match_object)",
        "snippet": "    def _replacer(self, match_object):\n        # this method is used as the replace function in the re.sub below\n        return self._replace_dict[match_object.group()]",
        "begin_line": 76,
        "end_line": 78,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.postgres.PostgresTarget.__init__#108",
        "src_path": "luigi/postgres.py",
        "class_name": "luigi.postgres.PostgresTarget",
        "signature": "luigi.postgres.PostgresTarget.__init__(self, host, database, user, password, table, update_id)",
        "snippet": "    def __init__(self, host, database, user, password, table, update_id):\n        \"\"\"\n        Args:\n            host (str): Postgres server address. Possibly a host:port string.\n            database (str): Database name\n            user (str): Database user\n            password (str): Password for specified user\n            update_id (str): An identifier for this data set\n\n        \"\"\"\n        if ':' in host:\n            self.host, self.port = host.split(':')\n        else:\n            self.host = host\n            self.port = None\n        self.database = database\n        self.user = user\n        self.password = password\n        self.table = table\n        self.update_id = update_id",
        "begin_line": 108,
        "end_line": 127,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.05555555555555555,
            "pseudo_dstar_susp": 0.005847953216374269,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.005847953216374269,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.postgres.PostgresTarget.connect#180",
        "src_path": "luigi/postgres.py",
        "class_name": "luigi.postgres.PostgresTarget",
        "signature": "luigi.postgres.PostgresTarget.connect(self)",
        "snippet": "    def connect(self):\n        \"\"\"\n        Get a psycopg2 connection object to the database where the table is.\n        \"\"\"\n        connection = psycopg2.connect(\n            host=self.host,\n            port=self.port,\n            database=self.database,\n            user=self.user,\n            password=self.password)\n        connection.set_client_encoding('utf-8')\n        return connection",
        "begin_line": 180,
        "end_line": 191,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.0028328611898017,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.0028328611898017,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.postgres.CopyToTable.output#264",
        "src_path": "luigi/postgres.py",
        "class_name": "luigi.postgres.CopyToTable",
        "signature": "luigi.postgres.CopyToTable.output(self)",
        "snippet": "    def output(self):\n        \"\"\"\n        Returns a PostgresTarget representing the inserted dataset.\n\n        Normally you don't override this.\n        \"\"\"\n        return PostgresTarget(\n            host=self.host,\n            database=self.database,\n            user=self.user,\n            password=self.password,\n            table=self.table,\n            update_id=self.update_id()\n        )",
        "begin_line": 264,
        "end_line": 277,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.0028328611898017,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.0028328611898017,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.tools.parse_task.id_to_name_and_params#21",
        "src_path": "luigi/tools/parse_task.py",
        "class_name": "luigi.tools.parse_task",
        "signature": "luigi.tools.parse_task.id_to_name_and_params(task_id)",
        "snippet": "def id_to_name_and_params(task_id):\n    \"\"\"\n    Turn a task_id into a (task_family, {params}) tuple.\n\n    E.g. calling with ``Foo(bar=bar, baz=baz)`` returns ``('Foo', {'bar': 'bar', 'baz': 'baz'})``.\n    \"\"\"\n\n    warnings.warn(\n        'id_to_name_and_params is deprecated (and moved to luigi.tools.parse_task). '\n        'Please don\\'t use task names as a serialization mechanism. Rather, store '\n        'the task family and the parameters as separate strings',\n        DeprecationWarning,\n        stacklevel=2)\n\n    name_chars = pp.alphanums + '_'\n    # modified version of pp.printables. Removed '[]', '()', ','\n    value_chars = pp.alphanums + '\\'!\"#$%&*+-./:;<=>?@\\\\^_`{|}~'\n    parameter = (\n        (pp.Word(name_chars) +\n         pp.Literal('=').suppress() +\n         ((pp.Literal('(').suppress() | pp.Literal('[').suppress()) +\n          pp.ZeroOrMore(pp.Word(value_chars) +\n                        pp.ZeroOrMore(pp.Literal(',')).suppress()) +\n          (pp.Literal(')').suppress() |\n           pp.Literal(']').suppress()))).setResultsName('list_params',\n                                                        listAllMatches=True) |\n        (pp.Word(name_chars) +\n         pp.Literal('=').suppress() +\n         pp.Word(value_chars)).setResultsName('params', listAllMatches=True))\n\n    parser = (\n        pp.Word(name_chars).setResultsName('task') +\n        pp.Literal('(').suppress() +\n        pp.ZeroOrMore(parameter + (pp.Literal(',')).suppress()) +\n        pp.ZeroOrMore(parameter) +\n        pp.Literal(')').suppress())\n\n    parsed = parser.parseString(task_id).asDict()\n    task_name = parsed['task']\n\n    params = {}\n    if 'params' in parsed:\n        for k, v in parsed['params']:\n            params[k] = v\n    if 'list_params' in parsed:\n        for x in parsed['list_params']:\n            params[x[0]] = x[1:]\n    return task_name, params",
        "begin_line": 21,
        "end_line": 68,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003787878787878788,
            "pseudo_dstar_susp": 0.0048543689320388345,
            "pseudo_tarantula_susp": 0.0035971223021582736,
            "pseudo_op2_susp": 0.0048543689320388345,
            "pseudo_barinel_susp": 0.0035971223021582736
        }
    },
    {
        "name": "luigi.contrib.rdbms.CopyToTable.update_id#98",
        "src_path": "luigi/contrib/rdbms.py",
        "class_name": "luigi.contrib.rdbms.CopyToTable",
        "signature": "luigi.contrib.rdbms.CopyToTable.update_id(self)",
        "snippet": "    def update_id(self):\n        \"\"\"\n        This update id will be a unique identifier for this insert on this table.\n        \"\"\"\n        return self.task_id",
        "begin_line": 98,
        "end_line": 102,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.05555555555555555,
            "pseudo_dstar_susp": 0.005847953216374269,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.005847953216374269,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.six._SixMetaPathImporter.find_module#185",
        "src_path": "luigi/six.py",
        "class_name": "luigi.six._SixMetaPathImporter",
        "signature": "luigi.six._SixMetaPathImporter.find_module(self, fullname, path=None)",
        "snippet": "    def find_module(self, fullname, path=None):\n        if fullname in self.known_modules:\n            return self\n        return None",
        "begin_line": 185,
        "end_line": 188,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002770083102493075,
            "pseudo_dstar_susp": 0.0013157894736842105,
            "pseudo_tarantula_susp": 0.014492753623188406,
            "pseudo_op2_susp": 0.0013157894736842105,
            "pseudo_barinel_susp": 0.014492753623188406
        }
    },
    {
        "name": "luigi.six.itervalues#559",
        "src_path": "luigi/six.py",
        "class_name": "luigi.six",
        "signature": "luigi.six.itervalues(d, **kw)",
        "snippet": "    def itervalues(d, **kw):\n        return iter(d.values(**kw))",
        "begin_line": 559,
        "end_line": 560,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018214936247723133,
            "pseudo_dstar_susp": 0.0015082956259426848,
            "pseudo_tarantula_susp": 0.002577319587628866,
            "pseudo_op2_susp": 0.0015082956259426848,
            "pseudo_barinel_susp": 0.002577319587628866
        }
    },
    {
        "name": "luigi.six.iteritems#562",
        "src_path": "luigi/six.py",
        "class_name": "luigi.six",
        "signature": "luigi.six.iteritems(d, **kw)",
        "snippet": "    def iteritems(d, **kw):\n        return iter(d.items(**kw))",
        "begin_line": 562,
        "end_line": 563,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009174311926605505,
            "pseudo_dstar_susp": 0.07692307692307693,
            "pseudo_tarantula_susp": 0.004830917874396135,
            "pseudo_op2_susp": 0.07692307692307693,
            "pseudo_barinel_susp": 0.004830917874396135
        }
    },
    {
        "name": "luigi.notifications.email_type#31",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.email_type()",
        "snippet": "def email_type():\n    return configuration.get_config().get('core', 'email-type', 'plain')",
        "begin_line": 31,
        "end_line": 32,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00234192037470726,
            "pseudo_dstar_susp": 0.002008032128514056,
            "pseudo_tarantula_susp": 0.002617801047120419,
            "pseudo_op2_susp": 0.002008032128514056,
            "pseudo_barinel_susp": 0.002617801047120419
        }
    },
    {
        "name": "luigi.notifications.generate_email#35",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.generate_email(sender, subject, message, recipients, image_png)",
        "snippet": "def generate_email(sender, subject, message, recipients, image_png):\n    import email\n    import email.mime\n    import email.mime.multipart\n    import email.mime.text\n    import email.mime.image\n\n    msg_root = email.mime.multipart.MIMEMultipart('related')\n\n    msg_text = email.mime.text.MIMEText(message, email_type())\n    msg_text.set_charset('utf-8')\n    msg_root.attach(msg_text)\n\n    if image_png:\n        fp = open(image_png, 'rb')\n        msg_image = email.mime.image.MIMEImage(fp.read(), 'png')\n        fp.close()\n        msg_root.attach(msg_image)\n\n    msg_root['Subject'] = subject\n    msg_root['From'] = sender\n    msg_root['To'] = ','.join(recipients)\n\n    return msg_root",
        "begin_line": 35,
        "end_line": 58,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.notifications.wrap_traceback#61",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.wrap_traceback(traceback)",
        "snippet": "def wrap_traceback(traceback):\n    if email_type() == 'html':\n        return '<pre>%s</pre>' % traceback\n    return traceback",
        "begin_line": 61,
        "end_line": 64,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0030303030303030303,
            "pseudo_dstar_susp": 0.0053475935828877,
            "pseudo_tarantula_susp": 0.00267379679144385,
            "pseudo_op2_susp": 0.0053475935828877,
            "pseudo_barinel_susp": 0.00267379679144385
        }
    },
    {
        "name": "luigi.notifications.send_email_smtp#67",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.send_email_smtp(config, sender, subject, message, recipients, image_png)",
        "snippet": "def send_email_smtp(config, sender, subject, message, recipients, image_png):\n    import smtplib\n\n    smtp_ssl = config.getboolean('core', 'smtp_ssl', False)\n    smtp_host = config.get('core', 'smtp_host', 'localhost')\n    smtp_port = config.getint('core', 'smtp_port', 0)\n    smtp_local_hostname = config.get('core', 'smtp_local_hostname', None)\n    smtp_timeout = config.getfloat('core', 'smtp_timeout', None)\n    kwargs = dict(host=smtp_host, port=smtp_port, local_hostname=smtp_local_hostname)\n    if smtp_timeout:\n        kwargs['timeout'] = smtp_timeout\n\n    smtp_login = config.get('core', 'smtp_login', None)\n    smtp_password = config.get('core', 'smtp_password', None)\n    smtp = smtplib.SMTP(**kwargs) if not smtp_ssl else smtplib.SMTP_SSL(**kwargs)\n    if smtp_login and smtp_password:\n        smtp.login(smtp_login, smtp_password)\n\n    msg_root = generate_email(sender, subject, message, recipients, image_png)\n\n    smtp.sendmail(sender, recipients, msg_root.as_string())",
        "begin_line": 67,
        "end_line": 87,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.notifications.send_email#120",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.send_email(subject, message, sender, recipients, image_png=None)",
        "snippet": "def send_email(subject, message, sender, recipients, image_png=None):\n    config = configuration.get_config()\n\n    subject = _prefix(subject)\n    if not recipients or recipients == (None,):\n        return\n    if (sys.stdout.isatty() or DEBUG) and (not config.getboolean('email', 'force-send', False)):\n        logger.info(\"Not sending email when running from a tty or in debug mode\")\n        return\n\n    # Clean the recipients lists to allow multiple error-email addresses, comma\n    # separated in client.cfg\n    recipients_tmp = []\n    for r in recipients:\n        recipients_tmp.extend(r.split(','))\n\n    # Replace original recipients with the clean list\n    recipients = recipients_tmp\n\n    email_sender_type = config.get('email', 'type', None)\n    if email_sender_type == \"ses\":\n        send_email_ses(config, sender, subject, message, recipients, image_png)\n    elif email_sender_type == \"sendgrid\":\n        send_email_sendgrid(config, sender, subject, message, recipients, image_png)\n    else:\n        send_email_smtp(config, sender, subject, message, recipients, image_png)",
        "begin_line": 120,
        "end_line": 145,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0007698229407236335,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    },
    {
        "name": "luigi.notifications.send_error_email#148",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.send_error_email(subject, message)",
        "snippet": "def send_error_email(subject, message):\n    \"\"\"\n    Sends an email to the configured error-email.\n\n    If no error-email is configured, then a message is logged.\n    \"\"\"\n    config = configuration.get_config()\n    receiver = config.get('core', 'error-email', None)\n    if receiver:\n        sender = config.get('core', 'email-sender', DEFAULT_CLIENT_EMAIL)\n        logger.info(\"Sending warning email to %r\", receiver)\n        send_email(\n            subject=subject,\n            message=message,\n            sender=sender,\n            recipients=(receiver,)\n        )\n    else:\n        logger.info(\"Skipping error email. Set `error-email` in the `core` \"\n                    \"section of the luigi config file to receive error \"\n                    \"emails.\")",
        "begin_line": 148,
        "end_line": 168,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002564102564102564,
            "pseudo_dstar_susp": 0.005649717514124294,
            "pseudo_tarantula_susp": 0.002036659877800407,
            "pseudo_op2_susp": 0.005649717514124294,
            "pseudo_barinel_susp": 0.002036659877800407
        }
    },
    {
        "name": "luigi.notifications._prefix#171",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications._prefix(subject)",
        "snippet": "def _prefix(subject):\n    \"\"\"\n    If the config has a special prefix for emails then this function adds\n    this prefix.\n    \"\"\"\n    config = configuration.get_config()\n    email_prefix = config.get('core', 'email-prefix', None)\n    if email_prefix is not None:\n        subject = \"%s %s\" % (email_prefix, subject)\n    return subject",
        "begin_line": 171,
        "end_line": 180,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005984440454817474,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.0005984440454817474,
            "pseudo_op2_susp": 0.0009354536950420954,
            "pseudo_barinel_susp": 0.0005984440454817474
        }
    }
]