[
    {
        "name": "pandas.tests.indexing.multiindex.conftest.multiindex_dataframe_random_data#9",
        "src_path": "pandas/tests/indexing/multiindex/conftest.py",
        "class_name": "pandas.tests.indexing.multiindex.conftest",
        "signature": "pandas.tests.indexing.multiindex.conftest.multiindex_dataframe_random_data()",
        "snippet": "def multiindex_dataframe_random_data():\n    \"\"\"DataFrame with 2 level MultiIndex with random data\"\"\"\n    index = MultiIndex(\n        levels=[[\"foo\", \"bar\", \"baz\", \"qux\"], [\"one\", \"two\", \"three\"]],\n        codes=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3], [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],\n        names=[\"first\", \"second\"],\n    )\n    return DataFrame(\n        np.random.randn(10, 3), index=index, columns=Index([\"A\", \"B\", \"C\"], name=\"exp\")\n    )",
        "begin_line": 9,
        "end_line": 18,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.conftest.multiindex_year_month_day_dataframe_random_data#22",
        "src_path": "pandas/tests/indexing/multiindex/conftest.py",
        "class_name": "pandas.tests.indexing.multiindex.conftest",
        "signature": "pandas.tests.indexing.multiindex.conftest.multiindex_year_month_day_dataframe_random_data()",
        "snippet": "def multiindex_year_month_day_dataframe_random_data():\n    \"\"\"DataFrame with 3 level MultiIndex (year, month, day) covering\n    first 100 business days from 2000-01-01 with random data\"\"\"\n    tdf = tm.makeTimeDataFrame(100)\n    ymd = tdf.groupby([lambda x: x.year, lambda x: x.month, lambda x: x.day]).sum()\n    # use Int64Index, to make sure things work\n    ymd.index.set_levels([lev.astype(\"i8\") for lev in ymd.index.levels], inplace=True)\n    ymd.index.set_names([\"year\", \"month\", \"day\"], inplace=True)\n    return ymd",
        "begin_line": 22,
        "end_line": 30,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common._mklbl#13",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common",
        "signature": "pandas.tests.indexing.common._mklbl(prefix, n)",
        "snippet": "def _mklbl(prefix, n):\n    return [\"{prefix}{i}\".format(prefix=prefix, i=i) for i in range(n)]",
        "begin_line": 13,
        "end_line": 14,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common._axify#17",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common",
        "signature": "pandas.tests.indexing.common._axify(obj, key, axis)",
        "snippet": "def _axify(obj, key, axis):\n    # create a tuple accessor\n    axes = [slice(None)] * obj.ndim\n    axes[axis] = key\n    return tuple(axes)",
        "begin_line": 17,
        "end_line": 21,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.setup_method#40",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.setup_method(self, method)",
        "snippet": "    def setup_method(self, method):\n\n        self.series_ints = Series(np.random.rand(4), index=np.arange(0, 8, 2))\n        self.frame_ints = DataFrame(\n            np.random.randn(4, 4), index=np.arange(0, 8, 2), columns=np.arange(0, 12, 3)\n        )\n\n        self.series_uints = Series(\n            np.random.rand(4), index=UInt64Index(np.arange(0, 8, 2))\n        )\n        self.frame_uints = DataFrame(\n            np.random.randn(4, 4),\n            index=UInt64Index(range(0, 8, 2)),\n            columns=UInt64Index(range(0, 12, 3)),\n        )\n\n        self.series_floats = Series(\n            np.random.rand(4), index=Float64Index(range(0, 8, 2))\n        )\n        self.frame_floats = DataFrame(\n            np.random.randn(4, 4),\n            index=Float64Index(range(0, 8, 2)),\n            columns=Float64Index(range(0, 12, 3)),\n        )\n\n        m_idces = [\n            MultiIndex.from_product([[1, 2], [3, 4]]),\n            MultiIndex.from_product([[5, 6], [7, 8]]),\n            MultiIndex.from_product([[9, 10], [11, 12]]),\n        ]\n\n        self.series_multi = Series(np.random.rand(4), index=m_idces[0])\n        self.frame_multi = DataFrame(\n            np.random.randn(4, 4), index=m_idces[0], columns=m_idces[1]\n        )\n\n        self.series_labels = Series(np.random.randn(4), index=list(\"abcd\"))\n        self.frame_labels = DataFrame(\n            np.random.randn(4, 4), index=list(\"abcd\"), columns=list(\"ABCD\")\n        )\n\n        self.series_mixed = Series(np.random.randn(4), index=[2, 4, \"null\", 8])\n        self.frame_mixed = DataFrame(np.random.randn(4, 4), index=[2, 4, \"null\", 8])\n\n        self.series_ts = Series(\n            np.random.randn(4), index=date_range(\"20130101\", periods=4)\n        )\n        self.frame_ts = DataFrame(\n            np.random.randn(4, 4), index=date_range(\"20130101\", periods=4)\n        )\n\n        dates_rev = date_range(\"20130101\", periods=4).sort_values(ascending=False)\n        self.series_ts_rev = Series(np.random.randn(4), index=dates_rev)\n        self.frame_ts_rev = DataFrame(np.random.randn(4, 4), index=dates_rev)\n\n        self.frame_empty = DataFrame()\n        self.series_empty = Series(dtype=object)\n\n        # form agglomerates\n        for kind in self._kinds:\n            d = dict()\n            for typ in self._typs:\n                d[typ] = getattr(self, \"{kind}_{typ}\".format(kind=kind, typ=typ))\n\n            setattr(self, kind, d)",
        "begin_line": 40,
        "end_line": 104,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.generate_indices#106",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.generate_indices(self, f, values=False)",
        "snippet": "    def generate_indices(self, f, values=False):\n        \"\"\" generate the indices\n        if values is True , use the axis values\n        is False, use the range\n        \"\"\"\n\n        axes = f.axes\n        if values:\n            axes = (list(range(len(ax))) for ax in axes)\n\n        return itertools.product(*axes)",
        "begin_line": 106,
        "end_line": 116,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.get_result#118",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.get_result(self, obj, method, key, axis)",
        "snippet": "    def get_result(self, obj, method, key, axis):\n        \"\"\" return the result for this obj with this key and this axis \"\"\"\n\n        if isinstance(key, dict):\n            key = key[axis]\n\n        # use an artificial conversion to map the key as integers to the labels\n        # so ix can work for comparisons\n        if method == \"indexer\":\n            method = \"ix\"\n            key = obj._get_axis(axis)[key]\n\n        # in case we actually want 0 index slicing\n        with catch_warnings(record=True):\n            try:\n                xp = getattr(obj, method).__getitem__(_axify(obj, key, axis))\n            except AttributeError:\n                xp = getattr(obj, method).__getitem__(key)\n\n        return xp",
        "begin_line": 118,
        "end_line": 137,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.get_value#139",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.get_value(self, name, f, i, values=False)",
        "snippet": "    def get_value(self, name, f, i, values=False):\n        \"\"\" return the value for the location i \"\"\"\n\n        # check against values\n        if values:\n            return f.values[i]\n\n        elif name == \"iat\":\n            return f.iloc[i]\n        else:\n            assert name == \"at\"\n            return f.loc[i]",
        "begin_line": 139,
        "end_line": 150,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.check_values#152",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.check_values(self, f, func, values=False)",
        "snippet": "    def check_values(self, f, func, values=False):\n\n        if f is None:\n            return\n        axes = f.axes\n        indicies = itertools.product(*axes)\n\n        for i in indicies:\n            result = getattr(f, func)[i]\n\n            # check against values\n            if values:\n                expected = f.values[i]\n            else:\n                expected = f\n                for a in reversed(i):\n                    expected = expected.__getitem__(a)\n\n            tm.assert_almost_equal(result, expected)",
        "begin_line": 152,
        "end_line": 170,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.check_result#172",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.check_result(self, method1, key1, method2, key2, typs=None, axes=None, fails=None)",
        "snippet": "    def check_result(\n        self, method1, key1, method2, key2, typs=None, axes=None, fails=None,\n    ):\n        def _eq(axis, obj, key1, key2):\n            \"\"\" compare equal for these 2 keys \"\"\"\n            if axis > obj.ndim - 1:\n                return\n\n            try:\n                rs = getattr(obj, method1).__getitem__(_axify(obj, key1, axis))\n\n                try:\n                    xp = self.get_result(obj=obj, method=method2, key=key2, axis=axis)\n                except (KeyError, IndexError):\n                    # TODO: why is this allowed?\n                    return\n\n                if is_scalar(rs) and is_scalar(xp):\n                    assert rs == xp\n                else:\n                    tm.assert_equal(rs, xp)\n\n            except (IndexError, TypeError, KeyError) as detail:\n\n                # if we are in fails, the ok, otherwise raise it\n                if fails is not None:\n                    if isinstance(detail, fails):\n                        result = f\"ok ({type(detail).__name__})\"\n                        return\n\n                result = type(detail).__name__\n                raise AssertionError(result, detail)\n\n        if typs is None:\n            typs = self._typs\n\n        if axes is None:\n            axes = [0, 1]\n        elif not isinstance(axes, (tuple, list)):\n            assert isinstance(axes, int)\n            axes = [axes]\n\n        # check\n        for kind in self._kinds:\n\n            d = getattr(self, kind)\n            for ax in axes:\n                for typ in typs:\n                    if typ not in self._typs:\n                        continue\n\n                    obj = d[typ]\n                    _eq(axis=ax, obj=obj, key1=key1, key2=key2)",
        "begin_line": 172,
        "end_line": 224,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base._eq#175",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base._eq(axis, obj, key1, key2)",
        "snippet": "        def _eq(axis, obj, key1, key2):\n            \"\"\" compare equal for these 2 keys \"\"\"\n            if axis > obj.ndim - 1:\n                return\n\n            try:\n                rs = getattr(obj, method1).__getitem__(_axify(obj, key1, axis))\n\n                try:\n                    xp = self.get_result(obj=obj, method=method2, key=key2, axis=axis)\n                except (KeyError, IndexError):\n                    # TODO: why is this allowed?\n                    return\n\n                if is_scalar(rs) and is_scalar(xp):\n                    assert rs == xp\n                else:\n                    tm.assert_equal(rs, xp)\n\n            except (IndexError, TypeError, KeyError) as detail:\n\n                # if we are in fails, the ok, otherwise raise it\n                if fails is not None:\n                    if isinstance(detail, fails):\n                        result = f\"ok ({type(detail).__name__})\"\n                        return\n\n                result = type(detail).__name__\n                raise AssertionError(result, detail)",
        "begin_line": 175,
        "end_line": 203,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar.test_at_and_iat_get#12",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar.test_at_and_iat_get(self)",
        "snippet": "    def test_at_and_iat_get(self):\n        def _check(f, func, values=False):\n\n            if f is not None:\n                indicies = self.generate_indices(f, values)\n                for i in indicies:\n                    result = getattr(f, func)[i]\n                    expected = self.get_value(func, f, i, values)\n                    tm.assert_almost_equal(result, expected)\n\n        for kind in self._kinds:\n\n            d = getattr(self, kind)\n\n            # iat\n            for f in [d[\"ints\"], d[\"uints\"]]:\n                _check(f, \"iat\", values=True)\n\n            for f in [d[\"labels\"], d[\"ts\"], d[\"floats\"]]:\n                if f is not None:\n                    msg = \"iAt based indexing can only have integer indexers\"\n                    with pytest.raises(ValueError, match=msg):\n                        self.check_values(f, \"iat\")\n\n            # at\n            for f in [d[\"ints\"], d[\"uints\"], d[\"labels\"], d[\"ts\"], d[\"floats\"]]:\n                _check(f, \"at\")",
        "begin_line": 12,
        "end_line": 38,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar._check#13",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar._check(f, func, values=False)",
        "snippet": "        def _check(f, func, values=False):\n\n            if f is not None:\n                indicies = self.generate_indices(f, values)\n                for i in indicies:\n                    result = getattr(f, func)[i]\n                    expected = self.get_value(func, f, i, values)\n                    tm.assert_almost_equal(result, expected)",
        "begin_line": 13,
        "end_line": 20,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar.test_at_and_iat_set#40",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar.test_at_and_iat_set(self)",
        "snippet": "    def test_at_and_iat_set(self):\n        def _check(f, func, values=False):\n\n            if f is not None:\n                indicies = self.generate_indices(f, values)\n                for i in indicies:\n                    getattr(f, func)[i] = 1\n                    expected = self.get_value(func, f, i, values)\n                    tm.assert_almost_equal(expected, 1)\n\n        for kind in self._kinds:\n\n            d = getattr(self, kind)\n\n            # iat\n            for f in [d[\"ints\"], d[\"uints\"]]:\n                _check(f, \"iat\", values=True)\n\n            for f in [d[\"labels\"], d[\"ts\"], d[\"floats\"]]:\n                if f is not None:\n                    msg = \"iAt based indexing can only have integer indexers\"\n                    with pytest.raises(ValueError, match=msg):\n                        _check(f, \"iat\")\n\n            # at\n            for f in [d[\"ints\"], d[\"uints\"], d[\"labels\"], d[\"ts\"], d[\"floats\"]]:\n                _check(f, \"at\")",
        "begin_line": 40,
        "end_line": 66,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar._check#41",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar._check(f, func, values=False)",
        "snippet": "        def _check(f, func, values=False):\n\n            if f is not None:\n                indicies = self.generate_indices(f, values)\n                for i in indicies:\n                    getattr(f, func)[i] = 1\n                    expected = self.get_value(func, f, i, values)\n                    tm.assert_almost_equal(expected, 1)",
        "begin_line": 41,
        "end_line": 48,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_at_iat_coercion#72",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_at_iat_coercion(self)",
        "snippet": "    def test_at_iat_coercion(self):\n\n        # as timestamp is not a tuple!\n        dates = date_range(\"1/1/2000\", periods=8)\n        df = DataFrame(np.random.randn(8, 4), index=dates, columns=[\"A\", \"B\", \"C\", \"D\"])\n        s = df[\"A\"]\n\n        result = s.at[dates[5]]\n        xp = s.values[5]\n        assert result == xp\n\n        # GH 7729\n        # make sure we are boxing the returns\n        s = Series([\"2014-01-01\", \"2014-02-02\"], dtype=\"datetime64[ns]\")\n        expected = Timestamp(\"2014-02-02\")\n\n        for r in [lambda: s.iat[1], lambda: s.iloc[1]]:\n            result = r()\n            assert result == expected\n\n        s = Series([\"1 days\", \"2 days\"], dtype=\"timedelta64[ns]\")\n        expected = Timedelta(\"2 days\")\n\n        for r in [lambda: s.iat[1], lambda: s.iloc[1]]:\n            result = r()\n            assert result == expected",
        "begin_line": 72,
        "end_line": 97,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_iat_invalid_args#99",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_iat_invalid_args(self)",
        "snippet": "    def test_iat_invalid_args(self):\n        pass",
        "begin_line": 99,
        "end_line": 100,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_imethods_with_dups#102",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_imethods_with_dups(self)",
        "snippet": "    def test_imethods_with_dups(self):\n\n        # GH6493\n        # iat/iloc with dups\n\n        s = Series(range(5), index=[1, 1, 2, 2, 3], dtype=\"int64\")\n        result = s.iloc[2]\n        assert result == 2\n        result = s.iat[2]\n        assert result == 2\n\n        msg = \"index 10 is out of bounds for axis 0 with size 5\"\n        with pytest.raises(IndexError, match=msg):\n            s.iat[10]\n        msg = \"index -10 is out of bounds for axis 0 with size 5\"\n        with pytest.raises(IndexError, match=msg):\n            s.iat[-10]\n\n        result = s.iloc[[2, 3]]\n        expected = Series([2, 3], [2, 2], dtype=\"int64\")\n        tm.assert_series_equal(result, expected)\n\n        df = s.to_frame()\n        result = df.iloc[2]\n        expected = Series(2, index=[0], name=2)\n        tm.assert_series_equal(result, expected)\n\n        result = df.iat[2, 0]\n        assert result == 2",
        "begin_line": 102,
        "end_line": 130,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_series_at_raises_type_error#132",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_series_at_raises_type_error(self)",
        "snippet": "    def test_series_at_raises_type_error(self):\n        # at should not fallback\n        # GH 7814\n        # GH#31724 .at should match .loc\n        ser = Series([1, 2, 3], index=list(\"abc\"))\n        result = ser.at[\"a\"]\n        assert result == 1\n        result = ser.loc[\"a\"]\n        assert result == 1\n\n        msg = (\n            \"cannot do label indexing on <class 'pandas.core.indexes.base.Index'> \"\n            r\"with these indexers \\[0\\] of <class 'int'>\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            ser.at[0]\n        with pytest.raises(TypeError, match=msg):\n            ser.loc[0]",
        "begin_line": 132,
        "end_line": 149,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_frame_raises_type_error#151",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_frame_raises_type_error(self)",
        "snippet": "    def test_frame_raises_type_error(self):\n        # GH#31724 .at should match .loc\n        df = DataFrame({\"A\": [1, 2, 3]}, index=list(\"abc\"))\n        result = df.at[\"a\", \"A\"]\n        assert result == 1\n        result = df.loc[\"a\", \"A\"]\n        assert result == 1\n\n        msg = (\n            \"cannot do label indexing on <class 'pandas.core.indexes.base.Index'> \"\n            r\"with these indexers \\[0\\] of <class 'int'>\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            df.at[\"a\", 0]\n        with pytest.raises(TypeError, match=msg):\n            df.loc[\"a\", 0]",
        "begin_line": 151,
        "end_line": 166,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_series_at_raises_key_error#168",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_series_at_raises_key_error(self)",
        "snippet": "    def test_series_at_raises_key_error(self):\n        # GH#31724 .at should match .loc\n\n        ser = Series([1, 2, 3], index=[3, 2, 1])\n        result = ser.at[1]\n        assert result == 3\n        result = ser.loc[1]\n        assert result == 3\n\n        with pytest.raises(KeyError, match=\"a\"):\n            ser.at[\"a\"]\n        with pytest.raises(KeyError, match=\"a\"):\n            # .at should match .loc\n            ser.loc[\"a\"]",
        "begin_line": 168,
        "end_line": 181,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_frame_at_raises_key_error#183",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_frame_at_raises_key_error(self)",
        "snippet": "    def test_frame_at_raises_key_error(self):\n        # GH#31724 .at should match .loc\n\n        df = DataFrame({0: [1, 2, 3]}, index=[3, 2, 1])\n\n        result = df.at[1, 0]\n        assert result == 3\n        result = df.loc[1, 0]\n        assert result == 3\n\n        with pytest.raises(KeyError, match=\"a\"):\n            df.at[\"a\", 0]\n        with pytest.raises(KeyError, match=\"a\"):\n            df.loc[\"a\", 0]\n\n        with pytest.raises(KeyError, match=\"a\"):\n            df.at[1, \"a\"]\n        with pytest.raises(KeyError, match=\"a\"):\n            df.loc[1, \"a\"]",
        "begin_line": 183,
        "end_line": 201,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_getitem_list_missing_key#204",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_getitem_list_missing_key(self)",
        "snippet": "    def test_getitem_list_missing_key(self):\n        # GH 13822, incorrect error string with non-unique columns when missing\n        # column is accessed\n        df = DataFrame({\"x\": [1.0], \"y\": [2.0], \"z\": [3.0]})\n        df.columns = [\"x\", \"x\", \"z\"]\n\n        # Check that we get the correct value in the KeyError\n        with pytest.raises(KeyError, match=r\"\\['y'\\] not in index\"):\n            df[[\"x\", \"y\", \"z\"]]",
        "begin_line": 204,
        "end_line": 212,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_at_with_tz#214",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_at_with_tz(self)",
        "snippet": "    def test_at_with_tz(self):\n        # gh-15822\n        df = DataFrame(\n            {\n                \"name\": [\"John\", \"Anderson\"],\n                \"date\": [\n                    Timestamp(2017, 3, 13, 13, 32, 56),\n                    Timestamp(2017, 2, 16, 12, 10, 3),\n                ],\n            }\n        )\n        df[\"date\"] = df[\"date\"].dt.tz_localize(\"Asia/Shanghai\")\n\n        expected = Timestamp(\"2017-03-13 13:32:56+0800\", tz=\"Asia/Shanghai\")\n\n        result = df.loc[0, \"date\"]\n        assert result == expected\n\n        result = df.at[0, \"date\"]\n        assert result == expected",
        "begin_line": 214,
        "end_line": 233,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_series_set_tz_timestamp#235",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_series_set_tz_timestamp(self, tz_naive_fixture)",
        "snippet": "    def test_series_set_tz_timestamp(self, tz_naive_fixture):\n        # GH 25506\n        ts = Timestamp(\"2017-08-05 00:00:00+0100\", tz=tz_naive_fixture)\n        result = Series(ts)\n        result.at[1] = ts\n        expected = Series([ts, ts])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 235,
        "end_line": 241,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_mixed_index_at_iat_loc_iloc_series#243",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_mixed_index_at_iat_loc_iloc_series(self)",
        "snippet": "    def test_mixed_index_at_iat_loc_iloc_series(self):\n        # GH 19860\n        s = Series([1, 2, 3, 4, 5], index=[\"a\", \"b\", \"c\", 1, 2])\n        for el, item in s.items():\n            assert s.at[el] == s.loc[el] == item\n        for i in range(len(s)):\n            assert s.iat[i] == s.iloc[i] == i + 1\n\n        with pytest.raises(KeyError, match=\"^4$\"):\n            s.at[4]\n        with pytest.raises(KeyError, match=\"^4$\"):\n            s.loc[4]",
        "begin_line": 243,
        "end_line": 254,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_mixed_index_at_iat_loc_iloc_dataframe#256",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_mixed_index_at_iat_loc_iloc_dataframe(self)",
        "snippet": "    def test_mixed_index_at_iat_loc_iloc_dataframe(self):\n        # GH 19860\n        df = DataFrame(\n            [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]], columns=[\"a\", \"b\", \"c\", 1, 2]\n        )\n        for rowIdx, row in df.iterrows():\n            for el, item in row.items():\n                assert df.at[rowIdx, el] == df.loc[rowIdx, el] == item\n\n        for row in range(2):\n            for i in range(5):\n                assert df.iat[row, i] == df.iloc[row, i] == row * 5 + i\n\n        with pytest.raises(KeyError, match=\"^3$\"):\n            df.at[0, 3]\n        with pytest.raises(KeyError, match=\"^3$\"):\n            df.loc[0, 3]",
        "begin_line": 256,
        "end_line": 272,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_iat_setter_incompatible_assignment#274",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_iat_setter_incompatible_assignment(self)",
        "snippet": "    def test_iat_setter_incompatible_assignment(self):\n        # GH 23236\n        result = DataFrame({\"a\": [0, 1], \"b\": [4, 5]})\n        result.iat[0, 0] = None\n        expected = DataFrame({\"a\": [None, 1], \"b\": [4, 5]})\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 274,
        "end_line": 279,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_scalar.TestScalar2.test_getitem_zerodim_np_array#281",
        "src_path": "pandas/tests/indexing/test_scalar.py",
        "class_name": "pandas.tests.indexing.test_scalar.TestScalar2",
        "signature": "pandas.tests.indexing.test_scalar.TestScalar2.test_getitem_zerodim_np_array(self)",
        "snippet": "    def test_getitem_zerodim_np_array(self):\n        # GH24924\n        # dataframe __getitem__\n        df = DataFrame([[1, 2], [3, 4]])\n        result = df[np.array(0)]\n        expected = Series([1, 3], name=0)\n        tm.assert_series_equal(result, expected)\n\n        # series __getitem__\n        s = Series([1, 2])\n        result = s[np.array(0)]\n        assert result == 1",
        "begin_line": 281,
        "end_line": 292,
        "comment": "",
        "is_bug": false
    }
]