[
    {
        "name": "test.helpers.with_config.__init__#90",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.with_config",
        "signature": "test.helpers.with_config.__init__(self, config, replace_sections=False)",
        "snippet": "    def __init__(self, config, replace_sections=False):\n        self.config = config\n        self.replace_sections = replace_sections",
        "begin_line": 90,
        "end_line": 92,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.with_config._make_dict#94",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.with_config",
        "signature": "test.helpers.with_config._make_dict(self, old_dict)",
        "snippet": "    def _make_dict(self, old_dict):\n        if self.replace_sections:\n            old_dict.update(self.config)\n            return old_dict\n\n        def get_section(sec):\n            old_sec = old_dict.get(sec, {})\n            new_sec = self.config.get(sec, {})\n            old_sec.update(new_sec)\n            return old_sec\n\n        all_sections = itertools.chain(old_dict.keys(), self.config.keys())\n        return {sec: get_section(sec) for sec in all_sections}",
        "begin_line": 94,
        "end_line": 106,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.with_config.get_section#99",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.with_config",
        "signature": "test.helpers.with_config.get_section(sec)",
        "snippet": "        def get_section(sec):\n            old_sec = old_dict.get(sec, {})\n            new_sec = self.config.get(sec, {})\n            old_sec.update(new_sec)\n            return old_sec",
        "begin_line": 99,
        "end_line": 103,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.with_config.__call__#108",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.with_config",
        "signature": "test.helpers.with_config.__call__(self, fun)",
        "snippet": "    def __call__(self, fun):\n        @functools.wraps(fun)\n        def wrapper(*args, **kwargs):\n            import luigi.configuration\n            orig_conf = luigi.configuration.LuigiConfigParser.instance()\n            new_conf = luigi.configuration.LuigiConfigParser()\n            luigi.configuration.LuigiConfigParser._instance = new_conf\n            orig_dict = {k: dict(orig_conf.items(k)) for k in orig_conf.sections()}\n            new_dict = self._make_dict(orig_dict)\n            for (section, settings) in six.iteritems(new_dict):\n                new_conf.add_section(section)\n                for (name, value) in six.iteritems(settings):\n                    new_conf.set(section, name, value)\n            try:\n                return fun(*args, **kwargs)\n            finally:\n                luigi.configuration.LuigiConfigParser._instance = orig_conf\n        return wrapper",
        "begin_line": 108,
        "end_line": 125,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.with_config.wrapper#110",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.with_config",
        "signature": "test.helpers.with_config.wrapper(*args, **kwargs)",
        "snippet": "        def wrapper(*args, **kwargs):\n            import luigi.configuration\n            orig_conf = luigi.configuration.LuigiConfigParser.instance()\n            new_conf = luigi.configuration.LuigiConfigParser()\n            luigi.configuration.LuigiConfigParser._instance = new_conf\n            orig_dict = {k: dict(orig_conf.items(k)) for k in orig_conf.sections()}\n            new_dict = self._make_dict(orig_dict)\n            for (section, settings) in six.iteritems(new_dict):\n                new_conf.add_section(section)\n                for (name, value) in six.iteritems(settings):\n                    new_conf.set(section, name, value)\n            try:\n                return fun(*args, **kwargs)\n            finally:\n                luigi.configuration.LuigiConfigParser._instance = orig_conf",
        "begin_line": 110,
        "end_line": 124,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.RunOnceTask.__init__#130",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.RunOnceTask",
        "signature": "test.helpers.RunOnceTask.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        super(RunOnceTask, self).__init__(*args, **kwargs)\n        self.comp = False",
        "begin_line": 130,
        "end_line": 132,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.RunOnceTask.complete#134",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.RunOnceTask",
        "signature": "test.helpers.RunOnceTask.complete(self)",
        "snippet": "    def complete(self):\n        return self.comp",
        "begin_line": 134,
        "end_line": 135,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.RunOnceTask.run#137",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.RunOnceTask",
        "signature": "test.helpers.RunOnceTask.run(self)",
        "snippet": "    def run(self):\n        self.comp = True",
        "begin_line": 137,
        "end_line": 138,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.LuigiTestCase.setUp#145",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.LuigiTestCase",
        "signature": "test.helpers.LuigiTestCase.setUp(self)",
        "snippet": "    def setUp(self):\n        super(LuigiTestCase, self).setUp()\n        self._stashed_reg = luigi.task_register.Register._get_reg()",
        "begin_line": 145,
        "end_line": 147,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.LuigiTestCase.tearDown#149",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.LuigiTestCase",
        "signature": "test.helpers.LuigiTestCase.tearDown(self)",
        "snippet": "    def tearDown(self):\n        luigi.task_register.Register._set_reg(self._stashed_reg)\n        super(LuigiTestCase, self).tearDown()",
        "begin_line": 149,
        "end_line": 151,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.LuigiTestCase.run_locally#153",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.LuigiTestCase",
        "signature": "test.helpers.LuigiTestCase.run_locally(self, args)",
        "snippet": "    def run_locally(self, args):\n        \"\"\" Helper for running tests testing more of the stack, the command\n        line parsing and task from name intstantiation parts in particular. \"\"\"\n        temp = CmdlineParser._instance\n        try:\n            CmdlineParser._instance = None\n            run_exit_status = luigi.run(['--local-scheduler', '--no-lock'] + args)\n        finally:\n            CmdlineParser._instance = temp\n        return run_exit_status",
        "begin_line": 153,
        "end_line": 162,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.LuigiTestCase.run_locally_split#164",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.LuigiTestCase",
        "signature": "test.helpers.LuigiTestCase.run_locally_split(self, space_seperated_args)",
        "snippet": "    def run_locally_split(self, space_seperated_args):\n        \"\"\" Helper for running tests testing more of the stack, the command\n        line parsing and task from name intstantiation parts in particular. \"\"\"\n        return self.run_locally(space_seperated_args.split(' '))",
        "begin_line": 164,
        "end_line": 167,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.parsing.__call__#178",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.parsing",
        "signature": "test.helpers.parsing.__call__(self, fun)",
        "snippet": "    def __call__(self, fun):\n        @functools.wraps(fun)\n        def wrapper(*args, **kwargs):\n            with CmdlineParser.global_instance(self.cmds, allow_override=True):\n                return fun(*args, **kwargs)\n\n        return wrapper",
        "begin_line": 178,
        "end_line": 184,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.parsing.wrapper#180",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.parsing",
        "signature": "test.helpers.parsing.wrapper(*args, **kwargs)",
        "snippet": "        def wrapper(*args, **kwargs):\n            with CmdlineParser.global_instance(self.cmds, allow_override=True):\n                return fun(*args, **kwargs)",
        "begin_line": 180,
        "end_line": 182,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.in_parse#187",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers",
        "signature": "test.helpers.in_parse(cmds, deferred_computation)",
        "snippet": "def in_parse(cmds, deferred_computation):\n    with CmdlineParser.global_instance(cmds) as cp:\n        deferred_computation(cp.get_task_obj())",
        "begin_line": 187,
        "end_line": 189,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.temporary_unloaded_module#193",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers",
        "signature": "test.helpers.temporary_unloaded_module(python_file_contents)",
        "snippet": "def temporary_unloaded_module(python_file_contents):\n    \"\"\" Create an importable module\n\n    Return the name of importable module name given its file contents (source\n    code) \"\"\"\n    with tempfile.NamedTemporaryFile(\n            dir='test/',\n            prefix=\"_test_time_generated_module\",\n            suffix='.py') as temp_module_file:\n        temp_module_file.file.write(python_file_contents)\n        temp_module_file.file.flush()\n        temp_module_path = temp_module_file.name\n        temp_module_name = re.search(r'/(_test_time_generated_module.*).py',\n                                     temp_module_path).group(1)\n        yield temp_module_name",
        "begin_line": 193,
        "end_line": 207,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.other_module.OtherModuleTask.output#24",
        "src_path": "test/other_module.py",
        "class_name": "test.other_module.OtherModuleTask",
        "signature": "test.other_module.OtherModuleTask.output(self)",
        "snippet": "    def output(self):\n        return luigi.LocalTarget(self.p)",
        "begin_line": 24,
        "end_line": 25,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.other_module.OtherModuleTask.run#27",
        "src_path": "test/other_module.py",
        "class_name": "test.other_module.OtherModuleTask",
        "signature": "test.other_module.OtherModuleTask.run(self)",
        "snippet": "    def run(self):\n        with self.output().open('w') as f:\n            f.write('Done!')",
        "begin_line": 27,
        "end_line": 29,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.scheduler_test.SchedulerIoTest.test_load_old_state#30",
        "src_path": "test/scheduler_test.py",
        "class_name": "test.scheduler_test.SchedulerIoTest",
        "signature": "test.scheduler_test.SchedulerIoTest.test_load_old_state(self)",
        "snippet": "    def test_load_old_state(self):\n        tasks = {}\n        active_workers = {'Worker1': 1e9, 'Worker2': time.time()}\n\n        with tempfile.NamedTemporaryFile(delete=True) as fn:\n            with open(fn.name, 'wb') as fobj:\n                state = (tasks, active_workers)\n                pickle.dump(state, fobj)\n\n            state = luigi.scheduler.SimpleTaskState(\n                state_path=fn.name)\n            state.load()\n\n            self.assertEqual(set(state.get_worker_ids()),\n                             set(['Worker1', 'Worker2']))",
        "begin_line": 30,
        "end_line": 44,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.scheduler_test.SchedulerIoTest.test_load_broken_state#46",
        "src_path": "test/scheduler_test.py",
        "class_name": "test.scheduler_test.SchedulerIoTest",
        "signature": "test.scheduler_test.SchedulerIoTest.test_load_broken_state(self)",
        "snippet": "    def test_load_broken_state(self):\n        with tempfile.NamedTemporaryFile(delete=True) as fn:\n            with open(fn.name, 'w') as fobj:\n                print(\"b0rk\", file=fobj)\n\n            state = luigi.scheduler.SimpleTaskState(\n                state_path=fn.name)\n            state.load()  # bad if this crashes\n\n            self.assertEqual(list(state.get_worker_ids()), [])",
        "begin_line": 46,
        "end_line": 55,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.scheduler_test.SchedulerIoTest.test_scheduler_with_config#58",
        "src_path": "test/scheduler_test.py",
        "class_name": "test.scheduler_test.SchedulerIoTest",
        "signature": "test.scheduler_test.SchedulerIoTest.test_scheduler_with_config(self)",
        "snippet": "    def test_scheduler_with_config(self):\n        scheduler = luigi.scheduler.Scheduler()\n        self.assertEqual(44, scheduler._config.retry_count)\n        self.assertEqual(55, scheduler._config.worker_disconnect_delay)\n\n        # Override\n        scheduler = luigi.scheduler.Scheduler(retry_count=66,\n                                              worker_disconnect_delay=77)\n        self.assertEqual(66, scheduler._config.retry_count)\n        self.assertEqual(77, scheduler._config.worker_disconnect_delay)",
        "begin_line": 58,
        "end_line": 67,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.scheduler_test.SchedulerIoTest.test_scheduler_with_resources#70",
        "src_path": "test/scheduler_test.py",
        "class_name": "test.scheduler_test.SchedulerIoTest",
        "signature": "test.scheduler_test.SchedulerIoTest.test_scheduler_with_resources(self)",
        "snippet": "    def test_scheduler_with_resources(self):\n        scheduler = luigi.scheduler.Scheduler()\n        self.assertEqual({'a': 100, 'b': 200}, scheduler._resources)",
        "begin_line": 70,
        "end_line": 72,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.scheduler_test.SchedulerIoTest.test_local_scheduler_task_history_status#76",
        "src_path": "test/scheduler_test.py",
        "class_name": "test.scheduler_test.SchedulerIoTest",
        "signature": "test.scheduler_test.SchedulerIoTest.test_local_scheduler_task_history_status(self)",
        "snippet": "    def test_local_scheduler_task_history_status(self):\n        ls = luigi.interface._WorkerSchedulerFactory().create_local_scheduler()\n        self.assertEqual(False, ls._config.record_task_history)",
        "begin_line": 76,
        "end_line": 78,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.scheduler_test.SchedulerIoTest.test_load_recovers_tasks_index#80",
        "src_path": "test/scheduler_test.py",
        "class_name": "test.scheduler_test.SchedulerIoTest",
        "signature": "test.scheduler_test.SchedulerIoTest.test_load_recovers_tasks_index(self)",
        "snippet": "    def test_load_recovers_tasks_index(self):\n        scheduler = luigi.scheduler.Scheduler()\n        scheduler.add_task(worker='A', task_id='1')\n        scheduler.add_task(worker='B', task_id='2')\n        scheduler.add_task(worker='C', task_id='3')\n        scheduler.add_task(worker='D', task_id='4')\n        self.assertEqual(scheduler.get_work(worker='A')['task_id'], '1')\n\n        with tempfile.NamedTemporaryFile(delete=True) as fn:\n            def reload_from_disk(scheduler):\n                scheduler._state._state_path = fn.name\n                scheduler.dump()\n                scheduler = luigi.scheduler.Scheduler()\n                scheduler._state._state_path = fn.name\n                scheduler.load()\n                return scheduler\n            scheduler = reload_from_disk(scheduler=scheduler)\n            self.assertEqual(scheduler.get_work(worker='B')['task_id'], '2')\n            self.assertEqual(scheduler.get_work(worker='C')['task_id'], '3')\n            scheduler = reload_from_disk(scheduler=scheduler)\n            self.assertEqual(scheduler.get_work(worker='D')['task_id'], '4')",
        "begin_line": 80,
        "end_line": 100,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.scheduler_test.SchedulerIoTest.reload_from_disk#89",
        "src_path": "test/scheduler_test.py",
        "class_name": "test.scheduler_test.SchedulerIoTest",
        "signature": "test.scheduler_test.SchedulerIoTest.reload_from_disk(scheduler)",
        "snippet": "            def reload_from_disk(scheduler):\n                scheduler._state._state_path = fn.name\n                scheduler.dump()\n                scheduler = luigi.scheduler.Scheduler()\n                scheduler._state._state_path = fn.name\n                scheduler.load()\n                return scheduler",
        "begin_line": 89,
        "end_line": 95,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.scheduler_test.SchedulerIoTest.test_worker_prune_after_init#102",
        "src_path": "test/scheduler_test.py",
        "class_name": "test.scheduler_test.SchedulerIoTest",
        "signature": "test.scheduler_test.SchedulerIoTest.test_worker_prune_after_init(self)",
        "snippet": "    def test_worker_prune_after_init(self):\n        \"\"\"\n        See https://github.com/spotify/luigi/pull/1019\n        \"\"\"\n        worker = luigi.scheduler.Worker(123)\n\n        class TmpCfg:\n            def __init__(self):\n                self.worker_disconnect_delay = 10\n\n        worker.prune(TmpCfg())",
        "begin_line": 102,
        "end_line": 112,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.scheduler_test.TmpCfg.test_worker_prune_after_init#102",
        "src_path": "test/scheduler_test.py",
        "class_name": "test.scheduler_test.TmpCfg",
        "signature": "test.scheduler_test.TmpCfg.test_worker_prune_after_init(self)",
        "snippet": "    def test_worker_prune_after_init(self):\n        \"\"\"\n        See https://github.com/spotify/luigi/pull/1019\n        \"\"\"\n        worker = luigi.scheduler.Worker(123)\n\n        class TmpCfg:\n            def __init__(self):\n                self.worker_disconnect_delay = 10\n\n        worker.prune(TmpCfg())",
        "begin_line": 102,
        "end_line": 112,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.scheduler_test.TmpCfg.__init__#109",
        "src_path": "test/scheduler_test.py",
        "class_name": "test.scheduler_test.TmpCfg",
        "signature": "test.scheduler_test.TmpCfg.__init__(self)",
        "snippet": "            def __init__(self):\n                self.worker_disconnect_delay = 10",
        "begin_line": 109,
        "end_line": 110,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.scheduler_test.SchedulerIoTest.test_get_empty_retry_policy#114",
        "src_path": "test/scheduler_test.py",
        "class_name": "test.scheduler_test.SchedulerIoTest",
        "signature": "test.scheduler_test.SchedulerIoTest.test_get_empty_retry_policy(self)",
        "snippet": "    def test_get_empty_retry_policy(self):\n        retry_policy = luigi.scheduler._get_empty_retry_policy()\n        self.assertEqual(3, len(retry_policy))\n        self.assertEqual([\"retry_count\", \"disable_hard_timeout\", \"disable_window\"], list(retry_policy._asdict().keys()))\n        self.assertEqual([None, None, None], list(retry_policy._asdict().values()))",
        "begin_line": 114,
        "end_line": 118,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.scheduler_test.SchedulerIoTest.test_scheduler_get_retry_policy#121",
        "src_path": "test/scheduler_test.py",
        "class_name": "test.scheduler_test.SchedulerIoTest",
        "signature": "test.scheduler_test.SchedulerIoTest.test_scheduler_get_retry_policy(self)",
        "snippet": "    def test_scheduler_get_retry_policy(self):\n        s = luigi.scheduler.Scheduler()\n        self.assertEqual(luigi.scheduler.RetryPolicy(9, 99, 999), s._config._get_retry_policy())",
        "begin_line": 121,
        "end_line": 123,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.scheduler_test.SchedulerIoTest.test_generate_retry_policy#126",
        "src_path": "test/scheduler_test.py",
        "class_name": "test.scheduler_test.SchedulerIoTest",
        "signature": "test.scheduler_test.SchedulerIoTest.test_generate_retry_policy(self)",
        "snippet": "    def test_generate_retry_policy(self):\n        s = luigi.scheduler.Scheduler()\n\n        try:\n            s._generate_retry_policy({'inexist_attr': True})\n            self.assertFalse(True, \"'unexpected keyword argument' error must have been thrown\")\n        except TypeError:\n            self.assertTrue(True)\n\n        retry_policy = s._generate_retry_policy({})\n        self.assertEqual(luigi.scheduler.RetryPolicy(9, 99, 999), retry_policy)\n\n        retry_policy = s._generate_retry_policy({'retry_count': 1})\n        self.assertEqual(luigi.scheduler.RetryPolicy(1, 99, 999), retry_policy)\n\n        retry_policy = s._generate_retry_policy({'retry_count': 1, 'disable_hard_timeout': 11, 'disable_window': 111})\n        self.assertEqual(luigi.scheduler.RetryPolicy(1, 11, 111), retry_policy)",
        "begin_line": 126,
        "end_line": 142,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.scheduler_test.SchedulerIoTest.test_per_task_retry_policy#145",
        "src_path": "test/scheduler_test.py",
        "class_name": "test.scheduler_test.SchedulerIoTest",
        "signature": "test.scheduler_test.SchedulerIoTest.test_per_task_retry_policy(self)",
        "snippet": "    def test_per_task_retry_policy(self):\n        cps = luigi.scheduler.Scheduler()\n\n        cps.add_task(worker='test_worker1', task_id='test_task_1', deps=['test_task_2', 'test_task_3'])\n        tasks = list(cps._state.get_active_tasks())\n        self.assertEqual(3, len(tasks))\n\n        tasks = sorted(tasks, key=lambda x: x.id)\n        task_1 = tasks[0]\n        task_2 = tasks[1]\n        task_3 = tasks[2]\n\n        self.assertEqual('test_task_1', task_1.id)\n        self.assertEqual('test_task_2', task_2.id)\n        self.assertEqual('test_task_3', task_3.id)\n\n        self.assertEqual(luigi.scheduler.RetryPolicy(44, 999999999, 3600), task_1.retry_policy)\n        self.assertEqual(luigi.scheduler.RetryPolicy(44, 999999999, 3600), task_2.retry_policy)\n        self.assertEqual(luigi.scheduler.RetryPolicy(44, 999999999, 3600), task_3.retry_policy)\n\n        cps._state._tasks = {}\n        cps.add_task(worker='test_worker2', task_id='test_task_4', deps=['test_task_5', 'test_task_6'],\n                     retry_policy_dict=luigi.scheduler.RetryPolicy(99, 999, 9999)._asdict())\n\n        tasks = list(cps._state.get_active_tasks())\n        self.assertEqual(3, len(tasks))\n\n        tasks = sorted(tasks, key=lambda x: x.id)\n        task_4 = tasks[0]\n        task_5 = tasks[1]\n        task_6 = tasks[2]\n\n        self.assertEqual('test_task_4', task_4.id)\n        self.assertEqual('test_task_5', task_5.id)\n        self.assertEqual('test_task_6', task_6.id)\n\n        self.assertEqual(luigi.scheduler.RetryPolicy(99, 999, 9999), task_4.retry_policy)\n        self.assertEqual(luigi.scheduler.RetryPolicy(44, 999999999, 3600), task_5.retry_policy)\n        self.assertEqual(luigi.scheduler.RetryPolicy(44, 999999999, 3600), task_6.retry_policy)\n\n        cps._state._tasks = {}\n        cps.add_task(worker='test_worker3', task_id='test_task_7', deps=['test_task_8', 'test_task_9'])\n        cps.add_task(worker='test_worker3', task_id='test_task_8', retry_policy_dict=luigi.scheduler.RetryPolicy(99, 999, 9999)._asdict())\n        cps.add_task(worker='test_worker3', task_id='test_task_9', retry_policy_dict=luigi.scheduler.RetryPolicy(11, 111, 1111)._asdict())\n\n        tasks = list(cps._state.get_active_tasks())\n        self.assertEqual(3, len(tasks))\n\n        tasks = sorted(tasks, key=lambda x: x.id)\n        task_7 = tasks[0]\n        task_8 = tasks[1]\n        task_9 = tasks[2]\n\n        self.assertEqual('test_task_7', task_7.id)\n        self.assertEqual('test_task_8', task_8.id)\n        self.assertEqual('test_task_9', task_9.id)\n\n        self.assertEqual(luigi.scheduler.RetryPolicy(44, 999999999, 3600), task_7.retry_policy)\n        self.assertEqual(luigi.scheduler.RetryPolicy(99, 999, 9999), task_8.retry_policy)\n        self.assertEqual(luigi.scheduler.RetryPolicy(11, 111, 1111), task_9.retry_policy)\n\n        # Task 7 which is disable-failures 44 and its has_excessive_failures method returns False under 44\n        for i in range(43):\n            task_7.add_failure()\n        self.assertFalse(task_7.has_excessive_failures())\n        task_7.add_failure()\n        self.assertTrue(task_7.has_excessive_failures())\n\n        # Task 8 which is disable-failures 99 and its has_excessive_failures method returns False under 44\n        for i in range(98):\n            task_8.add_failure()\n        self.assertFalse(task_8.has_excessive_failures())\n        task_8.add_failure()\n        self.assertTrue(task_8.has_excessive_failures())\n\n        # Task 9 which is disable-failures 1 and its has_excessive_failures method returns False under 44\n        for i in range(10):\n            task_9.add_failure()\n        self.assertFalse(task_9.has_excessive_failures())\n        task_9.add_failure()\n        self.assertTrue(task_9.has_excessive_failures())",
        "begin_line": 145,
        "end_line": 225,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.scheduler_test.SchedulerWorkerTest.get_pending_ids#229",
        "src_path": "test/scheduler_test.py",
        "class_name": "test.scheduler_test.SchedulerWorkerTest",
        "signature": "test.scheduler_test.SchedulerWorkerTest.get_pending_ids(self, worker, state)",
        "snippet": "    def get_pending_ids(self, worker, state):\n        return {task.id for task in worker.get_pending_tasks(state)}",
        "begin_line": 229,
        "end_line": 230,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.scheduler_test.SchedulerWorkerTest.test_get_pending_tasks_with_many_done_tasks#232",
        "src_path": "test/scheduler_test.py",
        "class_name": "test.scheduler_test.SchedulerWorkerTest",
        "signature": "test.scheduler_test.SchedulerWorkerTest.test_get_pending_tasks_with_many_done_tasks(self)",
        "snippet": "    def test_get_pending_tasks_with_many_done_tasks(self):\n        sch = luigi.scheduler.Scheduler()\n        sch.add_task(worker='NON_TRIVIAL', task_id='A', resources={'a': 1})\n        sch.add_task(worker='TRIVIAL', task_id='B', status='PENDING')\n        sch.add_task(worker='TRIVIAL', task_id='C', status='DONE')\n        sch.add_task(worker='TRIVIAL', task_id='D', status='DONE')\n\n        scheduler_state = sch._state\n        trivial_worker = scheduler_state.get_worker('TRIVIAL')\n        self.assertEqual({'B'}, self.get_pending_ids(trivial_worker, scheduler_state))\n\n        non_trivial_worker = scheduler_state.get_worker('NON_TRIVIAL')\n        self.assertEqual({'A'}, self.get_pending_ids(non_trivial_worker, scheduler_state))",
        "begin_line": 232,
        "end_line": 244,
        "comment": "",
        "is_bug": false
    }
]