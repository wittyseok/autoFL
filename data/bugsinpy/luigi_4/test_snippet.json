[
    {
        "name": "test.helpers.with_config.__init__#90",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.with_config",
        "signature": "test.helpers.with_config.__init__(self, config, replace_sections=False)",
        "snippet": "    def __init__(self, config, replace_sections=False):\n        self.config = config\n        self.replace_sections = replace_sections",
        "begin_line": 90,
        "end_line": 92,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.with_config._make_dict#94",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.with_config",
        "signature": "test.helpers.with_config._make_dict(self, old_dict)",
        "snippet": "    def _make_dict(self, old_dict):\n        if self.replace_sections:\n            old_dict.update(self.config)\n            return old_dict\n\n        def get_section(sec):\n            old_sec = old_dict.get(sec, {})\n            new_sec = self.config.get(sec, {})\n            old_sec.update(new_sec)\n            return old_sec\n\n        all_sections = itertools.chain(old_dict.keys(), self.config.keys())\n        return {sec: get_section(sec) for sec in all_sections}",
        "begin_line": 94,
        "end_line": 106,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.with_config.get_section#99",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.with_config",
        "signature": "test.helpers.with_config.get_section(sec)",
        "snippet": "        def get_section(sec):\n            old_sec = old_dict.get(sec, {})\n            new_sec = self.config.get(sec, {})\n            old_sec.update(new_sec)\n            return old_sec",
        "begin_line": 99,
        "end_line": 103,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.with_config.__call__#108",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.with_config",
        "signature": "test.helpers.with_config.__call__(self, fun)",
        "snippet": "    def __call__(self, fun):\n        @functools.wraps(fun)\n        def wrapper(*args, **kwargs):\n            import luigi.configuration\n            orig_conf = luigi.configuration.LuigiConfigParser.instance()\n            new_conf = luigi.configuration.LuigiConfigParser()\n            luigi.configuration.LuigiConfigParser._instance = new_conf\n            orig_dict = {k: dict(orig_conf.items(k)) for k in orig_conf.sections()}\n            new_dict = self._make_dict(orig_dict)\n            for (section, settings) in six.iteritems(new_dict):\n                new_conf.add_section(section)\n                for (name, value) in six.iteritems(settings):\n                    new_conf.set(section, name, value)\n            try:\n                return fun(*args, **kwargs)\n            finally:\n                luigi.configuration.LuigiConfigParser._instance = orig_conf\n        return wrapper",
        "begin_line": 108,
        "end_line": 125,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.with_config.wrapper#110",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.with_config",
        "signature": "test.helpers.with_config.wrapper(*args, **kwargs)",
        "snippet": "        def wrapper(*args, **kwargs):\n            import luigi.configuration\n            orig_conf = luigi.configuration.LuigiConfigParser.instance()\n            new_conf = luigi.configuration.LuigiConfigParser()\n            luigi.configuration.LuigiConfigParser._instance = new_conf\n            orig_dict = {k: dict(orig_conf.items(k)) for k in orig_conf.sections()}\n            new_dict = self._make_dict(orig_dict)\n            for (section, settings) in six.iteritems(new_dict):\n                new_conf.add_section(section)\n                for (name, value) in six.iteritems(settings):\n                    new_conf.set(section, name, value)\n            try:\n                return fun(*args, **kwargs)\n            finally:\n                luigi.configuration.LuigiConfigParser._instance = orig_conf",
        "begin_line": 110,
        "end_line": 124,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.RunOnceTask.__init__#130",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.RunOnceTask",
        "signature": "test.helpers.RunOnceTask.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        super(RunOnceTask, self).__init__(*args, **kwargs)\n        self.comp = False",
        "begin_line": 130,
        "end_line": 132,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.RunOnceTask.complete#134",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.RunOnceTask",
        "signature": "test.helpers.RunOnceTask.complete(self)",
        "snippet": "    def complete(self):\n        return self.comp",
        "begin_line": 134,
        "end_line": 135,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.RunOnceTask.run#137",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.RunOnceTask",
        "signature": "test.helpers.RunOnceTask.run(self)",
        "snippet": "    def run(self):\n        self.comp = True",
        "begin_line": 137,
        "end_line": 138,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.LuigiTestCase.setUp#147",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.LuigiTestCase",
        "signature": "test.helpers.LuigiTestCase.setUp(self)",
        "snippet": "    def setUp(self):\n        super(LuigiTestCase, self).setUp()\n        self._stashed_reg = luigi.task_register.Register._get_reg()\n        luigi.task_register.Register.clear_instance_cache()",
        "begin_line": 147,
        "end_line": 150,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.LuigiTestCase.tearDown#152",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.LuigiTestCase",
        "signature": "test.helpers.LuigiTestCase.tearDown(self)",
        "snippet": "    def tearDown(self):\n        luigi.task_register.Register._set_reg(self._stashed_reg)\n        super(LuigiTestCase, self).tearDown()\n        luigi.task_register.Register.clear_instance_cache()",
        "begin_line": 152,
        "end_line": 155,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.LuigiTestCase.run_locally#157",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.LuigiTestCase",
        "signature": "test.helpers.LuigiTestCase.run_locally(self, args)",
        "snippet": "    def run_locally(self, args):\n        \"\"\" Helper for running tests testing more of the stack, the command\n        line parsing and task from name intstantiation parts in particular. \"\"\"\n        temp = CmdlineParser._instance\n        try:\n            CmdlineParser._instance = None\n            run_exit_status = luigi.run(['--local-scheduler', '--no-lock'] + args)\n        finally:\n            CmdlineParser._instance = temp\n        return run_exit_status",
        "begin_line": 157,
        "end_line": 166,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.LuigiTestCase.run_locally_split#168",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.LuigiTestCase",
        "signature": "test.helpers.LuigiTestCase.run_locally_split(self, space_seperated_args)",
        "snippet": "    def run_locally_split(self, space_seperated_args):\n        \"\"\" Helper for running tests testing more of the stack, the command\n        line parsing and task from name intstantiation parts in particular. \"\"\"\n        return self.run_locally(space_seperated_args.split(' '))",
        "begin_line": 168,
        "end_line": 171,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.parsing.__call__#182",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.parsing",
        "signature": "test.helpers.parsing.__call__(self, fun)",
        "snippet": "    def __call__(self, fun):\n        @functools.wraps(fun)\n        def wrapper(*args, **kwargs):\n            with CmdlineParser.global_instance(self.cmds, allow_override=True):\n                return fun(*args, **kwargs)\n\n        return wrapper",
        "begin_line": 182,
        "end_line": 188,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.parsing.wrapper#184",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.parsing",
        "signature": "test.helpers.parsing.wrapper(*args, **kwargs)",
        "snippet": "        def wrapper(*args, **kwargs):\n            with CmdlineParser.global_instance(self.cmds, allow_override=True):\n                return fun(*args, **kwargs)",
        "begin_line": 184,
        "end_line": 186,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.in_parse#191",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers",
        "signature": "test.helpers.in_parse(cmds, deferred_computation)",
        "snippet": "def in_parse(cmds, deferred_computation):\n    with CmdlineParser.global_instance(cmds) as cp:\n        deferred_computation(cp.get_task_obj())",
        "begin_line": 191,
        "end_line": 193,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.temporary_unloaded_module#197",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers",
        "signature": "test.helpers.temporary_unloaded_module(python_file_contents)",
        "snippet": "def temporary_unloaded_module(python_file_contents):\n    \"\"\" Create an importable module\n\n    Return the name of importable module name given its file contents (source\n    code) \"\"\"\n    with tempfile.NamedTemporaryFile(\n            dir='test/',\n            prefix=\"_test_time_generated_module\",\n            suffix='.py') as temp_module_file:\n        temp_module_file.file.write(python_file_contents)\n        temp_module_file.file.flush()\n        temp_module_path = temp_module_file.name\n        temp_module_name = re.search(r'/(_test_time_generated_module.*).py',\n                                     temp_module_path).group(1)\n        yield temp_module_name",
        "begin_line": 197,
        "end_line": 211,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.other_module.OtherModuleTask.output#24",
        "src_path": "test/other_module.py",
        "class_name": "test.other_module.OtherModuleTask",
        "signature": "test.other_module.OtherModuleTask.output(self)",
        "snippet": "    def output(self):\n        return luigi.LocalTarget(self.p)",
        "begin_line": 24,
        "end_line": 25,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.other_module.OtherModuleTask.run#27",
        "src_path": "test/other_module.py",
        "class_name": "test.other_module.OtherModuleTask",
        "signature": "test.other_module.OtherModuleTask.run(self)",
        "snippet": "    def run(self):\n        with self.output().open('w') as f:\n            f.write('Done!')",
        "begin_line": 27,
        "end_line": 29,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.DummyS3CopyToTableBase.s3_load_path#55",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.DummyS3CopyToTableBase",
        "signature": "test.contrib.redshift_test.DummyS3CopyToTableBase.s3_load_path(self)",
        "snippet": "    def s3_load_path(self):\n        return 's3://%s/%s' % (BUCKET, KEY)",
        "begin_line": 55,
        "end_line": 56,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.TestInternalCredentials.test_from_property#90",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.TestInternalCredentials",
        "signature": "test.contrib.redshift_test.TestInternalCredentials.test_from_property(self)",
        "snippet": "    def test_from_property(self):\n        self.assertEqual(self.aws_access_key_id, AWS_ACCESS_KEY)\n        self.assertEqual(self.aws_secret_access_key, AWS_SECRET_KEY)",
        "begin_line": 90,
        "end_line": 92,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.TestExternalCredentials.test_from_env#98",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.TestExternalCredentials",
        "signature": "test.contrib.redshift_test.TestExternalCredentials.test_from_env(self)",
        "snippet": "    def test_from_env(self):\n        self.assertEqual(self.aws_access_key_id, \"env_key\")\n        self.assertEqual(self.aws_secret_access_key, \"env_secret\")",
        "begin_line": 98,
        "end_line": 100,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.TestExternalCredentials.test_from_config#104",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.TestExternalCredentials",
        "signature": "test.contrib.redshift_test.TestExternalCredentials.test_from_config(self)",
        "snippet": "    def test_from_config(self):\n        self.assertEqual(self.aws_access_key_id, \"config_key\")\n        self.assertEqual(self.aws_secret_access_key, \"config_secret\")",
        "begin_line": 104,
        "end_line": 106,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.TestS3CopyToTable.test_copy_missing_creds#111",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.TestS3CopyToTable",
        "signature": "test.contrib.redshift_test.TestS3CopyToTable.test_copy_missing_creds(self, mock_redshift_target)",
        "snippet": "    def test_copy_missing_creds(self, mock_redshift_target):\n        task = DummyS3CopyToTableBase()\n\n        # The mocked connection cursor passed to\n        # S3CopyToTable.copy(self, cursor, f).\n        mock_cursor = (mock_redshift_target.return_value\n                       .connect\n                       .return_value\n                       .cursor\n                       .return_value)\n\n        with self.assertRaises(NotImplementedError):\n            task.copy(mock_cursor, task.s3_load_path())",
        "begin_line": 111,
        "end_line": 123,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.TestS3CopyToTable.test_s3_copy_to_table#127",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.TestS3CopyToTable",
        "signature": "test.contrib.redshift_test.TestS3CopyToTable.test_s3_copy_to_table(self, mock_redshift_target, mock_copy)",
        "snippet": "    def test_s3_copy_to_table(self, mock_redshift_target, mock_copy):\n        task = DummyS3CopyToTableKey()\n        task.run()\n\n        # The mocked connection cursor passed to\n        # S3CopyToTable.copy(self, cursor, f).\n        mock_cursor = (mock_redshift_target.return_value\n                                           .connect\n                                           .return_value\n                                           .cursor\n                                           .return_value)\n\n        # `mock_redshift_target` is the mocked `RedshiftTarget` object\n        # returned by S3CopyToTable.output(self).\n        mock_redshift_target.assert_called_with(database=task.database,\n                                                host=task.host,\n                                                update_id=task.task_id,\n                                                user=task.user,\n                                                table=task.table,\n                                                password=task.password)\n\n        # Check if the `S3CopyToTable.s3_load_path` class attribute was\n        # successfully referenced in the `S3CopyToTable.run` method, which is\n        # in-turn passed to `S3CopyToTable.copy` and other functions in `run`\n        # (see issue #995).\n        mock_copy.assert_called_with(mock_cursor, task.s3_load_path())\n\n        # Check the SQL query in `S3CopyToTable.does_table_exist`.\n        mock_cursor.execute.assert_called_with(\"select 1 as table_exists \"\n                                               \"from pg_table_def \"\n                                               \"where tablename = lower(%s) limit 1\",\n                                               (task.table,))\n\n        return",
        "begin_line": 127,
        "end_line": 160,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.TestS3CopyToTable.test_s3_copy_to_missing_table#165",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.TestS3CopyToTable",
        "signature": "test.contrib.redshift_test.TestS3CopyToTable.test_s3_copy_to_missing_table(self, mock_redshift_target, mock_does_exist)",
        "snippet": "    def test_s3_copy_to_missing_table(self,\n                                      mock_redshift_target,\n                                      mock_does_exist):\n        \"\"\"\n        Test missing table creation\n        \"\"\"\n        # Ensure `S3CopyToTable.create_table` does not throw an error.\n        task = DummyS3CopyToTableKey()\n        task.run()\n\n        # Make sure the cursor was successfully used to create the table in\n        # `create_table` as expected.\n        mock_cursor = (mock_redshift_target.return_value\n                                           .connect\n                                           .return_value\n                                           .cursor\n                                           .return_value)\n        assert mock_cursor.execute.call_args_list[0][0][0].startswith(\n            \"CREATE  TABLE %s\" % task.table)\n\n        return",
        "begin_line": 165,
        "end_line": 185,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.TestS3CopyToTable.test_s3_copy_to_missing_table_with_compression_encodings#190",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.TestS3CopyToTable",
        "signature": "test.contrib.redshift_test.TestS3CopyToTable.test_s3_copy_to_missing_table_with_compression_encodings(self, mock_redshift_target, mock_does_exist)",
        "snippet": "    def test_s3_copy_to_missing_table_with_compression_encodings(self,\n                                                                 mock_redshift_target,\n                                                                 mock_does_exist):\n        \"\"\"\n        Test missing table creation with compression encodings\n        \"\"\"\n        # Ensure `S3CopyToTable.create_table` does not throw an error.\n        task = DummyS3CopyToTableWithCompressionEncodings()\n        task.run()\n\n        # Make sure the cursor was successfully used to create the table in\n        # `create_table` as expected.\n        mock_cursor = (mock_redshift_target.return_value\n                                           .connect\n                                           .return_value\n                                           .cursor\n                                           .return_value)\n        encode_string = ','.join(\n                '{name} {type} ENCODE {encoding}'.format(\n                    name=name,\n                    type=type,\n                    encoding=encoding) for name, type, encoding in task.columns\n            )\n\n        assert mock_cursor.execute.call_args_list[0][0][0].startswith(\n            \"CREATE  TABLE %s (%s)\" % (task.table, encode_string))\n\n        return",
        "begin_line": 190,
        "end_line": 217,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.TestS3CopyToTable.test_s3_copy_to_temp_table#221",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.TestS3CopyToTable",
        "signature": "test.contrib.redshift_test.TestS3CopyToTable.test_s3_copy_to_temp_table(self, mock_redshift_target, mock_copy)",
        "snippet": "    def test_s3_copy_to_temp_table(self, mock_redshift_target, mock_copy):\n        task = DummyS3CopyToTempTable()\n        task.run()\n\n        # The mocked connection cursor passed to\n        # S3CopyToTable.copy(self, cursor, f).\n        mock_cursor = (mock_redshift_target.return_value\n                                           .connect\n                                           .return_value\n                                           .cursor\n                                           .return_value)\n\n        # `mock_redshift_target` is the mocked `RedshiftTarget` object\n        # returned by S3CopyToTable.output(self).\n        mock_redshift_target.assert_called_once_with(\n            database=task.database,\n            host=task.host,\n            update_id=task.task_id,\n            user=task.user,\n            table=task.table,\n            password=task.password,\n        )\n\n        # Check if the `S3CopyToTable.s3_load_path` class attribute was\n        # successfully referenced in the `S3CopyToTable.run` method, which is\n        # in-turn passed to `S3CopyToTable.copy` and other functions in `run`\n        # (see issue #995).\n        mock_copy.assert_called_once_with(mock_cursor, task.s3_load_path())\n\n        # Check the SQL query in `S3CopyToTable.does_table_exist`. # temp table\n        mock_cursor.execute.assert_any_call(\n            \"select 1 as table_exists \"\n            \"from pg_table_def \"\n            \"where tablename = lower(%s) limit 1\",\n            (task.table,),\n        )",
        "begin_line": 221,
        "end_line": 256,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.TestS3CopyToTable.test_s3_copy_with_valid_columns#259",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.TestS3CopyToTable",
        "signature": "test.contrib.redshift_test.TestS3CopyToTable.test_s3_copy_with_valid_columns(self, mock_redshift_target)",
        "snippet": "    def test_s3_copy_with_valid_columns(self, mock_redshift_target):\n        task = DummyS3CopyToTableKey()\n        task.run()\n\n        # The mocked connection cursor passed to\n        # S3CopyToTable.copy(self, cursor, f).\n        mock_cursor = (mock_redshift_target.return_value\n                                           .connect\n                                           .return_value\n                                           .cursor\n                                           .return_value)\n\n        # `mock_redshift_target` is the mocked `RedshiftTarget` object\n        # returned by S3CopyToTable.output(self).\n        mock_redshift_target.assert_called_once_with(\n            database=task.database,\n            host=task.host,\n            update_id=task.task_id,\n            user=task.user,\n            table=task.table,\n            password=task.password,\n        )\n\n        # To get the proper intendation in the multiline `COPY` statement the\n        # SQL string was copied from redshift.py.\n        mock_cursor.execute.assert_called_with(\"\"\"\n         COPY {table} {colnames} from '{source}'\n         CREDENTIALS '{creds}'\n         {options}\n         ;\"\"\".format(\n            table='dummy_table',\n            colnames='(some_text,some_int)',\n            source='s3://bucket/key',\n            creds='aws_access_key_id=key;aws_secret_access_key=secret',\n            options='')\n        )",
        "begin_line": 259,
        "end_line": 294,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.TestS3CopyToTable.test_s3_copy_with_default_columns#297",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.TestS3CopyToTable",
        "signature": "test.contrib.redshift_test.TestS3CopyToTable.test_s3_copy_with_default_columns(self, mock_redshift_target)",
        "snippet": "    def test_s3_copy_with_default_columns(self, mock_redshift_target):\n        task = DummyS3CopyToTableKey(columns=[])\n        task.run()\n\n        # The mocked connection cursor passed to\n        # S3CopyToTable.copy(self, cursor, f).\n        mock_cursor = (mock_redshift_target.return_value\n                                           .connect\n                                           .return_value\n                                           .cursor\n                                           .return_value)\n\n        # `mock_redshift_target` is the mocked `RedshiftTarget` object\n        # returned by S3CopyToTable.output(self).\n        mock_redshift_target.assert_called_once_with(\n            database=task.database,\n            host=task.host,\n            update_id=task.task_id,\n            user=task.user,\n            table=task.table,\n            password=task.password,\n        )\n\n        # To get the proper intendation in the multiline `COPY` statement the\n        # SQL string was copied from redshift.py.\n        mock_cursor.execute.assert_called_with(\"\"\"\n         COPY {table} {colnames} from '{source}'\n         CREDENTIALS '{creds}'\n         {options}\n         ;\"\"\".format(\n            table='dummy_table',\n            colnames='',\n            source='s3://bucket/key',\n            creds='aws_access_key_id=key;aws_secret_access_key=secret',\n            options='')\n        )",
        "begin_line": 297,
        "end_line": 332,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.TestS3CopyToTable.test_s3_copy_with_nonetype_columns#335",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.TestS3CopyToTable",
        "signature": "test.contrib.redshift_test.TestS3CopyToTable.test_s3_copy_with_nonetype_columns(self, mock_redshift_target)",
        "snippet": "    def test_s3_copy_with_nonetype_columns(self, mock_redshift_target):\n        task = DummyS3CopyToTableKey(columns=None)\n        task.run()\n\n        # The mocked connection cursor passed to\n        # S3CopyToTable.copy(self, cursor, f).\n        mock_cursor = (mock_redshift_target.return_value\n                                           .connect\n                                           .return_value\n                                           .cursor\n                                           .return_value)\n\n        # `mock_redshift_target` is the mocked `RedshiftTarget` object\n        # returned by S3CopyToTable.output(self).\n        mock_redshift_target.assert_called_once_with(\n            database=task.database,\n            host=task.host,\n            update_id=task.task_id,\n            user=task.user,\n            table=task.table,\n            password=task.password,\n        )\n\n        # To get the proper intendation in the multiline `COPY` statement the\n        # SQL string was copied from redshift.py.\n        mock_cursor.execute.assert_called_with(\"\"\"\n         COPY {table} {colnames} from '{source}'\n         CREDENTIALS '{creds}'\n         {options}\n         ;\"\"\".format(\n            table='dummy_table',\n            colnames='',\n            source='s3://bucket/key',\n            creds='aws_access_key_id=key;aws_secret_access_key=secret',\n            options='')\n        )",
        "begin_line": 335,
        "end_line": 370,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.TestS3CopyToSchemaTable.test_s3_copy_to_table#376",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.TestS3CopyToSchemaTable",
        "signature": "test.contrib.redshift_test.TestS3CopyToSchemaTable.test_s3_copy_to_table(self, mock_redshift_target, mock_copy)",
        "snippet": "    def test_s3_copy_to_table(self, mock_redshift_target, mock_copy):\n        task = DummyS3CopyToTableKey(table='dummy_schema.dummy_table')\n        task.run()\n\n        # The mocked connection cursor passed to\n        # S3CopyToTable.copy(self, cursor, f).\n        mock_cursor = (mock_redshift_target.return_value\n                                           .connect\n                                           .return_value\n                                           .cursor\n                                           .return_value)\n\n        # Check the SQL query in `S3CopyToTable.does_table_exist`.\n        mock_cursor.execute.assert_called_with(\n            \"select 1 as table_exists \"\n            \"from information_schema.tables \"\n            \"where table_schema = lower(%s) and \"\n            \"table_name = lower(%s) limit 1\",\n            tuple(task.table.split('.')),\n        )",
        "begin_line": 376,
        "end_line": 395,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.DummyRedshiftUnloadTask.query#417",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.DummyRedshiftUnloadTask",
        "signature": "test.contrib.redshift_test.DummyRedshiftUnloadTask.query(self)",
        "snippet": "    def query(self):\n        return \"SELECT 'a' as col_a, current_date as col_b\"",
        "begin_line": 417,
        "end_line": 418,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.TestRedshiftUnloadTask.test_redshift_unload_command#423",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.TestRedshiftUnloadTask",
        "signature": "test.contrib.redshift_test.TestRedshiftUnloadTask.test_redshift_unload_command(self, mock_redshift_target)",
        "snippet": "    def test_redshift_unload_command(self, mock_redshift_target):\n\n        task = DummyRedshiftUnloadTask()\n        task.run()\n\n        # The mocked connection cursor passed to\n        # RedshiftUnloadTask.\n        mock_cursor = (mock_redshift_target.return_value\n                                           .connect\n                                           .return_value\n                                           .cursor\n                                           .return_value)\n\n        # Check the Unload query.\n        mock_cursor.execute.assert_called_with(\n            \"UNLOAD ( 'SELECT \\\\'a\\\\' as col_a, current_date as col_b' ) TO 's3://bucket/key' \"\n            \"credentials 'aws_access_key_id=AWS_ACCESS_KEY;aws_secret_access_key=AWS_SECRET_KEY' \"\n            \"DELIMITER ',' ADDQUOTES GZIP ALLOWOVERWRITE PARALLEL OFF;\"\n        )",
        "begin_line": 423,
        "end_line": 441,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.DummyRedshiftAutocommitQuery.query#454",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.DummyRedshiftAutocommitQuery",
        "signature": "test.contrib.redshift_test.DummyRedshiftAutocommitQuery.query(self)",
        "snippet": "    def query(self):\n        return \"SELECT 'a' as col_a, current_date as col_b\"",
        "begin_line": 454,
        "end_line": 455,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.TestRedshiftAutocommitQuery.test_redshift_autocommit_query#460",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.TestRedshiftAutocommitQuery",
        "signature": "test.contrib.redshift_test.TestRedshiftAutocommitQuery.test_redshift_autocommit_query(self, mock_redshift_target)",
        "snippet": "    def test_redshift_autocommit_query(self, mock_redshift_target):\n\n        task = DummyRedshiftAutocommitQuery()\n        task.run()\n\n        # The mocked connection cursor passed to\n        # RedshiftUnloadTask.\n        mock_connect = (mock_redshift_target.return_value\n                                            .connect\n                                            .return_value)\n\n        # Check the Unload query.\n        self.assertTrue(mock_connect.autocommit)",
        "begin_line": 460,
        "end_line": 472,
        "comment": "",
        "is_bug": false
    }
]