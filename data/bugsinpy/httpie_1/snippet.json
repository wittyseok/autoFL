[
    {
        "name": "httpie.config.BaseConfigDict.__getattr__#22",
        "src_path": "httpie/config.py",
        "class_name": "httpie.config.BaseConfigDict",
        "signature": "httpie.config.BaseConfigDict.__getattr__(self, item)",
        "snippet": "    def __getattr__(self, item):\n        return self[item]",
        "begin_line": 22,
        "end_line": 23,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004132231404958678,
            "pseudo_dstar_susp": 0.005847953216374269,
            "pseudo_tarantula_susp": 0.004081632653061225,
            "pseudo_op2_susp": 0.005847953216374269,
            "pseudo_barinel_susp": 0.004081632653061225
        }
    },
    {
        "name": "httpie.config.BaseConfigDict.path#30",
        "src_path": "httpie/config.py",
        "class_name": "httpie.config.BaseConfigDict",
        "signature": "httpie.config.BaseConfigDict.path(self)",
        "snippet": "    def path(self):\n        \"\"\"Return the config file path creating basedir, if needed.\"\"\"\n        path = self._get_path()\n        try:\n            os.makedirs(os.path.dirname(path), mode=0o700)\n        except OSError as e:\n            if e.errno != errno.EEXIST:\n                raise\n        return path",
        "begin_line": 30,
        "end_line": 38,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004484304932735426,
            "pseudo_dstar_susp": 0.006578947368421052,
            "pseudo_tarantula_susp": 0.004424778761061947,
            "pseudo_op2_susp": 0.006578947368421052,
            "pseudo_barinel_susp": 0.004424778761061947
        }
    },
    {
        "name": "httpie.config.BaseConfigDict.is_new#40",
        "src_path": "httpie/config.py",
        "class_name": "httpie.config.BaseConfigDict",
        "signature": "httpie.config.BaseConfigDict.is_new(self)",
        "snippet": "    def is_new(self):\n        return not os.path.exists(self._get_path())",
        "begin_line": 40,
        "end_line": 41,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004484304932735426,
            "pseudo_dstar_susp": 0.006578947368421052,
            "pseudo_tarantula_susp": 0.004424778761061947,
            "pseudo_op2_susp": 0.006578947368421052,
            "pseudo_barinel_susp": 0.004424778761061947
        }
    },
    {
        "name": "httpie.config.BaseConfigDict.load#43",
        "src_path": "httpie/config.py",
        "class_name": "httpie.config.BaseConfigDict",
        "signature": "httpie.config.BaseConfigDict.load(self)",
        "snippet": "    def load(self):\n        try:\n            with open(self.path, 'rt') as f:\n                try:\n                    data = json.load(f)\n                except ValueError as e:\n                    raise ValueError(\n                        'Invalid %s JSON: %s [%s]' %\n                        (type(self).__name__, str(e), self.path)\n                    )\n                self.update(data)\n        except IOError as e:\n            if e.errno != errno.ENOENT:\n                raise",
        "begin_line": 43,
        "end_line": 56,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01694915254237288,
            "pseudo_dstar_susp": 0.0031847133757961785,
            "pseudo_tarantula_susp": 0.017241379310344827,
            "pseudo_op2_susp": 0.0031847133757961785,
            "pseudo_barinel_susp": 0.017241379310344827
        }
    },
    {
        "name": "httpie.config.BaseConfigDict.save#58",
        "src_path": "httpie/config.py",
        "class_name": "httpie.config.BaseConfigDict",
        "signature": "httpie.config.BaseConfigDict.save(self)",
        "snippet": "    def save(self):\n        self['__meta__'] = {\n            'httpie': __version__\n        }\n        if self.helpurl:\n            self['__meta__']['help'] = self.helpurl\n\n        if self.about:\n            self['__meta__']['about'] = self.about\n\n        with open(self.path, 'w') as f:\n            json.dump(self, f, indent=4, sort_keys=True, ensure_ascii=True)\n            f.write('\\n')",
        "begin_line": 58,
        "end_line": 70,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004878048780487805,
            "pseudo_dstar_susp": 0.007462686567164179,
            "pseudo_tarantula_susp": 0.004807692307692308,
            "pseudo_op2_susp": 0.007462686567164179,
            "pseudo_barinel_susp": 0.004807692307692308
        }
    },
    {
        "name": "httpie.config.Config.__init__#90",
        "src_path": "httpie/config.py",
        "class_name": "httpie.config.Config",
        "signature": "httpie.config.Config.__init__(self, directory=DEFAULT_CONFIG_DIR)",
        "snippet": "    def __init__(self, directory=DEFAULT_CONFIG_DIR):\n        super(Config, self).__init__()\n        self.update(self.DEFAULTS)\n        self.directory = directory",
        "begin_line": 90,
        "end_line": 93,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004484304932735426,
            "pseudo_dstar_susp": 0.006578947368421052,
            "pseudo_tarantula_susp": 0.004424778761061947,
            "pseudo_op2_susp": 0.006578947368421052,
            "pseudo_barinel_susp": 0.004424778761061947
        }
    },
    {
        "name": "httpie.config.Config.load#95",
        "src_path": "httpie/config.py",
        "class_name": "httpie.config.Config",
        "signature": "httpie.config.Config.load(self)",
        "snippet": "    def load(self):\n        super(Config, self).load()\n        self._migrate_implicit_content_type()",
        "begin_line": 95,
        "end_line": 97,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.001092896174863388,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.config.Config._get_path#99",
        "src_path": "httpie/config.py",
        "class_name": "httpie.config.Config",
        "signature": "httpie.config.Config._get_path(self)",
        "snippet": "    def _get_path(self):\n        return os.path.join(self.directory, self.name + '.json')",
        "begin_line": 99,
        "end_line": 100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004484304932735426,
            "pseudo_dstar_susp": 0.006578947368421052,
            "pseudo_tarantula_susp": 0.004424778761061947,
            "pseudo_op2_susp": 0.006578947368421052,
            "pseudo_barinel_susp": 0.004424778761061947
        }
    },
    {
        "name": "httpie.config.Config._migrate_implicit_content_type#102",
        "src_path": "httpie/config.py",
        "class_name": "httpie.config.Config",
        "signature": "httpie.config.Config._migrate_implicit_content_type(self)",
        "snippet": "    def _migrate_implicit_content_type(self):\n        \"\"\"Migrate the removed implicit_content_type config option\"\"\"\n        try:\n            implicit_content_type = self.pop('implicit_content_type')\n        except KeyError:\n            pass\n        else:\n            if implicit_content_type == 'form':\n                self['default_options'].insert(0, '--form')\n            self.save()\n            self.load()",
        "begin_line": 102,
        "end_line": 112,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0020876826722338203,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.processing.is_valid_mime#10",
        "src_path": "httpie/output/processing.py",
        "class_name": "httpie.output.processing",
        "signature": "httpie.output.processing.is_valid_mime(mime)",
        "snippet": "def is_valid_mime(mime):\n    return mime and MIME_RE.match(mime)",
        "begin_line": 10,
        "end_line": 11,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0008857395925597874,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.processing.Conversion.get_converter#16",
        "src_path": "httpie/output/processing.py",
        "class_name": "httpie.output.processing.Conversion",
        "signature": "httpie.output.processing.Conversion.get_converter(self, mime)",
        "snippet": "    def get_converter(self, mime):\n        if is_valid_mime(mime):\n            for converter_class in plugin_manager.get_converters():\n                if converter_class.supports(mime):\n                    return converter_class(mime)",
        "begin_line": 16,
        "end_line": 20,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0014771048744460858,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.processing.Formatting.__init__#26",
        "src_path": "httpie/output/processing.py",
        "class_name": "httpie.output.processing.Formatting",
        "signature": "httpie.output.processing.Formatting.__init__(self, groups, env=Environment(), **kwargs)",
        "snippet": "    def __init__(self, groups, env=Environment(), **kwargs):\n        \"\"\"\n        :param groups: names of processor groups to be applied\n        :param env: Environment\n        :param kwargs: additional keyword arguments for processors\n\n        \"\"\"\n        available_plugins = plugin_manager.get_formatters_grouped()\n        self.enabled_plugins = []\n        for group in groups:\n            for cls in available_plugins[group]:\n                p = cls(env=env, **kwargs)\n                if p.enabled:\n                    self.enabled_plugins.append(p)",
        "begin_line": 26,
        "end_line": 39,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.000855431993156544,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.processing.Formatting.format_headers#41",
        "src_path": "httpie/output/processing.py",
        "class_name": "httpie.output.processing.Formatting",
        "signature": "httpie.output.processing.Formatting.format_headers(self, headers)",
        "snippet": "    def format_headers(self, headers):\n        for p in self.enabled_plugins:\n            headers = p.format_headers(headers)\n        return headers",
        "begin_line": 41,
        "end_line": 44,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0008936550491510277,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.processing.Formatting.format_body#46",
        "src_path": "httpie/output/processing.py",
        "class_name": "httpie.output.processing.Formatting",
        "signature": "httpie.output.processing.Formatting.format_body(self, content, mime)",
        "snippet": "    def format_body(self, content, mime):\n        if is_valid_mime(mime):\n            for p in self.enabled_plugins:\n                content = p.format_body(content, mime)\n        return content",
        "begin_line": 46,
        "end_line": 50,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0009115770282588879,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.formatters.json.JSONFormatter.format_body#12",
        "src_path": "httpie/output/formatters/json.py",
        "class_name": "httpie.output.formatters.json.JSONFormatter",
        "signature": "httpie.output.formatters.json.JSONFormatter.format_body(self, body, mime)",
        "snippet": "    def format_body(self, body, mime):\n        if 'json' in mime or self.kwargs['explicit_json']:\n            try:\n                obj = json.loads(body)\n            except ValueError:\n                pass  # Invalid JSON, ignore.\n            else:\n                # Indent, sort keys by name, and avoid\n                # unicode escapes to improve readability.\n                body = json.dumps(\n                    obj=obj,\n                    sort_keys=True,\n                    ensure_ascii=False,\n                    indent=DEFAULT_INDENT\n                )\n        return body",
        "begin_line": 12,
        "end_line": 27,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0009250693802035153,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.downloads.parse_content_range#40",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads",
        "signature": "httpie.downloads.parse_content_range(content_range, resumed_from)",
        "snippet": "def parse_content_range(content_range, resumed_from):\n    \"\"\"\n    Parse and validate Content-Range header.\n\n    <http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html>\n\n    :param content_range: the value of a Content-Range response header\n                          eg. \"bytes 21010-47021/47022\"\n    :param resumed_from: first byte pos. from the Range request header\n    :return: total size of the response body when fully downloaded.\n\n    \"\"\"\n    if content_range is None:\n        raise ContentRangeError('Missing Content-Range')\n\n    pattern = (\n        '^bytes (?P<first_byte_pos>\\d+)-(?P<last_byte_pos>\\d+)'\n        '/(\\*|(?P<instance_length>\\d+))$'\n    )\n    match = re.match(pattern, content_range)\n\n    if not match:\n        raise ContentRangeError(\n            'Invalid Content-Range format %r' % content_range)\n\n    content_range_dict = match.groupdict()\n    first_byte_pos = int(content_range_dict['first_byte_pos'])\n    last_byte_pos = int(content_range_dict['last_byte_pos'])\n    instance_length = (\n        int(content_range_dict['instance_length'])\n        if content_range_dict['instance_length']\n        else None\n    )\n\n    # \"A byte-content-range-spec with a byte-range-resp-spec whose\n    # last- byte-pos value is less than its first-byte-pos value,\n    # or whose instance-length value is less than or equal to its\n    # last-byte-pos value, is invalid. The recipient of an invalid\n    # byte-content-range- spec MUST ignore it and any content\n    # transferred along with it.\"\n    if (first_byte_pos >= last_byte_pos\n            or (instance_length is not None\n                and instance_length <= last_byte_pos)):\n        raise ContentRangeError(\n            'Invalid Content-Range returned: %r' % content_range)\n\n    if (first_byte_pos != resumed_from\n        or (instance_length is not None\n            and last_byte_pos + 1 != instance_length)):\n        # Not what we asked for.\n        raise ContentRangeError(\n            'Unexpected Content-Range returned (%r)'\n            ' for the requested Range (\"bytes=%d-\")'\n            % (content_range, resumed_from)\n        )\n\n    return last_byte_pos + 1",
        "begin_line": 40,
        "end_line": 96,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0020876826722338203,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.downloads.filename_from_content_disposition#99",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads",
        "signature": "httpie.downloads.filename_from_content_disposition(content_disposition)",
        "snippet": "def filename_from_content_disposition(content_disposition):\n    \"\"\"\n    Extract and validate filename from a Content-Disposition header.\n\n    :param content_disposition: Content-Disposition value\n    :return: the filename if present and valid, otherwise `None`\n\n    \"\"\"\n    # attachment; filename=jkbrzt-httpie-0.4.1-20-g40bd8f6.tar.gz\n\n    msg = Message('Content-Disposition: %s' % content_disposition)\n    filename = msg.get_filename()\n    if filename:\n        # Basic sanitation.\n        filename = os.path.basename(filename).lstrip('.').strip()\n        if filename:\n            return filename",
        "begin_line": 99,
        "end_line": 115,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0020876826722338203,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.downloads.filename_from_url#118",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads",
        "signature": "httpie.downloads.filename_from_url(url, content_type)",
        "snippet": "def filename_from_url(url, content_type):\n    fn = urlsplit(url).path.rstrip('/')\n    fn = os.path.basename(fn) if fn else 'index'\n    if '.' not in fn and content_type:\n        content_type = content_type.split(';')[0]\n        if content_type == 'text/plain':\n            # mimetypes returns '.ksh'\n            ext = '.txt'\n        else:\n            ext = mimetypes.guess_extension(content_type)\n\n        if ext == '.htm':  # Python 3\n            ext = '.html'\n\n        if ext:\n            fn += ext\n\n    return fn",
        "begin_line": 118,
        "end_line": 135,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0020876826722338203,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.downloads.get_unique_filename#138",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads",
        "signature": "httpie.downloads.get_unique_filename(filename, exists=os.path.exists)",
        "snippet": "def get_unique_filename(filename, exists=os.path.exists):\n    attempt = 0\n    while True:\n        suffix = '-' + str(attempt) if attempt > 0 else ''\n        if not exists(filename + suffix):\n            return filename + suffix\n        attempt += 1",
        "begin_line": 138,
        "end_line": 144,
        "comment": "",
        "is_bug": true,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0020876826722338203,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.downloads.Downloader.__init__#149",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.Downloader",
        "signature": "httpie.downloads.Downloader.__init__(self, output_file=None, resume=False, progress_file=sys.stderr)",
        "snippet": "    def __init__(self, output_file=None,\n                 resume=False, progress_file=sys.stderr):\n        \"\"\"\n        :param resume: Should the download resume if partial download\n                       already exists.\n        :type resume: bool\n\n        :param output_file: The file to store response body in. If not\n                            provided, it will be guessed from the response.\n\n        :param progress_file: Where to report download progress.\n\n        \"\"\"\n        self._output_file = output_file\n        self._resume = resume\n        self._resumed_from = 0\n        self.finished = False\n\n        self.status = Status()\n        self._progress_reporter = ProgressReporterThread(\n            status=self.status,\n            output=progress_file\n        )",
        "begin_line": 149,
        "end_line": 171,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0012484394506866417,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.downloads.Downloader.pre_request#173",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.Downloader",
        "signature": "httpie.downloads.Downloader.pre_request(self, request_headers)",
        "snippet": "    def pre_request(self, request_headers):\n        \"\"\"Called just before the HTTP request is sent.\n\n        Might alter `request_headers`.\n\n        :type request_headers: dict\n\n        \"\"\"\n        # Ask the server not to encode the content so that we can resume, etc.\n        request_headers['Accept-Encoding'] = 'identity'\n        if self._resume:\n            bytes_have = os.path.getsize(self._output_file.name)\n            if bytes_have:\n                # Set ``Range`` header to resume the download\n                # TODO: Use \"If-Range: mtime\" to make sure it's fresh?\n                request_headers['Range'] = 'bytes=%d-' % bytes_have\n                self._resumed_from = bytes_have",
        "begin_line": 173,
        "end_line": 189,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0016420361247947454,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.downloads.Downloader.start#191",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.Downloader",
        "signature": "httpie.downloads.Downloader.start(self, response)",
        "snippet": "    def start(self, response):\n        \"\"\"\n        Initiate and return a stream for `response` body  with progress\n        callback attached. Can be called only once.\n\n        :param response: Initiated response object with headers already fetched\n        :type response: requests.models.Response\n\n        :return: RawStream, output_file\n\n        \"\"\"\n        assert not self.status.time_started\n\n        # FIXME: some servers still might sent Content-Encoding: gzip\n        # <https://github.com/jkbrzt/httpie/issues/423>\n        try:\n            total_size = int(response.headers['Content-Length'])\n        except (KeyError, ValueError, TypeError):\n            total_size = None\n\n        if self._output_file:\n            if self._resume and response.status_code == PARTIAL_CONTENT:\n                total_size = parse_content_range(\n                    response.headers.get('Content-Range'),\n                    self._resumed_from\n                )\n\n            else:\n                self._resumed_from = 0\n                try:\n                    self._output_file.seek(0)\n                    self._output_file.truncate()\n                except IOError:\n                    pass  # stdout\n        else:\n            # TODO: Should the filename be taken from response.history[0].url?\n            # Output file not specified. Pick a name that doesn't exist yet.\n            filename = None\n            if 'Content-Disposition' in response.headers:\n                filename = filename_from_content_disposition(\n                    response.headers['Content-Disposition'])\n            if not filename:\n                filename = filename_from_url(\n                    url=response.url,\n                    content_type=response.headers.get('Content-Type'),\n                )\n            self._output_file = open(get_unique_filename(filename), mode='a+b')\n\n        self.status.started(\n            resumed_from=self._resumed_from,\n            total_size=total_size\n        )\n\n        stream = RawStream(\n            msg=HTTPResponse(response),\n            with_headers=False,\n            with_body=True,\n            on_body_chunk_downloaded=self.chunk_downloaded,\n            chunk_size=1024 * 8\n        )\n\n        self._progress_reporter.output.write(\n            'Downloading %sto \"%s\"\\n' % (\n                (humanize_bytes(total_size) + ' '\n                 if total_size is not None\n                 else ''),\n                self._output_file.name\n            )\n        )\n        self._progress_reporter.start()\n\n        return stream, self._output_file",
        "begin_line": 191,
        "end_line": 262,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0020876826722338203,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.downloads.Downloader.finish#264",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.Downloader",
        "signature": "httpie.downloads.Downloader.finish(self)",
        "snippet": "    def finish(self):\n        assert not self.finished\n        self.finished = True\n        self.status.finished()",
        "begin_line": 264,
        "end_line": 267,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0012484394506866417,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.downloads.Downloader.interrupted#273",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.Downloader",
        "signature": "httpie.downloads.Downloader.interrupted(self)",
        "snippet": "    def interrupted(self):\n        return (\n            self.finished\n            and self.status.total_size\n            and self.status.total_size != self.status.downloaded\n        )",
        "begin_line": 273,
        "end_line": 278,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0013812154696132596,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.downloads.Downloader.chunk_downloaded#280",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.Downloader",
        "signature": "httpie.downloads.Downloader.chunk_downloaded(self, chunk)",
        "snippet": "    def chunk_downloaded(self, chunk):\n        \"\"\"\n        A download progress callback.\n\n        :param chunk: A chunk of response body data that has just\n                      been downloaded and written to the output.\n        :type chunk: bytes\n\n        \"\"\"\n        self.status.chunk_downloaded(len(chunk))",
        "begin_line": 280,
        "end_line": 289,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0012484394506866417,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.downloads.Status.__init__#295",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.Status",
        "signature": "httpie.downloads.Status.__init__(self)",
        "snippet": "    def __init__(self):\n        self.downloaded = 0\n        self.total_size = None\n        self.resumed_from = 0\n        self.time_started = None\n        self.time_finished = None",
        "begin_line": 295,
        "end_line": 300,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0012484394506866417,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.downloads.Status.started#302",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.Status",
        "signature": "httpie.downloads.Status.started(self, resumed_from=0, total_size=None)",
        "snippet": "    def started(self, resumed_from=0, total_size=None):\n        assert self.time_started is None\n        self.total_size = total_size\n        self.downloaded = self.resumed_from = resumed_from\n        self.time_started = time()",
        "begin_line": 302,
        "end_line": 306,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0012484394506866417,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.downloads.Status.chunk_downloaded#308",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.Status",
        "signature": "httpie.downloads.Status.chunk_downloaded(self, size)",
        "snippet": "    def chunk_downloaded(self, size):\n        assert self.time_finished is None\n        self.downloaded += size",
        "begin_line": 308,
        "end_line": 310,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0012484394506866417,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.downloads.Status.has_finished#313",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.Status",
        "signature": "httpie.downloads.Status.has_finished(self)",
        "snippet": "    def has_finished(self):\n        return self.time_finished is not None",
        "begin_line": 313,
        "end_line": 314,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.downloads.Status.finished#316",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.Status",
        "signature": "httpie.downloads.Status.finished(self)",
        "snippet": "    def finished(self):\n        assert self.time_started is not None\n        assert self.time_finished is None\n        self.time_finished = time()",
        "begin_line": 316,
        "end_line": 319,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0012484394506866417,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.downloads.ProgressReporterThread.__init__#329",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.ProgressReporterThread",
        "signature": "httpie.downloads.ProgressReporterThread.__init__(self, status, output, tick=0.1, update_interval=1)",
        "snippet": "    def __init__(self, status, output, tick=.1, update_interval=1):\n        \"\"\"\n\n        :type status: Status\n        :type output: file\n        \"\"\"\n        super(ProgressReporterThread, self).__init__()\n        self.status = status\n        self.output = output\n        self._tick = tick\n        self._update_interval = update_interval\n        self._spinner_pos = 0\n        self._status_line = ''\n        self._prev_bytes = 0\n        self._prev_time = time()\n        self._should_stop = threading.Event()",
        "begin_line": 329,
        "end_line": 344,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0012484394506866417,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.downloads.ProgressReporterThread.run#350",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.ProgressReporterThread",
        "signature": "httpie.downloads.ProgressReporterThread.run(self)",
        "snippet": "    def run(self):\n        while not self._should_stop.is_set():\n            if self.status.has_finished:\n                self.sum_up()\n                break\n\n            self.report_speed()\n            sleep(self._tick)",
        "begin_line": 350,
        "end_line": 357,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0013812154696132596,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.downloads.ProgressReporterThread.report_speed#359",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.ProgressReporterThread",
        "signature": "httpie.downloads.ProgressReporterThread.report_speed(self)",
        "snippet": "    def report_speed(self):\n\n        now = time()\n\n        if now - self._prev_time >= self._update_interval:\n            downloaded = self.status.downloaded\n            try:\n                speed = ((downloaded - self._prev_bytes)\n                         / (now - self._prev_time))\n            except ZeroDivisionError:\n                speed = 0\n\n            if not self.status.total_size:\n                self._status_line = PROGRESS_NO_CONTENT_LENGTH.format(\n                    downloaded=humanize_bytes(downloaded),\n                    speed=humanize_bytes(speed),\n                )\n            else:\n                try:\n                    percentage = downloaded / self.status.total_size * 100\n                except ZeroDivisionError:\n                    percentage = 0\n\n                if not speed:\n                    eta = '-:--:--'\n                else:\n                    s = int((self.status.total_size - downloaded) / speed)\n                    h, s = divmod(s, 60 * 60)\n                    m, s = divmod(s, 60)\n                    eta = '{0}:{1:0>2}:{2:0>2}'.format(h, m, s)\n\n                self._status_line = PROGRESS.format(\n                    percentage=percentage,\n                    downloaded=humanize_bytes(downloaded),\n                    speed=humanize_bytes(speed),\n                    eta=eta,\n                )\n\n            self._prev_time = now\n            self._prev_bytes = downloaded\n\n        self.output.write(\n            CLEAR_LINE\n            + ' '\n            + SPINNER[self._spinner_pos]\n            + ' '\n            + self._status_line\n        )\n        self.output.flush()\n\n        self._spinner_pos = (self._spinner_pos + 1\n                             if self._spinner_pos + 1 != len(SPINNER)\n                             else 0)",
        "begin_line": 359,
        "end_line": 411,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0020876826722338203,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.downloads.ProgressReporterThread.sum_up#413",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.ProgressReporterThread",
        "signature": "httpie.downloads.ProgressReporterThread.sum_up(self)",
        "snippet": "    def sum_up(self):\n        actually_downloaded = (self.status.downloaded\n                               - self.status.resumed_from)\n        time_taken = self.status.time_finished - self.status.time_started\n\n        self.output.write(CLEAR_LINE)\n\n        try:\n            speed = actually_downloaded / time_taken\n        except ZeroDivisionError:\n            # Either time is 0 (not all systems provide `time.time`\n            # with a better precision than 1 second), and/or nothing\n            # has been downloaded.\n            speed = actually_downloaded\n\n        self.output.write(SUMMARY.format(\n            downloaded=humanize_bytes(actually_downloaded),\n            total=(self.status.total_size\n                   and humanize_bytes(self.status.total_size)),\n            speed=humanize_bytes(speed),\n            time=time_taken,\n        ))\n        self.output.flush()",
        "begin_line": 413,
        "end_line": 435,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0013812154696132596,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.context.Environment.__init__#55",
        "src_path": "httpie/context.py",
        "class_name": "httpie.context.Environment",
        "signature": "httpie.context.Environment.__init__(self, **kwargs)",
        "snippet": "    def __init__(self, **kwargs):\n        \"\"\"\n        Use keyword arguments to overwrite\n        any of the class attributes for this instance.\n\n        \"\"\"\n        assert all(hasattr(type(self), attr) for attr in kwargs.keys())\n        self.__dict__.update(**kwargs)\n\n        # Keyword arguments > stream.encoding > default utf8\n        if self.stdin_encoding is None:\n            self.stdin_encoding = getattr(\n                self.stdin, 'encoding', None) or 'utf8'\n        if self.stdout_encoding is None:\n            actual_stdout = self.stdout\n            if is_windows:\n                # noinspection PyUnresolvedReferences\n                from colorama import AnsiToWin32\n                if isinstance(self.stdout, AnsiToWin32):\n                    actual_stdout = self.stdout.wrapped\n            self.stdout_encoding = getattr(\n                actual_stdout, 'encoding', None) or 'utf8'",
        "begin_line": 55,
        "end_line": 76,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.010309278350515464,
            "pseudo_dstar_susp": 0.125,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.125,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "httpie.context.Environment.config#79",
        "src_path": "httpie/context.py",
        "class_name": "httpie.context.Environment",
        "signature": "httpie.context.Environment.config(self)",
        "snippet": "    def config(self):\n        if not hasattr(self, '_config'):\n            self._config = Config(directory=self.config_dir)\n            if self._config.is_new():\n                self._config.save()\n            else:\n                self._config.load()\n        return self._config",
        "begin_line": 79,
        "end_line": 86,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004878048780487805,
            "pseudo_dstar_susp": 0.007462686567164179,
            "pseudo_tarantula_susp": 0.004807692307692308,
            "pseudo_op2_susp": 0.007462686567164179,
            "pseudo_barinel_susp": 0.004807692307692308
        }
    },
    {
        "name": "httpie.context.Environment.__str__#88",
        "src_path": "httpie/context.py",
        "class_name": "httpie.context.Environment",
        "signature": "httpie.context.Environment.__str__(self)",
        "snippet": "    def __str__(self):\n        defaults = dict(type(self).__dict__)\n        actual = dict(defaults)\n        actual.update(self.__dict__)\n        actual['config'] = self.config\n        return repr_dict_nice(dict(\n            (key, value)\n            for key, value in actual.items()\n            if not key.startswith('_'))\n        )",
        "begin_line": 88,
        "end_line": 97,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0020876826722338203,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.context.Environment.__repr__#99",
        "src_path": "httpie/context.py",
        "class_name": "httpie.context.Environment",
        "signature": "httpie.context.Environment.__repr__(self)",
        "snippet": "    def __repr__(self):\n        return '<{0} {1}>'.format(type(self).__name__, str(self))",
        "begin_line": 99,
        "end_line": 100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0020876826722338203,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.client.HTTPieHTTPAdapter.__init__#34",
        "src_path": "httpie/client.py",
        "class_name": "httpie.client.HTTPieHTTPAdapter",
        "signature": "httpie.client.HTTPieHTTPAdapter.__init__(self, ssl_version=None, **kwargs)",
        "snippet": "    def __init__(self, ssl_version=None, **kwargs):\n        self._ssl_version = ssl_version\n        super(HTTPieHTTPAdapter, self).__init__(**kwargs)",
        "begin_line": 34,
        "end_line": 36,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007751937984496124,
            "pseudo_dstar_susp": 0.017241379310344827,
            "pseudo_tarantula_susp": 0.007692307692307693,
            "pseudo_op2_susp": 0.017241379310344827,
            "pseudo_barinel_susp": 0.007692307692307693
        }
    },
    {
        "name": "httpie.client.HTTPieHTTPAdapter.init_poolmanager#38",
        "src_path": "httpie/client.py",
        "class_name": "httpie.client.HTTPieHTTPAdapter",
        "signature": "httpie.client.HTTPieHTTPAdapter.init_poolmanager(self, *args, **kwargs)",
        "snippet": "    def init_poolmanager(self, *args, **kwargs):\n        kwargs['ssl_version'] = self._ssl_version\n        super(HTTPieHTTPAdapter, self).init_poolmanager(*args, **kwargs)",
        "begin_line": 38,
        "end_line": 40,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007751937984496124,
            "pseudo_dstar_susp": 0.017241379310344827,
            "pseudo_tarantula_susp": 0.007692307692307693,
            "pseudo_op2_susp": 0.017241379310344827,
            "pseudo_barinel_susp": 0.007692307692307693
        }
    },
    {
        "name": "httpie.client.get_requests_session#43",
        "src_path": "httpie/client.py",
        "class_name": "httpie.client",
        "signature": "httpie.client.get_requests_session(ssl_version)",
        "snippet": "def get_requests_session(ssl_version):\n    requests_session = requests.Session()\n    requests_session.mount(\n        'https://',\n        HTTPieHTTPAdapter(ssl_version=ssl_version)\n    )\n    for cls in plugin_manager.get_transport_plugins():\n        transport_plugin = cls()\n        requests_session.mount(prefix=transport_plugin.prefix,\n                               adapter=transport_plugin.get_adapter())\n    return requests_session",
        "begin_line": 43,
        "end_line": 53,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007751937984496124,
            "pseudo_dstar_susp": 0.017241379310344827,
            "pseudo_tarantula_susp": 0.007692307692307693,
            "pseudo_op2_susp": 0.017241379310344827,
            "pseudo_barinel_susp": 0.007692307692307693
        }
    },
    {
        "name": "httpie.client.get_response#56",
        "src_path": "httpie/client.py",
        "class_name": "httpie.client",
        "signature": "httpie.client.get_response(args, config_dir)",
        "snippet": "def get_response(args, config_dir):\n    \"\"\"Send the request and return a `request.Response`.\"\"\"\n\n    ssl_version = None\n    if args.ssl_version:\n        ssl_version = SSL_VERSION_ARG_MAPPING[args.ssl_version]\n\n    requests_session = get_requests_session(ssl_version)\n    requests_session.max_redirects = args.max_redirects\n\n    if not args.session and not args.session_read_only:\n        kwargs = get_requests_kwargs(args)\n        if args.debug:\n            dump_request(kwargs)\n        response = requests_session.request(**kwargs)\n    else:\n        response = sessions.get_response(\n            requests_session=requests_session,\n            args=args,\n            config_dir=config_dir,\n            session_name=args.session or args.session_read_only,\n            read_only=bool(args.session_read_only),\n        )\n\n    return response",
        "begin_line": 56,
        "end_line": 80,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01694915254237288,
            "pseudo_dstar_susp": 0.017241379310344827,
            "pseudo_tarantula_susp": 0.017241379310344827,
            "pseudo_op2_susp": 0.017241379310344827,
            "pseudo_barinel_susp": 0.017241379310344827
        }
    },
    {
        "name": "httpie.client.encode_headers#88",
        "src_path": "httpie/client.py",
        "class_name": "httpie.client",
        "signature": "httpie.client.encode_headers(headers)",
        "snippet": "def encode_headers(headers):\n    # This allows for unicode headers which is non-standard but practical.\n    # See: https://github.com/jkbrzt/httpie/issues/212\n    return dict(\n        (name, value.encode('utf8') if isinstance(value, str) else value)\n        for name, value in headers.items()\n    )",
        "begin_line": 88,
        "end_line": 94,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.010869565217391304,
            "pseudo_dstar_susp": 0.3333333333333333,
            "pseudo_tarantula_susp": 0.007692307692307693,
            "pseudo_op2_susp": 0.3333333333333333,
            "pseudo_barinel_susp": 0.007692307692307693
        }
    },
    {
        "name": "httpie.client.get_default_headers#97",
        "src_path": "httpie/client.py",
        "class_name": "httpie.client",
        "signature": "httpie.client.get_default_headers(args)",
        "snippet": "def get_default_headers(args):\n    default_headers = {\n        'User-Agent': DEFAULT_UA\n    }\n\n    auto_json = args.data and not args.form\n    # FIXME: Accept is set to JSON with `http url @./file.txt`.\n    if args.json or auto_json:\n        default_headers['Accept'] = 'application/json'\n        if args.json or (auto_json and args.data):\n            default_headers['Content-Type'] = JSON\n\n    elif args.form and not args.files:\n        # If sending files, `requests` will set\n        # the `Content-Type` for us.\n        default_headers['Content-Type'] = FORM\n    return default_headers",
        "begin_line": 97,
        "end_line": 113,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.010101010101010102,
            "pseudo_dstar_susp": 0.03571428571428571,
            "pseudo_tarantula_susp": 0.010526315789473684,
            "pseudo_op2_susp": 0.03571428571428571,
            "pseudo_barinel_susp": 0.010526315789473684
        }
    },
    {
        "name": "httpie.client.get_requests_kwargs#116",
        "src_path": "httpie/client.py",
        "class_name": "httpie.client",
        "signature": "httpie.client.get_requests_kwargs(args, base_headers=None)",
        "snippet": "def get_requests_kwargs(args, base_headers=None):\n    \"\"\"\n    Translate our `args` into `requests.request` keyword arguments.\n\n    \"\"\"\n    # Serialize JSON data, if needed.\n    data = args.data\n    auto_json = data and not args.form\n    if (args.json or auto_json) and isinstance(data, dict):\n        if data:\n            data = json.dumps(data)\n        else:\n            # We need to set data to an empty string to prevent requests\n            # from assigning an empty list to `response.request.data`.\n            data = ''\n\n    # Finalize headers.\n    headers = get_default_headers(args)\n    if base_headers:\n        headers.update(base_headers)\n    headers.update(args.headers)\n    headers = encode_headers(headers)\n\n    credentials = None\n    if args.auth:\n        auth_plugin = plugin_manager.get_auth_plugin(args.auth_type)()\n        credentials = auth_plugin.get_auth(args.auth.key, args.auth.value)\n\n    cert = None\n    if args.cert:\n        cert = args.cert\n        if args.cert_key:\n            cert = cert, args.cert_key\n\n    kwargs = {\n        'stream': True,\n        'method': args.method.lower(),\n        'url': args.url,\n        'headers': headers,\n        'data': data,\n        'verify': {\n            'yes': True,\n            'no': False\n        }.get(args.verify, args.verify),\n        'cert': cert,\n        'timeout': args.timeout,\n        'auth': credentials,\n        'proxies': dict((p.key, p.value) for p in args.proxy),\n        'files': args.files,\n        'allow_redirects': args.follow,\n        'params': args.params,\n    }\n\n    return kwargs",
        "begin_line": 116,
        "end_line": 169,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.010869565217391304,
            "pseudo_dstar_susp": 0.3333333333333333,
            "pseudo_tarantula_susp": 0.007692307692307693,
            "pseudo_op2_susp": 0.3333333333333333,
            "pseudo_barinel_susp": 0.007692307692307693
        }
    },
    {
        "name": "httpie.plugins.builtin.HTTPBasicAuth.__call__#15",
        "src_path": "httpie/plugins/builtin.py",
        "class_name": "httpie.plugins.builtin.HTTPBasicAuth",
        "signature": "httpie.plugins.builtin.HTTPBasicAuth.__call__(self, r)",
        "snippet": "    def __call__(self, r):\n        \"\"\"\n        Override username/password serialization to allow unicode.\n\n        See https://github.com/jkbrzt/httpie/issues/212\n\n        \"\"\"\n        r.headers['Authorization'] = type(self).make_header(\n            self.username, self.password).encode('latin1')\n        return r",
        "begin_line": 15,
        "end_line": 24,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0010615711252653928,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.plugins.builtin.HTTPBasicAuth.make_header#27",
        "src_path": "httpie/plugins/builtin.py",
        "class_name": "httpie.plugins.builtin.HTTPBasicAuth",
        "signature": "httpie.plugins.builtin.HTTPBasicAuth.make_header(username, password)",
        "snippet": "    def make_header(username, password):\n        credentials = u'%s:%s' % (username, password)\n        token = b64encode(credentials.encode('utf8')).strip().decode('latin1')\n        return 'Basic %s' % token",
        "begin_line": 27,
        "end_line": 30,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0010615711252653928,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.plugins.builtin.BasicAuthPlugin.get_auth#38",
        "src_path": "httpie/plugins/builtin.py",
        "class_name": "httpie.plugins.builtin.BasicAuthPlugin",
        "signature": "httpie.plugins.builtin.BasicAuthPlugin.get_auth(self, username, password)",
        "snippet": "    def get_auth(self, username, password):\n        return HTTPBasicAuth(username, password)",
        "begin_line": 38,
        "end_line": 39,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0010615711252653928,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.plugins.builtin.DigestAuthPlugin.get_auth#47",
        "src_path": "httpie/plugins/builtin.py",
        "class_name": "httpie.plugins.builtin.DigestAuthPlugin",
        "signature": "httpie.plugins.builtin.DigestAuthPlugin.get_auth(self, username, password)",
        "snippet": "    def get_auth(self, username, password):\n        return requests.auth.HTTPDigestAuth(username, password)",
        "begin_line": 47,
        "end_line": 48,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0016420361247947454,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.input.HTTPieArgumentParser.parse_args#134",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.HTTPieArgumentParser",
        "signature": "httpie.input.HTTPieArgumentParser.parse_args(self, env, args=None, namespace=None)",
        "snippet": "    def parse_args(self, env, args=None, namespace=None):\n\n        self.env = env\n        self.args, no_options = super(HTTPieArgumentParser, self)\\\n            .parse_known_args(args, namespace)\n\n        if self.args.debug:\n            self.args.traceback = True\n\n        # Arguments processing and environment setup.\n        self._apply_no_options(no_options)\n        self._validate_download_options()\n        self._setup_standard_streams()\n        self._process_output_options()\n        self._process_pretty_options()\n        self._guess_method()\n        self._parse_items()\n        if not self.args.ignore_stdin and not env.stdin_isatty:\n            self._body_from_file(self.env.stdin)\n        if not URL_SCHEME_RE.match(self.args.url):\n            scheme = HTTP\n\n            # See if we're using curl style shorthand for localhost (:3000/foo)\n            shorthand = re.match(r'^:(?!:)(\\d*)(/?.*)$', self.args.url)\n            if shorthand:\n                port = shorthand.group(1)\n                rest = shorthand.group(2)\n                self.args.url = scheme + 'localhost'\n                if port:\n                    self.args.url += ':' + port\n                self.args.url += rest\n            else:\n                self.args.url = scheme + self.args.url\n        self._process_auth()\n\n        return self.args",
        "begin_line": 134,
        "end_line": 169,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004132231404958678,
            "pseudo_dstar_susp": 0.005847953216374269,
            "pseudo_tarantula_susp": 0.004081632653061225,
            "pseudo_op2_susp": 0.005847953216374269,
            "pseudo_barinel_susp": 0.004081632653061225
        }
    },
    {
        "name": "httpie.input.HTTPieArgumentParser._print_message#172",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.HTTPieArgumentParser",
        "signature": "httpie.input.HTTPieArgumentParser._print_message(self, message, file=None)",
        "snippet": "    def _print_message(self, message, file=None):\n        # Sneak in our stderr/stdout.\n        file = {\n            sys.stdout: self.env.stdout,\n            sys.stderr: self.env.stderr,\n            None: self.env.stderr\n        }.get(file, file)\n        if not hasattr(file, 'buffer') and isinstance(message, str):\n            message = message.encode(self.env.stdout_encoding)\n        super(HTTPieArgumentParser, self)._print_message(message, file)",
        "begin_line": 172,
        "end_line": 181,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0016420361247947454,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.input.HTTPieArgumentParser._setup_standard_streams#183",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.HTTPieArgumentParser",
        "signature": "httpie.input.HTTPieArgumentParser._setup_standard_streams(self)",
        "snippet": "    def _setup_standard_streams(self):\n        \"\"\"\n        Modify `env.stdout` and `env.stdout_isatty` based on args, if needed.\n\n        \"\"\"\n        self.args.output_file_specified = bool(self.args.output_file)\n        if self.args.download:\n            # FIXME: Come up with a cleaner solution.\n            if not self.args.output_file and not self.env.stdout_isatty:\n                # Use stdout as the download output file.\n                self.args.output_file = self.env.stdout\n            # With `--download`, we write everything that would normally go to\n            # `stdout` to `stderr` instead. Let's replace the stream so that\n            # we don't have to use many `if`s throughout the codebase.\n            # The response body will be treated separately.\n            self.env.stdout = self.env.stderr\n            self.env.stdout_isatty = self.env.stderr_isatty\n        elif self.args.output_file:\n            # When not `--download`ing, then `--output` simply replaces\n            # `stdout`. The file is opened for appending, which isn't what\n            # we want in this case.\n            self.args.output_file.seek(0)\n            try:\n                self.args.output_file.truncate()\n            except IOError as e:\n                if e.errno == errno.EINVAL:\n                    # E.g. /dev/null on Linux.\n                    pass\n                else:\n                    raise\n            self.env.stdout = self.args.output_file\n            self.env.stdout_isatty = False",
        "begin_line": 183,
        "end_line": 214,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0038022813688212928,
            "pseudo_dstar_susp": 0.005208333333333333,
            "pseudo_tarantula_susp": 0.0036363636363636364,
            "pseudo_op2_susp": 0.005208333333333333,
            "pseudo_barinel_susp": 0.0036363636363636364
        }
    },
    {
        "name": "httpie.input.HTTPieArgumentParser._process_auth#216",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.HTTPieArgumentParser",
        "signature": "httpie.input.HTTPieArgumentParser._process_auth(self)",
        "snippet": "    def _process_auth(self):\n        \"\"\"\n        If only a username provided via --auth, then ask for a password.\n        Or, take credentials from the URL, if provided.\n\n        \"\"\"\n        url = urlsplit(self.args.url)\n\n        if self.args.auth:\n            if not self.args.auth.has_password():\n                # Stdin already read (if not a tty) so it's save to prompt.\n                if self.args.ignore_stdin:\n                    self.error('Unable to prompt for passwords because'\n                               ' --ignore-stdin is set.')\n                self.args.auth.prompt_password(url.netloc)\n\n        elif url.username is not None:\n            # Handle http://username:password@hostname/\n            username = url.username\n            password = url.password or ''\n            self.args.auth = AuthCredentials(\n                key=username,\n                value=password,\n                sep=SEP_CREDENTIALS,\n                orig=SEP_CREDENTIALS.join([username, password])\n            )",
        "begin_line": 216,
        "end_line": 241,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005681818181818182,
            "pseudo_dstar_susp": 0.009523809523809525,
            "pseudo_tarantula_susp": 0.0056179775280898875,
            "pseudo_op2_susp": 0.009523809523809525,
            "pseudo_barinel_susp": 0.0056179775280898875
        }
    },
    {
        "name": "httpie.input.HTTPieArgumentParser._apply_no_options#243",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.HTTPieArgumentParser",
        "signature": "httpie.input.HTTPieArgumentParser._apply_no_options(self, no_options)",
        "snippet": "    def _apply_no_options(self, no_options):\n        \"\"\"For every `--no-OPTION` in `no_options`, set `args.OPTION` to\n        its default value. This allows for un-setting of options, e.g.,\n        specified in config.\n\n        \"\"\"\n        invalid = []\n\n        for option in no_options:\n            if not option.startswith('--no-'):\n                invalid.append(option)\n                continue\n\n            # --no-option => --option\n            inverted = '--' + option[5:]\n            for action in self._actions:\n                if inverted in action.option_strings:\n                    setattr(self.args, action.dest, action.default)\n                    break\n            else:\n                invalid.append(option)\n\n        if invalid:\n            msg = 'unrecognized arguments: %s'\n            self.error(msg % ' '.join(invalid))",
        "begin_line": 243,
        "end_line": 267,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0033333333333333335,
            "pseudo_dstar_susp": 0.004366812227074236,
            "pseudo_tarantula_susp": 0.003194888178913738,
            "pseudo_op2_susp": 0.004366812227074236,
            "pseudo_barinel_susp": 0.003194888178913738
        }
    },
    {
        "name": "httpie.input.HTTPieArgumentParser._body_from_file#269",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.HTTPieArgumentParser",
        "signature": "httpie.input.HTTPieArgumentParser._body_from_file(self, fd)",
        "snippet": "    def _body_from_file(self, fd):\n        \"\"\"There can only be one source of request data.\n\n        Bytes are always read.\n\n        \"\"\"\n        if self.args.data:\n            self.error('Request body (from stdin or a file) and request '\n                       'data (key=value) cannot be mixed.')\n        self.args.data = getattr(fd, 'buffer', fd).read()",
        "begin_line": 269,
        "end_line": 278,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0020876826722338203,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.input.HTTPieArgumentParser._guess_method#280",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.HTTPieArgumentParser",
        "signature": "httpie.input.HTTPieArgumentParser._guess_method(self)",
        "snippet": "    def _guess_method(self):\n        \"\"\"Set `args.method` if not specified to either POST or GET\n        based on whether the request has data or not.\n\n        \"\"\"\n        if self.args.method is None:\n            # Invoked as `http URL'.\n            assert not self.args.items\n            if not self.args.ignore_stdin and not self.env.stdin_isatty:\n                self.args.method = HTTP_POST\n            else:\n                self.args.method = HTTP_GET\n\n        # FIXME: False positive, e.g., \"localhost\" matches but is a valid URL.\n        elif not re.match('^[a-zA-Z]+$', self.args.method):\n            # Invoked as `http URL item+'. The URL is now in `args.method`\n            # and the first ITEM is now incorrectly in `args.url`.\n            try:\n                # Parse the URL as an ITEM and store it as the first ITEM arg.\n                self.args.items.insert(0, KeyValueArgType(\n                    *SEP_GROUP_ALL_ITEMS).__call__(self.args.url))\n\n            except ArgumentTypeError as e:\n                if self.args.traceback:\n                    raise\n                self.error(e.args[0])\n\n            else:\n                # Set the URL correctly\n                self.args.url = self.args.method\n                # Infer the method\n                has_data = (\n                    (not self.args.ignore_stdin and not self.env.stdin_isatty)\n                    or any(item.sep in SEP_GROUP_DATA_ITEMS\n                           for item in self.args.items)\n                )\n                self.args.method = HTTP_POST if has_data else HTTP_GET",
        "begin_line": 280,
        "end_line": 316,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0031545741324921135,
            "pseudo_dstar_susp": 0.0040650406504065045,
            "pseudo_tarantula_susp": 0.010869565217391304,
            "pseudo_op2_susp": 0.0040650406504065045,
            "pseudo_barinel_susp": 0.010869565217391304
        }
    },
    {
        "name": "httpie.input.HTTPieArgumentParser._parse_items#318",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.HTTPieArgumentParser",
        "signature": "httpie.input.HTTPieArgumentParser._parse_items(self)",
        "snippet": "    def _parse_items(self):\n        \"\"\"Parse `args.items` into `args.headers`, `args.data`, `args.params`,\n         and `args.files`.\n\n        \"\"\"\n        try:\n            items = parse_items(\n                items=self.args.items,\n                data_class=ParamsDict if self.args.form else OrderedDict\n            )\n        except ParseError as e:\n            if self.args.traceback:\n                raise\n            self.error(e.args[0])\n        else:\n            self.args.headers = items.headers\n            self.args.data = items.data\n            self.args.files = items.files\n            self.args.params = items.params\n\n        if self.args.files and not self.args.form:\n            # `http url @/path/to/file`\n            file_fields = list(self.args.files.keys())\n            if file_fields != ['']:\n                self.error(\n                    'Invalid file fields (perhaps you meant --form?): %s'\n                    % ','.join(file_fields))\n\n            fn, fd, ct = self.args.files['']\n            self.args.files = {}\n\n            self._body_from_file(fd)\n\n            if 'Content-Type' not in self.args.headers:\n                content_type = get_content_type(fn)\n                if content_type:\n                    self.args.headers['Content-Type'] = content_type",
        "begin_line": 318,
        "end_line": 354,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0038022813688212928,
            "pseudo_dstar_susp": 0.005208333333333333,
            "pseudo_tarantula_susp": 0.0036363636363636364,
            "pseudo_op2_susp": 0.005208333333333333,
            "pseudo_barinel_susp": 0.0036363636363636364
        }
    },
    {
        "name": "httpie.input.HTTPieArgumentParser._process_output_options#356",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.HTTPieArgumentParser",
        "signature": "httpie.input.HTTPieArgumentParser._process_output_options(self)",
        "snippet": "    def _process_output_options(self):\n        \"\"\"Apply defaults to output options, or validate the provided ones.\n\n        The default output options are stdout-type-sensitive.\n\n        \"\"\"\n        def check_options(value, option):\n            unknown = set(value) - OUTPUT_OPTIONS\n            if unknown:\n                self.error('Unknown output options: {0}={1}'.format(\n                    option,\n                    ','.join(unknown)\n                ))\n\n        if self.args.verbose:\n            self.args.all = True\n\n        if self.args.output_options is None:\n            if self.args.verbose:\n                self.args.output_options = ''.join(OUTPUT_OPTIONS)\n            else:\n                self.args.output_options = (\n                    OUTPUT_OPTIONS_DEFAULT\n                    if self.env.stdout_isatty\n                    else OUTPUT_OPTIONS_DEFAULT_STDOUT_REDIRECTED\n                )\n\n        if self.args.output_options_others is None:\n            self.args.output_options_others = self.args.output_options\n\n        check_options(self.args.output_options, '--print')\n        check_options(self.args.output_options_others, '--print-others')\n\n        if self.args.download and OUT_RESP_BODY in self.args.output_options:\n            # Response body is always downloaded with --download and it goes\n            # through a different routine, so we remove it.\n            self.args.output_options = str(\n                set(self.args.output_options) - set(OUT_RESP_BODY))",
        "begin_line": 356,
        "end_line": 393,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01,
            "pseudo_dstar_susp": 0.034482758620689655,
            "pseudo_tarantula_susp": 0.010416666666666666,
            "pseudo_op2_susp": 0.034482758620689655,
            "pseudo_barinel_susp": 0.010416666666666666
        }
    },
    {
        "name": "httpie.input.HTTPieArgumentParser.check_options#362",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.HTTPieArgumentParser",
        "signature": "httpie.input.HTTPieArgumentParser.check_options(value, option)",
        "snippet": "        def check_options(value, option):\n            unknown = set(value) - OUTPUT_OPTIONS\n            if unknown:\n                self.error('Unknown output options: {0}={1}'.format(\n                    option,\n                    ','.join(unknown)\n                ))",
        "begin_line": 362,
        "end_line": 368,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.010416666666666666,
            "pseudo_dstar_susp": 0.14285714285714285,
            "pseudo_tarantula_susp": 0.003367003367003367,
            "pseudo_op2_susp": 0.14285714285714285,
            "pseudo_barinel_susp": 0.003367003367003367
        }
    },
    {
        "name": "httpie.input.HTTPieArgumentParser._process_pretty_options#395",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.HTTPieArgumentParser",
        "signature": "httpie.input.HTTPieArgumentParser._process_pretty_options(self)",
        "snippet": "    def _process_pretty_options(self):\n        if self.args.prettify == PRETTY_STDOUT_TTY_ONLY:\n            self.args.prettify = PRETTY_MAP[\n                'all' if self.env.stdout_isatty else 'none']\n        elif (self.args.prettify and self.env.is_windows and\n              self.args.output_file):\n            self.error('Only terminal output can be colorized on Windows.')\n        else:\n            # noinspection PyTypeChecker\n            self.args.prettify = PRETTY_MAP[self.args.prettify]",
        "begin_line": 395,
        "end_line": 404,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005747126436781609,
            "pseudo_dstar_susp": 0.009708737864077669,
            "pseudo_tarantula_susp": 0.005681818181818182,
            "pseudo_op2_susp": 0.009708737864077669,
            "pseudo_barinel_susp": 0.005681818181818182
        }
    },
    {
        "name": "httpie.input.HTTPieArgumentParser._validate_download_options#406",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.HTTPieArgumentParser",
        "signature": "httpie.input.HTTPieArgumentParser._validate_download_options(self)",
        "snippet": "    def _validate_download_options(self):\n        if not self.args.download:\n            if self.args.download_resume:\n                self.error('--continue only works with --download')\n        if self.args.download_resume and not (\n                self.args.download and self.args.output_file):\n            self.error('--continue requires --output to be specified')",
        "begin_line": 406,
        "end_line": 412,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0038022813688212928,
            "pseudo_dstar_susp": 0.005208333333333333,
            "pseudo_tarantula_susp": 0.0036363636363636364,
            "pseudo_op2_susp": 0.005208333333333333,
            "pseudo_barinel_susp": 0.0036363636363636364
        }
    },
    {
        "name": "httpie.input.KeyValue.__init__#422",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.KeyValue",
        "signature": "httpie.input.KeyValue.__init__(self, key, value, sep, orig)",
        "snippet": "    def __init__(self, key, value, sep, orig):\n        self.key = key\n        self.value = value\n        self.sep = sep\n        self.orig = orig",
        "begin_line": 422,
        "end_line": 426,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002638522427440633,
            "pseudo_dstar_susp": 0.002638522427440633,
            "pseudo_tarantula_susp": 0.002857142857142857,
            "pseudo_op2_susp": 0.002638522427440633,
            "pseudo_barinel_susp": 0.002857142857142857
        }
    },
    {
        "name": "httpie.input.KeyValue.__eq__#428",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.KeyValue",
        "signature": "httpie.input.KeyValue.__eq__(self, other)",
        "snippet": "    def __eq__(self, other):\n        return self.__dict__ == other.__dict__",
        "begin_line": 428,
        "end_line": 429,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0016420361247947454,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.input.SessionNameValidator.__call__#440",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.SessionNameValidator",
        "signature": "httpie.input.SessionNameValidator.__call__(self, value)",
        "snippet": "    def __call__(self, value):\n        # Session name can be a path or just a name.\n        if (os.path.sep not in value\n                and not VALID_SESSION_NAME_PATTERN.search(value)):\n            raise ArgumentError(None, self.error_message)\n        return value",
        "begin_line": 440,
        "end_line": 445,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.03571428571428571,
            "pseudo_dstar_susp": 0.0035335689045936395,
            "pseudo_tarantula_susp": 0.038461538461538464,
            "pseudo_op2_susp": 0.0035335689045936395,
            "pseudo_barinel_susp": 0.038461538461538464
        }
    },
    {
        "name": "httpie.input.KeyValueArgType.__init__#458",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.KeyValueArgType",
        "signature": "httpie.input.KeyValueArgType.__init__(self, *separators)",
        "snippet": "    def __init__(self, *separators):\n        self.separators = separators\n        self.special_characters = set('\\\\')\n        for separator in separators:\n            self.special_characters.update(separator)",
        "begin_line": 458,
        "end_line": 462,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0009910802775024777,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.input.KeyValueArgType.__call__#464",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.KeyValueArgType",
        "signature": "httpie.input.KeyValueArgType.__call__(self, string)",
        "snippet": "    def __call__(self, string):\n        \"\"\"Parse `string` and return `self.key_value_class()` instance.\n\n        The best of `self.separators` is determined (first found, longest).\n        Back slash escaped characters aren't considered as separators\n        (or parts thereof). Literal back slash characters have to be escaped\n        as well (r'\\\\').\n\n        \"\"\"\n\n        class Escaped(str):\n            \"\"\"Represents an escaped character.\"\"\"\n\n        def tokenize(string):\n            \"\"\"Tokenize `string`. There are only two token types - strings\n            and escaped characters:\n\n            tokenize(r'foo\\=bar\\\\baz')\n            => ['foo', Escaped('='), 'bar', Escaped('\\\\'), 'baz']\n\n            \"\"\"\n            tokens = ['']\n            characters = iter(string)\n            for char in characters:\n                if char == '\\\\':\n                    char = next(characters, '')\n                    if char not in self.special_characters:\n                        tokens[-1] += '\\\\' + char\n                    else:\n                        tokens.extend([Escaped(char), ''])\n                else:\n                    tokens[-1] += char\n            return tokens\n\n        tokens = tokenize(string)\n\n        # Sorting by length ensures that the longest one will be\n        # chosen as it will overwrite any shorter ones starting\n        # at the same position in the `found` dictionary.\n        separators = sorted(self.separators, key=len)\n\n        for i, token in enumerate(tokens):\n\n            if isinstance(token, Escaped):\n                continue\n\n            found = {}\n            for sep in separators:\n                pos = token.find(sep)\n                if pos != -1:\n                    found[pos] = sep\n\n            if found:\n                # Starting first, longest separator found.\n                sep = found[min(found.keys())]\n\n                key, value = token.split(sep, 1)\n\n                # Any preceding tokens are part of the key.\n                key = ''.join(tokens[:i]) + key\n\n                # Any following tokens are part of the value.\n                value += ''.join(tokens[i + 1:])\n\n                break\n\n        else:\n            raise ArgumentTypeError(\n                u'\"%s\" is not a valid value' % string)\n\n        return self.key_value_class(\n            key=key, value=value, sep=sep, orig=string)",
        "begin_line": 464,
        "end_line": 535,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0028169014084507044,
            "pseudo_dstar_susp": 0.0028169014084507044,
            "pseudo_tarantula_susp": 0.0038022813688212928,
            "pseudo_op2_susp": 0.0028169014084507044,
            "pseudo_barinel_susp": 0.0038022813688212928
        }
    },
    {
        "name": "httpie.input.Escaped.__call__#464",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.Escaped",
        "signature": "httpie.input.Escaped.__call__(self, string)",
        "snippet": "    def __call__(self, string):\n        \"\"\"Parse `string` and return `self.key_value_class()` instance.\n\n        The best of `self.separators` is determined (first found, longest).\n        Back slash escaped characters aren't considered as separators\n        (or parts thereof). Literal back slash characters have to be escaped\n        as well (r'\\\\').\n\n        \"\"\"\n\n        class Escaped(str):\n            \"\"\"Represents an escaped character.\"\"\"\n\n        def tokenize(string):\n            \"\"\"Tokenize `string`. There are only two token types - strings\n            and escaped characters:\n\n            tokenize(r'foo\\=bar\\\\baz')\n            => ['foo', Escaped('='), 'bar', Escaped('\\\\'), 'baz']\n\n            \"\"\"\n            tokens = ['']\n            characters = iter(string)\n            for char in characters:\n                if char == '\\\\':\n                    char = next(characters, '')\n                    if char not in self.special_characters:\n                        tokens[-1] += '\\\\' + char\n                    else:\n                        tokens.extend([Escaped(char), ''])\n                else:\n                    tokens[-1] += char\n            return tokens\n\n        tokens = tokenize(string)\n\n        # Sorting by length ensures that the longest one will be\n        # chosen as it will overwrite any shorter ones starting\n        # at the same position in the `found` dictionary.\n        separators = sorted(self.separators, key=len)\n\n        for i, token in enumerate(tokens):\n\n            if isinstance(token, Escaped):\n                continue\n\n            found = {}\n            for sep in separators:\n                pos = token.find(sep)\n                if pos != -1:\n                    found[pos] = sep\n\n            if found:\n                # Starting first, longest separator found.\n                sep = found[min(found.keys())]\n\n                key, value = token.split(sep, 1)\n\n                # Any preceding tokens are part of the key.\n                key = ''.join(tokens[:i]) + key\n\n                # Any following tokens are part of the value.\n                value += ''.join(tokens[i + 1:])\n\n                break\n\n        else:\n            raise ArgumentTypeError(\n                u'\"%s\" is not a valid value' % string)\n\n        return self.key_value_class(\n            key=key, value=value, sep=sep, orig=string)",
        "begin_line": 464,
        "end_line": 535,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003278688524590164,
            "pseudo_dstar_susp": 0.004273504273504274,
            "pseudo_tarantula_susp": 0.0030581039755351682,
            "pseudo_op2_susp": 0.004273504273504274,
            "pseudo_barinel_susp": 0.0030581039755351682
        }
    },
    {
        "name": "httpie.input.KeyValueArgType.tokenize#477",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.KeyValueArgType",
        "signature": "httpie.input.KeyValueArgType.tokenize(string)",
        "snippet": "        def tokenize(string):\n            \"\"\"Tokenize `string`. There are only two token types - strings\n            and escaped characters:\n\n            tokenize(r'foo\\=bar\\\\baz')\n            => ['foo', Escaped('='), 'bar', Escaped('\\\\'), 'baz']\n\n            \"\"\"\n            tokens = ['']\n            characters = iter(string)\n            for char in characters:\n                if char == '\\\\':\n                    char = next(characters, '')\n                    if char not in self.special_characters:\n                        tokens[-1] += '\\\\' + char\n                    else:\n                        tokens.extend([Escaped(char), ''])\n                else:\n                    tokens[-1] += char\n            return tokens",
        "begin_line": 477,
        "end_line": 496,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003278688524590164,
            "pseudo_dstar_susp": 0.004273504273504274,
            "pseudo_tarantula_susp": 0.0030581039755351682,
            "pseudo_op2_susp": 0.004273504273504274,
            "pseudo_barinel_susp": 0.0030581039755351682
        }
    },
    {
        "name": "httpie.input.AuthCredentials.has_password#545",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.AuthCredentials",
        "signature": "httpie.input.AuthCredentials.has_password(self)",
        "snippet": "    def has_password(self):\n        return self.value is not None",
        "begin_line": 545,
        "end_line": 546,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0010330578512396695,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.input.AuthCredentials.prompt_password#548",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.AuthCredentials",
        "signature": "httpie.input.AuthCredentials.prompt_password(self, host)",
        "snippet": "    def prompt_password(self, host):\n        try:\n            self.value = self._getpass(\n                'http: password for %s@%s: ' % (self.key, host))\n        except (EOFError, KeyboardInterrupt):\n            sys.stderr.write('\\n')\n            sys.exit(0)",
        "begin_line": 548,
        "end_line": 554,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0020876826722338203,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.input.AuthCredentialsArgType.__call__#562",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.AuthCredentialsArgType",
        "signature": "httpie.input.AuthCredentialsArgType.__call__(self, string)",
        "snippet": "    def __call__(self, string):\n        \"\"\"Parse credentials from `string`.\n\n        (\"username\" or \"username:password\").\n\n        \"\"\"\n        try:\n            return super(AuthCredentialsArgType, self).__call__(string)\n        except ArgumentTypeError:\n            # No password provided, will prompt for it later.\n            return self.key_value_class(\n                key=string,\n                value=None,\n                sep=SEP_CREDENTIALS,\n                orig=string\n            )",
        "begin_line": 562,
        "end_line": 577,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0016420361247947454,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.input.RequestItemsDict.__setitem__#595",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.RequestItemsDict",
        "signature": "httpie.input.RequestItemsDict.__setitem__(self, key, value)",
        "snippet": "    def __setitem__(self, key, value):\n        \"\"\" If `key` is assigned more than once, `self[key]` holds a\n        `list` of all the values.\n\n        This allows having multiple fields with the same name in form\n        data and URL params.\n\n        \"\"\"\n        assert not isinstance(value, list)\n        if key not in self:\n            super(RequestItemsDict, self).__setitem__(key, value)\n        else:\n            if not isinstance(self[key], list):\n                super(RequestItemsDict, self).__setitem__(key, [self[key]])\n            self[key].append(value)",
        "begin_line": 595,
        "end_line": 609,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0012484394506866417,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.input.DataDict.items#618",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.DataDict",
        "signature": "httpie.input.DataDict.items(self)",
        "snippet": "    def items(self):\n        for key, values in super(RequestItemsDict, self).items():\n            if not isinstance(values, list):\n                values = [values]\n            for value in values:\n                yield key, value",
        "begin_line": 618,
        "end_line": 623,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0016420361247947454,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.input.get_content_type#630",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input",
        "signature": "httpie.input.get_content_type(filename)",
        "snippet": "def get_content_type(filename):\n    \"\"\"\n    Return the content type for ``filename`` in format appropriate\n    for Content-Type headers, or ``None`` if the file type is unknown\n    to ``mimetypes``.\n\n    \"\"\"\n    mime, encoding = mimetypes.guess_type(filename, strict=False)\n    if mime:\n        content_type = mime\n        if encoding:\n            content_type = '%s; charset=%s' % (mime, encoding)\n        return content_type",
        "begin_line": 630,
        "end_line": 642,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0010162601626016261,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.input.parse_items#645",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input",
        "signature": "httpie.input.parse_items(items, headers_class=CaseInsensitiveDict, data_class=OrderedDict, files_class=DataDict, params_class=ParamsDict)",
        "snippet": "def parse_items(items,\n                headers_class=CaseInsensitiveDict,\n                data_class=OrderedDict,\n                files_class=DataDict,\n                params_class=ParamsDict):\n    \"\"\"Parse `KeyValue` `items` into `data`, `headers`, `files`,\n    and `params`.\n\n    \"\"\"\n    headers = []\n    data = []\n    files = []\n    params = []\n\n    for item in items:\n        value = item.value\n\n        if item.sep == SEP_HEADERS:\n            target = headers\n        elif item.sep == SEP_QUERY:\n            target = params\n        elif item.sep == SEP_FILES:\n            try:\n                with open(os.path.expanduser(value), 'rb') as f:\n                    value = (os.path.basename(value),\n                             BytesIO(f.read()),\n                             get_content_type(value))\n            except IOError as e:\n                raise ParseError('\"%s\": %s' % (item.orig, e))\n            target = files\n\n        elif item.sep in SEP_GROUP_DATA_ITEMS:\n\n            if item.sep in SEP_GROUP_DATA_EMBED_ITEMS:\n                try:\n                    with open(os.path.expanduser(value), 'rb') as f:\n                        value = f.read().decode('utf8')\n                except IOError as e:\n                    raise ParseError('\"%s\": %s' % (item.orig, e))\n                except UnicodeDecodeError:\n                    raise ParseError(\n                        '\"%s\": cannot embed the content of \"%s\",'\n                        ' not a UTF8 or ASCII-encoded text file'\n                        % (item.orig, item.value)\n                    )\n\n            if item.sep in SEP_GROUP_RAW_JSON_ITEMS:\n                try:\n                    value = load_json_preserve_order(value)\n                except ValueError as e:\n                    raise ParseError('\"%s\": %s' % (item.orig, e))\n            target = data\n\n        else:\n            raise TypeError(item)\n\n        target.append((item.key, value))\n\n    return RequestItems(headers_class(headers),\n                        data_class(data),\n                        files_class(files),\n                        params_class(params))",
        "begin_line": 645,
        "end_line": 706,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01020408163265306,
            "pseudo_dstar_susp": 0.004219409282700422,
            "pseudo_tarantula_susp": 0.011111111111111112,
            "pseudo_op2_susp": 0.004219409282700422,
            "pseudo_barinel_susp": 0.011111111111111112
        }
    },
    {
        "name": "httpie.input.readable_file_arg#709",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input",
        "signature": "httpie.input.readable_file_arg(filename)",
        "snippet": "def readable_file_arg(filename):\n    try:\n        open(filename, 'rb')\n    except IOError as ex:\n        raise ArgumentTypeError('%s: %s' % (filename, ex.args[1]))\n    return filename",
        "begin_line": 709,
        "end_line": 714,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0020876826722338203,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.utils.load_json_preserve_order#7",
        "src_path": "httpie/utils.py",
        "class_name": "httpie.utils",
        "signature": "httpie.utils.load_json_preserve_order(s)",
        "snippet": "def load_json_preserve_order(s):\n    if is_py26:\n        return json.loads(s)\n    return json.loads(s, object_pairs_hook=OrderedDict)",
        "begin_line": 7,
        "end_line": 10,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0013812154696132596,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.utils.repr_dict_nice#13",
        "src_path": "httpie/utils.py",
        "class_name": "httpie.utils",
        "signature": "httpie.utils.repr_dict_nice(d)",
        "snippet": "def repr_dict_nice(d):\n    def prepare_dict(d):\n        for k, v in d.items():\n            if isinstance(v, dict):\n                v = dict(prepare_dict(v))\n            elif isinstance(v, bytes):\n                v = v.decode('utf8')\n            elif not isinstance(v, (int, str)):\n                v = repr(v)\n            yield k, v\n    return json.dumps(\n        dict(prepare_dict(d)),\n        indent=4, sort_keys=True,\n    )",
        "begin_line": 13,
        "end_line": 26,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0020876826722338203,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.utils.prepare_dict#14",
        "src_path": "httpie/utils.py",
        "class_name": "httpie.utils",
        "signature": "httpie.utils.prepare_dict(d)",
        "snippet": "    def prepare_dict(d):\n        for k, v in d.items():\n            if isinstance(v, dict):\n                v = dict(prepare_dict(v))\n            elif isinstance(v, bytes):\n                v = v.decode('utf8')\n            elif not isinstance(v, (int, str)):\n                v = repr(v)\n            yield k, v",
        "begin_line": 14,
        "end_line": 22,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0020876826722338203,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.utils.humanize_bytes#29",
        "src_path": "httpie/utils.py",
        "class_name": "httpie.utils",
        "signature": "httpie.utils.humanize_bytes(n, precision=2)",
        "snippet": "def humanize_bytes(n, precision=2):\n    # Author: Doug Latornell\n    # Licence: MIT\n    # URL: http://code.activestate.com/recipes/577081/\n    \"\"\"Return a humanized string representation of a number of bytes.\n\n    Assumes `from __future__ import division`.\n\n    >>> humanize_bytes(1)\n    '1 B'\n    >>> humanize_bytes(1024, precision=1)\n    '1.0 kB'\n    >>> humanize_bytes(1024 * 123, precision=1)\n    '123.0 kB'\n    >>> humanize_bytes(1024 * 12342, precision=1)\n    '12.1 MB'\n    >>> humanize_bytes(1024 * 12342, precision=2)\n    '12.05 MB'\n    >>> humanize_bytes(1024 * 1234, precision=2)\n    '1.21 MB'\n    >>> humanize_bytes(1024 * 1234 * 1111, precision=2)\n    '1.31 GB'\n    >>> humanize_bytes(1024 * 1234 * 1111, precision=1)\n    '1.3 GB'\n\n    \"\"\"\n    abbrevs = [\n        (1 << 50, 'PB'),\n        (1 << 40, 'TB'),\n        (1 << 30, 'GB'),\n        (1 << 20, 'MB'),\n        (1 << 10, 'kB'),\n        (1, 'B')\n    ]\n\n    if n == 1:\n        return '1 B'\n\n    for factor, suffix in abbrevs:\n        if n >= factor:\n            break\n\n    # noinspection PyUnboundLocalVariable\n    return '%.*f %s' % (precision, n / factor, suffix)",
        "begin_line": 29,
        "end_line": 72,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.plugins.manager.PluginManager.__iter__#20",
        "src_path": "httpie/plugins/manager.py",
        "class_name": "httpie.plugins.manager.PluginManager",
        "signature": "httpie.plugins.manager.PluginManager.__iter__(self)",
        "snippet": "    def __iter__(self):\n        return iter(self._plugins)",
        "begin_line": 20,
        "end_line": 21,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007751937984496124,
            "pseudo_dstar_susp": 0.017241379310344827,
            "pseudo_tarantula_susp": 0.007692307692307693,
            "pseudo_op2_susp": 0.017241379310344827,
            "pseudo_barinel_susp": 0.007692307692307693
        }
    },
    {
        "name": "httpie.plugins.manager.PluginManager.load_installed_plugins#27",
        "src_path": "httpie/plugins/manager.py",
        "class_name": "httpie.plugins.manager.PluginManager",
        "signature": "httpie.plugins.manager.PluginManager.load_installed_plugins(self)",
        "snippet": "    def load_installed_plugins(self):\n        for entry_point_name in ENTRY_POINT_NAMES:\n            for entry_point in iter_entry_points(entry_point_name):\n                plugin = entry_point.load()\n                plugin.package_name = entry_point.dist.key\n                self.register(entry_point.load())",
        "begin_line": 27,
        "end_line": 32,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004132231404958678,
            "pseudo_dstar_susp": 0.005847953216374269,
            "pseudo_tarantula_susp": 0.004081632653061225,
            "pseudo_op2_susp": 0.005847953216374269,
            "pseudo_barinel_susp": 0.004081632653061225
        }
    },
    {
        "name": "httpie.plugins.manager.PluginManager.get_auth_plugins#35",
        "src_path": "httpie/plugins/manager.py",
        "class_name": "httpie.plugins.manager.PluginManager",
        "signature": "httpie.plugins.manager.PluginManager.get_auth_plugins(self)",
        "snippet": "    def get_auth_plugins(self):\n        return [plugin for plugin in self if issubclass(plugin, AuthPlugin)]",
        "begin_line": 35,
        "end_line": 36,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0010330578512396695,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.plugins.manager.PluginManager.get_auth_plugin_mapping#38",
        "src_path": "httpie/plugins/manager.py",
        "class_name": "httpie.plugins.manager.PluginManager",
        "signature": "httpie.plugins.manager.PluginManager.get_auth_plugin_mapping(self)",
        "snippet": "    def get_auth_plugin_mapping(self):\n        return dict((plugin.auth_type, plugin)\n                    for plugin in self.get_auth_plugins())",
        "begin_line": 38,
        "end_line": 40,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0010330578512396695,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.plugins.manager.PluginManager.get_auth_plugin#42",
        "src_path": "httpie/plugins/manager.py",
        "class_name": "httpie.plugins.manager.PluginManager",
        "signature": "httpie.plugins.manager.PluginManager.get_auth_plugin(self, auth_type)",
        "snippet": "    def get_auth_plugin(self, auth_type):\n        return self.get_auth_plugin_mapping()[auth_type]",
        "begin_line": 42,
        "end_line": 43,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0010330578512396695,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.plugins.manager.PluginManager.get_formatters#46",
        "src_path": "httpie/plugins/manager.py",
        "class_name": "httpie.plugins.manager.PluginManager",
        "signature": "httpie.plugins.manager.PluginManager.get_formatters(self)",
        "snippet": "    def get_formatters(self):\n        return [plugin for plugin in self\n                if issubclass(plugin, FormatterPlugin)]",
        "begin_line": 46,
        "end_line": 48,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.000855431993156544,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.plugins.manager.PluginManager.get_formatters_grouped#50",
        "src_path": "httpie/plugins/manager.py",
        "class_name": "httpie.plugins.manager.PluginManager",
        "signature": "httpie.plugins.manager.PluginManager.get_formatters_grouped(self)",
        "snippet": "    def get_formatters_grouped(self):\n        groups = {}\n        for group_name, group in groupby(\n                self.get_formatters(),\n                key=lambda p: getattr(p, 'group_name', 'format')):\n            groups[group_name] = list(group)\n        return groups",
        "begin_line": 50,
        "end_line": 56,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.000855431993156544,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.plugins.manager.PluginManager.get_converters#58",
        "src_path": "httpie/plugins/manager.py",
        "class_name": "httpie.plugins.manager.PluginManager",
        "signature": "httpie.plugins.manager.PluginManager.get_converters(self)",
        "snippet": "    def get_converters(self):\n        return [plugin for plugin in self\n                if issubclass(plugin, ConverterPlugin)]",
        "begin_line": 58,
        "end_line": 60,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0014771048744460858,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.plugins.manager.PluginManager.get_transport_plugins#63",
        "src_path": "httpie/plugins/manager.py",
        "class_name": "httpie.plugins.manager.PluginManager",
        "signature": "httpie.plugins.manager.PluginManager.get_transport_plugins(self)",
        "snippet": "    def get_transport_plugins(self):\n        return [plugin for plugin in self\n                if issubclass(plugin, TransportPlugin)]",
        "begin_line": 63,
        "end_line": 65,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.010869565217391304,
            "pseudo_dstar_susp": 0.3333333333333333,
            "pseudo_tarantula_susp": 0.007692307692307693,
            "pseudo_op2_susp": 0.3333333333333333,
            "pseudo_barinel_susp": 0.007692307692307693
        }
    },
    {
        "name": "httpie.core.get_exit_status#34",
        "src_path": "httpie/core.py",
        "class_name": "httpie.core",
        "signature": "httpie.core.get_exit_status(http_status, follow=False)",
        "snippet": "def get_exit_status(http_status, follow=False):\n    \"\"\"Translate HTTP status code to exit status code.\"\"\"\n    if 300 <= http_status <= 399 and not follow:\n        # Redirect\n        return ExitStatus.ERROR_HTTP_3XX\n    elif 400 <= http_status <= 499:\n        # Client Error\n        return ExitStatus.ERROR_HTTP_4XX\n    elif 500 <= http_status <= 599:\n        # Server Error\n        return ExitStatus.ERROR_HTTP_5XX\n    else:\n        return ExitStatus.OK",
        "begin_line": 34,
        "end_line": 46,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0020876826722338203,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.core.print_debug_info#49",
        "src_path": "httpie/core.py",
        "class_name": "httpie.core",
        "signature": "httpie.core.print_debug_info(env)",
        "snippet": "def print_debug_info(env):\n    env.stderr.writelines([\n        'HTTPie %s\\n' % httpie_version,\n        'Requests %s\\n' % requests_version,\n        'Pygments %s\\n' % pygments_version,\n        'Python %s\\n%s\\n' % (sys.version, sys.executable),\n        '%s %s' % (platform.system(), platform.release()),\n    ])\n    env.stderr.write('\\n\\n')\n    env.stderr.write(repr(env))\n    env.stderr.write('\\n')",
        "begin_line": 49,
        "end_line": 59,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0020876826722338203,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.core.decode_args#62",
        "src_path": "httpie/core.py",
        "class_name": "httpie.core",
        "signature": "httpie.core.decode_args(args, stdin_encoding)",
        "snippet": "def decode_args(args, stdin_encoding):\n    \"\"\"\n    Convert all bytes ags to str\n    by decoding them using stdin encoding.\n\n    \"\"\"\n    return [\n        arg.decode(stdin_encoding)\n        if type(arg) == bytes else arg\n        for arg in args\n    ]",
        "begin_line": 62,
        "end_line": 72,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.010526315789473684,
            "pseudo_dstar_susp": 0.16666666666666666,
            "pseudo_tarantula_susp": 0.004081632653061225,
            "pseudo_op2_susp": 0.16666666666666666,
            "pseudo_barinel_susp": 0.004081632653061225
        }
    },
    {
        "name": "httpie.core.program#75",
        "src_path": "httpie/core.py",
        "class_name": "httpie.core",
        "signature": "httpie.core.program(args, env, log_error)",
        "snippet": "def program(args, env, log_error):\n    \"\"\"\n    The main program without error handling\n\n    :param args: parsed args (argparse.Namespace)\n    :type env: Environment\n    :param log_error: error log function\n    :return: status code\n\n    \"\"\"\n    exit_status = ExitStatus.OK\n    downloader = None\n    show_traceback = args.debug or args.traceback\n\n    try:\n        if args.download:\n            args.follow = True  # --download implies --follow.\n            downloader = Downloader(\n                output_file=args.output_file,\n                progress_file=env.stderr,\n                resume=args.download_resume\n            )\n            downloader.pre_request(args.headers)\n\n        final_response = get_response(args, config_dir=env.config.directory)\n        if args.all:\n            responses = final_response.history + [final_response]\n        else:\n            responses = [final_response]\n\n        for response in responses:\n\n            if args.check_status or downloader:\n                exit_status = get_exit_status(\n                    http_status=response.status_code,\n                    follow=args.follow\n                )\n                if not env.stdout_isatty and exit_status != ExitStatus.OK:\n                    log_error(\n                        'HTTP %s %s', response.raw.status, response.raw.reason,\n                        level='warning'\n                    )\n\n            write_stream_kwargs = {\n                'stream': build_output_stream(\n                    args=args,\n                    env=env,\n                    request=response.request,\n                    response=response,\n                    output_options=(\n                        args.output_options\n                        if response is final_response\n                        else args.output_options_others\n                    )\n                ),\n                # NOTE: `env.stdout` will in fact be `stderr` with `--download`\n                'outfile': env.stdout,\n                'flush': env.stdout_isatty or args.stream\n            }\n            try:\n                if env.is_windows and is_py3 and 'colors' in args.prettify:\n                    write_stream_with_colors_win_py3(**write_stream_kwargs)\n                else:\n                    write_stream(**write_stream_kwargs)\n            except IOError as e:\n                if not show_traceback and e.errno == errno.EPIPE:\n                    # Ignore broken pipes unless --traceback.\n                    env.stderr.write('\\n')\n                else:\n                    raise\n\n        if downloader and exit_status == ExitStatus.OK:\n            # Last response body download.\n            download_stream, download_to = downloader.start(final_response)\n            write_stream(\n                stream=download_stream,\n                outfile=download_to,\n                flush=False,\n            )\n            downloader.finish()\n            if downloader.interrupted:\n                exit_status = ExitStatus.ERROR\n                log_error('Incomplete download: size=%d; downloaded=%d' % (\n                    downloader.status.total_size,\n                    downloader.status.downloaded\n                ))\n        return exit_status\n\n    finally:\n        if downloader and not downloader.finished:\n            downloader.failed()\n\n        if (not isinstance(args, list) and args.output_file and\n                args.output_file_specified):\n            args.output_file.close()",
        "begin_line": 75,
        "end_line": 169,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006024096385542169,
            "pseudo_dstar_susp": 0.010526315789473684,
            "pseudo_tarantula_susp": 0.005952380952380952,
            "pseudo_op2_susp": 0.010526315789473684,
            "pseudo_barinel_susp": 0.005952380952380952
        }
    },
    {
        "name": "httpie.core.main#172",
        "src_path": "httpie/core.py",
        "class_name": "httpie.core",
        "signature": "httpie.core.main(args=sys.argv[1:], env=Environment(), custom_log_error=None)",
        "snippet": "def main(args=sys.argv[1:], env=Environment(), custom_log_error=None):\n    \"\"\"\n    The main function.\n\n    Pre-process args, handle some special types of invocations,\n    and run the main program with error handling.\n\n    Return exit status code.\n\n    \"\"\"\n    args = decode_args(args, env.stdin_encoding)\n    plugin_manager.load_installed_plugins()\n\n    def log_error(msg, *args, **kwargs):\n        msg = msg % args\n        level = kwargs.get('level', 'error')\n        assert level in ['error', 'warning']\n        env.stderr.write('\\nhttp: %s: %s\\n' % (level, msg))\n\n    from httpie.cli import parser\n\n    if env.config.default_options:\n        args = env.config.default_options + args\n\n    if custom_log_error:\n        log_error = custom_log_error\n\n    include_debug_info = '--debug' in args\n    include_traceback = include_debug_info or '--traceback' in args\n\n    if include_debug_info:\n        print_debug_info(env)\n        if args == ['--debug']:\n            return ExitStatus.OK\n\n    exit_status = ExitStatus.OK\n\n    try:\n        parsed_args = parser.parse_args(args=args, env=env)\n    except KeyboardInterrupt:\n        env.stderr.write('\\n')\n        if include_traceback:\n            raise\n        exit_status = ExitStatus.ERROR\n    except SystemExit as e:\n        if e.code != ExitStatus.OK:\n            env.stderr.write('\\n')\n            if include_traceback:\n                raise\n            exit_status = ExitStatus.ERROR\n    else:\n        try:\n            exit_status = program(\n                args=parsed_args,\n                env=env,\n                log_error=log_error,\n            )\n        except KeyboardInterrupt:\n            env.stderr.write('\\n')\n            if include_traceback:\n                raise\n            exit_status = ExitStatus.ERROR\n        except SystemExit as e:\n            if e.code != ExitStatus.OK:\n                env.stderr.write('\\n')\n                if include_traceback:\n                    raise\n                exit_status = ExitStatus.ERROR\n        except requests.Timeout:\n            exit_status = ExitStatus.ERROR_TIMEOUT\n            log_error('Request timed out (%ss).', parsed_args.timeout)\n        except requests.TooManyRedirects:\n            exit_status = ExitStatus.ERROR_TOO_MANY_REDIRECTS\n            log_error('Too many redirects (--max-redirects=%s).',\n                  parsed_args.max_redirects)\n        except Exception as e:\n            # TODO: Further distinction between expected and unexpected errors.\n            msg = str(e)\n            if hasattr(e, 'request'):\n                request = e.request\n                if hasattr(request, 'url'):\n                    msg += ' while doing %s request to URL: %s' % (\n                        request.method, request.url)\n            log_error('%s: %s', type(e).__name__, msg)\n            if include_traceback:\n                raise\n            exit_status = ExitStatus.ERROR\n\n    return exit_status",
        "begin_line": 172,
        "end_line": 260,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.16666666666666666,
            "pseudo_dstar_susp": 0.09090909090909091,
            "pseudo_tarantula_susp": 0.16666666666666666,
            "pseudo_op2_susp": 0.09090909090909091,
            "pseudo_barinel_susp": 0.16666666666666666
        }
    },
    {
        "name": "httpie.core.log_error#185",
        "src_path": "httpie/core.py",
        "class_name": "httpie.core",
        "signature": "httpie.core.log_error(msg, *args, **kwargs)",
        "snippet": "    def log_error(msg, *args, **kwargs):\n        msg = msg % args\n        level = kwargs.get('level', 'error')\n        assert level in ['error', 'warning']\n        env.stderr.write('\\nhttp: %s: %s\\n' % (level, msg))",
        "begin_line": 185,
        "end_line": 189,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0625,
            "pseudo_dstar_susp": 1.0,
            "pseudo_tarantula_susp": 0.058823529411764705,
            "pseudo_op2_susp": 1.0,
            "pseudo_barinel_susp": 0.058823529411764705
        }
    },
    {
        "name": "httpie.plugins.base.FormatterPlugin.__init__#67",
        "src_path": "httpie/plugins/base.py",
        "class_name": "httpie.plugins.base.FormatterPlugin",
        "signature": "httpie.plugins.base.FormatterPlugin.__init__(self, **kwargs)",
        "snippet": "    def __init__(self, **kwargs):\n        \"\"\"\n        :param env: an class:`Environment` instance\n        :param kwargs: additional keyword argument that some\n                       processor might require.\n\n        \"\"\"\n        self.enabled = True\n        self.kwargs = kwargs",
        "begin_line": 67,
        "end_line": 75,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.000855431993156544,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.plugins.base.FormatterPlugin.format_headers#77",
        "src_path": "httpie/plugins/base.py",
        "class_name": "httpie.plugins.base.FormatterPlugin",
        "signature": "httpie.plugins.base.FormatterPlugin.format_headers(self, headers)",
        "snippet": "    def format_headers(self, headers):\n        \"\"\"Return processed `headers`\n\n        :param headers: The headers as text.\n\n        \"\"\"\n        return headers",
        "begin_line": 77,
        "end_line": 83,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0008936550491510277,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.plugins.base.FormatterPlugin.format_body#85",
        "src_path": "httpie/plugins/base.py",
        "class_name": "httpie.plugins.base.FormatterPlugin",
        "signature": "httpie.plugins.base.FormatterPlugin.format_body(self, content, mime)",
        "snippet": "    def format_body(self, content, mime):\n        \"\"\"Return processed `content`.\n\n        :param mime: E.g., 'application/atom+xml'.\n        :param content: The body content as text\n\n        \"\"\"\n        return content",
        "begin_line": 85,
        "end_line": 92,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0009174311926605505,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.formatters.colors.ColorFormatter.__init__#39",
        "src_path": "httpie/output/formatters/colors.py",
        "class_name": "httpie.output.formatters.colors.ColorFormatter",
        "signature": "httpie.output.formatters.colors.ColorFormatter.__init__(self, env, explicit_json=False, color_scheme=DEFAULT_STYLE, **kwargs)",
        "snippet": "    def __init__(self, env, explicit_json=False,\n                 color_scheme=DEFAULT_STYLE, **kwargs):\n        super(ColorFormatter, self).__init__(**kwargs)\n        if not env.colors:\n            self.enabled = False\n            return\n\n        # --json, -j\n        self.explicit_json = explicit_json\n\n        try:\n            style_class = pygments.styles.get_style_by_name(color_scheme)\n        except ClassNotFound:\n            style_class = Solarized256Style\n\n        if env.colors == 256:\n            fmt_class = Terminal256Formatter\n        else:\n            fmt_class = TerminalFormatter\n        self.formatter = fmt_class(style=style_class)",
        "begin_line": 39,
        "end_line": 58,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0012484394506866417,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.formatters.colors.ColorFormatter.format_headers#60",
        "src_path": "httpie/output/formatters/colors.py",
        "class_name": "httpie.output.formatters.colors.ColorFormatter",
        "signature": "httpie.output.formatters.colors.ColorFormatter.format_headers(self, headers)",
        "snippet": "    def format_headers(self, headers):\n        return pygments.highlight(headers, HTTPLexer(), self.formatter).strip()",
        "begin_line": 60,
        "end_line": 61,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0016420361247947454,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.formatters.colors.ColorFormatter.format_body#63",
        "src_path": "httpie/output/formatters/colors.py",
        "class_name": "httpie.output.formatters.colors.ColorFormatter",
        "signature": "httpie.output.formatters.colors.ColorFormatter.format_body(self, body, mime)",
        "snippet": "    def format_body(self, body, mime):\n        lexer = self.get_lexer(mime, body)\n        if lexer:\n            body = pygments.highlight(body, lexer, self.formatter)\n        return body.strip()",
        "begin_line": 63,
        "end_line": 67,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0012484394506866417,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.formatters.colors.ColorFormatter.get_lexer#69",
        "src_path": "httpie/output/formatters/colors.py",
        "class_name": "httpie.output.formatters.colors.ColorFormatter",
        "signature": "httpie.output.formatters.colors.ColorFormatter.get_lexer(self, mime, body)",
        "snippet": "    def get_lexer(self, mime, body):\n        return get_lexer(\n            mime=mime,\n            explicit_json=self.explicit_json,\n            body=body,\n        )",
        "begin_line": 69,
        "end_line": 74,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0012484394506866417,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.formatters.colors.get_lexer#77",
        "src_path": "httpie/output/formatters/colors.py",
        "class_name": "httpie.output.formatters.colors",
        "signature": "httpie.output.formatters.colors.get_lexer(mime, explicit_json=False, body='')",
        "snippet": "def get_lexer(mime, explicit_json=False, body=''):\n\n    # Build candidate mime type and lexer names.\n    mime_types, lexer_names = [mime], []\n    type_, subtype = mime.split('/', 1)\n    if '+' not in subtype:\n        lexer_names.append(subtype)\n    else:\n        subtype_name, subtype_suffix = subtype.split('+', 1)\n        lexer_names.extend([subtype_name, subtype_suffix])\n        mime_types.extend([\n            '%s/%s' % (type_, subtype_name),\n            '%s/%s' % (type_, subtype_suffix)\n        ])\n\n    # As a last resort, if no lexer feels responsible, and\n    # the subtype contains 'json', take the JSON lexer\n    if 'json' in subtype:\n        lexer_names.append('json')\n\n    # Try to resolve the right lexer.\n    lexer = None\n    for mime_type in mime_types:\n        try:\n            lexer = pygments.lexers.get_lexer_for_mimetype(mime_type)\n            break\n        except ClassNotFound:\n            pass\n    else:\n        for name in lexer_names:\n            try:\n                lexer = pygments.lexers.get_lexer_by_name(name)\n            except ClassNotFound:\n                pass\n\n    if explicit_json and body and (not lexer or isinstance(lexer, TextLexer)):\n        # JSON response with an incorrect Content-Type?\n        try:\n            json.loads(body)  # FIXME: the body also gets parsed in json.py\n        except ValueError:\n            pass  # Nope\n        else:\n            lexer = pygments.lexers.get_lexer_by_name('json')\n\n    return lexer",
        "begin_line": 77,
        "end_line": 121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0020876826722338203,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.streams.write_stream#27",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams",
        "signature": "httpie.output.streams.write_stream(stream, outfile, flush)",
        "snippet": "def write_stream(stream, outfile, flush):\n    \"\"\"Write the output stream.\"\"\"\n    try:\n        # Writing bytes so we use the buffer interface (Python 3).\n        buf = outfile.buffer\n    except AttributeError:\n        buf = outfile\n\n    for chunk in stream:\n        buf.write(chunk)\n        if flush:\n            outfile.flush()",
        "begin_line": 27,
        "end_line": 38,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0008396305625524769,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.streams.build_output_stream#58",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams",
        "signature": "httpie.output.streams.build_output_stream(args, env, request, response, output_options)",
        "snippet": "def build_output_stream(args, env, request, response, output_options):\n    \"\"\"Build and return a chain of iterators over the `request`-`response`\n    exchange each of which yields `bytes` chunks.\n\n    \"\"\"\n    req_h = OUT_REQ_HEAD in output_options\n    req_b = OUT_REQ_BODY in output_options\n    resp_h = OUT_RESP_HEAD in output_options\n    resp_b = OUT_RESP_BODY in output_options\n    req = req_h or req_b\n    resp = resp_h or resp_b\n\n    output = []\n    Stream = get_stream_type(env, args)\n\n    if req:\n        output.append(Stream(\n            msg=HTTPRequest(request),\n            with_headers=req_h,\n            with_body=req_b))\n\n    if req_b and resp:\n        # Request/Response separator.\n        output.append([b'\\n\\n'])\n\n    if resp:\n        output.append(Stream(\n            msg=HTTPResponse(response),\n            with_headers=resp_h,\n            with_body=resp_b))\n\n    if env.stdout_isatty and resp_b:\n        # Ensure a blank line after the response body.\n        # For terminal output only.\n        output.append([b'\\n\\n'])\n\n    return chain(*output)",
        "begin_line": 58,
        "end_line": 94,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0009813542688910696,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.streams.get_stream_type#97",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams",
        "signature": "httpie.output.streams.get_stream_type(env, args)",
        "snippet": "def get_stream_type(env, args):\n    \"\"\"Pick the right stream type based on `env` and `args`.\n    Wrap it in a partial with the type-specific args so that\n    we don't need to think what stream we are dealing with.\n\n    \"\"\"\n    if not env.stdout_isatty and not args.prettify:\n        Stream = partial(\n            RawStream,\n            chunk_size=RawStream.CHUNK_SIZE_BY_LINE\n            if args.stream\n            else RawStream.CHUNK_SIZE\n        )\n    elif args.prettify:\n        Stream = partial(\n            PrettyStream if args.stream else BufferedPrettyStream,\n            env=env,\n            conversion=Conversion(),\n            formatting=Formatting(\n                env=env,\n                groups=args.prettify,\n                color_scheme=args.style,\n                explicit_json=args.json,\n            ),\n        )\n    else:\n        Stream = partial(EncodedStream, env=env)\n\n    return Stream",
        "begin_line": 97,
        "end_line": 125,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0013812154696132596,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.streams.BaseStream.__init__#131",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.BaseStream",
        "signature": "httpie.output.streams.BaseStream.__init__(self, msg, with_headers=True, with_body=True, on_body_chunk_downloaded=None)",
        "snippet": "    def __init__(self, msg, with_headers=True, with_body=True,\n                 on_body_chunk_downloaded=None):\n        \"\"\"\n        :param msg: a :class:`models.HTTPMessage` subclass\n        :param with_headers: if `True`, headers will be included\n        :param with_body: if `True`, body will be included\n\n        \"\"\"\n        assert with_headers or with_body\n        self.msg = msg\n        self.with_headers = with_headers\n        self.with_body = with_body\n        self.on_body_chunk_downloaded = on_body_chunk_downloaded",
        "begin_line": 131,
        "end_line": 143,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0007980845969672786,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.streams.BaseStream.get_headers#145",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.BaseStream",
        "signature": "httpie.output.streams.BaseStream.get_headers(self)",
        "snippet": "    def get_headers(self):\n        \"\"\"Return the headers' bytes.\"\"\"\n        return self.msg.headers.encode('utf8')",
        "begin_line": 145,
        "end_line": 147,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.001092896174863388,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.streams.BaseStream.__iter__#153",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.BaseStream",
        "signature": "httpie.output.streams.BaseStream.__iter__(self)",
        "snippet": "    def __iter__(self):\n        \"\"\"Return an iterator over `self.msg`.\"\"\"\n        if self.with_headers:\n            yield self.get_headers()\n            yield b'\\r\\n\\r\\n'\n\n        if self.with_body:\n            try:\n                for chunk in self.iter_body():\n                    yield chunk\n                    if self.on_body_chunk_downloaded:\n                        self.on_body_chunk_downloaded(chunk)\n            except BinarySuppressedError as e:\n                if self.with_headers:\n                    yield b'\\n'\n                yield e.message",
        "begin_line": 153,
        "end_line": 168,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0016420361247947454,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.streams.RawStream.__init__#177",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.RawStream",
        "signature": "httpie.output.streams.RawStream.__init__(self, chunk_size=CHUNK_SIZE, **kwargs)",
        "snippet": "    def __init__(self, chunk_size=CHUNK_SIZE, **kwargs):\n        super(RawStream, self).__init__(**kwargs)\n        self.chunk_size = chunk_size",
        "begin_line": 177,
        "end_line": 179,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0009910802775024777,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.streams.RawStream.iter_body#181",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.RawStream",
        "signature": "httpie.output.streams.RawStream.iter_body(self)",
        "snippet": "    def iter_body(self):\n        return self.msg.iter_body(self.chunk_size)",
        "begin_line": 181,
        "end_line": 182,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0010330578512396695,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.streams.EncodedStream.__init__#195",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.EncodedStream",
        "signature": "httpie.output.streams.EncodedStream.__init__(self, env=Environment(), **kwargs)",
        "snippet": "    def __init__(self, env=Environment(), **kwargs):\n\n        super(EncodedStream, self).__init__(**kwargs)\n\n        if env.stdout_isatty:\n            # Use the encoding supported by the terminal.\n            output_encoding = env.stdout_encoding\n        else:\n            # Preserve the message encoding.\n            output_encoding = self.msg.encoding\n\n        # Default to utf8 when unsure.\n        self.output_encoding = output_encoding or 'utf8'",
        "begin_line": 195,
        "end_line": 207,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0014771048744460858,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.streams.EncodedStream.iter_body#209",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.EncodedStream",
        "signature": "httpie.output.streams.EncodedStream.iter_body(self)",
        "snippet": "    def iter_body(self):\n\n        for line, lf in self.msg.iter_lines(self.CHUNK_SIZE):\n\n            if b'\\0' in line:\n                raise BinarySuppressedError()\n\n            yield line.decode(self.msg.encoding) \\\n                      .encode(self.output_encoding, 'replace') + lf",
        "begin_line": 209,
        "end_line": 217,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0020876826722338203,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.streams.PrettyStream.__init__#231",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.PrettyStream",
        "signature": "httpie.output.streams.PrettyStream.__init__(self, conversion, formatting, **kwargs)",
        "snippet": "    def __init__(self, conversion, formatting, **kwargs):\n        super(PrettyStream, self).__init__(**kwargs)\n        self.formatting = formatting\n        self.conversion = conversion\n        self.mime = self.msg.content_type.split(';')[0]",
        "begin_line": 231,
        "end_line": 235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.000855431993156544,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.streams.PrettyStream.get_headers#237",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.PrettyStream",
        "signature": "httpie.output.streams.PrettyStream.get_headers(self)",
        "snippet": "    def get_headers(self):\n        return self.formatting.format_headers(\n            self.msg.headers).encode(self.output_encoding)",
        "begin_line": 237,
        "end_line": 239,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0008936550491510277,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.streams.PrettyStream.iter_body#241",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.PrettyStream",
        "signature": "httpie.output.streams.PrettyStream.iter_body(self)",
        "snippet": "    def iter_body(self):\n        first_chunk = True\n        iter_lines = self.msg.iter_lines(self.CHUNK_SIZE)\n        for line, lf in iter_lines:\n            if b'\\0' in line:\n                if first_chunk:\n                    converter = self.conversion.get_converter(self.mime)\n                    if converter:\n                        body = bytearray()\n                        # noinspection PyAssignmentToLoopOrWithParameter\n                        for line, lf in chain([(line, lf)], iter_lines):\n                            body.extend(line)\n                            body.extend(lf)\n                        self.mime, body = converter.convert(body)\n                        assert isinstance(body, str)\n                        yield self.process_body(body)\n                        return\n                raise BinarySuppressedError()\n            yield self.process_body(line) + lf\n            first_chunk = False",
        "begin_line": 241,
        "end_line": 260,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0020876826722338203,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.streams.PrettyStream.process_body#262",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.PrettyStream",
        "signature": "httpie.output.streams.PrettyStream.process_body(self, chunk)",
        "snippet": "    def process_body(self, chunk):\n        if not isinstance(chunk, str):\n            # Text when a converter has been used,\n            # otherwise it will always be bytes.\n            chunk = chunk.decode(self.msg.encoding, 'replace')\n        chunk = self.formatting.format_body(content=chunk, mime=self.mime)\n        return chunk.encode(self.output_encoding, 'replace')",
        "begin_line": 262,
        "end_line": 268,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0009041591320072332,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.streams.BufferedPrettyStream.iter_body#281",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.BufferedPrettyStream",
        "signature": "httpie.output.streams.BufferedPrettyStream.iter_body(self)",
        "snippet": "    def iter_body(self):\n        # Read the whole body before prettifying it,\n        # but bail out immediately if the body is binary.\n        converter = None\n        body = bytearray()\n\n        for chunk in self.msg.iter_body(self.CHUNK_SIZE):\n            if not converter and b'\\0' in chunk:\n                converter = self.conversion.get_converter(self.mime)\n                if not converter:\n                    raise BinarySuppressedError()\n            body.extend(chunk)\n\n        if converter:\n            self.mime, body = converter.convert(body)\n\n        yield self.process_body(body)",
        "begin_line": 281,
        "end_line": 297,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0016420361247947454,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.sessions.get_response#23",
        "src_path": "httpie/sessions.py",
        "class_name": "httpie.sessions",
        "signature": "httpie.sessions.get_response(requests_session, session_name, config_dir, args, read_only=False)",
        "snippet": "def get_response(requests_session, session_name,\n                 config_dir, args, read_only=False):\n    \"\"\"Like `client.get_responses`, but applies permanent\n    aspects of the session to the request.\n\n    \"\"\"\n    from .client import get_requests_kwargs, dump_request\n    if os.path.sep in session_name:\n        path = os.path.expanduser(session_name)\n    else:\n        hostname = (args.headers.get('Host', None) or\n                    urlsplit(args.url).netloc.split('@')[-1])\n        if not hostname:\n            # HACK/FIXME: httpie-unixsocket's URLs have no hostname.\n            hostname = 'localhost'\n\n        # host:port => host_port\n        hostname = hostname.replace(':', '_')\n        path = os.path.join(config_dir,\n                            SESSIONS_DIR_NAME,\n                            hostname,\n                            session_name + '.json')\n\n    session = Session(path)\n    session.load()\n\n    kwargs = get_requests_kwargs(args, base_headers=session.headers)\n    if args.debug:\n        dump_request(kwargs)\n    session.update_headers(kwargs['headers'])\n\n    if args.auth:\n        session.auth = {\n            'type': args.auth_type,\n            'username': args.auth.key,\n            'password': args.auth.value,\n        }\n    elif session.auth:\n        kwargs['auth'] = session.auth\n\n    requests_session.cookies = session.cookies\n\n    try:\n        response = requests_session.request(**kwargs)\n    except Exception:\n        raise\n    else:\n        # Existing sessions with `read_only=True` don't get updated.\n        if session.is_new() or not read_only:\n            session.cookies = requests_session.cookies\n            session.save()\n        return response",
        "begin_line": 23,
        "end_line": 74,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.5,
            "pseudo_dstar_susp": 0.0036231884057971015,
            "pseudo_tarantula_susp": 0.5,
            "pseudo_op2_susp": 0.0036231884057971015,
            "pseudo_barinel_susp": 0.5
        }
    },
    {
        "name": "httpie.sessions.Session.__init__#81",
        "src_path": "httpie/sessions.py",
        "class_name": "httpie.sessions.Session",
        "signature": "httpie.sessions.Session.__init__(self, path, *args, **kwargs)",
        "snippet": "    def __init__(self, path, *args, **kwargs):\n        super(Session, self).__init__(*args, **kwargs)\n        self._path = path\n        self['headers'] = {}\n        self['cookies'] = {}\n        self['auth'] = {\n            'type': None,\n            'username': None,\n            'password': None\n        }",
        "begin_line": 81,
        "end_line": 90,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01694915254237288,
            "pseudo_dstar_susp": 0.0031847133757961785,
            "pseudo_tarantula_susp": 0.017241379310344827,
            "pseudo_op2_susp": 0.0031847133757961785,
            "pseudo_barinel_susp": 0.017241379310344827
        }
    },
    {
        "name": "httpie.sessions.Session._get_path#92",
        "src_path": "httpie/sessions.py",
        "class_name": "httpie.sessions.Session",
        "signature": "httpie.sessions.Session._get_path(self)",
        "snippet": "    def _get_path(self):\n        return self._path",
        "begin_line": 92,
        "end_line": 93,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01694915254237288,
            "pseudo_dstar_susp": 0.0031847133757961785,
            "pseudo_tarantula_susp": 0.017241379310344827,
            "pseudo_op2_susp": 0.0031847133757961785,
            "pseudo_barinel_susp": 0.017241379310344827
        }
    },
    {
        "name": "httpie.sessions.Session.update_headers#95",
        "src_path": "httpie/sessions.py",
        "class_name": "httpie.sessions.Session",
        "signature": "httpie.sessions.Session.update_headers(self, request_headers)",
        "snippet": "    def update_headers(self, request_headers):\n        \"\"\"\n        Update the session headers with the request ones while ignoring\n        certain name prefixes.\n\n        :type request_headers: dict\n\n        \"\"\"\n        for name, value in request_headers.items():\n\n            if value is None:\n                continue  # Ignore explicitely unset headers\n\n            value = value.decode('utf8')\n            if name == 'User-Agent' and value.startswith('HTTPie/'):\n                continue\n\n            for prefix in SESSION_IGNORED_HEADER_PREFIXES:\n                if name.lower().startswith(prefix.lower()):\n                    break\n            else:\n                self['headers'][name] = value",
        "begin_line": 95,
        "end_line": 116,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.5,
            "pseudo_dstar_susp": 0.0036231884057971015,
            "pseudo_tarantula_susp": 0.5,
            "pseudo_op2_susp": 0.0036231884057971015,
            "pseudo_barinel_susp": 0.5
        }
    },
    {
        "name": "httpie.sessions.Session.headers#119",
        "src_path": "httpie/sessions.py",
        "class_name": "httpie.sessions.Session",
        "signature": "httpie.sessions.Session.headers(self)",
        "snippet": "    def headers(self):\n        return self['headers']",
        "begin_line": 119,
        "end_line": 120,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01694915254237288,
            "pseudo_dstar_susp": 0.0031847133757961785,
            "pseudo_tarantula_susp": 0.017241379310344827,
            "pseudo_op2_susp": 0.0031847133757961785,
            "pseudo_barinel_susp": 0.017241379310344827
        }
    },
    {
        "name": "httpie.sessions.Session.cookies#123",
        "src_path": "httpie/sessions.py",
        "class_name": "httpie.sessions.Session",
        "signature": "httpie.sessions.Session.cookies(self)",
        "snippet": "    def cookies(self):\n        jar = RequestsCookieJar()\n        for name, cookie_dict in self['cookies'].items():\n            jar.set_cookie(create_cookie(\n                name, cookie_dict.pop('value'), **cookie_dict))\n        jar.clear_expired_cookies()\n        return jar",
        "begin_line": 123,
        "end_line": 129,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01694915254237288,
            "pseudo_dstar_susp": 0.0031847133757961785,
            "pseudo_tarantula_susp": 0.017241379310344827,
            "pseudo_op2_susp": 0.0031847133757961785,
            "pseudo_barinel_susp": 0.017241379310344827
        }
    },
    {
        "name": "httpie.sessions.Session.cookies#132",
        "src_path": "httpie/sessions.py",
        "class_name": "httpie.sessions.Session",
        "signature": "httpie.sessions.Session.cookies(self, jar)",
        "snippet": "    def cookies(self, jar):\n        \"\"\"\n        :type jar: CookieJar\n        \"\"\"\n        # http://docs.python.org/2/library/cookielib.html#cookie-objects\n        stored_attrs = ['value', 'path', 'secure', 'expires']\n        self['cookies'] = {}\n        for cookie in jar:\n            self['cookies'][cookie.name] = dict(\n                (attname, getattr(cookie, attname))\n                for attname in stored_attrs\n            )",
        "begin_line": 132,
        "end_line": 143,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0014771048744460858,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.sessions.Session.auth#146",
        "src_path": "httpie/sessions.py",
        "class_name": "httpie.sessions.Session",
        "signature": "httpie.sessions.Session.auth(self)",
        "snippet": "    def auth(self):\n        auth = self.get('auth', None)\n        if not auth or not auth['type']:\n            return\n        auth_plugin = plugin_manager.get_auth_plugin(auth['type'])()\n        return auth_plugin.get_auth(auth['username'], auth['password'])",
        "begin_line": 146,
        "end_line": 151,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.043478260869565216,
            "pseudo_dstar_susp": 0.0035971223021582736,
            "pseudo_tarantula_susp": 0.16666666666666666,
            "pseudo_op2_susp": 0.0035971223021582736,
            "pseudo_barinel_susp": 0.16666666666666666
        }
    },
    {
        "name": "httpie.sessions.Session.auth#154",
        "src_path": "httpie/sessions.py",
        "class_name": "httpie.sessions.Session",
        "signature": "httpie.sessions.Session.auth(self, auth)",
        "snippet": "    def auth(self, auth):\n        assert set(['type', 'username', 'password']) == set(auth.keys())\n        self['auth'] = auth",
        "begin_line": 154,
        "end_line": 156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0014771048744460858,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.cli.HTTPieHelpFormatter.__init__#35",
        "src_path": "httpie/cli.py",
        "class_name": "httpie.cli.HTTPieHelpFormatter",
        "signature": "httpie.cli.HTTPieHelpFormatter.__init__(self, max_help_position=6, *args, **kwargs)",
        "snippet": "    def __init__(self, max_help_position=6, *args, **kwargs):\n        # A smaller indent for args help.\n        kwargs['max_help_position'] = max_help_position\n        super(HTTPieHelpFormatter, self).__init__(*args, **kwargs)",
        "begin_line": 35,
        "end_line": 38,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0010615711252653928,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.cli.HTTPieHelpFormatter._split_lines#40",
        "src_path": "httpie/cli.py",
        "class_name": "httpie.cli.HTTPieHelpFormatter",
        "signature": "httpie.cli.HTTPieHelpFormatter._split_lines(self, text, width)",
        "snippet": "    def _split_lines(self, text, width):\n        text = dedent(text).strip() + '\\n\\n'\n        return text.splitlines()",
        "begin_line": 40,
        "end_line": 42,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0020876826722338203,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.models.HTTPMessage.__init__#7",
        "src_path": "httpie/models.py",
        "class_name": "httpie.models.HTTPMessage",
        "signature": "httpie.models.HTTPMessage.__init__(self, orig)",
        "snippet": "    def __init__(self, orig):\n        self._orig = orig",
        "begin_line": 7,
        "end_line": 8,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0007980845969672786,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.models.HTTPMessage.content_type#34",
        "src_path": "httpie/models.py",
        "class_name": "httpie.models.HTTPMessage",
        "signature": "httpie.models.HTTPMessage.content_type(self)",
        "snippet": "    def content_type(self):\n        \"\"\"Return the message content type.\"\"\"\n        ct = self._orig.headers.get('Content-Type', '')\n        if not isinstance(ct, str):\n            ct = ct.decode('utf8')\n        return ct",
        "begin_line": 34,
        "end_line": 39,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0010330578512396695,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.models.HTTPResponse.iter_body#45",
        "src_path": "httpie/models.py",
        "class_name": "httpie.models.HTTPResponse",
        "signature": "httpie.models.HTTPResponse.iter_body(self, chunk_size=1)",
        "snippet": "    def iter_body(self, chunk_size=1):\n        return self._orig.iter_content(chunk_size=chunk_size)",
        "begin_line": 45,
        "end_line": 46,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0008818342151675485,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.models.HTTPResponse.iter_lines#48",
        "src_path": "httpie/models.py",
        "class_name": "httpie.models.HTTPResponse",
        "signature": "httpie.models.HTTPResponse.iter_lines(self, chunk_size)",
        "snippet": "    def iter_lines(self, chunk_size):\n        return ((line, b'\\n') for line in self._orig.iter_lines(chunk_size))",
        "begin_line": 48,
        "end_line": 49,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0013812154696132596,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.models.HTTPResponse.headers#53",
        "src_path": "httpie/models.py",
        "class_name": "httpie.models.HTTPResponse",
        "signature": "httpie.models.HTTPResponse.headers(self)",
        "snippet": "    def headers(self):\n        original = self._orig.raw._original_response\n\n        version = {\n            9: '0.9',\n            10: '1.0',\n            11: '1.1',\n            20: '2',\n        }[original.version]\n\n        status_line = 'HTTP/{version} {status} {reason}'.format(\n            version=version,\n            status=original.status,\n            reason=original.reason\n        )\n        headers = [status_line]\n        try:\n            # `original.msg` is a `http.client.HTTPMessage` on Python 3\n            # `_headers` is a 2-tuple\n            headers.extend(\n                '%s: %s' % header for header in original.msg._headers)\n        except AttributeError:\n            # and a `httplib.HTTPMessage` on Python 2.x\n            # `headers` is a list of `name: val<CRLF>`.\n            headers.extend(h.strip() for h in original.msg.headers)\n\n        return '\\r\\n'.join(headers)",
        "begin_line": 53,
        "end_line": 79,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0008748906386701663,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.models.HTTPResponse.encoding#82",
        "src_path": "httpie/models.py",
        "class_name": "httpie.models.HTTPResponse",
        "signature": "httpie.models.HTTPResponse.encoding(self)",
        "snippet": "    def encoding(self):\n        return self._orig.encoding or 'utf8'",
        "begin_line": 82,
        "end_line": 83,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0009041591320072332,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.models.HTTPRequest.iter_body#95",
        "src_path": "httpie/models.py",
        "class_name": "httpie.models.HTTPRequest",
        "signature": "httpie.models.HTTPRequest.iter_body(self, chunk_size)",
        "snippet": "    def iter_body(self, chunk_size):\n        yield self.body",
        "begin_line": 95,
        "end_line": 96,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0009737098344693282,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.models.HTTPRequest.iter_lines#98",
        "src_path": "httpie/models.py",
        "class_name": "httpie.models.HTTPRequest",
        "signature": "httpie.models.HTTPRequest.iter_lines(self, chunk_size)",
        "snippet": "    def iter_lines(self, chunk_size):\n        yield self.body, b''",
        "begin_line": 98,
        "end_line": 99,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0014771048744460858,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.models.HTTPRequest.headers#102",
        "src_path": "httpie/models.py",
        "class_name": "httpie.models.HTTPRequest",
        "signature": "httpie.models.HTTPRequest.headers(self)",
        "snippet": "    def headers(self):\n        url = urlsplit(self._orig.url)\n\n        request_line = '{method} {path}{query} HTTP/1.1'.format(\n            method=self._orig.method,\n            path=url.path or '/',\n            query='?' + url.query if url.query else ''\n        )\n\n        headers = dict(self._orig.headers)\n        if 'Host' not in self._orig.headers:\n            headers['Host'] = url.netloc.split('@')[-1]\n\n        headers = [\n            '%s: %s' % (\n                name,\n                value if isinstance(value, str) else value.decode('utf8')\n            )\n            for name, value in headers.items()\n        ]\n\n        headers.insert(0, request_line)\n        headers = '\\r\\n'.join(headers).strip()\n\n        if isinstance(headers, bytes):\n            # Python < 3\n            headers = headers.decode('utf8')\n        return headers",
        "begin_line": 102,
        "end_line": 129,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.000970873786407767,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.models.HTTPRequest.encoding#132",
        "src_path": "httpie/models.py",
        "class_name": "httpie.models.HTTPRequest",
        "signature": "httpie.models.HTTPRequest.encoding(self)",
        "snippet": "    def encoding(self):\n        return 'utf8'",
        "begin_line": 132,
        "end_line": 133,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0009765625,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.models.HTTPRequest.body#136",
        "src_path": "httpie/models.py",
        "class_name": "httpie.models.HTTPRequest",
        "signature": "httpie.models.HTTPRequest.body(self)",
        "snippet": "    def body(self):\n        body = self._orig.body\n        if isinstance(body, str):\n            # Happens with JSON/form request data parsed from the command line.\n            body = body.encode('utf8')\n        return body or b''",
        "begin_line": 136,
        "end_line": 141,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.001092896174863388,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.formatters.xml.XMLFormatter.format_body#42",
        "src_path": "httpie/output/formatters/xml.py",
        "class_name": "httpie.output.formatters.xml.XMLFormatter",
        "signature": "httpie.output.formatters.xml.XMLFormatter.format_body(self, body, mime)",
        "snippet": "    def format_body(self, body, mime):\n        if 'xml' in mime:\n            # FIXME: orig NS names get forgotten during the conversion, etc.\n            try:\n                root = ElementTree.fromstring(body.encode('utf8'))\n            except ElementTree.ParseError:\n                # Ignore invalid XML errors (skips attempting to pretty print)\n                pass\n            else:\n                indent(root)\n                # Use the original declaration\n                declaration = DECLARATION_RE.match(body)\n                doctype = DOCTYPE_RE.match(body)\n                body = ElementTree.tostring(root, encoding='utf-8')\\\n                                  .decode('utf8')\n                if doctype:\n                    body = '%s\\n%s' % (doctype.group(0), body)\n                if declaration:\n                    body = '%s\\n%s' % (declaration.group(0), body)\n        return body",
        "begin_line": 42,
        "end_line": 61,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0009174311926605505,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    },
    {
        "name": "httpie.output.formatters.headers.HeadersFormatter.format_headers#6",
        "src_path": "httpie/output/formatters/headers.py",
        "class_name": "httpie.output.formatters.headers.HeadersFormatter",
        "signature": "httpie.output.formatters.headers.HeadersFormatter.format_headers(self, headers)",
        "snippet": "    def format_headers(self, headers):\n        \"\"\"\n        Sorts headers by name while retaining relative\n        order of multiple headers with the same name.\n\n        \"\"\"\n        lines = headers.splitlines()\n        headers = sorted(lines[1:], key=lambda h: h.split(':')[0])\n        return '\\r\\n'.join(lines[:1] + headers)",
        "begin_line": 6,
        "end_line": 14,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001199040767386091,
            "pseudo_dstar_susp": 0.001199040767386091,
            "pseudo_tarantula_susp": 0.001199040767386091,
            "pseudo_op2_susp": 0.0008936550491510277,
            "pseudo_barinel_susp": 0.001199040767386091
        }
    }
]