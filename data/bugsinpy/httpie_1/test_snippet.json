[
    {
        "name": "tests.test_downloads.Response.__init__#18",
        "src_path": "tests/test_downloads.py",
        "class_name": "tests.test_downloads.Response",
        "signature": "tests.test_downloads.Response.__init__(self, url, headers={}, status_code=200)",
        "snippet": "    def __init__(self, url, headers={}, status_code=200):\n        self.url = url\n        self.headers = CaseInsensitiveDict(headers)\n        self.status_code = status_code",
        "begin_line": 18,
        "end_line": 21,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_downloads.TestDownloadUtils.test_Content_Range_parsing#25",
        "src_path": "tests/test_downloads.py",
        "class_name": "tests.test_downloads.TestDownloadUtils",
        "signature": "tests.test_downloads.TestDownloadUtils.test_Content_Range_parsing(self)",
        "snippet": "    def test_Content_Range_parsing(self):\n        parse = parse_content_range\n\n        assert parse('bytes 100-199/200', 100) == 200\n        assert parse('bytes 100-199/*', 100) == 200\n\n        # missing\n        pytest.raises(ContentRangeError, parse, None, 100)\n\n        # syntax error\n        pytest.raises(ContentRangeError, parse, 'beers 100-199/*', 100)\n\n        # unexpected range\n        pytest.raises(ContentRangeError, parse, 'bytes 100-199/*', 99)\n\n        # invalid instance-length\n        pytest.raises(ContentRangeError, parse, 'bytes 100-199/199', 100)\n\n        # invalid byte-range-resp-spec\n        pytest.raises(ContentRangeError, parse, 'bytes 100-99/199', 100)\n\n        # invalid byte-range-resp-spec\n        pytest.raises(ContentRangeError, parse, 'bytes 100-100/*', 100)",
        "begin_line": 25,
        "end_line": 47,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_downloads.TestDownloadUtils.test_Content_Disposition_parsing#57",
        "src_path": "tests/test_downloads.py",
        "class_name": "tests.test_downloads.TestDownloadUtils",
        "signature": "tests.test_downloads.TestDownloadUtils.test_Content_Disposition_parsing(self, header, expected_filename)",
        "snippet": "    def test_Content_Disposition_parsing(self, header, expected_filename):\n        assert filename_from_content_disposition(header) == expected_filename",
        "begin_line": 57,
        "end_line": 58,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_downloads.TestDownloadUtils.test_filename_from_url#60",
        "src_path": "tests/test_downloads.py",
        "class_name": "tests.test_downloads.TestDownloadUtils",
        "signature": "tests.test_downloads.TestDownloadUtils.test_filename_from_url(self)",
        "snippet": "    def test_filename_from_url(self):\n        assert 'foo.txt' == filename_from_url(\n            url='http://example.org/foo',\n            content_type='text/plain'\n        )\n        assert 'foo.html' == filename_from_url(\n            url='http://example.org/foo',\n            content_type='text/html; charset=utf8'\n        )\n        assert 'foo' == filename_from_url(\n            url='http://example.org/foo',\n            content_type=None\n        )\n        assert 'foo' == filename_from_url(\n            url='http://example.org/foo',\n            content_type='x-foo/bar'\n        )",
        "begin_line": 60,
        "end_line": 76,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_downloads.TestDownloadUtils.test_unique_filename#99",
        "src_path": "tests/test_downloads.py",
        "class_name": "tests.test_downloads.TestDownloadUtils",
        "signature": "tests.test_downloads.TestDownloadUtils.test_unique_filename(self, get_filename_max_length, orig_name, unique_on_attempt, expected)",
        "snippet": "    def test_unique_filename(self, get_filename_max_length,\n                             orig_name, unique_on_attempt,\n                             expected):\n\n        def attempts(unique_on_attempt=0):\n            # noinspection PyUnresolvedReferences,PyUnusedLocal\n            def exists(filename):\n                if exists.attempt == unique_on_attempt:\n                    return False\n                exists.attempt += 1\n                return True\n\n            exists.attempt = 0\n            return exists\n\n        get_filename_max_length.return_value = 10\n\n        actual = get_unique_filename(orig_name, attempts(unique_on_attempt))\n        assert expected == actual",
        "begin_line": 99,
        "end_line": 117,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_downloads.TestDownloadUtils.attempts#103",
        "src_path": "tests/test_downloads.py",
        "class_name": "tests.test_downloads.TestDownloadUtils",
        "signature": "tests.test_downloads.TestDownloadUtils.attempts(unique_on_attempt=0)",
        "snippet": "        def attempts(unique_on_attempt=0):\n            # noinspection PyUnresolvedReferences,PyUnusedLocal\n            def exists(filename):\n                if exists.attempt == unique_on_attempt:\n                    return False\n                exists.attempt += 1\n                return True\n\n            exists.attempt = 0\n            return exists",
        "begin_line": 103,
        "end_line": 112,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_downloads.TestDownloadUtils.exists#105",
        "src_path": "tests/test_downloads.py",
        "class_name": "tests.test_downloads.TestDownloadUtils",
        "signature": "tests.test_downloads.TestDownloadUtils.exists(filename)",
        "snippet": "            def exists(filename):\n                if exists.attempt == unique_on_attempt:\n                    return False\n                exists.attempt += 1\n                return True",
        "begin_line": 105,
        "end_line": 109,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_downloads.TestDownloads.test_actual_download#123",
        "src_path": "tests/test_downloads.py",
        "class_name": "tests.test_downloads.TestDownloads",
        "signature": "tests.test_downloads.TestDownloads.test_actual_download(self, httpbin_both, httpbin)",
        "snippet": "    def test_actual_download(self, httpbin_both, httpbin):\n        robots_txt = '/robots.txt'\n        body = urlopen(httpbin + robots_txt).read().decode()\n        env = TestEnvironment(stdin_isatty=True, stdout_isatty=False)\n        r = http('--download', httpbin_both.url + robots_txt, env=env)\n        assert 'Downloading' in r.stderr\n        assert '[K' in r.stderr\n        assert 'Done' in r.stderr\n        assert body == r",
        "begin_line": 123,
        "end_line": 131,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_downloads.TestDownloads.test_download_with_Content_Length#133",
        "src_path": "tests/test_downloads.py",
        "class_name": "tests.test_downloads.TestDownloads",
        "signature": "tests.test_downloads.TestDownloads.test_download_with_Content_Length(self, httpbin_both)",
        "snippet": "    def test_download_with_Content_Length(self, httpbin_both):\n        devnull = open(os.devnull, 'w')\n        downloader = Downloader(output_file=devnull, progress_file=devnull)\n        downloader.start(Response(\n            url=httpbin_both.url + '/',\n            headers={'Content-Length': 10}\n        ))\n        time.sleep(1.1)\n        downloader.chunk_downloaded(b'12345')\n        time.sleep(1.1)\n        downloader.chunk_downloaded(b'12345')\n        downloader.finish()\n        assert not downloader.interrupted",
        "begin_line": 133,
        "end_line": 145,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_downloads.TestDownloads.test_download_no_Content_Length#147",
        "src_path": "tests/test_downloads.py",
        "class_name": "tests.test_downloads.TestDownloads",
        "signature": "tests.test_downloads.TestDownloads.test_download_no_Content_Length(self, httpbin_both)",
        "snippet": "    def test_download_no_Content_Length(self, httpbin_both):\n        devnull = open(os.devnull, 'w')\n        downloader = Downloader(output_file=devnull, progress_file=devnull)\n        downloader.start(Response(url=httpbin_both.url + '/'))\n        time.sleep(1.1)\n        downloader.chunk_downloaded(b'12345')\n        downloader.finish()\n        assert not downloader.interrupted",
        "begin_line": 147,
        "end_line": 154,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_downloads.TestDownloads.test_download_interrupted#156",
        "src_path": "tests/test_downloads.py",
        "class_name": "tests.test_downloads.TestDownloads",
        "signature": "tests.test_downloads.TestDownloads.test_download_interrupted(self, httpbin_both)",
        "snippet": "    def test_download_interrupted(self, httpbin_both):\n        devnull = open(os.devnull, 'w')\n        downloader = Downloader(output_file=devnull, progress_file=devnull)\n        downloader.start(Response(\n            url=httpbin_both.url + '/',\n            headers={'Content-Length': 5}\n        ))\n        downloader.chunk_downloaded(b'1234')\n        downloader.finish()\n        assert downloader.interrupted",
        "begin_line": 156,
        "end_line": 165,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.utils.mk_config_dir#26",
        "src_path": "tests/utils.py",
        "class_name": "tests.utils",
        "signature": "tests.utils.mk_config_dir()",
        "snippet": "def mk_config_dir():\n    dirname = tempfile.mkdtemp(prefix='httpie_config_')\n    return dirname",
        "begin_line": 26,
        "end_line": 28,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.utils.add_auth#31",
        "src_path": "tests/utils.py",
        "class_name": "tests.utils",
        "signature": "tests.utils.add_auth(url, auth)",
        "snippet": "def add_auth(url, auth):\n    proto, rest = url.split('://', 1)\n    return proto + '://' + auth + '@' + rest",
        "begin_line": 31,
        "end_line": 33,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.utils.TestEnvironment.__init__#43",
        "src_path": "tests/utils.py",
        "class_name": "tests.utils.TestEnvironment",
        "signature": "tests.utils.TestEnvironment.__init__(self, **kwargs)",
        "snippet": "    def __init__(self, **kwargs):\n        if 'stdout' not in kwargs:\n            kwargs['stdout'] = tempfile.TemporaryFile(\n                mode='w+b',\n                prefix='httpie_stdout'\n            )\n        if 'stderr' not in kwargs:\n            kwargs['stderr'] = tempfile.TemporaryFile(\n                mode='w+t',\n                prefix='httpie_stderr'\n            )\n        super(TestEnvironment, self).__init__(**kwargs)\n        self._delete_config_dir = False",
        "begin_line": 43,
        "end_line": 55,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.utils.TestEnvironment.config#58",
        "src_path": "tests/utils.py",
        "class_name": "tests.utils.TestEnvironment",
        "signature": "tests.utils.TestEnvironment.config(self)",
        "snippet": "    def config(self):\n        if not self.config_dir.startswith(tempfile.gettempdir()):\n            self.config_dir = mk_config_dir()\n            self._delete_config_dir = True\n        return super(TestEnvironment, self).config",
        "begin_line": 58,
        "end_line": 62,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.utils.TestEnvironment.cleanup#64",
        "src_path": "tests/utils.py",
        "class_name": "tests.utils.TestEnvironment",
        "signature": "tests.utils.TestEnvironment.cleanup(self)",
        "snippet": "    def cleanup(self):\n        if self._delete_config_dir:\n            assert self.config_dir.startswith(tempfile.gettempdir())\n            from shutil import rmtree\n            rmtree(self.config_dir)",
        "begin_line": 64,
        "end_line": 68,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.utils.TestEnvironment.__del__#70",
        "src_path": "tests/utils.py",
        "class_name": "tests.utils.TestEnvironment",
        "signature": "tests.utils.TestEnvironment.__del__(self)",
        "snippet": "    def __del__(self):\n        try:\n            self.cleanup()\n        except Exception:\n            pass",
        "begin_line": 70,
        "end_line": 74,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.utils.StrCLIResponse.json#107",
        "src_path": "tests/utils.py",
        "class_name": "tests.utils.StrCLIResponse",
        "signature": "tests.utils.StrCLIResponse.json(self)",
        "snippet": "    def json(self):\n        \"\"\"\n        Return deserialized JSON body, if one included in the output\n        and is parseable.\n\n        \"\"\"\n        if not hasattr(self, '_json'):\n            self._json = None\n            # De-serialize JSON body if possible.\n            if COLOR in self:\n                # Colorized output cannot be parsed.\n                pass\n            elif self.strip().startswith('{'):\n                # Looks like JSON body.\n                self._json = json.loads(self)\n            elif (self.count('Content-Type:') == 1 and\n                    'application/json' in self):\n                # Looks like a whole JSON HTTP message,\n                # try to extract its body.\n                try:\n                    j = self.strip()[self.strip().rindex('\\r\\n\\r\\n'):]\n                except ValueError:\n                    pass\n                else:\n                    try:\n                        self._json = json.loads(j)\n                    except ValueError:\n                        pass\n        return self._json",
        "begin_line": 107,
        "end_line": 135,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.utils.http#142",
        "src_path": "tests/utils.py",
        "class_name": "tests.utils",
        "signature": "tests.utils.http(*args, **kwargs)",
        "snippet": "def http(*args, **kwargs):\n    # noinspection PyUnresolvedReferences\n    \"\"\"\n    Run HTTPie and capture stderr/out and exit status.\n\n    Invoke `httpie.core.main()` with `args` and `kwargs`,\n    and return a `CLIResponse` subclass instance.\n\n    The return value is either a `StrCLIResponse`, or `BytesCLIResponse`\n    if unable to decode the output.\n\n    The response has the following attributes:\n\n        `stdout` is represented by the instance itself (print r)\n        `stderr`: text written to stderr\n        `exit_status`: the exit status\n        `json`: decoded JSON (if possible) or `None`\n\n    Exceptions are propagated.\n\n    If you pass ``error_exit_ok=True``, then error exit statuses\n    won't result into an exception.\n\n    Example:\n\n    $ http --auth=user:password GET httpbin.org/basic-auth/user/password\n\n        >>> httpbin = getfixture('httpbin')\n        >>> r = http('-a', 'user:pw', httpbin.url + '/basic-auth/user/pw')\n        >>> type(r) == StrCLIResponse\n        True\n        >>> r.exit_status\n        0\n        >>> r.stderr\n        ''\n        >>> 'HTTP/1.1 200 OK' in r\n        True\n        >>> r.json == {'authenticated': True, 'user': 'user'}\n        True\n\n    \"\"\"\n    error_exit_ok = kwargs.pop('error_exit_ok', False)\n    env = kwargs.get('env')\n    if not env:\n        env = kwargs['env'] = TestEnvironment()\n\n    stdout = env.stdout\n    stderr = env.stderr\n\n    args = list(args)\n    args_with_config_defaults = args + env.config.default_options\n    add_to_args = []\n    if '--debug' not in args_with_config_defaults:\n        if '--traceback' not in args_with_config_defaults:\n            add_to_args.append('--traceback')\n        if not any('--timeout' in arg for arg in args_with_config_defaults):\n            add_to_args.append('--timeout=3')\n    args = add_to_args + args\n\n    def dump_stderr():\n        stderr.seek(0)\n        sys.stderr.write(stderr.read())\n\n    try:\n        try:\n            exit_status = main(args=args, **kwargs)\n            if '--download' in args:\n                # Let the progress reporter thread finish.\n                time.sleep(.5)\n        except SystemExit:\n            if error_exit_ok:\n                exit_status = ExitStatus.ERROR\n            else:\n                dump_stderr()\n                raise\n        except Exception:\n            stderr.seek(0)\n            sys.stderr.write(stderr.read())\n            raise\n        else:\n            if not error_exit_ok and exit_status != ExitStatus.OK:\n                dump_stderr()\n                raise ExitStatusError(\n                    'httpie.core.main() unexpectedly returned'\n                    ' a non-zero exit status: {0} ({1})'.format(\n                        exit_status,\n                        EXIT_STATUS_LABELS[exit_status]\n                    )\n                )\n\n        stdout.seek(0)\n        stderr.seek(0)\n        output = stdout.read()\n        try:\n            output = output.decode('utf8')\n        except UnicodeDecodeError:\n            # noinspection PyArgumentList\n            r = BytesCLIResponse(output)\n        else:\n            # noinspection PyArgumentList\n            r = StrCLIResponse(output)\n        r.stderr = stderr.read()\n        r.exit_status = exit_status\n\n        if r.exit_status != ExitStatus.OK:\n            sys.stderr.write(r.stderr)\n\n        return r\n\n    finally:\n        stdout.close()\n        stderr.close()\n        env.cleanup()",
        "begin_line": 142,
        "end_line": 254,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.utils.dump_stderr#201",
        "src_path": "tests/utils.py",
        "class_name": "tests.utils",
        "signature": "tests.utils.dump_stderr()",
        "snippet": "    def dump_stderr():\n        stderr.seek(0)\n        sys.stderr.write(stderr.read())",
        "begin_line": 201,
        "end_line": 203,
        "comment": "",
        "is_bug": false
    }
]