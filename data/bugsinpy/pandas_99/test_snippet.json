[
    {
        "name": "pandas.tests.indexes.conftest.indices#28",
        "src_path": "pandas/tests/indexes/conftest.py",
        "class_name": "pandas.tests.indexes.conftest",
        "signature": "pandas.tests.indexes.conftest.indices(request)",
        "snippet": "def indices(request):\n    # copy to avoid mutation, e.g. setting .name\n    return indices_dict[request.param].copy()",
        "begin_line": 28,
        "end_line": 30,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_format#40",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_format(self, cache)",
        "snippet": "    def test_to_datetime_format(self, cache):\n        values = [\"1/1/2000\", \"1/2/2000\", \"1/3/2000\"]\n\n        results1 = [Timestamp(\"20000101\"), Timestamp(\"20000201\"), Timestamp(\"20000301\")]\n        results2 = [Timestamp(\"20000101\"), Timestamp(\"20000102\"), Timestamp(\"20000103\")]\n        for vals, expecteds in [\n            (values, (Index(results1), Index(results2))),\n            (Series(values), (Series(results1), Series(results2))),\n            (values[0], (results1[0], results2[0])),\n            (values[1], (results1[1], results2[1])),\n            (values[2], (results1[2], results2[2])),\n        ]:\n\n            for i, fmt in enumerate([\"%d/%m/%Y\", \"%m/%d/%Y\"]):\n                result = to_datetime(vals, format=fmt, cache=cache)\n                expected = expecteds[i]\n\n                if isinstance(expected, Series):\n                    tm.assert_series_equal(result, Series(expected))\n                elif isinstance(expected, Timestamp):\n                    assert result == expected\n                else:\n                    tm.assert_index_equal(result, expected)",
        "begin_line": 40,
        "end_line": 62,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_format_YYYYMMDD#65",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_format_YYYYMMDD(self, cache)",
        "snippet": "    def test_to_datetime_format_YYYYMMDD(self, cache):\n        s = Series([19801222, 19801222] + [19810105] * 5)\n        expected = Series([Timestamp(x) for x in s.apply(str)])\n\n        result = to_datetime(s, format=\"%Y%m%d\", cache=cache)\n        tm.assert_series_equal(result, expected)\n\n        result = to_datetime(s.apply(str), format=\"%Y%m%d\", cache=cache)\n        tm.assert_series_equal(result, expected)\n\n        # with NaT\n        expected = Series(\n            [Timestamp(\"19801222\"), Timestamp(\"19801222\")] + [Timestamp(\"19810105\")] * 5\n        )\n        expected[2] = np.nan\n        s[2] = np.nan\n\n        result = to_datetime(s, format=\"%Y%m%d\", cache=cache)\n        tm.assert_series_equal(result, expected)\n\n        # string with NaT\n        s = s.apply(str)\n        s[2] = \"nat\"\n        result = to_datetime(s, format=\"%Y%m%d\", cache=cache)\n        tm.assert_series_equal(result, expected)\n\n        # coercion\n        # GH 7930\n        s = Series([20121231, 20141231, 99991231])\n        result = pd.to_datetime(s, format=\"%Y%m%d\", errors=\"ignore\", cache=cache)\n        expected = Series(\n            [datetime(2012, 12, 31), datetime(2014, 12, 31), datetime(9999, 12, 31)],\n            dtype=object,\n        )\n        tm.assert_series_equal(result, expected)\n\n        result = pd.to_datetime(s, format=\"%Y%m%d\", errors=\"coerce\", cache=cache)\n        expected = Series([\"20121231\", \"20141231\", \"NaT\"], dtype=\"M8[ns]\")\n        tm.assert_series_equal(result, expected)",
        "begin_line": 65,
        "end_line": 103,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_format_YYYYMMDD_with_none#120",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_format_YYYYMMDD_with_none(self, input_s)",
        "snippet": "    def test_to_datetime_format_YYYYMMDD_with_none(self, input_s):\n        # GH 30011\n        # format='%Y%m%d'\n        # with None\n        expected = Series([Timestamp(\"19801222\"), Timestamp(\"20010112\"), pd.NaT])\n        result = Series(pd.to_datetime(input_s, format=\"%Y%m%d\"))\n        tm.assert_series_equal(result, expected)",
        "begin_line": 120,
        "end_line": 126,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_format_YYYYMMDD_overflow#153",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_format_YYYYMMDD_overflow(self, input_s, expected)",
        "snippet": "    def test_to_datetime_format_YYYYMMDD_overflow(self, input_s, expected):\n        # GH 25512\n        # format='%Y%m%d', errors='coerce'\n        result = pd.to_datetime(input_s, format=\"%Y%m%d\", errors=\"coerce\")\n        tm.assert_series_equal(result, expected)",
        "begin_line": 153,
        "end_line": 157,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_format_integer#160",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_format_integer(self, cache)",
        "snippet": "    def test_to_datetime_format_integer(self, cache):\n        # GH 10178\n        s = Series([2000, 2001, 2002])\n        expected = Series([Timestamp(x) for x in s.apply(str)])\n\n        result = to_datetime(s, format=\"%Y\", cache=cache)\n        tm.assert_series_equal(result, expected)\n\n        s = Series([200001, 200105, 200206])\n        expected = Series([Timestamp(x[:4] + \"-\" + x[4:]) for x in s.apply(str)])\n\n        result = to_datetime(s, format=\"%Y%m\", cache=cache)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 160,
        "end_line": 172,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_int_to_datetime_format_YYYYMMDD_typeerror#191",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_int_to_datetime_format_YYYYMMDD_typeerror(self, int_date, expected)",
        "snippet": "    def test_int_to_datetime_format_YYYYMMDD_typeerror(self, int_date, expected):\n        # GH 26583\n        result = to_datetime(int_date, format=\"%Y%m%d\", errors=\"ignore\")\n        assert result == expected",
        "begin_line": 191,
        "end_line": 194,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_format_microsecond#197",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_format_microsecond(self, cache)",
        "snippet": "    def test_to_datetime_format_microsecond(self, cache):\n\n        # these are locale dependent\n        lang, _ = locale.getlocale()\n        month_abbr = calendar.month_abbr[4]\n        val = \"01-{}-2011 00:00:01.978\".format(month_abbr)\n\n        format = \"%d-%b-%Y %H:%M:%S.%f\"\n        result = to_datetime(val, format=format, cache=cache)\n        exp = datetime.strptime(val, format)\n        assert result == exp",
        "begin_line": 197,
        "end_line": 207,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_format_time#210",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_format_time(self, cache)",
        "snippet": "    def test_to_datetime_format_time(self, cache):\n        data = [\n            [\"01/10/2010 15:20\", \"%m/%d/%Y %H:%M\", Timestamp(\"2010-01-10 15:20\")],\n            [\"01/10/2010 05:43\", \"%m/%d/%Y %I:%M\", Timestamp(\"2010-01-10 05:43\")],\n            [\n                \"01/10/2010 13:56:01\",\n                \"%m/%d/%Y %H:%M:%S\",\n                Timestamp(\"2010-01-10 13:56:01\"),\n            ]  # ,\n            # ['01/10/2010 08:14 PM', '%m/%d/%Y %I:%M %p',\n            #  Timestamp('2010-01-10 20:14')],\n            # ['01/10/2010 07:40 AM', '%m/%d/%Y %I:%M %p',\n            #  Timestamp('2010-01-10 07:40')],\n            # ['01/10/2010 09:12:56 AM', '%m/%d/%Y %I:%M:%S %p',\n            #  Timestamp('2010-01-10 09:12:56')]\n        ]\n        for s, format, dt in data:\n            assert to_datetime(s, format=format, cache=cache) == dt",
        "begin_line": 210,
        "end_line": 227,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_with_non_exact#231",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_with_non_exact(self, cache)",
        "snippet": "    def test_to_datetime_with_non_exact(self, cache):\n        # GH 10834\n        # 8904\n        # exact kw\n        s = Series(\n            [\"19MAY11\", \"foobar19MAY11\", \"19MAY11:00:00:00\", \"19MAY11 00:00:00Z\"]\n        )\n        result = to_datetime(s, format=\"%d%b%y\", exact=False, cache=cache)\n        expected = to_datetime(\n            s.str.extract(r\"(\\d+\\w+\\d+)\", expand=False), format=\"%d%b%y\", cache=cache\n        )\n        tm.assert_series_equal(result, expected)",
        "begin_line": 231,
        "end_line": 242,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_parse_nanoseconds_with_formula#245",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_parse_nanoseconds_with_formula(self, cache)",
        "snippet": "    def test_parse_nanoseconds_with_formula(self, cache):\n\n        # GH8989\n        # truncating the nanoseconds when a format was provided\n        for v in [\n            \"2012-01-01 09:00:00.000000001\",\n            \"2012-01-01 09:00:00.000001\",\n            \"2012-01-01 09:00:00.001\",\n            \"2012-01-01 09:00:00.001000\",\n            \"2012-01-01 09:00:00.001000000\",\n        ]:\n            expected = pd.to_datetime(v, cache=cache)\n            result = pd.to_datetime(v, format=\"%Y-%m-%d %H:%M:%S.%f\", cache=cache)\n            assert result == expected",
        "begin_line": 245,
        "end_line": 258,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_format_weeks#261",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_format_weeks(self, cache)",
        "snippet": "    def test_to_datetime_format_weeks(self, cache):\n        data = [\n            [\"2009324\", \"%Y%W%w\", Timestamp(\"2009-08-13\")],\n            [\"2013020\", \"%Y%U%w\", Timestamp(\"2013-01-13\")],\n        ]\n        for s, format, dt in data:\n            assert to_datetime(s, format=format, cache=cache) == dt",
        "begin_line": 261,
        "end_line": 267,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_parse_tzname_or_tzoffset#320",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_parse_tzname_or_tzoffset(self, fmt, dates, expected_dates)",
        "snippet": "    def test_to_datetime_parse_tzname_or_tzoffset(self, fmt, dates, expected_dates):\n        # GH 13486\n        result = pd.to_datetime(dates, format=fmt)\n        expected = pd.Index(expected_dates)\n        tm.assert_equal(result, expected)\n\n        with pytest.raises(ValueError):\n            pd.to_datetime(dates, format=fmt, utc=True)",
        "begin_line": 320,
        "end_line": 327,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_parse_timezone_malformed#332",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_parse_timezone_malformed(self, offset)",
        "snippet": "    def test_to_datetime_parse_timezone_malformed(self, offset):\n        fmt = \"%Y-%m-%d %H:%M:%S %z\"\n        date = \"2010-01-01 12:00:00 \" + offset\n        with pytest.raises(ValueError):\n            pd.to_datetime([date], format=fmt)",
        "begin_line": 332,
        "end_line": 336,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_parse_timezone_keeps_name#338",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestTimeConversionFormats.test_to_datetime_parse_timezone_keeps_name(self)",
        "snippet": "    def test_to_datetime_parse_timezone_keeps_name(self):\n        # GH 21697\n        fmt = \"%Y-%m-%d %H:%M:%S %z\"\n        arg = pd.Index([\"2010-01-01 12:00:00 Z\"], name=\"foo\")\n        result = pd.to_datetime(arg, format=fmt)\n        expected = pd.DatetimeIndex([\"2010-01-01 12:00:00\"], tz=\"UTC\", name=\"foo\")\n        tm.assert_index_equal(result, expected)",
        "begin_line": 338,
        "end_line": 344,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_iso_week_year_format#356",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_iso_week_year_format(self, s, _format, dt)",
        "snippet": "    def test_to_datetime_iso_week_year_format(self, s, _format, dt):\n        # See GH#16607\n        assert to_datetime(s, format=_format) == dt",
        "begin_line": 356,
        "end_line": 358,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_error_iso_week_year#443",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_error_iso_week_year(self, msg, s, _format)",
        "snippet": "    def test_error_iso_week_year(self, msg, s, _format):\n        # See GH#16607\n        # This test checks for errors thrown when giving the wrong format\n        # However, as discussed on PR#25541, overriding the locale\n        # causes a different error to be thrown due to the format being\n        # locale specific, but the test data is in english.\n        # Therefore, the tests only run when locale is not overwritten,\n        # as a sort of solution to this problem.\n        if locale.getlocale() != (\"zh_CN\", \"UTF-8\") and locale.getlocale() != (\n            \"it_IT\",\n            \"UTF-8\",\n        ):\n            with pytest.raises(ValueError, match=msg):\n                to_datetime(s, format=_format)",
        "begin_line": 443,
        "end_line": 456,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_dtarr#459",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_dtarr(self, tz)",
        "snippet": "    def test_to_datetime_dtarr(self, tz):\n        # DatetimeArray\n        dti = date_range(\"1965-04-03\", periods=19, freq=\"2W\", tz=tz)\n        arr = DatetimeArray(dti)\n\n        result = to_datetime(arr)\n        assert result is arr\n\n        result = to_datetime(arr)\n        assert result is arr",
        "begin_line": 459,
        "end_line": 468,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_pydatetime#470",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_pydatetime(self)",
        "snippet": "    def test_to_datetime_pydatetime(self):\n        actual = pd.to_datetime(datetime(2008, 1, 15))\n        assert actual == datetime(2008, 1, 15)",
        "begin_line": 470,
        "end_line": 472,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_YYYYMMDD#474",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_YYYYMMDD(self)",
        "snippet": "    def test_to_datetime_YYYYMMDD(self):\n        actual = pd.to_datetime(\"20080115\")\n        assert actual == datetime(2008, 1, 15)",
        "begin_line": 474,
        "end_line": 476,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_unparseable_ignore#478",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_unparseable_ignore(self)",
        "snippet": "    def test_to_datetime_unparseable_ignore(self):\n        # unparseable\n        s = \"Month 1, 1999\"\n        assert pd.to_datetime(s, errors=\"ignore\") == s",
        "begin_line": 478,
        "end_line": 481,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_now#484",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_now(self)",
        "snippet": "    def test_to_datetime_now(self):\n        # See GH#18666\n        with tm.set_timezone(\"US/Eastern\"):\n            npnow = np.datetime64(\"now\").astype(\"datetime64[ns]\")\n            pdnow = pd.to_datetime(\"now\")\n            pdnow2 = pd.to_datetime([\"now\"])[0]\n\n            # These should all be equal with infinite perf; this gives\n            # a generous margin of 10 seconds\n            assert abs(pdnow.value - npnow.astype(np.int64)) < 1e10\n            assert abs(pdnow2.value - npnow.astype(np.int64)) < 1e10\n\n            assert pdnow.tzinfo is None\n            assert pdnow2.tzinfo is None",
        "begin_line": 484,
        "end_line": 497,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_today#500",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_today(self)",
        "snippet": "    def test_to_datetime_today(self):\n        # See GH#18666\n        # Test with one timezone far ahead of UTC and another far behind, so\n        # one of these will _almost_ always be in a different day from UTC.\n        # Unfortunately this test between 12 and 1 AM Samoa time\n        # this both of these timezones _and_ UTC will all be in the same day,\n        # so this test will not detect the regression introduced in #18666.\n        with tm.set_timezone(\"Pacific/Auckland\"):  # 12-13 hours ahead of UTC\n            nptoday = np.datetime64(\"today\").astype(\"datetime64[ns]\").astype(np.int64)\n            pdtoday = pd.to_datetime(\"today\")\n            pdtoday2 = pd.to_datetime([\"today\"])[0]\n\n            tstoday = pd.Timestamp(\"today\")\n            tstoday2 = pd.Timestamp.today()\n\n            # These should all be equal with infinite perf; this gives\n            # a generous margin of 10 seconds\n            assert abs(pdtoday.normalize().value - nptoday) < 1e10\n            assert abs(pdtoday2.normalize().value - nptoday) < 1e10\n            assert abs(pdtoday.value - tstoday.value) < 1e10\n            assert abs(pdtoday.value - tstoday2.value) < 1e10\n\n            assert pdtoday.tzinfo is None\n            assert pdtoday2.tzinfo is None\n\n        with tm.set_timezone(\"US/Samoa\"):  # 11 hours behind UTC\n            nptoday = np.datetime64(\"today\").astype(\"datetime64[ns]\").astype(np.int64)\n            pdtoday = pd.to_datetime(\"today\")\n            pdtoday2 = pd.to_datetime([\"today\"])[0]\n\n            # These should all be equal with infinite perf; this gives\n            # a generous margin of 10 seconds\n            assert abs(pdtoday.normalize().value - nptoday) < 1e10\n            assert abs(pdtoday2.normalize().value - nptoday) < 1e10\n\n            assert pdtoday.tzinfo is None\n            assert pdtoday2.tzinfo is None",
        "begin_line": 500,
        "end_line": 536,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_today_now_unicode_bytes#538",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_today_now_unicode_bytes(self)",
        "snippet": "    def test_to_datetime_today_now_unicode_bytes(self):\n        to_datetime([\"now\"])\n        to_datetime([\"today\"])",
        "begin_line": 538,
        "end_line": 540,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_dt64s#543",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_dt64s(self, cache)",
        "snippet": "    def test_to_datetime_dt64s(self, cache):\n        in_bound_dts = [np.datetime64(\"2000-01-01\"), np.datetime64(\"2000-01-02\")]\n\n        for dt in in_bound_dts:\n            assert pd.to_datetime(dt, cache=cache) == Timestamp(dt)",
        "begin_line": 543,
        "end_line": 547,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_dt64s_out_of_bounds#553",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_dt64s_out_of_bounds(self, cache, dt)",
        "snippet": "    def test_to_datetime_dt64s_out_of_bounds(self, cache, dt):\n        msg = \"Out of bounds nanosecond timestamp: {}\".format(dt)\n        with pytest.raises(OutOfBoundsDatetime, match=msg):\n            pd.to_datetime(dt, errors=\"raise\")\n        with pytest.raises(OutOfBoundsDatetime, match=msg):\n            Timestamp(dt)\n        assert pd.to_datetime(dt, errors=\"coerce\", cache=cache) is NaT",
        "begin_line": 553,
        "end_line": 559,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_array_of_dt64s#562",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_array_of_dt64s(self, cache)",
        "snippet": "    def test_to_datetime_array_of_dt64s(self, cache):\n        dts = [np.datetime64(\"2000-01-01\"), np.datetime64(\"2000-01-02\")]\n\n        # Assuming all datetimes are in bounds, to_datetime() returns\n        # an array that is equal to Timestamp() parsing\n        tm.assert_index_equal(\n            pd.to_datetime(dts, cache=cache),\n            pd.DatetimeIndex([Timestamp(x).asm8 for x in dts]),\n        )\n\n        # A list of datetimes where the last one is out of bounds\n        dts_with_oob = dts + [np.datetime64(\"9999-01-01\")]\n\n        msg = \"Out of bounds nanosecond timestamp: 9999-01-01 00:00:00\"\n        with pytest.raises(OutOfBoundsDatetime, match=msg):\n            pd.to_datetime(dts_with_oob, errors=\"raise\")\n\n        tm.assert_index_equal(\n            pd.to_datetime(dts_with_oob, errors=\"coerce\", cache=cache),\n            pd.DatetimeIndex(\n                [\n                    Timestamp(dts_with_oob[0]).asm8,\n                    Timestamp(dts_with_oob[1]).asm8,\n                    pd.NaT,\n                ]\n            ),\n        )\n\n        # With errors='ignore', out of bounds datetime64s\n        # are converted to their .item(), which depending on the version of\n        # numpy is either a python datetime.datetime or datetime.date\n        tm.assert_index_equal(\n            pd.to_datetime(dts_with_oob, errors=\"ignore\", cache=cache),\n            pd.Index([dt.item() for dt in dts_with_oob]),\n        )",
        "begin_line": 562,
        "end_line": 596,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_tz#599",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_tz(self, cache)",
        "snippet": "    def test_to_datetime_tz(self, cache):\n\n        # xref 8260\n        # uniform returns a DatetimeIndex\n        arr = [\n            pd.Timestamp(\"2013-01-01 13:00:00-0800\", tz=\"US/Pacific\"),\n            pd.Timestamp(\"2013-01-02 14:00:00-0800\", tz=\"US/Pacific\"),\n        ]\n        result = pd.to_datetime(arr, cache=cache)\n        expected = DatetimeIndex(\n            [\"2013-01-01 13:00:00\", \"2013-01-02 14:00:00\"], tz=\"US/Pacific\"\n        )\n        tm.assert_index_equal(result, expected)\n\n        # mixed tzs will raise\n        arr = [\n            pd.Timestamp(\"2013-01-01 13:00:00\", tz=\"US/Pacific\"),\n            pd.Timestamp(\"2013-01-02 14:00:00\", tz=\"US/Eastern\"),\n        ]\n        msg = (\n            \"Tz-aware datetime.datetime cannot be converted to datetime64\"\n            \" unless utc=True\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            pd.to_datetime(arr, cache=cache)",
        "begin_line": 599,
        "end_line": 623,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_different_offsets#626",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_different_offsets(self, cache)",
        "snippet": "    def test_to_datetime_different_offsets(self, cache):\n        # inspired by asv timeseries.ToDatetimeNONISO8601 benchmark\n        # see GH-26097 for more\n        ts_string_1 = \"March 1, 2018 12:00:00+0400\"\n        ts_string_2 = \"March 1, 2018 12:00:00+0500\"\n        arr = [ts_string_1] * 5 + [ts_string_2] * 5\n        expected = pd.Index([parse(x) for x in arr])\n        result = pd.to_datetime(arr, cache=cache)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 626,
        "end_line": 634,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_tz_pytz#637",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_tz_pytz(self, cache)",
        "snippet": "    def test_to_datetime_tz_pytz(self, cache):\n        # see gh-8260\n        us_eastern = pytz.timezone(\"US/Eastern\")\n        arr = np.array(\n            [\n                us_eastern.localize(\n                    datetime(year=2000, month=1, day=1, hour=3, minute=0)\n                ),\n                us_eastern.localize(\n                    datetime(year=2000, month=6, day=1, hour=3, minute=0)\n                ),\n            ],\n            dtype=object,\n        )\n        result = pd.to_datetime(arr, utc=True, cache=cache)\n        expected = DatetimeIndex(\n            [\"2000-01-01 08:00:00+00:00\", \"2000-06-01 07:00:00+00:00\"],\n            dtype=\"datetime64[ns, UTC]\",\n            freq=None,\n        )\n        tm.assert_index_equal(result, expected)",
        "begin_line": 637,
        "end_line": 657,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_utc_true#669",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_utc_true(self, cache, init_constructor, end_constructor, test_method)",
        "snippet": "    def test_to_datetime_utc_true(\n        self, cache, init_constructor, end_constructor, test_method\n    ):\n        # See gh-11934 & gh-6415\n        data = [\"20100102 121314\", \"20100102 121315\"]\n        expected_data = [\n            pd.Timestamp(\"2010-01-02 12:13:14\", tz=\"utc\"),\n            pd.Timestamp(\"2010-01-02 12:13:15\", tz=\"utc\"),\n        ]\n\n        result = pd.to_datetime(\n            init_constructor(data), format=\"%Y%m%d %H%M%S\", utc=True, cache=cache\n        )\n        expected = end_constructor(expected_data)\n        test_method(result, expected)\n\n        # Test scalar case as well\n        for scalar, expected in zip(data, expected_data):\n            result = pd.to_datetime(\n                scalar, format=\"%Y%m%d %H%M%S\", utc=True, cache=cache\n            )\n            assert result == expected",
        "begin_line": 669,
        "end_line": 690,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_utc_true_with_series_single_value#693",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_utc_true_with_series_single_value(self, cache)",
        "snippet": "    def test_to_datetime_utc_true_with_series_single_value(self, cache):\n        # GH 15760 UTC=True with Series\n        ts = 1.5e18\n        result = pd.to_datetime(pd.Series([ts]), utc=True, cache=cache)\n        expected = pd.Series([pd.Timestamp(ts, tz=\"utc\")])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 693,
        "end_line": 698,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_utc_true_with_series_tzaware_string#701",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_utc_true_with_series_tzaware_string(self, cache)",
        "snippet": "    def test_to_datetime_utc_true_with_series_tzaware_string(self, cache):\n        ts = \"2013-01-01 00:00:00-01:00\"\n        expected_ts = \"2013-01-01 01:00:00\"\n        data = pd.Series([ts] * 3)\n        result = pd.to_datetime(data, utc=True, cache=cache)\n        expected = pd.Series([pd.Timestamp(expected_ts, tz=\"utc\")] * 3)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 701,
        "end_line": 707,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_utc_true_with_series_datetime_ns#717",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_utc_true_with_series_datetime_ns(self, cache, date, dtype)",
        "snippet": "    def test_to_datetime_utc_true_with_series_datetime_ns(self, cache, date, dtype):\n        expected = pd.Series([pd.Timestamp(\"2013-01-01 01:00:00\", tz=\"UTC\")])\n        result = pd.to_datetime(pd.Series([date], dtype=dtype), utc=True, cache=cache)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 717,
        "end_line": 720,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_tz_psycopg2#724",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_tz_psycopg2(self, cache)",
        "snippet": "    def test_to_datetime_tz_psycopg2(self, cache):\n\n        # xref 8260\n        import psycopg2\n\n        # misc cases\n        tz1 = psycopg2.tz.FixedOffsetTimezone(offset=-300, name=None)\n        tz2 = psycopg2.tz.FixedOffsetTimezone(offset=-240, name=None)\n        arr = np.array(\n            [\n                datetime(2000, 1, 1, 3, 0, tzinfo=tz1),\n                datetime(2000, 6, 1, 3, 0, tzinfo=tz2),\n            ],\n            dtype=object,\n        )\n\n        result = pd.to_datetime(arr, errors=\"coerce\", utc=True, cache=cache)\n        expected = DatetimeIndex(\n            [\"2000-01-01 08:00:00+00:00\", \"2000-06-01 07:00:00+00:00\"],\n            dtype=\"datetime64[ns, UTC]\",\n            freq=None,\n        )\n        tm.assert_index_equal(result, expected)\n\n        # dtype coercion\n        i = pd.DatetimeIndex(\n            [\"2000-01-01 08:00:00\"],\n            tz=psycopg2.tz.FixedOffsetTimezone(offset=-300, name=None),\n        )\n        assert is_datetime64_ns_dtype(i)\n\n        # tz coercion\n        result = pd.to_datetime(i, errors=\"coerce\", cache=cache)\n        tm.assert_index_equal(result, i)\n\n        result = pd.to_datetime(i, errors=\"coerce\", utc=True, cache=cache)\n        expected = pd.DatetimeIndex(\n            [\"2000-01-01 13:00:00\"], dtype=\"datetime64[ns, UTC]\"\n        )\n        tm.assert_index_equal(result, expected)",
        "begin_line": 724,
        "end_line": 763,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_datetime_bool#766",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_datetime_bool(self, cache)",
        "snippet": "    def test_datetime_bool(self, cache):\n        # GH13176\n        with pytest.raises(TypeError):\n            to_datetime(False)\n        assert to_datetime(False, errors=\"coerce\", cache=cache) is NaT\n        assert to_datetime(False, errors=\"ignore\", cache=cache) is False\n        with pytest.raises(TypeError):\n            to_datetime(True)\n        assert to_datetime(True, errors=\"coerce\", cache=cache) is NaT\n        assert to_datetime(True, errors=\"ignore\", cache=cache) is True\n        with pytest.raises(TypeError):\n            to_datetime([False, datetime.today()], cache=cache)\n        with pytest.raises(TypeError):\n            to_datetime([\"20130101\", True], cache=cache)\n        tm.assert_index_equal(\n            to_datetime([0, False, NaT, 0.0], errors=\"coerce\", cache=cache),\n            DatetimeIndex(\n                [to_datetime(0, cache=cache), NaT, NaT, to_datetime(0, cache=cache)]\n            ),\n        )",
        "begin_line": 766,
        "end_line": 785,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_datetime_invalid_datatype#787",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_datetime_invalid_datatype(self)",
        "snippet": "    def test_datetime_invalid_datatype(self):\n        # GH13176\n\n        with pytest.raises(TypeError):\n            pd.to_datetime(bool)\n        with pytest.raises(TypeError):\n            pd.to_datetime(pd.to_datetime)",
        "begin_line": 787,
        "end_line": 793,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_datetime_invalid_scalar#798",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_datetime_invalid_scalar(self, value, format, infer)",
        "snippet": "    def test_datetime_invalid_scalar(self, value, format, infer):\n        # GH24763\n        res = pd.to_datetime(\n            value, errors=\"ignore\", format=format, infer_datetime_format=infer\n        )\n        assert res == value\n\n        res = pd.to_datetime(\n            value, errors=\"coerce\", format=format, infer_datetime_format=infer\n        )\n        assert res is pd.NaT\n\n        with pytest.raises(ValueError):\n            pd.to_datetime(\n                value, errors=\"raise\", format=format, infer_datetime_format=infer\n            )",
        "begin_line": 798,
        "end_line": 813,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_datetime_outofbounds_scalar#818",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_datetime_outofbounds_scalar(self, value, format, infer)",
        "snippet": "    def test_datetime_outofbounds_scalar(self, value, format, infer):\n        # GH24763\n        res = pd.to_datetime(\n            value, errors=\"ignore\", format=format, infer_datetime_format=infer\n        )\n        assert res == value\n\n        res = pd.to_datetime(\n            value, errors=\"coerce\", format=format, infer_datetime_format=infer\n        )\n        assert res is pd.NaT\n\n        if format is not None:\n            with pytest.raises(ValueError):\n                pd.to_datetime(\n                    value, errors=\"raise\", format=format, infer_datetime_format=infer\n                )\n        else:\n            with pytest.raises(OutOfBoundsDatetime):\n                pd.to_datetime(\n                    value, errors=\"raise\", format=format, infer_datetime_format=infer\n                )",
        "begin_line": 818,
        "end_line": 839,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_datetime_invalid_index#844",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_datetime_invalid_index(self, values, format, infer)",
        "snippet": "    def test_datetime_invalid_index(self, values, format, infer):\n        # GH24763\n        res = pd.to_datetime(\n            values, errors=\"ignore\", format=format, infer_datetime_format=infer\n        )\n        tm.assert_index_equal(res, pd.Index(values))\n\n        res = pd.to_datetime(\n            values, errors=\"coerce\", format=format, infer_datetime_format=infer\n        )\n        tm.assert_index_equal(res, pd.DatetimeIndex([pd.NaT] * len(values)))\n\n        with pytest.raises(ValueError):\n            pd.to_datetime(\n                values, errors=\"raise\", format=format, infer_datetime_format=infer\n            )",
        "begin_line": 844,
        "end_line": 859,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_cache#864",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_cache(self, utc, format, constructor)",
        "snippet": "    def test_to_datetime_cache(self, utc, format, constructor):\n        date = \"20130101 00:00:00\"\n        test_dates = [date] * 10 ** 5\n        data = constructor(test_dates)\n\n        result = pd.to_datetime(data, utc=utc, format=format, cache=True)\n        expected = pd.to_datetime(data, utc=utc, format=format, cache=False)\n\n        tm.assert_index_equal(result, expected)",
        "begin_line": 864,
        "end_line": 872,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_no_slicing_errors_in_should_cache#882",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_no_slicing_errors_in_should_cache(self, listlike)",
        "snippet": "    def test_no_slicing_errors_in_should_cache(self, listlike):\n        # GH 29403\n        assert tools.should_cache(listlike) is True",
        "begin_line": 882,
        "end_line": 884,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_from_deque#886",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_from_deque(self)",
        "snippet": "    def test_to_datetime_from_deque(self):\n        # GH 29403\n        result = pd.to_datetime(deque([pd.Timestamp(\"2010-06-02 09:30:00\")] * 51))\n        expected = pd.to_datetime([pd.Timestamp(\"2010-06-02 09:30:00\")] * 51)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 886,
        "end_line": 890,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_cache_series#894",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_cache_series(self, utc, format)",
        "snippet": "    def test_to_datetime_cache_series(self, utc, format):\n        date = \"20130101 00:00:00\"\n        test_dates = [date] * 10 ** 5\n        data = pd.Series(test_dates)\n        result = pd.to_datetime(data, utc=utc, format=format, cache=True)\n        expected = pd.to_datetime(data, utc=utc, format=format, cache=False)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 894,
        "end_line": 900,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_cache_scalar#902",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_cache_scalar(self)",
        "snippet": "    def test_to_datetime_cache_scalar(self):\n        date = \"20130101 00:00:00\"\n        result = pd.to_datetime(date, cache=True)\n        expected = pd.Timestamp(\"20130101 00:00:00\")\n        assert result == expected",
        "begin_line": 902,
        "end_line": 906,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_week_without_day_and_calendar_year#919",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_week_without_day_and_calendar_year(self, date, format)",
        "snippet": "    def test_week_without_day_and_calendar_year(self, date, format):\n        # GH16774\n\n        msg = \"Cannot use '%W' or '%U' without day and year\"\n        with pytest.raises(ValueError, match=msg):\n            pd.to_datetime(date, format=format)",
        "begin_line": 919,
        "end_line": 924,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_coerce#926",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_coerce(self)",
        "snippet": "    def test_to_datetime_coerce(self):\n        # GH 26122\n        ts_strings = [\n            \"March 1, 2018 12:00:00+0400\",\n            \"March 1, 2018 12:00:00+0500\",\n            \"20100240\",\n        ]\n        result = to_datetime(ts_strings, errors=\"coerce\")\n        expected = Index(\n            [\n                datetime(2018, 3, 1, 12, 0, tzinfo=tzoffset(None, 14400)),\n                datetime(2018, 3, 1, 12, 0, tzinfo=tzoffset(None, 18000)),\n                NaT,\n            ]\n        )\n        tm.assert_index_equal(result, expected)",
        "begin_line": 926,
        "end_line": 941,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_coerce_malformed#943",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_coerce_malformed(self)",
        "snippet": "    def test_to_datetime_coerce_malformed(self):\n        # GH 28299\n        ts_strings = [\"200622-12-31\", \"111111-24-11\"]\n        result = to_datetime(ts_strings, errors=\"coerce\")\n        expected = Index([NaT, NaT])\n        tm.assert_index_equal(result, expected)",
        "begin_line": 943,
        "end_line": 948,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_iso_8601_strings_with_same_offset#950",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_iso_8601_strings_with_same_offset(self)",
        "snippet": "    def test_iso_8601_strings_with_same_offset(self):\n        # GH 17697, 11736\n        ts_str = \"2015-11-18 15:30:00+05:30\"\n        result = to_datetime(ts_str)\n        expected = Timestamp(ts_str)\n        assert result == expected\n\n        expected = DatetimeIndex([Timestamp(ts_str)] * 2)\n        result = to_datetime([ts_str] * 2)\n        tm.assert_index_equal(result, expected)\n\n        result = DatetimeIndex([ts_str] * 2)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 950,
        "end_line": 962,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_iso_8601_strings_with_different_offsets#964",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_iso_8601_strings_with_different_offsets(self)",
        "snippet": "    def test_iso_8601_strings_with_different_offsets(self):\n        # GH 17697, 11736\n        ts_strings = [\"2015-11-18 15:30:00+05:30\", \"2015-11-18 16:30:00+06:30\", NaT]\n        result = to_datetime(ts_strings)\n        expected = np.array(\n            [\n                datetime(2015, 11, 18, 15, 30, tzinfo=tzoffset(None, 19800)),\n                datetime(2015, 11, 18, 16, 30, tzinfo=tzoffset(None, 23400)),\n                NaT,\n            ],\n            dtype=object,\n        )\n        # GH 21864\n        expected = Index(expected)\n        tm.assert_index_equal(result, expected)\n\n        result = to_datetime(ts_strings, utc=True)\n        expected = DatetimeIndex(\n            [Timestamp(2015, 11, 18, 10), Timestamp(2015, 11, 18, 10), NaT], tz=\"UTC\"\n        )\n        tm.assert_index_equal(result, expected)",
        "begin_line": 964,
        "end_line": 984,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_iso8601_strings_mixed_offsets_with_naive#986",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_iso8601_strings_mixed_offsets_with_naive(self)",
        "snippet": "    def test_iso8601_strings_mixed_offsets_with_naive(self):\n        # GH 24992\n        result = pd.to_datetime(\n            [\n                \"2018-11-28T00:00:00\",\n                \"2018-11-28T00:00:00+12:00\",\n                \"2018-11-28T00:00:00\",\n                \"2018-11-28T00:00:00+06:00\",\n                \"2018-11-28T00:00:00\",\n            ],\n            utc=True,\n        )\n        expected = pd.to_datetime(\n            [\n                \"2018-11-28T00:00:00\",\n                \"2018-11-27T12:00:00\",\n                \"2018-11-28T00:00:00\",\n                \"2018-11-27T18:00:00\",\n                \"2018-11-28T00:00:00\",\n            ],\n            utc=True,\n        )\n        tm.assert_index_equal(result, expected)\n\n        items = [\"2018-11-28T00:00:00+12:00\", \"2018-11-28T00:00:00\"]\n        result = pd.to_datetime(items, utc=True)\n        expected = pd.to_datetime(list(reversed(items)), utc=True)[::-1]\n        tm.assert_index_equal(result, expected)",
        "begin_line": 986,
        "end_line": 1013,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_mixed_offsets_with_native_datetime_raises#1015",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_mixed_offsets_with_native_datetime_raises(self)",
        "snippet": "    def test_mixed_offsets_with_native_datetime_raises(self):\n        # GH 25978\n        s = pd.Series(\n            [\n                \"nan\",\n                pd.Timestamp(\"1990-01-01\"),\n                \"2015-03-14T16:15:14.123-08:00\",\n                \"2019-03-04T21:56:32.620-07:00\",\n                None,\n            ]\n        )\n        with pytest.raises(ValueError, match=\"Tz-aware datetime.datetime\"):\n            pd.to_datetime(s)",
        "begin_line": 1015,
        "end_line": 1027,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_non_iso_strings_with_tz_offset#1029",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_non_iso_strings_with_tz_offset(self)",
        "snippet": "    def test_non_iso_strings_with_tz_offset(self):\n        result = to_datetime([\"March 1, 2018 12:00:00+0400\"] * 2)\n        expected = DatetimeIndex(\n            [datetime(2018, 3, 1, 12, tzinfo=pytz.FixedOffset(240))] * 2\n        )\n        tm.assert_index_equal(result, expected)",
        "begin_line": 1029,
        "end_line": 1034,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_timestamp_utc_true#1046",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_timestamp_utc_true(self, ts, expected)",
        "snippet": "    def test_timestamp_utc_true(self, ts, expected):\n        # GH 24415\n        result = to_datetime(ts, utc=True)\n        assert result == expected",
        "begin_line": 1046,
        "end_line": 1049,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_with_format_out_of_bounds#1052",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetime.test_to_datetime_with_format_out_of_bounds(self, dt_str)",
        "snippet": "    def test_to_datetime_with_format_out_of_bounds(self, dt_str):\n        # GH 9107\n        with pytest.raises(OutOfBoundsDatetime):\n            pd.to_datetime(dt_str, format=\"%Y%m%d\")",
        "begin_line": 1052,
        "end_line": 1055,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit.test_unit#1060",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit.test_unit(self, cache)",
        "snippet": "    def test_unit(self, cache):\n        # GH 11758\n        # test proper behavior with errors\n\n        with pytest.raises(ValueError):\n            to_datetime([1], unit=\"D\", format=\"%Y%m%d\", cache=cache)\n\n        values = [11111111, 1, 1.0, iNaT, NaT, np.nan, \"NaT\", \"\"]\n        result = to_datetime(values, unit=\"D\", errors=\"ignore\", cache=cache)\n        expected = Index(\n            [\n                11111111,\n                Timestamp(\"1970-01-02\"),\n                Timestamp(\"1970-01-02\"),\n                NaT,\n                NaT,\n                NaT,\n                NaT,\n                NaT,\n            ],\n            dtype=object,\n        )\n        tm.assert_index_equal(result, expected)\n\n        result = to_datetime(values, unit=\"D\", errors=\"coerce\", cache=cache)\n        expected = DatetimeIndex(\n            [\"NaT\", \"1970-01-02\", \"1970-01-02\", \"NaT\", \"NaT\", \"NaT\", \"NaT\", \"NaT\"]\n        )\n        tm.assert_index_equal(result, expected)\n\n        with pytest.raises(tslib.OutOfBoundsDatetime):\n            to_datetime(values, unit=\"D\", errors=\"raise\", cache=cache)\n\n        values = [1420043460000, iNaT, NaT, np.nan, \"NaT\"]\n\n        result = to_datetime(values, errors=\"ignore\", unit=\"s\", cache=cache)\n        expected = Index([1420043460000, NaT, NaT, NaT, NaT], dtype=object)\n        tm.assert_index_equal(result, expected)\n\n        result = to_datetime(values, errors=\"coerce\", unit=\"s\", cache=cache)\n        expected = DatetimeIndex([\"NaT\", \"NaT\", \"NaT\", \"NaT\", \"NaT\"])\n        tm.assert_index_equal(result, expected)\n\n        with pytest.raises(tslib.OutOfBoundsDatetime):\n            to_datetime(values, errors=\"raise\", unit=\"s\", cache=cache)\n\n        # if we have a string, then we raise a ValueError\n        # and NOT an OutOfBoundsDatetime\n        for val in [\"foo\", Timestamp(\"20130101\")]:\n            try:\n                to_datetime(val, errors=\"raise\", unit=\"s\", cache=cache)\n            except tslib.OutOfBoundsDatetime:\n                raise AssertionError(\"incorrect exception raised\")\n            except ValueError:\n                pass",
        "begin_line": 1060,
        "end_line": 1114,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit.test_unit_consistency#1117",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit.test_unit_consistency(self, cache)",
        "snippet": "    def test_unit_consistency(self, cache):\n\n        # consistency of conversions\n        expected = Timestamp(\"1970-05-09 14:25:11\")\n        result = pd.to_datetime(11111111, unit=\"s\", errors=\"raise\", cache=cache)\n        assert result == expected\n        assert isinstance(result, Timestamp)\n\n        result = pd.to_datetime(11111111, unit=\"s\", errors=\"coerce\", cache=cache)\n        assert result == expected\n        assert isinstance(result, Timestamp)\n\n        result = pd.to_datetime(11111111, unit=\"s\", errors=\"ignore\", cache=cache)\n        assert result == expected\n        assert isinstance(result, Timestamp)",
        "begin_line": 1117,
        "end_line": 1131,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit.test_unit_with_numeric#1134",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit.test_unit_with_numeric(self, cache)",
        "snippet": "    def test_unit_with_numeric(self, cache):\n\n        # GH 13180\n        # coercions from floats/ints are ok\n        expected = DatetimeIndex([\"2015-06-19 05:33:20\", \"2015-05-27 22:33:20\"])\n        arr1 = [1.434692e18, 1.432766e18]\n        arr2 = np.array(arr1).astype(\"int64\")\n        for errors in [\"ignore\", \"raise\", \"coerce\"]:\n            result = pd.to_datetime(arr1, errors=errors, cache=cache)\n            tm.assert_index_equal(result, expected)\n\n            result = pd.to_datetime(arr2, errors=errors, cache=cache)\n            tm.assert_index_equal(result, expected)\n\n        # but we want to make sure that we are coercing\n        # if we have ints/strings\n        expected = DatetimeIndex([\"NaT\", \"2015-06-19 05:33:20\", \"2015-05-27 22:33:20\"])\n        arr = [\"foo\", 1.434692e18, 1.432766e18]\n        result = pd.to_datetime(arr, errors=\"coerce\", cache=cache)\n        tm.assert_index_equal(result, expected)\n\n        expected = DatetimeIndex(\n            [\"2015-06-19 05:33:20\", \"2015-05-27 22:33:20\", \"NaT\", \"NaT\"]\n        )\n        arr = [1.434692e18, 1.432766e18, \"foo\", \"NaT\"]\n        result = pd.to_datetime(arr, errors=\"coerce\", cache=cache)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 1134,
        "end_line": 1160,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit.test_unit_mixed#1163",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit.test_unit_mixed(self, cache)",
        "snippet": "    def test_unit_mixed(self, cache):\n\n        # mixed integers/datetimes\n        expected = DatetimeIndex([\"2013-01-01\", \"NaT\", \"NaT\"])\n        arr = [pd.Timestamp(\"20130101\"), 1.434692e18, 1.432766e18]\n        result = pd.to_datetime(arr, errors=\"coerce\", cache=cache)\n        tm.assert_index_equal(result, expected)\n\n        with pytest.raises(ValueError):\n            pd.to_datetime(arr, errors=\"raise\", cache=cache)\n\n        expected = DatetimeIndex([\"NaT\", \"NaT\", \"2013-01-01\"])\n        arr = [1.434692e18, 1.432766e18, pd.Timestamp(\"20130101\")]\n        result = pd.to_datetime(arr, errors=\"coerce\", cache=cache)\n        tm.assert_index_equal(result, expected)\n\n        with pytest.raises(ValueError):\n            pd.to_datetime(arr, errors=\"raise\", cache=cache)",
        "begin_line": 1163,
        "end_line": 1180,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit.test_unit_rounding#1183",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit.test_unit_rounding(self, cache)",
        "snippet": "    def test_unit_rounding(self, cache):\n        # GH 14156: argument will incur floating point errors but no\n        # premature rounding\n        result = pd.to_datetime(1434743731.8770001, unit=\"s\", cache=cache)\n        expected = pd.Timestamp(\"2015-06-19 19:55:31.877000093\")\n        assert result == expected",
        "begin_line": 1183,
        "end_line": 1188,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit.test_unit_ignore_keeps_name#1191",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit.test_unit_ignore_keeps_name(self, cache)",
        "snippet": "    def test_unit_ignore_keeps_name(self, cache):\n        # GH 21697\n        expected = pd.Index([15e9] * 2, name=\"name\")\n        result = pd.to_datetime(expected, errors=\"ignore\", unit=\"s\", cache=cache)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 1191,
        "end_line": 1195,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit.test_dataframe#1198",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit.test_dataframe(self, cache)",
        "snippet": "    def test_dataframe(self, cache):\n\n        df = DataFrame(\n            {\n                \"year\": [2015, 2016],\n                \"month\": [2, 3],\n                \"day\": [4, 5],\n                \"hour\": [6, 7],\n                \"minute\": [58, 59],\n                \"second\": [10, 11],\n                \"ms\": [1, 1],\n                \"us\": [2, 2],\n                \"ns\": [3, 3],\n            }\n        )\n\n        result = to_datetime(\n            {\"year\": df[\"year\"], \"month\": df[\"month\"], \"day\": df[\"day\"]}, cache=cache\n        )\n        expected = Series(\n            [Timestamp(\"20150204 00:00:00\"), Timestamp(\"20160305 00:0:00\")]\n        )\n        tm.assert_series_equal(result, expected)\n\n        # dict-like\n        result = to_datetime(df[[\"year\", \"month\", \"day\"]].to_dict(), cache=cache)\n        tm.assert_series_equal(result, expected)\n\n        # dict but with constructable\n        df2 = df[[\"year\", \"month\", \"day\"]].to_dict()\n        df2[\"month\"] = 2\n        result = to_datetime(df2, cache=cache)\n        expected2 = Series(\n            [Timestamp(\"20150204 00:00:00\"), Timestamp(\"20160205 00:0:00\")]\n        )\n        tm.assert_series_equal(result, expected2)\n\n        # unit mappings\n        units = [\n            {\n                \"year\": \"years\",\n                \"month\": \"months\",\n                \"day\": \"days\",\n                \"hour\": \"hours\",\n                \"minute\": \"minutes\",\n                \"second\": \"seconds\",\n            },\n            {\n                \"year\": \"year\",\n                \"month\": \"month\",\n                \"day\": \"day\",\n                \"hour\": \"hour\",\n                \"minute\": \"minute\",\n                \"second\": \"second\",\n            },\n        ]\n\n        for d in units:\n            result = to_datetime(df[list(d.keys())].rename(columns=d), cache=cache)\n            expected = Series(\n                [Timestamp(\"20150204 06:58:10\"), Timestamp(\"20160305 07:59:11\")]\n            )\n            tm.assert_series_equal(result, expected)\n\n        d = {\n            \"year\": \"year\",\n            \"month\": \"month\",\n            \"day\": \"day\",\n            \"hour\": \"hour\",\n            \"minute\": \"minute\",\n            \"second\": \"second\",\n            \"ms\": \"ms\",\n            \"us\": \"us\",\n            \"ns\": \"ns\",\n        }\n\n        result = to_datetime(df.rename(columns=d), cache=cache)\n        expected = Series(\n            [\n                Timestamp(\"20150204 06:58:10.001002003\"),\n                Timestamp(\"20160305 07:59:11.001002003\"),\n            ]\n        )\n        tm.assert_series_equal(result, expected)\n\n        # coerce back to int\n        result = to_datetime(df.astype(str), cache=cache)\n        tm.assert_series_equal(result, expected)\n\n        # passing coerce\n        df2 = DataFrame({\"year\": [2015, 2016], \"month\": [2, 20], \"day\": [4, 5]})\n\n        msg = (\n            \"cannot assemble the datetimes: time data .+ does not \"\n            r\"match format '%Y%m%d' \\(match\\)\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(df2, cache=cache)\n        result = to_datetime(df2, errors=\"coerce\", cache=cache)\n        expected = Series([Timestamp(\"20150204 00:00:00\"), NaT])\n        tm.assert_series_equal(result, expected)\n\n        # extra columns\n        msg = r\"extra keys have been passed to the datetime assemblage: \\[foo\\]\"\n        with pytest.raises(ValueError, match=msg):\n            df2 = df.copy()\n            df2[\"foo\"] = 1\n            to_datetime(df2, cache=cache)\n\n        # not enough\n        msg = (\n            r\"to assemble mappings requires at least that \\[year, month, \"\n            r\"day\\] be specified: \\[.+\\] is missing\"\n        )\n        for c in [\n            [\"year\"],\n            [\"year\", \"month\"],\n            [\"year\", \"month\", \"second\"],\n            [\"month\", \"day\"],\n            [\"year\", \"day\", \"second\"],\n        ]:\n            with pytest.raises(ValueError, match=msg):\n                to_datetime(df[c], cache=cache)\n\n        # duplicates\n        msg = \"cannot assemble with duplicate keys\"\n        df2 = DataFrame({\"year\": [2015, 2016], \"month\": [2, 20], \"day\": [4, 5]})\n        df2.columns = [\"year\", \"year\", \"day\"]\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(df2, cache=cache)\n\n        df2 = DataFrame(\n            {\"year\": [2015, 2016], \"month\": [2, 20], \"day\": [4, 5], \"hour\": [4, 5]}\n        )\n        df2.columns = [\"year\", \"month\", \"day\", \"day\"]\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(df2, cache=cache)",
        "begin_line": 1198,
        "end_line": 1334,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit.test_dataframe_dtypes#1337",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit.test_dataframe_dtypes(self, cache)",
        "snippet": "    def test_dataframe_dtypes(self, cache):\n        # #13451\n        df = DataFrame({\"year\": [2015, 2016], \"month\": [2, 3], \"day\": [4, 5]})\n\n        # int16\n        result = to_datetime(df.astype(\"int16\"), cache=cache)\n        expected = Series(\n            [Timestamp(\"20150204 00:00:00\"), Timestamp(\"20160305 00:00:00\")]\n        )\n        tm.assert_series_equal(result, expected)\n\n        # mixed dtypes\n        df[\"month\"] = df[\"month\"].astype(\"int8\")\n        df[\"day\"] = df[\"day\"].astype(\"int8\")\n        result = to_datetime(df, cache=cache)\n        expected = Series(\n            [Timestamp(\"20150204 00:00:00\"), Timestamp(\"20160305 00:00:00\")]\n        )\n        tm.assert_series_equal(result, expected)\n\n        # float\n        df = DataFrame({\"year\": [2000, 2001], \"month\": [1.5, 1], \"day\": [1, 1]})\n        with pytest.raises(ValueError):\n            to_datetime(df, cache=cache)",
        "begin_line": 1337,
        "end_line": 1360,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit.test_dataframe_utc_true#1362",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit.test_dataframe_utc_true(self)",
        "snippet": "    def test_dataframe_utc_true(self):\n        # GH 23760\n        df = pd.DataFrame({\"year\": [2015, 2016], \"month\": [2, 3], \"day\": [4, 5]})\n        result = pd.to_datetime(df, utc=True)\n        expected = pd.Series(\n            np.array([\"2015-02-04\", \"2016-03-05\"], dtype=\"datetime64[ns]\")\n        ).dt.tz_localize(\"UTC\")\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1362,
        "end_line": 1369,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit.test_to_datetime_errors_ignore_utc_true#1371",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeUnit.test_to_datetime_errors_ignore_utc_true(self)",
        "snippet": "    def test_to_datetime_errors_ignore_utc_true(self):\n        # GH 23758\n        result = pd.to_datetime([1], unit=\"s\", utc=True, errors=\"ignore\")\n        expected = DatetimeIndex([\"1970-01-01 00:00:01\"], tz=\"UTC\")\n        tm.assert_index_equal(result, expected)",
        "begin_line": 1371,
        "end_line": 1375,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_barely_out_of_bounds#1379",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_barely_out_of_bounds(self)",
        "snippet": "    def test_to_datetime_barely_out_of_bounds(self):\n        # GH#19529\n        # GH#19382 close enough to bounds that dropping nanos would result\n        # in an in-bounds datetime\n        arr = np.array([\"2262-04-11 23:47:16.854775808\"], dtype=object)\n\n        with pytest.raises(OutOfBoundsDatetime):\n            to_datetime(arr)",
        "begin_line": 1379,
        "end_line": 1386,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_iso8601#1389",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_iso8601(self, cache)",
        "snippet": "    def test_to_datetime_iso8601(self, cache):\n        result = to_datetime([\"2012-01-01 00:00:00\"], cache=cache)\n        exp = Timestamp(\"2012-01-01 00:00:00\")\n        assert result[0] == exp\n\n        result = to_datetime([\"20121001\"], cache=cache)  # bad iso 8601\n        exp = Timestamp(\"2012-10-01\")\n        assert result[0] == exp",
        "begin_line": 1389,
        "end_line": 1396,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_default#1399",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_default(self, cache)",
        "snippet": "    def test_to_datetime_default(self, cache):\n        rs = to_datetime(\"2001\", cache=cache)\n        xp = datetime(2001, 1, 1)\n        assert rs == xp",
        "begin_line": 1399,
        "end_line": 1402,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_on_datetime64_series#1411",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_on_datetime64_series(self, cache)",
        "snippet": "    def test_to_datetime_on_datetime64_series(self, cache):\n        # #2699\n        s = Series(date_range(\"1/1/2000\", periods=10))\n\n        result = to_datetime(s, cache=cache)\n        assert result[0] == s[0]",
        "begin_line": 1411,
        "end_line": 1416,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_with_space_in_series#1419",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_with_space_in_series(self, cache)",
        "snippet": "    def test_to_datetime_with_space_in_series(self, cache):\n        # GH 6428\n        s = Series([\"10/18/2006\", \"10/18/2008\", \" \"])\n        msg = r\"(\\(')?String does not contain a date(:', ' '\\))?\"\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(s, errors=\"raise\", cache=cache)\n        result_coerce = to_datetime(s, errors=\"coerce\", cache=cache)\n        expected_coerce = Series([datetime(2006, 10, 18), datetime(2008, 10, 18), NaT])\n        tm.assert_series_equal(result_coerce, expected_coerce)\n        result_ignore = to_datetime(s, errors=\"ignore\", cache=cache)\n        tm.assert_series_equal(result_ignore, s)",
        "begin_line": 1419,
        "end_line": 1429,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_with_apply#1433",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_with_apply(self, cache)",
        "snippet": "    def test_to_datetime_with_apply(self, cache):\n        # this is only locale tested with US/None locales\n        # GH 5195\n        # with a format and coerce a single item to_datetime fails\n        td = Series([\"May 04\", \"Jun 02\", \"Dec 11\"], index=[1, 2, 3])\n        expected = pd.to_datetime(td, format=\"%b %y\", cache=cache)\n        result = td.apply(pd.to_datetime, format=\"%b %y\", cache=cache)\n        tm.assert_series_equal(result, expected)\n\n        td = pd.Series([\"May 04\", \"Jun 02\", \"\"], index=[1, 2, 3])\n        msg = r\"time data '' does not match format '%b %y' \\(match\\)\"\n        with pytest.raises(ValueError, match=msg):\n            pd.to_datetime(td, format=\"%b %y\", errors=\"raise\", cache=cache)\n        with pytest.raises(ValueError, match=msg):\n            td.apply(pd.to_datetime, format=\"%b %y\", errors=\"raise\", cache=cache)\n        expected = pd.to_datetime(td, format=\"%b %y\", errors=\"coerce\", cache=cache)\n\n        result = td.apply(\n            lambda x: pd.to_datetime(x, format=\"%b %y\", errors=\"coerce\", cache=cache)\n        )\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1433,
        "end_line": 1453,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_types#1456",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_types(self, cache)",
        "snippet": "    def test_to_datetime_types(self, cache):\n\n        # empty string\n        result = to_datetime(\"\", cache=cache)\n        assert result is NaT\n\n        result = to_datetime([\"\", \"\"], cache=cache)\n        assert isna(result).all()\n\n        # ints\n        result = Timestamp(0)\n        expected = to_datetime(0, cache=cache)\n        assert result == expected\n\n        # GH 3888 (strings)\n        expected = to_datetime([\"2012\"], cache=cache)[0]\n        result = to_datetime(\"2012\", cache=cache)\n        assert result == expected\n\n        # array = ['2012','20120101','20120101 12:01:01']\n        array = [\"20120101\", \"20120101 12:01:01\"]\n        expected = list(to_datetime(array, cache=cache))\n        result = [Timestamp(date_str) for date_str in array]\n        tm.assert_almost_equal(result, expected)",
        "begin_line": 1456,
        "end_line": 1479,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_unprocessable_input#1487",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_unprocessable_input(self, cache)",
        "snippet": "    def test_to_datetime_unprocessable_input(self, cache):\n        # GH 4928\n        # GH 21864\n        result = to_datetime([1, \"1\"], errors=\"ignore\", cache=cache)\n\n        expected = Index(np.array([1, \"1\"], dtype=\"O\"))\n        tm.assert_equal(result, expected)\n        msg = \"invalid string coercion to datetime\"\n        with pytest.raises(TypeError, match=msg):\n            to_datetime([1, \"1\"], errors=\"raise\", cache=cache)",
        "begin_line": 1487,
        "end_line": 1496,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_other_datetime64_units#1498",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_other_datetime64_units(self)",
        "snippet": "    def test_to_datetime_other_datetime64_units(self):\n        # 5/25/2012\n        scalar = np.int64(1337904000000000).view(\"M8[us]\")\n        as_obj = scalar.astype(\"O\")\n\n        index = DatetimeIndex([scalar])\n        assert index[0] == scalar.astype(\"O\")\n\n        value = Timestamp(scalar)\n        assert value == as_obj",
        "begin_line": 1498,
        "end_line": 1507,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_list_of_integers#1509",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_list_of_integers(self)",
        "snippet": "    def test_to_datetime_list_of_integers(self):\n        rng = date_range(\"1/1/2000\", periods=20)\n        rng = DatetimeIndex(rng.values)\n\n        ints = list(rng.asi8)\n\n        result = DatetimeIndex(ints)\n\n        tm.assert_index_equal(rng, result)",
        "begin_line": 1509,
        "end_line": 1517,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_overflow#1519",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_overflow(self)",
        "snippet": "    def test_to_datetime_overflow(self):\n        # gh-17637\n        # we are overflowing Timedelta range here\n\n        with pytest.raises(OverflowError):\n            date_range(start=\"1/1/1700\", freq=\"B\", periods=100000)",
        "begin_line": 1519,
        "end_line": 1524,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_string_na_nat_conversion#1527",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_string_na_nat_conversion(self, cache)",
        "snippet": "    def test_string_na_nat_conversion(self, cache):\n        # GH #999, #858\n\n        strings = np.array(\n            [\"1/1/2000\", \"1/2/2000\", np.nan, \"1/4/2000, 12:34:56\"], dtype=object\n        )\n\n        expected = np.empty(4, dtype=\"M8[ns]\")\n        for i, val in enumerate(strings):\n            if isna(val):\n                expected[i] = iNaT\n            else:\n                expected[i] = parse(val)\n\n        result = tslib.array_to_datetime(strings)[0]\n        tm.assert_almost_equal(result, expected)\n\n        result2 = to_datetime(strings, cache=cache)\n        assert isinstance(result2, DatetimeIndex)\n        tm.assert_numpy_array_equal(result, result2.values)\n\n        malformed = np.array([\"1/100/2000\", np.nan], dtype=object)\n\n        # GH 10636, default is now 'raise'\n        msg = r\"Unknown string format:|day is out of range for month\"\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(malformed, errors=\"raise\", cache=cache)\n\n        result = to_datetime(malformed, errors=\"ignore\", cache=cache)\n        # GH 21864\n        expected = Index(malformed)\n        tm.assert_index_equal(result, expected)\n\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(malformed, errors=\"raise\", cache=cache)\n\n        idx = [\"a\", \"b\", \"c\", \"d\", \"e\"]\n        series = Series(\n            [\"1/1/2000\", np.nan, \"1/3/2000\", np.nan, \"1/5/2000\"], index=idx, name=\"foo\"\n        )\n        dseries = Series(\n            [\n                to_datetime(\"1/1/2000\", cache=cache),\n                np.nan,\n                to_datetime(\"1/3/2000\", cache=cache),\n                np.nan,\n                to_datetime(\"1/5/2000\", cache=cache),\n            ],\n            index=idx,\n            name=\"foo\",\n        )\n\n        result = to_datetime(series, cache=cache)\n        dresult = to_datetime(dseries, cache=cache)\n\n        expected = Series(np.empty(5, dtype=\"M8[ns]\"), index=idx)\n        for i in range(5):\n            x = series[i]\n            if isna(x):\n                expected[i] = iNaT\n            else:\n                expected[i] = to_datetime(x, cache=cache)\n\n        tm.assert_series_equal(result, expected, check_names=False)\n        assert result.name == \"foo\"\n\n        tm.assert_series_equal(dresult, expected, check_names=False)\n        assert dresult.name == \"foo\"",
        "begin_line": 1527,
        "end_line": 1594,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_dti_constructor_numpy_timeunits#1608",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_dti_constructor_numpy_timeunits(self, cache, dtype)",
        "snippet": "    def test_dti_constructor_numpy_timeunits(self, cache, dtype):\n        # GH 9114\n        base = pd.to_datetime(\n            [\"2000-01-01T00:00\", \"2000-01-02T00:00\", \"NaT\"], cache=cache\n        )\n\n        values = base.values.astype(dtype)\n\n        tm.assert_index_equal(DatetimeIndex(values), base)\n        tm.assert_index_equal(to_datetime(values, cache=cache), base)",
        "begin_line": 1608,
        "end_line": 1617,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_dayfirst#1620",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_dayfirst(self, cache)",
        "snippet": "    def test_dayfirst(self, cache):\n        # GH 5917\n        arr = [\"10/02/2014\", \"11/02/2014\", \"12/02/2014\"]\n        expected = DatetimeIndex(\n            [datetime(2014, 2, 10), datetime(2014, 2, 11), datetime(2014, 2, 12)]\n        )\n        idx1 = DatetimeIndex(arr, dayfirst=True)\n        idx2 = DatetimeIndex(np.array(arr), dayfirst=True)\n        idx3 = to_datetime(arr, dayfirst=True, cache=cache)\n        idx4 = to_datetime(np.array(arr), dayfirst=True, cache=cache)\n        idx5 = DatetimeIndex(Index(arr), dayfirst=True)\n        idx6 = DatetimeIndex(Series(arr), dayfirst=True)\n        tm.assert_index_equal(expected, idx1)\n        tm.assert_index_equal(expected, idx2)\n        tm.assert_index_equal(expected, idx3)\n        tm.assert_index_equal(expected, idx4)\n        tm.assert_index_equal(expected, idx5)\n        tm.assert_index_equal(expected, idx6)",
        "begin_line": 1620,
        "end_line": 1637,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_dta_tz#1640",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc.test_to_datetime_dta_tz(self, klass)",
        "snippet": "    def test_to_datetime_dta_tz(self, klass):\n        # GH#27733\n        dti = date_range(\"2015-04-05\", periods=3).rename(\"foo\")\n        expected = dti.tz_localize(\"UTC\")\n\n        obj = klass(dti)\n        expected = klass(expected)\n\n        result = to_datetime(obj, utc=True)\n        tm.assert_equal(result, expected)",
        "begin_line": 1640,
        "end_line": 1649,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestGuessDatetimeFormat.test_guess_datetime_format_for_array#1654",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestGuessDatetimeFormat",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestGuessDatetimeFormat.test_guess_datetime_format_for_array(self)",
        "snippet": "    def test_guess_datetime_format_for_array(self):\n        expected_format = \"%Y-%m-%d %H:%M:%S.%f\"\n        dt_string = datetime(2011, 12, 30, 0, 0, 0).strftime(expected_format)\n\n        test_arrays = [\n            np.array([dt_string, dt_string, dt_string], dtype=\"O\"),\n            np.array([np.nan, np.nan, dt_string], dtype=\"O\"),\n            np.array([dt_string, \"random_string\"], dtype=\"O\"),\n        ]\n\n        for test_array in test_arrays:\n            assert tools._guess_datetime_format_for_array(test_array) == expected_format\n\n        format_for_string_of_nans = tools._guess_datetime_format_for_array(\n            np.array([np.nan, np.nan, np.nan], dtype=\"O\")\n        )\n        assert format_for_string_of_nans is None",
        "begin_line": 1654,
        "end_line": 1670,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeInferFormat.test_to_datetime_infer_datetime_format_consistent_format#1675",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeInferFormat",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeInferFormat.test_to_datetime_infer_datetime_format_consistent_format(self, cache)",
        "snippet": "    def test_to_datetime_infer_datetime_format_consistent_format(self, cache):\n        s = pd.Series(pd.date_range(\"20000101\", periods=50, freq=\"H\"))\n\n        test_formats = [\"%m-%d-%Y\", \"%m/%d/%Y %H:%M:%S.%f\", \"%Y-%m-%dT%H:%M:%S.%f\"]\n\n        for test_format in test_formats:\n            s_as_dt_strings = s.apply(lambda x: x.strftime(test_format))\n\n            with_format = pd.to_datetime(\n                s_as_dt_strings, format=test_format, cache=cache\n            )\n            no_infer = pd.to_datetime(\n                s_as_dt_strings, infer_datetime_format=False, cache=cache\n            )\n            yes_infer = pd.to_datetime(\n                s_as_dt_strings, infer_datetime_format=True, cache=cache\n            )\n\n            # Whether the format is explicitly passed, it is inferred, or\n            # it is not inferred, the results should all be the same\n            tm.assert_series_equal(with_format, no_infer)\n            tm.assert_series_equal(no_infer, yes_infer)",
        "begin_line": 1675,
        "end_line": 1696,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeInferFormat.test_to_datetime_infer_datetime_format_inconsistent_format#1699",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeInferFormat",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeInferFormat.test_to_datetime_infer_datetime_format_inconsistent_format(self, cache)",
        "snippet": "    def test_to_datetime_infer_datetime_format_inconsistent_format(self, cache):\n        s = pd.Series(\n            np.array(\n                [\"01/01/2011 00:00:00\", \"01-02-2011 00:00:00\", \"2011-01-03T00:00:00\"]\n            )\n        )\n\n        # When the format is inconsistent, infer_datetime_format should just\n        # fallback to the default parsing\n        tm.assert_series_equal(\n            pd.to_datetime(s, infer_datetime_format=False, cache=cache),\n            pd.to_datetime(s, infer_datetime_format=True, cache=cache),\n        )\n\n        s = pd.Series(np.array([\"Jan/01/2011\", \"Feb/01/2011\", \"Mar/01/2011\"]))\n\n        tm.assert_series_equal(\n            pd.to_datetime(s, infer_datetime_format=False, cache=cache),\n            pd.to_datetime(s, infer_datetime_format=True, cache=cache),\n        )",
        "begin_line": 1699,
        "end_line": 1718,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeInferFormat.test_to_datetime_infer_datetime_format_series_with_nans#1721",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeInferFormat",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeInferFormat.test_to_datetime_infer_datetime_format_series_with_nans(self, cache)",
        "snippet": "    def test_to_datetime_infer_datetime_format_series_with_nans(self, cache):\n        s = pd.Series(\n            np.array([\"01/01/2011 00:00:00\", np.nan, \"01/03/2011 00:00:00\", np.nan])\n        )\n        tm.assert_series_equal(\n            pd.to_datetime(s, infer_datetime_format=False, cache=cache),\n            pd.to_datetime(s, infer_datetime_format=True, cache=cache),\n        )",
        "begin_line": 1721,
        "end_line": 1728,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeInferFormat.test_to_datetime_infer_datetime_format_series_start_with_nans#1731",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeInferFormat",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeInferFormat.test_to_datetime_infer_datetime_format_series_start_with_nans(self, cache)",
        "snippet": "    def test_to_datetime_infer_datetime_format_series_start_with_nans(self, cache):\n        s = pd.Series(\n            np.array(\n                [\n                    np.nan,\n                    np.nan,\n                    \"01/01/2011 00:00:00\",\n                    \"01/02/2011 00:00:00\",\n                    \"01/03/2011 00:00:00\",\n                ]\n            )\n        )\n\n        tm.assert_series_equal(\n            pd.to_datetime(s, infer_datetime_format=False, cache=cache),\n            pd.to_datetime(s, infer_datetime_format=True, cache=cache),\n        )",
        "begin_line": 1731,
        "end_line": 1747,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeInferFormat.test_to_datetime_iso8601_noleading_0s#1750",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeInferFormat",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestToDatetimeInferFormat.test_to_datetime_iso8601_noleading_0s(self, cache)",
        "snippet": "    def test_to_datetime_iso8601_noleading_0s(self, cache):\n        # GH 11871\n        s = pd.Series([\"2014-1-1\", \"2014-2-2\", \"2015-3-3\"])\n        expected = pd.Series(\n            [\n                pd.Timestamp(\"2014-01-01\"),\n                pd.Timestamp(\"2014-02-02\"),\n                pd.Timestamp(\"2015-03-03\"),\n            ]\n        )\n        tm.assert_series_equal(pd.to_datetime(s, cache=cache), expected)\n        tm.assert_series_equal(\n            pd.to_datetime(s, format=\"%Y-%m-%d\", cache=cache), expected\n        )",
        "begin_line": 1750,
        "end_line": 1763,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestDaysInMonth.test_day_not_in_month_coerce#1770",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestDaysInMonth",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestDaysInMonth.test_day_not_in_month_coerce(self, cache)",
        "snippet": "    def test_day_not_in_month_coerce(self, cache):\n        assert isna(to_datetime(\"2015-02-29\", errors=\"coerce\", cache=cache))\n        assert isna(\n            to_datetime(\"2015-02-29\", format=\"%Y-%m-%d\", errors=\"coerce\", cache=cache)\n        )\n        assert isna(\n            to_datetime(\"2015-02-32\", format=\"%Y-%m-%d\", errors=\"coerce\", cache=cache)\n        )\n        assert isna(\n            to_datetime(\"2015-04-31\", format=\"%Y-%m-%d\", errors=\"coerce\", cache=cache)\n        )",
        "begin_line": 1770,
        "end_line": 1780,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestDaysInMonth.test_day_not_in_month_raise#1783",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestDaysInMonth",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestDaysInMonth.test_day_not_in_month_raise(self, cache)",
        "snippet": "    def test_day_not_in_month_raise(self, cache):\n        msg = \"day is out of range for month\"\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(\"2015-02-29\", errors=\"raise\", cache=cache)\n\n        msg = \"time data 2015-02-29 doesn't match format specified\"\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(\"2015-02-29\", errors=\"raise\", format=\"%Y-%m-%d\", cache=cache)\n\n        msg = \"time data 2015-02-32 doesn't match format specified\"\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(\"2015-02-32\", errors=\"raise\", format=\"%Y-%m-%d\", cache=cache)\n\n        msg = \"time data 2015-04-31 doesn't match format specified\"\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(\"2015-04-31\", errors=\"raise\", format=\"%Y-%m-%d\", cache=cache)",
        "begin_line": 1783,
        "end_line": 1798,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestDaysInMonth.test_day_not_in_month_ignore#1801",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestDaysInMonth",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestDaysInMonth.test_day_not_in_month_ignore(self, cache)",
        "snippet": "    def test_day_not_in_month_ignore(self, cache):\n        assert to_datetime(\"2015-02-29\", errors=\"ignore\", cache=cache) == \"2015-02-29\"\n        assert (\n            to_datetime(\"2015-02-29\", errors=\"ignore\", format=\"%Y-%m-%d\", cache=cache)\n            == \"2015-02-29\"\n        )\n        assert (\n            to_datetime(\"2015-02-32\", errors=\"ignore\", format=\"%Y-%m-%d\", cache=cache)\n            == \"2015-02-32\"\n        )\n        assert (\n            to_datetime(\"2015-04-31\", errors=\"ignore\", format=\"%Y-%m-%d\", cache=cache)\n            == \"2015-04-31\"\n        )",
        "begin_line": 1801,
        "end_line": 1814,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestDatetimeParsingWrappers.test_parsers#1871",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestDatetimeParsingWrappers",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestDatetimeParsingWrappers.test_parsers(self, date_str, expected, cache)",
        "snippet": "    def test_parsers(self, date_str, expected, cache):\n\n        # dateutil >= 2.5.0 defaults to yearfirst=True\n        # https://github.com/dateutil/dateutil/issues/217\n        yearfirst = True\n\n        result1, _, _ = parsing.parse_time_string(date_str, yearfirst=yearfirst)\n        result2 = to_datetime(date_str, yearfirst=yearfirst)\n        result3 = to_datetime([date_str], yearfirst=yearfirst)\n        # result5 is used below\n        result4 = to_datetime(\n            np.array([date_str], dtype=object), yearfirst=yearfirst, cache=cache\n        )\n        result6 = DatetimeIndex([date_str], yearfirst=yearfirst)\n        # result7 is used below\n        result8 = DatetimeIndex(Index([date_str]), yearfirst=yearfirst)\n        result9 = DatetimeIndex(Series([date_str]), yearfirst=yearfirst)\n\n        for res in [result1, result2]:\n            assert res == expected\n        for res in [result3, result4, result6, result8, result9]:\n            exp = DatetimeIndex([pd.Timestamp(expected)])\n            tm.assert_index_equal(res, exp)\n\n        # these really need to have yearfirst, but we don't support\n        if not yearfirst:\n            result5 = Timestamp(date_str)\n            assert result5 == expected\n            result7 = date_range(date_str, freq=\"S\", periods=1, yearfirst=yearfirst)\n            assert result7 == expected",
        "begin_line": 1871,
        "end_line": 1900,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestDatetimeParsingWrappers.test_na_values_with_cache#1903",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestDatetimeParsingWrappers",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestDatetimeParsingWrappers.test_na_values_with_cache(self, cache, unique_nulls_fixture, unique_nulls_fixture2)",
        "snippet": "    def test_na_values_with_cache(\n        self, cache, unique_nulls_fixture, unique_nulls_fixture2\n    ):\n        # GH22305\n        expected = Index([NaT, NaT], dtype=\"datetime64[ns]\")\n        result = to_datetime([unique_nulls_fixture, unique_nulls_fixture2], cache=cache)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 1903,
        "end_line": 1909,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestDatetimeParsingWrappers.test_parsers_nat#1911",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestDatetimeParsingWrappers",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestDatetimeParsingWrappers.test_parsers_nat(self)",
        "snippet": "    def test_parsers_nat(self):\n        # Test that each of several string-accepting methods return pd.NaT\n        result1, _, _ = parsing.parse_time_string(\"NaT\")\n        result2 = to_datetime(\"NaT\")\n        result3 = Timestamp(\"NaT\")\n        result4 = DatetimeIndex([\"NaT\"])[0]\n        assert result1 is NaT\n        assert result2 is NaT\n        assert result3 is NaT\n        assert result4 is NaT",
        "begin_line": 1911,
        "end_line": 1920,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestDatetimeParsingWrappers.test_parsers_dayfirst_yearfirst#1923",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestDatetimeParsingWrappers",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestDatetimeParsingWrappers.test_parsers_dayfirst_yearfirst(self, cache)",
        "snippet": "    def test_parsers_dayfirst_yearfirst(self, cache):\n        # OK\n        # 2.5.1 10-11-12   [dayfirst=0, yearfirst=0] -> 2012-10-11 00:00:00\n        # 2.5.2 10-11-12   [dayfirst=0, yearfirst=1] -> 2012-10-11 00:00:00\n        # 2.5.3 10-11-12   [dayfirst=0, yearfirst=0] -> 2012-10-11 00:00:00\n\n        # OK\n        # 2.5.1 10-11-12   [dayfirst=0, yearfirst=1] -> 2010-11-12 00:00:00\n        # 2.5.2 10-11-12   [dayfirst=0, yearfirst=1] -> 2010-11-12 00:00:00\n        # 2.5.3 10-11-12   [dayfirst=0, yearfirst=1] -> 2010-11-12 00:00:00\n\n        # bug fix in 2.5.2\n        # 2.5.1 10-11-12   [dayfirst=1, yearfirst=1] -> 2010-11-12 00:00:00\n        # 2.5.2 10-11-12   [dayfirst=1, yearfirst=1] -> 2010-12-11 00:00:00\n        # 2.5.3 10-11-12   [dayfirst=1, yearfirst=1] -> 2010-12-11 00:00:00\n\n        # OK\n        # 2.5.1 10-11-12   [dayfirst=1, yearfirst=0] -> 2012-11-10 00:00:00\n        # 2.5.2 10-11-12   [dayfirst=1, yearfirst=0] -> 2012-11-10 00:00:00\n        # 2.5.3 10-11-12   [dayfirst=1, yearfirst=0] -> 2012-11-10 00:00:00\n\n        # OK\n        # 2.5.1 20/12/21   [dayfirst=0, yearfirst=0] -> 2021-12-20 00:00:00\n        # 2.5.2 20/12/21   [dayfirst=0, yearfirst=0] -> 2021-12-20 00:00:00\n        # 2.5.3 20/12/21   [dayfirst=0, yearfirst=0] -> 2021-12-20 00:00:00\n\n        # OK\n        # 2.5.1 20/12/21   [dayfirst=0, yearfirst=1] -> 2020-12-21 00:00:00\n        # 2.5.2 20/12/21   [dayfirst=0, yearfirst=1] -> 2020-12-21 00:00:00\n        # 2.5.3 20/12/21   [dayfirst=0, yearfirst=1] -> 2020-12-21 00:00:00\n\n        # revert of bug in 2.5.2\n        # 2.5.1 20/12/21   [dayfirst=1, yearfirst=1] -> 2020-12-21 00:00:00\n        # 2.5.2 20/12/21   [dayfirst=1, yearfirst=1] -> month must be in 1..12\n        # 2.5.3 20/12/21   [dayfirst=1, yearfirst=1] -> 2020-12-21 00:00:00\n\n        # OK\n        # 2.5.1 20/12/21   [dayfirst=1, yearfirst=0] -> 2021-12-20 00:00:00\n        # 2.5.2 20/12/21   [dayfirst=1, yearfirst=0] -> 2021-12-20 00:00:00\n        # 2.5.3 20/12/21   [dayfirst=1, yearfirst=0] -> 2021-12-20 00:00:00\n\n        # str : dayfirst, yearfirst, expected\n        cases = {\n            \"10-11-12\": [\n                (False, False, datetime(2012, 10, 11)),\n                (True, False, datetime(2012, 11, 10)),\n                (False, True, datetime(2010, 11, 12)),\n                (True, True, datetime(2010, 12, 11)),\n            ],\n            \"20/12/21\": [\n                (False, False, datetime(2021, 12, 20)),\n                (True, False, datetime(2021, 12, 20)),\n                (False, True, datetime(2020, 12, 21)),\n                (True, True, datetime(2020, 12, 21)),\n            ],\n        }\n\n        for date_str, values in cases.items():\n            for dayfirst, yearfirst, expected in values:\n\n                # compare with dateutil result\n                dateutil_result = parse(\n                    date_str, dayfirst=dayfirst, yearfirst=yearfirst\n                )\n                assert dateutil_result == expected\n\n                result1, _, _ = parsing.parse_time_string(\n                    date_str, dayfirst=dayfirst, yearfirst=yearfirst\n                )\n\n                # we don't support dayfirst/yearfirst here:\n                if not dayfirst and not yearfirst:\n                    result2 = Timestamp(date_str)\n                    assert result2 == expected\n\n                result3 = to_datetime(\n                    date_str, dayfirst=dayfirst, yearfirst=yearfirst, cache=cache\n                )\n\n                result4 = DatetimeIndex(\n                    [date_str], dayfirst=dayfirst, yearfirst=yearfirst\n                )[0]\n\n                assert result1 == expected\n                assert result3 == expected\n                assert result4 == expected",
        "begin_line": 1923,
        "end_line": 2008,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestDatetimeParsingWrappers.test_parsers_timestring#2011",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestDatetimeParsingWrappers",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestDatetimeParsingWrappers.test_parsers_timestring(self, cache)",
        "snippet": "    def test_parsers_timestring(self, cache):\n        # must be the same as dateutil result\n        cases = {\n            \"10:15\": (parse(\"10:15\"), datetime(1, 1, 1, 10, 15)),\n            \"9:05\": (parse(\"9:05\"), datetime(1, 1, 1, 9, 5)),\n        }\n\n        for date_str, (exp_now, exp_def) in cases.items():\n            result1, _, _ = parsing.parse_time_string(date_str)\n            result2 = to_datetime(date_str)\n            result3 = to_datetime([date_str])\n            result4 = Timestamp(date_str)\n            result5 = DatetimeIndex([date_str])[0]\n            # parse time string return time string based on default date\n            # others are not, and can't be changed because it is used in\n            # time series plot\n            assert result1 == exp_def\n            assert result2 == exp_now\n            assert result3 == exp_now\n            assert result4 == exp_now\n            assert result5 == exp_now",
        "begin_line": 2011,
        "end_line": 2031,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestDatetimeParsingWrappers.test_parsers_time#2034",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestDatetimeParsingWrappers",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestDatetimeParsingWrappers.test_parsers_time(self)",
        "snippet": "    def test_parsers_time(self):\n        # GH11818\n        strings = [\n            \"14:15\",\n            \"1415\",\n            \"2:15pm\",\n            \"0215pm\",\n            \"14:15:00\",\n            \"141500\",\n            \"2:15:00pm\",\n            \"021500pm\",\n            time(14, 15),\n        ]\n        expected = time(14, 15)\n\n        for time_string in strings:\n            assert tools.to_time(time_string) == expected\n\n        new_string = \"14.15\"\n        msg = r\"Cannot convert arg \\['14\\.15'\\] to a time\"\n        with pytest.raises(ValueError, match=msg):\n            tools.to_time(new_string)\n        assert tools.to_time(new_string, format=\"%H.%M\") == expected\n\n        arg = [\"14:15\", \"20:20\"]\n        expected_arr = [time(14, 15), time(20, 20)]\n        assert tools.to_time(arg) == expected_arr\n        assert tools.to_time(arg, format=\"%H:%M\") == expected_arr\n        assert tools.to_time(arg, infer_time_format=True) == expected_arr\n        assert tools.to_time(arg, format=\"%I:%M%p\", errors=\"coerce\") == [None, None]\n\n        res = tools.to_time(arg, format=\"%I:%M%p\", errors=\"ignore\")\n        tm.assert_numpy_array_equal(res, np.array(arg, dtype=np.object_))\n\n        with pytest.raises(ValueError):\n            tools.to_time(arg, format=\"%I:%M%p\", errors=\"raise\")\n\n        tm.assert_series_equal(\n            tools.to_time(Series(arg, name=\"test\")), Series(expected_arr, name=\"test\")\n        )\n\n        res = tools.to_time(np.array(arg))\n        assert isinstance(res, list)\n        assert res == expected_arr",
        "begin_line": 2034,
        "end_line": 2077,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestDatetimeParsingWrappers.test_parsers_timezone_minute_offsets_roundtrip#2095",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestDatetimeParsingWrappers",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestDatetimeParsingWrappers.test_parsers_timezone_minute_offsets_roundtrip(self, cache, dt_string, tz, dt_string_repr)",
        "snippet": "    def test_parsers_timezone_minute_offsets_roundtrip(\n        self, cache, dt_string, tz, dt_string_repr\n    ):\n        # GH11708\n        base = to_datetime(\"2013-01-01 00:00:00\", cache=cache)\n        base = base.tz_localize(\"UTC\").tz_convert(tz)\n        dt_time = to_datetime(dt_string, cache=cache)\n        assert base == dt_time\n        assert dt_string_repr == repr(dt_time)",
        "begin_line": 2095,
        "end_line": 2103,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.units#2107",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools",
        "signature": "pandas.tests.indexes.datetimes.test_tools.units(request)",
        "snippet": "def units(request):\n    \"\"\"Day and some time units.\n\n    * D\n    * s\n    * ms\n    * us\n    * ns\n    \"\"\"\n    return request.param",
        "begin_line": 2107,
        "end_line": 2116,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.epoch_1960#2120",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools",
        "signature": "pandas.tests.indexes.datetimes.test_tools.epoch_1960()",
        "snippet": "def epoch_1960():\n    \"\"\"Timestamp at 1960-01-01.\"\"\"\n    return Timestamp(\"1960-01-01\")",
        "begin_line": 2120,
        "end_line": 2122,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.units_from_epochs#2126",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools",
        "signature": "pandas.tests.indexes.datetimes.test_tools.units_from_epochs()",
        "snippet": "def units_from_epochs():\n    return list(range(5))",
        "begin_line": 2126,
        "end_line": 2127,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.epochs#2131",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools",
        "signature": "pandas.tests.indexes.datetimes.test_tools.epochs(epoch_1960, request)",
        "snippet": "def epochs(epoch_1960, request):\n    \"\"\"Timestamp at 1960-01-01 in various forms.\n\n    * pd.Timestamp\n    * datetime.datetime\n    * numpy.datetime64\n    * str\n    \"\"\"\n    assert request.param in {\"timestamp\", \"pydatetime\", \"datetime64\", \"str_1960\"}\n    if request.param == \"timestamp\":\n        return epoch_1960\n    elif request.param == \"pydatetime\":\n        return epoch_1960.to_pydatetime()\n    elif request.param == \"datetime64\":\n        return epoch_1960.to_datetime64()\n    else:\n        return str(epoch_1960)",
        "begin_line": 2131,
        "end_line": 2147,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.julian_dates#2151",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools",
        "signature": "pandas.tests.indexes.datetimes.test_tools.julian_dates()",
        "snippet": "def julian_dates():\n    return pd.date_range(\"2014-1-1\", periods=10).to_julian_date().values",
        "begin_line": 2151,
        "end_line": 2152,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestOrigin.test_to_basic#2156",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestOrigin",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestOrigin.test_to_basic(self, julian_dates)",
        "snippet": "    def test_to_basic(self, julian_dates):\n        # gh-11276, gh-11745\n        # for origin as julian\n\n        result = Series(pd.to_datetime(julian_dates, unit=\"D\", origin=\"julian\"))\n        expected = Series(\n            pd.to_datetime(julian_dates - pd.Timestamp(0).to_julian_date(), unit=\"D\")\n        )\n        tm.assert_series_equal(result, expected)\n\n        result = Series(pd.to_datetime([0, 1, 2], unit=\"D\", origin=\"unix\"))\n        expected = Series(\n            [Timestamp(\"1970-01-01\"), Timestamp(\"1970-01-02\"), Timestamp(\"1970-01-03\")]\n        )\n        tm.assert_series_equal(result, expected)\n\n        # default\n        result = Series(pd.to_datetime([0, 1, 2], unit=\"D\"))\n        expected = Series(\n            [Timestamp(\"1970-01-01\"), Timestamp(\"1970-01-02\"), Timestamp(\"1970-01-03\")]\n        )\n        tm.assert_series_equal(result, expected)",
        "begin_line": 2156,
        "end_line": 2177,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestOrigin.test_julian_round_trip#2179",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestOrigin",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestOrigin.test_julian_round_trip(self)",
        "snippet": "    def test_julian_round_trip(self):\n        result = pd.to_datetime(2456658, origin=\"julian\", unit=\"D\")\n        assert result.to_julian_date() == 2456658\n\n        # out-of-bounds\n        with pytest.raises(ValueError):\n            pd.to_datetime(1, origin=\"julian\", unit=\"D\")",
        "begin_line": 2179,
        "end_line": 2185,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestOrigin.test_invalid_unit#2187",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestOrigin",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestOrigin.test_invalid_unit(self, units, julian_dates)",
        "snippet": "    def test_invalid_unit(self, units, julian_dates):\n\n        # checking for invalid combination of origin='julian' and unit != D\n        if units != \"D\":\n            with pytest.raises(ValueError):\n                pd.to_datetime(julian_dates, unit=units, origin=\"julian\")",
        "begin_line": 2187,
        "end_line": 2192,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestOrigin.test_invalid_origin#2194",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestOrigin",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestOrigin.test_invalid_origin(self)",
        "snippet": "    def test_invalid_origin(self):\n\n        # need to have a numeric specified\n        with pytest.raises(ValueError):\n            pd.to_datetime(\"2005-01-01\", origin=\"1960-01-01\")\n\n        with pytest.raises(ValueError):\n            pd.to_datetime(\"2005-01-01\", origin=\"1960-01-01\", unit=\"D\")",
        "begin_line": 2194,
        "end_line": 2201,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestOrigin.test_epoch#2203",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestOrigin",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestOrigin.test_epoch(self, units, epochs, epoch_1960, units_from_epochs)",
        "snippet": "    def test_epoch(self, units, epochs, epoch_1960, units_from_epochs):\n\n        expected = Series(\n            [pd.Timedelta(x, unit=units) + epoch_1960 for x in units_from_epochs]\n        )\n\n        result = Series(pd.to_datetime(units_from_epochs, unit=units, origin=epochs))\n        tm.assert_series_equal(result, expected)",
        "begin_line": 2203,
        "end_line": 2210,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestOrigin.test_invalid_origins#2221",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestOrigin",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestOrigin.test_invalid_origins(self, origin, exc, units, units_from_epochs)",
        "snippet": "    def test_invalid_origins(self, origin, exc, units, units_from_epochs):\n\n        with pytest.raises(exc):\n            pd.to_datetime(units_from_epochs, unit=units, origin=origin)",
        "begin_line": 2221,
        "end_line": 2224,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestOrigin.test_invalid_origins_tzinfo#2226",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestOrigin",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestOrigin.test_invalid_origins_tzinfo(self)",
        "snippet": "    def test_invalid_origins_tzinfo(self):\n        # GH16842\n        with pytest.raises(ValueError):\n            pd.to_datetime(1, unit=\"D\", origin=datetime(2000, 1, 1, tzinfo=pytz.utc))",
        "begin_line": 2226,
        "end_line": 2229,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestOrigin.test_to_datetime_out_of_bounds_with_format_arg#2232",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestOrigin",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestOrigin.test_to_datetime_out_of_bounds_with_format_arg(self, format)",
        "snippet": "    def test_to_datetime_out_of_bounds_with_format_arg(self, format):\n        # see gh-23830\n        msg = \"Out of bounds nanosecond timestamp\"\n        with pytest.raises(OutOfBoundsDatetime, match=msg):\n            to_datetime(\"2417-10-27 00:00:00\", format=format)",
        "begin_line": 2232,
        "end_line": 2236,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestOrigin.test_processing_order#2238",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestOrigin",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestOrigin.test_processing_order(self)",
        "snippet": "    def test_processing_order(self):\n        # make sure we handle out-of-bounds *before*\n        # constructing the dates\n\n        result = pd.to_datetime(200 * 365, unit=\"D\")\n        expected = Timestamp(\"2169-11-13 00:00:00\")\n        assert result == expected\n\n        result = pd.to_datetime(200 * 365, unit=\"D\", origin=\"1870-01-01\")\n        expected = Timestamp(\"2069-11-13 00:00:00\")\n        assert result == expected\n\n        result = pd.to_datetime(300 * 365, unit=\"D\", origin=\"1870-01-01\")\n        expected = Timestamp(\"2169-10-20 00:00:00\")\n        assert result == expected",
        "begin_line": 2238,
        "end_line": 2252,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.TestOrigin.test_arg_tz_ns_unit#2263",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools.TestOrigin",
        "signature": "pandas.tests.indexes.datetimes.test_tools.TestOrigin.test_arg_tz_ns_unit(self, offset, utc, exp)",
        "snippet": "    def test_arg_tz_ns_unit(self, offset, utc, exp):\n        # GH 25546\n        arg = \"2019-01-01T00:00:00.000\" + offset\n        result = to_datetime([arg], unit=\"ns\", utc=utc)\n        expected = to_datetime([exp])\n        tm.assert_index_equal(result, expected)",
        "begin_line": 2263,
        "end_line": 2268,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.test_should_cache#2275",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools",
        "signature": "pandas.tests.indexes.datetimes.test_tools.test_should_cache(listlike, do_caching)",
        "snippet": "def test_should_cache(listlike, do_caching):\n    assert (\n        tools.should_cache(listlike, check_count=len(listlike), unique_share=0.7)\n        == do_caching\n    )",
        "begin_line": 2275,
        "end_line": 2279,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.test_should_cache_errors#2289",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools",
        "signature": "pandas.tests.indexes.datetimes.test_tools.test_should_cache_errors(unique_share, check_count, err_message)",
        "snippet": "def test_should_cache_errors(unique_share, check_count, err_message):\n    arg = [5] * 10\n\n    with pytest.raises(AssertionError, match=err_message):\n        tools.should_cache(arg, unique_share, check_count)",
        "begin_line": 2289,
        "end_line": 2293,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_tools.test_nullable_integer_to_datetime#2296",
        "src_path": "pandas/tests/indexes/datetimes/test_tools.py",
        "class_name": "pandas.tests.indexes.datetimes.test_tools",
        "signature": "pandas.tests.indexes.datetimes.test_tools.test_nullable_integer_to_datetime()",
        "snippet": "def test_nullable_integer_to_datetime():\n    # Test for #30050\n    ser = pd.Series([1, 2, None, 2 ** 61, None])\n    ser = ser.astype(\"Int64\")\n    ser_copy = ser.copy()\n\n    res = pd.to_datetime(ser, unit=\"ns\")\n\n    expected = pd.Series(\n        [\n            np.datetime64(\"1970-01-01 00:00:00.000000001\"),\n            np.datetime64(\"1970-01-01 00:00:00.000000002\"),\n            np.datetime64(\"NaT\"),\n            np.datetime64(\"2043-01-25 23:56:49.213693952\"),\n            np.datetime64(\"NaT\"),\n        ]\n    )\n    tm.assert_series_equal(res, expected)\n    # Check that ser isn't mutated\n    tm.assert_series_equal(ser, ser_copy)",
        "begin_line": 2296,
        "end_line": 2315,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_pickle_compat_construction#37",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_pickle_compat_construction(self)",
        "snippet": "    def test_pickle_compat_construction(self):\n        # need an object to create with\n        msg = (\n            r\"Index\\(\\.\\.\\.\\) must be called with a collection of some\"\n            r\" kind, None was passed|\"\n            r\"__new__\\(\\) missing 1 required positional argument: 'data'|\"\n            r\"__new__\\(\\) takes at least 2 arguments \\(1 given\\)\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            self._holder()",
        "begin_line": 37,
        "end_line": 46,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_to_series#48",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_to_series(self)",
        "snippet": "    def test_to_series(self):\n        # assert that we are creating a copy of the index\n\n        idx = self.create_index()\n        s = idx.to_series()\n        assert s.values is not idx.values\n        assert s.index is not idx\n        assert s.name == idx.name",
        "begin_line": 48,
        "end_line": 55,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_to_series_with_arguments#57",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_to_series_with_arguments(self)",
        "snippet": "    def test_to_series_with_arguments(self):\n        # GH18699\n\n        # index kwarg\n        idx = self.create_index()\n        s = idx.to_series(index=idx)\n\n        assert s.values is not idx.values\n        assert s.index is idx\n        assert s.name == idx.name\n\n        # name kwarg\n        idx = self.create_index()\n        s = idx.to_series(name=\"__test\")\n\n        assert s.values is not idx.values\n        assert s.index is not idx\n        assert s.name != idx.name",
        "begin_line": 57,
        "end_line": 74,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_to_frame#77",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_to_frame(self, name)",
        "snippet": "    def test_to_frame(self, name):\n        # see GH-15230, GH-22580\n        idx = self.create_index()\n\n        if name:\n            idx_name = name\n        else:\n            idx_name = idx.name or 0\n\n        df = idx.to_frame(name=idx_name)\n\n        assert df.index is idx\n        assert len(df.columns) == 1\n        assert df.columns[0] == idx_name\n        assert df[idx_name].values is not idx.values\n\n        df = idx.to_frame(index=False, name=idx_name)\n        assert df.index is not idx",
        "begin_line": 77,
        "end_line": 94,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_shift#96",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_shift(self)",
        "snippet": "    def test_shift(self):\n\n        # GH8083 test the base class for shift\n        idx = self.create_index()\n        msg = \"Not supported for type {}\".format(type(idx).__name__)\n        with pytest.raises(NotImplementedError, match=msg):\n            idx.shift(1)\n        with pytest.raises(NotImplementedError, match=msg):\n            idx.shift(1, 2)",
        "begin_line": 96,
        "end_line": 104,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_constructor_name_unhashable#106",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_constructor_name_unhashable(self)",
        "snippet": "    def test_constructor_name_unhashable(self):\n        # GH#29069 check that name is hashable\n        # See also same-named test in tests.series.test_constructors\n        idx = self.create_index()\n        with pytest.raises(TypeError, match=\"Index.name must be a hashable type\"):\n            type(idx)(idx, name=[])",
        "begin_line": 106,
        "end_line": 111,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_create_index_existing_name#113",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_create_index_existing_name(self)",
        "snippet": "    def test_create_index_existing_name(self):\n\n        # GH11193, when an existing index is passed, and a new name is not\n        # specified, the new index should inherit the previous object name\n        expected = self.create_index()\n        if not isinstance(expected, MultiIndex):\n            expected.name = \"foo\"\n            result = pd.Index(expected)\n            tm.assert_index_equal(result, expected)\n\n            result = pd.Index(expected, name=\"bar\")\n            expected.name = \"bar\"\n            tm.assert_index_equal(result, expected)\n        else:\n            expected.names = [\"foo\", \"bar\"]\n            result = pd.Index(expected)\n            tm.assert_index_equal(\n                result,\n                Index(\n                    Index(\n                        [\n                            (\"foo\", \"one\"),\n                            (\"foo\", \"two\"),\n                            (\"bar\", \"one\"),\n                            (\"baz\", \"two\"),\n                            (\"qux\", \"one\"),\n                            (\"qux\", \"two\"),\n                        ],\n                        dtype=\"object\",\n                    ),\n                    names=[\"foo\", \"bar\"],\n                ),\n            )\n\n            result = pd.Index(expected, names=[\"A\", \"B\"])\n            tm.assert_index_equal(\n                result,\n                Index(\n                    Index(\n                        [\n                            (\"foo\", \"one\"),\n                            (\"foo\", \"two\"),\n                            (\"bar\", \"one\"),\n                            (\"baz\", \"two\"),\n                            (\"qux\", \"one\"),\n                            (\"qux\", \"two\"),\n                        ],\n                        dtype=\"object\",\n                    ),\n                    names=[\"A\", \"B\"],\n                ),\n            )",
        "begin_line": 113,
        "end_line": 164,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_numeric_compat#166",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_numeric_compat(self)",
        "snippet": "    def test_numeric_compat(self):\n\n        idx = self.create_index()\n        with pytest.raises(TypeError, match=\"cannot perform __mul__\"):\n            idx * 1\n        with pytest.raises(TypeError, match=\"cannot perform __rmul__\"):\n            1 * idx\n\n        div_err = \"cannot perform __truediv__\"\n        with pytest.raises(TypeError, match=div_err):\n            idx / 1\n\n        div_err = div_err.replace(\" __\", \" __r\")\n        with pytest.raises(TypeError, match=div_err):\n            1 / idx\n        with pytest.raises(TypeError, match=\"cannot perform __floordiv__\"):\n            idx // 1\n        with pytest.raises(TypeError, match=\"cannot perform __rfloordiv__\"):\n            1 // idx",
        "begin_line": 166,
        "end_line": 184,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_logical_compat#186",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_logical_compat(self)",
        "snippet": "    def test_logical_compat(self):\n        idx = self.create_index()\n        with pytest.raises(TypeError, match=\"cannot perform all\"):\n            idx.all()\n        with pytest.raises(TypeError, match=\"cannot perform any\"):\n            idx.any()",
        "begin_line": 186,
        "end_line": 191,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_boolean_context_compat#193",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_boolean_context_compat(self)",
        "snippet": "    def test_boolean_context_compat(self):\n\n        # boolean context compat\n        idx = self.create_index()\n\n        with pytest.raises(ValueError, match=\"The truth value of a\"):\n            if idx:\n                pass",
        "begin_line": 193,
        "end_line": 200,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_reindex_base#202",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_reindex_base(self)",
        "snippet": "    def test_reindex_base(self):\n        idx = self.create_index()\n        expected = np.arange(idx.size, dtype=np.intp)\n\n        actual = idx.get_indexer(idx)\n        tm.assert_numpy_array_equal(expected, actual)\n\n        with pytest.raises(ValueError, match=\"Invalid fill method\"):\n            idx.get_indexer(idx, method=\"invalid\")",
        "begin_line": 202,
        "end_line": 210,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_get_indexer_consistency#212",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_get_indexer_consistency(self, indices)",
        "snippet": "    def test_get_indexer_consistency(self, indices):\n        # See GH 16819\n        if isinstance(indices, IntervalIndex):\n            return\n\n        if indices.is_unique or isinstance(indices, CategoricalIndex):\n            indexer = indices.get_indexer(indices[0:2])\n            assert isinstance(indexer, np.ndarray)\n            assert indexer.dtype == np.intp\n        else:\n            e = \"Reindexing only valid with uniquely valued Index objects\"\n            with pytest.raises(InvalidIndexError, match=e):\n                indices.get_indexer(indices[0:2])\n\n        indexer, _ = indices.get_indexer_non_unique(indices[0:2])\n        assert isinstance(indexer, np.ndarray)\n        assert indexer.dtype == np.intp",
        "begin_line": 212,
        "end_line": 228,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_ndarray_compat_properties#230",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_ndarray_compat_properties(self)",
        "snippet": "    def test_ndarray_compat_properties(self):\n        idx = self.create_index()\n        assert idx.T.equals(idx)\n        assert idx.transpose().equals(idx)\n\n        values = idx.values\n        for prop in self._compat_props:\n            assert getattr(idx, prop) == getattr(values, prop)\n\n        # test for validity\n        idx.nbytes\n        idx.values.nbytes",
        "begin_line": 230,
        "end_line": 241,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_repr_roundtrip#243",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_repr_roundtrip(self)",
        "snippet": "    def test_repr_roundtrip(self):\n\n        idx = self.create_index()\n        tm.assert_index_equal(eval(repr(idx)), idx)",
        "begin_line": 243,
        "end_line": 246,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_str#248",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_str(self)",
        "snippet": "    def test_str(self):\n\n        # test the string repr\n        idx = self.create_index()\n        idx.name = \"foo\"\n        assert \"'foo'\" in str(idx)\n        assert type(idx).__name__ in str(idx)",
        "begin_line": 248,
        "end_line": 254,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_repr_max_seq_item_setting#256",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_repr_max_seq_item_setting(self)",
        "snippet": "    def test_repr_max_seq_item_setting(self):\n        # GH10182\n        idx = self.create_index()\n        idx = idx.repeat(50)\n        with pd.option_context(\"display.max_seq_items\", None):\n            repr(idx)\n            assert \"...\" not in str(idx)",
        "begin_line": 256,
        "end_line": 262,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_copy_name#264",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_copy_name(self, indices)",
        "snippet": "    def test_copy_name(self, indices):\n        # gh-12309: Check that the \"name\" argument\n        # passed at initialization is honored.\n        if isinstance(indices, MultiIndex):\n            return\n\n        first = type(indices)(indices, copy=True, name=\"mario\")\n        second = type(first)(first, copy=False)\n\n        # Even though \"copy=False\", we want a new object.\n        assert first is not second\n\n        # Not using tm.assert_index_equal() since names differ.\n        assert indices.equals(first)\n\n        assert first.name == \"mario\"\n        assert second.name == \"mario\"\n\n        s1 = Series(2, index=first)\n        s2 = Series(3, index=second[:-1])\n\n        if not isinstance(indices, CategoricalIndex):\n            # See gh-13365\n            s3 = s1 * s2\n            assert s3.index.name == \"mario\"",
        "begin_line": 264,
        "end_line": 288,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_ensure_copied_data#290",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_ensure_copied_data(self, indices)",
        "snippet": "    def test_ensure_copied_data(self, indices):\n        # Check the \"copy\" argument of each Index.__new__ is honoured\n        # GH12309\n        init_kwargs = {}\n        if isinstance(indices, PeriodIndex):\n            # Needs \"freq\" specification:\n            init_kwargs[\"freq\"] = indices.freq\n        elif isinstance(indices, (RangeIndex, MultiIndex, CategoricalIndex)):\n            # RangeIndex cannot be initialized from data\n            # MultiIndex and CategoricalIndex are tested separately\n            return\n\n        index_type = type(indices)\n        result = index_type(indices.values, copy=True, **init_kwargs)\n        tm.assert_index_equal(indices, result)\n        tm.assert_numpy_array_equal(\n            indices._ndarray_values, result._ndarray_values, check_same=\"copy\"\n        )\n\n        if isinstance(indices, PeriodIndex):\n            # .values an object array of Period, thus copied\n            result = index_type(ordinal=indices.asi8, copy=False, **init_kwargs)\n            tm.assert_numpy_array_equal(\n                indices._ndarray_values, result._ndarray_values, check_same=\"same\"\n            )\n        elif isinstance(indices, IntervalIndex):\n            # checked in test_interval.py\n            pass\n        else:\n            result = index_type(indices.values, copy=False, **init_kwargs)\n            tm.assert_numpy_array_equal(\n                indices.values, result.values, check_same=\"same\"\n            )\n            tm.assert_numpy_array_equal(\n                indices._ndarray_values, result._ndarray_values, check_same=\"same\"\n            )",
        "begin_line": 290,
        "end_line": 325,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_memory_usage#327",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_memory_usage(self, indices)",
        "snippet": "    def test_memory_usage(self, indices):\n        indices._engine.clear_mapping()\n        result = indices.memory_usage()\n        if indices.empty:\n            # we report 0 for no-length\n            assert result == 0\n            return\n\n        # non-zero length\n        indices.get_loc(indices[0])\n        result2 = indices.memory_usage()\n        result3 = indices.memory_usage(deep=True)\n\n        # RangeIndex, IntervalIndex\n        # don't have engines\n        if not isinstance(indices, (RangeIndex, IntervalIndex)):\n            assert result2 > result\n\n        if indices.inferred_type == \"object\":\n            assert result3 > result2",
        "begin_line": 327,
        "end_line": 346,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_argsort#348",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_argsort(self, request, indices)",
        "snippet": "    def test_argsort(self, request, indices):\n        # separately tested\n        if isinstance(indices, CategoricalIndex):\n            return\n\n        result = indices.argsort()\n        expected = np.array(indices).argsort()\n        tm.assert_numpy_array_equal(result, expected, check_dtype=False)",
        "begin_line": 348,
        "end_line": 355,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_numpy_argsort#357",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_numpy_argsort(self, indices)",
        "snippet": "    def test_numpy_argsort(self, indices):\n        result = np.argsort(indices)\n        expected = indices.argsort()\n        tm.assert_numpy_array_equal(result, expected)\n\n        # these are the only two types that perform\n        # pandas compatibility input validation - the\n        # rest already perform separate (or no) such\n        # validation via their 'values' attribute as\n        # defined in pandas.core.indexes/base.py - they\n        # cannot be changed at the moment due to\n        # backwards compatibility concerns\n        if isinstance(type(indices), (CategoricalIndex, RangeIndex)):\n            msg = \"the 'axis' parameter is not supported\"\n            with pytest.raises(ValueError, match=msg):\n                np.argsort(indices, axis=1)\n\n            msg = \"the 'kind' parameter is not supported\"\n            with pytest.raises(ValueError, match=msg):\n                np.argsort(indices, kind=\"mergesort\")\n\n            msg = \"the 'order' parameter is not supported\"\n            with pytest.raises(ValueError, match=msg):\n                np.argsort(indices, order=(\"a\", \"b\"))",
        "begin_line": 357,
        "end_line": 380,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_take#382",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_take(self, indices)",
        "snippet": "    def test_take(self, indices):\n        indexer = [4, 3, 0, 2]\n        if len(indices) < 5:\n            # not enough elements; ignore\n            return\n\n        result = indices.take(indexer)\n        expected = indices[indexer]\n        assert result.equals(expected)\n\n        if not isinstance(indices, (DatetimeIndex, PeriodIndex, TimedeltaIndex)):\n            # GH 10791\n            with pytest.raises(AttributeError):\n                indices.freq",
        "begin_line": 382,
        "end_line": 395,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_take_invalid_kwargs#397",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_take_invalid_kwargs(self)",
        "snippet": "    def test_take_invalid_kwargs(self):\n        idx = self.create_index()\n        indices = [1, 2]\n\n        msg = r\"take\\(\\) got an unexpected keyword argument 'foo'\"\n        with pytest.raises(TypeError, match=msg):\n            idx.take(indices, foo=2)\n\n        msg = \"the 'out' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            idx.take(indices, out=indices)\n\n        msg = \"the 'mode' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            idx.take(indices, mode=\"clip\")",
        "begin_line": 397,
        "end_line": 411,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_repeat#413",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_repeat(self)",
        "snippet": "    def test_repeat(self):\n        rep = 2\n        i = self.create_index()\n        expected = pd.Index(i.values.repeat(rep), name=i.name)\n        tm.assert_index_equal(i.repeat(rep), expected)\n\n        i = self.create_index()\n        rep = np.arange(len(i))\n        expected = pd.Index(i.values.repeat(rep), name=i.name)\n        tm.assert_index_equal(i.repeat(rep), expected)",
        "begin_line": 413,
        "end_line": 422,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_numpy_repeat#424",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_numpy_repeat(self)",
        "snippet": "    def test_numpy_repeat(self):\n        rep = 2\n        i = self.create_index()\n        expected = i.repeat(rep)\n        tm.assert_index_equal(np.repeat(i, rep), expected)\n\n        msg = \"the 'axis' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            np.repeat(i, rep, axis=0)",
        "begin_line": 424,
        "end_line": 432,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_where#435",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_where(self, klass)",
        "snippet": "    def test_where(self, klass):\n        i = self.create_index()\n\n        cond = [True] * len(i)\n        result = i.where(klass(cond))\n        expected = i\n        tm.assert_index_equal(result, expected)\n\n        cond = [False] + [True] * len(i[1:])\n        expected = pd.Index([i._na_value] + i[1:].tolist(), dtype=i.dtype)\n        result = i.where(klass(cond))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 435,
        "end_line": 446,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_set_ops_error_cases#452",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_set_ops_error_cases(self, case, method, indices)",
        "snippet": "    def test_set_ops_error_cases(self, case, method, indices):\n        # non-iterable input\n        msg = \"Input must be Index or array-like\"\n        with pytest.raises(TypeError, match=msg):\n            getattr(indices, method)(case)",
        "begin_line": 452,
        "end_line": 456,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_intersection_base#458",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_intersection_base(self, indices)",
        "snippet": "    def test_intersection_base(self, indices):\n        if isinstance(indices, CategoricalIndex):\n            return\n\n        first = indices[:5]\n        second = indices[:3]\n        intersect = first.intersection(second)\n        assert tm.equalContents(intersect, second)\n\n        # GH 10149\n        cases = [klass(second.values) for klass in [np.array, Series, list]]\n        for case in cases:\n            result = first.intersection(case)\n            assert tm.equalContents(result, second)\n\n        if isinstance(indices, MultiIndex):\n            msg = \"other must be a MultiIndex or a list of tuples\"\n            with pytest.raises(TypeError, match=msg):\n                first.intersection([1, 2, 3])",
        "begin_line": 458,
        "end_line": 476,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_union_base#478",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_union_base(self, indices)",
        "snippet": "    def test_union_base(self, indices):\n        first = indices[3:]\n        second = indices[:5]\n        everything = indices\n        union = first.union(second)\n        assert tm.equalContents(union, everything)\n\n        # GH 10149\n        cases = [klass(second.values) for klass in [np.array, Series, list]]\n        for case in cases:\n            if not isinstance(indices, CategoricalIndex):\n                result = first.union(case)\n                assert tm.equalContents(result, everything)\n\n        if isinstance(indices, MultiIndex):\n            msg = \"other must be a MultiIndex or a list of tuples\"\n            with pytest.raises(TypeError, match=msg):\n                first.union([1, 2, 3])",
        "begin_line": 478,
        "end_line": 495,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_difference_base#498",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_difference_base(self, sort, indices)",
        "snippet": "    def test_difference_base(self, sort, indices):\n        if isinstance(indices, CategoricalIndex):\n            return\n\n        first = indices[2:]\n        second = indices[:4]\n        answer = indices[4:]\n        result = first.difference(second, sort)\n        assert tm.equalContents(result, answer)\n\n        # GH 10149\n        cases = [klass(second.values) for klass in [np.array, Series, list]]\n        for case in cases:\n            if isinstance(indices, (DatetimeIndex, TimedeltaIndex)):\n                assert type(result) == type(answer)\n                tm.assert_numpy_array_equal(\n                    result.sort_values().asi8, answer.sort_values().asi8\n                )\n            else:\n                result = first.difference(case, sort)\n                assert tm.equalContents(result, answer)\n\n        if isinstance(indices, MultiIndex):\n            msg = \"other must be a MultiIndex or a list of tuples\"\n            with pytest.raises(TypeError, match=msg):\n                first.difference([1, 2, 3], sort)",
        "begin_line": 498,
        "end_line": 523,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_symmetric_difference#525",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_symmetric_difference(self, indices)",
        "snippet": "    def test_symmetric_difference(self, indices):\n        if isinstance(indices, CategoricalIndex):\n            return\n\n        first = indices[1:]\n        second = indices[:-1]\n        answer = indices[[0, -1]]\n        result = first.symmetric_difference(second)\n        assert tm.equalContents(result, answer)\n\n        # GH 10149\n        cases = [klass(second.values) for klass in [np.array, Series, list]]\n        for case in cases:\n            result = first.symmetric_difference(case)\n            assert tm.equalContents(result, answer)\n\n        if isinstance(indices, MultiIndex):\n            msg = \"other must be a MultiIndex or a list of tuples\"\n            with pytest.raises(TypeError, match=msg):\n                first.symmetric_difference([1, 2, 3])",
        "begin_line": 525,
        "end_line": 544,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_insert_base#546",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_insert_base(self, indices)",
        "snippet": "    def test_insert_base(self, indices):\n        result = indices[1:4]\n\n        if not len(indices):\n            return\n\n        # test 0th element\n        assert indices[0:4].equals(result.insert(0, indices[0]))",
        "begin_line": 546,
        "end_line": 553,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_delete_base#555",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_delete_base(self, indices)",
        "snippet": "    def test_delete_base(self, indices):\n        if not len(indices):\n            return\n\n        if isinstance(indices, RangeIndex):\n            # tested in class\n            return\n\n        expected = indices[1:]\n        result = indices.delete(0)\n        assert result.equals(expected)\n        assert result.name == expected.name\n\n        expected = indices[:-1]\n        result = indices.delete(-1)\n        assert result.equals(expected)\n        assert result.name == expected.name\n\n        with pytest.raises((IndexError, ValueError)):\n            # either depending on numpy version\n            indices.delete(len(indices))",
        "begin_line": 555,
        "end_line": 575,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_equals#577",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_equals(self, indices)",
        "snippet": "    def test_equals(self, indices):\n        if isinstance(indices, IntervalIndex):\n            # IntervalIndex tested separately\n            return\n\n        assert indices.equals(indices)\n        assert indices.equals(indices.copy())\n        assert indices.equals(indices.astype(object))\n\n        assert not indices.equals(list(indices))\n        assert not indices.equals(np.array(indices))\n\n        # Cannot pass in non-int64 dtype to RangeIndex\n        if not isinstance(indices, RangeIndex):\n            same_values = Index(indices, dtype=object)\n            assert indices.equals(same_values)\n            assert same_values.equals(indices)\n\n        if indices.nlevels == 1:\n            # do not test MultiIndex\n            assert not indices.equals(Series(indices))",
        "begin_line": 577,
        "end_line": 597,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_equals_op#599",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_equals_op(self)",
        "snippet": "    def test_equals_op(self):\n        # GH9947, GH10637\n        index_a = self.create_index()\n        if isinstance(index_a, PeriodIndex):\n            pytest.skip(\"Skip check for PeriodIndex\")\n\n        n = len(index_a)\n        index_b = index_a[0:-1]\n        index_c = index_a[0:-1].append(index_a[-2:-1])\n        index_d = index_a[0:1]\n\n        msg = \"Lengths must match|could not be broadcast\"\n        with pytest.raises(ValueError, match=msg):\n            index_a == index_b\n        expected1 = np.array([True] * n)\n        expected2 = np.array([True] * (n - 1) + [False])\n        tm.assert_numpy_array_equal(index_a == index_a, expected1)\n        tm.assert_numpy_array_equal(index_a == index_c, expected2)\n\n        # test comparisons with numpy arrays\n        array_a = np.array(index_a)\n        array_b = np.array(index_a[0:-1])\n        array_c = np.array(index_a[0:-1].append(index_a[-2:-1]))\n        array_d = np.array(index_a[0:1])\n        with pytest.raises(ValueError, match=msg):\n            index_a == array_b\n        tm.assert_numpy_array_equal(index_a == array_a, expected1)\n        tm.assert_numpy_array_equal(index_a == array_c, expected2)\n\n        # test comparisons with Series\n        series_a = Series(array_a)\n        series_b = Series(array_b)\n        series_c = Series(array_c)\n        series_d = Series(array_d)\n        with pytest.raises(ValueError, match=msg):\n            index_a == series_b\n\n        tm.assert_numpy_array_equal(index_a == series_a, expected1)\n        tm.assert_numpy_array_equal(index_a == series_c, expected2)\n\n        # cases where length is 1 for one of them\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            index_a == index_d\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            index_a == series_d\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            index_a == array_d\n        msg = \"Can only compare identically-labeled Series objects\"\n        with pytest.raises(ValueError, match=msg):\n            series_a == series_d\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            series_a == array_d\n\n        # comparing with a scalar should broadcast; note that we are excluding\n        # MultiIndex because in this case each item in the index is a tuple of\n        # length 2, and therefore is considered an array of length 2 in the\n        # comparison instead of a scalar\n        if not isinstance(index_a, MultiIndex):\n            expected3 = np.array([False] * (len(index_a) - 2) + [True, False])\n            # assuming the 2nd to last item is unique in the data\n            item = index_a[-2]\n            tm.assert_numpy_array_equal(index_a == item, expected3)\n            tm.assert_series_equal(series_a == item, Series(expected3))",
        "begin_line": 599,
        "end_line": 661,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_hasnans_isnans#663",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_hasnans_isnans(self, indices)",
        "snippet": "    def test_hasnans_isnans(self, indices):\n        # GH 11343, added tests for hasnans / isnans\n        if isinstance(indices, MultiIndex):\n            return\n\n        # cases in indices doesn't include NaN\n        idx = indices.copy(deep=True)\n        expected = np.array([False] * len(idx), dtype=bool)\n        tm.assert_numpy_array_equal(idx._isnan, expected)\n        assert idx.hasnans is False\n\n        idx = indices.copy(deep=True)\n        values = np.asarray(idx.values)\n\n        if len(indices) == 0:\n            return\n        elif isinstance(indices, DatetimeIndexOpsMixin):\n            values[1] = iNaT\n        elif isinstance(indices, (Int64Index, UInt64Index)):\n            return\n        else:\n            values[1] = np.nan\n\n        if isinstance(indices, PeriodIndex):\n            idx = type(indices)(values, freq=indices.freq)\n        else:\n            idx = type(indices)(values)\n\n            expected = np.array([False] * len(idx), dtype=bool)\n            expected[1] = True\n            tm.assert_numpy_array_equal(idx._isnan, expected)\n            assert idx.hasnans is True",
        "begin_line": 663,
        "end_line": 694,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_fillna#696",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_fillna(self, indices)",
        "snippet": "    def test_fillna(self, indices):\n        # GH 11343\n        if len(indices) == 0:\n            pass\n        elif isinstance(indices, MultiIndex):\n            idx = indices.copy(deep=True)\n            msg = \"isna is not defined for MultiIndex\"\n            with pytest.raises(NotImplementedError, match=msg):\n                idx.fillna(idx[0])\n        else:\n            idx = indices.copy(deep=True)\n            result = idx.fillna(idx[0])\n            tm.assert_index_equal(result, idx)\n            assert result is not idx\n\n            msg = \"'value' must be a scalar, passed: \"\n            with pytest.raises(TypeError, match=msg):\n                idx.fillna([idx[0]])\n\n            idx = indices.copy(deep=True)\n            values = np.asarray(idx.values)\n\n            if isinstance(indices, DatetimeIndexOpsMixin):\n                values[1] = iNaT\n            elif isinstance(indices, (Int64Index, UInt64Index)):\n                return\n            else:\n                values[1] = np.nan\n\n            if isinstance(indices, PeriodIndex):\n                idx = type(indices)(values, freq=indices.freq)\n            else:\n                idx = type(indices)(values)\n\n            expected = np.array([False] * len(idx), dtype=bool)\n            expected[1] = True\n            tm.assert_numpy_array_equal(idx._isnan, expected)\n            assert idx.hasnans is True",
        "begin_line": 696,
        "end_line": 733,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_nulls#735",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_nulls(self, indices)",
        "snippet": "    def test_nulls(self, indices):\n        # this is really a smoke test for the methods\n        # as these are adequately tested for function elsewhere\n        if len(indices) == 0:\n            tm.assert_numpy_array_equal(indices.isna(), np.array([], dtype=bool))\n        elif isinstance(indices, MultiIndex):\n            idx = indices.copy()\n            msg = \"isna is not defined for MultiIndex\"\n            with pytest.raises(NotImplementedError, match=msg):\n                idx.isna()\n        elif not indices.hasnans:\n            tm.assert_numpy_array_equal(\n                indices.isna(), np.zeros(len(indices), dtype=bool)\n            )\n            tm.assert_numpy_array_equal(\n                indices.notna(), np.ones(len(indices), dtype=bool)\n            )\n        else:\n            result = isna(indices)\n            tm.assert_numpy_array_equal(indices.isna(), result)\n            tm.assert_numpy_array_equal(indices.notna(), ~result)",
        "begin_line": 735,
        "end_line": 755,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_empty#757",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_empty(self)",
        "snippet": "    def test_empty(self):\n        # GH 15270\n        index = self.create_index()\n        assert not index.empty\n        assert index[:0].empty",
        "begin_line": 757,
        "end_line": 761,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_join_self_unique#763",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_join_self_unique(self, join_type)",
        "snippet": "    def test_join_self_unique(self, join_type):\n        index = self.create_index()\n        if index.is_unique:\n            joined = index.join(index, how=join_type)\n            assert (index == joined).all()",
        "begin_line": 763,
        "end_line": 767,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_map#769",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_map(self)",
        "snippet": "    def test_map(self):\n        # callable\n        index = self.create_index()\n\n        # we don't infer UInt64\n        if isinstance(index, pd.UInt64Index):\n            expected = index.astype(\"int64\")\n        else:\n            expected = index\n\n        result = index.map(lambda x: x)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 769,
        "end_line": 780,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_map_dictlike#789",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_map_dictlike(self, mapper)",
        "snippet": "    def test_map_dictlike(self, mapper):\n\n        index = self.create_index()\n        if isinstance(index, (pd.CategoricalIndex, pd.IntervalIndex)):\n            pytest.skip(\"skipping tests for {}\".format(type(index)))\n\n        identity = mapper(index.values, index)\n\n        # we don't infer to UInt64 for a dict\n        if isinstance(index, pd.UInt64Index) and isinstance(identity, dict):\n            expected = index.astype(\"int64\")\n        else:\n            expected = index\n\n        result = index.map(identity)\n        tm.assert_index_equal(result, expected)\n\n        # empty mappable\n        expected = pd.Index([np.nan] * len(index))\n        result = index.map(mapper(expected, index))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 789,
        "end_line": 809,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_putmask_with_wrong_mask#811",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_putmask_with_wrong_mask(self)",
        "snippet": "    def test_putmask_with_wrong_mask(self):\n        # GH18368\n        index = self.create_index()\n\n        with pytest.raises(ValueError):\n            index.putmask(np.ones(len(index) + 1, np.bool), 1)\n\n        with pytest.raises(ValueError):\n            index.putmask(np.ones(len(index) - 1, np.bool), 1)\n\n        with pytest.raises(ValueError):\n            index.putmask(\"foo\", 1)",
        "begin_line": 811,
        "end_line": 822,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_astype_category#827",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_astype_category(self, copy, name, ordered)",
        "snippet": "    def test_astype_category(self, copy, name, ordered):\n        # GH 18630\n        index = self.create_index()\n        if name:\n            index = index.rename(name)\n\n        # standard categories\n        dtype = CategoricalDtype(ordered=ordered)\n        result = index.astype(dtype, copy=copy)\n        expected = CategoricalIndex(index.values, name=name, ordered=ordered)\n        tm.assert_index_equal(result, expected)\n\n        # non-standard categories\n        dtype = CategoricalDtype(index.unique().tolist()[:-1], ordered)\n        result = index.astype(dtype, copy=copy)\n        expected = CategoricalIndex(index.values, name=name, dtype=dtype)\n        tm.assert_index_equal(result, expected)\n\n        if ordered is False:\n            # dtype='category' defaults to ordered=False, so only test once\n            result = index.astype(\"category\", copy=copy)\n            expected = CategoricalIndex(index.values, name=name)\n            tm.assert_index_equal(result, expected)",
        "begin_line": 827,
        "end_line": 849,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_is_unique#851",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_is_unique(self)",
        "snippet": "    def test_is_unique(self):\n        # initialize a unique index\n        index = self.create_index().drop_duplicates()\n        assert index.is_unique is True\n\n        # empty index should be unique\n        index_empty = index[:0]\n        assert index_empty.is_unique is True\n\n        # test basic dupes\n        index_dup = index.insert(0, index[0])\n        assert index_dup.is_unique is False\n\n        # single NA should be unique\n        index_na = index.insert(0, np.nan)\n        assert index_na.is_unique is True\n\n        # multiple NA should not be unique\n        index_na_dup = index_na.insert(0, np.nan)\n        assert index_na_dup.is_unique is False",
        "begin_line": 851,
        "end_line": 870,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_engine_reference_cycle#872",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_engine_reference_cycle(self)",
        "snippet": "    def test_engine_reference_cycle(self):\n        # GH27585\n        index = self.create_index()\n        nrefs_pre = len(gc.get_referrers(index))\n        index._engine\n        assert len(gc.get_referrers(index)) == nrefs_pre",
        "begin_line": 872,
        "end_line": 877,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.idx#9",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.idx()",
        "snippet": "def idx():\n    # a MultiIndex used to test the general functionality of the\n    # general functionality of this object\n    major_axis = Index([\"foo\", \"bar\", \"baz\", \"qux\"])\n    minor_axis = Index([\"one\", \"two\"])\n\n    major_codes = np.array([0, 0, 1, 2, 3, 3])\n    minor_codes = np.array([0, 1, 0, 1, 0, 1])\n    index_names = [\"first\", \"second\"]\n    mi = MultiIndex(\n        levels=[major_axis, minor_axis],\n        codes=[major_codes, minor_codes],\n        names=index_names,\n        verify_integrity=False,\n    )\n    return mi",
        "begin_line": 9,
        "end_line": 24,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.idx_dup#28",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.idx_dup()",
        "snippet": "def idx_dup():\n    # compare tests/indexes/multi/conftest.py\n    major_axis = Index([\"foo\", \"bar\", \"baz\", \"qux\"])\n    minor_axis = Index([\"one\", \"two\"])\n\n    major_codes = np.array([0, 0, 1, 0, 1, 1])\n    minor_codes = np.array([0, 1, 0, 1, 0, 1])\n    index_names = [\"first\", \"second\"]\n    mi = MultiIndex(\n        levels=[major_axis, minor_axis],\n        codes=[major_codes, minor_codes],\n        names=index_names,\n        verify_integrity=False,\n    )\n    return mi",
        "begin_line": 28,
        "end_line": 42,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.index_names#46",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.index_names()",
        "snippet": "def index_names():\n    # names that match those in the idx fixture for testing equality of\n    # names assigned to the idx\n    return [\"first\", \"second\"]",
        "begin_line": 46,
        "end_line": 49,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.holder#53",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.holder()",
        "snippet": "def holder():\n    # the MultiIndex constructor used to base compatibility with pickle\n    return MultiIndex",
        "begin_line": 53,
        "end_line": 55,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.compat_props#59",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.compat_props()",
        "snippet": "def compat_props():\n    # a MultiIndex must have these properties associated with it\n    return [\"shape\", \"ndim\", \"size\"]",
        "begin_line": 59,
        "end_line": 61,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.narrow_multi_index#65",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.narrow_multi_index()",
        "snippet": "def narrow_multi_index():\n    \"\"\"\n    Return a MultiIndex that is narrower than the display (<80 characters).\n    \"\"\"\n    n = 1000\n    ci = pd.CategoricalIndex(list(\"a\" * n) + ([\"abc\"] * n))\n    dti = pd.date_range(\"2000-01-01\", freq=\"s\", periods=n * 2)\n    return pd.MultiIndex.from_arrays([ci, ci.codes + 9, dti], names=[\"a\", \"b\", \"dti\"])",
        "begin_line": 65,
        "end_line": 72,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.wide_multi_index#76",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.wide_multi_index()",
        "snippet": "def wide_multi_index():\n    \"\"\"\n    Return a MultiIndex that is wider than the display (>80 characters).\n    \"\"\"\n    n = 1000\n    ci = pd.CategoricalIndex(list(\"a\" * n) + ([\"abc\"] * n))\n    dti = pd.date_range(\"2000-01-01\", freq=\"s\", periods=n * 2)\n    levels = [ci, ci.codes + 9, dti, dti, dti]\n    names = [\"a\", \"b\", \"dti_1\", \"dti_2\", \"dti_3\"]\n    return pd.MultiIndex.from_arrays(levels, names=names)",
        "begin_line": 76,
        "end_line": 85,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_argmax_axis_invalid#12",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_argmax_axis_invalid(self)",
        "snippet": "    def test_argmax_axis_invalid(self):\n        # GH#23081\n        rng = self.create_index()\n        with pytest.raises(ValueError):\n            rng.argmax(axis=1)\n        with pytest.raises(ValueError):\n            rng.argmin(axis=2)\n        with pytest.raises(ValueError):\n            rng.min(axis=-2)\n        with pytest.raises(ValueError):\n            rng.max(axis=-3)",
        "begin_line": 12,
        "end_line": 22,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_can_hold_identifiers#24",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_can_hold_identifiers(self)",
        "snippet": "    def test_can_hold_identifiers(self):\n        idx = self.create_index()\n        key = idx[0]\n        assert idx._can_hold_identifiers_and_holds_name(key) is False",
        "begin_line": 24,
        "end_line": 27,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_shift_identity#29",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_shift_identity(self)",
        "snippet": "    def test_shift_identity(self):\n\n        idx = self.create_index()\n        tm.assert_index_equal(idx, idx.shift(0))",
        "begin_line": 29,
        "end_line": 32,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_str#34",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_str(self)",
        "snippet": "    def test_str(self):\n\n        # test the string repr\n        idx = self.create_index()\n        idx.name = \"foo\"\n        assert not \"length={}\".format(len(idx)) in str(idx)\n        assert \"'foo'\" in str(idx)\n        assert type(idx).__name__ in str(idx)\n\n        if hasattr(idx, \"tz\"):\n            if idx.tz is not None:\n                assert idx.tz in str(idx)\n        if hasattr(idx, \"freq\"):\n            assert \"freq='{idx.freqstr}'\".format(idx=idx) in str(idx)",
        "begin_line": 34,
        "end_line": 47,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_view#49",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_view(self)",
        "snippet": "    def test_view(self):\n        i = self.create_index()\n\n        i_view = i.view(\"i8\")\n        result = self._holder(i)\n        tm.assert_index_equal(result, i)\n\n        i_view = i.view(self._holder)\n        result = self._holder(i)\n        tm.assert_index_equal(result, i_view)",
        "begin_line": 49,
        "end_line": 58,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_callable#60",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_callable(self)",
        "snippet": "    def test_map_callable(self):\n        index = self.create_index()\n        expected = index + index.freq\n        result = index.map(lambda x: x + x.freq)\n        tm.assert_index_equal(result, expected)\n\n        # map to NaT\n        result = index.map(lambda x: pd.NaT if x == index[0] else x)\n        expected = pd.Index([pd.NaT] + index[1:].tolist())\n        tm.assert_index_equal(result, expected)",
        "begin_line": 60,
        "end_line": 69,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_dictlike#78",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_dictlike(self, mapper)",
        "snippet": "    def test_map_dictlike(self, mapper):\n        index = self.create_index()\n        expected = index + index.freq\n\n        # don't compare the freqs\n        if isinstance(expected, pd.DatetimeIndex):\n            expected._data.freq = None\n\n        result = index.map(mapper(expected, index))\n        tm.assert_index_equal(result, expected)\n\n        expected = pd.Index([pd.NaT] + index[1:].tolist())\n        result = index.map(mapper(expected, index))\n        tm.assert_index_equal(result, expected)\n\n        # empty map; these map to np.nan because we cannot know\n        # to re-infer things\n        expected = pd.Index([np.nan] * len(index))\n        result = index.map(mapper([], []))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 78,
        "end_line": 97,
        "comment": "",
        "is_bug": false
    }
]