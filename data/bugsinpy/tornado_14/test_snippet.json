[
    {
        "name": "tornado.test.ioloop_test.FakeTimeSelect.__init__#28",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.FakeTimeSelect",
        "signature": "tornado.test.ioloop_test.FakeTimeSelect.__init__(self)",
        "snippet": "    def __init__(self):\n        self._time = 1000\n        super(FakeTimeSelect, self).__init__()",
        "begin_line": 28,
        "end_line": 30,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.FakeTimeSelect.time#32",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.FakeTimeSelect",
        "signature": "tornado.test.ioloop_test.FakeTimeSelect.time(self)",
        "snippet": "    def time(self):\n        return self._time",
        "begin_line": 32,
        "end_line": 33,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.FakeTimeSelect.sleep#35",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.FakeTimeSelect",
        "signature": "tornado.test.ioloop_test.FakeTimeSelect.sleep(self, t)",
        "snippet": "    def sleep(self, t):\n        self._time += t",
        "begin_line": 35,
        "end_line": 36,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.FakeTimeSelect.poll#38",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.FakeTimeSelect",
        "signature": "tornado.test.ioloop_test.FakeTimeSelect.poll(self, timeout)",
        "snippet": "    def poll(self, timeout):\n        events = super(FakeTimeSelect, self).poll(0)\n        if events:\n            return events\n        self._time += timeout\n        return []",
        "begin_line": 38,
        "end_line": 43,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.FakeTimeIOLoop.initialize#53",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.FakeTimeIOLoop",
        "signature": "tornado.test.ioloop_test.FakeTimeIOLoop.initialize(self)",
        "snippet": "    def initialize(self):\n        self.fts = FakeTimeSelect()\n        super(FakeTimeIOLoop, self).initialize(impl=self.fts,\n                                               time_func=self.fts.time)",
        "begin_line": 53,
        "end_line": 56,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.FakeTimeIOLoop.sleep#58",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.FakeTimeIOLoop",
        "signature": "tornado.test.ioloop_test.FakeTimeIOLoop.sleep(self, t)",
        "snippet": "    def sleep(self, t):\n        \"\"\"Simulate a blocking sleep by advancing the clock.\"\"\"\n        self.fts.sleep(t)",
        "begin_line": 58,
        "end_line": 60,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_wakeup#65",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_wakeup(self)",
        "snippet": "    def test_add_callback_wakeup(self):\n        # Make sure that add_callback from inside a running IOLoop\n        # wakes up the IOLoop immediately instead of waiting for a timeout.\n        def callback():\n            self.called = True\n            self.stop()\n\n        def schedule_callback():\n            self.called = False\n            self.io_loop.add_callback(callback)\n            # Store away the time so we can check if we woke up immediately\n            self.start_time = time.time()\n        self.io_loop.add_timeout(self.io_loop.time(), schedule_callback)\n        self.wait()\n        self.assertAlmostEqual(time.time(), self.start_time, places=2)\n        self.assertTrue(self.called)",
        "begin_line": 65,
        "end_line": 80,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.callback#68",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.callback()",
        "snippet": "        def callback():\n            self.called = True\n            self.stop()",
        "begin_line": 68,
        "end_line": 70,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.schedule_callback#72",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.schedule_callback()",
        "snippet": "        def schedule_callback():\n            self.called = False\n            self.io_loop.add_callback(callback)\n            # Store away the time so we can check if we woke up immediately\n            self.start_time = time.time()",
        "begin_line": 72,
        "end_line": 76,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_wakeup_other_thread#83",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_wakeup_other_thread(self)",
        "snippet": "    def test_add_callback_wakeup_other_thread(self):\n        def target():\n            # sleep a bit to let the ioloop go into its poll loop\n            time.sleep(0.01)\n            self.stop_time = time.time()\n            self.io_loop.add_callback(self.stop)\n        thread = threading.Thread(target=target)\n        self.io_loop.add_callback(thread.start)\n        self.wait()\n        delta = time.time() - self.stop_time\n        self.assertLess(delta, 0.1)\n        thread.join()",
        "begin_line": 83,
        "end_line": 94,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.target#84",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.target()",
        "snippet": "        def target():\n            # sleep a bit to let the ioloop go into its poll loop\n            time.sleep(0.01)\n            self.stop_time = time.time()\n            self.io_loop.add_callback(self.stop)",
        "begin_line": 84,
        "end_line": 88,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_add_timeout_timedelta#96",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_add_timeout_timedelta(self)",
        "snippet": "    def test_add_timeout_timedelta(self):\n        self.io_loop.add_timeout(datetime.timedelta(microseconds=1), self.stop)\n        self.wait()",
        "begin_line": 96,
        "end_line": 98,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_multiple_add#100",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_multiple_add(self)",
        "snippet": "    def test_multiple_add(self):\n        sock, port = bind_unused_port()\n        try:\n            self.io_loop.add_handler(sock.fileno(), lambda fd, events: None,\n                                     IOLoop.READ)\n            # Attempting to add the same handler twice fails\n            # (with a platform-dependent exception)\n            self.assertRaises(Exception, self.io_loop.add_handler,\n                              sock.fileno(), lambda fd, events: None,\n                              IOLoop.READ)\n        finally:\n            self.io_loop.remove_handler(sock.fileno())\n            sock.close()",
        "begin_line": 100,
        "end_line": 112,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_remove_without_add#114",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_remove_without_add(self)",
        "snippet": "    def test_remove_without_add(self):\n        # remove_handler should not throw an exception if called on an fd\n        # was never added.\n        sock, port = bind_unused_port()\n        try:\n            self.io_loop.remove_handler(sock.fileno())\n        finally:\n            sock.close()",
        "begin_line": 114,
        "end_line": 121,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_from_signal#123",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_from_signal(self)",
        "snippet": "    def test_add_callback_from_signal(self):\n        # cheat a little bit and just run this normally, since we can't\n        # easily simulate the races that happen with real signal handlers\n        self.io_loop.add_callback_from_signal(self.stop)\n        self.wait()",
        "begin_line": 123,
        "end_line": 127,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_from_signal_other_thread#129",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_from_signal_other_thread(self)",
        "snippet": "    def test_add_callback_from_signal_other_thread(self):\n        # Very crude test, just to make sure that we cover this case.\n        # This also happens to be the first test where we run an IOLoop in\n        # a non-main thread.\n        other_ioloop = IOLoop()\n        thread = threading.Thread(target=other_ioloop.start)\n        thread.start()\n        other_ioloop.add_callback_from_signal(other_ioloop.stop)\n        thread.join()\n        other_ioloop.close()",
        "begin_line": 129,
        "end_line": 138,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_while_closing#140",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_while_closing(self)",
        "snippet": "    def test_add_callback_while_closing(self):\n        # Issue #635: add_callback() should raise a clean exception\n        # if called while another thread is closing the IOLoop.\n        closing = threading.Event()\n\n        def target():\n            other_ioloop.add_callback(other_ioloop.stop)\n            other_ioloop.start()\n            closing.set()\n            other_ioloop.close(all_fds=True)\n        other_ioloop = IOLoop()\n        thread = threading.Thread(target=target)\n        thread.start()\n        closing.wait()\n        for i in range(1000):\n            try:\n                other_ioloop.add_callback(lambda: None)\n            except RuntimeError as e:\n                self.assertEqual(\"IOLoop is closing\", str(e))\n                break",
        "begin_line": 140,
        "end_line": 159,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.target#145",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.target()",
        "snippet": "        def target():\n            other_ioloop.add_callback(other_ioloop.stop)\n            other_ioloop.start()\n            closing.set()\n            other_ioloop.close(all_fds=True)",
        "begin_line": 145,
        "end_line": 149,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_handle_callback_exception#161",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_handle_callback_exception(self)",
        "snippet": "    def test_handle_callback_exception(self):\n        # IOLoop.handle_callback_exception can be overridden to catch\n        # exceptions in callbacks.\n        def handle_callback_exception(callback):\n            self.assertIs(sys.exc_info()[0], ZeroDivisionError)\n            self.stop()\n        self.io_loop.handle_callback_exception = handle_callback_exception\n        with NullContext():\n            # remove the test StackContext that would see this uncaught\n            # exception as a test failure.\n            self.io_loop.add_callback(lambda: 1 / 0)\n        self.wait()",
        "begin_line": 161,
        "end_line": 172,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.handle_callback_exception#164",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.handle_callback_exception(callback)",
        "snippet": "        def handle_callback_exception(callback):\n            self.assertIs(sys.exc_info()[0], ZeroDivisionError)\n            self.stop()",
        "begin_line": 164,
        "end_line": 166,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_read_while_writeable#175",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_read_while_writeable(self)",
        "snippet": "    def test_read_while_writeable(self):\n        # Ensure that write events don't come in while we're waiting for\n        # a read and haven't asked for writeability. (the reverse is\n        # difficult to test for)\n        client, server = socket.socketpair()\n        try:\n            def handler(fd, events):\n                self.assertEqual(events, IOLoop.READ)\n                self.stop()\n            self.io_loop.add_handler(client.fileno(), handler, IOLoop.READ)\n            self.io_loop.add_timeout(self.io_loop.time() + 0.01,\n                                     functools.partial(server.send, b'asdf'))\n            self.wait()\n            self.io_loop.remove_handler(client.fileno())\n        finally:\n            client.close()\n            server.close()",
        "begin_line": 175,
        "end_line": 191,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.handler#181",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.handler(fd, events)",
        "snippet": "            def handler(fd, events):\n                self.assertEqual(events, IOLoop.READ)\n                self.stop()",
        "begin_line": 181,
        "end_line": 183,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_remove_timeout_after_fire#193",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_remove_timeout_after_fire(self)",
        "snippet": "    def test_remove_timeout_after_fire(self):\n        # It is not an error to call remove_timeout after it has run.\n        handle = self.io_loop.add_timeout(self.io_loop.time(), self.stop)\n        self.wait()\n        self.io_loop.remove_timeout(handle)",
        "begin_line": 193,
        "end_line": 197,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_remove_timeout_cleanup#199",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_remove_timeout_cleanup(self)",
        "snippet": "    def test_remove_timeout_cleanup(self):\n        # Add and remove enough callbacks to trigger cleanup.\n        # Not a very thorough test, but it ensures that the cleanup code\n        # gets executed and doesn't blow up.  This test is only really useful\n        # on PollIOLoop subclasses, but it should run silently on any\n        # implementation.\n        for i in range(2000):\n            timeout = self.io_loop.add_timeout(self.io_loop.time() + 3600,\n                                               lambda: None)\n            self.io_loop.remove_timeout(timeout)\n        # HACK: wait two IOLoop iterations for the GC to happen.\n        self.io_loop.add_callback(lambda: self.io_loop.add_callback(self.stop))\n        self.wait()",
        "begin_line": 199,
        "end_line": 211,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_remove_timeout_from_timeout#213",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_remove_timeout_from_timeout(self)",
        "snippet": "    def test_remove_timeout_from_timeout(self):\n        calls = [False, False]\n\n        # Schedule several callbacks and wait for them all to come due at once.\n        # t2 should be cancelled by t1, even though it is already scheduled to\n        # be run before the ioloop even looks at it.\n        now = self.io_loop.time()\n\n        def t1():\n            calls[0] = True\n            self.io_loop.remove_timeout(t2_handle)\n        self.io_loop.add_timeout(now + 0.01, t1)\n\n        def t2():\n            calls[1] = True\n        t2_handle = self.io_loop.add_timeout(now + 0.02, t2)\n        self.io_loop.add_timeout(now + 0.03, self.stop)\n        time.sleep(0.03)\n        self.wait()\n        self.assertEqual(calls, [True, False])",
        "begin_line": 213,
        "end_line": 232,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.t1#221",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.t1()",
        "snippet": "        def t1():\n            calls[0] = True\n            self.io_loop.remove_timeout(t2_handle)",
        "begin_line": 221,
        "end_line": 223,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.t2#226",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.t2()",
        "snippet": "        def t2():\n            calls[1] = True",
        "begin_line": 226,
        "end_line": 227,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_timeout_with_arguments#234",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_timeout_with_arguments(self)",
        "snippet": "    def test_timeout_with_arguments(self):\n        # This tests that all the timeout methods pass through *args correctly.\n        results = []\n        self.io_loop.add_timeout(self.io_loop.time(), results.append, 1)\n        self.io_loop.add_timeout(datetime.timedelta(seconds=0),\n                                 results.append, 2)\n        self.io_loop.call_at(self.io_loop.time(), results.append, 3)\n        self.io_loop.call_later(0, results.append, 4)\n        self.io_loop.call_later(0, self.stop)\n        self.wait()\n        self.assertEqual(results, [1, 2, 3, 4])",
        "begin_line": 234,
        "end_line": 244,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_add_timeout_return#246",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_add_timeout_return(self)",
        "snippet": "    def test_add_timeout_return(self):\n        # All the timeout methods return non-None handles that can be\n        # passed to remove_timeout.\n        handle = self.io_loop.add_timeout(self.io_loop.time(), lambda: None)\n        self.assertFalse(handle is None)\n        self.io_loop.remove_timeout(handle)",
        "begin_line": 246,
        "end_line": 251,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_call_at_return#253",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_call_at_return(self)",
        "snippet": "    def test_call_at_return(self):\n        handle = self.io_loop.call_at(self.io_loop.time(), lambda: None)\n        self.assertFalse(handle is None)\n        self.io_loop.remove_timeout(handle)",
        "begin_line": 253,
        "end_line": 256,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_call_later_return#258",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_call_later_return(self)",
        "snippet": "    def test_call_later_return(self):\n        handle = self.io_loop.call_later(0, lambda: None)\n        self.assertFalse(handle is None)\n        self.io_loop.remove_timeout(handle)",
        "begin_line": 258,
        "end_line": 261,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_close_file_object#263",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_close_file_object(self)",
        "snippet": "    def test_close_file_object(self):\n        \"\"\"When a file object is used instead of a numeric file descriptor,\n        the object should be closed (by IOLoop.close(all_fds=True),\n        not just the fd.\n        \"\"\"\n        # Use a socket since they are supported by IOLoop on all platforms.\n        # Unfortunately, sockets don't support the .closed attribute for\n        # inspecting their close status, so we must use a wrapper.\n        class SocketWrapper(object):\n            def __init__(self, sockobj):\n                self.sockobj = sockobj\n                self.closed = False\n\n            def fileno(self):\n                return self.sockobj.fileno()\n\n            def close(self):\n                self.closed = True\n                self.sockobj.close()\n        sockobj, port = bind_unused_port()\n        socket_wrapper = SocketWrapper(sockobj)\n        io_loop = IOLoop()\n        io_loop.add_handler(socket_wrapper, lambda fd, events: None,\n                            IOLoop.READ)\n        io_loop.close(all_fds=True)\n        self.assertTrue(socket_wrapper.closed)",
        "begin_line": 263,
        "end_line": 288,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.SocketWrapper.test_close_file_object#263",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.SocketWrapper",
        "signature": "tornado.test.ioloop_test.SocketWrapper.test_close_file_object(self)",
        "snippet": "    def test_close_file_object(self):\n        \"\"\"When a file object is used instead of a numeric file descriptor,\n        the object should be closed (by IOLoop.close(all_fds=True),\n        not just the fd.\n        \"\"\"\n        # Use a socket since they are supported by IOLoop on all platforms.\n        # Unfortunately, sockets don't support the .closed attribute for\n        # inspecting their close status, so we must use a wrapper.\n        class SocketWrapper(object):\n            def __init__(self, sockobj):\n                self.sockobj = sockobj\n                self.closed = False\n\n            def fileno(self):\n                return self.sockobj.fileno()\n\n            def close(self):\n                self.closed = True\n                self.sockobj.close()\n        sockobj, port = bind_unused_port()\n        socket_wrapper = SocketWrapper(sockobj)\n        io_loop = IOLoop()\n        io_loop.add_handler(socket_wrapper, lambda fd, events: None,\n                            IOLoop.READ)\n        io_loop.close(all_fds=True)\n        self.assertTrue(socket_wrapper.closed)",
        "begin_line": 263,
        "end_line": 288,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.SocketWrapper.__init__#272",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.SocketWrapper",
        "signature": "tornado.test.ioloop_test.SocketWrapper.__init__(self, sockobj)",
        "snippet": "            def __init__(self, sockobj):\n                self.sockobj = sockobj\n                self.closed = False",
        "begin_line": 272,
        "end_line": 274,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.SocketWrapper.fileno#276",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.SocketWrapper",
        "signature": "tornado.test.ioloop_test.SocketWrapper.fileno(self)",
        "snippet": "            def fileno(self):\n                return self.sockobj.fileno()",
        "begin_line": 276,
        "end_line": 277,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.SocketWrapper.close#279",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.SocketWrapper",
        "signature": "tornado.test.ioloop_test.SocketWrapper.close(self)",
        "snippet": "            def close(self):\n                self.closed = True\n                self.sockobj.close()",
        "begin_line": 279,
        "end_line": 281,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_handler_callback_file_object#290",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_handler_callback_file_object(self)",
        "snippet": "    def test_handler_callback_file_object(self):\n        \"\"\"The handler callback receives the same fd object it passed in.\"\"\"\n        server_sock, port = bind_unused_port()\n        fds = []\n\n        def handle_connection(fd, events):\n            fds.append(fd)\n            conn, addr = server_sock.accept()\n            conn.close()\n            self.stop()\n        self.io_loop.add_handler(server_sock, handle_connection, IOLoop.READ)\n        with contextlib.closing(socket.socket()) as client_sock:\n            client_sock.connect(('127.0.0.1', port))\n            self.wait()\n        self.io_loop.remove_handler(server_sock)\n        self.io_loop.add_handler(server_sock.fileno(), handle_connection,\n                                 IOLoop.READ)\n        with contextlib.closing(socket.socket()) as client_sock:\n            client_sock.connect(('127.0.0.1', port))\n            self.wait()\n        self.assertIs(fds[0], server_sock)\n        self.assertEqual(fds[1], server_sock.fileno())\n        self.io_loop.remove_handler(server_sock.fileno())\n        server_sock.close()",
        "begin_line": 290,
        "end_line": 313,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.handle_connection#295",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.handle_connection(fd, events)",
        "snippet": "        def handle_connection(fd, events):\n            fds.append(fd)\n            conn, addr = server_sock.accept()\n            conn.close()\n            self.stop()",
        "begin_line": 295,
        "end_line": 299,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_mixed_fd_fileobj#315",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_mixed_fd_fileobj(self)",
        "snippet": "    def test_mixed_fd_fileobj(self):\n        server_sock, port = bind_unused_port()\n\n        def f(fd, events):\n            pass\n        self.io_loop.add_handler(server_sock, f, IOLoop.READ)\n        with self.assertRaises(Exception):\n            # The exact error is unspecified - some implementations use\n            # IOError, others use ValueError.\n            self.io_loop.add_handler(server_sock.fileno(), f, IOLoop.READ)\n        self.io_loop.remove_handler(server_sock.fileno())\n        server_sock.close()",
        "begin_line": 315,
        "end_line": 326,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.f#318",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.f(fd, events)",
        "snippet": "        def f(fd, events):\n            pass",
        "begin_line": 318,
        "end_line": 319,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_reentrant#328",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_reentrant(self)",
        "snippet": "    def test_reentrant(self):\n        \"\"\"Calling start() twice should raise an error, not deadlock.\"\"\"\n        returned_from_start = [False]\n        got_exception = [False]\n\n        def callback():\n            try:\n                self.io_loop.start()\n                returned_from_start[0] = True\n            except Exception:\n                got_exception[0] = True\n            self.stop()\n        self.io_loop.add_callback(callback)\n        self.wait()\n        self.assertTrue(got_exception[0])\n        self.assertFalse(returned_from_start[0])",
        "begin_line": 328,
        "end_line": 343,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.callback#333",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.callback()",
        "snippet": "        def callback():\n            try:\n                self.io_loop.start()\n                returned_from_start[0] = True\n            except Exception:\n                got_exception[0] = True\n            self.stop()",
        "begin_line": 333,
        "end_line": 339,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_exception_logging#345",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_exception_logging(self)",
        "snippet": "    def test_exception_logging(self):\n        \"\"\"Uncaught exceptions get logged by the IOLoop.\"\"\"\n        # Use a NullContext to keep the exception from being caught by\n        # AsyncTestCase.\n        with NullContext():\n            self.io_loop.add_callback(lambda: 1 / 0)\n            self.io_loop.add_callback(self.stop)\n            with ExpectLog(app_log, \"Exception in callback\"):\n                self.wait()",
        "begin_line": 345,
        "end_line": 353,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_exception_logging_future#355",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_exception_logging_future(self)",
        "snippet": "    def test_exception_logging_future(self):\n        \"\"\"The IOLoop examines exceptions from Futures and logs them.\"\"\"\n        with NullContext():\n            @gen.coroutine\n            def callback():\n                self.io_loop.add_callback(self.stop)\n                1 / 0\n            self.io_loop.add_callback(callback)\n            with ExpectLog(app_log, \"Exception in callback\"):\n                self.wait()",
        "begin_line": 355,
        "end_line": 364,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.callback#359",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.callback()",
        "snippet": "            def callback():\n                self.io_loop.add_callback(self.stop)\n                1 / 0",
        "begin_line": 359,
        "end_line": 361,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_spawn_callback#366",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_spawn_callback(self)",
        "snippet": "    def test_spawn_callback(self):\n        # An added callback runs in the test's stack_context, so will be\n        # re-arised in wait().\n        self.io_loop.add_callback(lambda: 1 / 0)\n        with self.assertRaises(ZeroDivisionError):\n            self.wait()\n        # A spawned callback is run directly on the IOLoop, so it will be\n        # logged without stopping the test.\n        self.io_loop.spawn_callback(lambda: 1 / 0)\n        self.io_loop.add_callback(self.stop)\n        with ExpectLog(app_log, \"Exception in callback\"):\n            self.wait()",
        "begin_line": 366,
        "end_line": 377,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_remove_handler_from_handler#380",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_remove_handler_from_handler(self)",
        "snippet": "    def test_remove_handler_from_handler(self):\n        # Create two sockets with simultaneous read events.\n        client, server = socket.socketpair()\n        try:\n            client.send(b'abc')\n            server.send(b'abc')\n\n            # After reading from one fd, remove the other from the IOLoop.\n            chunks = []\n\n            def handle_read(fd, events):\n                chunks.append(fd.recv(1024))\n                if fd is client:\n                    self.io_loop.remove_handler(server)\n                else:\n                    self.io_loop.remove_handler(client)\n            self.io_loop.add_handler(client, handle_read, self.io_loop.READ)\n            self.io_loop.add_handler(server, handle_read, self.io_loop.READ)\n            self.io_loop.call_later(0.03, self.stop)\n            self.wait()\n\n            # Only one fd was read; the other was cleanly removed.\n            self.assertEqual(chunks, [b'abc'])\n        finally:\n            client.close()\n            server.close()",
        "begin_line": 380,
        "end_line": 405,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.handle_read#390",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.handle_read(fd, events)",
        "snippet": "            def handle_read(fd, events):\n                chunks.append(fd.recv(1024))\n                if fd is client:\n                    self.io_loop.remove_handler(server)\n                else:\n                    self.io_loop.remove_handler(client)",
        "begin_line": 390,
        "end_line": 395,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopCurrent.setUp#411",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopCurrent",
        "signature": "tornado.test.ioloop_test.TestIOLoopCurrent.setUp(self)",
        "snippet": "    def setUp(self):\n        self.io_loop = None\n        IOLoop.clear_current()",
        "begin_line": 411,
        "end_line": 413,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopCurrent.tearDown#415",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopCurrent",
        "signature": "tornado.test.ioloop_test.TestIOLoopCurrent.tearDown(self)",
        "snippet": "    def tearDown(self):\n        if self.io_loop is not None:\n            self.io_loop.close()",
        "begin_line": 415,
        "end_line": 417,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopCurrent.test_default_current#419",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopCurrent",
        "signature": "tornado.test.ioloop_test.TestIOLoopCurrent.test_default_current(self)",
        "snippet": "    def test_default_current(self):\n        self.io_loop = IOLoop()\n        # The first IOLoop with default arguments is made current.\n        self.assertIs(self.io_loop, IOLoop.current())\n        # A second IOLoop can be created but is not made current.\n        io_loop2 = IOLoop()\n        self.assertIs(self.io_loop, IOLoop.current())\n        io_loop2.close()",
        "begin_line": 419,
        "end_line": 426,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopCurrent.test_non_current#428",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopCurrent",
        "signature": "tornado.test.ioloop_test.TestIOLoopCurrent.test_non_current(self)",
        "snippet": "    def test_non_current(self):\n        self.io_loop = IOLoop(make_current=False)\n        # The new IOLoop is not initially made current.\n        self.assertIsNone(IOLoop.current(instance=False))\n        def f():\n            # But it is current after it is started.\n            self.current_io_loop = IOLoop.current()\n            self.io_loop.stop()\n        self.io_loop.add_callback(f)\n        self.io_loop.start()\n        self.assertIs(self.current_io_loop, self.io_loop)\n        # Now that the loop is stopped, it is no longer current.\n        self.assertIsNone(IOLoop.current(instance=False))",
        "begin_line": 428,
        "end_line": 440,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopCurrent.f#432",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopCurrent",
        "signature": "tornado.test.ioloop_test.TestIOLoopCurrent.f()",
        "snippet": "        def f():\n            # But it is current after it is started.\n            self.current_io_loop = IOLoop.current()\n            self.io_loop.stop()",
        "begin_line": 432,
        "end_line": 435,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopCurrent.test_force_current#442",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopCurrent",
        "signature": "tornado.test.ioloop_test.TestIOLoopCurrent.test_force_current(self)",
        "snippet": "    def test_force_current(self):\n        self.io_loop = IOLoop(make_current=True)\n        self.assertIs(self.io_loop, IOLoop.current())\n        with self.assertRaises(RuntimeError):\n            # A second make_current=True construction cannot succeed.\n            IOLoop(make_current=True)\n        # current() was not affected by the failed construction.\n        self.assertIs(self.io_loop, IOLoop.current())",
        "begin_line": 442,
        "end_line": 449,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallback.setUp#453",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallback",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallback.setUp(self)",
        "snippet": "    def setUp(self):\n        super(TestIOLoopAddCallback, self).setUp()\n        self.active_contexts = []",
        "begin_line": 453,
        "end_line": 455,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallback.add_callback#457",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallback",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallback.add_callback(self, callback, *args, **kwargs)",
        "snippet": "    def add_callback(self, callback, *args, **kwargs):\n        self.io_loop.add_callback(callback, *args, **kwargs)",
        "begin_line": 457,
        "end_line": 458,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallback.context#461",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallback",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallback.context(self, name)",
        "snippet": "    def context(self, name):\n        self.active_contexts.append(name)\n        yield\n        self.assertEqual(self.active_contexts.pop(), name)",
        "begin_line": 461,
        "end_line": 464,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallback.test_pre_wrap#466",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallback",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallback.test_pre_wrap(self)",
        "snippet": "    def test_pre_wrap(self):\n        # A pre-wrapped callback is run in the context in which it was\n        # wrapped, not when it was added to the IOLoop.\n        def f1():\n            self.assertIn('c1', self.active_contexts)\n            self.assertNotIn('c2', self.active_contexts)\n            self.stop()\n\n        with StackContext(functools.partial(self.context, 'c1')):\n            wrapped = wrap(f1)\n\n        with StackContext(functools.partial(self.context, 'c2')):\n            self.add_callback(wrapped)\n\n        self.wait()",
        "begin_line": 466,
        "end_line": 480,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallback.f1#469",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallback",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallback.f1()",
        "snippet": "        def f1():\n            self.assertIn('c1', self.active_contexts)\n            self.assertNotIn('c2', self.active_contexts)\n            self.stop()",
        "begin_line": 469,
        "end_line": 472,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallback.test_pre_wrap_with_args#482",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallback",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallback.test_pre_wrap_with_args(self)",
        "snippet": "    def test_pre_wrap_with_args(self):\n        # Same as test_pre_wrap, but the function takes arguments.\n        # Implementation note: The function must not be wrapped in a\n        # functools.partial until after it has been passed through\n        # stack_context.wrap\n        def f1(foo, bar):\n            self.assertIn('c1', self.active_contexts)\n            self.assertNotIn('c2', self.active_contexts)\n            self.stop((foo, bar))\n\n        with StackContext(functools.partial(self.context, 'c1')):\n            wrapped = wrap(f1)\n\n        with StackContext(functools.partial(self.context, 'c2')):\n            self.add_callback(wrapped, 1, bar=2)\n\n        result = self.wait()\n        self.assertEqual(result, (1, 2))",
        "begin_line": 482,
        "end_line": 499,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallback.f1#487",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallback",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallback.f1(foo, bar)",
        "snippet": "        def f1(foo, bar):\n            self.assertIn('c1', self.active_contexts)\n            self.assertNotIn('c2', self.active_contexts)\n            self.stop((foo, bar))",
        "begin_line": 487,
        "end_line": 490,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallbackFromSignal.add_callback#504",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallbackFromSignal",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallbackFromSignal.add_callback(self, callback, *args, **kwargs)",
        "snippet": "    def add_callback(self, callback, *args, **kwargs):\n        self.io_loop.add_callback_from_signal(callback, *args, **kwargs)",
        "begin_line": 504,
        "end_line": 505,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.test_add_future_threads#510",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.test_add_future_threads(self)",
        "snippet": "    def test_add_future_threads(self):\n        with futures.ThreadPoolExecutor(1) as pool:\n            self.io_loop.add_future(pool.submit(lambda: None),\n                                    lambda future: self.stop(future))\n            future = self.wait()\n            self.assertTrue(future.done())\n            self.assertTrue(future.result() is None)",
        "begin_line": 510,
        "end_line": 516,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.test_add_future_stack_context#518",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.test_add_future_stack_context(self)",
        "snippet": "    def test_add_future_stack_context(self):\n        ready = threading.Event()\n\n        def task():\n            # we must wait for the ioloop callback to be scheduled before\n            # the task completes to ensure that add_future adds the callback\n            # asynchronously (which is the scenario in which capturing\n            # the stack_context matters)\n            ready.wait(1)\n            assert ready.isSet(), \"timed out\"\n            raise Exception(\"worker\")\n\n        def callback(future):\n            self.future = future\n            raise Exception(\"callback\")\n\n        def handle_exception(typ, value, traceback):\n            self.exception = value\n            self.stop()\n            return True\n\n        # stack_context propagates to the ioloop callback, but the worker\n        # task just has its exceptions caught and saved in the Future.\n        with futures.ThreadPoolExecutor(1) as pool:\n            with ExceptionStackContext(handle_exception):\n                self.io_loop.add_future(pool.submit(task), callback)\n            ready.set()\n        self.wait()\n\n        self.assertEqual(self.exception.args[0], \"callback\")\n        self.assertEqual(self.future.exception().args[0], \"worker\")",
        "begin_line": 518,
        "end_line": 548,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.task#521",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.task()",
        "snippet": "        def task():\n            # we must wait for the ioloop callback to be scheduled before\n            # the task completes to ensure that add_future adds the callback\n            # asynchronously (which is the scenario in which capturing\n            # the stack_context matters)\n            ready.wait(1)\n            assert ready.isSet(), \"timed out\"\n            raise Exception(\"worker\")",
        "begin_line": 521,
        "end_line": 528,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.callback#530",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.callback(future)",
        "snippet": "        def callback(future):\n            self.future = future\n            raise Exception(\"callback\")",
        "begin_line": 530,
        "end_line": 532,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.handle_exception#534",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.handle_exception(typ, value, traceback)",
        "snippet": "        def handle_exception(typ, value, traceback):\n            self.exception = value\n            self.stop()\n            return True",
        "begin_line": 534,
        "end_line": 537,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.setUp#552",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.setUp(self)",
        "snippet": "    def setUp(self):\n        self.io_loop = IOLoop()",
        "begin_line": 552,
        "end_line": 553,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.tearDown#555",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.tearDown(self)",
        "snippet": "    def tearDown(self):\n        self.io_loop.close()",
        "begin_line": 555,
        "end_line": 556,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.test_sync_result#558",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.test_sync_result(self)",
        "snippet": "    def test_sync_result(self):\n        self.assertEqual(self.io_loop.run_sync(lambda: 42), 42)",
        "begin_line": 558,
        "end_line": 559,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.test_sync_exception#561",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.test_sync_exception(self)",
        "snippet": "    def test_sync_exception(self):\n        with self.assertRaises(ZeroDivisionError):\n            self.io_loop.run_sync(lambda: 1 / 0)",
        "begin_line": 561,
        "end_line": 563,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.test_async_result#565",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.test_async_result(self)",
        "snippet": "    def test_async_result(self):\n        @gen.coroutine\n        def f():\n            yield gen.Task(self.io_loop.add_callback)\n            raise gen.Return(42)\n        self.assertEqual(self.io_loop.run_sync(f), 42)",
        "begin_line": 565,
        "end_line": 570,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.f#567",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.f()",
        "snippet": "        def f():\n            yield gen.Task(self.io_loop.add_callback)\n            raise gen.Return(42)",
        "begin_line": 567,
        "end_line": 569,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.test_async_exception#572",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.test_async_exception(self)",
        "snippet": "    def test_async_exception(self):\n        @gen.coroutine\n        def f():\n            yield gen.Task(self.io_loop.add_callback)\n            1 / 0\n        with self.assertRaises(ZeroDivisionError):\n            self.io_loop.run_sync(f)",
        "begin_line": 572,
        "end_line": 578,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.f#574",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.f()",
        "snippet": "        def f():\n            yield gen.Task(self.io_loop.add_callback)\n            1 / 0",
        "begin_line": 574,
        "end_line": 576,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.test_current#580",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.test_current(self)",
        "snippet": "    def test_current(self):\n        def f():\n            self.assertIs(IOLoop.current(), self.io_loop)\n        self.io_loop.run_sync(f)",
        "begin_line": 580,
        "end_line": 583,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.f#581",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.f()",
        "snippet": "        def f():\n            self.assertIs(IOLoop.current(), self.io_loop)",
        "begin_line": 581,
        "end_line": 582,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.test_timeout#585",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.test_timeout(self)",
        "snippet": "    def test_timeout(self):\n        @gen.coroutine\n        def f():\n            yield gen.Task(self.io_loop.add_timeout, self.io_loop.time() + 1)\n        self.assertRaises(TimeoutError, self.io_loop.run_sync, f, timeout=0.01)",
        "begin_line": 585,
        "end_line": 589,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.f#587",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.f()",
        "snippet": "        def f():\n            yield gen.Task(self.io_loop.add_timeout, self.io_loop.time() + 1)",
        "begin_line": 587,
        "end_line": 588,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallback.setUp#593",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallback",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallback.setUp(self)",
        "snippet": "    def setUp(self):\n        self.io_loop = FakeTimeIOLoop()\n        self.io_loop.make_current()",
        "begin_line": 593,
        "end_line": 595,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallback.tearDown#597",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallback",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallback.tearDown(self)",
        "snippet": "    def tearDown(self):\n        self.io_loop.close()",
        "begin_line": 597,
        "end_line": 598,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallback.test_basic#600",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallback",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallback.test_basic(self)",
        "snippet": "    def test_basic(self):\n        calls = []\n\n        def cb():\n            calls.append(self.io_loop.time())\n        pc = PeriodicCallback(cb, 10000)\n        pc.start()\n        self.io_loop.call_later(50, self.io_loop.stop)\n        self.io_loop.start()\n        self.assertEqual(calls, [1010, 1020, 1030, 1040, 1050])",
        "begin_line": 600,
        "end_line": 609,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallback.cb#603",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallback",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallback.cb()",
        "snippet": "        def cb():\n            calls.append(self.io_loop.time())",
        "begin_line": 603,
        "end_line": 604,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallback.test_overrun#611",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallback",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallback.test_overrun(self)",
        "snippet": "    def test_overrun(self):\n        sleep_durations = [9, 9, 10, 11, 20, 20, 35, 35, 0, 0]\n        expected = [\n            1010, 1020, 1030,  # first 3 calls on schedule\n            1050, 1070,  # next 2 delayed one cycle\n            1100, 1130,  # next 2 delayed 2 cycles\n            1170, 1210,  # next 2 delayed 3 cycles\n            1220, 1230,  # then back on schedule.\n        ]\n        calls = []\n\n        def cb():\n            calls.append(self.io_loop.time())\n            if not sleep_durations:\n                self.io_loop.stop()\n                return\n            self.io_loop.sleep(sleep_durations.pop(0))\n        pc = PeriodicCallback(cb, 10000)\n        pc.start()\n        self.io_loop.start()\n        self.assertEqual(calls, expected)",
        "begin_line": 611,
        "end_line": 631,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallback.cb#622",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallback",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallback.cb()",
        "snippet": "        def cb():\n            calls.append(self.io_loop.time())\n            if not sleep_durations:\n                self.io_loop.stop()\n                return\n            self.io_loop.sleep(sleep_durations.pop(0))",
        "begin_line": 622,
        "end_line": 627,
        "comment": "",
        "is_bug": false
    }
]