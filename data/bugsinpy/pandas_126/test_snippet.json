[
    {
        "name": "pandas.tests.frame.conftest.float_frame_with_na#9",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.float_frame_with_na()",
        "snippet": "def float_frame_with_na():\n    \"\"\"\n    Fixture for DataFrame of floats with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D']; some entries are missing\n\n                       A         B         C         D\n    ABwBzA0ljw -1.128865 -0.897161  0.046603  0.274997\n    DJiRzmbyQF  0.728869  0.233502  0.722431 -0.890872\n    neMgPD5UBF  0.486072 -1.027393 -0.031553  1.449522\n    0yWA4n8VeX -1.937191 -1.142531  0.805215 -0.462018\n    3slYUbbqU1  0.153260  1.164691  1.489795 -0.545826\n    soujjZ0A08       NaN       NaN       NaN       NaN\n    7W6NLGsjB9       NaN       NaN       NaN       NaN\n    ...              ...       ...       ...       ...\n    uhfeaNkCR1 -0.231210 -0.340472  0.244717 -0.901590\n    n6p7GYuBIV -0.419052  1.922721 -0.125361 -0.727717\n    ZhzAeY6p1y  1.234374 -1.425359 -0.827038 -0.633189\n    uWdPsORyUh  0.046738 -0.980445 -1.102965  0.605503\n    3DJA6aN590 -0.091018 -1.684734 -1.100900  0.215947\n    2GBPAzdbMk -2.883405 -1.021071  1.209877  1.633083\n    sHadBoyVHw -2.223032 -0.326384  0.258931  0.245517\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData())\n    # set some NAs\n    df.loc[5:10] = np.nan\n    df.loc[15:20, -2:] = np.nan\n    return df",
        "begin_line": 9,
        "end_line": 38,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.bool_frame_with_na#42",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.bool_frame_with_na()",
        "snippet": "def bool_frame_with_na():\n    \"\"\"\n    Fixture for DataFrame of booleans with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D']; some entries are missing\n\n                    A      B      C      D\n    zBZxY2IDGd  False  False  False  False\n    IhBWBMWllt  False   True   True   True\n    ctjdvZSR6R   True  False   True   True\n    AVTujptmxb  False   True  False   True\n    G9lrImrSWq  False  False  False   True\n    sFFwdIUfz2    NaN    NaN    NaN    NaN\n    s15ptEJnRb    NaN    NaN    NaN    NaN\n    ...           ...    ...    ...    ...\n    UW41KkDyZ4   True   True  False  False\n    l9l6XkOdqV   True  False  False  False\n    X2MeZfzDYA  False   True  False  False\n    xWkIKU7vfX  False   True  False   True\n    QOhL6VmpGU  False  False  False   True\n    22PwkRJdat  False   True  False  False\n    kfboQ3VeIK   True  False   True  False\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData()) > 0\n    df = df.astype(object)\n    # set some NAs\n    df.loc[5:10] = np.nan\n    df.loc[15:20, -2:] = np.nan\n    return df",
        "begin_line": 42,
        "end_line": 72,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.int_frame#76",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.int_frame()",
        "snippet": "def int_frame():\n    \"\"\"\n    Fixture for DataFrame of ints with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D']\n\n                A  B  C  D\n    vpBeWjM651  1  0  1  0\n    5JyxmrP1En -1  0  0  0\n    qEDaoD49U2 -1  1  0  0\n    m66TkTfsFe  0  0  0  0\n    EHPaNzEUFm -1  0 -1  0\n    fpRJCevQhi  2  0  0  0\n    OlQvnmfi3Q  0  0 -2  0\n    ...        .. .. .. ..\n    uB1FPlz4uP  0  0  0  1\n    EcSe6yNzCU  0  0 -1  0\n    L50VudaiI8 -1  1 -2  0\n    y3bpw4nwIp  0 -1  0  0\n    H0RdLLwrCT  1  1  0  0\n    rY82K0vMwm  0  0  0  0\n    1OPIUjnkjk  2  0  0  0\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame({k: v.astype(int) for k, v in tm.getSeriesData().items()})\n    # force these all to int64 to avoid platform testing issues\n    return DataFrame({c: s for c, s in df.items()}, dtype=np.int64)",
        "begin_line": 76,
        "end_line": 103,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.datetime_frame#107",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.datetime_frame()",
        "snippet": "def datetime_frame():\n    \"\"\"\n    Fixture for DataFrame of floats with DatetimeIndex\n\n    Columns are ['A', 'B', 'C', 'D']\n\n                       A         B         C         D\n    2000-01-03 -1.122153  0.468535  0.122226  1.693711\n    2000-01-04  0.189378  0.486100  0.007864 -1.216052\n    2000-01-05  0.041401 -0.835752 -0.035279 -0.414357\n    2000-01-06  0.430050  0.894352  0.090719  0.036939\n    2000-01-07 -0.620982 -0.668211 -0.706153  1.466335\n    2000-01-10 -0.752633  0.328434 -0.815325  0.699674\n    2000-01-11 -2.236969  0.615737 -0.829076 -1.196106\n    ...              ...       ...       ...       ...\n    2000-02-03  1.642618 -0.579288  0.046005  1.385249\n    2000-02-04 -0.544873 -1.160962 -0.284071 -1.418351\n    2000-02-07 -2.656149 -0.601387  1.410148  0.444150\n    2000-02-08 -1.201881 -1.289040  0.772992 -1.445300\n    2000-02-09  1.377373  0.398619  1.008453 -0.928207\n    2000-02-10  0.473194 -0.636677  0.984058  0.511519\n    2000-02-11 -0.965556  0.408313 -1.312844 -0.381948\n\n    [30 rows x 4 columns]\n    \"\"\"\n    return DataFrame(tm.getTimeSeriesData())",
        "begin_line": 107,
        "end_line": 132,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.float_string_frame#136",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.float_string_frame()",
        "snippet": "def float_string_frame():\n    \"\"\"\n    Fixture for DataFrame of floats and strings with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D', 'foo'].\n\n                       A         B         C         D  foo\n    w3orJvq07g -1.594062 -1.084273 -1.252457  0.356460  bar\n    PeukuVdmz2  0.109855 -0.955086 -0.809485  0.409747  bar\n    ahp2KvwiM8 -1.533729 -0.142519 -0.154666  1.302623  bar\n    3WSJ7BUCGd  2.484964  0.213829  0.034778 -2.327831  bar\n    khdAmufk0U -0.193480 -0.743518 -0.077987  0.153646  bar\n    LE2DZiFlrE -0.193566 -1.343194 -0.107321  0.959978  bar\n    HJXSJhVn7b  0.142590  1.257603 -0.659409 -0.223844  bar\n    ...              ...       ...       ...       ...  ...\n    9a1Vypttgw -1.316394  1.601354  0.173596  1.213196  bar\n    h5d1gVFbEy  0.609475  1.106738 -0.155271  0.294630  bar\n    mK9LsTQG92  1.303613  0.857040 -1.019153  0.369468  bar\n    oOLksd9gKH  0.558219 -0.134491 -0.289869 -0.951033  bar\n    9jgoOjKyHg  0.058270 -0.496110 -0.413212 -0.852659  bar\n    jZLDHclHAO  0.096298  1.267510  0.549206 -0.005235  bar\n    lR0nxDp1C2 -2.119350 -0.794384  0.544118  0.145849  bar\n\n    [30 rows x 5 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData())\n    df[\"foo\"] = \"bar\"\n    return df",
        "begin_line": 136,
        "end_line": 163,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.mixed_float_frame#167",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.mixed_float_frame()",
        "snippet": "def mixed_float_frame():\n    \"\"\"\n    Fixture for DataFrame of different float types with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D'].\n\n                       A         B         C         D\n    GI7bbDaEZe -0.237908 -0.246225 -0.468506  0.752993\n    KGp9mFepzA -1.140809 -0.644046 -1.225586  0.801588\n    VeVYLAb1l2 -1.154013 -1.677615  0.690430 -0.003731\n    kmPME4WKhO  0.979578  0.998274 -0.776367  0.897607\n    CPyopdXTiz  0.048119 -0.257174  0.836426  0.111266\n    0kJZQndAj0  0.274357 -0.281135 -0.344238  0.834541\n    tqdwQsaHG8 -0.979716 -0.519897  0.582031  0.144710\n    ...              ...       ...       ...       ...\n    7FhZTWILQj -2.906357  1.261039 -0.780273 -0.537237\n    4pUDPM4eGq -2.042512 -0.464382 -0.382080  1.132612\n    B8dUgUzwTi -1.506637 -0.364435  1.087891  0.297653\n    hErlVYjVv9  1.477453 -0.495515 -0.713867  1.438427\n    1BKN3o7YLs  0.127535 -0.349812 -0.881836  0.489827\n    9S4Ekn7zga  1.445518 -2.095149  0.031982  0.373204\n    xN1dNn6OV6  1.425017 -0.983995 -0.363281 -0.224502\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData())\n    df.A = df.A.astype(\"float32\")\n    df.B = df.B.astype(\"float32\")\n    df.C = df.C.astype(\"float16\")\n    df.D = df.D.astype(\"float64\")\n    return df",
        "begin_line": 167,
        "end_line": 197,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.mixed_int_frame#201",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.mixed_int_frame()",
        "snippet": "def mixed_int_frame():\n    \"\"\"\n    Fixture for DataFrame of different int types with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D'].\n\n                A  B    C    D\n    mUrCZ67juP  0  1    2    2\n    rw99ACYaKS  0  1    0    0\n    7QsEcpaaVU  0  1    1    1\n    xkrimI2pcE  0  1    0    0\n    dz01SuzoS8  0  1  255  255\n    ccQkqOHX75 -1  1    0    0\n    DN0iXaoDLd  0  1    0    0\n    ...        .. ..  ...  ...\n    Dfb141wAaQ  1  1  254  254\n    IPD8eQOVu5  0  1    0    0\n    CcaKulsCmv  0  1    0    0\n    rIBa8gu7E5  0  1    0    0\n    RP6peZmh5o  0  1    1    1\n    NMb9pipQWQ  0  1    0    0\n    PqgbJEzjib  0  1    3    3\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame({k: v.astype(int) for k, v in tm.getSeriesData().items()})\n    df.A = df.A.astype(\"int32\")\n    df.B = np.ones(len(df.B), dtype=\"uint64\")\n    df.C = df.C.astype(\"uint8\")\n    df.D = df.C.astype(\"int64\")\n    return df",
        "begin_line": 201,
        "end_line": 231,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.mixed_type_frame#235",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.mixed_type_frame()",
        "snippet": "def mixed_type_frame():\n    \"\"\"\n    Fixture for DataFrame of float/int/string columns with RangeIndex\n    Columns are ['a', 'b', 'c', 'float32', 'int32'].\n    \"\"\"\n    return DataFrame(\n        {\n            \"a\": 1.0,\n            \"b\": 2,\n            \"c\": \"foo\",\n            \"float32\": np.array([1.0] * 10, dtype=\"float32\"),\n            \"int32\": np.array([1] * 10, dtype=\"int32\"),\n        },\n        index=np.arange(10),\n    )",
        "begin_line": 235,
        "end_line": 249,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.timezone_frame#253",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.timezone_frame()",
        "snippet": "def timezone_frame():\n    \"\"\"\n    Fixture for DataFrame of date_range Series with different time zones\n\n    Columns are ['A', 'B', 'C']; some entries are missing\n\n               A                         B                         C\n    0 2013-01-01 2013-01-01 00:00:00-05:00 2013-01-01 00:00:00+01:00\n    1 2013-01-02                       NaT                       NaT\n    2 2013-01-03 2013-01-03 00:00:00-05:00 2013-01-03 00:00:00+01:00\n    \"\"\"\n    df = DataFrame(\n        {\n            \"A\": date_range(\"20130101\", periods=3),\n            \"B\": date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n            \"C\": date_range(\"20130101\", periods=3, tz=\"CET\"),\n        }\n    )\n    df.iloc[1, 1] = NaT\n    df.iloc[1, 2] = NaT\n    return df",
        "begin_line": 253,
        "end_line": 273,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.uint64_frame#277",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.uint64_frame()",
        "snippet": "def uint64_frame():\n    \"\"\"\n    Fixture for DataFrame with uint64 values\n\n    Columns are ['A', 'B']\n    \"\"\"\n    return DataFrame(\n        {\"A\": np.arange(3), \"B\": [2 ** 63, 2 ** 63 + 5, 2 ** 63 + 10]}, dtype=np.uint64\n    )",
        "begin_line": 277,
        "end_line": 285,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.simple_frame#289",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.simple_frame()",
        "snippet": "def simple_frame():\n    \"\"\"\n    Fixture for simple 3x3 DataFrame\n\n    Columns are ['one', 'two', 'three'], index is ['a', 'b', 'c'].\n\n       one  two  three\n    a  1.0  2.0    3.0\n    b  4.0  5.0    6.0\n    c  7.0  8.0    9.0\n    \"\"\"\n    arr = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])\n\n    return DataFrame(arr, columns=[\"one\", \"two\", \"three\"], index=[\"a\", \"b\", \"c\"])",
        "begin_line": 289,
        "end_line": 302,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.frame_of_index_cols#306",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.frame_of_index_cols()",
        "snippet": "def frame_of_index_cols():\n    \"\"\"\n    Fixture for DataFrame of columns that can be used for indexing\n\n    Columns are ['A', 'B', 'C', 'D', 'E', ('tuple', 'as', 'label')];\n    'A' & 'B' contain duplicates (but are jointly unique), the rest are unique.\n\n         A      B  C         D         E  (tuple, as, label)\n    0  foo    one  a  0.608477 -0.012500           -1.664297\n    1  foo    two  b -0.633460  0.249614           -0.364411\n    2  foo  three  c  0.615256  2.154968           -0.834666\n    3  bar    one  d  0.234246  1.085675            0.718445\n    4  bar    two  e  0.533841 -0.005702           -3.533912\n    \"\"\"\n    df = DataFrame(\n        {\n            \"A\": [\"foo\", \"foo\", \"foo\", \"bar\", \"bar\"],\n            \"B\": [\"one\", \"two\", \"three\", \"one\", \"two\"],\n            \"C\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n            \"D\": np.random.randn(5),\n            \"E\": np.random.randn(5),\n            (\"tuple\", \"as\", \"label\"): np.random.randn(5),\n        }\n    )\n    return df",
        "begin_line": 306,
        "end_line": 330,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_concat_multiple_frames_dtypes#12",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_concat_multiple_frames_dtypes(self)",
        "snippet": "    def test_concat_multiple_frames_dtypes(self):\n\n        # GH 2759\n        A = DataFrame(data=np.ones((10, 2)), columns=[\"foo\", \"bar\"], dtype=np.float64)\n        B = DataFrame(data=np.ones((10, 2)), dtype=np.float32)\n        results = pd.concat((A, B), axis=1).dtypes\n        expected = Series(\n            [np.dtype(\"float64\")] * 2 + [np.dtype(\"float32\")] * 2,\n            index=[\"foo\", \"bar\", 0, 1],\n        )\n        tm.assert_series_equal(results, expected)",
        "begin_line": 12,
        "end_line": 22,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_combine_datetlike_udf#33",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_combine_datetlike_udf(self, data)",
        "snippet": "    def test_combine_datetlike_udf(self, data):\n        # https://github.com/pandas-dev/pandas/issues/23079\n        df = pd.DataFrame({\"A\": data})\n        other = df.copy()\n        df.iloc[1, 0] = None\n\n        def combiner(a, b):\n            return b\n\n        result = df.combine(other, combiner)\n        tm.assert_frame_equal(result, other)",
        "begin_line": 33,
        "end_line": 43,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.combiner#39",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.combiner(a, b)",
        "snippet": "        def combiner(a, b):\n            return b",
        "begin_line": 39,
        "end_line": 40,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_concat_multiple_tzs#45",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_concat_multiple_tzs(self)",
        "snippet": "    def test_concat_multiple_tzs(self):\n        # GH 12467\n        # combining datetime tz-aware and naive DataFrames\n        ts1 = Timestamp(\"2015-01-01\", tz=None)\n        ts2 = Timestamp(\"2015-01-01\", tz=\"UTC\")\n        ts3 = Timestamp(\"2015-01-01\", tz=\"EST\")\n\n        df1 = DataFrame(dict(time=[ts1]))\n        df2 = DataFrame(dict(time=[ts2]))\n        df3 = DataFrame(dict(time=[ts3]))\n\n        results = pd.concat([df1, df2]).reset_index(drop=True)\n        expected = DataFrame(dict(time=[ts1, ts2]), dtype=object)\n        tm.assert_frame_equal(results, expected)\n\n        results = pd.concat([df1, df3]).reset_index(drop=True)\n        expected = DataFrame(dict(time=[ts1, ts3]), dtype=object)\n        tm.assert_frame_equal(results, expected)\n\n        results = pd.concat([df2, df3]).reset_index(drop=True)\n        expected = DataFrame(dict(time=[ts2, ts3]))\n        tm.assert_frame_equal(results, expected)",
        "begin_line": 45,
        "end_line": 66,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_concat_tz_NaT#80",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_concat_tz_NaT(self, t1)",
        "snippet": "    def test_concat_tz_NaT(self, t1):\n        # GH 22796\n        # Concating tz-aware multicolumn DataFrames\n        ts1 = Timestamp(t1, tz=\"UTC\")\n        ts2 = Timestamp(\"2015-01-01\", tz=\"UTC\")\n        ts3 = Timestamp(\"2015-01-01\", tz=\"UTC\")\n\n        df1 = DataFrame([[ts1, ts2]])\n        df2 = DataFrame([[ts3]])\n\n        result = pd.concat([df1, df2])\n        expected = DataFrame([[ts1, ts2], [ts3, pd.NaT]], index=[0, 0])\n\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 80,
        "end_line": 93,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_concat_tz_not_aligned#95",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_concat_tz_not_aligned(self)",
        "snippet": "    def test_concat_tz_not_aligned(self):\n        # GH 22796\n        ts = pd.to_datetime([1, 2]).tz_localize(\"UTC\")\n        a = pd.DataFrame({\"A\": ts})\n        b = pd.DataFrame({\"A\": ts, \"B\": ts})\n        result = pd.concat([a, b], sort=True, ignore_index=True)\n        expected = pd.DataFrame(\n            {\"A\": list(ts) + list(ts), \"B\": [pd.NaT, pd.NaT] + list(ts)}\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 95,
        "end_line": 104,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_concat_tuple_keys#106",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_concat_tuple_keys(self)",
        "snippet": "    def test_concat_tuple_keys(self):\n        # GH 14438\n        df1 = pd.DataFrame(np.ones((2, 2)), columns=list(\"AB\"))\n        df2 = pd.DataFrame(np.ones((3, 2)) * 2, columns=list(\"AB\"))\n        results = pd.concat((df1, df2), keys=[(\"bee\", \"bah\"), (\"bee\", \"boo\")])\n        expected = pd.DataFrame(\n            {\n                \"A\": {\n                    (\"bee\", \"bah\", 0): 1.0,\n                    (\"bee\", \"bah\", 1): 1.0,\n                    (\"bee\", \"boo\", 0): 2.0,\n                    (\"bee\", \"boo\", 1): 2.0,\n                    (\"bee\", \"boo\", 2): 2.0,\n                },\n                \"B\": {\n                    (\"bee\", \"bah\", 0): 1.0,\n                    (\"bee\", \"bah\", 1): 1.0,\n                    (\"bee\", \"boo\", 0): 2.0,\n                    (\"bee\", \"boo\", 1): 2.0,\n                    (\"bee\", \"boo\", 2): 2.0,\n                },\n            }\n        )\n        tm.assert_frame_equal(results, expected)",
        "begin_line": 106,
        "end_line": 129,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_append_empty_list#131",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_append_empty_list(self)",
        "snippet": "    def test_append_empty_list(self):\n        # GH 28769\n        df = DataFrame()\n        result = df.append([])\n        expected = df\n        tm.assert_frame_equal(result, expected)\n        assert result is not df\n\n        df = DataFrame(np.random.randn(5, 4), columns=[\"foo\", \"bar\", \"baz\", \"qux\"])\n        result = df.append([])\n        expected = df\n        tm.assert_frame_equal(result, expected)\n        assert result is not df  # .append() should return a new object",
        "begin_line": 131,
        "end_line": 143,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_append_series_dict#145",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_append_series_dict(self)",
        "snippet": "    def test_append_series_dict(self):\n        df = DataFrame(np.random.randn(5, 4), columns=[\"foo\", \"bar\", \"baz\", \"qux\"])\n\n        series = df.loc[4]\n        msg = \"Indexes have overlapping values\"\n        with pytest.raises(ValueError, match=msg):\n            df.append(series, verify_integrity=True)\n\n        series.name = None\n        msg = \"Can only append a Series if ignore_index=True\"\n        with pytest.raises(TypeError, match=msg):\n            df.append(series, verify_integrity=True)\n\n        result = df.append(series[::-1], ignore_index=True)\n        expected = df.append(\n            DataFrame({0: series[::-1]}, index=df.columns).T, ignore_index=True\n        )\n        tm.assert_frame_equal(result, expected)\n\n        # dict\n        result = df.append(series.to_dict(), ignore_index=True)\n        tm.assert_frame_equal(result, expected)\n\n        result = df.append(series[::-1][:3], ignore_index=True)\n        expected = df.append(\n            DataFrame({0: series[::-1][:3]}).T, ignore_index=True, sort=True\n        )\n        tm.assert_frame_equal(result, expected.loc[:, result.columns])\n\n        # can append when name set\n        row = df.loc[4]\n        row.name = 5\n        result = df.append(row)\n        expected = df.append(df[-1:], ignore_index=True)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 145,
        "end_line": 179,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_append_list_of_series_dicts#181",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_append_list_of_series_dicts(self)",
        "snippet": "    def test_append_list_of_series_dicts(self):\n        df = DataFrame(np.random.randn(5, 4), columns=[\"foo\", \"bar\", \"baz\", \"qux\"])\n\n        dicts = [x.to_dict() for idx, x in df.iterrows()]\n\n        result = df.append(dicts, ignore_index=True)\n        expected = df.append(df, ignore_index=True)\n        tm.assert_frame_equal(result, expected)\n\n        # different columns\n        dicts = [\n            {\"foo\": 1, \"bar\": 2, \"baz\": 3, \"peekaboo\": 4},\n            {\"foo\": 5, \"bar\": 6, \"baz\": 7, \"peekaboo\": 8},\n        ]\n        result = df.append(dicts, ignore_index=True, sort=True)\n        expected = df.append(DataFrame(dicts), ignore_index=True, sort=True)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 181,
        "end_line": 197,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_append_missing_cols#199",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_append_missing_cols(self)",
        "snippet": "    def test_append_missing_cols(self):\n        # GH22252\n        # exercise the conditional branch in append method where the data\n        # to be appended is a list and does not contain all columns that are in\n        # the target DataFrame\n        df = DataFrame(np.random.randn(5, 4), columns=[\"foo\", \"bar\", \"baz\", \"qux\"])\n\n        dicts = [{\"foo\": 9}, {\"bar\": 10}]\n        with tm.assert_produces_warning(None):\n            result = df.append(dicts, ignore_index=True, sort=True)\n\n        expected = df.append(DataFrame(dicts), ignore_index=True, sort=True)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 199,
        "end_line": 211,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_append_empty_dataframe#213",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_append_empty_dataframe(self)",
        "snippet": "    def test_append_empty_dataframe(self):\n\n        # Empty df append empty df\n        df1 = DataFrame()\n        df2 = DataFrame()\n        result = df1.append(df2)\n        expected = df1.copy()\n        tm.assert_frame_equal(result, expected)\n\n        # Non-empty df append empty df\n        df1 = DataFrame(np.random.randn(5, 2))\n        df2 = DataFrame()\n        result = df1.append(df2)\n        expected = df1.copy()\n        tm.assert_frame_equal(result, expected)\n\n        # Empty df with columns append empty df\n        df1 = DataFrame(columns=[\"bar\", \"foo\"])\n        df2 = DataFrame()\n        result = df1.append(df2)\n        expected = df1.copy()\n        tm.assert_frame_equal(result, expected)\n\n        # Non-Empty df with columns append empty df\n        df1 = DataFrame(np.random.randn(5, 2), columns=[\"bar\", \"foo\"])\n        df2 = DataFrame()\n        result = df1.append(df2)\n        expected = df1.copy()\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 213,
        "end_line": 241,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_append_dtypes#243",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_append_dtypes(self)",
        "snippet": "    def test_append_dtypes(self):\n\n        # GH 5754\n        # row appends of different dtypes (so need to do by-item)\n        # can sometimes infer the correct type\n\n        df1 = DataFrame({\"bar\": Timestamp(\"20130101\")}, index=range(5))\n        df2 = DataFrame()\n        result = df1.append(df2)\n        expected = df1.copy()\n        tm.assert_frame_equal(result, expected)\n\n        df1 = DataFrame({\"bar\": Timestamp(\"20130101\")}, index=range(1))\n        df2 = DataFrame({\"bar\": \"foo\"}, index=range(1, 2))\n        result = df1.append(df2)\n        expected = DataFrame({\"bar\": [Timestamp(\"20130101\"), \"foo\"]})\n        tm.assert_frame_equal(result, expected)\n\n        df1 = DataFrame({\"bar\": Timestamp(\"20130101\")}, index=range(1))\n        df2 = DataFrame({\"bar\": np.nan}, index=range(1, 2))\n        result = df1.append(df2)\n        expected = DataFrame(\n            {\"bar\": Series([Timestamp(\"20130101\"), np.nan], dtype=\"M8[ns]\")}\n        )\n        tm.assert_frame_equal(result, expected)\n\n        df1 = DataFrame({\"bar\": Timestamp(\"20130101\")}, index=range(1))\n        df2 = DataFrame({\"bar\": np.nan}, index=range(1, 2), dtype=object)\n        result = df1.append(df2)\n        expected = DataFrame(\n            {\"bar\": Series([Timestamp(\"20130101\"), np.nan], dtype=\"M8[ns]\")}\n        )\n        tm.assert_frame_equal(result, expected)\n\n        df1 = DataFrame({\"bar\": np.nan}, index=range(1))\n        df2 = DataFrame({\"bar\": Timestamp(\"20130101\")}, index=range(1, 2))\n        result = df1.append(df2)\n        expected = DataFrame(\n            {\"bar\": Series([np.nan, Timestamp(\"20130101\")], dtype=\"M8[ns]\")}\n        )\n        tm.assert_frame_equal(result, expected)\n\n        df1 = DataFrame({\"bar\": Timestamp(\"20130101\")}, index=range(1))\n        df2 = DataFrame({\"bar\": 1}, index=range(1, 2), dtype=object)\n        result = df1.append(df2)\n        expected = DataFrame({\"bar\": Series([Timestamp(\"20130101\"), 1])})\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 243,
        "end_line": 289,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_update#291",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_update(self)",
        "snippet": "    def test_update(self):\n        df = DataFrame(\n            [[1.5, np.nan, 3.0], [1.5, np.nan, 3.0], [1.5, np.nan, 3], [1.5, np.nan, 3]]\n        )\n\n        other = DataFrame([[3.6, 2.0, np.nan], [np.nan, np.nan, 7]], index=[1, 3])\n\n        df.update(other)\n\n        expected = DataFrame(\n            [[1.5, np.nan, 3], [3.6, 2, 3], [1.5, np.nan, 3], [1.5, np.nan, 7.0]]\n        )\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 291,
        "end_line": 303,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_update_dtypes#305",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_update_dtypes(self)",
        "snippet": "    def test_update_dtypes(self):\n\n        # gh 3016\n        df = DataFrame(\n            [[1.0, 2.0, False, True], [4.0, 5.0, True, False]],\n            columns=[\"A\", \"B\", \"bool1\", \"bool2\"],\n        )\n\n        other = DataFrame([[45, 45]], index=[0], columns=[\"A\", \"B\"])\n        df.update(other)\n\n        expected = DataFrame(\n            [[45.0, 45.0, False, True], [4.0, 5.0, True, False]],\n            columns=[\"A\", \"B\", \"bool1\", \"bool2\"],\n        )\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 305,
        "end_line": 320,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_update_nooverwrite#322",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_update_nooverwrite(self)",
        "snippet": "    def test_update_nooverwrite(self):\n        df = DataFrame(\n            [[1.5, np.nan, 3.0], [1.5, np.nan, 3.0], [1.5, np.nan, 3], [1.5, np.nan, 3]]\n        )\n\n        other = DataFrame([[3.6, 2.0, np.nan], [np.nan, np.nan, 7]], index=[1, 3])\n\n        df.update(other, overwrite=False)\n\n        expected = DataFrame(\n            [[1.5, np.nan, 3], [1.5, 2, 3], [1.5, np.nan, 3], [1.5, np.nan, 3.0]]\n        )\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 322,
        "end_line": 334,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_update_filtered#336",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_update_filtered(self)",
        "snippet": "    def test_update_filtered(self):\n        df = DataFrame(\n            [[1.5, np.nan, 3.0], [1.5, np.nan, 3.0], [1.5, np.nan, 3], [1.5, np.nan, 3]]\n        )\n\n        other = DataFrame([[3.6, 2.0, np.nan], [np.nan, np.nan, 7]], index=[1, 3])\n\n        df.update(other, filter_func=lambda x: x > 2)\n\n        expected = DataFrame(\n            [[1.5, np.nan, 3], [1.5, np.nan, 3], [1.5, np.nan, 3], [1.5, np.nan, 7.0]]\n        )\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 336,
        "end_line": 348,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_update_raise_bad_parameter#358",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_update_raise_bad_parameter(self, bad_kwarg, exception, msg)",
        "snippet": "    def test_update_raise_bad_parameter(self, bad_kwarg, exception, msg):\n        df = DataFrame([[1.5, 1, 3.0]])\n        with pytest.raises(exception, match=msg):\n            df.update(df, **bad_kwarg)",
        "begin_line": 358,
        "end_line": 361,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_update_raise_on_overlap#363",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_update_raise_on_overlap(self)",
        "snippet": "    def test_update_raise_on_overlap(self):\n        df = DataFrame(\n            [[1.5, 1, 3.0], [1.5, np.nan, 3.0], [1.5, np.nan, 3], [1.5, np.nan, 3]]\n        )\n\n        other = DataFrame([[2.0, np.nan], [np.nan, 7]], index=[1, 3], columns=[1, 2])\n        with pytest.raises(ValueError, match=\"Data overlaps\"):\n            df.update(other, errors=\"raise\")",
        "begin_line": 363,
        "end_line": 370,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_update_deprecation#373",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_update_deprecation(self, raise_conflict)",
        "snippet": "    def test_update_deprecation(self, raise_conflict):\n        df = DataFrame([[1.5, 1, 3.0]])\n        other = DataFrame()\n        with tm.assert_produces_warning(FutureWarning):\n            df.update(other, raise_conflict=raise_conflict)",
        "begin_line": 373,
        "end_line": 377,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_update_from_non_df#379",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_update_from_non_df(self)",
        "snippet": "    def test_update_from_non_df(self):\n        d = {\"a\": Series([1, 2, 3, 4]), \"b\": Series([5, 6, 7, 8])}\n        df = DataFrame(d)\n\n        d[\"a\"] = Series([5, 6, 7, 8])\n        df.update(d)\n\n        expected = DataFrame(d)\n\n        tm.assert_frame_equal(df, expected)\n\n        d = {\"a\": [1, 2, 3, 4], \"b\": [5, 6, 7, 8]}\n        df = DataFrame(d)\n\n        d[\"a\"] = [5, 6, 7, 8]\n        df.update(d)\n\n        expected = DataFrame(d)\n\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 379,
        "end_line": 398,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_update_datetime_tz#400",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_update_datetime_tz(self)",
        "snippet": "    def test_update_datetime_tz(self):\n        # GH 25807\n        result = DataFrame([pd.Timestamp(\"2019\", tz=\"UTC\")])\n        result.update(result)\n        expected = DataFrame([pd.Timestamp(\"2019\", tz=\"UTC\")])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 400,
        "end_line": 405,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_join_str_datetime#407",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_join_str_datetime(self)",
        "snippet": "    def test_join_str_datetime(self):\n        str_dates = [\"20120209\", \"20120222\"]\n        dt_dates = [datetime(2012, 2, 9), datetime(2012, 2, 22)]\n\n        A = DataFrame(str_dates, index=range(2), columns=[\"aa\"])\n        C = DataFrame([[1, 2], [3, 4]], index=str_dates, columns=dt_dates)\n\n        tst = A.join(C, on=\"aa\")\n\n        assert len(tst.columns) == 3",
        "begin_line": 407,
        "end_line": 416,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_join_multiindex_leftright#418",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_join_multiindex_leftright(self)",
        "snippet": "    def test_join_multiindex_leftright(self):\n        # GH 10741\n        df1 = pd.DataFrame(\n            [\n                [\"a\", \"x\", 0.471780],\n                [\"a\", \"y\", 0.774908],\n                [\"a\", \"z\", 0.563634],\n                [\"b\", \"x\", -0.353756],\n                [\"b\", \"y\", 0.368062],\n                [\"b\", \"z\", -1.721840],\n                [\"c\", \"x\", 1],\n                [\"c\", \"y\", 2],\n                [\"c\", \"z\", 3],\n            ],\n            columns=[\"first\", \"second\", \"value1\"],\n        ).set_index([\"first\", \"second\"])\n\n        df2 = pd.DataFrame(\n            [[\"a\", 10], [\"b\", 20]], columns=[\"first\", \"value2\"]\n        ).set_index([\"first\"])\n\n        exp = pd.DataFrame(\n            [\n                [0.471780, 10],\n                [0.774908, 10],\n                [0.563634, 10],\n                [-0.353756, 20],\n                [0.368062, 20],\n                [-1.721840, 20],\n                [1.000000, np.nan],\n                [2.000000, np.nan],\n                [3.000000, np.nan],\n            ],\n            index=df1.index,\n            columns=[\"value1\", \"value2\"],\n        )\n\n        # these must be the same results (but columns are flipped)\n        tm.assert_frame_equal(df1.join(df2, how=\"left\"), exp)\n        tm.assert_frame_equal(df2.join(df1, how=\"right\"), exp[[\"value2\", \"value1\"]])\n\n        exp_idx = pd.MultiIndex.from_product(\n            [[\"a\", \"b\"], [\"x\", \"y\", \"z\"]], names=[\"first\", \"second\"]\n        )\n        exp = pd.DataFrame(\n            [\n                [0.471780, 10],\n                [0.774908, 10],\n                [0.563634, 10],\n                [-0.353756, 20],\n                [0.368062, 20],\n                [-1.721840, 20],\n            ],\n            index=exp_idx,\n            columns=[\"value1\", \"value2\"],\n        )\n\n        tm.assert_frame_equal(df1.join(df2, how=\"right\"), exp)\n        tm.assert_frame_equal(df2.join(df1, how=\"left\"), exp[[\"value2\", \"value1\"]])",
        "begin_line": 418,
        "end_line": 476,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_concat_named_keys#478",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_concat_named_keys(self)",
        "snippet": "    def test_concat_named_keys(self):\n        # GH 14252\n        df = pd.DataFrame({\"foo\": [1, 2], \"bar\": [0.1, 0.2]})\n        index = Index([\"a\", \"b\"], name=\"baz\")\n        concatted_named_from_keys = pd.concat([df, df], keys=index)\n        expected_named = pd.DataFrame(\n            {\"foo\": [1, 2, 1, 2], \"bar\": [0.1, 0.2, 0.1, 0.2]},\n            index=pd.MultiIndex.from_product(([\"a\", \"b\"], [0, 1]), names=[\"baz\", None]),\n        )\n        tm.assert_frame_equal(concatted_named_from_keys, expected_named)\n\n        index_no_name = Index([\"a\", \"b\"], name=None)\n        concatted_named_from_names = pd.concat(\n            [df, df], keys=index_no_name, names=[\"baz\"]\n        )\n        tm.assert_frame_equal(concatted_named_from_names, expected_named)\n\n        concatted_unnamed = pd.concat([df, df], keys=index_no_name)\n        expected_unnamed = pd.DataFrame(\n            {\"foo\": [1, 2, 1, 2], \"bar\": [0.1, 0.2, 0.1, 0.2]},\n            index=pd.MultiIndex.from_product(([\"a\", \"b\"], [0, 1]), names=[None, None]),\n        )\n        tm.assert_frame_equal(concatted_unnamed, expected_unnamed)",
        "begin_line": 478,
        "end_line": 500,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_concat_axis_parameter#502",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_concat_axis_parameter(self)",
        "snippet": "    def test_concat_axis_parameter(self):\n        # GH 14369\n        df1 = pd.DataFrame({\"A\": [0.1, 0.2]}, index=range(2))\n        df2 = pd.DataFrame({\"A\": [0.3, 0.4]}, index=range(2))\n\n        # Index/row/0 DataFrame\n        expected_index = pd.DataFrame({\"A\": [0.1, 0.2, 0.3, 0.4]}, index=[0, 1, 0, 1])\n\n        concatted_index = pd.concat([df1, df2], axis=\"index\")\n        tm.assert_frame_equal(concatted_index, expected_index)\n\n        concatted_row = pd.concat([df1, df2], axis=\"rows\")\n        tm.assert_frame_equal(concatted_row, expected_index)\n\n        concatted_0 = pd.concat([df1, df2], axis=0)\n        tm.assert_frame_equal(concatted_0, expected_index)\n\n        # Columns/1 DataFrame\n        expected_columns = pd.DataFrame(\n            [[0.1, 0.3], [0.2, 0.4]], index=[0, 1], columns=[\"A\", \"A\"]\n        )\n\n        concatted_columns = pd.concat([df1, df2], axis=\"columns\")\n        tm.assert_frame_equal(concatted_columns, expected_columns)\n\n        concatted_1 = pd.concat([df1, df2], axis=1)\n        tm.assert_frame_equal(concatted_1, expected_columns)\n\n        series1 = pd.Series([0.1, 0.2])\n        series2 = pd.Series([0.3, 0.4])\n\n        # Index/row/0 Series\n        expected_index_series = pd.Series([0.1, 0.2, 0.3, 0.4], index=[0, 1, 0, 1])\n\n        concatted_index_series = pd.concat([series1, series2], axis=\"index\")\n        tm.assert_series_equal(concatted_index_series, expected_index_series)\n\n        concatted_row_series = pd.concat([series1, series2], axis=\"rows\")\n        tm.assert_series_equal(concatted_row_series, expected_index_series)\n\n        concatted_0_series = pd.concat([series1, series2], axis=0)\n        tm.assert_series_equal(concatted_0_series, expected_index_series)\n\n        # Columns/1 Series\n        expected_columns_series = pd.DataFrame(\n            [[0.1, 0.3], [0.2, 0.4]], index=[0, 1], columns=[0, 1]\n        )\n\n        concatted_columns_series = pd.concat([series1, series2], axis=\"columns\")\n        tm.assert_frame_equal(concatted_columns_series, expected_columns_series)\n\n        concatted_1_series = pd.concat([series1, series2], axis=1)\n        tm.assert_frame_equal(concatted_1_series, expected_columns_series)\n\n        # Testing ValueError\n        with pytest.raises(ValueError, match=\"No axis named\"):\n            pd.concat([series1, series2], axis=\"something\")",
        "begin_line": 502,
        "end_line": 558,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_concat_numerical_names#560",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_concat_numerical_names(self)",
        "snippet": "    def test_concat_numerical_names(self):\n        # #15262  # #12223\n        df = pd.DataFrame(\n            {\"col\": range(9)},\n            dtype=\"int32\",\n            index=(\n                pd.MultiIndex.from_product(\n                    [[\"A0\", \"A1\", \"A2\"], [\"B0\", \"B1\", \"B2\"]], names=[1, 2]\n                )\n            ),\n        )\n        result = pd.concat((df.iloc[:2, :], df.iloc[-2:, :]))\n        expected = pd.DataFrame(\n            {\"col\": [0, 1, 7, 8]},\n            dtype=\"int32\",\n            index=pd.MultiIndex.from_tuples(\n                [(\"A0\", \"B0\"), (\"A0\", \"B1\"), (\"A2\", \"B1\"), (\"A2\", \"B2\")], names=[1, 2]\n            ),\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 560,
        "end_line": 579,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_concat_astype_dup_col#581",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameConcatCommon.test_concat_astype_dup_col(self)",
        "snippet": "    def test_concat_astype_dup_col(self):\n        # gh 23049\n        df = pd.DataFrame([{\"a\": \"b\"}])\n        df = pd.concat([df, df], axis=1)\n\n        result = df.astype(\"category\")\n        expected = pd.DataFrame(\n            np.array([\"b\", \"b\"]).reshape(1, 2), columns=[\"a\", \"a\"]\n        ).astype(\"category\")\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 581,
        "end_line": 590,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst.test_combine_first_mixed#594",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst.test_combine_first_mixed(self)",
        "snippet": "    def test_combine_first_mixed(self):\n        a = Series([\"a\", \"b\"], index=range(2))\n        b = Series(range(2), index=range(2))\n        f = DataFrame({\"A\": a, \"B\": b})\n\n        a = Series([\"a\", \"b\"], index=range(5, 7))\n        b = Series(range(2), index=range(5, 7))\n        g = DataFrame({\"A\": a, \"B\": b})\n\n        exp = pd.DataFrame(\n            {\"A\": list(\"abab\"), \"B\": [0.0, 1.0, 0.0, 1.0]}, index=[0, 1, 5, 6]\n        )\n        combined = f.combine_first(g)\n        tm.assert_frame_equal(combined, exp)",
        "begin_line": 594,
        "end_line": 607,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst.test_combine_first#609",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst.test_combine_first(self, float_frame)",
        "snippet": "    def test_combine_first(self, float_frame):\n        # disjoint\n        head, tail = float_frame[:5], float_frame[5:]\n\n        combined = head.combine_first(tail)\n        reordered_frame = float_frame.reindex(combined.index)\n        tm.assert_frame_equal(combined, reordered_frame)\n        assert tm.equalContents(combined.columns, float_frame.columns)\n        tm.assert_series_equal(combined[\"A\"], reordered_frame[\"A\"])\n\n        # same index\n        fcopy = float_frame.copy()\n        fcopy[\"A\"] = 1\n        del fcopy[\"C\"]\n\n        fcopy2 = float_frame.copy()\n        fcopy2[\"B\"] = 0\n        del fcopy2[\"D\"]\n\n        combined = fcopy.combine_first(fcopy2)\n\n        assert (combined[\"A\"] == 1).all()\n        tm.assert_series_equal(combined[\"B\"], fcopy[\"B\"])\n        tm.assert_series_equal(combined[\"C\"], fcopy2[\"C\"])\n        tm.assert_series_equal(combined[\"D\"], fcopy[\"D\"])\n\n        # overlap\n        head, tail = reordered_frame[:10].copy(), reordered_frame\n        head[\"A\"] = 1\n\n        combined = head.combine_first(tail)\n        assert (combined[\"A\"][:10] == 1).all()\n\n        # reverse overlap\n        tail[\"A\"][:10] = 0\n        combined = tail.combine_first(head)\n        assert (combined[\"A\"][:10] == 0).all()\n\n        # no overlap\n        f = float_frame[:10]\n        g = float_frame[10:]\n        combined = f.combine_first(g)\n        tm.assert_series_equal(combined[\"A\"].reindex(f.index), f[\"A\"])\n        tm.assert_series_equal(combined[\"A\"].reindex(g.index), g[\"A\"])\n\n        # corner cases\n        comb = float_frame.combine_first(DataFrame())\n        tm.assert_frame_equal(comb, float_frame)\n\n        comb = DataFrame().combine_first(float_frame)\n        tm.assert_frame_equal(comb, float_frame)\n\n        comb = float_frame.combine_first(DataFrame(index=[\"faz\", \"boo\"]))\n        assert \"faz\" in comb.index\n\n        # #2525\n        df = DataFrame({\"a\": [1]}, index=[datetime(2012, 1, 1)])\n        df2 = DataFrame(columns=[\"b\"])\n        result = df.combine_first(df2)\n        assert \"b\" in result",
        "begin_line": 609,
        "end_line": 668,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst.test_combine_first_mixed_bug#670",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst.test_combine_first_mixed_bug(self)",
        "snippet": "    def test_combine_first_mixed_bug(self):\n        idx = Index([\"a\", \"b\", \"c\", \"e\"])\n        ser1 = Series([5.0, -9.0, 4.0, 100.0], index=idx)\n        ser2 = Series([\"a\", \"b\", \"c\", \"e\"], index=idx)\n        ser3 = Series([12, 4, 5, 97], index=idx)\n\n        frame1 = DataFrame({\"col0\": ser1, \"col2\": ser2, \"col3\": ser3})\n\n        idx = Index([\"a\", \"b\", \"c\", \"f\"])\n        ser1 = Series([5.0, -9.0, 4.0, 100.0], index=idx)\n        ser2 = Series([\"a\", \"b\", \"c\", \"f\"], index=idx)\n        ser3 = Series([12, 4, 5, 97], index=idx)\n\n        frame2 = DataFrame({\"col1\": ser1, \"col2\": ser2, \"col5\": ser3})\n\n        combined = frame1.combine_first(frame2)\n        assert len(combined.columns) == 5\n\n        # gh 3016 (same as in update)\n        df = DataFrame(\n            [[1.0, 2.0, False, True], [4.0, 5.0, True, False]],\n            columns=[\"A\", \"B\", \"bool1\", \"bool2\"],\n        )\n\n        other = DataFrame([[45, 45]], index=[0], columns=[\"A\", \"B\"])\n        result = df.combine_first(other)\n        tm.assert_frame_equal(result, df)\n\n        df.loc[0, \"A\"] = np.nan\n        result = df.combine_first(other)\n        df.loc[0, \"A\"] = 45\n        tm.assert_frame_equal(result, df)\n\n        # doc example\n        df1 = DataFrame(\n            {\"A\": [1.0, np.nan, 3.0, 5.0, np.nan], \"B\": [np.nan, 2.0, 3.0, np.nan, 6.0]}\n        )\n\n        df2 = DataFrame(\n            {\n                \"A\": [5.0, 2.0, 4.0, np.nan, 3.0, 7.0],\n                \"B\": [np.nan, np.nan, 3.0, 4.0, 6.0, 8.0],\n            }\n        )\n\n        result = df1.combine_first(df2)\n        expected = DataFrame({\"A\": [1, 2, 3, 5, 3, 7.0], \"B\": [np.nan, 2, 3, 4, 6, 8]})\n        tm.assert_frame_equal(result, expected)\n\n        # GH3552, return object dtype with bools\n        df1 = DataFrame(\n            [[np.nan, 3.0, True], [-4.6, np.nan, True], [np.nan, 7.0, False]]\n        )\n        df2 = DataFrame([[-42.6, np.nan, True], [-5.0, 1.6, False]], index=[1, 2])\n\n        result = df1.combine_first(df2)[2]\n        expected = Series([True, True, False], name=2)\n        tm.assert_series_equal(result, expected)\n\n        # GH 3593, converting datetime64[ns] incorrectly\n        df0 = DataFrame(\n            {\"a\": [datetime(2000, 1, 1), datetime(2000, 1, 2), datetime(2000, 1, 3)]}\n        )\n        df1 = DataFrame({\"a\": [None, None, None]})\n        df2 = df1.combine_first(df0)\n        tm.assert_frame_equal(df2, df0)\n\n        df2 = df0.combine_first(df1)\n        tm.assert_frame_equal(df2, df0)\n\n        df0 = DataFrame(\n            {\"a\": [datetime(2000, 1, 1), datetime(2000, 1, 2), datetime(2000, 1, 3)]}\n        )\n        df1 = DataFrame({\"a\": [datetime(2000, 1, 2), None, None]})\n        df2 = df1.combine_first(df0)\n        result = df0.copy()\n        result.iloc[0, :] = df1.iloc[0, :]\n        tm.assert_frame_equal(df2, result)\n\n        df2 = df0.combine_first(df1)\n        tm.assert_frame_equal(df2, df0)",
        "begin_line": 670,
        "end_line": 750,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst.test_combine_first_align_nan#752",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst.test_combine_first_align_nan(self)",
        "snippet": "    def test_combine_first_align_nan(self):\n        # GH 7509 (not fixed)\n        dfa = pd.DataFrame([[pd.Timestamp(\"2011-01-01\"), 2]], columns=[\"a\", \"b\"])\n        dfb = pd.DataFrame([[4], [5]], columns=[\"b\"])\n        assert dfa[\"a\"].dtype == \"datetime64[ns]\"\n        assert dfa[\"b\"].dtype == \"int64\"\n\n        res = dfa.combine_first(dfb)\n        exp = pd.DataFrame(\n            {\"a\": [pd.Timestamp(\"2011-01-01\"), pd.NaT], \"b\": [2.0, 5.0]},\n            columns=[\"a\", \"b\"],\n        )\n        tm.assert_frame_equal(res, exp)\n        assert res[\"a\"].dtype == \"datetime64[ns]\"\n        # ToDo: this must be int64\n        assert res[\"b\"].dtype == \"float64\"\n\n        res = dfa.iloc[:0].combine_first(dfb)\n        exp = pd.DataFrame({\"a\": [np.nan, np.nan], \"b\": [4, 5]}, columns=[\"a\", \"b\"])\n        tm.assert_frame_equal(res, exp)\n        # ToDo: this must be datetime64\n        assert res[\"a\"].dtype == \"float64\"\n        # ToDo: this must be int64\n        assert res[\"b\"].dtype == \"int64\"",
        "begin_line": 752,
        "end_line": 775,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst.test_combine_first_timezone#777",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst.test_combine_first_timezone(self)",
        "snippet": "    def test_combine_first_timezone(self):\n        # see gh-7630\n        data1 = pd.to_datetime(\"20100101 01:01\").tz_localize(\"UTC\")\n        df1 = pd.DataFrame(\n            columns=[\"UTCdatetime\", \"abc\"],\n            data=data1,\n            index=pd.date_range(\"20140627\", periods=1),\n        )\n        data2 = pd.to_datetime(\"20121212 12:12\").tz_localize(\"UTC\")\n        df2 = pd.DataFrame(\n            columns=[\"UTCdatetime\", \"xyz\"],\n            data=data2,\n            index=pd.date_range(\"20140628\", periods=1),\n        )\n        res = df2[[\"UTCdatetime\"]].combine_first(df1)\n        exp = pd.DataFrame(\n            {\n                \"UTCdatetime\": [\n                    pd.Timestamp(\"2010-01-01 01:01\", tz=\"UTC\"),\n                    pd.Timestamp(\"2012-12-12 12:12\", tz=\"UTC\"),\n                ],\n                \"abc\": [pd.Timestamp(\"2010-01-01 01:01:00\", tz=\"UTC\"), pd.NaT],\n            },\n            columns=[\"UTCdatetime\", \"abc\"],\n            index=pd.date_range(\"20140627\", periods=2, freq=\"D\"),\n        )\n        tm.assert_frame_equal(res, exp)\n        assert res[\"UTCdatetime\"].dtype == \"datetime64[ns, UTC]\"\n        assert res[\"abc\"].dtype == \"datetime64[ns, UTC]\"\n\n        # see gh-10567\n        dts1 = pd.date_range(\"2015-01-01\", \"2015-01-05\", tz=\"UTC\")\n        df1 = pd.DataFrame({\"DATE\": dts1})\n        dts2 = pd.date_range(\"2015-01-03\", \"2015-01-05\", tz=\"UTC\")\n        df2 = pd.DataFrame({\"DATE\": dts2})\n\n        res = df1.combine_first(df2)\n        tm.assert_frame_equal(res, df1)\n        assert res[\"DATE\"].dtype == \"datetime64[ns, UTC]\"\n\n        dts1 = pd.DatetimeIndex(\n            [\"2011-01-01\", \"NaT\", \"2011-01-03\", \"2011-01-04\"], tz=\"US/Eastern\"\n        )\n        df1 = pd.DataFrame({\"DATE\": dts1}, index=[1, 3, 5, 7])\n        dts2 = pd.DatetimeIndex(\n            [\"2012-01-01\", \"2012-01-02\", \"2012-01-03\"], tz=\"US/Eastern\"\n        )\n        df2 = pd.DataFrame({\"DATE\": dts2}, index=[2, 4, 5])\n\n        res = df1.combine_first(df2)\n        exp_dts = pd.DatetimeIndex(\n            [\n                \"2011-01-01\",\n                \"2012-01-01\",\n                \"NaT\",\n                \"2012-01-02\",\n                \"2011-01-03\",\n                \"2011-01-04\",\n            ],\n            tz=\"US/Eastern\",\n        )\n        exp = pd.DataFrame({\"DATE\": exp_dts}, index=[1, 2, 3, 4, 5, 7])\n        tm.assert_frame_equal(res, exp)\n\n        # different tz\n        dts1 = pd.date_range(\"2015-01-01\", \"2015-01-05\", tz=\"US/Eastern\")\n        df1 = pd.DataFrame({\"DATE\": dts1})\n        dts2 = pd.date_range(\"2015-01-03\", \"2015-01-05\")\n        df2 = pd.DataFrame({\"DATE\": dts2})\n\n        # if df1 doesn't have NaN, keep its dtype\n        res = df1.combine_first(df2)\n        tm.assert_frame_equal(res, df1)\n        assert res[\"DATE\"].dtype == \"datetime64[ns, US/Eastern]\"\n\n        dts1 = pd.date_range(\"2015-01-01\", \"2015-01-02\", tz=\"US/Eastern\")\n        df1 = pd.DataFrame({\"DATE\": dts1})\n        dts2 = pd.date_range(\"2015-01-01\", \"2015-01-03\")\n        df2 = pd.DataFrame({\"DATE\": dts2})\n\n        res = df1.combine_first(df2)\n        exp_dts = [\n            pd.Timestamp(\"2015-01-01\", tz=\"US/Eastern\"),\n            pd.Timestamp(\"2015-01-02\", tz=\"US/Eastern\"),\n            pd.Timestamp(\"2015-01-03\"),\n        ]\n        exp = pd.DataFrame({\"DATE\": exp_dts})\n        tm.assert_frame_equal(res, exp)\n        assert res[\"DATE\"].dtype == \"object\"",
        "begin_line": 777,
        "end_line": 865,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst.test_combine_first_timedelta#867",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst.test_combine_first_timedelta(self)",
        "snippet": "    def test_combine_first_timedelta(self):\n        data1 = pd.TimedeltaIndex([\"1 day\", \"NaT\", \"3 day\", \"4day\"])\n        df1 = pd.DataFrame({\"TD\": data1}, index=[1, 3, 5, 7])\n        data2 = pd.TimedeltaIndex([\"10 day\", \"11 day\", \"12 day\"])\n        df2 = pd.DataFrame({\"TD\": data2}, index=[2, 4, 5])\n\n        res = df1.combine_first(df2)\n        exp_dts = pd.TimedeltaIndex(\n            [\"1 day\", \"10 day\", \"NaT\", \"11 day\", \"3 day\", \"4 day\"]\n        )\n        exp = pd.DataFrame({\"TD\": exp_dts}, index=[1, 2, 3, 4, 5, 7])\n        tm.assert_frame_equal(res, exp)\n        assert res[\"TD\"].dtype == \"timedelta64[ns]\"",
        "begin_line": 867,
        "end_line": 879,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst.test_combine_first_period#881",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst.test_combine_first_period(self)",
        "snippet": "    def test_combine_first_period(self):\n        data1 = pd.PeriodIndex([\"2011-01\", \"NaT\", \"2011-03\", \"2011-04\"], freq=\"M\")\n        df1 = pd.DataFrame({\"P\": data1}, index=[1, 3, 5, 7])\n        data2 = pd.PeriodIndex([\"2012-01-01\", \"2012-02\", \"2012-03\"], freq=\"M\")\n        df2 = pd.DataFrame({\"P\": data2}, index=[2, 4, 5])\n\n        res = df1.combine_first(df2)\n        exp_dts = pd.PeriodIndex(\n            [\"2011-01\", \"2012-01\", \"NaT\", \"2012-02\", \"2011-03\", \"2011-04\"], freq=\"M\"\n        )\n        exp = pd.DataFrame({\"P\": exp_dts}, index=[1, 2, 3, 4, 5, 7])\n        tm.assert_frame_equal(res, exp)\n        assert res[\"P\"].dtype == data1.dtype\n\n        # different freq\n        dts2 = pd.PeriodIndex([\"2012-01-01\", \"2012-01-02\", \"2012-01-03\"], freq=\"D\")\n        df2 = pd.DataFrame({\"P\": dts2}, index=[2, 4, 5])\n\n        res = df1.combine_first(df2)\n        exp_dts = [\n            pd.Period(\"2011-01\", freq=\"M\"),\n            pd.Period(\"2012-01-01\", freq=\"D\"),\n            pd.NaT,\n            pd.Period(\"2012-01-02\", freq=\"D\"),\n            pd.Period(\"2011-03\", freq=\"M\"),\n            pd.Period(\"2011-04\", freq=\"M\"),\n        ]\n        exp = pd.DataFrame({\"P\": exp_dts}, index=[1, 2, 3, 4, 5, 7])\n        tm.assert_frame_equal(res, exp)\n        assert res[\"P\"].dtype == \"object\"",
        "begin_line": 881,
        "end_line": 910,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst.test_combine_first_int#912",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst.test_combine_first_int(self)",
        "snippet": "    def test_combine_first_int(self):\n        # GH14687 - integer series that do no align exactly\n\n        df1 = pd.DataFrame({\"a\": [0, 1, 3, 5]}, dtype=\"int64\")\n        df2 = pd.DataFrame({\"a\": [1, 4]}, dtype=\"int64\")\n\n        res = df1.combine_first(df2)\n        tm.assert_frame_equal(res, df1)\n        assert res[\"a\"].dtype == \"int64\"",
        "begin_line": 912,
        "end_line": 920,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst.test_combine_first_with_asymmetric_other#923",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst.test_combine_first_with_asymmetric_other(self, val)",
        "snippet": "    def test_combine_first_with_asymmetric_other(self, val):\n        # see gh-20699\n        df1 = pd.DataFrame({\"isNum\": [val]})\n        df2 = pd.DataFrame({\"isBool\": [True]})\n\n        res = df1.combine_first(df2)\n        exp = pd.DataFrame({\"isBool\": [True], \"isNum\": [val]})\n\n        tm.assert_frame_equal(res, exp)",
        "begin_line": 923,
        "end_line": 931,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst.test_concat_datetime_datetime64_frame#933",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameCombineFirst.test_concat_datetime_datetime64_frame(self)",
        "snippet": "    def test_concat_datetime_datetime64_frame(self):\n        # #2624\n        rows = []\n        rows.append([datetime(2010, 1, 1), 1])\n        rows.append([datetime(2010, 1, 2), \"hi\"])\n\n        df2_obj = DataFrame.from_records(rows, columns=[\"date\", \"test\"])\n\n        ind = date_range(start=\"2000/1/1\", freq=\"D\", periods=10)\n        df1 = DataFrame({\"date\": ind, \"test\": range(10)})\n\n        # it works!\n        pd.concat([df1, df2_obj])",
        "begin_line": 933,
        "end_line": 945,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_combine_concat.TestDataFrameUpdate.test_update_nan#949",
        "src_path": "pandas/tests/frame/test_combine_concat.py",
        "class_name": "pandas.tests.frame.test_combine_concat.TestDataFrameUpdate",
        "signature": "pandas.tests.frame.test_combine_concat.TestDataFrameUpdate.test_update_nan(self)",
        "snippet": "    def test_update_nan(self):\n        # #15593 #15617\n        # test 1\n        df1 = DataFrame({\"A\": [1.0, 2, 3], \"B\": date_range(\"2000\", periods=3)})\n        df2 = DataFrame({\"A\": [None, 2, 3]})\n        expected = df1.copy()\n        df1.update(df2, overwrite=False)\n\n        tm.assert_frame_equal(df1, expected)\n\n        # test 2\n        df1 = DataFrame({\"A\": [1.0, None, 3], \"B\": date_range(\"2000\", periods=3)})\n        df2 = DataFrame({\"A\": [None, 2, 3]})\n        expected = DataFrame({\"A\": [1.0, 2, 3], \"B\": date_range(\"2000\", periods=3)})\n        df1.update(df2, overwrite=False)\n\n        tm.assert_frame_equal(df1, expected)",
        "begin_line": 949,
        "end_line": 965,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common._check_mixed_float#1",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common",
        "signature": "pandas.tests.frame.common._check_mixed_float(df, dtype=None)",
        "snippet": "def _check_mixed_float(df, dtype=None):\n    # float16 are most likely to be upcasted to float32\n    dtypes = dict(A=\"float32\", B=\"float32\", C=\"float16\", D=\"float64\")\n    if isinstance(dtype, str):\n        dtypes = {k: dtype for k, v in dtypes.items()}\n    elif isinstance(dtype, dict):\n        dtypes.update(dtype)\n    if dtypes.get(\"A\"):\n        assert df.dtypes[\"A\"] == dtypes[\"A\"]\n    if dtypes.get(\"B\"):\n        assert df.dtypes[\"B\"] == dtypes[\"B\"]\n    if dtypes.get(\"C\"):\n        assert df.dtypes[\"C\"] == dtypes[\"C\"]\n    if dtypes.get(\"D\"):\n        assert df.dtypes[\"D\"] == dtypes[\"D\"]",
        "begin_line": 1,
        "end_line": 15,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common._check_mixed_int#18",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common",
        "signature": "pandas.tests.frame.common._check_mixed_int(df, dtype=None)",
        "snippet": "def _check_mixed_int(df, dtype=None):\n    dtypes = dict(A=\"int32\", B=\"uint64\", C=\"uint8\", D=\"int64\")\n    if isinstance(dtype, str):\n        dtypes = {k: dtype for k, v in dtypes.items()}\n    elif isinstance(dtype, dict):\n        dtypes.update(dtype)\n    if dtypes.get(\"A\"):\n        assert df.dtypes[\"A\"] == dtypes[\"A\"]\n    if dtypes.get(\"B\"):\n        assert df.dtypes[\"B\"] == dtypes[\"B\"]\n    if dtypes.get(\"C\"):\n        assert df.dtypes[\"C\"] == dtypes[\"C\"]\n    if dtypes.get(\"D\"):\n        assert df.dtypes[\"D\"] == dtypes[\"D\"]",
        "begin_line": 18,
        "end_line": 31,
        "comment": "",
        "is_bug": false
    }
]