[
    {
        "name": "luigi.date_interval.DateInterval.__init__#63",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__init__(self, date_a, date_b)",
        "snippet": "    def __init__(self, date_a, date_b):\n        self.date_a = date_a\n        self.date_b = date_b",
        "begin_line": 63,
        "end_line": 65,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002607561929595828,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.dates#67",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.dates(self)",
        "snippet": "    def dates(self):\n        ''' Returns a list of dates in this date interval.'''\n        dates = []\n        d = self.date_a\n        while d < self.date_b:\n            dates.append(d)\n            d += datetime.timedelta(1)\n\n        return dates",
        "begin_line": 67,
        "end_line": 75,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00031575623618566466,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.hours#77",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.hours(self)",
        "snippet": "    def hours(self):\n        ''' Same as dates() but returns 24 times more info: one for each hour.'''\n        for date in self.dates():\n            for hour in xrange(24):\n                yield datetime.datetime.combine(date, datetime.time(hour))",
        "begin_line": 77,
        "end_line": 81,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__str__#83",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__str__(self)",
        "snippet": "    def __str__(self):\n        return self.to_string()",
        "begin_line": 83,
        "end_line": 84,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002842524161455372,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__repr__#86",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__repr__(self)",
        "snippet": "    def __repr__(self):\n        return self.to_string()",
        "begin_line": 86,
        "end_line": 87,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00030543677458766036,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.prev#89",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.prev(self)",
        "snippet": "    def prev(self):\n        ''' Returns the preceding corresponding date interval (eg. May -> April).'''\n        return self.from_date(self.date_a - datetime.timedelta(1))",
        "begin_line": 89,
        "end_line": 91,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002937720329024677,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.next#93",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.next(self)",
        "snippet": "    def next(self):\n        ''' Returns the subsequent corresponding date interval (eg. 2014 -> 2015).'''\n        return self.from_date(self.date_b)",
        "begin_line": 93,
        "end_line": 95,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00032754667540124465,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.from_date#101",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.from_date(cls, d)",
        "snippet": "    def from_date(cls, d):\n        ''' Abstract class method.\n\n        For instance, ``Month.from_date(datetime.date(2012, 6, 6))`` returns a ``Month(2012, 6)``.'''\n        raise NotImplementedError",
        "begin_line": 101,
        "end_line": 105,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__hash__#121",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__hash__(self)",
        "snippet": "    def __hash__(self):\n        return hash(repr(self))",
        "begin_line": 121,
        "end_line": 122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00030543677458766036,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__lt__#131",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__lt__(self, other)",
        "snippet": "    def __lt__(self, other):\n        if not isinstance(self, type(other)):\n            raise TypeError('Date interval type mismatch')\n        return (self.date_a, self.date_b) < (other.date_a, other.date_b)",
        "begin_line": 131,
        "end_line": 134,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__le__#136",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__le__(self, other)",
        "snippet": "    def __le__(self, other):\n        if not isinstance(self, type(other)):\n            raise TypeError('Date interval type mismatch')\n        return (self.date_a, self.date_b) <= (other.date_a, other.date_b)",
        "begin_line": 136,
        "end_line": 139,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__gt__#141",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__gt__(self, other)",
        "snippet": "    def __gt__(self, other):\n        if not isinstance(self, type(other)):\n            raise TypeError('Date interval type mismatch')\n        return (self.date_a, self.date_b) > (other.date_a, other.date_b)",
        "begin_line": 141,
        "end_line": 144,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__ge__#146",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__ge__(self, other)",
        "snippet": "    def __ge__(self, other):\n        if not isinstance(self, type(other)):\n            raise TypeError('Date interval type mismatch')\n        return (self.date_a, self.date_b) >= (other.date_a, other.date_b)",
        "begin_line": 146,
        "end_line": 149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__eq__#151",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__eq__(self, other)",
        "snippet": "    def __eq__(self, other):\n        if not isinstance(other, DateInterval):\n            return False\n        if not isinstance(self, type(other)):\n            raise TypeError('Date interval type mismatch')\n        else:\n            return (self.date_a, self.date_b) == (other.date_a, other.date_b)",
        "begin_line": 151,
        "end_line": 157,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__ne__#159",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__ne__(self, other)",
        "snippet": "    def __ne__(self, other):\n        return not self.__eq__(other)",
        "begin_line": 159,
        "end_line": 160,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.Date.__init__#167",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Date",
        "signature": "luigi.date_interval.Date.__init__(self, y, m, d)",
        "snippet": "    def __init__(self, y, m, d):\n        a = datetime.date(y, m, d)\n        b = datetime.date(y, m, d) + datetime.timedelta(1)\n        super(Date, self).__init__(a, b)",
        "begin_line": 167,
        "end_line": 170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.Date.to_string#172",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Date",
        "signature": "luigi.date_interval.Date.to_string(self)",
        "snippet": "    def to_string(self):\n        return self.date_a.strftime('%Y-%m-%d')",
        "begin_line": 172,
        "end_line": 173,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.Date.from_date#176",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Date",
        "signature": "luigi.date_interval.Date.from_date(cls, d)",
        "snippet": "    def from_date(cls, d):\n        return Date(d.year, d.month, d.day)",
        "begin_line": 176,
        "end_line": 177,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.Date.parse#180",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Date",
        "signature": "luigi.date_interval.Date.parse(cls, s)",
        "snippet": "    def parse(cls, s):\n        if re.match(r'\\d\\d\\d\\d\\-\\d\\d\\-\\d\\d$', s):\n            return Date(*map(int, s.split('-')))",
        "begin_line": 180,
        "end_line": 182,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.Week.__init__#191",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Week",
        "signature": "luigi.date_interval.Week.__init__(self, y, w)",
        "snippet": "    def __init__(self, y, w):\n        ''' Python datetime does not have a method to convert from ISO weeks, so the constructor uses some stupid brute force'''\n        for d in xrange(-10, 370):\n            date = datetime.date(y, 1, 1) + datetime.timedelta(d)\n            if date.isocalendar() == (y, w, 1):\n                date_a = date\n                break\n        else:\n            raise ValueError('Invalid week')\n        date_b = date_a + datetime.timedelta(7)\n        super(Week, self).__init__(date_a, date_b)",
        "begin_line": 191,
        "end_line": 201,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.Week.to_string#203",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Week",
        "signature": "luigi.date_interval.Week.to_string(self)",
        "snippet": "    def to_string(self):\n        return '%d-W%02d' % self.date_a.isocalendar()[:2]",
        "begin_line": 203,
        "end_line": 204,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.Week.from_date#207",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Week",
        "signature": "luigi.date_interval.Week.from_date(cls, d)",
        "snippet": "    def from_date(cls, d):\n        return Week(*d.isocalendar()[:2])",
        "begin_line": 207,
        "end_line": 208,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.Week.parse#211",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Week",
        "signature": "luigi.date_interval.Week.parse(cls, s)",
        "snippet": "    def parse(cls, s):\n        if re.match(r'\\d\\d\\d\\d\\-W\\d\\d$', s):\n            y, w = map(int, s.split('-W'))\n            return Week(y, w)",
        "begin_line": 211,
        "end_line": 214,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.Month.__init__#219",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Month",
        "signature": "luigi.date_interval.Month.__init__(self, y, m)",
        "snippet": "    def __init__(self, y, m):\n        date_a = datetime.date(y, m, 1)\n        date_b = datetime.date(y + m // 12, 1 + m % 12, 1)\n        super(Month, self).__init__(date_a, date_b)",
        "begin_line": 219,
        "end_line": 222,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.Month.to_string#224",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Month",
        "signature": "luigi.date_interval.Month.to_string(self)",
        "snippet": "    def to_string(self):\n        return self.date_a.strftime('%Y-%m')",
        "begin_line": 224,
        "end_line": 225,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.Month.from_date#228",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Month",
        "signature": "luigi.date_interval.Month.from_date(cls, d)",
        "snippet": "    def from_date(cls, d):\n        return Month(d.year, d.month)",
        "begin_line": 228,
        "end_line": 229,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.Month.parse#232",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Month",
        "signature": "luigi.date_interval.Month.parse(cls, s)",
        "snippet": "    def parse(cls, s):\n        if re.match(r'\\d\\d\\d\\d\\-\\d\\d$', s):\n            y, m = map(int, s.split('-'))\n            return Month(y, m)",
        "begin_line": 232,
        "end_line": 235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.Year.__init__#240",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Year",
        "signature": "luigi.date_interval.Year.__init__(self, y)",
        "snippet": "    def __init__(self, y):\n        date_a = datetime.date(y, 1, 1)\n        date_b = datetime.date(y + 1, 1, 1)\n        super(Year, self).__init__(date_a, date_b)",
        "begin_line": 240,
        "end_line": 243,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00032754667540124465,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.Year.to_string#245",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Year",
        "signature": "luigi.date_interval.Year.to_string(self)",
        "snippet": "    def to_string(self):\n        return self.date_a.strftime('%Y')",
        "begin_line": 245,
        "end_line": 246,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.Year.from_date#249",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Year",
        "signature": "luigi.date_interval.Year.from_date(cls, d)",
        "snippet": "    def from_date(cls, d):\n        return Year(d.year)",
        "begin_line": 249,
        "end_line": 250,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.Year.parse#253",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Year",
        "signature": "luigi.date_interval.Year.parse(cls, s)",
        "snippet": "    def parse(cls, s):\n        if re.match(r'\\d\\d\\d\\d$', s):\n            return Year(int(s))",
        "begin_line": 253,
        "end_line": 255,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.Custom.to_string#266",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Custom",
        "signature": "luigi.date_interval.Custom.to_string(self)",
        "snippet": "    def to_string(self):\n        return '-'.join([d.strftime('%Y-%m-%d') for d in (self.date_a, self.date_b)])",
        "begin_line": 266,
        "end_line": 267,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.date_interval.Custom.parse#270",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Custom",
        "signature": "luigi.date_interval.Custom.parse(cls, s)",
        "snippet": "    def parse(cls, s):\n        if re.match(r'\\d\\d\\d\\d\\-\\d\\d\\-\\d\\d\\-\\d\\d\\d\\d\\-\\d\\d\\-\\d\\d$', s):\n            x = list(map(int, s.split('-')))\n            date_a = datetime.date(*x[:3])\n            date_b = datetime.date(*x[3:])\n            return Custom(date_a, date_b)",
        "begin_line": 270,
        "end_line": 275,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.get_all_data#40",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.get_all_data(self)",
        "snippet": "    def get_all_data(self):\n        # This starts a server in the background, so we don't want to do it in the global scope\n        if MockFileSystem._data is None:\n            MockFileSystem._data = multiprocessing.Manager().dict()\n        return MockFileSystem._data",
        "begin_line": 40,
        "end_line": 44,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.get_data#46",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.get_data(self, fn)",
        "snippet": "    def get_data(self, fn):\n        return self.get_all_data()[fn]",
        "begin_line": 46,
        "end_line": 47,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002772387025228722,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.exists#49",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.exists(self, path)",
        "snippet": "    def exists(self, path):\n        return MockTarget(path).exists()",
        "begin_line": 49,
        "end_line": 50,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00031575623618566466,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.remove#52",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.remove(self, path, recursive=True, skip_trash=True)",
        "snippet": "    def remove(self, path, recursive=True, skip_trash=True):\n        \"\"\"\n        Removes the given mockfile. skip_trash doesn't have any meaning.\n        \"\"\"\n        if recursive:\n            to_delete = []\n            for s in self.get_all_data().keys():\n                if s.startswith(path):\n                    to_delete.append(s)\n            for s in to_delete:\n                self.get_all_data().pop(s)\n        else:\n            self.get_all_data().pop(path)",
        "begin_line": 52,
        "end_line": 64,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00030543677458766036,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.listdir#66",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.listdir(self, path)",
        "snippet": "    def listdir(self, path):\n        \"\"\"\n        listdir does a prefix match of self.get_all_data(), but doesn't yet support globs.\n        \"\"\"\n        return [s for s in self.get_all_data().keys()\n                if s.startswith(path)]",
        "begin_line": 66,
        "end_line": 71,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.clear#82",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.clear(self)",
        "snippet": "    def clear(self):\n        self.get_all_data().clear()",
        "begin_line": 82,
        "end_line": 83,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00023894862604540023,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.mock.MockTarget.__init__#89",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockTarget",
        "signature": "luigi.mock.MockTarget.__init__(self, fn, is_tmp=None, mirror_on_stderr=False, format=None)",
        "snippet": "    def __init__(self, fn, is_tmp=None, mirror_on_stderr=False, format=None):\n        self._mirror_on_stderr = mirror_on_stderr\n        self._fn = fn\n        if format is None:\n            format = get_default_format()\n\n        # Allow to write unicode in file for retrocompatibility\n        if six.PY2:\n            format = format >> MixedUnicodeBytes\n\n        self.format = format",
        "begin_line": 89,
        "end_line": 99,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00023234200743494423,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.mock.MockTarget.exists#101",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockTarget",
        "signature": "luigi.mock.MockTarget.exists(self)",
        "snippet": "    def exists(self,):\n        return self._fn in self.fs.get_all_data()",
        "begin_line": 101,
        "end_line": 102,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00023435669088352472,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.mock.MockTarget.path#111",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockTarget",
        "signature": "luigi.mock.MockTarget.path(self)",
        "snippet": "    def path(self):\n        return self._fn",
        "begin_line": 111,
        "end_line": 112,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002772387025228722,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.mock.MockTarget.open#114",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockTarget",
        "signature": "luigi.mock.MockTarget.open(self, mode)",
        "snippet": "    def open(self, mode):\n        fn = self._fn\n        mock_target = self\n\n        class Buffer(BytesIO):\n            # Just to be able to do writing + reading from the same buffer\n\n            _write_line = True\n\n            def set_wrapper(self, wrapper):\n                self.wrapper = wrapper\n\n            def write(self, data):\n                if six.PY3:\n                    stderrbytes = sys.stderr.buffer\n                else:\n                    stderrbytes = sys.stderr\n\n                if mock_target._mirror_on_stderr:\n                    if self._write_line:\n                        sys.stderr.write(fn + \": \")\n                    stderrbytes.write(data)\n                    if (data[-1]) == '\\n':\n                        self._write_line = True\n                    else:\n                        self._write_line = False\n                super(Buffer, self).write(data)\n\n            def close(self):\n                if mode == 'w':\n                    try:\n                        mock_target.wrapper.flush()\n                    except AttributeError:\n                        pass\n                    mock_target.fs.get_all_data()[fn] = self.getvalue()\n                super(Buffer, self).close()\n\n            def __exit__(self, exc_type, exc_val, exc_tb):\n                if not exc_type:\n                    self.close()\n\n            def __enter__(self):\n                return self\n\n            def readable(self):\n                return mode == 'r'\n\n            def writeable(self):\n                return mode == 'w'\n\n            def seekable(self):\n                return False\n\n        if mode == 'w':\n            wrapper = self.format.pipe_writer(Buffer())\n            wrapper.set_wrapper(wrapper)\n            return wrapper\n        else:\n            return self.format.pipe_reader(Buffer(self.fs.get_all_data()[fn]))",
        "begin_line": 114,
        "end_line": 172,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00024396194193705782,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.mock.Buffer.open#114",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.open(self, mode)",
        "snippet": "    def open(self, mode):\n        fn = self._fn\n        mock_target = self\n\n        class Buffer(BytesIO):\n            # Just to be able to do writing + reading from the same buffer\n\n            _write_line = True\n\n            def set_wrapper(self, wrapper):\n                self.wrapper = wrapper\n\n            def write(self, data):\n                if six.PY3:\n                    stderrbytes = sys.stderr.buffer\n                else:\n                    stderrbytes = sys.stderr\n\n                if mock_target._mirror_on_stderr:\n                    if self._write_line:\n                        sys.stderr.write(fn + \": \")\n                    stderrbytes.write(data)\n                    if (data[-1]) == '\\n':\n                        self._write_line = True\n                    else:\n                        self._write_line = False\n                super(Buffer, self).write(data)\n\n            def close(self):\n                if mode == 'w':\n                    try:\n                        mock_target.wrapper.flush()\n                    except AttributeError:\n                        pass\n                    mock_target.fs.get_all_data()[fn] = self.getvalue()\n                super(Buffer, self).close()\n\n            def __exit__(self, exc_type, exc_val, exc_tb):\n                if not exc_type:\n                    self.close()\n\n            def __enter__(self):\n                return self\n\n            def readable(self):\n                return mode == 'r'\n\n            def writeable(self):\n                return mode == 'w'\n\n            def seekable(self):\n                return False\n\n        if mode == 'w':\n            wrapper = self.format.pipe_writer(Buffer())\n            wrapper.set_wrapper(wrapper)\n            return wrapper\n        else:\n            return self.format.pipe_reader(Buffer(self.fs.get_all_data()[fn]))",
        "begin_line": 114,
        "end_line": 172,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00023596035865974517,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.mock.Buffer.set_wrapper#123",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.set_wrapper(self, wrapper)",
        "snippet": "            def set_wrapper(self, wrapper):\n                self.wrapper = wrapper",
        "begin_line": 123,
        "end_line": 124,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00023837902264600716,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.mock.Buffer.write#126",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.write(self, data)",
        "snippet": "            def write(self, data):\n                if six.PY3:\n                    stderrbytes = sys.stderr.buffer\n                else:\n                    stderrbytes = sys.stderr\n\n                if mock_target._mirror_on_stderr:\n                    if self._write_line:\n                        sys.stderr.write(fn + \": \")\n                    stderrbytes.write(data)\n                    if (data[-1]) == '\\n':\n                        self._write_line = True\n                    else:\n                        self._write_line = False\n                super(Buffer, self).write(data)",
        "begin_line": 126,
        "end_line": 140,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.mock.Buffer.close#142",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.close(self)",
        "snippet": "            def close(self):\n                if mode == 'w':\n                    try:\n                        mock_target.wrapper.flush()\n                    except AttributeError:\n                        pass\n                    mock_target.fs.get_all_data()[fn] = self.getvalue()\n                super(Buffer, self).close()",
        "begin_line": 142,
        "end_line": 149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00023798191337458352,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.mock.Buffer.__exit__#151",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.__exit__(self, exc_type, exc_val, exc_tb)",
        "snippet": "            def __exit__(self, exc_type, exc_val, exc_tb):\n                if not exc_type:\n                    self.close()",
        "begin_line": 151,
        "end_line": 153,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00024783147459727387,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.mock.Buffer.__enter__#155",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.__enter__(self)",
        "snippet": "            def __enter__(self):\n                return self",
        "begin_line": 155,
        "end_line": 156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00024783147459727387,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.mock.Buffer.readable#158",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.readable(self)",
        "snippet": "            def readable(self):\n                return mode == 'r'",
        "begin_line": 158,
        "end_line": 159,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00023596035865974517,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.mock.Buffer.writeable#161",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.writeable(self)",
        "snippet": "            def writeable(self):\n                return mode == 'w'",
        "begin_line": 161,
        "end_line": 162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00023596035865974517,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.mock.Buffer.seekable#164",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.seekable(self)",
        "snippet": "            def seekable(self):\n                return False",
        "begin_line": 164,
        "end_line": 165,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00023596035865974517,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.mock.MockFile.__init__#176",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFile",
        "signature": "luigi.mock.MockFile.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        warnings.warn(\"MockFile has been renamed MockTarget\", DeprecationWarning, stacklevel=2)\n        super(MockFile, self).__init__(*args, **kwargs)",
        "begin_line": 176,
        "end_line": 178,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002607561929595828,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.app_options#56",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.app_options(self)",
        "snippet": "    def app_options(self):\n        \"\"\"\n        Subclass this method to map your task parameters to the app's arguments\n\n        \"\"\"\n        return []",
        "begin_line": 56,
        "end_line": 61,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.spark_submit#64",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.spark_submit(self)",
        "snippet": "    def spark_submit(self):\n        return configuration.get_config().get('spark', 'spark-submit', 'spark-submit')",
        "begin_line": 64,
        "end_line": 65,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002937720329024677,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.master#68",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.master(self)",
        "snippet": "    def master(self):\n        return configuration.get_config().get(\"spark\", \"master\", None)",
        "begin_line": 68,
        "end_line": 69,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002937720329024677,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.deploy_mode#72",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.deploy_mode(self)",
        "snippet": "    def deploy_mode(self):\n        return configuration.get_config().get(\"spark\", \"deploy-mode\", None)",
        "begin_line": 72,
        "end_line": 73,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.jars#76",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.jars(self)",
        "snippet": "    def jars(self):\n        return self._list_config(configuration.get_config().get(\"spark\", \"jars\", None))",
        "begin_line": 76,
        "end_line": 77,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.packages#80",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.packages(self)",
        "snippet": "    def packages(self):\n        return self._list_config(configuration.get_config().get(\"spark\", \"packages\", None))",
        "begin_line": 80,
        "end_line": 81,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002937720329024677,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.py_files#84",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.py_files(self)",
        "snippet": "    def py_files(self):\n        return self._list_config(configuration.get_config().get(\"spark\", \"py-files\", None))",
        "begin_line": 84,
        "end_line": 85,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.files#88",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.files(self)",
        "snippet": "    def files(self):\n        return self._list_config(configuration.get_config().get(\"spark\", \"files\", None))",
        "begin_line": 88,
        "end_line": 89,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.conf#92",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.conf(self)",
        "snippet": "    def conf(self):\n        return self._dict_config(configuration.get_config().get(\"spark\", \"conf\", None))",
        "begin_line": 92,
        "end_line": 93,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.properties_file#96",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.properties_file(self)",
        "snippet": "    def properties_file(self):\n        return configuration.get_config().get(\"spark\", \"properties-file\", None)",
        "begin_line": 96,
        "end_line": 97,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.driver_memory#100",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.driver_memory(self)",
        "snippet": "    def driver_memory(self):\n        return configuration.get_config().get(\"spark\", \"driver-memory\", None)",
        "begin_line": 100,
        "end_line": 101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.driver_java_options#104",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.driver_java_options(self)",
        "snippet": "    def driver_java_options(self):\n        return configuration.get_config().get(\"spark\", \"driver-java-options\", None)",
        "begin_line": 104,
        "end_line": 105,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.driver_library_path#108",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.driver_library_path(self)",
        "snippet": "    def driver_library_path(self):\n        return configuration.get_config().get(\"spark\", \"driver-library-path\", None)",
        "begin_line": 108,
        "end_line": 109,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.driver_class_path#112",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.driver_class_path(self)",
        "snippet": "    def driver_class_path(self):\n        return configuration.get_config().get(\"spark\", \"driver-class-path\", None)",
        "begin_line": 112,
        "end_line": 113,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.executor_memory#116",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.executor_memory(self)",
        "snippet": "    def executor_memory(self):\n        return configuration.get_config().get(\"spark\", \"executor-memory\", None)",
        "begin_line": 116,
        "end_line": 117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.driver_cores#120",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.driver_cores(self)",
        "snippet": "    def driver_cores(self):\n        return configuration.get_config().get(\"spark\", \"driver-cores\", None)",
        "begin_line": 120,
        "end_line": 121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.supervise#124",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.supervise(self)",
        "snippet": "    def supervise(self):\n        return bool(configuration.get_config().get(\"spark\", \"supervise\", False))",
        "begin_line": 124,
        "end_line": 125,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.total_executor_cores#128",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.total_executor_cores(self)",
        "snippet": "    def total_executor_cores(self):\n        return configuration.get_config().get(\"spark\", \"total-executor-cores\", None)",
        "begin_line": 128,
        "end_line": 129,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.executor_cores#132",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.executor_cores(self)",
        "snippet": "    def executor_cores(self):\n        return configuration.get_config().get(\"spark\", \"executor-cores\", None)",
        "begin_line": 132,
        "end_line": 133,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.queue#136",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.queue(self)",
        "snippet": "    def queue(self):\n        return configuration.get_config().get(\"spark\", \"queue\", None)",
        "begin_line": 136,
        "end_line": 137,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.num_executors#140",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.num_executors(self)",
        "snippet": "    def num_executors(self):\n        return configuration.get_config().get(\"spark\", \"num-executors\", None)",
        "begin_line": 140,
        "end_line": 141,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.archives#144",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.archives(self)",
        "snippet": "    def archives(self):\n        return self._list_config(configuration.get_config().get(\"spark\", \"archives\", None))",
        "begin_line": 144,
        "end_line": 145,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.hadoop_conf_dir#148",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.hadoop_conf_dir(self)",
        "snippet": "    def hadoop_conf_dir(self):\n        return configuration.get_config().get(\"spark\", \"hadoop-conf-dir\", None)",
        "begin_line": 148,
        "end_line": 149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00030543677458766036,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.get_environment#151",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.get_environment(self)",
        "snippet": "    def get_environment(self):\n        env = os.environ.copy()\n        hadoop_conf_dir = self.hadoop_conf_dir\n        if hadoop_conf_dir:\n            env['HADOOP_CONF_DIR'] = hadoop_conf_dir\n        return env",
        "begin_line": 151,
        "end_line": 156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.program_environment#158",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.program_environment(self)",
        "snippet": "    def program_environment(self):\n        return self.get_environment()",
        "begin_line": 158,
        "end_line": 159,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00030543677458766036,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.program_args#161",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.program_args(self)",
        "snippet": "    def program_args(self):\n        return self.spark_command() + self.app_command()",
        "begin_line": 161,
        "end_line": 162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00030543677458766036,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.spark_command#164",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.spark_command(self)",
        "snippet": "    def spark_command(self):\n        command = [self.spark_submit]\n        command += self._text_arg('--master', self.master)\n        command += self._text_arg('--deploy-mode', self.deploy_mode)\n        command += self._text_arg('--name', self.name)\n        command += self._text_arg('--class', self.entry_class)\n        command += self._list_arg('--jars', self.jars)\n        command += self._list_arg('--packages', self.packages)\n        command += self._list_arg('--py-files', self.py_files)\n        command += self._list_arg('--files', self.files)\n        command += self._list_arg('--archives', self.archives)\n        command += self._dict_arg('--conf', self.conf)\n        command += self._text_arg('--properties-file', self.properties_file)\n        command += self._text_arg('--driver-memory', self.driver_memory)\n        command += self._text_arg('--driver-java-options', self.driver_java_options)\n        command += self._text_arg('--driver-library-path', self.driver_library_path)\n        command += self._text_arg('--driver-class-path', self.driver_class_path)\n        command += self._text_arg('--executor-memory', self.executor_memory)\n        command += self._text_arg('--driver-cores', self.driver_cores)\n        command += self._flag_arg('--supervise', self.supervise)\n        command += self._text_arg('--total-executor-cores', self.total_executor_cores)\n        command += self._text_arg('--executor-cores', self.executor_cores)\n        command += self._text_arg('--queue', self.queue)\n        command += self._text_arg('--num-executors', self.num_executors)\n        return command",
        "begin_line": 164,
        "end_line": 188,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002937720329024677,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.app_command#190",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.app_command(self)",
        "snippet": "    def app_command(self):\n        if not self.app:\n            raise NotImplementedError(\"subclass should define an app (.jar or .py file)\")\n        return [self.app] + self.app_options()",
        "begin_line": 190,
        "end_line": 193,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask._list_config#195",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask._list_config(self, config)",
        "snippet": "    def _list_config(self, config):\n        if config and isinstance(config, six.string_types):\n            return list(map(lambda x: x.strip(), config.split(',')))",
        "begin_line": 195,
        "end_line": 197,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask._dict_config#199",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask._dict_config(self, config)",
        "snippet": "    def _dict_config(self, config):\n        if config and isinstance(config, six.string_types):\n            return dict(map(lambda i: i.split('=', 1), config.split('|')))",
        "begin_line": 199,
        "end_line": 201,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask._text_arg#203",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask._text_arg(self, name, value)",
        "snippet": "    def _text_arg(self, name, value):\n        if value:\n            return [name, value]\n        return []",
        "begin_line": 203,
        "end_line": 206,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00030543677458766036,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask._list_arg#208",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask._list_arg(self, name, value)",
        "snippet": "    def _list_arg(self, name, value):\n        if value and isinstance(value, (list, tuple)):\n            return [name, ','.join(value)]\n        return []",
        "begin_line": 208,
        "end_line": 211,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00031575623618566466,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask._dict_arg#213",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask._dict_arg(self, name, value)",
        "snippet": "    def _dict_arg(self, name, value):\n        command = []\n        if value and isinstance(value, dict):\n            for prop, value in value.items():\n                command += [name, '{0}={1}'.format(prop, value)]\n        return command",
        "begin_line": 213,
        "end_line": 218,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00031575623618566466,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask._flag_arg#220",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask._flag_arg(self, name, value)",
        "snippet": "    def _flag_arg(self, name, value):\n        if value:\n            return [name]\n        return []",
        "begin_line": 220,
        "end_line": 223,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask.name#243",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask.name(self)",
        "snippet": "    def name(self):\n        return self.__class__.__name__",
        "begin_line": 243,
        "end_line": 244,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask.py_packages#247",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask.py_packages(self)",
        "snippet": "    def py_packages(self):\n        packages = configuration.get_config().get('spark', 'py-packages', None)\n        if packages:\n            return map(lambda s: s.strip(), packages.split(','))",
        "begin_line": 247,
        "end_line": 250,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask.setup#252",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask.setup(self, conf)",
        "snippet": "    def setup(self, conf):\n        \"\"\"\n        Called by the pyspark_runner with a SparkConf instance that will be used to instantiate the SparkContext\n\n        :param conf: SparkConf\n        \"\"\"",
        "begin_line": 252,
        "end_line": 257,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask.setup_remote#259",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask.setup_remote(self, sc)",
        "snippet": "    def setup_remote(self, sc):\n        self._setup_packages(sc)",
        "begin_line": 259,
        "end_line": 260,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask.program_args#271",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask.program_args(self)",
        "snippet": "    def program_args(self):\n        return self.spark_command() + self.app_command()",
        "begin_line": 271,
        "end_line": 272,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask.app_command#274",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask.app_command(self)",
        "snippet": "    def app_command(self):\n        return [self.app, self.run_pickle] + self.app_options()",
        "begin_line": 274,
        "end_line": 275,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask.run#277",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask.run(self)",
        "snippet": "    def run(self):\n        self.run_path = tempfile.mkdtemp(prefix=self.name)\n        self.run_pickle = os.path.join(self.run_path, '.'.join([self.name.replace(' ', '_'), 'pickle']))\n        with open(self.run_pickle, 'wb') as fd:\n            self._dump(fd)\n        try:\n            super(PySparkTask, self).run()\n        finally:\n            shutil.rmtree(self.run_path)",
        "begin_line": 277,
        "end_line": 285,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask._dump#287",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask._dump(self, fd)",
        "snippet": "    def _dump(self, fd):\n        if self.__module__ == '__main__':\n            d = pickle.dumps(self)\n            module_name = os.path.basename(sys.argv[0]).rsplit('.', 1)[0]\n            d = d.replace(b'(c__main__', \"(c\" + module_name)\n            fd.write(d)\n        else:\n            pickle.dump(self, fd)",
        "begin_line": 287,
        "end_line": 294,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask._setup_packages#296",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask._setup_packages(self, sc)",
        "snippet": "    def _setup_packages(self, sc):\n        \"\"\"\n        This method compresses and uploads packages to the cluster\n\n        \"\"\"\n        packages = self.py_packages\n        if not packages:\n            return\n        for package in packages:\n            mod = importlib.import_module(package)\n            try:\n                mod_path = mod.__path__[0]\n            except AttributeError:\n                mod_path = mod.__file__\n            tar_path = os.path.join(self.run_path, package + '.tar.gz')\n            tar = tarfile.open(tar_path, \"w:gz\")\n            tar.add(mod_path, os.path.basename(mod_path))\n            tar.close()\n            sc.addPyFile(tar_path)",
        "begin_line": 296,
        "end_line": 314,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.s3.S3Client.__init__#76",
        "src_path": "luigi/s3.py",
        "class_name": "luigi.s3.S3Client",
        "signature": "luigi.s3.S3Client.__init__(self, aws_access_key_id=None, aws_secret_access_key=None, **kwargs)",
        "snippet": "    def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,\n                 **kwargs):\n        # only import boto when needed to allow top-lvl s3 module import\n        import boto\n        import boto.s3.connection\n        from boto.s3.key import Key\n\n        options = self._get_s3_config()\n        options.update(kwargs)\n        # Removing key args would break backwards compability\n        role_arn = options.get('aws_role_arn')\n        role_session_name = options.get('aws_role_session_name')\n\n        aws_session_token = None\n\n        if role_arn and role_session_name:\n            from boto import sts\n\n            sts_client = sts.STSConnection()\n            assumed_role = sts_client.assume_role(role_arn, role_session_name)\n            aws_secret_access_key = assumed_role.credentials.secret_key\n            aws_access_key_id = assumed_role.credentials.access_key\n            aws_session_token = assumed_role.credentials.session_token\n\n        else:\n            if not aws_access_key_id:\n                aws_access_key_id = options.get('aws_access_key_id')\n\n            if not aws_secret_access_key:\n                aws_secret_access_key = options.get('aws_secret_access_key')\n\n        for key in ['aws_access_key_id', 'aws_secret_access_key', 'aws_role_session_name', 'aws_role_arn']:\n            if key in options:\n                options.pop(key)\n\n        self.s3 = boto.s3.connection.S3Connection(aws_access_key_id,\n                                                  aws_secret_access_key,\n                                                  security_token=aws_session_token,\n                                                  **options)\n        self.Key = Key",
        "begin_line": 76,
        "end_line": 115,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.14285714285714285,
            "pseudo_dstar_susp": 0.08333333333333333,
            "pseudo_tarantula_susp": 0.047619047619047616,
            "pseudo_op2_susp": 0.08333333333333333,
            "pseudo_barinel_susp": 0.047619047619047616
        }
    },
    {
        "name": "luigi.s3.S3Client._get_s3_config#532",
        "src_path": "luigi/s3.py",
        "class_name": "luigi.s3.S3Client",
        "signature": "luigi.s3.S3Client._get_s3_config(self, key=None)",
        "snippet": "    def _get_s3_config(self, key=None):\n        try:\n            config = dict(configuration.get_config().items('s3'))\n        except NoSectionError:\n            return {}\n        # So what ports etc can be read without us having to specify all dtypes\n        for k, v in six.iteritems(config):\n            try:\n                config[k] = int(v)\n            except ValueError:\n                pass\n        if key:\n            return config.get(key)\n        return config",
        "begin_line": 532,
        "end_line": 545,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.14285714285714285,
            "pseudo_dstar_susp": 0.08333333333333333,
            "pseudo_tarantula_susp": 0.023255813953488372,
            "pseudo_op2_susp": 0.08333333333333333,
            "pseudo_barinel_susp": 0.023255813953488372
        }
    },
    {
        "name": "luigi.retcodes.run_with_retcodes#47",
        "src_path": "luigi/retcodes.py",
        "class_name": "luigi.retcodes",
        "signature": "luigi.retcodes.run_with_retcodes(argv)",
        "snippet": "def run_with_retcodes(argv):\n    \"\"\"\n    Run luigi with command line parsing, but raise ``SystemExit`` with the configured exit code.\n\n    Note: Usually you use the luigi binary directly and don't call this function yourself.\n\n    :param argv: Should (conceptually) be ``sys.argv[1:]``\n    \"\"\"\n    logger = logging.getLogger('luigi-interface')\n    with luigi.cmdline_parser.CmdlineParser.global_instance(argv):\n        retcodes = retcode()\n\n    worker = None\n    try:\n        worker = luigi.interface._run(argv)['worker']\n    except luigi.interface.PidLockAlreadyTakenExit:\n        sys.exit(retcodes.already_running)\n    except Exception:\n        # Some errors occur before logging is set up, we set it up now\n        luigi.interface.setup_interface_logging()\n        logger.exception(\"Uncaught exception in luigi\")\n        sys.exit(retcodes.unhandled_exception)\n\n    task_sets = luigi.execution_summary._summary_dict(worker)\n    non_empty_categories = {k: v for k, v in task_sets.items() if v}.keys()\n\n    def has(status):\n        assert status in luigi.execution_summary._ORDERED_STATUSES\n        return status in non_empty_categories\n\n    codes_and_conds = (\n        (retcodes.missing_data, has('still_pending_ext')),\n        (retcodes.task_failed, has('failed')),\n        (retcodes.already_running, has('run_by_other_worker')),\n    )\n    sys.exit(max(code * (1 if cond else 0) for code, cond in codes_and_conds))",
        "begin_line": 47,
        "end_line": 82,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002544529262086514,
            "pseudo_dstar_susp": 0.0009199632014719411,
            "pseudo_tarantula_susp": 0.0058823529411764705,
            "pseudo_op2_susp": 0.0009199632014719411,
            "pseudo_barinel_susp": 0.0058823529411764705
        }
    },
    {
        "name": "luigi.retcodes.has#73",
        "src_path": "luigi/retcodes.py",
        "class_name": "luigi.retcodes",
        "signature": "luigi.retcodes.has(status)",
        "snippet": "    def has(status):\n        assert status in luigi.execution_summary._ORDERED_STATUSES\n        return status in non_empty_categories",
        "begin_line": 73,
        "end_line": 75,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.cmdline_parser.CmdlineParser.get_instance#38",
        "src_path": "luigi/cmdline_parser.py",
        "class_name": "luigi.cmdline_parser.CmdlineParser",
        "signature": "luigi.cmdline_parser.CmdlineParser.get_instance(cls)",
        "snippet": "    def get_instance(cls):\n        \"\"\" Singleton getter \"\"\"\n        return cls._instance",
        "begin_line": 38,
        "end_line": 40,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003424657534246575,
            "pseudo_dstar_susp": 0.009174311926605505,
            "pseudo_tarantula_susp": 0.0017391304347826088,
            "pseudo_op2_susp": 0.009174311926605505,
            "pseudo_barinel_susp": 0.0017391304347826088
        }
    },
    {
        "name": "luigi.cmdline_parser.CmdlineParser.global_instance#44",
        "src_path": "luigi/cmdline_parser.py",
        "class_name": "luigi.cmdline_parser.CmdlineParser",
        "signature": "luigi.cmdline_parser.CmdlineParser.global_instance(cls, cmdline_args, allow_override=False)",
        "snippet": "    def global_instance(cls, cmdline_args, allow_override=False):\n        \"\"\"\n        Meant to be used as a context manager.\n        \"\"\"\n        orig_value = cls._instance\n        assert (orig_value is None) or allow_override\n        new_value = None\n        try:\n            new_value = CmdlineParser(cmdline_args)\n            cls._instance = new_value\n            yield new_value\n        finally:\n            assert cls._instance is new_value\n            cls._instance = orig_value",
        "begin_line": 44,
        "end_line": 57,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0028328611898017,
            "pseudo_dstar_susp": 0.0021321961620469083,
            "pseudo_tarantula_susp": 0.003472222222222222,
            "pseudo_op2_susp": 0.0021321961620469083,
            "pseudo_barinel_susp": 0.003472222222222222
        }
    },
    {
        "name": "luigi.cmdline_parser.CmdlineParser.__init__#59",
        "src_path": "luigi/cmdline_parser.py",
        "class_name": "luigi.cmdline_parser.CmdlineParser",
        "signature": "luigi.cmdline_parser.CmdlineParser.__init__(self, cmdline_args)",
        "snippet": "    def __init__(self, cmdline_args):\n        \"\"\"\n        Initialize cmd line args\n        \"\"\"\n        known_args, _ = self._build_parser().parse_known_args(args=cmdline_args)\n        self._attempt_load_module(known_args)\n        # We have to parse again now. As the positionally first unrecognized\n        # argument (the task) could be different.\n        known_args, _ = self._build_parser().parse_known_args(args=cmdline_args)\n        root_task = known_args.root_task\n        parser = self._build_parser(root_task=root_task,\n                                    help_all=known_args.core_help_all)\n        self._possibly_exit_with_help(parser, known_args)\n        if not root_task:\n            raise SystemExit('No task specified')\n        else:\n            # Check that what we believe to be the task is correctly spelled\n            Register.get_task_cls(root_task)\n        known_args = parser.parse_args(args=cmdline_args)\n        self.known_args = known_args  # Also publically expose parsed arguments",
        "begin_line": 59,
        "end_line": 78,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0030581039755351682,
            "pseudo_dstar_susp": 0.0022522522522522522,
            "pseudo_tarantula_susp": 0.0038022813688212928,
            "pseudo_op2_susp": 0.0022522522522522522,
            "pseudo_barinel_susp": 0.0038022813688212928
        }
    },
    {
        "name": "luigi.cmdline_parser.CmdlineParser._build_parser#81",
        "src_path": "luigi/cmdline_parser.py",
        "class_name": "luigi.cmdline_parser.CmdlineParser",
        "signature": "luigi.cmdline_parser.CmdlineParser._build_parser(root_task=None, help_all=False)",
        "snippet": "    def _build_parser(root_task=None, help_all=False):\n        parser = argparse.ArgumentParser(add_help=False)\n\n        # Unfortunately, we have to set it as optional to argparse, so we can\n        # parse out stuff like `--module` before we call for `--help`.\n        parser.add_argument('root_task',\n                            nargs='?',\n                            help='Task family to run. Is not optional.',\n                            metavar='Required root task',\n                            )\n\n        for task_name, is_without_section, param_name, param_obj in Register.get_all_params():\n            is_the_root_task = task_name == root_task\n            help = param_obj.description if any((is_the_root_task, help_all, param_obj.always_in_help)) else argparse.SUPPRESS\n            flag_name_underscores = param_name if is_without_section else task_name + '_' + param_name\n            global_flag_name = '--' + flag_name_underscores.replace('_', '-')\n            parser.add_argument(global_flag_name,\n                                help=help,\n                                action=param_obj._parser_action(),\n                                dest=param_obj._parser_global_dest(param_name, task_name)\n                                )\n            if is_the_root_task:\n                local_flag_name = '--' + param_name.replace('_', '-')\n                parser.add_argument(local_flag_name,\n                                    help=help,\n                                    action=param_obj._parser_action(),\n                                    dest=param_name\n                                    )\n\n        return parser",
        "begin_line": 81,
        "end_line": 110,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0028328611898017,
            "pseudo_dstar_susp": 0.0021321961620469083,
            "pseudo_tarantula_susp": 0.00390625,
            "pseudo_op2_susp": 0.0021321961620469083,
            "pseudo_barinel_susp": 0.00390625
        }
    },
    {
        "name": "luigi.cmdline_parser.CmdlineParser.get_task_obj#112",
        "src_path": "luigi/cmdline_parser.py",
        "class_name": "luigi.cmdline_parser.CmdlineParser",
        "signature": "luigi.cmdline_parser.CmdlineParser.get_task_obj(self)",
        "snippet": "    def get_task_obj(self):\n        \"\"\"\n        Get the task object\n        \"\"\"\n        return self._get_task_cls()(**self._get_task_kwargs())",
        "begin_line": 112,
        "end_line": 116,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008726003490401396,
            "pseudo_dstar_susp": 0.0008605851979345956,
            "pseudo_tarantula_susp": 0.0016474464579901153,
            "pseudo_op2_susp": 0.0008605851979345956,
            "pseudo_barinel_susp": 0.0016474464579901153
        }
    },
    {
        "name": "luigi.cmdline_parser.CmdlineParser._get_task_cls#118",
        "src_path": "luigi/cmdline_parser.py",
        "class_name": "luigi.cmdline_parser.CmdlineParser",
        "signature": "luigi.cmdline_parser.CmdlineParser._get_task_cls(self)",
        "snippet": "    def _get_task_cls(self):\n        \"\"\"\n        Get the task class\n        \"\"\"\n        return Register.get_task_cls(self.known_args.root_task)",
        "begin_line": 118,
        "end_line": 122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008726003490401396,
            "pseudo_dstar_susp": 0.0008605851979345956,
            "pseudo_tarantula_susp": 0.0016474464579901153,
            "pseudo_op2_susp": 0.0008605851979345956,
            "pseudo_barinel_susp": 0.0016474464579901153
        }
    },
    {
        "name": "luigi.cmdline_parser.CmdlineParser._get_task_kwargs#124",
        "src_path": "luigi/cmdline_parser.py",
        "class_name": "luigi.cmdline_parser.CmdlineParser",
        "signature": "luigi.cmdline_parser.CmdlineParser._get_task_kwargs(self)",
        "snippet": "    def _get_task_kwargs(self):\n        \"\"\"\n        Get the local task arguments as a dictionary. The return value is in\n        the form ``dict(my_param='my_value', ...)``\n        \"\"\"\n        res = {}\n        for (param_name, param_obj) in self._get_task_cls().get_params():\n            attr = getattr(self.known_args, param_name)\n            if attr:\n                res.update(((param_name, param_obj.parse(attr)),))\n\n        return res",
        "begin_line": 124,
        "end_line": 135,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009372071227741331,
            "pseudo_dstar_susp": 0.0008818342151675485,
            "pseudo_tarantula_susp": 0.0022123893805309734,
            "pseudo_op2_susp": 0.0008818342151675485,
            "pseudo_barinel_susp": 0.0022123893805309734
        }
    },
    {
        "name": "luigi.cmdline_parser.CmdlineParser._attempt_load_module#138",
        "src_path": "luigi/cmdline_parser.py",
        "class_name": "luigi.cmdline_parser.CmdlineParser",
        "signature": "luigi.cmdline_parser.CmdlineParser._attempt_load_module(known_args)",
        "snippet": "    def _attempt_load_module(known_args):\n        \"\"\"\n        Load the --module parameter\n        \"\"\"\n        module = known_args.core_module\n        if module:\n            __import__(module)",
        "begin_line": 138,
        "end_line": 144,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0028328611898017,
            "pseudo_dstar_susp": 0.0021321961620469083,
            "pseudo_tarantula_susp": 0.003472222222222222,
            "pseudo_op2_susp": 0.0021321961620469083,
            "pseudo_barinel_susp": 0.003472222222222222
        }
    },
    {
        "name": "luigi.cmdline_parser.CmdlineParser._possibly_exit_with_help#147",
        "src_path": "luigi/cmdline_parser.py",
        "class_name": "luigi.cmdline_parser.CmdlineParser",
        "signature": "luigi.cmdline_parser.CmdlineParser._possibly_exit_with_help(parser, known_args)",
        "snippet": "    def _possibly_exit_with_help(parser, known_args):\n        \"\"\"\n        Check if the user passed --help[-all], if so, print a message and exit.\n        \"\"\"\n        if known_args.core_help or known_args.core_help_all:\n            parser.print_help()\n            sys.exit()",
        "begin_line": 147,
        "end_line": 153,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0028328611898017,
            "pseudo_dstar_susp": 0.0021321961620469083,
            "pseudo_tarantula_susp": 0.003472222222222222,
            "pseudo_op2_susp": 0.0021321961620469083,
            "pseudo_barinel_susp": 0.003472222222222222
        }
    },
    {
        "name": "luigi.contrib.sge._parse_qstat_state#113",
        "src_path": "luigi/contrib/sge.py",
        "class_name": "luigi.contrib.sge",
        "signature": "luigi.contrib.sge._parse_qstat_state(qstat_out, job_id)",
        "snippet": "def _parse_qstat_state(qstat_out, job_id):\n    \"\"\"Parse \"state\" column from `qstat` output for given job_id\n\n    Returns state for the *first* job matching job_id. Returns 'u' if\n    `qstat` output is empty or job_id is not found.\n\n    \"\"\"\n    if qstat_out.strip() == '':\n        return 'u'\n    lines = qstat_out.split('\\n')\n    # skip past header\n    while not lines.pop(0).startswith('---'):\n        pass\n    for line in lines:\n        if line:\n            job, prior, name, user, state = line.strip().split()[0:5]\n            if int(job) == int(job_id):\n                return state\n    return 'u'",
        "begin_line": 113,
        "end_line": 131,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.sge._parse_qsub_job_id#134",
        "src_path": "luigi/contrib/sge.py",
        "class_name": "luigi.contrib.sge",
        "signature": "luigi.contrib.sge._parse_qsub_job_id(qsub_out)",
        "snippet": "def _parse_qsub_job_id(qsub_out):\n    \"\"\"Parse job id from qsub output string.\n\n    Assume format:\n\n        \"Your job <job_id> (\"<job_name>\") has been submitted\"\n\n    \"\"\"\n    return int(qsub_out.split()[2])",
        "begin_line": 134,
        "end_line": 142,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory._session#66",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory._session(self, session=None)",
        "snippet": "    def _session(self, session=None):\n        if session:\n            yield session\n        else:\n            session = self.session_factory()\n            try:\n                yield session\n            except:\n                session.rollback()\n                raise\n            else:\n                session.commit()",
        "begin_line": 66,
        "end_line": 77,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008403361344537815,
            "pseudo_dstar_susp": 0.0011614401858304297,
            "pseudo_tarantula_susp": 0.00847457627118644,
            "pseudo_op2_susp": 0.0011614401858304297,
            "pseudo_barinel_susp": 0.00847457627118644
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory.__init__#79",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory.__init__(self)",
        "snippet": "    def __init__(self):\n        config = configuration.get_config()\n        connection_string = config.get('task_history', 'db_connection')\n        self.engine = sqlalchemy.create_engine(connection_string)\n        self.session_factory = sqlalchemy.orm.sessionmaker(bind=self.engine, expire_on_commit=False)\n        Base.metadata.create_all(self.engine)\n        self.tasks = {}  # task_id -> TaskRecord\n\n        _upgrade_schema(self.engine)",
        "begin_line": 79,
        "end_line": 87,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008403361344537815,
            "pseudo_dstar_susp": 0.0011614401858304297,
            "pseudo_tarantula_susp": 0.00847457627118644,
            "pseudo_op2_susp": 0.0011614401858304297,
            "pseudo_barinel_susp": 0.00847457627118644
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory.task_scheduled#89",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory.task_scheduled(self, task)",
        "snippet": "    def task_scheduled(self, task):\n        htask = self._get_task(task, status=PENDING)\n        self._add_task_event(htask, TaskEvent(event_name=PENDING, ts=datetime.datetime.now()))",
        "begin_line": 89,
        "end_line": 91,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008403361344537815,
            "pseudo_dstar_susp": 0.0011614401858304297,
            "pseudo_tarantula_susp": 0.00847457627118644,
            "pseudo_op2_susp": 0.0011614401858304297,
            "pseudo_barinel_susp": 0.00847457627118644
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory.task_finished#93",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory.task_finished(self, task, successful)",
        "snippet": "    def task_finished(self, task, successful):\n        event_name = DONE if successful else FAILED\n        htask = self._get_task(task, status=event_name)\n        self._add_task_event(htask, TaskEvent(event_name=event_name, ts=datetime.datetime.now()))",
        "begin_line": 93,
        "end_line": 96,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008403361344537815,
            "pseudo_dstar_susp": 0.0011614401858304297,
            "pseudo_tarantula_susp": 0.00847457627118644,
            "pseudo_op2_susp": 0.0011614401858304297,
            "pseudo_barinel_susp": 0.00847457627118644
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory.task_started#98",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory.task_started(self, task, worker_host)",
        "snippet": "    def task_started(self, task, worker_host):\n        htask = self._get_task(task, status=RUNNING, host=worker_host)\n        self._add_task_event(htask, TaskEvent(event_name=RUNNING, ts=datetime.datetime.now()))",
        "begin_line": 98,
        "end_line": 100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008403361344537815,
            "pseudo_dstar_susp": 0.0011614401858304297,
            "pseudo_tarantula_susp": 0.00847457627118644,
            "pseudo_op2_susp": 0.0011614401858304297,
            "pseudo_barinel_susp": 0.00847457627118644
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory._get_task#102",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory._get_task(self, task, status, host=None)",
        "snippet": "    def _get_task(self, task, status, host=None):\n        if task.id in self.tasks:\n            htask = self.tasks[task.id]\n            htask.status = status\n            if host:\n                htask.host = host\n        else:\n            htask = self.tasks[task.id] = task_history.StoredTask(task, status, host)\n        return htask",
        "begin_line": 102,
        "end_line": 110,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008403361344537815,
            "pseudo_dstar_susp": 0.0011614401858304297,
            "pseudo_tarantula_susp": 0.00847457627118644,
            "pseudo_op2_susp": 0.0011614401858304297,
            "pseudo_barinel_susp": 0.00847457627118644
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory._add_task_event#112",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory._add_task_event(self, task, event)",
        "snippet": "    def _add_task_event(self, task, event):\n        for (task_record, session) in self._find_or_create_task(task):\n            task_record.events.append(event)",
        "begin_line": 112,
        "end_line": 114,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008403361344537815,
            "pseudo_dstar_susp": 0.0011614401858304297,
            "pseudo_tarantula_susp": 0.00847457627118644,
            "pseudo_op2_susp": 0.0011614401858304297,
            "pseudo_barinel_susp": 0.00847457627118644
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory._find_or_create_task#116",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory._find_or_create_task(self, task)",
        "snippet": "    def _find_or_create_task(self, task):\n        with self._session() as session:\n            if task.record_id is not None:\n                logger.debug(\"Finding task with record_id [%d]\", task.record_id)\n                task_record = session.query(TaskRecord).get(task.record_id)\n                if not task_record:\n                    raise Exception(\"Task with record_id, but no matching Task record!\")\n                yield (task_record, session)\n            else:\n                task_record = TaskRecord(task_id=task._task.id, name=task.task_family, host=task.host)\n                for (k, v) in six.iteritems(task.parameters):\n                    task_record.parameters[k] = TaskParameter(name=k, value=v)\n                session.add(task_record)\n                yield (task_record, session)\n            if task.host:\n                task_record.host = task.host\n        task.record_id = task_record.id",
        "begin_line": 116,
        "end_line": 132,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008403361344537815,
            "pseudo_dstar_susp": 0.0011614401858304297,
            "pseudo_tarantula_susp": 0.00847457627118644,
            "pseudo_op2_susp": 0.0011614401858304297,
            "pseudo_barinel_susp": 0.00847457627118644
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory.find_all_by_parameters#134",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory.find_all_by_parameters(self, task_name, session=None, **task_params)",
        "snippet": "    def find_all_by_parameters(self, task_name, session=None, **task_params):\n        \"\"\"\n        Find tasks with the given task_name and the same parameters as the kwargs.\n        \"\"\"\n        with self._session(session) as session:\n            query = session.query(TaskRecord).join(TaskEvent).filter(TaskRecord.name == task_name)\n            for (k, v) in six.iteritems(task_params):\n                alias = sqlalchemy.orm.aliased(TaskParameter)\n                query = query.join(alias).filter(alias.name == k, alias.value == v)\n\n            tasks = query.order_by(TaskEvent.ts)\n            for task in tasks:\n                # Sanity check\n                assert all(k in task.parameters and v == str(task.parameters[k].value) for (k, v) in six.iteritems(task_params))\n\n                yield task",
        "begin_line": 134,
        "end_line": 149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.013513513513513514,
            "pseudo_dstar_susp": 0.003367003367003367,
            "pseudo_tarantula_susp": 0.00847457627118644,
            "pseudo_op2_susp": 0.003367003367003367,
            "pseudo_barinel_susp": 0.00847457627118644
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory.find_all_by_name#151",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory.find_all_by_name(self, task_name, session=None)",
        "snippet": "    def find_all_by_name(self, task_name, session=None):\n        \"\"\"\n        Find all tasks with the given task_name.\n        \"\"\"\n        return self.find_all_by_parameters(task_name, session)",
        "begin_line": 151,
        "end_line": 155,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012048192771084338,
            "pseudo_dstar_susp": 0.0012121212121212121,
            "pseudo_tarantula_susp": 0.012345679012345678,
            "pseudo_op2_susp": 0.0012121212121212121,
            "pseudo_barinel_susp": 0.012345679012345678
        }
    },
    {
        "name": "luigi.db_task_history.TaskEvent.__repr__#215",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.TaskEvent",
        "signature": "luigi.db_task_history.TaskEvent.__repr__(self)",
        "snippet": "    def __repr__(self):\n        return \"TaskEvent(task_id=%s, event_name=%s, ts=%s\" % (self.task_id, self.event_name, self.ts)",
        "begin_line": 215,
        "end_line": 216,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.db_task_history._upgrade_schema#243",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history",
        "signature": "luigi.db_task_history._upgrade_schema(engine)",
        "snippet": "def _upgrade_schema(engine):\n    \"\"\"\n    Ensure the database schema is up to date with the codebase.\n\n    :param engine: SQLAlchemy engine of the underlying database.\n    \"\"\"\n    inspector = reflection.Inspector.from_engine(engine)\n    conn = engine.connect()\n\n    # Upgrade 1.  Add task_id column and index to tasks\n    if 'task_id' not in [x['name'] for x in inspector.get_columns('tasks')]:\n        logger.warn('Upgrading DbTaskHistory schema: Adding tasks.task_id')\n        conn.execute('ALTER TABLE tasks ADD COLUMN task_id VARCHAR(200)')\n        conn.execute('CREATE INDEX ix_task_id ON tasks (task_id)')",
        "begin_line": 243,
        "end_line": 256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.013513513513513514,
            "pseudo_dstar_susp": 0.003367003367003367,
            "pseudo_tarantula_susp": 0.00847457627118644,
            "pseudo_op2_susp": 0.003367003367003367,
            "pseudo_barinel_susp": 0.00847457627118644
        }
    },
    {
        "name": "luigi.rpc._urljoin#53",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc",
        "signature": "luigi.rpc._urljoin(base, url)",
        "snippet": "def _urljoin(base, url):\n    \"\"\"\n    Join relative URLs to base URLs like urllib.parse.urljoin but support\n    arbitrary URIs (esp. 'http+unix://').\n    \"\"\"\n    parsed = urlparse(base)\n    scheme = parsed.scheme\n    return urlparse(\n        urljoin(parsed._replace(scheme='http').geturl(), url)\n    )._replace(scheme=scheme).geturl()",
        "begin_line": 53,
        "end_line": 62,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00024073182474723158,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.rpc.RPCError.__init__#67",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RPCError",
        "signature": "luigi.rpc.RPCError.__init__(self, message, sub_exception=None)",
        "snippet": "    def __init__(self, message, sub_exception=None):\n        super(RPCError, self).__init__(message)\n        self.sub_exception = sub_exception",
        "begin_line": 67,
        "end_line": 69,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00030543677458766036,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.rpc.URLLibFetcher.fetch#75",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.URLLibFetcher",
        "signature": "luigi.rpc.URLLibFetcher.fetch(self, full_url, body, timeout)",
        "snippet": "    def fetch(self, full_url, body, timeout):\n        body = urlencode(body).encode('utf-8')\n        return urlopen(full_url, body, timeout).read().decode('utf-8')",
        "begin_line": 75,
        "end_line": 77,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00032754667540124465,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.rpc.RequestsFetcher.__init__#81",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RequestsFetcher",
        "signature": "luigi.rpc.RequestsFetcher.__init__(self, session)",
        "snippet": "    def __init__(self, session):\n        from requests import exceptions as requests_exceptions\n        self.raises = requests_exceptions.RequestException\n        self.session = session",
        "begin_line": 81,
        "end_line": 84,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007651109410864575,
            "pseudo_dstar_susp": 0.0007651109410864575,
            "pseudo_tarantula_susp": 0.0007716049382716049,
            "pseudo_op2_susp": 0.0007651109410864575,
            "pseudo_barinel_susp": 0.0007716049382716049
        }
    },
    {
        "name": "luigi.rpc.RequestsFetcher.fetch#86",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RequestsFetcher",
        "signature": "luigi.rpc.RequestsFetcher.fetch(self, full_url, body, timeout)",
        "snippet": "    def fetch(self, full_url, body, timeout):\n        resp = self.session.get(full_url, data=body, timeout=timeout)\n        resp.raise_for_status()\n        return resp.text",
        "begin_line": 86,
        "end_line": 89,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002573340195573855,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler.__init__#97",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler.__init__(self, url='http://localhost:8082/', connect_timeout=None)",
        "snippet": "    def __init__(self, url='http://localhost:8082/', connect_timeout=None):\n        assert not url.startswith('http+unix://') or HAS_UNIX_SOCKET, (\n            'You need to install requests-unixsocket for Unix socket support.'\n        )\n\n        self._url = url.rstrip('/')\n        config = configuration.get_config()\n\n        if connect_timeout is None:\n            connect_timeout = config.getfloat('core', 'rpc-connect-timeout', 10.0)\n        self._connect_timeout = connect_timeout\n\n        if HAS_REQUESTS:\n            self._fetcher = RequestsFetcher(requests.Session())\n        else:\n            self._fetcher = URLLibFetcher()",
        "begin_line": 97,
        "end_line": 112,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.03333333333333333,
            "pseudo_dstar_susp": 0.007246376811594203,
            "pseudo_tarantula_susp": 0.047619047619047616,
            "pseudo_op2_susp": 0.007246376811594203,
            "pseudo_barinel_susp": 0.047619047619047616
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler._fetch#117",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler._fetch(self, url_suffix, body, log_exceptions=True, attempts=3)",
        "snippet": "    def _fetch(self, url_suffix, body, log_exceptions=True, attempts=3):\n        full_url = _urljoin(self._url, url_suffix)\n        last_exception = None\n        attempt = 0\n        while attempt < attempts:\n            attempt += 1\n            if last_exception:\n                logger.info(\"Retrying...\")\n                self._wait()  # wait for a bit and retry\n            try:\n                response = self._fetcher.fetch(full_url, body, self._connect_timeout)\n                break\n            except self._fetcher.raises as e:\n                last_exception = e\n                if log_exceptions:\n                    logger.exception(\"Failed connecting to remote scheduler %r\", self._url)\n                continue\n        else:\n            raise RPCError(\n                \"Errors (%d attempts) when connecting to remote scheduler %r\" %\n                (attempts, self._url),\n                last_exception\n            )\n        return response",
        "begin_line": 117,
        "end_line": 140,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00031575623618566466,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler._request#142",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler._request(self, url, data, log_exceptions=True, attempts=3, allow_null=True)",
        "snippet": "    def _request(self, url, data, log_exceptions=True, attempts=3, allow_null=True):\n        body = {'data': json.dumps(data)}\n\n        for _ in range(attempts):\n            page = self._fetch(url, body, log_exceptions, attempts)\n            response = json.loads(page)[\"response\"]\n            if allow_null or response is not None:\n                return response\n        raise RPCError(\"Received null response from remote scheduler %r\" % self._url)",
        "begin_line": 142,
        "end_line": 150,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler.ping#152",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler.ping(self, worker)",
        "snippet": "    def ping(self, worker):\n        # just one attempt, keep-alive thread will keep trying anyway\n        self._request('/api/ping', {'worker': worker}, attempts=1)",
        "begin_line": 152,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00025471217524197657,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler.add_task#156",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler.add_task(self, worker, task_id, status=PENDING, runnable=True, deps=None, new_deps=None, expl=None, resources=None, priority=0, family='', module=None, params=None, assistant=False, tracking_url=None)",
        "snippet": "    def add_task(self, worker, task_id, status=PENDING, runnable=True,\n                 deps=None, new_deps=None, expl=None, resources=None, priority=0,\n                 family='', module=None, params=None, assistant=False,\n                 tracking_url=None):\n        self._request('/api/add_task', {\n            'task_id': task_id,\n            'worker': worker,\n            'status': status,\n            'runnable': runnable,\n            'deps': deps,\n            'new_deps': new_deps,\n            'expl': expl,\n            'resources': resources,\n            'priority': priority,\n            'family': family,\n            'module': module,\n            'params': params,\n            'assistant': assistant,\n            'tracking_url': tracking_url,\n        })",
        "begin_line": 156,
        "end_line": 175,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00022983222247759135,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler.get_work#177",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler.get_work(self, worker, host=None, assistant=False, current_tasks=None)",
        "snippet": "    def get_work(self, worker, host=None, assistant=False, current_tasks=None):\n        return self._request(\n            '/api/get_work',\n            {\n                'worker': worker,\n                'host': host,\n                'assistant': assistant,\n                'current_tasks': current_tasks,\n            },\n            allow_null=False,\n        )",
        "begin_line": 177,
        "end_line": 187,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002311604253351826,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler.task_list#199",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler.task_list(self, status, upstream_status, search=None)",
        "snippet": "    def task_list(self, status, upstream_status, search=None):\n        return self._request('/api/task_list', {\n            'search': search,\n            'status': status,\n            'upstream_status': upstream_status,\n        })",
        "begin_line": 199,
        "end_line": 204,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00023894862604540023,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler.worker_list#206",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler.worker_list(self)",
        "snippet": "    def worker_list(self):\n        return self._request('/api/worker_list', {})",
        "begin_line": 206,
        "end_line": 207,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler.add_worker#218",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler.add_worker(self, worker, info)",
        "snippet": "    def add_worker(self, worker, info):\n        return self._request('/api/add_worker', {'worker': worker, 'info': info})",
        "begin_line": 218,
        "end_line": 219,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002573340195573855,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler.disable_worker#221",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler.disable_worker(self, worker)",
        "snippet": "    def disable_worker(self, worker):\n        return self._request('/api/disable_worker', {'worker': worker})",
        "begin_line": 221,
        "end_line": 222,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00030543677458766036,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler.update_resources#224",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler.update_resources(self, **resources)",
        "snippet": "    def update_resources(self, **resources):\n        return self._request('/api/update_resources', resources)",
        "begin_line": 224,
        "end_line": 225,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002494387627837366,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler.prune#227",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler.prune(self)",
        "snippet": "    def prune(self):\n        return self._request('/api/prune', {})",
        "begin_line": 227,
        "end_line": 228,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00026673779674579886,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler.re_enable_task#230",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler.re_enable_task(self, task_id)",
        "snippet": "    def re_enable_task(self, task_id):\n        return self._request('/api/re_enable_task', {'task_id': task_id})",
        "begin_line": 230,
        "end_line": 231,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.task_history.StoredTask.__init__#38",
        "src_path": "luigi/task_history.py",
        "class_name": "luigi.task_history.StoredTask",
        "signature": "luigi.task_history.StoredTask.__init__(self, task, status, host=None)",
        "snippet": "    def __init__(self, task, status, host=None):\n        self._task = task\n        self.status = status\n        self.record_id = None\n        self.host = host",
        "begin_line": 38,
        "end_line": 42,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008403361344537815,
            "pseudo_dstar_susp": 0.0011614401858304297,
            "pseudo_tarantula_susp": 0.00847457627118644,
            "pseudo_op2_susp": 0.0011614401858304297,
            "pseudo_barinel_susp": 0.00847457627118644
        }
    },
    {
        "name": "luigi.task_history.StoredTask.task_family#45",
        "src_path": "luigi/task_history.py",
        "class_name": "luigi.task_history.StoredTask",
        "signature": "luigi.task_history.StoredTask.task_family(self)",
        "snippet": "    def task_family(self):\n        return self._task.family",
        "begin_line": 45,
        "end_line": 46,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008403361344537815,
            "pseudo_dstar_susp": 0.0011614401858304297,
            "pseudo_tarantula_susp": 0.00847457627118644,
            "pseudo_op2_susp": 0.0011614401858304297,
            "pseudo_barinel_susp": 0.00847457627118644
        }
    },
    {
        "name": "luigi.task_history.StoredTask.parameters#49",
        "src_path": "luigi/task_history.py",
        "class_name": "luigi.task_history.StoredTask",
        "signature": "luigi.task_history.StoredTask.parameters(self)",
        "snippet": "    def parameters(self):\n        return self._task.params",
        "begin_line": 49,
        "end_line": 50,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008403361344537815,
            "pseudo_dstar_susp": 0.0011614401858304297,
            "pseudo_tarantula_susp": 0.00847457627118644,
            "pseudo_op2_susp": 0.0011614401858304297,
            "pseudo_barinel_susp": 0.00847457627118644
        }
    },
    {
        "name": "luigi.task_history.NopHistory.task_scheduled#76",
        "src_path": "luigi/task_history.py",
        "class_name": "luigi.task_history.NopHistory",
        "signature": "luigi.task_history.NopHistory.task_scheduled(self, task)",
        "snippet": "    def task_scheduled(self, task):\n        pass",
        "begin_line": 76,
        "end_line": 77,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009363295880149813,
            "pseudo_dstar_susp": 0.0012406947890818859,
            "pseudo_tarantula_susp": 0.0008319467554076539,
            "pseudo_op2_susp": 0.0012406947890818859,
            "pseudo_barinel_susp": 0.0008319467554076539
        }
    },
    {
        "name": "luigi.task_history.NopHistory.task_finished#79",
        "src_path": "luigi/task_history.py",
        "class_name": "luigi.task_history.NopHistory",
        "signature": "luigi.task_history.NopHistory.task_finished(self, task, successful)",
        "snippet": "    def task_finished(self, task, successful):\n        pass",
        "begin_line": 79,
        "end_line": 80,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014947683109118087,
            "pseudo_dstar_susp": 0.0029154518950437317,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.0029154518950437317,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "luigi.task_history.NopHistory.task_started#82",
        "src_path": "luigi/task_history.py",
        "class_name": "luigi.task_history.NopHistory",
        "signature": "luigi.task_history.NopHistory.task_started(self, task, worker_host)",
        "snippet": "    def task_started(self, task, worker_host):\n        pass",
        "begin_line": 82,
        "end_line": 83,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009881422924901185,
            "pseudo_dstar_susp": 0.0013175230566534915,
            "pseudo_tarantula_susp": 0.000980392156862745,
            "pseudo_op2_susp": 0.0013175230566534915,
            "pseudo_barinel_susp": 0.000980392156862745
        }
    },
    {
        "name": "luigi.lock.getpcmd#30",
        "src_path": "luigi/lock.py",
        "class_name": "luigi.lock",
        "signature": "luigi.lock.getpcmd(pid)",
        "snippet": "def getpcmd(pid):\n    \"\"\"\n    Returns command of process.\n\n    :param pid:\n    \"\"\"\n    if os.name == \"nt\":\n        # Use wmic command instead of ps on Windows.\n        cmd = 'wmic path win32_process where ProcessID=%s get Commandline' % (pid, )\n        with os.popen(cmd, 'r') as p:\n            lines = [line for line in p.readlines() if line.strip(\"\\r\\n \") != \"\"]\n            if lines:\n                _, val = lines\n                return val\n    else:\n        cmd = 'ps -o pid,args'\n        with os.popen(cmd, 'r') as p:\n            # Skip the column titles\n            p.readline()\n            for line in p:\n                spid, scmd = line.strip().split(' ', 1)\n                if int(spid) == int(pid):\n                    return scmd",
        "begin_line": 30,
        "end_line": 52,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00030543677458766036,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.lock.get_info#55",
        "src_path": "luigi/lock.py",
        "class_name": "luigi.lock",
        "signature": "luigi.lock.get_info(pid_dir, my_pid=None)",
        "snippet": "def get_info(pid_dir, my_pid=None):\n    # Check the name and pid of this process\n    if my_pid is None:\n        my_pid = os.getpid()\n\n    my_cmd = getpcmd(my_pid)\n\n    if six.PY3:\n        cmd_hash = my_cmd.encode('utf8')\n    else:\n        cmd_hash = my_cmd\n\n    pid_file = os.path.join(pid_dir, hashlib.md5(cmd_hash).hexdigest()) + '.pid'\n\n    return my_pid, my_cmd, pid_file",
        "begin_line": 55,
        "end_line": 69,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00031575623618566466,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.lock.acquire_for#72",
        "src_path": "luigi/lock.py",
        "class_name": "luigi.lock",
        "signature": "luigi.lock.acquire_for(pid_dir, num_available=1, kill_signal=None)",
        "snippet": "def acquire_for(pid_dir, num_available=1, kill_signal=None):\n    \"\"\"\n    Makes sure the process is only run once at the same time with the same name.\n\n    Notice that we since we check the process name, different parameters to the same\n    command can spawn multiple processes at the same time, i.e. running\n    \"/usr/bin/my_process\" does not prevent anyone from launching\n    \"/usr/bin/my_process --foo bar\".\n    \"\"\"\n\n    my_pid, my_cmd, pid_file = get_info(pid_dir)\n\n    # Check if there is a pid file corresponding to this name\n    if not os.path.exists(pid_dir):\n        os.mkdir(pid_dir)\n        os.chmod(pid_dir, 0o777)\n\n    pids = set()\n    pid_cmds = {}\n    if os.path.exists(pid_file):\n        # There is such a file - read the pid and look up its process name\n        pids.update(filter(None, map(str.strip, open(pid_file))))\n        pid_cmds = dict((pid, getpcmd(pid)) for pid in pids)\n        matching_pids = list(filter(lambda pid: pid_cmds[pid] == my_cmd, pids))\n\n        if kill_signal is not None:\n            for pid in map(int, matching_pids):\n                os.kill(pid, kill_signal)\n        elif len(matching_pids) >= num_available:\n            # We are already running under a different pid\n            print('Pid(s)', ', '.join(matching_pids), 'already running')\n            return False\n        else:\n            # The pid belongs to something else, we could\n            pass\n    pid_cmds[str(my_pid)] = my_cmd\n\n    # Write pids\n    pids.add(str(my_pid))\n    with open(pid_file, 'w') as f:\n        f.writelines('%s\\n' % (pid, ) for pid in filter(pid_cmds.__getitem__, pids))\n\n    # Make the file writable by all\n    if os.name == 'nt':\n        pass\n    else:\n        s = os.stat(pid_file)\n        if os.getuid() == s.st_uid:\n            os.chmod(pid_file, s.st_mode | 0o777)\n\n    return True",
        "begin_line": 72,
        "end_line": 122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.worker.TaskProcess.__init__#92",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.TaskProcess",
        "signature": "luigi.worker.TaskProcess.__init__(self, task, worker_id, result_queue, random_seed=False, worker_timeout=0, tracking_url_callback=None)",
        "snippet": "    def __init__(self, task, worker_id, result_queue, random_seed=False, worker_timeout=0,\n                 tracking_url_callback=None):\n        super(TaskProcess, self).__init__()\n        self.task = task\n        self.worker_id = worker_id\n        self.result_queue = result_queue\n        self.random_seed = random_seed\n        self.tracking_url_callback = tracking_url_callback\n        if task.worker_timeout is not None:\n            worker_timeout = task.worker_timeout\n        self.timeout_time = time.time() + worker_timeout if worker_timeout else None",
        "begin_line": 92,
        "end_line": 102,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006958942240779402,
            "pseudo_dstar_susp": 0.0006958942240779402,
            "pseudo_tarantula_susp": 0.0006958942240779402,
            "pseudo_op2_susp": 0.0006958942240779402,
            "pseudo_barinel_susp": 0.0006958942240779402
        }
    },
    {
        "name": "luigi.worker.TaskProcess._run_get_new_deps#104",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.TaskProcess",
        "signature": "luigi.worker.TaskProcess._run_get_new_deps(self)",
        "snippet": "    def _run_get_new_deps(self):\n        run_again = False\n        try:\n            task_gen = self.task.run(tracking_url_callback=self.tracking_url_callback)\n        except TypeError as ex:\n            if 'unexpected keyword argument' not in str(ex):\n                raise\n            run_again = True\n        if run_again:\n            task_gen = self.task.run()\n        if not isinstance(task_gen, types.GeneratorType):\n            return None\n\n        next_send = None\n        while True:\n            try:\n                if next_send is None:\n                    requires = six.next(task_gen)\n                else:\n                    requires = task_gen.send(next_send)\n            except StopIteration:\n                return None\n\n            new_req = flatten(requires)\n            new_deps = [(t.task_module, t.task_family, t.to_str_params())\n                        for t in new_req]\n            if all(t.complete() for t in new_req):\n                next_send = getpaths(requires)\n            else:\n                return new_deps",
        "begin_line": 104,
        "end_line": 133,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007496251874062968,
            "pseudo_dstar_susp": 0.0007496251874062968,
            "pseudo_tarantula_susp": 0.0007524454477050414,
            "pseudo_op2_susp": 0.0007496251874062968,
            "pseudo_barinel_susp": 0.0007524454477050414
        }
    },
    {
        "name": "luigi.worker.TaskProcess.run#135",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.TaskProcess",
        "signature": "luigi.worker.TaskProcess.run(self)",
        "snippet": "    def run(self):\n        logger.info('[pid %s] Worker %s running   %s', os.getpid(), self.worker_id, self.task)\n\n        if self.random_seed:\n            # Need to have different random seeds if running in separate processes\n            random.seed((os.getpid(), time.time()))\n\n        status = FAILED\n        expl = ''\n        missing = []\n        new_deps = []\n        try:\n            # Verify that all the tasks are fulfilled! For external tasks we\n            # don't care about unfulfilled dependencies, because we are just\n            # checking completeness of self.task so outputs of dependencies are\n            # irrelevant.\n            if self.task.run != NotImplemented:\n                missing = [dep.task_id for dep in self.task.deps() if not dep.complete()]\n                if missing:\n                    deps = 'dependency' if len(missing) == 1 else 'dependencies'\n                    raise RuntimeError('Unfulfilled %s at run time: %s' % (deps, ', '.join(missing)))\n            self.task.trigger_event(Event.START, self.task)\n            t0 = time.time()\n            status = None\n\n            if self.task.run == NotImplemented:\n                # External task\n                # TODO(erikbern): We should check for task completeness after non-external tasks too!\n                # This will resolve #814 and make things a lot more consistent\n                if self.task.complete():\n                    status = DONE\n                else:\n                    status = FAILED\n                    expl = 'Task is an external data dependency ' \\\n                        'and data does not exist (yet?).'\n            else:\n                new_deps = self._run_get_new_deps()\n                status = DONE if not new_deps else PENDING\n\n            if new_deps:\n                logger.info(\n                    '[pid %s] Worker %s new requirements      %s',\n                    os.getpid(), self.worker_id, self.task)\n            elif status == DONE:\n                self.task.trigger_event(\n                    Event.PROCESSING_TIME, self.task, time.time() - t0)\n                expl = self.task.on_success()\n                logger.info('[pid %s] Worker %s done      %s', os.getpid(),\n                            self.worker_id, self.task)\n                self.task.trigger_event(Event.SUCCESS, self.task)\n\n        except KeyboardInterrupt:\n            raise\n        except BaseException as ex:\n            status = FAILED\n            logger.exception(\"[pid %s] Worker %s failed    %s\", os.getpid(), self.worker_id, self.task)\n            self.task.trigger_event(Event.FAILURE, self.task, ex)\n            raw_error_message = self.task.on_failure(ex)\n            expl = raw_error_message\n\n        finally:\n            self.result_queue.put(\n                (self.task.task_id, status, expl, missing, new_deps))",
        "begin_line": 135,
        "end_line": 197,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009813542688910696,
            "pseudo_dstar_susp": 0.0009433962264150943,
            "pseudo_tarantula_susp": 0.0024154589371980675,
            "pseudo_op2_susp": 0.0009433962264150943,
            "pseudo_barinel_susp": 0.0024154589371980675
        }
    },
    {
        "name": "luigi.worker.TaskProcess._recursive_terminate#199",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.TaskProcess",
        "signature": "luigi.worker.TaskProcess._recursive_terminate(self)",
        "snippet": "    def _recursive_terminate(self):\n        import psutil\n\n        try:\n            parent = psutil.Process(self.pid)\n            children = parent.children(recursive=True)\n\n            # terminate parent. Give it a chance to clean up\n            super(TaskProcess, self).terminate()\n            parent.wait()\n\n            # terminate children\n            for child in children:\n                try:\n                    child.terminate()\n                except psutil.NoSuchProcess:\n                    continue\n        except psutil.NoSuchProcess:\n            return",
        "begin_line": 199,
        "end_line": 217,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.worker.TaskProcess.terminate#219",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.TaskProcess",
        "signature": "luigi.worker.TaskProcess.terminate(self)",
        "snippet": "    def terminate(self):\n        \"\"\"Terminate this process and its subprocesses.\"\"\"\n        # default terminate() doesn't cleanup child processes, it orphans them.\n        try:\n            return self._recursive_terminate()\n        except ImportError:\n            return super(TaskProcess, self).terminate()",
        "begin_line": 219,
        "end_line": 225,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00031575623618566466,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.worker.SingleProcessPool.apply_async#235",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.SingleProcessPool",
        "signature": "luigi.worker.SingleProcessPool.apply_async(self, function, args)",
        "snippet": "    def apply_async(self, function, args):\n        return function(*args)",
        "begin_line": 235,
        "end_line": 236,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012484394506866417,
            "pseudo_dstar_susp": 0.0015337423312883436,
            "pseudo_tarantula_susp": 0.0011862396204033216,
            "pseudo_op2_susp": 0.0015337423312883436,
            "pseudo_barinel_susp": 0.0011862396204033216
        }
    },
    {
        "name": "luigi.worker.SingleProcessPool.close#238",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.SingleProcessPool",
        "signature": "luigi.worker.SingleProcessPool.close(self)",
        "snippet": "    def close(self):\n        pass",
        "begin_line": 238,
        "end_line": 239,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012610340479192938,
            "pseudo_dstar_susp": 0.0015527950310559005,
            "pseudo_tarantula_susp": 0.0011976047904191617,
            "pseudo_op2_susp": 0.0015527950310559005,
            "pseudo_barinel_susp": 0.0011976047904191617
        }
    },
    {
        "name": "luigi.worker.SingleProcessPool.join#241",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.SingleProcessPool",
        "signature": "luigi.worker.SingleProcessPool.join(self)",
        "snippet": "    def join(self):\n        pass",
        "begin_line": 241,
        "end_line": 242,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012610340479192938,
            "pseudo_dstar_susp": 0.0015527950310559005,
            "pseudo_tarantula_susp": 0.0011976047904191617,
            "pseudo_op2_susp": 0.0015527950310559005,
            "pseudo_barinel_susp": 0.0011976047904191617
        }
    },
    {
        "name": "luigi.worker.DequeQueue.put#250",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.DequeQueue",
        "signature": "luigi.worker.DequeQueue.put(self, obj, block=None, timeout=None)",
        "snippet": "    def put(self, obj, block=None, timeout=None):\n        return self.append(obj)",
        "begin_line": 250,
        "end_line": 251,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012610340479192938,
            "pseudo_dstar_susp": 0.0015527950310559005,
            "pseudo_tarantula_susp": 0.0011976047904191617,
            "pseudo_op2_susp": 0.0015527950310559005,
            "pseudo_barinel_susp": 0.0011976047904191617
        }
    },
    {
        "name": "luigi.worker.DequeQueue.get#253",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.DequeQueue",
        "signature": "luigi.worker.DequeQueue.get(self, block=None, timeout=None)",
        "snippet": "    def get(self, block=None, timeout=None):\n        return self.pop()",
        "begin_line": 253,
        "end_line": 254,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012610340479192938,
            "pseudo_dstar_susp": 0.0015527950310559005,
            "pseudo_tarantula_susp": 0.0011976047904191617,
            "pseudo_op2_susp": 0.0015527950310559005,
            "pseudo_barinel_susp": 0.0011976047904191617
        }
    },
    {
        "name": "luigi.worker.AsyncCompletionException.__init__#262",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.AsyncCompletionException",
        "signature": "luigi.worker.AsyncCompletionException.__init__(self, trace)",
        "snippet": "    def __init__(self, trace):\n        self.trace = trace",
        "begin_line": 262,
        "end_line": 263,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00030543677458766036,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.worker.TracebackWrapper.__init__#271",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.TracebackWrapper",
        "signature": "luigi.worker.TracebackWrapper.__init__(self, trace)",
        "snippet": "    def __init__(self, trace):\n        self.trace = trace",
        "begin_line": 271,
        "end_line": 272,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00032754667540124465,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.worker.check_complete#275",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker",
        "signature": "luigi.worker.check_complete(task, out_queue)",
        "snippet": "def check_complete(task, out_queue):\n    \"\"\"\n    Checks if task is complete, puts the result to out_queue.\n    \"\"\"\n    logger.debug(\"Checking if %s is complete\", task)\n    try:\n        is_complete = task.complete()\n    except Exception:\n        is_complete = TracebackWrapper(traceback.format_exc())\n    out_queue.put((task, is_complete))",
        "begin_line": 275,
        "end_line": 284,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012610340479192938,
            "pseudo_dstar_susp": 0.0015527950310559005,
            "pseudo_tarantula_susp": 0.0011976047904191617,
            "pseudo_op2_susp": 0.0015527950310559005,
            "pseudo_barinel_susp": 0.0011976047904191617
        }
    },
    {
        "name": "luigi.worker.KeepAliveThread.__init__#323",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.KeepAliveThread",
        "signature": "luigi.worker.KeepAliveThread.__init__(self, scheduler, worker_id, ping_interval)",
        "snippet": "    def __init__(self, scheduler, worker_id, ping_interval):\n        super(KeepAliveThread, self).__init__()\n        self._should_stop = threading.Event()\n        self._scheduler = scheduler\n        self._worker_id = worker_id\n        self._ping_interval = ping_interval",
        "begin_line": 323,
        "end_line": 328,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014204545454545455,
            "pseudo_dstar_susp": 0.0017699115044247787,
            "pseudo_tarantula_susp": 0.0014534883720930232,
            "pseudo_op2_susp": 0.0017699115044247787,
            "pseudo_barinel_susp": 0.0014534883720930232
        }
    },
    {
        "name": "luigi.worker.KeepAliveThread.stop#330",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.KeepAliveThread",
        "signature": "luigi.worker.KeepAliveThread.stop(self)",
        "snippet": "    def stop(self):\n        self._should_stop.set()",
        "begin_line": 330,
        "end_line": 331,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014204545454545455,
            "pseudo_dstar_susp": 0.0017699115044247787,
            "pseudo_tarantula_susp": 0.0014534883720930232,
            "pseudo_op2_susp": 0.0017699115044247787,
            "pseudo_barinel_susp": 0.0014534883720930232
        }
    },
    {
        "name": "luigi.worker.KeepAliveThread.run#333",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.KeepAliveThread",
        "signature": "luigi.worker.KeepAliveThread.run(self)",
        "snippet": "    def run(self):\n        while True:\n            self._should_stop.wait(self._ping_interval)\n            if self._should_stop.is_set():\n                logger.info(\"Worker %s was stopped. Shutting down Keep-Alive thread\" % self._worker_id)\n                break\n            with fork_lock:\n                try:\n                    self._scheduler.ping(worker=self._worker_id)\n                except:  # httplib.BadStatusLine:\n                    logger.warning('Failed pinging scheduler')",
        "begin_line": 333,
        "end_line": 343,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014204545454545455,
            "pseudo_dstar_susp": 0.0017699115044247787,
            "pseudo_tarantula_susp": 0.0014534883720930232,
            "pseudo_op2_susp": 0.0017699115044247787,
            "pseudo_barinel_susp": 0.0014534883720930232
        }
    },
    {
        "name": "luigi.worker.Worker.__init__#356",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker.__init__(self, scheduler=None, worker_id=None, worker_processes=1, assistant=False, **kwargs)",
        "snippet": "    def __init__(self, scheduler=None, worker_id=None, worker_processes=1, assistant=False, **kwargs):\n        if scheduler is None:\n            scheduler = CentralPlannerScheduler()\n\n        self.worker_processes = int(worker_processes)\n        self._worker_info = self._generate_worker_info()\n\n        if not worker_id:\n            worker_id = 'Worker(%s)' % ', '.join(['%s=%s' % (k, v) for k, v in self._worker_info])\n\n        self._config = worker(**kwargs)\n\n        assert self._config.wait_interval >= _WAIT_INTERVAL_EPS, \"[worker] wait_interval must be positive\"\n        assert self._config.wait_jitter >= 0.0, \"[worker] wait_jitter must be equal or greater than zero\"\n\n        self._id = worker_id\n        self._scheduler = scheduler\n        self._assistant = assistant\n        self._stop_requesting_work = False\n\n        self.host = socket.gethostname()\n        self._scheduled_tasks = {}\n        self._suspended_tasks = {}\n\n        self._first_task = None\n\n        self.add_succeeded = True\n        self.run_succeeded = True\n        self.unfulfilled_counts = collections.defaultdict(int)\n\n        # note that ``signal.signal(signal.SIGUSR1, fn)`` only works inside the main execution thread, which is why we\n        # provide the ability to conditionally install the hook.\n        if not self._config.no_install_shutdown_handler:\n            try:\n                signal.signal(signal.SIGUSR1, self.handle_interrupt)\n            except AttributeError:\n                pass\n\n        # Keep info about what tasks are running (could be in other processes)\n        if worker_processes == 1:\n            self._task_result_queue = DequeQueue()\n        else:\n            self._task_result_queue = multiprocessing.Queue()\n\n        self._running_tasks = {}\n\n        # Stuff for execution_summary\n        self._add_task_history = []\n        self._get_work_response_history = []",
        "begin_line": 356,
        "end_line": 404,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0031847133757961785,
            "pseudo_dstar_susp": 0.007518796992481203,
            "pseudo_tarantula_susp": 0.002053388090349076,
            "pseudo_op2_susp": 0.007518796992481203,
            "pseudo_barinel_susp": 0.002053388090349076
        }
    },
    {
        "name": "luigi.worker.Worker._add_task#406",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._add_task(self, *args, **kwargs)",
        "snippet": "    def _add_task(self, *args, **kwargs):\n        \"\"\"\n        Call ``self._scheduler.add_task``, but store the values too so we can\n        implement :py:func:`luigi.execution_summary.summary`.\n        \"\"\"\n        task_id = kwargs['task_id']\n        status = kwargs['status']\n        runnable = kwargs['runnable']\n        task = self._scheduled_tasks.get(task_id)\n        if task:\n            msg = (task, status, runnable)\n            self._add_task_history.append(msg)\n        self._scheduler.add_task(*args, **kwargs)\n\n        logger.info('Informed scheduler that task   %s   has status   %s', task_id, status)",
        "begin_line": 406,
        "end_line": 420,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009000900090009,
            "pseudo_dstar_susp": 0.0009746588693957114,
            "pseudo_tarantula_susp": 0.0009017132551848512,
            "pseudo_op2_susp": 0.0009746588693957114,
            "pseudo_barinel_susp": 0.0009017132551848512
        }
    },
    {
        "name": "luigi.worker.Worker.__enter__#422",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker.__enter__(self)",
        "snippet": "    def __enter__(self):\n        \"\"\"\n        Start the KeepAliveThread.\n        \"\"\"\n        self._keep_alive_thread = KeepAliveThread(self._scheduler, self._id, self._config.ping_interval)\n        self._keep_alive_thread.daemon = True\n        self._keep_alive_thread.start()\n        return self",
        "begin_line": 422,
        "end_line": 429,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014204545454545455,
            "pseudo_dstar_susp": 0.0017699115044247787,
            "pseudo_tarantula_susp": 0.0014534883720930232,
            "pseudo_op2_susp": 0.0017699115044247787,
            "pseudo_barinel_susp": 0.0014534883720930232
        }
    },
    {
        "name": "luigi.worker.Worker.__exit__#431",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker.__exit__(self, type, value, traceback)",
        "snippet": "    def __exit__(self, type, value, traceback):\n        \"\"\"\n        Stop the KeepAliveThread and kill still running tasks.\n        \"\"\"\n        self._keep_alive_thread.stop()\n        self._keep_alive_thread.join()\n        for task in self._running_tasks.values():\n            if task.is_alive():\n                task.terminate()\n        return False  # Don't suppress exception",
        "begin_line": 431,
        "end_line": 440,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014204545454545455,
            "pseudo_dstar_susp": 0.0017699115044247787,
            "pseudo_tarantula_susp": 0.0014534883720930232,
            "pseudo_op2_susp": 0.0017699115044247787,
            "pseudo_barinel_susp": 0.0014534883720930232
        }
    },
    {
        "name": "luigi.worker.Worker._generate_worker_info#442",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._generate_worker_info(self)",
        "snippet": "    def _generate_worker_info(self):\n        # Generate as much info as possible about the worker\n        # Some of these calls might not be available on all OS's\n        args = [('salt', '%09d' % random.randrange(0, 999999999)),\n                ('workers', self.worker_processes)]\n        try:\n            args += [('host', socket.gethostname())]\n        except BaseException:\n            pass\n        try:\n            args += [('username', getpass.getuser())]\n        except BaseException:\n            pass\n        try:\n            args += [('pid', os.getpid())]\n        except BaseException:\n            pass\n        try:\n            sudo_user = os.getenv(\"SUDO_USER\")\n            if sudo_user:\n                args.append(('sudo_user', sudo_user))\n        except BaseException:\n            pass\n        return args",
        "begin_line": 442,
        "end_line": 465,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016556291390728477,
            "pseudo_dstar_susp": 0.003115264797507788,
            "pseudo_tarantula_susp": 0.0016474464579901153,
            "pseudo_op2_susp": 0.003115264797507788,
            "pseudo_barinel_susp": 0.0016474464579901153
        }
    },
    {
        "name": "luigi.worker.Worker._validate_task#467",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._validate_task(self, task)",
        "snippet": "    def _validate_task(self, task):\n        if not isinstance(task, Task):\n            raise TaskException('Can not schedule non-task %s' % task)\n\n        if not task.initialized():\n            # we can't get the repr of it since it's not initialized...\n            raise TaskException('Task of class %s not initialized. Did you override __init__ and forget to call super(...).__init__?' % task.__class__.__name__)",
        "begin_line": 467,
        "end_line": 473,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012004801920768306,
            "pseudo_dstar_susp": 0.0014705882352941176,
            "pseudo_tarantula_susp": 0.0011467889908256881,
            "pseudo_op2_susp": 0.0014705882352941176,
            "pseudo_barinel_susp": 0.0011467889908256881
        }
    },
    {
        "name": "luigi.worker.Worker._log_complete_error#475",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._log_complete_error(self, task, tb)",
        "snippet": "    def _log_complete_error(self, task, tb):\n        log_msg = \"Will not schedule {task} or any dependencies due to error in complete() method:\\n{tb}\".format(task=task, tb=tb)\n        logger.warning(log_msg)",
        "begin_line": 475,
        "end_line": 477,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002937720329024677,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.worker.Worker._log_dependency_error#479",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._log_dependency_error(self, task, tb)",
        "snippet": "    def _log_dependency_error(self, task, tb):\n        log_msg = \"Will not schedule {task} or any dependencies due to error in deps() method:\\n{tb}\".format(task=task, tb=tb)\n        logger.warning(log_msg)",
        "begin_line": 479,
        "end_line": 481,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002544529262086514,
            "pseudo_dstar_susp": 0.0009199632014719411,
            "pseudo_tarantula_susp": 0.0058823529411764705,
            "pseudo_op2_susp": 0.0009199632014719411,
            "pseudo_barinel_susp": 0.0058823529411764705
        }
    },
    {
        "name": "luigi.worker.Worker._log_unexpected_error#483",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._log_unexpected_error(self, task)",
        "snippet": "    def _log_unexpected_error(self, task):\n        logger.exception(\"Luigi unexpected framework error while scheduling %s\", task)  # needs to be called from within except clause",
        "begin_line": 483,
        "end_line": 484,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.worker.Worker._email_complete_error#486",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._email_complete_error(self, task, formatted_traceback)",
        "snippet": "    def _email_complete_error(self, task, formatted_traceback):\n        self._email_error(task, formatted_traceback,\n                          subject=\"Luigi: {task} failed scheduling. Host: {host}\",\n                          headline=\"Will not schedule task or any dependencies due to error in complete() method\",\n                          )",
        "begin_line": 486,
        "end_line": 490,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002937720329024677,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.worker.Worker._email_dependency_error#492",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._email_dependency_error(self, task, formatted_traceback)",
        "snippet": "    def _email_dependency_error(self, task, formatted_traceback):\n        self._email_error(task, formatted_traceback,\n                          subject=\"Luigi: {task} failed scheduling. Host: {host}\",\n                          headline=\"Will not schedule task or any dependencies due to error in deps() method\",\n                          )",
        "begin_line": 492,
        "end_line": 496,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002544529262086514,
            "pseudo_dstar_susp": 0.0009199632014719411,
            "pseudo_tarantula_susp": 0.0058823529411764705,
            "pseudo_op2_susp": 0.0009199632014719411,
            "pseudo_barinel_susp": 0.0058823529411764705
        }
    },
    {
        "name": "luigi.worker.Worker._email_unexpected_error#498",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._email_unexpected_error(self, task, formatted_traceback)",
        "snippet": "    def _email_unexpected_error(self, task, formatted_traceback):\n        self._email_error(task, formatted_traceback,\n                          subject=\"Luigi: Framework error while scheduling {task}. Host: {host}\",\n                          headline=\"Luigi framework error\",\n                          )",
        "begin_line": 498,
        "end_line": 502,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.worker.Worker._email_task_failure#504",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._email_task_failure(self, task, formatted_traceback)",
        "snippet": "    def _email_task_failure(self, task, formatted_traceback):\n        self._email_error(task, formatted_traceback,\n                          subject=\"Luigi: {task} FAILED. Host: {host}\",\n                          headline=\"A task failed when running. Most likely run() raised an exception.\",\n                          )",
        "begin_line": 504,
        "end_line": 508,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009149130832570906,
            "pseudo_dstar_susp": 0.0008733624454148472,
            "pseudo_tarantula_susp": 0.002127659574468085,
            "pseudo_op2_susp": 0.0008733624454148472,
            "pseudo_barinel_susp": 0.002127659574468085
        }
    },
    {
        "name": "luigi.worker.Worker._email_error#510",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._email_error(self, task, formatted_traceback, subject, headline)",
        "snippet": "    def _email_error(self, task, formatted_traceback, subject, headline):\n        formatted_subject = subject.format(task=task, host=self.host)\n        message = notifications.format_task_error(headline, task, formatted_traceback)\n        notifications.send_error_email(formatted_subject, message, task.owner_email)",
        "begin_line": 510,
        "end_line": 513,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015772870662460567,
            "pseudo_dstar_susp": 0.0010570824524312897,
            "pseudo_tarantula_susp": 0.0026041666666666665,
            "pseudo_op2_susp": 0.0010570824524312897,
            "pseudo_barinel_susp": 0.0026041666666666665
        }
    },
    {
        "name": "luigi.worker.Worker.add#515",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker.add(self, task, multiprocess=False)",
        "snippet": "    def add(self, task, multiprocess=False):\n        \"\"\"\n        Add a Task for the worker to check and possibly schedule and run.\n\n        Returns True if task and its dependencies were successfully scheduled or completed before.\n        \"\"\"\n        if self._first_task is None and hasattr(task, 'task_id'):\n            self._first_task = task.task_id\n        self.add_succeeded = True\n        if multiprocess:\n            queue = multiprocessing.Manager().Queue()\n            pool = multiprocessing.Pool()\n        else:\n            queue = DequeQueue()\n            pool = SingleProcessPool()\n        self._validate_task(task)\n        pool.apply_async(check_complete, [task, queue])\n\n        # we track queue size ourselves because len(queue) won't work for multiprocessing\n        queue_size = 1\n        try:\n            seen = set([task.task_id])\n            while queue_size:\n                current = queue.get()\n                queue_size -= 1\n                item, is_complete = current\n                for next in self._add(item, is_complete):\n                    if next.task_id not in seen:\n                        self._validate_task(next)\n                        seen.add(next.task_id)\n                        pool.apply_async(check_complete, [next, queue])\n                        queue_size += 1\n        except (KeyboardInterrupt, TaskException):\n            raise\n        except Exception as ex:\n            self.add_succeeded = False\n            formatted_traceback = traceback.format_exc()\n            self._log_unexpected_error(task)\n            task.trigger_event(Event.BROKEN_TASK, task, ex)\n            self._email_unexpected_error(task, formatted_traceback)\n        finally:\n            pool.close()\n            pool.join()\n        return self.add_succeeded",
        "begin_line": 515,
        "end_line": 558,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012422360248447205,
            "pseudo_dstar_susp": 0.001524390243902439,
            "pseudo_tarantula_susp": 0.0011792452830188679,
            "pseudo_op2_susp": 0.001524390243902439,
            "pseudo_barinel_susp": 0.0011792452830188679
        }
    },
    {
        "name": "luigi.worker.Worker._add#560",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._add(self, task, is_complete)",
        "snippet": "    def _add(self, task, is_complete):\n        if self._config.task_limit is not None and len(self._scheduled_tasks) >= self._config.task_limit:\n            logger.warning('Will not schedule %s or any dependencies due to exceeded task-limit of %d', task, self._config.task_limit)\n            return\n\n        formatted_traceback = None\n        try:\n            self._check_complete_value(is_complete)\n        except KeyboardInterrupt:\n            raise\n        except AsyncCompletionException as ex:\n            formatted_traceback = ex.trace\n        except BaseException:\n            formatted_traceback = traceback.format_exc()\n\n        if formatted_traceback is not None:\n            self.add_succeeded = False\n            self._log_complete_error(task, formatted_traceback)\n            task.trigger_event(Event.DEPENDENCY_MISSING, task)\n            self._email_complete_error(task, formatted_traceback)\n            # abort, i.e. don't schedule any subtasks of a task with\n            # failing complete()-method since we don't know if the task\n            # is complete and subtasks might not be desirable to run if\n            # they have already ran before\n            return\n\n        if is_complete:\n            deps = None\n            status = DONE\n            runnable = False\n\n            task.trigger_event(Event.DEPENDENCY_PRESENT, task)\n        elif task.run == NotImplemented:\n            deps = None\n            status = PENDING\n            runnable = worker().retry_external_tasks\n\n            task.trigger_event(Event.DEPENDENCY_MISSING, task)\n            logger.warning('Data for %s does not exist (yet?). The task is an '\n                           'external data depedency, so it can not be run from'\n                           ' this luigi process.', task)\n\n        else:\n            try:\n                deps = task.deps()\n            except Exception as ex:\n                formatted_traceback = traceback.format_exc()\n                self.add_succeeded = False\n                self._log_dependency_error(task, formatted_traceback)\n                task.trigger_event(Event.BROKEN_TASK, task, ex)\n                self._email_dependency_error(task, formatted_traceback)\n                return\n            status = PENDING\n            runnable = True\n\n        if task.disabled:\n            status = DISABLED\n\n        if deps:\n            for d in deps:\n                self._validate_dependency(d)\n                task.trigger_event(Event.DEPENDENCY_DISCOVERED, task, d)\n                yield d  # return additional tasks to add\n\n            deps = [d.task_id for d in deps]\n\n        self._scheduled_tasks[task.task_id] = task\n        self._add_task(worker=self._id, task_id=task.task_id, status=status,\n                       deps=deps, runnable=runnable, priority=task.priority,\n                       resources=task.process_resources(),\n                       params=task.to_str_params(),\n                       family=task.task_family,\n                       module=task.task_module)",
        "begin_line": 560,
        "end_line": 632,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002544529262086514,
            "pseudo_dstar_susp": 0.0015527950310559005,
            "pseudo_tarantula_susp": 0.0058823529411764705,
            "pseudo_op2_susp": 0.0015527950310559005,
            "pseudo_barinel_susp": 0.0058823529411764705
        }
    },
    {
        "name": "luigi.worker.Worker._validate_dependency#634",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._validate_dependency(self, dependency)",
        "snippet": "    def _validate_dependency(self, dependency):\n        if isinstance(dependency, Target):\n            raise Exception('requires() can not return Target objects. Wrap it in an ExternalTask class')\n        elif not isinstance(dependency, Task):\n            raise Exception('requires() must return Task objects')",
        "begin_line": 634,
        "end_line": 638,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00022893772893772894,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.worker.Worker._check_complete_value#640",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._check_complete_value(self, is_complete)",
        "snippet": "    def _check_complete_value(self, is_complete):\n        if is_complete not in (True, False):\n            if isinstance(is_complete, TracebackWrapper):\n                raise AsyncCompletionException(is_complete.trace)\n            raise Exception(\"Return value of Task.complete() must be boolean (was %r)\" % is_complete)",
        "begin_line": 640,
        "end_line": 644,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012254901960784314,
            "pseudo_dstar_susp": 0.0014992503748125937,
            "pseudo_tarantula_susp": 0.0011641443538998836,
            "pseudo_op2_susp": 0.0014992503748125937,
            "pseudo_barinel_susp": 0.0011641443538998836
        }
    },
    {
        "name": "luigi.worker.Worker._add_worker#646",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._add_worker(self)",
        "snippet": "    def _add_worker(self):\n        self._worker_info.append(('first_task', self._first_task))\n        self._scheduler.add_worker(self._id, self._worker_info)",
        "begin_line": 646,
        "end_line": 648,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012970168612191958,
            "pseudo_dstar_susp": 0.001607717041800643,
            "pseudo_tarantula_susp": 0.0012755102040816326,
            "pseudo_op2_susp": 0.001607717041800643,
            "pseudo_barinel_susp": 0.0012755102040816326
        }
    },
    {
        "name": "luigi.worker.Worker._log_remote_tasks#650",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._log_remote_tasks(self, running_tasks, n_pending_tasks, n_unique_pending)",
        "snippet": "    def _log_remote_tasks(self, running_tasks, n_pending_tasks, n_unique_pending):\n        logger.debug(\"Done\")\n        logger.debug(\"There are no more tasks to run at this time\")\n        if running_tasks:\n            for r in running_tasks:\n                logger.debug('%s is currently run by worker %s', r['task_id'], r['worker'])\n        elif n_pending_tasks:\n            logger.debug(\"There are %s pending tasks possibly being run by other workers\", n_pending_tasks)\n            if n_unique_pending:\n                logger.debug(\"There are %i pending tasks unique to this worker\", n_unique_pending)",
        "begin_line": 650,
        "end_line": 659,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013812154696132596,
            "pseudo_dstar_susp": 0.0017241379310344827,
            "pseudo_tarantula_susp": 0.00141643059490085,
            "pseudo_op2_susp": 0.0017241379310344827,
            "pseudo_barinel_susp": 0.00141643059490085
        }
    },
    {
        "name": "luigi.worker.Worker._get_work#661",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._get_work(self)",
        "snippet": "    def _get_work(self):\n        if self._stop_requesting_work:\n            return None, 0, 0, 0\n        logger.debug(\"Asking scheduler for work...\")\n        r = self._scheduler.get_work(\n            worker=self._id,\n            host=self.host,\n            assistant=self._assistant,\n            current_tasks=list(self._running_tasks.keys()),\n        )\n        n_pending_tasks = r['n_pending_tasks']\n        task_id = r['task_id']\n        running_tasks = r['running_tasks']\n        n_unique_pending = r['n_unique_pending']\n\n        self._get_work_response_history.append(dict(\n            task_id=task_id,\n            running_tasks=running_tasks,\n        ))\n\n        if task_id is not None and task_id not in self._scheduled_tasks:\n            logger.info('Did not schedule %s, will load it dynamically', task_id)\n\n            try:\n                # TODO: we should obtain the module name from the server!\n                self._scheduled_tasks[task_id] = \\\n                    load_task(module=r.get('task_module'),\n                              task_name=r['task_family'],\n                              params_str=r['task_params'])\n            except TaskClassException as ex:\n                msg = 'Cannot find task for %s' % task_id\n                logger.exception(msg)\n                subject = 'Luigi: %s' % msg\n                error_message = notifications.wrap_traceback(ex)\n                notifications.send_error_email(subject, error_message)\n                self._add_task(worker=self._id, task_id=task_id, status=FAILED, runnable=False,\n                               assistant=self._assistant)\n                task_id = None\n                self.run_succeeded = False\n\n        return task_id, running_tasks, n_pending_tasks, n_unique_pending",
        "begin_line": 661,
        "end_line": 701,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013280212483399733,
            "pseudo_dstar_susp": 0.0016556291390728477,
            "pseudo_tarantula_susp": 0.0013698630136986301,
            "pseudo_op2_susp": 0.0016556291390728477,
            "pseudo_barinel_susp": 0.0013698630136986301
        }
    },
    {
        "name": "luigi.worker.Worker._run_task#703",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._run_task(self, task_id)",
        "snippet": "    def _run_task(self, task_id):\n        task = self._scheduled_tasks[task_id]\n\n        p = self._create_task_process(task)\n\n        self._running_tasks[task_id] = p\n\n        if self.worker_processes > 1:\n            with fork_lock:\n                p.start()\n        else:\n            # Run in the same process\n            p.run()",
        "begin_line": 703,
        "end_line": 715,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007374631268436578,
            "pseudo_dstar_susp": 0.0007374631268436578,
            "pseudo_tarantula_susp": 0.0007401924500370096,
            "pseudo_op2_susp": 0.0007374631268436578,
            "pseudo_barinel_susp": 0.0007401924500370096
        }
    },
    {
        "name": "luigi.worker.Worker._create_task_process#717",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._create_task_process(self, task)",
        "snippet": "    def _create_task_process(self, task):\n        def update_tracking_url(tracking_url):\n            self._scheduler.add_task(\n                task_id=task.task_id,\n                worker=self._id,\n                status=RUNNING,\n                tracking_url=tracking_url,\n            )\n\n        return TaskProcess(\n            task, self._id, self._task_result_queue,\n            random_seed=bool(self.worker_processes > 1),\n            worker_timeout=self._config.timeout,\n            tracking_url_callback=update_tracking_url,\n        )",
        "begin_line": 717,
        "end_line": 731,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007012622720897616,
            "pseudo_dstar_susp": 0.0007012622720897616,
            "pseudo_tarantula_susp": 0.0007012622720897616,
            "pseudo_op2_susp": 0.0007012622720897616,
            "pseudo_barinel_susp": 0.0007012622720897616
        }
    },
    {
        "name": "luigi.worker.Worker.update_tracking_url#718",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker.update_tracking_url(tracking_url)",
        "snippet": "        def update_tracking_url(tracking_url):\n            self._scheduler.add_task(\n                task_id=task.task_id,\n                worker=self._id,\n                status=RUNNING,\n                tracking_url=tracking_url,\n            )",
        "begin_line": 718,
        "end_line": 724,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006983240223463687,
            "pseudo_dstar_susp": 0.0006983240223463687,
            "pseudo_tarantula_susp": 0.0006983240223463687,
            "pseudo_op2_susp": 0.0006983240223463687,
            "pseudo_barinel_susp": 0.0006983240223463687
        }
    },
    {
        "name": "luigi.worker.Worker._purge_children#733",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._purge_children(self)",
        "snippet": "    def _purge_children(self):\n        \"\"\"\n        Find dead children and put a response on the result queue.\n\n        :return:\n        \"\"\"\n        for task_id, p in six.iteritems(self._running_tasks):\n            if not p.is_alive() and p.exitcode:\n                error_msg = 'Task %s died unexpectedly with exit code %s' % (task_id, p.exitcode)\n            elif p.timeout_time is not None and time.time() > float(p.timeout_time) and p.is_alive():\n                p.terminate()\n                error_msg = 'Task %s timed out and was terminated.' % task_id\n            else:\n                continue\n\n            logger.info(error_msg)\n            self._task_result_queue.put((task_id, FAILED, error_msg, [], []))",
        "begin_line": 733,
        "end_line": 749,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007199424046076314,
            "pseudo_dstar_susp": 0.0007199424046076314,
            "pseudo_tarantula_susp": 0.0007199424046076314,
            "pseudo_op2_susp": 0.0007199424046076314,
            "pseudo_barinel_susp": 0.0007199424046076314
        }
    },
    {
        "name": "luigi.worker.Worker._handle_next_task#751",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._handle_next_task(self)",
        "snippet": "    def _handle_next_task(self):\n        \"\"\"\n        We have to catch three ways a task can be \"done\":\n\n        1. normal execution: the task runs/fails and puts a result back on the queue,\n        2. new dependencies: the task yielded new deps that were not complete and\n           will be rescheduled and dependencies added,\n        3. child process dies: we need to catch this separately.\n        \"\"\"\n        while True:\n            self._purge_children()  # Deal with subprocess failures\n\n            try:\n                task_id, status, expl, missing, new_requirements = (\n                    self._task_result_queue.get(\n                        timeout=self._config.wait_interval))\n            except Queue.Empty:\n                return\n\n            task = self._scheduled_tasks[task_id]\n            if not task or task_id not in self._running_tasks:\n                continue\n                # Not a running task. Probably already removed.\n                # Maybe it yielded something?\n\n            # external task if run not implemented, retry-able if config option is enabled.\n            external_task_retryable = task.run == NotImplemented and self._config.retry_external_tasks\n            if status == FAILED and not external_task_retryable:\n                self._email_task_failure(task, expl)\n\n            new_deps = []\n            if new_requirements:\n                new_req = [load_task(module, name, params)\n                           for module, name, params in new_requirements]\n                for t in new_req:\n                    self.add(t)\n                new_deps = [t.task_id for t in new_req]\n\n            self._add_task(worker=self._id,\n                           task_id=task_id,\n                           status=status,\n                           expl=json.dumps(expl),\n                           resources=task.process_resources(),\n                           runnable=None,\n                           params=task.to_str_params(),\n                           family=task.task_family,\n                           module=task.task_module,\n                           new_deps=new_deps,\n                           assistant=self._assistant)\n\n            self._running_tasks.pop(task_id)\n\n            # re-add task to reschedule missing dependencies\n            if missing:\n                reschedule = True\n\n                # keep out of infinite loops by not rescheduling too many times\n                for task_id in missing:\n                    self.unfulfilled_counts[task_id] += 1\n                    if (self.unfulfilled_counts[task_id] >\n                            self._config.max_reschedules):\n                        reschedule = False\n                if reschedule:\n                    self.add(task)\n\n            self.run_succeeded &= (status == DONE) or (len(new_deps) > 0)\n            return",
        "begin_line": 751,
        "end_line": 817,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009149130832570906,
            "pseudo_dstar_susp": 0.0008733624454148472,
            "pseudo_tarantula_susp": 0.002127659574468085,
            "pseudo_op2_susp": 0.0008733624454148472,
            "pseudo_barinel_susp": 0.002127659574468085
        }
    },
    {
        "name": "luigi.worker.Worker._sleeper#819",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._sleeper(self)",
        "snippet": "    def _sleeper(self):\n        # TODO is exponential backoff necessary?\n        while True:\n            jitter = self._config.wait_jitter\n            wait_interval = self._config.wait_interval + random.uniform(0, jitter)\n            logger.debug('Sleeping for %f seconds', wait_interval)\n            time.sleep(wait_interval)\n            yield",
        "begin_line": 819,
        "end_line": 826,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013550135501355014,
            "pseudo_dstar_susp": 0.001697792869269949,
            "pseudo_tarantula_susp": 0.0013986013986013986,
            "pseudo_op2_susp": 0.001697792869269949,
            "pseudo_barinel_susp": 0.0013986013986013986
        }
    },
    {
        "name": "luigi.worker.Worker._keep_alive#828",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._keep_alive(self, n_pending_tasks, n_unique_pending)",
        "snippet": "    def _keep_alive(self, n_pending_tasks, n_unique_pending):\n        \"\"\"\n        Returns true if a worker should stay alive given.\n\n        If worker-keep-alive is not set, this will always return false.\n        For an assistant, it will always return the value of worker-keep-alive.\n        Otherwise, it will return true for nonzero n_pending_tasks.\n\n        If worker-count-uniques is true, it will also\n        require that one of the tasks is unique to this worker.\n        \"\"\"\n        if not self._config.keep_alive:\n            return False\n        elif self._assistant:\n            return True\n        else:\n            return n_pending_tasks and (n_unique_pending or not self._config.count_uniques)",
        "begin_line": 828,
        "end_line": 844,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013679890560875513,
            "pseudo_dstar_susp": 0.0017152658662092624,
            "pseudo_tarantula_susp": 0.0014104372355430183,
            "pseudo_op2_susp": 0.0017152658662092624,
            "pseudo_barinel_susp": 0.0014104372355430183
        }
    },
    {
        "name": "luigi.worker.Worker.handle_interrupt#846",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker.handle_interrupt(self, signum, _)",
        "snippet": "    def handle_interrupt(self, signum, _):\n        \"\"\"\n        Stops the assistant from asking for more work on SIGUSR1\n        \"\"\"\n        if signum == signal.SIGUSR1:\n            self._config.keep_alive = False\n            self._stop_requesting_work = True",
        "begin_line": 846,
        "end_line": 852,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.worker.Worker.run#854",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker.run(self)",
        "snippet": "    def run(self):\n        \"\"\"\n        Returns True if all scheduled tasks were executed successfully.\n        \"\"\"\n        logger.info('Running Worker with %d processes', self.worker_processes)\n\n        sleeper = self._sleeper()\n        self.run_succeeded = True\n\n        self._add_worker()\n\n        while True:\n            while len(self._running_tasks) >= self.worker_processes:\n                logger.debug('%d running tasks, waiting for next task to finish', len(self._running_tasks))\n                self._handle_next_task()\n\n            task_id, running_tasks, n_pending_tasks, n_unique_pending = self._get_work()\n\n            if task_id is None:\n                if not self._stop_requesting_work:\n                    self._log_remote_tasks(running_tasks, n_pending_tasks, n_unique_pending)\n                if len(self._running_tasks) == 0:\n                    if self._keep_alive(n_pending_tasks, n_unique_pending):\n                        six.next(sleeper)\n                        continue\n                    else:\n                        break\n                else:\n                    self._handle_next_task()\n                    continue\n\n            # task_id is not None:\n            logger.debug(\"Pending tasks: %s\", n_pending_tasks)\n            self._run_task(task_id)\n\n        while len(self._running_tasks):\n            logger.debug('Shut down Worker, %d more tasks to go', len(self._running_tasks))\n            self._handle_next_task()\n\n        return self.run_succeeded",
        "begin_line": 854,
        "end_line": 893,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013550135501355014,
            "pseudo_dstar_susp": 0.001697792869269949,
            "pseudo_tarantula_susp": 0.0013986013986013986,
            "pseudo_op2_susp": 0.001697792869269949,
            "pseudo_barinel_susp": 0.0013986013986013986
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.__init__#67",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.__init__(self)",
        "snippet": "    def __init__(self):\n        conf = luigi.configuration.get_config()\n\n        default = os.environ.get('SCALA_HOME', '/usr/share/scala')\n        self.scala_home = conf.get('scalding', 'scala-home', default)\n\n        default = os.environ.get('SCALDING_HOME', '/usr/share/scalding')\n        self.scalding_home = conf.get('scalding', 'scalding-home', default)\n        self.provided_dir = conf.get(\n            'scalding', 'scalding-provided', os.path.join(default, 'provided'))\n        self.libjars_dir = conf.get(\n            'scalding', 'scalding-libjars', os.path.join(default, 'libjars'))\n\n        self.tmp_dir = LocalTarget(is_tmp=True)",
        "begin_line": 67,
        "end_line": 80,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner._get_jars#82",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner._get_jars(self, path)",
        "snippet": "    def _get_jars(self, path):\n        return [os.path.join(path, j) for j in os.listdir(path)\n                if j.endswith('.jar')]",
        "begin_line": 82,
        "end_line": 84,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.get_scala_jars#86",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.get_scala_jars(self, include_compiler=False)",
        "snippet": "    def get_scala_jars(self, include_compiler=False):\n        lib_dir = os.path.join(self.scala_home, 'lib')\n        jars = [os.path.join(lib_dir, 'scala-library.jar')]\n\n        # additional jar for scala 2.10 only\n        reflect = os.path.join(lib_dir, 'scala-reflect.jar')\n        if os.path.exists(reflect):\n            jars.append(reflect)\n\n        if include_compiler:\n            jars.append(os.path.join(lib_dir, 'scala-compiler.jar'))\n\n        return jars",
        "begin_line": 86,
        "end_line": 98,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.get_scalding_jars#100",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.get_scalding_jars(self)",
        "snippet": "    def get_scalding_jars(self):\n        lib_dir = os.path.join(self.scalding_home, 'lib')\n        return self._get_jars(lib_dir)",
        "begin_line": 100,
        "end_line": 102,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.get_scalding_core#104",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.get_scalding_core(self)",
        "snippet": "    def get_scalding_core(self):\n        lib_dir = os.path.join(self.scalding_home, 'lib')\n        for j in os.listdir(lib_dir):\n            if j.startswith('scalding-core-'):\n                p = os.path.join(lib_dir, j)\n                logger.debug('Found scalding-core: %s', p)\n                return p\n        raise luigi.contrib.hadoop.HadoopJobError('Could not find scalding-core.')",
        "begin_line": 104,
        "end_line": 111,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.get_provided_jars#113",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.get_provided_jars(self)",
        "snippet": "    def get_provided_jars(self):\n        return self._get_jars(self.provided_dir)",
        "begin_line": 113,
        "end_line": 114,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.get_libjars#116",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.get_libjars(self)",
        "snippet": "    def get_libjars(self):\n        return self._get_jars(self.libjars_dir)",
        "begin_line": 116,
        "end_line": 117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.get_tmp_job_jar#119",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.get_tmp_job_jar(self, source)",
        "snippet": "    def get_tmp_job_jar(self, source):\n        job_name = os.path.basename(os.path.splitext(source)[0])\n        return os.path.join(self.tmp_dir.path, job_name + '.jar')",
        "begin_line": 119,
        "end_line": 121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.get_build_dir#123",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.get_build_dir(self, source)",
        "snippet": "    def get_build_dir(self, source):\n        build_dir = os.path.join(self.tmp_dir.path, 'build')\n        return build_dir",
        "begin_line": 123,
        "end_line": 125,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.get_job_class#127",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.get_job_class(self, source)",
        "snippet": "    def get_job_class(self, source):\n        # find name of the job class\n        # usually the one that matches file name or last class that extends Job\n        job_name = os.path.splitext(os.path.basename(source))[0]\n        package = None\n        job_class = None\n        for l in open(source).readlines():\n            p = re.search(r'package\\s+([^\\s\\(]+)', l)\n            if p:\n                package = p.groups()[0]\n            p = re.search(r'class\\s+([^\\s\\(]+).*extends\\s+.*Job', l)\n            if p:\n                job_class = p.groups()[0]\n                if job_class == job_name:\n                    break\n        if job_class:\n            if package:\n                job_class = package + '.' + job_class\n            logger.debug('Found scalding job class: %s', job_class)\n            return job_class\n        else:\n            raise luigi.contrib.hadoop.HadoopJobError('Coudl not find scalding job class.')",
        "begin_line": 127,
        "end_line": 148,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.build_job_jar#150",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.build_job_jar(self, job)",
        "snippet": "    def build_job_jar(self, job):\n        job_jar = job.jar()\n        if job_jar:\n            if not os.path.exists(job_jar):\n                logger.error(\"Can't find jar: %s, full path %s\", job_jar, os.path.abspath(job_jar))\n                raise Exception(\"job jar does not exist\")\n            if not job.job_class():\n                logger.error(\"Undefined job_class()\")\n                raise Exception(\"Undefined job_class()\")\n            return job_jar\n\n        job_src = job.source()\n        if not job_src:\n            logger.error(\"Both source() and jar() undefined\")\n            raise Exception(\"Both source() and jar() undefined\")\n        if not os.path.exists(job_src):\n            logger.error(\"Can't find source: %s, full path %s\", job_src, os.path.abspath(job_src))\n            raise Exception(\"job source does not exist\")\n\n        job_src = job.source()\n        job_jar = self.get_tmp_job_jar(job_src)\n\n        build_dir = self.get_build_dir(job_src)\n        if not os.path.exists(build_dir):\n            os.makedirs(build_dir)\n\n        classpath = ':'.join(filter(None,\n                                    self.get_scalding_jars() +\n                                    self.get_provided_jars() +\n                                    self.get_libjars() +\n                                    job.extra_jars()))\n        scala_cp = ':'.join(self.get_scala_jars(include_compiler=True))\n\n        # compile scala source\n        arglist = ['java', '-cp', scala_cp, 'scala.tools.nsc.Main',\n                   '-classpath', classpath,\n                   '-d', build_dir, job_src]\n        logger.info('Compiling scala source: %s', subprocess.list2cmdline(arglist))\n        subprocess.check_call(arglist)\n\n        # build job jar file\n        arglist = ['jar', 'cf', job_jar, '-C', build_dir, '.']\n        logger.info('Building job jar: %s', subprocess.list2cmdline(arglist))\n        subprocess.check_call(arglist)\n        return job_jar",
        "begin_line": 150,
        "end_line": 194,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.run_job#196",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.run_job(self, job, tracking_url_callback=None)",
        "snippet": "    def run_job(self, job, tracking_url_callback=None):\n        job_jar = self.build_job_jar(job)\n        jars = [job_jar] + self.get_libjars() + job.extra_jars()\n        scalding_core = self.get_scalding_core()\n        libjars = ','.join(filter(None, jars))\n        arglist = luigi.contrib.hdfs.load_hadoop_cmd() + ['jar', scalding_core, '-libjars', libjars]\n        arglist += ['-D%s' % c for c in job.jobconfs()]\n\n        job_class = job.job_class() or self.get_job_class(job.source())\n        arglist += [job_class, '--hdfs']\n\n        # scalding does not parse argument with '=' properly\n        arglist += ['--name', job.task_id.replace('=', ':')]\n\n        (tmp_files, job_args) = luigi.contrib.hadoop_jar.fix_paths(job)\n        arglist += job_args\n\n        env = os.environ.copy()\n        jars.append(scalding_core)\n        hadoop_cp = ':'.join(filter(None, jars))\n        env['HADOOP_CLASSPATH'] = hadoop_cp\n        logger.info(\"Submitting Hadoop job: HADOOP_CLASSPATH=%s %s\",\n                    hadoop_cp, subprocess.list2cmdline(arglist))\n        luigi.contrib.hadoop.run_and_track_hadoop_job(arglist, tracking_url_callback, env=env)\n\n        for a, b in tmp_files:\n            a.move(b)",
        "begin_line": 196,
        "end_line": 222,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobTask.jar#256",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobTask",
        "signature": "luigi.contrib.scalding.ScaldingJobTask.jar(self)",
        "snippet": "    def jar(self):\n        \"\"\"\n        Path to the jar file for this Scalding Job\n\n        Either one of source() or jar() must be specified.\n        \"\"\"\n        return None",
        "begin_line": 256,
        "end_line": 262,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobTask.extra_jars#264",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobTask",
        "signature": "luigi.contrib.scalding.ScaldingJobTask.extra_jars(self)",
        "snippet": "    def extra_jars(self):\n        \"\"\"\n        Extra jars for building and running this Scalding Job.\n        \"\"\"\n        return []",
        "begin_line": 264,
        "end_line": 268,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobTask.job_class#270",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobTask",
        "signature": "luigi.contrib.scalding.ScaldingJobTask.job_class(self)",
        "snippet": "    def job_class(self):\n        \"\"\"\n        optional main job class for this Scalding Job.\n        \"\"\"\n        return None",
        "begin_line": 270,
        "end_line": 274,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobTask.job_runner#276",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobTask",
        "signature": "luigi.contrib.scalding.ScaldingJobTask.job_runner(self)",
        "snippet": "    def job_runner(self):\n        return ScaldingJobRunner()",
        "begin_line": 276,
        "end_line": 277,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobTask.requires#286",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobTask",
        "signature": "luigi.contrib.scalding.ScaldingJobTask.requires(self)",
        "snippet": "    def requires(self):\n        return {}",
        "begin_line": 286,
        "end_line": 287,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobTask.job_args#289",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobTask",
        "signature": "luigi.contrib.scalding.ScaldingJobTask.job_args(self)",
        "snippet": "    def job_args(self):\n        \"\"\"\n        Extra arguments to pass to the Scalding job.\n        \"\"\"\n        return []",
        "begin_line": 289,
        "end_line": 293,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobTask.args#295",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobTask",
        "signature": "luigi.contrib.scalding.ScaldingJobTask.args(self)",
        "snippet": "    def args(self):\n        \"\"\"\n        Returns an array of args to pass to the job.\n        \"\"\"\n        arglist = []\n        for k, v in six.iteritems(self.requires_hadoop()):\n            arglist.append('--' + k)\n            arglist.extend([t.output().path for t in flatten(v)])\n        arglist.extend(['--output', self.output()])\n        arglist.extend(self.job_args())\n        return arglist",
        "begin_line": 295,
        "end_line": 305,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.server.RPCHandler.initialize#67",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server.RPCHandler",
        "signature": "luigi.server.RPCHandler.initialize(self, scheduler)",
        "snippet": "    def initialize(self, scheduler):\n        self._scheduler = scheduler",
        "begin_line": 67,
        "end_line": 68,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00023062730627306272,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.server.RPCHandler.get#70",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server.RPCHandler",
        "signature": "luigi.server.RPCHandler.get(self, method)",
        "snippet": "    def get(self, method):\n        payload = self.get_argument('data', default=\"{}\")\n        arguments = json.loads(payload)\n\n        # TODO: we should probably denote all methods on the scheduler that are \"API-level\"\n        # versus internal methods. Right now you can do a REST method call to any method\n        # defined on the scheduler, which is pretty bad from a security point of view.\n\n        if hasattr(self._scheduler, method):\n            result = getattr(self._scheduler, method)(**arguments)\n            self.write({\"response\": result})  # wrap all json response in a dictionary\n        else:\n            self.send_error(404)",
        "begin_line": 70,
        "end_line": 82,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.server.BaseTaskHistoryHandler.initialize#89",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server.BaseTaskHistoryHandler",
        "signature": "luigi.server.BaseTaskHistoryHandler.initialize(self, scheduler)",
        "snippet": "    def initialize(self, scheduler):\n        self._scheduler = scheduler",
        "begin_line": 89,
        "end_line": 90,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.server.from_utc#148",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server",
        "signature": "luigi.server.from_utc(utcTime, fmt=None)",
        "snippet": "def from_utc(utcTime, fmt=None):\n    \"\"\"convert UTC time string to time.struct_time: change datetime.datetime to time, return time.struct_time type\"\"\"\n    if fmt is None:\n        try_formats = [\"%Y-%m-%d %H:%M:%S.%f\", \"%Y-%m-%d %H:%M:%S\"]\n    else:\n        try_formats = [fmt]\n\n    for fmt in try_formats:\n        try:\n            time_struct = datetime.datetime.strptime(utcTime, fmt)\n        except ValueError:\n            pass\n        else:\n            date = int(time.mktime(time_struct.timetuple()))\n            return date\n    else:\n        raise ValueError(\"No UTC format matches {}\".format(utcTime))",
        "begin_line": 148,
        "end_line": 164,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.server.RootPathHandler.get#215",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server.RootPathHandler",
        "signature": "luigi.server.RootPathHandler.get(self)",
        "snippet": "    def get(self):\n        self.redirect(\"/static/visualiser/index.html\")",
        "begin_line": 215,
        "end_line": 216,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.server.app#219",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server",
        "signature": "luigi.server.app(scheduler)",
        "snippet": "def app(scheduler):\n    settings = {\"static_path\": os.path.join(os.path.dirname(__file__), \"static\"), \"unescape\": tornado.escape.xhtml_unescape}\n    handlers = [\n        (r'/api/(.*)', RPCHandler, {\"scheduler\": scheduler}),\n        (r'/static/(.*)', StaticFileHandler),\n        (r'/', RootPathHandler, {'scheduler': scheduler}),\n        (r'/tasklist', AllRunHandler, {'scheduler': scheduler}),\n        (r'/tasklist/(.*?)', SelectedRunHandler, {'scheduler': scheduler}),\n        (r'/history', RecentRunHandler, {'scheduler': scheduler}),\n        (r'/history/by_name/(.*?)', ByNameHandler, {'scheduler': scheduler}),\n        (r'/history/by_id/(.*?)', ByIdHandler, {'scheduler': scheduler}),\n        (r'/history/by_params/(.*?)', ByParamsHandler, {'scheduler': scheduler})\n    ]\n    api_app = tornado.web.Application(handlers, **settings)\n    return api_app",
        "begin_line": 219,
        "end_line": 233,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008453085376162299,
            "pseudo_dstar_susp": 0.0008453085376162299,
            "pseudo_tarantula_susp": 0.0008628127696289905,
            "pseudo_op2_susp": 0.0008453085376162299,
            "pseudo_barinel_susp": 0.0008628127696289905
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.fix_paths#32",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar",
        "signature": "luigi.contrib.hadoop_jar.fix_paths(job)",
        "snippet": "def fix_paths(job):\n    \"\"\"\n    Coerce input arguments to use temporary files when used for output.\n\n    Return a list of temporary file pairs (tmpfile, destination path) and\n    a list of arguments.\n\n    Converts each HdfsTarget to a string for the path.\n    \"\"\"\n    tmp_files = []\n    args = []\n    for x in job.args():\n        if isinstance(x, luigi.contrib.hdfs.HdfsTarget):  # input/output\n            if x.exists() or not job.atomic_output():  # input\n                args.append(x.path)\n            else:  # output\n                x_path_no_slash = x.path[:-1] if x.path[-1] == '/' else x.path\n                y = luigi.contrib.hdfs.HdfsTarget(x_path_no_slash + '-luigi-tmp-%09d' % random.randrange(0, 1e10))\n                tmp_files.append((y, x_path_no_slash))\n                logger.info('Using temp path: %s for path %s', y.path, x.path)\n                args.append(y.path)\n        else:\n            args.append(str(x))\n\n    return (tmp_files, args)",
        "begin_line": 32,
        "end_line": 56,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.HadoopJarJobRunner.__init__#68",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar.HadoopJarJobRunner",
        "signature": "luigi.contrib.hadoop_jar.HadoopJarJobRunner.__init__(self)",
        "snippet": "    def __init__(self):\n        pass",
        "begin_line": 68,
        "end_line": 69,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00032754667540124465,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.HadoopJarJobRunner.run_job#71",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar.HadoopJarJobRunner",
        "signature": "luigi.contrib.hadoop_jar.HadoopJarJobRunner.run_job(self, job, tracking_url_callback=None)",
        "snippet": "    def run_job(self, job, tracking_url_callback=None):\n        # TODO(jcrobak): libjars, files, etc. Can refactor out of\n        # hadoop.HadoopJobRunner\n        if not job.jar():\n            raise HadoopJarJobError(\"Jar not defined\")\n\n        hadoop_arglist = luigi.contrib.hdfs.load_hadoop_cmd() + ['jar', job.jar()]\n        if job.main():\n            hadoop_arglist.append(job.main())\n\n        jobconfs = job.jobconfs()\n\n        for jc in jobconfs:\n            hadoop_arglist += ['-D' + jc]\n\n        (tmp_files, job_args) = fix_paths(job)\n\n        hadoop_arglist += job_args\n\n        ssh_config = job.ssh()\n        if ssh_config:\n            host = ssh_config.get(\"host\", None)\n            key_file = ssh_config.get(\"key_file\", None)\n            username = ssh_config.get(\"username\", None)\n            if not host or not key_file or not username:\n                raise HadoopJarJobError(\"missing some config for HadoopRemoteJarJobRunner\")\n            arglist = ['ssh', '-i', key_file,\n                       '-o', 'BatchMode=yes']  # no password prompts etc\n            if ssh_config.get(\"no_host_key_check\", False):\n                arglist += ['-o', 'UserKnownHostsFile=/dev/null',\n                            '-o', 'StrictHostKeyChecking=no']\n            arglist.append('{}@{}'.format(username, host))\n            hadoop_arglist = [pipes.quote(arg) for arg in hadoop_arglist]\n            arglist.append(' '.join(hadoop_arglist))\n        else:\n            if not os.path.exists(job.jar()):\n                logger.error(\"Can't find jar: %s, full path %s\", job.jar(),\n                             os.path.abspath(job.jar()))\n                raise HadoopJarJobError(\"job jar does not exist\")\n            arglist = hadoop_arglist\n\n        luigi.contrib.hadoop.run_and_track_hadoop_job(arglist, tracking_url_callback)\n\n        for a, b in tmp_files:\n            a.move(b)",
        "begin_line": 71,
        "end_line": 115,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.HadoopJarJobTask.jar#123",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar.HadoopJarJobTask",
        "signature": "luigi.contrib.hadoop_jar.HadoopJarJobTask.jar(self)",
        "snippet": "    def jar(self):\n        \"\"\"\n        Path to the jar for this Hadoop Job.\n        \"\"\"\n        return None",
        "begin_line": 123,
        "end_line": 127,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.HadoopJarJobTask.main#129",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar.HadoopJarJobTask",
        "signature": "luigi.contrib.hadoop_jar.HadoopJarJobTask.main(self)",
        "snippet": "    def main(self):\n        \"\"\"\n        optional main method for this Hadoop Job.\n        \"\"\"\n        return None",
        "begin_line": 129,
        "end_line": 133,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.HadoopJarJobTask.job_runner#135",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar.HadoopJarJobTask",
        "signature": "luigi.contrib.hadoop_jar.HadoopJarJobTask.job_runner(self)",
        "snippet": "    def job_runner(self):\n        # We recommend that you define a subclass, override this method and set up your own config\n        return HadoopJarJobRunner()",
        "begin_line": 135,
        "end_line": 137,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00032754667540124465,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.HadoopJarJobTask.ssh#146",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar.HadoopJarJobTask",
        "signature": "luigi.contrib.hadoop_jar.HadoopJarJobTask.ssh(self)",
        "snippet": "    def ssh(self):\n        \"\"\"\n        Set this to run hadoop command remotely via ssh. It needs to be a dict that looks like\n        {\"host\": \"myhost\", \"key_file\": None, \"username\": None, [\"no_host_key_check\": False]}\n        \"\"\"\n        return None",
        "begin_line": 146,
        "end_line": 151,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.HadoopJarJobTask.args#153",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar.HadoopJarJobTask",
        "signature": "luigi.contrib.hadoop_jar.HadoopJarJobTask.args(self)",
        "snippet": "    def args(self):\n        \"\"\"\n        Returns an array of args to pass to the job (after hadoop jar <jar> <main>).\n        \"\"\"\n        return []",
        "begin_line": 153,
        "end_line": 157,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient.__init__#55",
        "src_path": "luigi/contrib/hdfs/webhdfs_client.py",
        "class_name": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient",
        "signature": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient.__init__(self, host=None, port=None, user=None)",
        "snippet": "    def __init__(self, host=None, port=None, user=None):\n        self.host = host or hdfs_config.hdfs().namenode_host\n        self.port = port or webhdfs().port\n        self.user = user or webhdfs().user or os.environ['USER']",
        "begin_line": 55,
        "end_line": 58,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02127659574468085,
            "pseudo_dstar_susp": 0.002421307506053269,
            "pseudo_tarantula_susp": 0.047619047619047616,
            "pseudo_op2_susp": 0.002421307506053269,
            "pseudo_barinel_susp": 0.047619047619047616
        }
    },
    {
        "name": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient.url#61",
        "src_path": "luigi/contrib/hdfs/webhdfs_client.py",
        "class_name": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient",
        "signature": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient.url(self)",
        "snippet": "    def url(self):\n        return 'http://' + self.host + ':' + str(self.port)",
        "begin_line": 61,
        "end_line": 62,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02127659574468085,
            "pseudo_dstar_susp": 0.002421307506053269,
            "pseudo_tarantula_susp": 0.047619047619047616,
            "pseudo_op2_susp": 0.002421307506053269,
            "pseudo_barinel_susp": 0.047619047619047616
        }
    },
    {
        "name": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient.client#65",
        "src_path": "luigi/contrib/hdfs/webhdfs_client.py",
        "class_name": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient",
        "signature": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient.client(self)",
        "snippet": "    def client(self):\n        # A naive benchmark showed that 1000 existence checks took 2.5 secs\n        # when not recreating the client, and 4.0 secs when recreating it. So\n        # not urgent to memoize it. Note that it *might* be issues with process\n        # forking and whatnot (as the one in the snakebite client) if we\n        # memoize it too trivially.\n        import hdfs\n        return hdfs.InsecureClient(url=self.url, user=self.user)",
        "begin_line": 65,
        "end_line": 72,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02127659574468085,
            "pseudo_dstar_susp": 0.002421307506053269,
            "pseudo_tarantula_susp": 0.047619047619047616,
            "pseudo_op2_susp": 0.002421307506053269,
            "pseudo_barinel_susp": 0.047619047619047616
        }
    },
    {
        "name": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient.exists#77",
        "src_path": "luigi/contrib/hdfs/webhdfs_client.py",
        "class_name": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient",
        "signature": "luigi.contrib.hdfs.webhdfs_client.WebHdfsClient.exists(self, path)",
        "snippet": "    def exists(self, path):\n        \"\"\"\n        Returns true if the path exists and false otherwise.\n        \"\"\"\n        import hdfs\n        try:\n            self.client.status(path)\n            return True\n        except hdfs.util.HdfsError as e:\n            if str(e).startswith('File does not exist: '):\n                return False\n            else:\n                raise e",
        "begin_line": 77,
        "end_line": 89,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02127659574468085,
            "pseudo_dstar_susp": 0.002421307506053269,
            "pseudo_tarantula_susp": 0.047619047619047616,
            "pseudo_op2_susp": 0.002421307506053269,
            "pseudo_barinel_susp": 0.047619047619047616
        }
    },
    {
        "name": "luigi.contrib.webhdfs.WebHdfsTarget.__init__#42",
        "src_path": "luigi/contrib/webhdfs.py",
        "class_name": "luigi.contrib.webhdfs.WebHdfsTarget",
        "signature": "luigi.contrib.webhdfs.WebHdfsTarget.__init__(self, path, client=None, format=None)",
        "snippet": "    def __init__(self, path, client=None, format=None):\n        super(WebHdfsTarget, self).__init__(path)\n        path = self.path\n        self.fs = client or WebHdfsClient()\n        if format is None:\n            format = get_default_format()\n\n        self.format = format",
        "begin_line": 42,
        "end_line": 49,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02127659574468085,
            "pseudo_dstar_susp": 0.002421307506053269,
            "pseudo_tarantula_susp": 0.047619047619047616,
            "pseudo_op2_susp": 0.002421307506053269,
            "pseudo_barinel_susp": 0.047619047619047616
        }
    },
    {
        "name": "luigi.task.task_id_str#70",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task",
        "signature": "luigi.task.task_id_str(task_family, params)",
        "snippet": "def task_id_str(task_family, params):\n    \"\"\"\n    Returns a canonical string used to identify a particular task\n\n    :param task_family: The task family (class name) of the task\n    :param params: a dict mapping parameter names to their serialized values\n    :return: A unique, shortened identifier corresponding to the family and params\n    \"\"\"\n    # task_id is a concatenation of task family, the first values of the first 3 parameters\n    # sorted by parameter name and a md5hash of the family/parameters as a cananocalised json.\n    param_str = json.dumps(params, separators=(',', ':'), sort_keys=True)\n    param_hash = hashlib.md5(param_str.encode('utf-8')).hexdigest()\n\n    param_summary = '_'.join(p[:TASK_ID_TRUNCATE_PARAMS]\n                             for p in (params[p] for p in sorted(params)[:TASK_ID_INCLUDE_PARAMS]))\n    param_summary = TASK_ID_INVALID_CHAR_REGEX.sub('_', param_summary)\n\n    return '{}_{}_{}'.format(task_family, param_summary, param_hash[:TASK_ID_TRUNCATE_HASH])",
        "begin_line": 70,
        "end_line": 87,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004219409282700422,
            "pseudo_dstar_susp": 0.018518518518518517,
            "pseudo_tarantula_susp": 0.0015384615384615385,
            "pseudo_op2_susp": 0.018518518518518517,
            "pseudo_barinel_susp": 0.0015384615384615385
        }
    },
    {
        "name": "luigi.task.Task.owner_email#150",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.owner_email(self)",
        "snippet": "    def owner_email(self):\n        '''\n        Override this to send out additional error emails to task owner, in addition to the one\n        defined in `core`.`error-email`. This should return a string or a list of strings. e.g.\n        'test@exmaple.com' or ['test1@example.com', 'test2@example.com']\n        '''\n        return None",
        "begin_line": 150,
        "end_line": 156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015772870662460567,
            "pseudo_dstar_susp": 0.0010570824524312897,
            "pseudo_tarantula_susp": 0.0026041666666666665,
            "pseudo_op2_susp": 0.0010570824524312897,
            "pseudo_barinel_susp": 0.0026041666666666665
        }
    },
    {
        "name": "luigi.task.Task.wrapped#169",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.wrapped(callback)",
        "snippet": "        def wrapped(callback):\n            cls._event_callbacks.setdefault(cls, {}).setdefault(event, set()).add(callback)\n            return callback",
        "begin_line": 169,
        "end_line": 171,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00025471217524197657,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.task.Task.event_handler#165",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.event_handler(cls, event)",
        "snippet": "    def event_handler(cls, event):\n        \"\"\"\n        Decorator for adding event handlers.\n        \"\"\"\n        def wrapped(callback):\n            cls._event_callbacks.setdefault(cls, {}).setdefault(event, set()).add(callback)\n            return callback\n        return wrapped",
        "begin_line": 165,
        "end_line": 172,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00025471217524197657,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.task.Task.trigger_event#174",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.trigger_event(self, event, *args, **kwargs)",
        "snippet": "    def trigger_event(self, event, *args, **kwargs):\n        \"\"\"\n        Trigger that calls all of the specified events associated with this class.\n        \"\"\"\n        for event_class, event_callbacks in six.iteritems(self._event_callbacks):\n            if not isinstance(self, event_class):\n                continue\n            for callback in event_callbacks.get(event, []):\n                try:\n                    # callbacks are protected\n                    callback(*args, **kwargs)\n                except KeyboardInterrupt:\n                    return\n                except BaseException:\n                    logger.exception(\"Error in event callback for %r\", event)",
        "begin_line": 174,
        "end_line": 188,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001364256480218281,
            "pseudo_dstar_susp": 0.0017123287671232876,
            "pseudo_tarantula_susp": 0.0014084507042253522,
            "pseudo_op2_susp": 0.0017123287671232876,
            "pseudo_barinel_susp": 0.0014084507042253522
        }
    },
    {
        "name": "luigi.task.Task.task_module#191",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.task_module(self)",
        "snippet": "    def task_module(self):\n        ''' Returns what Python module to import to get access to this class. '''\n        # TODO(erikbern): we should think about a language-agnostic mechanism\n        return self.__class__.__module__",
        "begin_line": 191,
        "end_line": 194,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00089126559714795,
            "pseudo_dstar_susp": 0.0009643201542912247,
            "pseudo_tarantula_susp": 0.0008928571428571428,
            "pseudo_op2_susp": 0.0009643201542912247,
            "pseudo_barinel_susp": 0.0008928571428571428
        }
    },
    {
        "name": "luigi.task.Task.task_family#197",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.task_family(self)",
        "snippet": "    def task_family(self):\n        \"\"\"\n        Convenience method since a property on the metaclass isn't directly accessible through the class instances.\n        \"\"\"\n        return self.__class__.task_family",
        "begin_line": 197,
        "end_line": 201,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0031545741324921135,
            "pseudo_dstar_susp": 0.007462686567164179,
            "pseudo_tarantula_susp": 0.002044989775051125,
            "pseudo_op2_susp": 0.007462686567164179,
            "pseudo_barinel_susp": 0.002044989775051125
        }
    },
    {
        "name": "luigi.task.Task.get_params#204",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.get_params(cls)",
        "snippet": "    def get_params(cls):\n        \"\"\"\n        Returns all of the Parameters for this Task.\n        \"\"\"\n        # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter):\n                continue\n\n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1]._counter)\n        return params",
        "begin_line": 204,
        "end_line": 219,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006060606060606061,
            "pseudo_dstar_susp": 0.03333333333333333,
            "pseudo_tarantula_susp": 0.001968503937007874,
            "pseudo_op2_susp": 0.03333333333333333,
            "pseudo_barinel_susp": 0.001968503937007874
        }
    },
    {
        "name": "luigi.task.Task.get_param_values#226",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.get_param_values(cls, params, args, kwargs)",
        "snippet": "    def get_param_values(cls, params, args, kwargs):\n        \"\"\"\n        Get the values of the parameters from the args and kwargs.\n\n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n        result = {}\n\n        params_dict = dict(params)\n\n        task_name = cls.task_family\n\n        # In case any exceptions are thrown, create a helpful description of how the Task was invoked\n        # TODO: should we detect non-reprable arguments? These will lead to mysterious errors\n        exc_desc = '%s[args=%s, kwargs=%s]' % (task_name, args, kwargs)\n\n        # Fill in the positional arguments\n        positional_params = [(n, p) for n, p in params if p.positional]\n        for i, arg in enumerate(args):\n            if i >= len(positional_params):\n                raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n            param_name, param_obj = positional_params[i]\n            result[param_name] = param_obj.normalize(arg)\n\n        # Then the keyword arguments\n        for param_name, arg in six.iteritems(kwargs):\n            if param_name in result:\n                raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n            if param_name not in params_dict:\n                raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n            result[param_name] = params_dict[param_name].normalize(arg)\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_task_value(task_name, param_name):\n                    raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n                result[param_name] = param_obj.task_value(task_name, param_name)\n\n        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n            if isinstance(x, list) or isinstance(x, set):\n                return tuple(x)\n            else:\n                return x\n        # Sort it by the correct order and make a list\n        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]",
        "begin_line": 226,
        "end_line": 275,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005988023952095809,
            "pseudo_dstar_susp": 0.03125,
            "pseudo_tarantula_susp": 0.0019157088122605363,
            "pseudo_op2_susp": 0.03125,
            "pseudo_barinel_susp": 0.0019157088122605363
        }
    },
    {
        "name": "luigi.task.Task.list_to_tuple#268",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.list_to_tuple(x)",
        "snippet": "        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n            if isinstance(x, list) or isinstance(x, set):\n                return tuple(x)\n            else:\n                return x",
        "begin_line": 268,
        "end_line": 273,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006024096385542169,
            "pseudo_dstar_susp": 0.03225806451612903,
            "pseudo_tarantula_susp": 0.0018214936247723133,
            "pseudo_op2_susp": 0.03225806451612903,
            "pseudo_barinel_susp": 0.0018214936247723133
        }
    },
    {
        "name": "luigi.task.Task.__init__#277",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        # Register args and kwargs as an attribute on the class. Might be useful\n        self.param_args = tuple(value for key, value in param_values)\n        self.param_kwargs = dict(param_values)\n\n        self.task_id = task_id_str(self.task_family, self.to_str_params(only_significant=True))\n        self.__hash = hash(self.task_id)",
        "begin_line": 277,
        "end_line": 290,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004219409282700422,
            "pseudo_dstar_susp": 0.018518518518518517,
            "pseudo_tarantula_susp": 0.0021141649048625794,
            "pseudo_op2_susp": 0.018518518518518517,
            "pseudo_barinel_susp": 0.0021141649048625794
        }
    },
    {
        "name": "luigi.task.Task.initialized#292",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.initialized(self)",
        "snippet": "    def initialized(self):\n        \"\"\"\n        Returns ``True`` if the Task is initialized and ``False`` otherwise.\n        \"\"\"\n        return hasattr(self, 'task_id')",
        "begin_line": 292,
        "end_line": 296,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012004801920768306,
            "pseudo_dstar_susp": 0.0014705882352941176,
            "pseudo_tarantula_susp": 0.0011467889908256881,
            "pseudo_op2_susp": 0.0014705882352941176,
            "pseudo_barinel_susp": 0.0011467889908256881
        }
    },
    {
        "name": "luigi.task.Task.from_str_params#299",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.from_str_params(cls, params_str)",
        "snippet": "    def from_str_params(cls, params_str):\n        \"\"\"\n        Creates an instance from a str->str hash.\n\n        :param params_str: dict of param name -> value as string.\n        \"\"\"\n        kwargs = {}\n        for param_name, param in cls.get_params():\n            if param_name in params_str:\n                kwargs[param_name] = param.parse(params_str[param_name])\n\n        return cls(**kwargs)",
        "begin_line": 299,
        "end_line": 310,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002772387025228722,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.task.Task.to_str_params#312",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.to_str_params(self, only_significant=False)",
        "snippet": "    def to_str_params(self, only_significant=False):\n        \"\"\"\n        Convert all parameters to a str->str hash.\n        \"\"\"\n        params_str = {}\n        params = dict(self.get_params())\n        for param_name, param_value in six.iteritems(self.param_kwargs):\n            if (not only_significant) or params[param_name].significant:\n                params_str[param_name] = params[param_name].serialize(param_value)\n\n        return params_str",
        "begin_line": 312,
        "end_line": 322,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004545454545454545,
            "pseudo_dstar_susp": 0.007936507936507936,
            "pseudo_tarantula_susp": 0.0022935779816513763,
            "pseudo_op2_susp": 0.007936507936507936,
            "pseudo_barinel_susp": 0.0022935779816513763
        }
    },
    {
        "name": "luigi.task.Task.clone#324",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.clone(self, cls=None, **kwargs)",
        "snippet": "    def clone(self, cls=None, **kwargs):\n        \"\"\"\n        Creates a new instance from an existing instance where some of the args have changed.\n\n        There's at least two scenarios where this is useful (see test/clone_test.py):\n\n        * remove a lot of boiler plate when you have recursive dependencies and lots of args\n        * there's task inheritance and some logic is on the base class\n\n        :param cls:\n        :param kwargs:\n        :return:\n        \"\"\"\n        k = self.param_kwargs.copy()\n        k.update(six.iteritems(kwargs))\n\n        if cls is None:\n            cls = self.__class__\n\n        new_k = {}\n        for param_name, param_class in cls.get_params():\n            if param_name in k:\n                new_k[param_name] = k[param_name]\n\n        return cls(**new_k)",
        "begin_line": 324,
        "end_line": 348,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002607561929595828,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.task.Task.__hash__#350",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.__hash__(self)",
        "snippet": "    def __hash__(self):\n        return self.__hash",
        "begin_line": 350,
        "end_line": 351,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007980845969672786,
            "pseudo_dstar_susp": 0.0007980845969672786,
            "pseudo_tarantula_susp": 0.0008064516129032258,
            "pseudo_op2_susp": 0.0007980845969672786,
            "pseudo_barinel_susp": 0.0008064516129032258
        }
    },
    {
        "name": "luigi.task.Task.__repr__#353",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.__repr__(self)",
        "snippet": "    def __repr__(self):\n        \"\"\"\n        Build a task representation like `MyTask(param1=1.5, param2='5')`\n        \"\"\"\n        params = self.get_params()\n        param_values = self.get_param_values(params, [], self.param_kwargs)\n\n        # Build up task id\n        repr_parts = []\n        param_objs = dict(params)\n        for param_name, param_value in param_values:\n            if param_objs[param_name].significant:\n                repr_parts.append('%s=%s' % (param_name, param_objs[param_name].serialize(param_value)))\n\n        task_str = '{}({})'.format(self.task_family, ', '.join(repr_parts))\n\n        return task_str",
        "begin_line": 353,
        "end_line": 369,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014534883720930232,
            "pseudo_dstar_susp": 0.0018115942028985507,
            "pseudo_tarantula_susp": 0.001941747572815534,
            "pseudo_op2_susp": 0.0018115942028985507,
            "pseudo_barinel_susp": 0.001941747572815534
        }
    },
    {
        "name": "luigi.task.Task.__eq__#371",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.__eq__(self, other)",
        "snippet": "    def __eq__(self, other):\n        return self.__class__ == other.__class__ and self.param_args == other.param_args",
        "begin_line": 371,
        "end_line": 372,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002725538293813028,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.task.Task.complete#374",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.complete(self)",
        "snippet": "    def complete(self):\n        \"\"\"\n        If the task has any outputs, return ``True`` if all outputs exist.\n        Otherwise, return ``False``.\n\n        However, you may freely override this method with custom logic.\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            warnings.warn(\n                \"Task %r without outputs has no custom complete() method\" % self,\n                stacklevel=2\n            )\n            return False\n\n        return all(map(lambda output: output.exists(), outputs))",
        "begin_line": 374,
        "end_line": 389,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00023293733985557886,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.task.Task.bulk_complete#392",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.bulk_complete(cls, parameter_tuples)",
        "snippet": "    def bulk_complete(cls, parameter_tuples):\n        \"\"\"\n        Returns those of parameter_tuples for which this Task is complete.\n\n        Override (with an efficient implementation) for efficient scheduling\n        with range tools. Keep the logic consistent with that of complete().\n        \"\"\"\n        raise BulkCompleteNotImplementedError()",
        "begin_line": 392,
        "end_line": 399,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00032754667540124465,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.task.Task.output#401",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.output(self)",
        "snippet": "    def output(self):\n        \"\"\"\n        The output that this Task produces.\n\n        The output of the Task determines if the Task needs to be run--the task\n        is considered finished iff the outputs all exist. Subclasses should\n        override this method to return a single :py:class:`Target` or a list of\n        :py:class:`Target` instances.\n\n        Implementation note\n          If running multiple workers, the output must be a resource that is accessible\n          by all workers, such as a DFS or database. Otherwise, workers might compute\n          the same output since they don't see the work done by other workers.\n\n        See :ref:`Task.output`\n        \"\"\"\n        return []  # default impl",
        "begin_line": 401,
        "end_line": 417,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002316423442205235,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.task.Task.requires#419",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.requires(self)",
        "snippet": "    def requires(self):\n        \"\"\"\n        The Tasks that this Task depends on.\n\n        A Task will only run if all of the Tasks that it requires are completed.\n        If your Task does not require any other Tasks, then you don't need to\n        override this method. Otherwise, a Subclasses can override this method\n        to return a single Task, a list of Task instances, or a dict whose\n        values are Task instances.\n\n        See :ref:`Task.requires`\n        \"\"\"\n        return []  # default impl",
        "begin_line": 419,
        "end_line": 431,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007457121551081282,
            "pseudo_dstar_susp": 0.0007457121551081282,
            "pseudo_tarantula_susp": 0.0007485029940119761,
            "pseudo_op2_susp": 0.0007457121551081282,
            "pseudo_barinel_susp": 0.0007485029940119761
        }
    },
    {
        "name": "luigi.task.Task._requires#433",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task._requires(self)",
        "snippet": "    def _requires(self):\n        \"\"\"\n        Override in \"template\" tasks which themselves are supposed to be\n        subclassed and thus have their requires() overridden (name preserved to\n        provide consistent end-user experience), yet need to introduce\n        (non-input) dependencies.\n\n        Must return an iterable which among others contains the _requires() of\n        the superclass.\n        \"\"\"\n        return flatten(self.requires())  # base impl",
        "begin_line": 433,
        "end_line": 443,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009017132551848512,
            "pseudo_dstar_susp": 0.0009765625,
            "pseudo_tarantula_susp": 0.0009149130832570906,
            "pseudo_op2_susp": 0.0009765625,
            "pseudo_barinel_susp": 0.0009149130832570906
        }
    },
    {
        "name": "luigi.task.Task.process_resources#445",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.process_resources(self)",
        "snippet": "    def process_resources(self):\n        \"\"\"\n        Override in \"template\" tasks which provide common resource functionality\n        but allow subclasses to specify additional resources while preserving\n        the name for consistent end-user experience.\n        \"\"\"\n        return self.resources  # default impl",
        "begin_line": 445,
        "end_line": 451,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00089126559714795,
            "pseudo_dstar_susp": 0.0009643201542912247,
            "pseudo_tarantula_susp": 0.0008928571428571428,
            "pseudo_op2_susp": 0.0009643201542912247,
            "pseudo_barinel_susp": 0.0008928571428571428
        }
    },
    {
        "name": "luigi.task.Task.input#453",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.input(self)",
        "snippet": "    def input(self):\n        \"\"\"\n        Returns the outputs of the Tasks returned by :py:meth:`requires`\n\n        See :ref:`Task.input`\n\n        :return: a list of :py:class:`Target` objects which are specified as\n                 outputs of all required Tasks.\n        \"\"\"\n        return getpaths(self.requires())",
        "begin_line": 453,
        "end_line": 462,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00024783147459727387,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.task.Task.deps#464",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.deps(self)",
        "snippet": "    def deps(self):\n        \"\"\"\n        Internal method used by the scheduler.\n\n        Returns the flattened list of requires.\n        \"\"\"\n        # used by scheduler\n        return flatten(self._requires())",
        "begin_line": 464,
        "end_line": 471,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009057971014492754,
            "pseudo_dstar_susp": 0.0009813542688910696,
            "pseudo_tarantula_susp": 0.0009267840593141798,
            "pseudo_op2_susp": 0.0009813542688910696,
            "pseudo_barinel_susp": 0.0009267840593141798
        }
    },
    {
        "name": "luigi.task.Task.run#473",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.run(self)",
        "snippet": "    def run(self):\n        \"\"\"\n        The task run method, to be overridden in a subclass.\n\n        See :ref:`Task.run`\n        \"\"\"\n        pass  # default impl",
        "begin_line": 473,
        "end_line": 479,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00023929169657812874,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.task.Task.on_failure#481",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.on_failure(self, exception)",
        "snippet": "    def on_failure(self, exception):\n        \"\"\"\n        Override for custom error handling.\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        The returned value of this method is json encoded and sent to the scheduler\n        as the `expl` argument. Its string representation will be used as the\n        body of the error email sent out if any.\n\n        Default behavior is to return a string representation of the stack trace.\n        \"\"\"\n\n        traceback_string = traceback.format_exc()\n        return \"Runtime error:\\n%s\" % traceback_string",
        "begin_line": 481,
        "end_line": 494,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000998003992015968,
            "pseudo_dstar_susp": 0.0008888888888888889,
            "pseudo_tarantula_susp": 0.0024630541871921183,
            "pseudo_op2_susp": 0.0008888888888888889,
            "pseudo_barinel_susp": 0.0024630541871921183
        }
    },
    {
        "name": "luigi.task.Task.on_success#496",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.on_success(self)",
        "snippet": "    def on_success(self):\n        \"\"\"\n        Override for doing custom completion handling for a larger class of tasks\n\n        This method gets called when :py:meth:`run` completes without raising any exceptions.\n\n        The returned value is json encoded and sent to the scheduler as the `expl` argument.\n\n        Default behavior is to send an None value\"\"\"\n        pass",
        "begin_line": 496,
        "end_line": 505,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00022768670309653916,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.task.MixinNaiveBulkComplete.bulk_complete#517",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.MixinNaiveBulkComplete",
        "signature": "luigi.task.MixinNaiveBulkComplete.bulk_complete(cls, parameter_tuples)",
        "snippet": "    def bulk_complete(cls, parameter_tuples):\n        generated_tuples = []\n        for parameter_tuple in parameter_tuples:\n            if isinstance(parameter_tuple, (list, tuple)):\n                if cls(*parameter_tuple).complete():\n                    generated_tuples.append(parameter_tuple)\n            elif isinstance(parameter_tuple, dict):\n                if cls(**parameter_tuple).complete():\n                    generated_tuples.append(parameter_tuple)\n            else:\n                if cls(parameter_tuple).complete():\n                    generated_tuples.append(parameter_tuple)\n        return generated_tuples",
        "begin_line": 517,
        "end_line": 529,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.task.WrapperTask.complete#558",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.WrapperTask",
        "signature": "luigi.task.WrapperTask.complete(self)",
        "snippet": "    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))",
        "begin_line": 558,
        "end_line": 559,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002725538293813028,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.task.getpaths#571",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task",
        "signature": "luigi.task.getpaths(struct)",
        "snippet": "def getpaths(struct):\n    \"\"\"\n    Maps all Tasks in a structured data object to their .output().\n    \"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in six.iteritems(struct):\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n\n        return [getpaths(r) for r in s]",
        "begin_line": 571,
        "end_line": 589,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00030543677458766036,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.task.flatten#592",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task",
        "signature": "luigi.task.flatten(struct)",
        "snippet": "def flatten(struct):\n    \"\"\"\n    Creates a flat list of all all items in structured output (dicts, lists, items):\n\n    .. code-block:: python\n\n        >>> sorted(flatten({'a': 'foo', 'b': 'bar'}))\n        ['bar', 'foo']\n        >>> sorted(flatten(['foo', ['bar', 'troll']]))\n        ['bar', 'foo', 'troll']\n        >>> flatten('foo')\n        ['foo']\n        >>> flatten(42)\n        [42]\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for _, result in six.iteritems(struct):\n            flat += flatten(result)\n        return flat\n    if isinstance(struct, six.string_types):\n        return [struct]\n\n    try:\n        # if iterable\n        iterator = iter(struct)\n    except TypeError:\n        return [struct]\n\n    for result in iterator:\n        flat += flatten(result)\n    return flat",
        "begin_line": 592,
        "end_line": 625,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006920415224913495,
            "pseudo_dstar_susp": 0.0006920415224913495,
            "pseudo_tarantula_susp": 0.0006920415224913495,
            "pseudo_op2_susp": 0.0006920415224913495,
            "pseudo_barinel_susp": 0.0006920415224913495
        }
    },
    {
        "name": "luigi.task.flatten_output#628",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task",
        "signature": "luigi.task.flatten_output(task)",
        "snippet": "def flatten_output(task):\n    \"\"\"\n    Lists all output targets by recursively walking output-less (wrapper) tasks.\n\n    FIXME order consistently.\n    \"\"\"\n    r = flatten(task.output())\n    if not r:\n        for dep in flatten(task.requires()):\n            r += flatten_output(dep)\n    return r",
        "begin_line": 628,
        "end_line": 638,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.target.FileSystem.rename_dont_move#167",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.FileSystem",
        "signature": "luigi.target.FileSystem.rename_dont_move(self, path, dest)",
        "snippet": "    def rename_dont_move(self, path, dest):\n        \"\"\"\n        Potentially rename ``path`` to ``dest``, but don't move it into the\n        ``dest`` folder (if it is a folder).  This kind of operation is useful\n        when you don't want your output path to ever contain partial or\n        errinously nested data.\n\n        See `this github issue <https://github.com/spotify/luigi/pull/557>`__ and\n        `the thanksgiving bug <http://tarrasch.github.io/luigi-budapest-bi-oct-2015/#/21>`__\n        where the problem is described.\n\n        This method has a reasonable but not bullet proof default\n        implementation.  It will just do ``move()`` if the file doesn't\n        ``exists()`` already.\n        \"\"\"\n        warnings.warn(\"File system {} client doesn't support atomic mv.\".format(self.__class__.__name__))\n        if self.exists(dest):\n            raise FileAlreadyExists()\n        self.move(path, dest)",
        "begin_line": 167,
        "end_line": 185,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02127659574468085,
            "pseudo_dstar_susp": 0.002421307506053269,
            "pseudo_tarantula_susp": 0.047619047619047616,
            "pseudo_op2_susp": 0.002421307506053269,
            "pseudo_barinel_susp": 0.047619047619047616
        }
    },
    {
        "name": "luigi.target.FileSystemTarget.__init__#200",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.FileSystemTarget",
        "signature": "luigi.target.FileSystemTarget.__init__(self, path)",
        "snippet": "    def __init__(self, path):\n        \"\"\"\n        Initializes a FileSystemTarget instance.\n\n        :param str path: the path associated with this FileSystemTarget.\n        \"\"\"\n        self.path = path",
        "begin_line": 200,
        "end_line": 206,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005747126436781609,
            "pseudo_dstar_susp": 0.007352941176470588,
            "pseudo_tarantula_susp": 0.0043859649122807015,
            "pseudo_op2_susp": 0.007352941176470588,
            "pseudo_barinel_susp": 0.0043859649122807015
        }
    },
    {
        "name": "luigi.target.FileSystemTarget.exists#229",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.FileSystemTarget",
        "signature": "luigi.target.FileSystemTarget.exists(self)",
        "snippet": "    def exists(self):\n        \"\"\"\n        Returns ``True`` if the path for this FileSystemTarget exists; ``False`` otherwise.\n\n        This method is implemented by using :py:meth:`fs`.\n        \"\"\"\n        path = self.path\n        if '*' in path or '?' in path or '[' in path or '{' in path:\n            logger.warning(\"Using wildcards in path %s might lead to processing of an incomplete dataset; \"\n                           \"override exists() to suppress the warning.\", path)\n        return self.fs.exists(path)",
        "begin_line": 229,
        "end_line": 239,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0030864197530864196,
            "pseudo_dstar_susp": 0.0022675736961451248,
            "pseudo_tarantula_susp": 0.0038461538461538464,
            "pseudo_op2_susp": 0.0022675736961451248,
            "pseudo_barinel_susp": 0.0038461538461538464
        }
    },
    {
        "name": "luigi.target.FileSystemTarget._touchz#249",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.FileSystemTarget",
        "signature": "luigi.target.FileSystemTarget._touchz(self)",
        "snippet": "    def _touchz(self):\n        with self.open('w'):\n            pass",
        "begin_line": 249,
        "end_line": 251,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.013888888888888888,
            "pseudo_dstar_susp": 0.00234192037470726,
            "pseudo_tarantula_susp": 0.014084507042253521,
            "pseudo_op2_susp": 0.00234192037470726,
            "pseudo_barinel_susp": 0.013333333333333334
        }
    },
    {
        "name": "luigi.target.AtomicLocalFile.__init__#263",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.AtomicLocalFile",
        "signature": "luigi.target.AtomicLocalFile.__init__(self, path)",
        "snippet": "    def __init__(self, path):\n        self.__tmp_path = self.generate_tmp_path(path)\n        self.path = path\n        super(AtomicLocalFile, self).__init__(io.FileIO(self.__tmp_path, 'w'))",
        "begin_line": 263,
        "end_line": 266,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022624434389140274,
            "pseudo_dstar_susp": 0.0019230769230769232,
            "pseudo_tarantula_susp": 0.0027624309392265192,
            "pseudo_op2_susp": 0.0019230769230769232,
            "pseudo_barinel_susp": 0.0027624309392265192
        }
    },
    {
        "name": "luigi.target.AtomicLocalFile.close#268",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.AtomicLocalFile",
        "signature": "luigi.target.AtomicLocalFile.close(self)",
        "snippet": "    def close(self):\n        super(AtomicLocalFile, self).close()\n        self.move_to_final_destination()",
        "begin_line": 268,
        "end_line": 270,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002457002457002457,
            "pseudo_dstar_susp": 0.002012072434607646,
            "pseudo_tarantula_susp": 0.003125,
            "pseudo_op2_susp": 0.002012072434607646,
            "pseudo_barinel_susp": 0.003125
        }
    },
    {
        "name": "luigi.target.AtomicLocalFile.__del__#278",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.AtomicLocalFile",
        "signature": "luigi.target.AtomicLocalFile.__del__(self)",
        "snippet": "    def __del__(self):\n        if os.path.exists(self.tmp_path):\n            os.remove(self.tmp_path)",
        "begin_line": 278,
        "end_line": 280,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022624434389140274,
            "pseudo_dstar_susp": 0.0019230769230769232,
            "pseudo_tarantula_susp": 0.0027624309392265192,
            "pseudo_op2_susp": 0.0019230769230769232,
            "pseudo_barinel_susp": 0.0027624309392265192
        }
    },
    {
        "name": "luigi.target.AtomicLocalFile.tmp_path#283",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.AtomicLocalFile",
        "signature": "luigi.target.AtomicLocalFile.tmp_path(self)",
        "snippet": "    def tmp_path(self):\n        return self.__tmp_path",
        "begin_line": 283,
        "end_line": 284,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022624434389140274,
            "pseudo_dstar_susp": 0.0019230769230769232,
            "pseudo_tarantula_susp": 0.0027624309392265192,
            "pseudo_op2_susp": 0.0019230769230769232,
            "pseudo_barinel_susp": 0.0027624309392265192
        }
    },
    {
        "name": "luigi.target.AtomicLocalFile.__exit__#286",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.AtomicLocalFile",
        "signature": "luigi.target.AtomicLocalFile.__exit__(self, exc_type, exc, traceback)",
        "snippet": "    def __exit__(self, exc_type, exc, traceback):\n        \" Close/commit the file if there are no exception \"\n        if exc_type:\n            return\n        return super(AtomicLocalFile, self).__exit__(exc_type, exc, traceback)",
        "begin_line": 286,
        "end_line": 290,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005681818181818182,
            "pseudo_dstar_susp": 0.002331002331002331,
            "pseudo_tarantula_susp": 0.005291005291005291,
            "pseudo_op2_susp": 0.002331002331002331,
            "pseudo_barinel_susp": 0.005291005291005291
        }
    },
    {
        "name": "luigi.parameter.Parameter.__init__#117",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.__init__(self, default=_no_value, is_global=False, significant=True, description=None, config_path=None, positional=True, always_in_help=False)",
        "snippet": "    def __init__(self, default=_no_value, is_global=False, significant=True, description=None,\n                 config_path=None, positional=True, always_in_help=False):\n        \"\"\"\n        :param default: the default value for this parameter. This should match the type of the\n                        Parameter, i.e. ``datetime.date`` for ``DateParameter`` or ``int`` for\n                        ``IntParameter``. By default, no default is stored and\n                        the value must be specified at runtime.\n        :param bool significant: specify ``False`` if the parameter should not be treated as part of\n                                 the unique identifier for a Task. An insignificant Parameter might\n                                 also be used to specify a password or other sensitive information\n                                 that should not be made public via the scheduler. Default:\n                                 ``True``.\n        :param str description: A human-readable string describing the purpose of this Parameter.\n                                For command-line invocations, this will be used as the `help` string\n                                shown to users. Default: ``None``.\n        :param dict config_path: a dictionary with entries ``section`` and ``name``\n                                 specifying a config file entry from which to read the\n                                 default value for this parameter. DEPRECATED.\n                                 Default: ``None``.\n        :param bool positional: If true, you can set the argument as a\n                                positional argument. It's true by default but we recommend\n                                ``positional=False`` for abstract base classes and similar cases.\n        :param bool always_in_help: For the --help option in the command line\n                                    parsing. Set true to always show in --help.\n        \"\"\"\n        self._default = default\n        if is_global:\n            warnings.warn(\"is_global support is removed. Assuming positional=False\",\n                          DeprecationWarning,\n                          stacklevel=2)\n            positional = False\n        self.significant = significant  # Whether different values for this parameter will differentiate otherwise equal tasks\n        self.positional = positional\n\n        self.description = description\n        self.always_in_help = always_in_help\n\n        if config_path is not None and ('section' not in config_path or 'name' not in config_path):\n            raise ParameterException('config_path must be a hash containing entries for section and name')\n        self.__config = config_path\n\n        self._counter = Parameter._counter  # We need to keep track of this to get the order right (see Task class)\n        Parameter._counter += 1",
        "begin_line": 117,
        "end_line": 159,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007374631268436578,
            "pseudo_dstar_susp": 0.0007374631268436578,
            "pseudo_tarantula_susp": 0.0007401924500370096,
            "pseudo_op2_susp": 0.0007374631268436578,
            "pseudo_barinel_susp": 0.0007401924500370096
        }
    },
    {
        "name": "luigi.parameter.Parameter._get_value_from_config#161",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter._get_value_from_config(self, section, name)",
        "snippet": "    def _get_value_from_config(self, section, name):\n        \"\"\"Loads the default from the config. Returns _no_value if it doesn't exist\"\"\"\n\n        conf = configuration.get_config()\n\n        try:\n            value = conf.get(section, name)\n        except (NoSectionError, NoOptionError):\n            return _no_value\n\n        return self.parse(value)",
        "begin_line": 161,
        "end_line": 171,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0036101083032490976,
            "pseudo_dstar_susp": 0.010526315789473684,
            "pseudo_tarantula_susp": 0.001893939393939394,
            "pseudo_op2_susp": 0.010526315789473684,
            "pseudo_barinel_susp": 0.001893939393939394
        }
    },
    {
        "name": "luigi.parameter.Parameter._get_value#173",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter._get_value(self, task_name, param_name)",
        "snippet": "    def _get_value(self, task_name, param_name):\n        for value, warn in self._value_iterator(task_name, param_name):\n            if value != _no_value:\n                if warn:\n                    warnings.warn(warn, DeprecationWarning)\n                return value\n        return _no_value",
        "begin_line": 173,
        "end_line": 179,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0036900369003690036,
            "pseudo_dstar_susp": 0.011235955056179775,
            "pseudo_tarantula_susp": 0.0019157088122605363,
            "pseudo_op2_susp": 0.011235955056179775,
            "pseudo_barinel_susp": 0.0019157088122605363
        }
    },
    {
        "name": "luigi.parameter.Parameter._value_iterator#181",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter._value_iterator(self, task_name, param_name)",
        "snippet": "    def _value_iterator(self, task_name, param_name):\n        \"\"\"\n        Yield the parameter values, with optional deprecation warning as second tuple value.\n\n        The parameter value will be whatever non-_no_value that is yielded first.\n        \"\"\"\n        cp_parser = CmdlineParser.get_instance()\n        if cp_parser:\n            dest = self._parser_global_dest(param_name, task_name)\n            found = getattr(cp_parser.known_args, dest, None)\n            yield (self._parse_or_no_value(found), None)\n        yield (self._get_value_from_config(task_name, param_name), None)\n        yield (self._get_value_from_config(task_name, param_name.replace('_', '-')),\n               'Configuration [{}] {} (with dashes) should be avoided. Please use underscores.'.format(\n               task_name, param_name))\n        if self.__config:\n            yield (self._get_value_from_config(self.__config['section'], self.__config['name']),\n                   'The use of the configuration [{}] {} is deprecated. Please use [{}] {}'.format(\n                   self.__config['section'], self.__config['name'], task_name, param_name))\n        yield (self._default, None)",
        "begin_line": 181,
        "end_line": 200,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00558659217877095,
            "pseudo_dstar_susp": 0.011764705882352941,
            "pseudo_tarantula_susp": 0.0023923444976076554,
            "pseudo_op2_susp": 0.011764705882352941,
            "pseudo_barinel_susp": 0.0023923444976076554
        }
    },
    {
        "name": "luigi.parameter.Parameter.has_task_value#202",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.has_task_value(self, task_name, param_name)",
        "snippet": "    def has_task_value(self, task_name, param_name):\n        return self._get_value(task_name, param_name) != _no_value",
        "begin_line": 202,
        "end_line": 203,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003424657534246575,
            "pseudo_dstar_susp": 0.009174311926605505,
            "pseudo_tarantula_susp": 0.0017391304347826088,
            "pseudo_op2_susp": 0.009174311926605505,
            "pseudo_barinel_susp": 0.0017391304347826088
        }
    },
    {
        "name": "luigi.parameter.Parameter.task_value#205",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.task_value(self, task_name, param_name)",
        "snippet": "    def task_value(self, task_name, param_name):\n        value = self._get_value(task_name, param_name)\n        if value == _no_value:\n            raise MissingParameterException(\"No default specified\")\n        else:\n            return self.normalize(value)",
        "begin_line": 205,
        "end_line": 210,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0036900369003690036,
            "pseudo_dstar_susp": 0.011235955056179775,
            "pseudo_tarantula_susp": 0.0019157088122605363,
            "pseudo_op2_susp": 0.011235955056179775,
            "pseudo_barinel_susp": 0.0019157088122605363
        }
    },
    {
        "name": "luigi.parameter.Parameter.parse#212",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.parse(self, x)",
        "snippet": "    def parse(self, x):\n        \"\"\"\n        Parse an individual value from the input.\n\n        The default implementation is the identity function, but subclasses should override\n        this method for specialized parsing.\n\n        :param str x: the value to parse.\n        :return: the parsed value.\n        \"\"\"\n        return x  # default impl",
        "begin_line": 212,
        "end_line": 222,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00022836263987211693,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.Parameter.serialize#224",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.serialize(self, x)",
        "snippet": "    def serialize(self, x):\n        \"\"\"\n        Opposite of :py:meth:`parse`.\n\n        Converts the value ``x`` to a string.\n\n        :param x: the value to serialize.\n        \"\"\"\n        return str(x)",
        "begin_line": 224,
        "end_line": 232,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005235602094240838,
            "pseudo_dstar_susp": 0.008064516129032258,
            "pseudo_tarantula_susp": 0.0024630541871921183,
            "pseudo_op2_susp": 0.008064516129032258,
            "pseudo_barinel_susp": 0.0024630541871921183
        }
    },
    {
        "name": "luigi.parameter.Parameter.normalize#234",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.normalize(self, x)",
        "snippet": "    def normalize(self, x):\n        \"\"\"\n        Given a parsed parameter value, normalizes it.\n\n        The value can either be the result of parse(), the default value or\n        arguments passed into the task's constructor by instantiation.\n\n        This is very implementation defined, but can be used to validate/clamp\n        valid values. For example, if you wanted to only accept even integers,\n        and \"correct\" odd values to the nearest integer, you can implement\n        normalize as ``x // 2 * 2``.\n        \"\"\"\n        return x  # default impl",
        "begin_line": 234,
        "end_line": 246,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004273504273504274,
            "pseudo_dstar_susp": 0.017857142857142856,
            "pseudo_tarantula_susp": 0.001976284584980237,
            "pseudo_op2_susp": 0.017857142857142856,
            "pseudo_barinel_susp": 0.001976284584980237
        }
    },
    {
        "name": "luigi.parameter.Parameter.next_in_enumeration#248",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.next_in_enumeration(self, _value)",
        "snippet": "    def next_in_enumeration(self, _value):\n        \"\"\"\n        If your Parameter type has an enumerable ordering of values. You can\n        choose to override this method. This method is used by the\n        :py:mod:`luigi.execution_summary` module for pretty printing\n        purposes. Enabling it to pretty print tasks like ``MyTask(num=1),\n        MyTask(num=2), MyTask(num=3)`` to ``MyTask(num=1..3)``.\n\n        :param value: The value\n        :return: The next value, like \"value + 1\". Or ``None`` if there's no enumerable ordering.\n        \"\"\"\n        return None",
        "begin_line": 248,
        "end_line": 259,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00024224806201550387,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.Parameter._parse_or_no_value#261",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter._parse_or_no_value(self, x)",
        "snippet": "    def _parse_or_no_value(self, x):\n        if not x:\n            return _no_value\n        else:\n            return self.parse(x)",
        "begin_line": 261,
        "end_line": 265,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008818342151675485,
            "pseudo_dstar_susp": 0.0008695652173913044,
            "pseudo_tarantula_susp": 0.0019455252918287938,
            "pseudo_op2_susp": 0.0008695652173913044,
            "pseudo_barinel_susp": 0.0019455252918287938
        }
    },
    {
        "name": "luigi.parameter.Parameter._parser_global_dest#268",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter._parser_global_dest(param_name, task_name)",
        "snippet": "    def _parser_global_dest(param_name, task_name):\n        return task_name + '_' + param_name",
        "begin_line": 268,
        "end_line": 269,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0028328611898017,
            "pseudo_dstar_susp": 0.0021321961620469083,
            "pseudo_tarantula_susp": 0.003472222222222222,
            "pseudo_op2_susp": 0.0021321961620469083,
            "pseudo_barinel_susp": 0.003472222222222222
        }
    },
    {
        "name": "luigi.parameter.Parameter._parser_action#272",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter._parser_action()",
        "snippet": "    def _parser_action():\n        return \"store\"",
        "begin_line": 272,
        "end_line": 273,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0028328611898017,
            "pseudo_dstar_susp": 0.0021321961620469083,
            "pseudo_tarantula_susp": 0.003472222222222222,
            "pseudo_op2_susp": 0.0021321961620469083,
            "pseudo_barinel_susp": 0.003472222222222222
        }
    },
    {
        "name": "luigi.parameter._DateParameterBase.__init__#284",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._DateParameterBase",
        "signature": "luigi.parameter._DateParameterBase.__init__(self, interval=1, start=None, **kwargs)",
        "snippet": "    def __init__(self, interval=1, start=None, **kwargs):\n        super(_DateParameterBase, self).__init__(**kwargs)\n        self.interval = interval\n        self.start = start if start is not None else _UNIX_EPOCH.date()",
        "begin_line": 284,
        "end_line": 287,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00024396194193705782,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter._DateParameterBase.parse#296",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._DateParameterBase",
        "signature": "luigi.parameter._DateParameterBase.parse(self, s)",
        "snippet": "    def parse(self, s):\n        \"\"\"\n        Parses a date string formatted like ``YYYY-MM-DD``.\n        \"\"\"\n        return datetime.datetime.strptime(s, self.date_format).date()",
        "begin_line": 296,
        "end_line": 300,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002607561929595828,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter._DateParameterBase.serialize#302",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._DateParameterBase",
        "signature": "luigi.parameter._DateParameterBase.serialize(self, dt)",
        "snippet": "    def serialize(self, dt):\n        \"\"\"\n        Converts the date to a string using the :py:attr:`~_DateParameterBase.date_format`.\n        \"\"\"\n        if dt is None:\n            return str(dt)\n        return dt.strftime(self.date_format)",
        "begin_line": 302,
        "end_line": 308,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00032754667540124465,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.DateParameter.next_in_enumeration#321",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.DateParameter",
        "signature": "luigi.parameter.DateParameter.next_in_enumeration(self, value)",
        "snippet": "    def next_in_enumeration(self, value):\n        return value + datetime.timedelta(days=self.interval)",
        "begin_line": 321,
        "end_line": 322,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002842524161455372,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.DateParameter.normalize#324",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.DateParameter",
        "signature": "luigi.parameter.DateParameter.normalize(self, value)",
        "snippet": "    def normalize(self, value):\n        if value is None:\n            return None\n\n        if isinstance(value, datetime.datetime):\n            value = value.date()\n\n        delta = (value - self.start).days % self.interval\n        return value - datetime.timedelta(days=delta)",
        "begin_line": 324,
        "end_line": 332,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.MonthParameter._add_months#346",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.MonthParameter",
        "signature": "luigi.parameter.MonthParameter._add_months(self, date, months)",
        "snippet": "    def _add_months(self, date, months):\n        \"\"\"\n        Add ``months`` months to ``date``.\n\n        Unfortunately we can't use timedeltas to add months because timedelta counts in days\n        and there's no foolproof way to add N months in days without counting the number of\n        days per month.\n        \"\"\"\n        year = date.year + (date.month + months - 1) // 12\n        month = (date.month + months - 1) % 12 + 1\n        return datetime.date(year=year, month=month, day=1)",
        "begin_line": 346,
        "end_line": 356,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00032754667540124465,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.MonthParameter.next_in_enumeration#358",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.MonthParameter",
        "signature": "luigi.parameter.MonthParameter.next_in_enumeration(self, value)",
        "snippet": "    def next_in_enumeration(self, value):\n        return self._add_months(value, self.interval)",
        "begin_line": 358,
        "end_line": 359,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.MonthParameter.normalize#361",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.MonthParameter",
        "signature": "luigi.parameter.MonthParameter.normalize(self, value)",
        "snippet": "    def normalize(self, value):\n        if value is None:\n            return None\n\n        months_since_start = (value.year - self.start.year) * 12 + (value.month - self.start.month)\n        months_since_start -= months_since_start % self.interval\n\n        return self._add_months(self.start, months_since_start)",
        "begin_line": 361,
        "end_line": 368,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00032754667540124465,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.YearParameter.normalize#384",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.YearParameter",
        "signature": "luigi.parameter.YearParameter.normalize(self, value)",
        "snippet": "    def normalize(self, value):\n        if value is None:\n            return None\n\n        delta = (value.year - self.start.year) % self.interval\n        return datetime.date(year=value.year - delta, month=1, day=1)",
        "begin_line": 384,
        "end_line": 389,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter._DatetimeParameterBase.__init__#397",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._DatetimeParameterBase",
        "signature": "luigi.parameter._DatetimeParameterBase.__init__(self, interval=1, start=None, **kwargs)",
        "snippet": "    def __init__(self, interval=1, start=None, **kwargs):\n        super(_DatetimeParameterBase, self).__init__(**kwargs)\n        self.interval = interval\n        self.start = start if start is not None else _UNIX_EPOCH",
        "begin_line": 397,
        "end_line": 400,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00024260067928190198,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter._DatetimeParameterBase.parse#416",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._DatetimeParameterBase",
        "signature": "luigi.parameter._DatetimeParameterBase.parse(self, s)",
        "snippet": "    def parse(self, s):\n        \"\"\"\n        Parses a string to a :py:class:`~datetime.datetime`.\n        \"\"\"\n        return datetime.datetime.strptime(s, self.date_format)",
        "begin_line": 416,
        "end_line": 420,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002772387025228722,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter._DatetimeParameterBase.serialize#422",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._DatetimeParameterBase",
        "signature": "luigi.parameter._DatetimeParameterBase.serialize(self, dt)",
        "snippet": "    def serialize(self, dt):\n        \"\"\"\n        Converts the date to a string using the :py:attr:`~_DatetimeParameterBase.date_format`.\n        \"\"\"\n        if dt is None:\n            return str(dt)\n        return dt.strftime(self.date_format)",
        "begin_line": 422,
        "end_line": 428,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00031575623618566466,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter._DatetimeParameterBase.normalize#430",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._DatetimeParameterBase",
        "signature": "luigi.parameter._DatetimeParameterBase.normalize(self, dt)",
        "snippet": "    def normalize(self, dt):\n        \"\"\"\n        Clamp dt to every Nth :py:attr:`~_DatetimeParameterBase.interval` starting at\n        :py:attr:`~_DatetimeParameterBase.start`.\n        \"\"\"\n        if dt is None:\n            return None\n\n        dt = dt.replace(microsecond=0)  # remove microseconds, to avoid float rounding issues.\n        delta = (dt - self.start).total_seconds()\n        granularity = (self._timedelta * self.interval).total_seconds()\n        return dt - datetime.timedelta(seconds=delta % granularity)",
        "begin_line": 430,
        "end_line": 441,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00031575623618566466,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter._DatetimeParameterBase.next_in_enumeration#443",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter._DatetimeParameterBase",
        "signature": "luigi.parameter._DatetimeParameterBase.next_in_enumeration(self, value)",
        "snippet": "    def next_in_enumeration(self, value):\n        return value + self._timedelta * self.interval",
        "begin_line": 443,
        "end_line": 444,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.DateMinuteParameter.parse#475",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.DateMinuteParameter",
        "signature": "luigi.parameter.DateMinuteParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        try:\n            value = datetime.datetime.strptime(s, self.deprecated_date_format)\n            warnings.warn(\n                'Using \"H\" between hours and minutes is deprecated, omit it instead.',\n                DeprecationWarning,\n                stacklevel=2\n            )\n            return value\n        except ValueError:\n            return super(DateMinuteParameter, self).parse(s)",
        "begin_line": 475,
        "end_line": 485,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.IntParameter.parse#493",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.IntParameter",
        "signature": "luigi.parameter.IntParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        \"\"\"\n        Parses an ``int`` from the string using ``int()``.\n        \"\"\"\n        return int(s)",
        "begin_line": 493,
        "end_line": 497,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009328358208955224,
            "pseudo_dstar_susp": 0.0008802816901408451,
            "pseudo_tarantula_susp": 0.002178649237472767,
            "pseudo_op2_susp": 0.0008802816901408451,
            "pseudo_barinel_susp": 0.002178649237472767
        }
    },
    {
        "name": "luigi.parameter.IntParameter.next_in_enumeration#499",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.IntParameter",
        "signature": "luigi.parameter.IntParameter.next_in_enumeration(self, value)",
        "snippet": "    def next_in_enumeration(self, value):\n        return value + 1",
        "begin_line": 499,
        "end_line": 500,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00024073182474723158,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.FloatParameter.parse#508",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.FloatParameter",
        "signature": "luigi.parameter.FloatParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        \"\"\"\n        Parses a ``float`` from the string using ``float()``.\n        \"\"\"\n        return float(s)",
        "begin_line": 508,
        "end_line": 512,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00031575623618566466,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.BoolParameter.__init__#521",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.BoolParameter",
        "signature": "luigi.parameter.BoolParameter.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        super(BoolParameter, self).__init__(*args, **kwargs)\n        if self._default == _no_value:\n            self._default = False",
        "begin_line": 521,
        "end_line": 524,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.BoolParameter.parse#526",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.BoolParameter",
        "signature": "luigi.parameter.BoolParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        \"\"\"\n        Parses a ``bool`` from the string, matching 'true' or 'false' ignoring case.\n        \"\"\"\n        return {'true': True, 'false': False}[str(s).lower()]",
        "begin_line": 526,
        "end_line": 530,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000877963125548727,
            "pseudo_dstar_susp": 0.0008658008658008658,
            "pseudo_tarantula_susp": 0.0017825311942959,
            "pseudo_op2_susp": 0.0008658008658008658,
            "pseudo_barinel_susp": 0.0017761989342806395
        }
    },
    {
        "name": "luigi.parameter.BoolParameter.normalize#532",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.BoolParameter",
        "signature": "luigi.parameter.BoolParameter.normalize(self, value)",
        "snippet": "    def normalize(self, value):\n        # coerce anything truthy to True\n        return bool(value) if value is not None else None",
        "begin_line": 532,
        "end_line": 534,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003278688524590164,
            "pseudo_dstar_susp": 0.00819672131147541,
            "pseudo_tarantula_susp": 0.001953125,
            "pseudo_op2_susp": 0.00819672131147541,
            "pseudo_barinel_susp": 0.001953125
        }
    },
    {
        "name": "luigi.parameter.BoolParameter._parser_action#537",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.BoolParameter",
        "signature": "luigi.parameter.BoolParameter._parser_action()",
        "snippet": "    def _parser_action():\n        return 'store_true'",
        "begin_line": 537,
        "end_line": 538,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0028328611898017,
            "pseudo_dstar_susp": 0.0021321961620469083,
            "pseudo_tarantula_susp": 0.003472222222222222,
            "pseudo_op2_susp": 0.0021321961620469083,
            "pseudo_barinel_susp": 0.003472222222222222
        }
    },
    {
        "name": "luigi.parameter.DateIntervalParameter.parse#564",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.DateIntervalParameter",
        "signature": "luigi.parameter.DateIntervalParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        \"\"\"\n        Parses a :py:class:`~luigi.date_interval.DateInterval` from the input.\n\n        see :py:mod:`luigi.date_interval`\n          for details on the parsing of DateIntervals.\n        \"\"\"\n        # TODO: can we use xml.utils.iso8601 or something similar?\n\n        from luigi import date_interval as d\n\n        for cls in [d.Year, d.Month, d.Week, d.Date, d.Custom]:\n            i = cls.parse(s)\n            if i:\n                return i\n\n        raise ValueError('Invalid date interval - could not be parsed')",
        "begin_line": 564,
        "end_line": 580,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.TimeDeltaParameter._apply_regex#595",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TimeDeltaParameter",
        "signature": "luigi.parameter.TimeDeltaParameter._apply_regex(self, regex, input)",
        "snippet": "    def _apply_regex(self, regex, input):\n        import re\n        re_match = re.match(regex, input)\n        if re_match:\n            kwargs = {}\n            has_val = False\n            for k, v in six.iteritems(re_match.groupdict(default=\"0\")):\n                val = int(v)\n                has_val = has_val or val != 0\n                kwargs[k] = val\n            if has_val:\n                return datetime.timedelta(**kwargs)",
        "begin_line": 595,
        "end_line": 606,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002937720329024677,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.TimeDeltaParameter._parseIso8601#608",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TimeDeltaParameter",
        "signature": "luigi.parameter.TimeDeltaParameter._parseIso8601(self, input)",
        "snippet": "    def _parseIso8601(self, input):\n        def field(key):\n            return r\"(?P<%s>\\d+)%s\" % (key, key[0].upper())\n\n        def optional_field(key):\n            return \"(%s)?\" % field(key)\n        # A little loose: ISO 8601 does not allow weeks in combination with other fields, but this regex does (as does python timedelta)\n        regex = \"P(%s|%s(T%s)?)\" % (field(\"weeks\"), optional_field(\"days\"), \"\".join([optional_field(key) for key in [\"hours\", \"minutes\", \"seconds\"]]))\n        return self._apply_regex(regex, input)",
        "begin_line": 608,
        "end_line": 616,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002772387025228722,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.TimeDeltaParameter.field#609",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TimeDeltaParameter",
        "signature": "luigi.parameter.TimeDeltaParameter.field(key)",
        "snippet": "        def field(key):\n            return r\"(?P<%s>\\d+)%s\" % (key, key[0].upper())",
        "begin_line": 609,
        "end_line": 610,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002772387025228722,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.TimeDeltaParameter.optional_field#612",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TimeDeltaParameter",
        "signature": "luigi.parameter.TimeDeltaParameter.optional_field(key)",
        "snippet": "        def optional_field(key):\n            return \"(%s)?\" % field(key)",
        "begin_line": 612,
        "end_line": 613,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002772387025228722,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.TimeDeltaParameter._parseSimple#618",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TimeDeltaParameter",
        "signature": "luigi.parameter.TimeDeltaParameter._parseSimple(self, input)",
        "snippet": "    def _parseSimple(self, input):\n        keys = [\"weeks\", \"days\", \"hours\", \"minutes\", \"seconds\"]\n        # Give the digits a regex group name from the keys, then look for text with the first letter of the key,\n        # optionally followed by the rest of the word, with final char (the \"s\") optional\n        regex = \"\".join([r\"((?P<%s>\\d+) ?%s(%s)?(%s)? ?)?\" % (k, k[0], k[1:-1], k[-1]) for k in keys])\n        return self._apply_regex(regex, input)",
        "begin_line": 618,
        "end_line": 623,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00031575623618566466,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.TimeDeltaParameter.parse#625",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TimeDeltaParameter",
        "signature": "luigi.parameter.TimeDeltaParameter.parse(self, input)",
        "snippet": "    def parse(self, input):\n        \"\"\"\n        Parses a time delta from the input.\n\n        See :py:class:`TimeDeltaParameter` for details on supported formats.\n        \"\"\"\n        result = self._parseIso8601(input)\n        if not result:\n            result = self._parseSimple(input)\n        if result:\n            return result\n        else:\n            raise ParameterException(\"Invalid time delta - could not parse %s\" % input)",
        "begin_line": 625,
        "end_line": 637,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.TaskParameter.parse#659",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TaskParameter",
        "signature": "luigi.parameter.TaskParameter.parse(self, input)",
        "snippet": "    def parse(self, input):\n        \"\"\"\n        Parse a task_famly using the :class:`~luigi.task_register.Register`\n        \"\"\"\n        return task_register.Register.get_task_cls(input)",
        "begin_line": 659,
        "end_line": 663,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.TaskParameter.serialize#665",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TaskParameter",
        "signature": "luigi.parameter.TaskParameter.serialize(self, cls)",
        "snippet": "    def serialize(self, cls):\n        \"\"\"\n        Converts the :py:class:`luigi.task.Task` (sub) class to its family name.\n        \"\"\"\n        return cls.task_family",
        "begin_line": 665,
        "end_line": 669,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002452783909737552,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.EnumParameter.__init__#694",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.EnumParameter",
        "signature": "luigi.parameter.EnumParameter.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        if 'enum' not in kwargs:\n            raise ParameterException('An enum class must be specified.')\n        self._enum = kwargs.pop('enum')\n        super(EnumParameter, self).__init__(*args, **kwargs)",
        "begin_line": 694,
        "end_line": 698,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.EnumParameter.parse#700",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.EnumParameter",
        "signature": "luigi.parameter.EnumParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        try:\n            return self._enum[s]\n        except KeyError:\n            raise ValueError('Invalid enum value - could not be parsed')",
        "begin_line": 700,
        "end_line": 704,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.EnumParameter.serialize#706",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.EnumParameter",
        "signature": "luigi.parameter.EnumParameter.serialize(self, e)",
        "snippet": "    def serialize(self, e):\n        return e.name",
        "begin_line": 706,
        "end_line": 707,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.FrozenOrderedDict.__init__#716",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.FrozenOrderedDict",
        "signature": "luigi.parameter.FrozenOrderedDict.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        self.__dict = OrderedDict(*args, **kwargs)\n        self.__hash = None",
        "begin_line": 716,
        "end_line": 718,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.FrozenOrderedDict.__getitem__#720",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.FrozenOrderedDict",
        "signature": "luigi.parameter.FrozenOrderedDict.__getitem__(self, key)",
        "snippet": "    def __getitem__(self, key):\n        return self.__dict[key]",
        "begin_line": 720,
        "end_line": 721,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.FrozenOrderedDict.__iter__#723",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.FrozenOrderedDict",
        "signature": "luigi.parameter.FrozenOrderedDict.__iter__(self)",
        "snippet": "    def __iter__(self):\n        return iter(self.__dict)",
        "begin_line": 723,
        "end_line": 724,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.FrozenOrderedDict.__repr__#729",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.FrozenOrderedDict",
        "signature": "luigi.parameter.FrozenOrderedDict.__repr__(self)",
        "snippet": "    def __repr__(self):\n        return '<FrozenOrderedDict %s>' % repr(self.__dict)",
        "begin_line": 729,
        "end_line": 730,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.FrozenOrderedDict.__hash__#732",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.FrozenOrderedDict",
        "signature": "luigi.parameter.FrozenOrderedDict.__hash__(self)",
        "snippet": "    def __hash__(self):\n        if self.__hash is None:\n            hashes = map(hash, self.items())\n            self.__hash = functools.reduce(operator.xor, hashes, 0)\n\n        return self.__hash",
        "begin_line": 732,
        "end_line": 737,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.FrozenOrderedDict.get_wrapped#739",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.FrozenOrderedDict",
        "signature": "luigi.parameter.FrozenOrderedDict.get_wrapped(self)",
        "snippet": "    def get_wrapped(self):\n        return self.__dict",
        "begin_line": 739,
        "end_line": 740,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.DictParamEncoder.default#780",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.DictParamEncoder",
        "signature": "luigi.parameter.DictParamEncoder.default(self, obj)",
        "snippet": "        def default(self, obj):\n            if isinstance(obj, FrozenOrderedDict):\n                return obj.get_wrapped()\n            return json.JSONEncoder.default(self, obj)",
        "begin_line": 780,
        "end_line": 783,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.DictParameter.parse#785",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.DictParameter",
        "signature": "luigi.parameter.DictParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        \"\"\"\n        Parses an immutable and ordered ``dict`` from a JSON string using standard JSON library.\n\n        We need to use an immutable dictionary, to create a hashable parameter and also preserve the internal structure\n        of parsing. The traversal order of standard ``dict`` is undefined, which can result various string\n        representations of this parameter, and therefore a different task id for the task containing this parameter.\n        This is because task id contains the hash of parameters' JSON representation.\n\n        :param s: String to be parse\n        \"\"\"\n        return json.loads(s, object_pairs_hook=FrozenOrderedDict)",
        "begin_line": 785,
        "end_line": 796,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.parameter.DictParameter.serialize#798",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.DictParameter",
        "signature": "luigi.parameter.DictParameter.serialize(self, x)",
        "snippet": "    def serialize(self, x):\n        return json.dumps(x, cls=DictParameter.DictParamEncoder)",
        "begin_line": 798,
        "end_line": 799,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.FileWrapper.__init__#35",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.FileWrapper",
        "signature": "luigi.format.FileWrapper.__init__(self, file_object)",
        "snippet": "    def __init__(self, file_object):\n        self._subpipe = file_object",
        "begin_line": 35,
        "end_line": 36,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00023596035865974517,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.FileWrapper.__getattr__#38",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.FileWrapper",
        "signature": "luigi.format.FileWrapper.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        # forward calls to 'write', 'close' and other methods not defined below\n        return getattr(self._subpipe, name)",
        "begin_line": 38,
        "end_line": 40,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00023691068467187872,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.FileWrapper.__enter__#42",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.FileWrapper",
        "signature": "luigi.format.FileWrapper.__enter__(self, *args, **kwargs)",
        "snippet": "    def __enter__(self, *args, **kwargs):\n        # instead of returning whatever is returned by __enter__ on the subpipe\n        # this returns self, so whatever custom injected methods are still available\n        # this might cause problems with custom file_objects, but seems to work\n        # fine with standard python `file` objects which is the only default use\n        return self",
        "begin_line": 42,
        "end_line": 47,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00025157232704402514,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.FileWrapper.__exit__#49",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.FileWrapper",
        "signature": "luigi.format.FileWrapper.__exit__(self, *args, **kwargs)",
        "snippet": "    def __exit__(self, *args, **kwargs):\n        return self._subpipe.__exit__(*args, **kwargs)",
        "begin_line": 49,
        "end_line": 50,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00025157232704402514,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.__init__#58",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.__init__(self, command, input_pipe=None)",
        "snippet": "    def __init__(self, command, input_pipe=None):\n        \"\"\"\n        Initializes a InputPipeProcessWrapper instance.\n\n        :param command: a subprocess.Popen instance with stdin=input_pipe and\n                        stdout=subprocess.PIPE.\n                        Alternatively, just its args argument as a convenience.\n        \"\"\"\n        self._command = command\n\n        self._input_pipe = input_pipe\n        self._original_input = True\n\n        if input_pipe is not None:\n            try:\n                input_pipe.fileno()\n            except AttributeError:\n                # subprocess require a fileno to work, if not present we copy to disk first\n                self._original_input = False\n                f = tempfile.NamedTemporaryFile('wb', prefix='luigi-process_tmp', delete=False)\n                self._tmp_file = f.name\n                while True:\n                    chunk = input_pipe.read(io.DEFAULT_BUFFER_SIZE)\n                    if not chunk:\n                        break\n                    f.write(chunk)\n                input_pipe.close()\n                f.close()\n                self._input_pipe = FileWrapper(io.BufferedReader(io.FileIO(self._tmp_file, 'r')))\n\n        self._process = command if isinstance(command, subprocess.Popen) else self.create_subprocess(command)\n        # we want to keep a circular reference to avoid garbage collection\n        # when the object is used in, e.g., pipe.read()\n        self._process._selfref = self",
        "begin_line": 58,
        "end_line": 91,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00026968716289104636,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.create_subprocess#93",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.create_subprocess(self, command)",
        "snippet": "    def create_subprocess(self, command):\n        \"\"\"\n        http://www.chiark.greenend.org.uk/ucgi/~cjwatson/blosxom/2009-07-02-python-sigpipe.html\n        \"\"\"\n\n        def subprocess_setup():\n            # Python installs a SIGPIPE handler by default. This is usually not what\n            # non-Python subprocesses expect.\n            signal.signal(signal.SIGPIPE, signal.SIG_DFL)\n\n        return subprocess.Popen(command,\n                                stdin=self._input_pipe,\n                                stdout=subprocess.PIPE,\n                                preexec_fn=subprocess_setup,\n                                close_fds=True)",
        "begin_line": 93,
        "end_line": 107,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002573340195573855,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.subprocess_setup#98",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.subprocess_setup()",
        "snippet": "        def subprocess_setup():\n            # Python installs a SIGPIPE handler by default. This is usually not what\n            # non-Python subprocesses expect.\n            signal.signal(signal.SIGPIPE, signal.SIG_DFL)",
        "begin_line": 98,
        "end_line": 101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002573340195573855,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper._finish#109",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper._finish(self)",
        "snippet": "    def _finish(self):\n        # Need to close this before input_pipe to get all SIGPIPE messages correctly\n        self._process.stdout.close()\n        if not self._original_input and os.path.exists(self._tmp_file):\n            os.remove(self._tmp_file)\n\n        if self._input_pipe is not None:\n            self._input_pipe.close()\n\n        self._process.wait()  # deadlock?\n        if self._process.returncode not in (0, 141, 128 - 141):\n            # 141 == 128 + 13 == 128 + SIGPIPE - normally processes exit with 128 + {reiceived SIG}\n            # 128 - 141 == -13 == -SIGPIPE, sometimes python receives -13 for some subprocesses\n            raise RuntimeError('Error reading from pipe. Subcommand exited with non-zero exit status %s.' % self._process.returncode)",
        "begin_line": 109,
        "end_line": 122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.close#124",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.close(self)",
        "snippet": "    def close(self):\n        self._finish()",
        "begin_line": 124,
        "end_line": 125,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002842524161455372,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.__del__#127",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.__del__(self)",
        "snippet": "    def __del__(self):\n        self._finish()",
        "begin_line": 127,
        "end_line": 128,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00031575623618566466,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.__enter__#130",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.__enter__(self)",
        "snippet": "    def __enter__(self):\n        return self",
        "begin_line": 130,
        "end_line": 131,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00031575623618566466,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.__exit__#144",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.__exit__(self, type, value, traceback)",
        "snippet": "    def __exit__(self, type, value, traceback):\n        if type:\n            self._abort()\n        else:\n            self._finish()",
        "begin_line": 144,
        "end_line": 148,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00031575623618566466,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.__getattr__#150",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        if name in ['_process', '_input_pipe']:\n            raise AttributeError(name)\n        try:\n            return getattr(self._process.stdout, name)\n        except AttributeError:\n            return getattr(self._input_pipe, name)",
        "begin_line": 150,
        "end_line": 156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00026441036488630354,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.__iter__#158",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.__iter__(self)",
        "snippet": "    def __iter__(self):\n        for line in self._process.stdout:\n            yield line\n        self._finish()",
        "begin_line": 158,
        "end_line": 161,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.readable#163",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.readable(self)",
        "snippet": "    def readable(self):\n        return True",
        "begin_line": 163,
        "end_line": 164,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.writable#166",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.writable(self)",
        "snippet": "    def writable(self):\n        return False",
        "begin_line": 166,
        "end_line": 167,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.seekable#169",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.seekable(self)",
        "snippet": "    def seekable(self):\n        return False",
        "begin_line": 169,
        "end_line": 170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.__init__#176",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.__init__(self, command, output_pipe=None)",
        "snippet": "    def __init__(self, command, output_pipe=None):\n        self.closed = False\n        self._command = command\n        self._output_pipe = output_pipe\n        self._process = subprocess.Popen(command,\n                                         stdin=subprocess.PIPE,\n                                         stdout=output_pipe,\n                                         close_fds=True)\n        self._flushcount = 0",
        "begin_line": 176,
        "end_line": 184,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002607561929595828,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.write#186",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.write(self, *args, **kwargs)",
        "snippet": "    def write(self, *args, **kwargs):\n        self._process.stdin.write(*args, **kwargs)\n        self._flushcount += 1\n        if self._flushcount == self.WRITES_BEFORE_FLUSH:\n            self._process.stdin.flush()\n            self._flushcount = 0",
        "begin_line": 186,
        "end_line": 191,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002607561929595828,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper._finish#197",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper._finish(self)",
        "snippet": "    def _finish(self):\n        \"\"\"\n        Closes and waits for subprocess to exit.\n        \"\"\"\n        if self._process.returncode is None:\n            self._process.stdin.flush()\n            self._process.stdin.close()\n            self._process.wait()\n            self.closed = True",
        "begin_line": 197,
        "end_line": 205,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002607561929595828,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.__del__#207",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.__del__(self)",
        "snippet": "    def __del__(self):\n        if not self.closed:\n            self.abort()",
        "begin_line": 207,
        "end_line": 209,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002607561929595828,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.__exit__#211",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.__exit__(self, type, value, traceback)",
        "snippet": "    def __exit__(self, type, value, traceback):\n        if type is None:\n            self.close()\n        else:\n            self.abort()",
        "begin_line": 211,
        "end_line": 215,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00031575623618566466,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.__enter__#217",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.__enter__(self)",
        "snippet": "    def __enter__(self):\n        return self",
        "begin_line": 217,
        "end_line": 218,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00031575623618566466,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.close#220",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.close(self)",
        "snippet": "    def close(self):\n        self._finish()\n        if self._process.returncode == 0:\n            if self._output_pipe is not None:\n                self._output_pipe.close()\n        else:\n            raise RuntimeError('Error when executing command %s' % self._command)",
        "begin_line": 220,
        "end_line": 226,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002607561929595828,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.__getattr__#231",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        if name in ['_process', '_output_pipe']:\n            raise AttributeError(name)\n        try:\n            return getattr(self._process.stdin, name)\n        except AttributeError:\n            return getattr(self._output_pipe, name)",
        "begin_line": 231,
        "end_line": 237,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00031575623618566466,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.readable#239",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.readable(self)",
        "snippet": "    def readable(self):\n        return False",
        "begin_line": 239,
        "end_line": 240,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.writable#242",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.writable(self)",
        "snippet": "    def writable(self):\n        return True",
        "begin_line": 242,
        "end_line": 243,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.seekable#245",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.seekable(self)",
        "snippet": "    def seekable(self):\n        return False",
        "begin_line": 245,
        "end_line": 246,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.BaseWrapper.__init__#251",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.BaseWrapper",
        "signature": "luigi.format.BaseWrapper.__init__(self, stream, *args, **kwargs)",
        "snippet": "    def __init__(self, stream, *args, **kwargs):\n        self._stream = stream\n        try:\n            super(BaseWrapper, self).__init__(stream, *args, **kwargs)\n        except TypeError:\n            pass",
        "begin_line": 251,
        "end_line": 256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.BaseWrapper.__getattr__#258",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.BaseWrapper",
        "signature": "luigi.format.BaseWrapper.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        if name == '_stream':\n            raise AttributeError(name)\n        return getattr(self._stream, name)",
        "begin_line": 258,
        "end_line": 261,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.BaseWrapper.__enter__#263",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.BaseWrapper",
        "signature": "luigi.format.BaseWrapper.__enter__(self)",
        "snippet": "    def __enter__(self):\n        self._stream.__enter__()\n        return self",
        "begin_line": 263,
        "end_line": 265,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.BaseWrapper.__exit__#267",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.BaseWrapper",
        "signature": "luigi.format.BaseWrapper.__exit__(self, *args)",
        "snippet": "    def __exit__(self, *args):\n        self._stream.__exit__(*args)",
        "begin_line": 267,
        "end_line": 268,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.NewlineWrapper.__init__#280",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.NewlineWrapper",
        "signature": "luigi.format.NewlineWrapper.__init__(self, stream, newline=None)",
        "snippet": "    def __init__(self, stream, newline=None):\n        if newline is None:\n            self.newline = newline\n        else:\n            self.newline = newline.encode('ascii')\n\n        if self.newline not in (b'', b'\\r\\n', b'\\n', b'\\r', None):\n            raise ValueError(\"newline need to be one of {b'', b'\\r\\n', b'\\n', b'\\r', None}\")\n        super(NewlineWrapper, self).__init__(stream)",
        "begin_line": 280,
        "end_line": 288,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.NewlineWrapper.read#290",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.NewlineWrapper",
        "signature": "luigi.format.NewlineWrapper.read(self, n=-1)",
        "snippet": "    def read(self, n=-1):\n        b = self._stream.read(n)\n\n        if self.newline == b'':\n            return b\n\n        if self.newline is None:\n            newline = b'\\n'\n\n        return re.sub(b'(\\n|\\r\\n|\\r)', newline, b)",
        "begin_line": 290,
        "end_line": 299,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.NewlineWrapper.write#311",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.NewlineWrapper",
        "signature": "luigi.format.NewlineWrapper.write(self, b)",
        "snippet": "    def write(self, b):\n        if self.newline is None or self.newline == '':\n            newline = os.linesep.encode('ascii')\n        else:\n            newline = self.newline\n\n        self._stream.write(re.sub(b'(\\n|\\r\\n|\\r)', newline, b))",
        "begin_line": 311,
        "end_line": 317,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.MixedUnicodeBytesWrapper.__init__#324",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.MixedUnicodeBytesWrapper",
        "signature": "luigi.format.MixedUnicodeBytesWrapper.__init__(self, stream, encoding=None)",
        "snippet": "    def __init__(self, stream, encoding=None):\n        if encoding is None:\n            encoding = locale.getpreferredencoding()\n        self.encoding = encoding\n        super(MixedUnicodeBytesWrapper, self).__init__(stream)",
        "begin_line": 324,
        "end_line": 328,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.MixedUnicodeBytesWrapper.write#330",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.MixedUnicodeBytesWrapper",
        "signature": "luigi.format.MixedUnicodeBytesWrapper.write(self, b)",
        "snippet": "    def write(self, b):\n        self._stream.write(self._convert(b))",
        "begin_line": 330,
        "end_line": 331,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.MixedUnicodeBytesWrapper._convert#336",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.MixedUnicodeBytesWrapper",
        "signature": "luigi.format.MixedUnicodeBytesWrapper._convert(self, b)",
        "snippet": "    def _convert(self, b):\n        if isinstance(b, six.text_type):\n            b = b.encode(self.encoding)\n            warnings.warn('Writing unicode to byte stream', stacklevel=2)\n        return b",
        "begin_line": 336,
        "end_line": 340,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.Format.__rshift__#356",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.Format",
        "signature": "luigi.format.Format.__rshift__(a, b)",
        "snippet": "    def __rshift__(a, b):\n        return ChainFormat(a, b)",
        "begin_line": 356,
        "end_line": 357,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00031575623618566466,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.ChainFormat.__init__#362",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.ChainFormat",
        "signature": "luigi.format.ChainFormat.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        self.args = args\n        try:\n            self.input = args[0].input\n        except AttributeError:\n            pass\n        try:\n            self.output = args[-1].output\n        except AttributeError:\n            pass\n        if not kwargs.get('check_consistency', True):\n            return\n        for x in range(len(args) - 1):\n            try:\n                if args[x].output != args[x + 1].input:\n                    raise TypeError(\n                        'The format chaining is not valid, %s expect %s'\n                        'but %s provide %s' % (\n                            args[x].__class__.__name__,\n                            args[x].input,\n                            args[x + 1].__class__.__name__,\n                            args[x + 1].output,\n                        )\n                    )\n            except AttributeError:\n                pass",
        "begin_line": 362,
        "end_line": 387,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00031575623618566466,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.ChainFormat.pipe_reader#389",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.ChainFormat",
        "signature": "luigi.format.ChainFormat.pipe_reader(self, input_pipe)",
        "snippet": "    def pipe_reader(self, input_pipe):\n        for x in reversed(self.args):\n            input_pipe = x.pipe_reader(input_pipe)\n        return input_pipe",
        "begin_line": 389,
        "end_line": 392,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.ChainFormat.pipe_writer#394",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.ChainFormat",
        "signature": "luigi.format.ChainFormat.pipe_writer(self, output_pipe)",
        "snippet": "    def pipe_writer(self, output_pipe):\n        for x in reversed(self.args):\n            output_pipe = x.pipe_writer(output_pipe)\n        return output_pipe",
        "begin_line": 394,
        "end_line": 397,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.TextWrapper.__exit__#402",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.TextWrapper",
        "signature": "luigi.format.TextWrapper.__exit__(self, *args)",
        "snippet": "    def __exit__(self, *args):\n        # io.TextIOWrapper close the file on __exit__, let the underlying file decide\n        if not self.closed and self.writable():\n            super(TextWrapper, self).flush()\n\n        self._stream.__exit__(*args)",
        "begin_line": 402,
        "end_line": 407,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00411522633744856,
            "pseudo_dstar_susp": 0.0023148148148148147,
            "pseudo_tarantula_susp": 0.004761904761904762,
            "pseudo_op2_susp": 0.0023148148148148147,
            "pseudo_barinel_susp": 0.004761904761904762
        }
    },
    {
        "name": "luigi.format.TextWrapper.__del__#409",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.TextWrapper",
        "signature": "luigi.format.TextWrapper.__del__(self, *args)",
        "snippet": "    def __del__(self, *args):\n        # io.TextIOWrapper close the file on __del__, let the underlying file decide\n        if not self.closed and self.writable():\n            super(TextWrapper, self).flush()\n\n        try:\n            self._stream.__del__(*args)\n        except AttributeError:\n            pass",
        "begin_line": 409,
        "end_line": 417,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001876172607879925,
            "pseudo_dstar_susp": 0.0018587360594795538,
            "pseudo_tarantula_susp": 0.0022727272727272726,
            "pseudo_op2_susp": 0.0018587360594795538,
            "pseudo_barinel_susp": 0.0022727272727272726
        }
    },
    {
        "name": "luigi.format.TextWrapper.__init__#419",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.TextWrapper",
        "signature": "luigi.format.TextWrapper.__init__(self, stream, *args, **kwargs)",
        "snippet": "    def __init__(self, stream, *args, **kwargs):\n        self._stream = stream\n        try:\n            super(TextWrapper, self).__init__(stream, *args, **kwargs)\n        except TypeError:\n            pass",
        "begin_line": 419,
        "end_line": 424,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018018018018018018,
            "pseudo_dstar_susp": 0.0018214936247723133,
            "pseudo_tarantula_susp": 0.002197802197802198,
            "pseudo_op2_susp": 0.0018214936247723133,
            "pseudo_barinel_susp": 0.002197802197802198
        }
    },
    {
        "name": "luigi.format.TextWrapper.__getattr__#426",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.TextWrapper",
        "signature": "luigi.format.TextWrapper.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        if name == '_stream':\n            raise AttributeError(name)\n        return getattr(self._stream, name)",
        "begin_line": 426,
        "end_line": 429,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00023452157598499062,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.TextWrapper.__enter__#431",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.TextWrapper",
        "signature": "luigi.format.TextWrapper.__enter__(self)",
        "snippet": "    def __enter__(self):\n        self._stream.__enter__()\n        return self",
        "begin_line": 431,
        "end_line": 433,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0033333333333333335,
            "pseudo_dstar_susp": 0.0022935779816513763,
            "pseudo_tarantula_susp": 0.004672897196261682,
            "pseudo_op2_susp": 0.0022935779816513763,
            "pseudo_barinel_susp": 0.004672897196261682
        }
    },
    {
        "name": "luigi.format.NopFormat.pipe_reader#437",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.NopFormat",
        "signature": "luigi.format.NopFormat.pipe_reader(self, input_pipe)",
        "snippet": "    def pipe_reader(self, input_pipe):\n        return input_pipe",
        "begin_line": 437,
        "end_line": 438,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.NopFormat.pipe_writer#440",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.NopFormat",
        "signature": "luigi.format.NopFormat.pipe_writer(self, output_pipe)",
        "snippet": "    def pipe_writer(self, output_pipe):\n        return output_pipe",
        "begin_line": 440,
        "end_line": 441,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.WrappedFormat.__init__#446",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.WrappedFormat",
        "signature": "luigi.format.WrappedFormat.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        self.args = args\n        self.kwargs = kwargs",
        "begin_line": 446,
        "end_line": 448,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.WrappedFormat.pipe_reader#450",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.WrappedFormat",
        "signature": "luigi.format.WrappedFormat.pipe_reader(self, input_pipe)",
        "snippet": "    def pipe_reader(self, input_pipe):\n        return self.wrapper_cls(input_pipe, *self.args, **self.kwargs)",
        "begin_line": 450,
        "end_line": 451,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00023452157598499062,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.WrappedFormat.pipe_writer#453",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.WrappedFormat",
        "signature": "luigi.format.WrappedFormat.pipe_writer(self, output_pipe)",
        "snippet": "    def pipe_writer(self, output_pipe):\n        return self.wrapper_cls(output_pipe, *self.args, **self.kwargs)",
        "begin_line": 453,
        "end_line": 454,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001876172607879925,
            "pseudo_dstar_susp": 0.0018587360594795538,
            "pseudo_tarantula_susp": 0.0022727272727272726,
            "pseudo_op2_susp": 0.0018587360594795538,
            "pseudo_barinel_susp": 0.0022727272727272726
        }
    },
    {
        "name": "luigi.format.GzipFormat.pipe_reader#485",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.GzipFormat",
        "signature": "luigi.format.GzipFormat.pipe_reader(self, input_pipe)",
        "snippet": "    def pipe_reader(self, input_pipe):\n        return InputPipeProcessWrapper(['gunzip'], input_pipe)",
        "begin_line": 485,
        "end_line": 486,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002842524161455372,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.GzipFormat.pipe_writer#488",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.GzipFormat",
        "signature": "luigi.format.GzipFormat.pipe_writer(self, output_pipe)",
        "snippet": "    def pipe_writer(self, output_pipe):\n        args = ['gzip']\n        if self.compression_level is not None:\n            args.append('-' + str(int(self.compression_level)))\n        return OutputPipeProcessWrapper(args, output_pipe)",
        "begin_line": 488,
        "end_line": 492,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00026968716289104636,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.Bzip2Format.pipe_reader#500",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.Bzip2Format",
        "signature": "luigi.format.Bzip2Format.pipe_reader(self, input_pipe)",
        "snippet": "    def pipe_reader(self, input_pipe):\n        return InputPipeProcessWrapper(['bzcat'], input_pipe)",
        "begin_line": 500,
        "end_line": 501,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.Bzip2Format.pipe_writer#503",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.Bzip2Format",
        "signature": "luigi.format.Bzip2Format.pipe_writer(self, output_pipe)",
        "snippet": "    def pipe_writer(self, output_pipe):\n        return OutputPipeProcessWrapper(['bzip2'], output_pipe)",
        "begin_line": 503,
        "end_line": 504,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.format.get_default_format#515",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format",
        "signature": "luigi.format.get_default_format()",
        "snippet": "def get_default_format():\n    if six.PY3:\n        return Text\n    elif os.linesep == '\\n':\n        return Nop\n    else:\n        return SysNewLine",
        "begin_line": 515,
        "end_line": 521,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004608294930875576,
            "pseudo_dstar_susp": 0.0070921985815602835,
            "pseudo_tarantula_susp": 0.003076923076923077,
            "pseudo_op2_susp": 0.0070921985815602835,
            "pseudo_barinel_susp": 0.003076923076923077
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.pig_home#44",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.pig_home(self)",
        "snippet": "    def pig_home(self):\n        return configuration.get_config().get('pig', 'home', '/usr/share/pig')",
        "begin_line": 44,
        "end_line": 45,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.pig_command_path#47",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.pig_command_path(self)",
        "snippet": "    def pig_command_path(self):\n        return os.path.join(self.pig_home(), \"bin/pig\")",
        "begin_line": 47,
        "end_line": 48,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.pig_env_vars#50",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.pig_env_vars(self)",
        "snippet": "    def pig_env_vars(self):\n        \"\"\"\n        Dictionary of environment variables that should be set when running Pig.\n\n        Ex::\n            return { 'PIG_CLASSPATH': '/your/path' }\n        \"\"\"\n        return {}",
        "begin_line": 50,
        "end_line": 57,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.pig_properties#59",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.pig_properties(self)",
        "snippet": "    def pig_properties(self):\n        \"\"\"\n        Dictionary of properties that should be set when running Pig.\n\n        Example::\n\n            return { 'pig.additional.jars':'/path/to/your/jar' }\n        \"\"\"\n        return {}",
        "begin_line": 59,
        "end_line": 67,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.pig_parameters#69",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.pig_parameters(self)",
        "snippet": "    def pig_parameters(self):\n        \"\"\"\n        Dictionary of parameters that should be set for the Pig job.\n\n        Example::\n\n            return { 'YOUR_PARAM_NAME':'Your param value' }\n        \"\"\"\n        return {}",
        "begin_line": 69,
        "end_line": 77,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.pig_options#79",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.pig_options(self)",
        "snippet": "    def pig_options(self):\n        \"\"\"\n        List of options that will be appended to the Pig command.\n\n        Example::\n\n            return ['-x', 'local']\n        \"\"\"\n        return []",
        "begin_line": 79,
        "end_line": 87,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask._build_pig_cmd#99",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask._build_pig_cmd(self)",
        "snippet": "    def _build_pig_cmd(self):\n        opts = self.pig_options()\n\n        def line(k, v):\n            return ('%s=%s%s' % (k, v, os.linesep)).encode('utf-8')\n\n        with tempfile.NamedTemporaryFile() as param_file, tempfile.NamedTemporaryFile() as prop_file:\n            if self.pig_parameters():\n                items = six.iteritems(self.pig_parameters())\n                param_file.writelines(line(k, v) for (k, v) in items)\n                param_file.flush()\n                opts.append('-param_file')\n                opts.append(param_file.name)\n\n            if self.pig_properties():\n                items = six.iteritems(self.pig_properties())\n                prop_file.writelines(line(k, v) for (k, v) in items)\n                prop_file.flush()\n                opts.append('-propertyFile')\n                opts.append(prop_file.name)\n\n            cmd = [self.pig_command_path()] + opts + [\"-f\", self.pig_script_path()]\n\n            logger.info(subprocess.list2cmdline(cmd))\n            yield cmd",
        "begin_line": 99,
        "end_line": 123,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.line#102",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.line(k, v)",
        "snippet": "        def line(k, v):\n            return ('%s=%s%s' % (k, v, os.linesep)).encode('utf-8')",
        "begin_line": 102,
        "end_line": 103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.run#125",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.run(self)",
        "snippet": "    def run(self):\n        with self._build_pig_cmd() as cmd:\n            self.track_and_progress(cmd)",
        "begin_line": 125,
        "end_line": 127,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.track_and_progress#129",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.track_and_progress(self, cmd)",
        "snippet": "    def track_and_progress(self, cmd):\n        temp_stdout = tempfile.TemporaryFile()\n        env = os.environ.copy()\n        env['PIG_HOME'] = self.pig_home()\n        for k, v in six.iteritems(self.pig_env_vars()):\n            env[k] = v\n\n        proc = subprocess.Popen(cmd, shell=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env)\n        reads = [proc.stderr.fileno(), proc.stdout.fileno()]\n        # tracking the possible problems with this job\n        err_lines = []\n        with PigRunContext():\n            while proc.poll() is None:\n                ret = select.select(reads, [], [])\n                for fd in ret[0]:\n                    if fd == proc.stderr.fileno():\n                        line = proc.stderr.readline().decode('utf8')\n                        err_lines.append(line)\n                    if fd == proc.stdout.fileno():\n                        line = proc.stdout.readline().decode('utf8')\n                        temp_stdout.write(line)\n\n                err_line = line.lower()\n                if err_line.find('More information at:') != -1:\n                    logger.info(err_line.split('more information at: ')[-1].strip())\n                if err_line.find(' - '):\n                    t = err_line.split(' - ')[-1].strip()\n                    if t != \"\":\n                        logger.info(t)\n\n        # Read the rest + stdout\n        err = ''.join(err_lines + [an_err_line.decode('utf8') for an_err_line in proc.stderr])\n        if proc.returncode == 0:\n            logger.info(\"Job completed successfully!\")\n        else:\n            logger.error(\"Error when running script:\\n%s\", self.pig_script_path())\n            logger.error(err)\n            raise PigJobError(\"Pig script failed with return value: %s\" % (proc.returncode,), err=err)",
        "begin_line": 129,
        "end_line": 166,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.pig.PigRunContext.__init__#170",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigRunContext",
        "signature": "luigi.contrib.pig.PigRunContext.__init__(self)",
        "snippet": "    def __init__(self):\n        self.job_id = None",
        "begin_line": 170,
        "end_line": 171,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.pig.PigRunContext.__enter__#173",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigRunContext",
        "signature": "luigi.contrib.pig.PigRunContext.__enter__(self)",
        "snippet": "    def __enter__(self):\n        self.__old_signal = signal.getsignal(signal.SIGTERM)\n        signal.signal(signal.SIGTERM, self.kill_job)\n        return self",
        "begin_line": 173,
        "end_line": 176,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.pig.PigRunContext.__exit__#186",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigRunContext",
        "signature": "luigi.contrib.pig.PigRunContext.__exit__(self, exc_type, exc_val, exc_tb)",
        "snippet": "    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is KeyboardInterrupt:\n            self.kill_job()\n        signal.signal(signal.SIGTERM, self.__old_signal)",
        "begin_line": 186,
        "end_line": 189,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobError.__init__#193",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobError",
        "signature": "luigi.contrib.pig.PigJobError.__init__(self, message, out=None, err=None)",
        "snippet": "    def __init__(self, message, out=None, err=None):\n        super(PigJobError, self).__init__(message, out, err)\n        self.message = message\n        self.out = out\n        self.err = err",
        "begin_line": 193,
        "end_line": 197,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.table_attributes#135",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.table_attributes(self)",
        "snippet": "    def table_attributes(self):\n        \"\"\"\n        Add extra table attributes, for example:\n\n        DISTSTYLE KEY\n        DISTKEY (MY_FIELD)\n        SORTKEY (MY_FIELD_2, MY_FIELD_3)\n        \"\"\"\n        return ''",
        "begin_line": 135,
        "end_line": 143,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.do_truncate_table#146",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.do_truncate_table(self)",
        "snippet": "    def do_truncate_table(self):\n        \"\"\"\n        Return True if table should be truncated before copying new data in.\n        \"\"\"\n        return False",
        "begin_line": 146,
        "end_line": 150,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.do_prune#152",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.do_prune(self)",
        "snippet": "    def do_prune(self):\n        \"\"\"\n        Return True if prune_table, prune_column, and prune_date are implemented.\n        If only a subset of prune variables are override, an exception is raised to remind the user to implement all or none.\n        Prune (data newer than prune_date deleted) before copying new data in.\n        \"\"\"\n        if self.prune_table and self.prune_column and self.prune_date:\n            return True\n        elif self.prune_table or self.prune_column or self.prune_date:\n            raise Exception('override zero or all prune variables')\n        else:\n            return False",
        "begin_line": 152,
        "end_line": 163,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.table_type#166",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.table_type(self)",
        "snippet": "    def table_type(self):\n        \"\"\"\n        Return table type (i.e. 'temp').\n        \"\"\"\n        return ''",
        "begin_line": 166,
        "end_line": 170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.queries#173",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.queries(self)",
        "snippet": "    def queries(self):\n        \"\"\"\n        Override to return a list of queries to be executed in order.\n        \"\"\"\n        return []",
        "begin_line": 173,
        "end_line": 177,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.prune#187",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.prune(self, connection)",
        "snippet": "    def prune(self, connection):\n        query = \"delete from %s where %s >= %s\" % (self.prune_table, self.prune_column, self.prune_date)\n        cursor = connection.cursor()\n        try:\n            cursor.execute(query)\n        finally:\n            cursor.close()",
        "begin_line": 187,
        "end_line": 193,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.create_table#195",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.create_table(self, connection)",
        "snippet": "    def create_table(self, connection):\n        \"\"\"\n        Override to provide code for creating the target table.\n\n        By default it will be created using types (optionally)\n        specified in columns.\n\n        If overridden, use the provided connection object for\n        setting up the table in order to create the table and\n        insert data using the same transaction.\n        \"\"\"\n        if len(self.columns[0]) == 1:\n            # only names of columns specified, no types\n            raise NotImplementedError(\"create_table() not implemented \"\n                                      \"for %r and columns types not \"\n                                      \"specified\" % self.table)\n        elif len(self.columns[0]) == 2:\n            # if columns is specified as (name, type) tuples\n            coldefs = ','.join(\n                '{name} {type}'.format(\n                    name=name,\n                    type=type) for name, type in self.columns\n            )\n\n            query = (\"CREATE {type} TABLE \"\n                     \"{table} ({coldefs}) \"\n                     \"{table_attributes}\").format(\n                type=self.table_type,\n                table=self.table,\n                coldefs=coldefs,\n                table_attributes=self.table_attributes)\n\n            connection.cursor().execute(query)",
        "begin_line": 195,
        "end_line": 227,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.run#229",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.run(self)",
        "snippet": "    def run(self):\n        \"\"\"\n        If the target table doesn't exist, self.create_table\n        will be called to attempt to create the table.\n        \"\"\"\n        if not (self.table):\n            raise Exception(\"table need to be specified\")\n\n        path = self.s3_load_path()\n        output = self.output()\n        connection = output.connect()\n        cursor = connection.cursor()\n\n        self.init_copy(connection)\n        self.copy(cursor, path)\n        self.post_copy(cursor)\n\n        # update marker table\n        output.touch(connection)\n        connection.commit()\n\n        # commit and clean up\n        connection.close()",
        "begin_line": 229,
        "end_line": 251,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.copy#253",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.copy(self, cursor, f)",
        "snippet": "    def copy(self, cursor, f):\n        \"\"\"\n        Defines copying from s3 into redshift.\n        \"\"\"\n        logger.info(\"Inserting file: %s\", f)\n        cursor.execute(\"\"\"\n         COPY %s from '%s'\n         CREDENTIALS 'aws_access_key_id=%s;aws_secret_access_key=%s'\n         %s\n         ;\"\"\" % (self.table, f, self.aws_access_key_id,\n                 self.aws_secret_access_key, self.copy_options))",
        "begin_line": 253,
        "end_line": 263,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.output#265",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.output(self)",
        "snippet": "    def output(self):\n        \"\"\"\n        Returns a RedshiftTarget representing the inserted dataset.\n\n        Normally you don't override this.\n        \"\"\"\n        return RedshiftTarget(\n            host=self.host,\n            database=self.database,\n            user=self.user,\n            password=self.password,\n            table=self.table,\n            update_id=self.update_id)",
        "begin_line": 265,
        "end_line": 277,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.does_table_exist#279",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.does_table_exist(self, connection)",
        "snippet": "    def does_table_exist(self, connection):\n        \"\"\"\n        Determine whether the table already exists.\n        \"\"\"\n\n        if '.' in self.table:\n            query = (\"select 1 as table_exists \"\n                     \"from information_schema.tables \"\n                     \"where table_schema = %s and table_name = %s limit 1\")\n        else:\n            query = (\"select 1 as table_exists \"\n                     \"from pg_table_def \"\n                     \"where tablename = %s limit 1\")\n        cursor = connection.cursor()\n        try:\n            cursor.execute(query, tuple(self.table.split('.')))\n            result = cursor.fetchone()\n            return bool(result)\n        finally:\n            cursor.close()",
        "begin_line": 279,
        "end_line": 298,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.init_copy#300",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.init_copy(self, connection)",
        "snippet": "    def init_copy(self, connection):\n        \"\"\"\n        Perform pre-copy sql - such as creating table, truncating, or removing data older than x.\n        \"\"\"\n        if not self.does_table_exist(connection):\n            logger.info(\"Creating table %s\", self.table)\n            connection.reset()\n            self.create_table(connection)\n\n        if self.do_truncate_table:\n            logger.info(\"Truncating table %s\", self.table)\n            self.truncate_table(connection)\n\n        if self.do_prune():\n            logger.info(\"Removing %s older than %s from %s\", self.prune_column, self.prune_date, self.prune_table)\n            self.prune(connection)",
        "begin_line": 300,
        "end_line": 315,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.post_copy#317",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.post_copy(self, cursor)",
        "snippet": "    def post_copy(self, cursor):\n        \"\"\"\n        Performs post-copy sql - such as cleansing data, inserting into production table (if copied to temp table), etc.\n        \"\"\"\n        logger.info('Executing post copy queries')\n        for query in self.queries:\n            cursor.execute(query)",
        "begin_line": 317,
        "end_line": 323,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.redshift.RedshiftUnloadTask.unload_query#592",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.RedshiftUnloadTask",
        "signature": "luigi.contrib.redshift.RedshiftUnloadTask.unload_query(self)",
        "snippet": "    def unload_query(self):\n        \"\"\"\n        Default UNLOAD command\n        \"\"\"\n        return (\"UNLOAD ( '{query}' ) TO '{s3_unload_path}' \"\n                \"credentials 'aws_access_key_id={s3_access_key};aws_secret_access_key={s3_security_key}' \"\n                \"{unload_options};\")",
        "begin_line": 592,
        "end_line": 598,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.redshift.RedshiftUnloadTask.run#600",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.RedshiftUnloadTask",
        "signature": "luigi.contrib.redshift.RedshiftUnloadTask.run(self)",
        "snippet": "    def run(self):\n        connection = self.output().connect()\n        cursor = connection.cursor()\n\n        # Retrieve AWS s3 credentials\n        config = luigi.configuration.get_config()\n        if self.aws_access_key_id is None or self.aws_secret_access_key is None:\n            self.aws_access_key_id = config.get('s3', 'aws_access_key_id')\n            self.aws_secret_access_key = config.get('s3', 'aws_secret_access_key')\n        # Optionally we can access env variables to get the keys\n        if self.aws_access_key_id is None or self.aws_access_key_id.strip() == '' \\\n                or self.aws_secret_access_key is None or self.aws_secret_access_key.strip() == '':\n            self.aws_access_key_id = os.environ['AWS_ACCESS_KEY_ID']\n            self.aws_secret_access_key = os.environ['AWS_SECRET_ACCESS_KEY']\n\n        unload_query = self.unload_query.format(\n            query=self.query().replace(\"'\", \"\\'\"),\n            s3_unload_path=self.s3_unload_path,\n            unload_options=self.unload_options,\n            s3_access_key=self.aws_access_key_id,\n            s3_security_key=self.aws_secret_access_key)\n\n        logger.info('Executing unload query from task: {name}'.format(name=self.__class__))\n        try:\n            cursor = connection.cursor()\n            cursor.execute(unload_query)\n            logger.info(cursor.statusmessage)\n        except:\n            raise\n\n        # Update marker table\n        self.output().touch(connection)\n        # commit and close connection\n        connection.commit()\n        connection.close()",
        "begin_line": 600,
        "end_line": 634,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.redshift.RedshiftUnloadTask.output#636",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.RedshiftUnloadTask",
        "signature": "luigi.contrib.redshift.RedshiftUnloadTask.output(self)",
        "snippet": "    def output(self):\n        \"\"\"\n        Returns a RedshiftTarget representing the executed query.\n\n        Normally you don't override this.\n        \"\"\"\n        return RedshiftTarget(\n            host=self.host,\n            database=self.database,\n            user=self.user,\n            password=self.password,\n            table=self.table,\n            update_id=self.update_id\n        )",
        "begin_line": 636,
        "end_line": 649,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.HiveCommandError.__init__#40",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveCommandError",
        "signature": "luigi.contrib.hive.HiveCommandError.__init__(self, message, out=None, err=None)",
        "snippet": "    def __init__(self, message, out=None, err=None):\n        super(HiveCommandError, self).__init__(message, out, err)\n        self.message = message\n        self.out = out\n        self.err = err",
        "begin_line": 40,
        "end_line": 44,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.load_hive_cmd#47",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive",
        "signature": "luigi.contrib.hive.load_hive_cmd()",
        "snippet": "def load_hive_cmd():\n    return luigi.configuration.get_config().get('hive', 'command', 'hive')",
        "begin_line": 47,
        "end_line": 48,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.get_hive_syntax#51",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive",
        "signature": "luigi.contrib.hive.get_hive_syntax()",
        "snippet": "def get_hive_syntax():\n    return luigi.configuration.get_config().get('hive', 'release', 'cdh4')",
        "begin_line": 51,
        "end_line": 52,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.run_hive#55",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive",
        "signature": "luigi.contrib.hive.run_hive(args, check_return_code=True)",
        "snippet": "def run_hive(args, check_return_code=True):\n    \"\"\"\n    Runs the `hive` from the command line, passing in the given args, and\n    returning stdout.\n\n    With the apache release of Hive, so of the table existence checks\n    (which are done using DESCRIBE do not exit with a return code of 0\n    so we need an option to ignore the return code and just return stdout for parsing\n    \"\"\"\n    cmd = [load_hive_cmd()] + args\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    stdout, stderr = p.communicate()\n    if check_return_code and p.returncode != 0:\n        raise HiveCommandError(\"Hive command: {0} failed with error code: {1}\".format(\" \".join(cmd), p.returncode),\n                               stdout, stderr)\n    return stdout",
        "begin_line": 55,
        "end_line": 70,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.run_hive_cmd#73",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive",
        "signature": "luigi.contrib.hive.run_hive_cmd(hivecmd, check_return_code=True)",
        "snippet": "def run_hive_cmd(hivecmd, check_return_code=True):\n    \"\"\"\n    Runs the given hive query and returns stdout.\n    \"\"\"\n    return run_hive(['-e', hivecmd], check_return_code)",
        "begin_line": 73,
        "end_line": 77,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.run_hive_script#80",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive",
        "signature": "luigi.contrib.hive.run_hive_script(script)",
        "snippet": "def run_hive_script(script):\n    \"\"\"\n    Runs the contents of the given script in hive and returns stdout.\n    \"\"\"\n    if not os.path.isfile(script):\n        raise RuntimeError(\"Hive script: {0} does not exist.\".format(script))\n    return run_hive(['-f', script])",
        "begin_line": 80,
        "end_line": 86,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.HiveCommandClient.table_location#126",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveCommandClient",
        "signature": "luigi.contrib.hive.HiveCommandClient.table_location(self, table, database='default', partition=None)",
        "snippet": "    def table_location(self, table, database='default', partition=None):\n        cmd = \"use {0}; describe formatted {1}\".format(database, table)\n        if partition is not None:\n            cmd += \" PARTITION ({0})\".format(self.partition_spec(partition))\n\n        stdout = run_hive_cmd(cmd)\n\n        for line in stdout.split(\"\\n\"):\n            if \"Location:\" in line:\n                return line.split(\"\\t\")[1]",
        "begin_line": 126,
        "end_line": 135,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.HiveCommandClient.table_exists#137",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveCommandClient",
        "signature": "luigi.contrib.hive.HiveCommandClient.table_exists(self, table, database='default', partition=None)",
        "snippet": "    def table_exists(self, table, database='default', partition=None):\n        if partition is None:\n            stdout = run_hive_cmd('use {0}; show tables like \"{1}\";'.format(database, table))\n\n            return stdout and table.lower() in stdout\n        else:\n            stdout = run_hive_cmd(\"\"\"use %s; show partitions %s partition\n                                (%s)\"\"\" % (database, table, self.partition_spec(partition)))\n\n            if stdout:\n                return True\n            else:\n                return False",
        "begin_line": 137,
        "end_line": 149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.HiveCommandClient.table_schema#151",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveCommandClient",
        "signature": "luigi.contrib.hive.HiveCommandClient.table_schema(self, table, database='default')",
        "snippet": "    def table_schema(self, table, database='default'):\n        describe = run_hive_cmd(\"use {0}; describe {1}\".format(database, table))\n        if not describe or \"does not exist\" in describe:\n            return None\n        return [tuple([x.strip() for x in line.strip().split(\"\\t\")]) for line in describe.strip().split(\"\\n\")]",
        "begin_line": 151,
        "end_line": 155,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.HiveCommandClient.partition_spec#157",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveCommandClient",
        "signature": "luigi.contrib.hive.HiveCommandClient.partition_spec(self, partition)",
        "snippet": "    def partition_spec(self, partition):\n        \"\"\"\n        Turns a dict into the a Hive partition specification string.\n        \"\"\"\n        return ','.join([\"`{0}`='{1}'\".format(k, v) for (k, v) in\n                         sorted(six.iteritems(partition), key=operator.itemgetter(0))])",
        "begin_line": 157,
        "end_line": 162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.ApacheHiveCommandClient.table_schema#171",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.ApacheHiveCommandClient",
        "signature": "luigi.contrib.hive.ApacheHiveCommandClient.table_schema(self, table, database='default')",
        "snippet": "    def table_schema(self, table, database='default'):\n        describe = run_hive_cmd(\"use {0}; describe {1}\".format(database, table), False)\n        if not describe or \"Table not found\" in describe:\n            return None\n        return [tuple([x.strip() for x in line.strip().split(\"\\t\")]) for line in describe.strip().split(\"\\n\")]",
        "begin_line": 171,
        "end_line": 175,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.MetastoreClient.table_exists#193",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.MetastoreClient",
        "signature": "luigi.contrib.hive.MetastoreClient.table_exists(self, table, database='default', partition=None)",
        "snippet": "    def table_exists(self, table, database='default', partition=None):\n        with HiveThriftContext() as client:\n            if partition is None:\n                return table in client.get_all_tables(database)\n            else:\n                return partition in self._existing_partitions(table, database, client)",
        "begin_line": 193,
        "end_line": 198,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.MetastoreClient._existing_partitions#200",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.MetastoreClient",
        "signature": "luigi.contrib.hive.MetastoreClient._existing_partitions(self, table, database, client)",
        "snippet": "    def _existing_partitions(self, table, database, client):\n        def _parse_partition_string(partition_string):\n            partition_def = {}\n            for part in partition_string.split(\"/\"):\n                name, value = part.split(\"=\")\n                partition_def[name] = value\n            return partition_def\n\n        # -1 is max_parts, the # of partition names to return (-1 = unlimited)\n        partition_strings = client.get_partition_names(database, table, -1)\n        return [_parse_partition_string(existing_partition) for existing_partition in partition_strings]",
        "begin_line": 200,
        "end_line": 210,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.MetastoreClient._parse_partition_string#201",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.MetastoreClient",
        "signature": "luigi.contrib.hive.MetastoreClient._parse_partition_string(partition_string)",
        "snippet": "        def _parse_partition_string(partition_string):\n            partition_def = {}\n            for part in partition_string.split(\"/\"):\n                name, value = part.split(\"=\")\n                partition_def[name] = value\n            return partition_def",
        "begin_line": 201,
        "end_line": 206,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.MetastoreClient.partition_spec#216",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.MetastoreClient",
        "signature": "luigi.contrib.hive.MetastoreClient.partition_spec(self, partition)",
        "snippet": "    def partition_spec(self, partition):\n        return \"/\".join(\"%s=%s\" % (k, v) for (k, v) in sorted(six.iteritems(partition), key=operator.itemgetter(0)))",
        "begin_line": 216,
        "end_line": 217,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.get_default_client#250",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive",
        "signature": "luigi.contrib.hive.get_default_client()",
        "snippet": "def get_default_client():\n    syntax = get_hive_syntax()\n    if syntax == \"apache\":\n        return ApacheHiveCommandClient()\n    elif syntax == \"metastore\":\n        return MetastoreClient()\n    else:\n        return HiveCommandClient()",
        "begin_line": 250,
        "end_line": 257,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.HiveQueryTask.hiverc#278",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveQueryTask",
        "signature": "luigi.contrib.hive.HiveQueryTask.hiverc(self)",
        "snippet": "    def hiverc(self):\n        \"\"\"\n        Location of an rc file to run before the query\n        if hiverc-location key is specified in luigi.cfg, will default to the value there\n        otherwise returns None.\n\n        Returning a list of rc files will load all of them in order.\n        \"\"\"\n        return luigi.configuration.get_config().get('hive', 'hiverc-location', default=None)",
        "begin_line": 278,
        "end_line": 286,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.HiveQueryTask.hiveconfs#288",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveQueryTask",
        "signature": "luigi.contrib.hive.HiveQueryTask.hiveconfs(self)",
        "snippet": "    def hiveconfs(self):\n        \"\"\"\n        Returns an dict of key=value settings to be passed along\n        to the hive command line via --hiveconf. By default, sets\n        mapred.job.name to task_id and if not None, sets:\n\n        * mapred.reduce.tasks (n_reduce_tasks)\n        * mapred.fairscheduler.pool (pool) or mapred.job.queue.name (pool)\n        * hive.exec.reducers.bytes.per.reducer (bytes_per_reducer)\n        * hive.exec.reducers.max (reducers_max)\n        \"\"\"\n        jcs = {}\n        jcs['mapred.job.name'] = self.task_id\n        if self.n_reduce_tasks is not None:\n            jcs['mapred.reduce.tasks'] = self.n_reduce_tasks\n        if self.pool is not None:\n            # Supporting two schedulers: fair (default) and capacity using the same option\n            scheduler_type = luigi.configuration.get_config().get('hadoop', 'scheduler', 'fair')\n            if scheduler_type == 'fair':\n                jcs['mapred.fairscheduler.pool'] = self.pool\n            elif scheduler_type == 'capacity':\n                jcs['mapred.job.queue.name'] = self.pool\n        if self.bytes_per_reducer is not None:\n            jcs['hive.exec.reducers.bytes.per.reducer'] = self.bytes_per_reducer\n        if self.reducers_max is not None:\n            jcs['hive.exec.reducers.max'] = self.reducers_max\n        return jcs",
        "begin_line": 288,
        "end_line": 314,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.HiveQueryTask.job_runner#316",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveQueryTask",
        "signature": "luigi.contrib.hive.HiveQueryTask.job_runner(self)",
        "snippet": "    def job_runner(self):\n        return HiveQueryRunner()",
        "begin_line": 316,
        "end_line": 317,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.HiveQueryRunner.prepare_outputs#325",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveQueryRunner",
        "signature": "luigi.contrib.hive.HiveQueryRunner.prepare_outputs(self, job)",
        "snippet": "    def prepare_outputs(self, job):\n        \"\"\"\n        Called before job is started.\n\n        If output is a `FileSystemTarget`, create parent directories so the hive command won't fail\n        \"\"\"\n        outputs = flatten(job.output())\n        for o in outputs:\n            if isinstance(o, FileSystemTarget):\n                parent_dir = os.path.dirname(o.path)\n                if parent_dir and not o.fs.exists(parent_dir):\n                    logger.info(\"Creating parent directory %r\", parent_dir)\n                    try:\n                        # there is a possible race condition\n                        # which needs to be handled here\n                        o.fs.mkdir(parent_dir)\n                    except FileAlreadyExists:\n                        pass",
        "begin_line": 325,
        "end_line": 342,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.HiveQueryRunner.run_job#344",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveQueryRunner",
        "signature": "luigi.contrib.hive.HiveQueryRunner.run_job(self, job, tracking_url_callback=None)",
        "snippet": "    def run_job(self, job, tracking_url_callback=None):\n        self.prepare_outputs(job)\n        with tempfile.NamedTemporaryFile() as f:\n            query = job.query()\n            if isinstance(query, unicode):\n                query = query.encode('utf8')\n            f.write(query)\n            f.flush()\n            arglist = [load_hive_cmd(), '-f', f.name]\n            hiverc = job.hiverc()\n            if hiverc:\n                if isinstance(hiverc, str):\n                    hiverc = [hiverc]\n                for rcfile in hiverc:\n                    arglist += ['-i', rcfile]\n            if job.hiveconfs():\n                for k, v in six.iteritems(job.hiveconfs()):\n                    arglist += ['--hiveconf', '{0}={1}'.format(k, v)]\n\n            logger.info(arglist)\n            return luigi.contrib.hadoop.run_and_track_hadoop_job(arglist, tracking_url_callback)",
        "begin_line": 344,
        "end_line": 364,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.HiveTableTarget.__init__#372",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveTableTarget",
        "signature": "luigi.contrib.hive.HiveTableTarget.__init__(self, table, database='default', client=None)",
        "snippet": "    def __init__(self, table, database='default', client=None):\n        self.database = database\n        self.table = table\n        self.hive_cmd = load_hive_cmd()\n        if client is None:\n            client = get_default_client()\n        self.client = client",
        "begin_line": 372,
        "end_line": 378,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.HiveTableTarget.exists#380",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveTableTarget",
        "signature": "luigi.contrib.hive.HiveTableTarget.exists(self)",
        "snippet": "    def exists(self):\n        logger.debug(\"Checking Hive table '%s.%s' exists\", self.database, self.table)\n        return self.client.table_exists(self.table, self.database)",
        "begin_line": 380,
        "end_line": 382,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.HivePartitionTarget.__init__#403",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HivePartitionTarget",
        "signature": "luigi.contrib.hive.HivePartitionTarget.__init__(self, table, partition, database='default', fail_missing_table=True, client=None)",
        "snippet": "    def __init__(self, table, partition, database='default', fail_missing_table=True, client=None):\n        self.database = database\n        self.table = table\n        self.partition = partition\n        if client is None:\n            client = get_default_client()\n        self.client = client\n\n        self.fail_missing_table = fail_missing_table",
        "begin_line": 403,
        "end_line": 411,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hive.HivePartitionTarget.exists#413",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HivePartitionTarget",
        "signature": "luigi.contrib.hive.HivePartitionTarget.exists(self)",
        "snippet": "    def exists(self):\n        try:\n            logger.debug(\"Checking Hive table '{d}.{t}' for partition {p}\".format(d=self.database, t=self.table, p=str(self.partition)))\n            return self.client.table_exists(self.table, self.database, self.partition)\n        except HiveCommandError:\n            if self.fail_missing_table:\n                raise\n            else:\n                if self.client.table_exists(self.table, self.database):\n                    # a real error occurred\n                    raise\n                else:\n                    # oh the table just doesn't exist\n                    return False",
        "begin_line": 413,
        "end_line": 426,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.configuration.LuigiConfigParser.instance#64",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration.LuigiConfigParser",
        "signature": "luigi.configuration.LuigiConfigParser.instance(cls, *args, **kwargs)",
        "snippet": "    def instance(cls, *args, **kwargs):\n        \"\"\" Singleton getter \"\"\"\n        if cls._instance is None:\n            cls._instance = cls(*args, **kwargs)\n            loaded = cls._instance.reload()\n            logging.getLogger('luigi-interface').info('Loaded %r', loaded)\n\n        return cls._instance",
        "begin_line": 64,
        "end_line": 71,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.037037037037037035,
            "pseudo_dstar_susp": 0.3333333333333333,
            "pseudo_tarantula_susp": 0.005376344086021506,
            "pseudo_op2_susp": 0.3333333333333333,
            "pseudo_barinel_susp": 0.005376344086021506
        }
    },
    {
        "name": "luigi.configuration.LuigiConfigParser._get_with_default#84",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration.LuigiConfigParser",
        "signature": "luigi.configuration.LuigiConfigParser._get_with_default(self, method, section, option, default, expected_type=None, **kwargs)",
        "snippet": "    def _get_with_default(self, method, section, option, default, expected_type=None, **kwargs):\n        \"\"\"\n        Gets the value of the section/option using method.\n\n        Returns default if value is not found.\n\n        Raises an exception if the default value is not None and doesn't match the expected_type.\n        \"\"\"\n        try:\n            return method(self, section, option, **kwargs)\n        except (NoOptionError, NoSectionError):\n            if default is LuigiConfigParser.NO_DEFAULT:\n                raise\n            if expected_type is not None and default is not None and \\\n               not isinstance(default, expected_type):\n                raise\n            return default",
        "begin_line": 84,
        "end_line": 100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004694835680751174,
            "pseudo_dstar_susp": 0.02564102564102564,
            "pseudo_tarantula_susp": 0.00199203187250996,
            "pseudo_op2_susp": 0.02564102564102564,
            "pseudo_barinel_susp": 0.00199203187250996
        }
    },
    {
        "name": "luigi.configuration.LuigiConfigParser.get#102",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration.LuigiConfigParser",
        "signature": "luigi.configuration.LuigiConfigParser.get(self, section, option, default=NO_DEFAULT, **kwargs)",
        "snippet": "    def get(self, section, option, default=NO_DEFAULT, **kwargs):\n        return self._get_with_default(ConfigParser.get, section, option, default, **kwargs)",
        "begin_line": 102,
        "end_line": 103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004694835680751174,
            "pseudo_dstar_susp": 0.02564102564102564,
            "pseudo_tarantula_susp": 0.00199203187250996,
            "pseudo_op2_susp": 0.02564102564102564,
            "pseudo_barinel_susp": 0.00199203187250996
        }
    },
    {
        "name": "luigi.configuration.LuigiConfigParser.getboolean#105",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration.LuigiConfigParser",
        "signature": "luigi.configuration.LuigiConfigParser.getboolean(self, section, option, default=NO_DEFAULT)",
        "snippet": "    def getboolean(self, section, option, default=NO_DEFAULT):\n        return self._get_with_default(ConfigParser.getboolean, section, option, default, bool)",
        "begin_line": 105,
        "end_line": 106,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008084074373484236,
            "pseudo_dstar_susp": 0.0008084074373484236,
            "pseudo_tarantula_susp": 0.0008169934640522876,
            "pseudo_op2_susp": 0.0008084074373484236,
            "pseudo_barinel_susp": 0.0008169934640522876
        }
    },
    {
        "name": "luigi.configuration.LuigiConfigParser.getint#108",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration.LuigiConfigParser",
        "signature": "luigi.configuration.LuigiConfigParser.getint(self, section, option, default=NO_DEFAULT)",
        "snippet": "    def getint(self, section, option, default=NO_DEFAULT):\n        return self._get_with_default(ConfigParser.getint, section, option, default, int)",
        "begin_line": 108,
        "end_line": 109,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002772387025228722,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.configuration.LuigiConfigParser.getfloat#111",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration.LuigiConfigParser",
        "signature": "luigi.configuration.LuigiConfigParser.getfloat(self, section, option, default=NO_DEFAULT)",
        "snippet": "    def getfloat(self, section, option, default=NO_DEFAULT):\n        return self._get_with_default(ConfigParser.getfloat, section, option, default, float)",
        "begin_line": 111,
        "end_line": 112,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007262164124909223,
            "pseudo_dstar_susp": 0.0007262164124909223,
            "pseudo_tarantula_susp": 0.0007283321194464676,
            "pseudo_op2_susp": 0.0007262164124909223,
            "pseudo_barinel_susp": 0.0007283321194464676
        }
    },
    {
        "name": "luigi.configuration.LuigiConfigParser.getintdict#114",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration.LuigiConfigParser",
        "signature": "luigi.configuration.LuigiConfigParser.getintdict(self, section)",
        "snippet": "    def getintdict(self, section):\n        try:\n            return dict((key, int(value)) for key, value in self.items(section))\n        except NoSectionError:\n            return {}",
        "begin_line": 114,
        "end_line": 118,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00196078431372549,
            "pseudo_dstar_susp": 0.005291005291005291,
            "pseudo_tarantula_susp": 0.001142857142857143,
            "pseudo_op2_susp": 0.005291005291005291,
            "pseudo_barinel_susp": 0.001142857142857143
        }
    },
    {
        "name": "luigi.configuration.LuigiConfigParser.set#120",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration.LuigiConfigParser",
        "signature": "luigi.configuration.LuigiConfigParser.set(self, section, option, value=None)",
        "snippet": "    def set(self, section, option, value=None):\n        if not ConfigParser.has_section(self, section):\n            ConfigParser.add_section(self, section)\n\n        return ConfigParser.set(self, section, option, value)",
        "begin_line": 120,
        "end_line": 124,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012987012987012988,
            "pseudo_dstar_susp": 0.0125,
            "pseudo_tarantula_susp": 0.047619047619047616,
            "pseudo_op2_susp": 0.0125,
            "pseudo_barinel_susp": 0.047619047619047616
        }
    },
    {
        "name": "luigi.configuration.get_config#127",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration",
        "signature": "luigi.configuration.get_config()",
        "snippet": "def get_config():\n    \"\"\"\n    Convenience method (for backwards compatibility) for accessing config singleton.\n    \"\"\"\n    return LuigiConfigParser.instance()",
        "begin_line": 127,
        "end_line": 131,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.037037037037037035,
            "pseudo_dstar_susp": 0.3333333333333333,
            "pseudo_tarantula_susp": 0.005376344086021506,
            "pseudo_op2_susp": 0.3333333333333333,
            "pseudo_barinel_susp": 0.005376344086021506
        }
    },
    {
        "name": "luigi.task_register.Register.__new__#59",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.__new__(metacls, classname, bases, classdict)",
        "snippet": "    def __new__(metacls, classname, bases, classdict):\n        \"\"\"\n        Custom class creation for namespacing.\n\n        Also register all subclasses.\n\n        Set the task namespace to whatever the currently declared namespace is.\n        \"\"\"\n        if \"task_namespace\" not in classdict:\n            classdict[\"task_namespace\"] = metacls._default_namespace\n\n        cls = super(Register, metacls).__new__(metacls, classname, bases, classdict)\n        metacls._reg.append(cls)\n\n        return cls",
        "begin_line": 59,
        "end_line": 73,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009057971014492754,
            "pseudo_dstar_susp": 0.0009813542688910696,
            "pseudo_tarantula_susp": 0.0009267840593141798,
            "pseudo_op2_susp": 0.0009813542688910696,
            "pseudo_barinel_susp": 0.0009267840593141798
        }
    },
    {
        "name": "luigi.task_register.Register.__call__#75",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.__call__(cls, *args, **kwargs)",
        "snippet": "    def __call__(cls, *args, **kwargs):\n        \"\"\"\n        Custom class instantiation utilizing instance cache.\n\n        If a Task has already been instantiated with the same parameters,\n        the previous instance is returned to reduce number of object instances.\n        \"\"\"\n        def instantiate():\n            return super(Register, cls).__call__(*args, **kwargs)\n\n        h = cls.__instance_cache\n\n        if h is None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        try:\n            hash(k)\n        except TypeError:\n            logger.debug(\"Not all parameter values are hashable so instance isn't coming from the cache\")\n            return instantiate()  # unhashable types in parameters\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]",
        "begin_line": 75,
        "end_line": 104,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004098360655737705,
            "pseudo_dstar_susp": 0.01639344262295082,
            "pseudo_tarantula_susp": 0.0015698587127158557,
            "pseudo_op2_susp": 0.01639344262295082,
            "pseudo_barinel_susp": 0.0015698587127158557
        }
    },
    {
        "name": "luigi.task_register.Register.instantiate#82",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.instantiate()",
        "snippet": "        def instantiate():\n            return super(Register, cls).__call__(*args, **kwargs)",
        "begin_line": 82,
        "end_line": 83,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005649717514124294,
            "pseudo_dstar_susp": 0.029411764705882353,
            "pseudo_tarantula_susp": 0.0015105740181268882,
            "pseudo_op2_susp": 0.029411764705882353,
            "pseudo_barinel_susp": 0.0015105740181268882
        }
    },
    {
        "name": "luigi.task_register.Register.task_family#121",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.task_family(cls)",
        "snippet": "    def task_family(cls):\n        \"\"\"\n        The task family for the given class.\n\n        If ``cls.task_namespace is None`` then it's the name of the class.\n        Otherwise, ``<task_namespace>.`` is prefixed to the class name.\n        \"\"\"\n        if cls.task_namespace is None:\n            return cls.__name__\n        else:\n            return \"%s.%s\" % (cls.task_namespace, cls.__name__)",
        "begin_line": 121,
        "end_line": 131,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004329004329004329,
            "pseudo_dstar_susp": 0.02,
            "pseudo_tarantula_susp": 0.001718213058419244,
            "pseudo_op2_susp": 0.02,
            "pseudo_barinel_susp": 0.001718213058419244
        }
    },
    {
        "name": "luigi.task_register.Register._get_reg#134",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register._get_reg(cls)",
        "snippet": "    def _get_reg(cls):\n        \"\"\"Return all of the registered classes.\n\n        :return:  an ``collections.OrderedDict`` of task_family -> class\n        \"\"\"\n        # We have to do this on-demand in case task names have changed later\n        # We return this in a topologically sorted list of inheritance: this is useful in some cases (#822)\n        reg = OrderedDict()\n        for cls in cls._reg:\n            name = cls.task_family\n\n            if name in reg and reg[name] != cls and \\\n                    reg[name] != cls.AMBIGUOUS_CLASS and \\\n                    not issubclass(cls, reg[name]):\n                # Registering two different classes - this means we can't instantiate them by name\n                # The only exception is if one class is a subclass of the other. In that case, we\n                # instantiate the most-derived class (this fixes some issues with decorator wrappers).\n                reg[name] = cls.AMBIGUOUS_CLASS\n            else:\n                reg[name] = cls\n\n        return reg",
        "begin_line": 134,
        "end_line": 155,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003115264797507788,
            "pseudo_dstar_susp": 0.001579778830963665,
            "pseudo_tarantula_susp": 0.004901960784313725,
            "pseudo_op2_susp": 0.001579778830963665,
            "pseudo_barinel_susp": 0.004901960784313725
        }
    },
    {
        "name": "luigi.task_register.Register._set_reg#158",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register._set_reg(cls, reg)",
        "snippet": "    def _set_reg(cls, reg):\n        \"\"\"The writing complement of _get_reg\n        \"\"\"\n        cls._reg = [task_cls for task_cls in reg.values() if task_cls is not cls.AMBIGUOUS_CLASS]",
        "begin_line": 158,
        "end_line": 161,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001366120218579235,
            "pseudo_dstar_susp": 0.002840909090909091,
            "pseudo_tarantula_susp": 0.0010141987829614604,
            "pseudo_op2_susp": 0.002840909090909091,
            "pseudo_barinel_susp": 0.0010141987829614604
        }
    },
    {
        "name": "luigi.task_register.Register.task_names#164",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.task_names(cls)",
        "snippet": "    def task_names(cls):\n        \"\"\"\n        List of task names as strings\n        \"\"\"\n        return sorted(cls._get_reg().keys())",
        "begin_line": 164,
        "end_line": 168,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.task_register.Register.tasks_str#171",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.tasks_str(cls)",
        "snippet": "    def tasks_str(cls):\n        \"\"\"\n        Human-readable register contents dump.\n        \"\"\"\n        return ','.join(cls.task_names())",
        "begin_line": 171,
        "end_line": 175,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.task_register.Register.get_task_cls#178",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.get_task_cls(cls, name)",
        "snippet": "    def get_task_cls(cls, name):\n        \"\"\"\n        Returns an unambiguous class or raises an exception.\n        \"\"\"\n        task_cls = cls._get_reg().get(name)\n        if not task_cls:\n            raise TaskClassNotFoundException(cls._missing_task_msg(name))\n\n        if task_cls == cls.AMBIGUOUS_CLASS:\n            raise TaskClassAmbigiousException('Task %r is ambiguous' % name)\n        return task_cls",
        "begin_line": 178,
        "end_line": 188,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00625,
            "pseudo_dstar_susp": 0.002012072434607646,
            "pseudo_tarantula_susp": 0.013157894736842105,
            "pseudo_op2_susp": 0.002012072434607646,
            "pseudo_barinel_susp": 0.013333333333333334
        }
    },
    {
        "name": "luigi.task_register.Register.get_all_params#191",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.get_all_params(cls)",
        "snippet": "    def get_all_params(cls):\n        \"\"\"\n        Compiles and returns all parameters for all :py:class:`Task`.\n\n        :return: a generator of tuples (TODO: we should make this more elegant)\n        \"\"\"\n        for task_name, task_cls in six.iteritems(cls._get_reg()):\n            if task_cls == cls.AMBIGUOUS_CLASS:\n                continue\n            for param_name, param_obj in task_cls.get_params():\n                yield task_name, (not task_cls.use_cmdline_section), param_name, param_obj",
        "begin_line": 191,
        "end_line": 201,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004830917874396135,
            "pseudo_dstar_susp": 0.0021321961620469083,
            "pseudo_tarantula_susp": 0.0058823529411764705,
            "pseudo_op2_susp": 0.0021321961620469083,
            "pseudo_barinel_susp": 0.0058823529411764705
        }
    },
    {
        "name": "luigi.task_register.Register._editdistance#204",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register._editdistance(a, b)",
        "snippet": "    def _editdistance(a, b):\n        \"\"\" Simple unweighted Levenshtein distance \"\"\"\n        r0 = range(0, len(b) + 1)\n        r1 = [0] * (len(b) + 1)\n\n        for i in range(0, len(a)):\n            r1[0] = i + 1\n\n            for j in range(0, len(b)):\n                c = 0 if a[i] is b[j] else 1\n                r1[j + 1] = min(r1[j] + 1, r0[j + 1] + 1, r0[j] + c)\n\n            r0 = r1[:]\n\n        return r1[len(b)]",
        "begin_line": 204,
        "end_line": 218,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.task_register.Register._missing_task_msg#221",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register._missing_task_msg(cls, task_name)",
        "snippet": "    def _missing_task_msg(cls, task_name):\n        weighted_tasks = [(Register._editdistance(task_name, task_name_2), task_name_2) for task_name_2 in cls.task_names()]\n        ordered_tasks = sorted(weighted_tasks, key=lambda pair: pair[0])\n        candidates = [task for (dist, task) in ordered_tasks if dist <= 5 and dist < len(task)]\n        if candidates:\n            return \"No task %s. Did you mean:\\n%s\" % (task_name, '\\n'.join(candidates))\n        else:\n            return \"No task %s. Candidates are: %s\" % (task_name, cls.tasks_str())",
        "begin_line": 221,
        "end_line": 228,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.task_register.load_task#231",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register",
        "signature": "luigi.task_register.load_task(module, task_name, params_str)",
        "snippet": "def load_task(module, task_name, params_str):\n    \"\"\"\n    Imports task dynamically given a module and a task name.\n    \"\"\"\n    if module is not None:\n        __import__(module)\n    task_cls = Register.get_task_cls(task_name)\n    return task_cls.from_str_params(params_str)",
        "begin_line": 231,
        "end_line": 238,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002772387025228722,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.mysqldb.MySqlTarget.touch#66",
        "src_path": "luigi/contrib/mysqldb.py",
        "class_name": "luigi.contrib.mysqldb.MySqlTarget",
        "signature": "luigi.contrib.mysqldb.MySqlTarget.touch(self, connection=None)",
        "snippet": "    def touch(self, connection=None):\n        \"\"\"\n        Mark this update as complete.\n\n        IMPORTANT, If the marker table doesn't exist,\n        the connection transaction will be aborted and the connection reset.\n        Then the marker table will be created.\n        \"\"\"\n        self.create_marker_table()\n\n        if connection is None:\n            connection = self.connect()\n            connection.autocommit = True  # if connection created here, we commit it here\n\n        connection.cursor().execute(\n            \"\"\"INSERT INTO {marker_table} (update_id, target_table)\n               VALUES (%s, %s)\n               ON DUPLICATE KEY UPDATE\n               update_id = VALUES(update_id)\n            \"\"\".format(marker_table=self.marker_table),\n            (self.update_id, self.table)\n        )\n        # make sure update is properly marked\n        assert self.exists(connection)",
        "begin_line": 66,
        "end_line": 89,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.mysqldb.MySqlTarget.exists#91",
        "src_path": "luigi/contrib/mysqldb.py",
        "class_name": "luigi.contrib.mysqldb.MySqlTarget",
        "signature": "luigi.contrib.mysqldb.MySqlTarget.exists(self, connection=None)",
        "snippet": "    def exists(self, connection=None):\n        if connection is None:\n            connection = self.connect()\n            connection.autocommit = True\n        cursor = connection.cursor()\n        try:\n            cursor.execute(\"\"\"SELECT 1 FROM {marker_table}\n                WHERE update_id = %s\n                LIMIT 1\"\"\".format(marker_table=self.marker_table),\n                           (self.update_id,)\n                           )\n            row = cursor.fetchone()\n        except mysql.connector.Error as e:\n            if e.errno == errorcode.ER_NO_SUCH_TABLE:\n                row = None\n            else:\n                raise\n        return row is not None",
        "begin_line": 91,
        "end_line": 108,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.mysqldb.MySqlTarget.connect#110",
        "src_path": "luigi/contrib/mysqldb.py",
        "class_name": "luigi.contrib.mysqldb.MySqlTarget",
        "signature": "luigi.contrib.mysqldb.MySqlTarget.connect(self, autocommit=False)",
        "snippet": "    def connect(self, autocommit=False):\n        connection = mysql.connector.connect(user=self.user,\n                                             password=self.password,\n                                             host=self.host,\n                                             port=self.port,\n                                             database=self.database,\n                                             autocommit=autocommit)\n        return connection",
        "begin_line": 110,
        "end_line": 117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.mysqldb.MySqlTarget.create_marker_table#119",
        "src_path": "luigi/contrib/mysqldb.py",
        "class_name": "luigi.contrib.mysqldb.MySqlTarget",
        "signature": "luigi.contrib.mysqldb.MySqlTarget.create_marker_table(self)",
        "snippet": "    def create_marker_table(self):\n        \"\"\"\n        Create marker table if it doesn't exist.\n\n        Using a separate connection since the transaction might have to be reset.\n        \"\"\"\n        connection = self.connect(autocommit=True)\n        cursor = connection.cursor()\n        try:\n            cursor.execute(\n                \"\"\" CREATE TABLE {marker_table} (\n                        id            BIGINT(20)    NOT NULL AUTO_INCREMENT,\n                        update_id     VARCHAR(128)  NOT NULL,\n                        target_table  VARCHAR(128),\n                        inserted      TIMESTAMP DEFAULT NOW(),\n                        PRIMARY KEY (update_id),\n                        KEY id (id)\n                    )\n                \"\"\"\n                .format(marker_table=self.marker_table)\n            )\n        except mysql.connector.Error as e:\n            if e.errno == errorcode.ER_TABLE_EXISTS_ERROR:\n                pass\n            else:\n                raise\n        connection.close()",
        "begin_line": 119,
        "end_line": 145,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hadoop.BaseHadoopJobTask._get_pool#637",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.BaseHadoopJobTask",
        "signature": "luigi.contrib.hadoop.BaseHadoopJobTask._get_pool(self)",
        "snippet": "    def _get_pool(self):\n        \"\"\" Protected method \"\"\"\n        if self.pool:\n            return self.pool\n        if hadoop().pool:\n            return hadoop().pool",
        "begin_line": 637,
        "end_line": 642,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00032754667540124465,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hadoop.BaseHadoopJobTask.jobconfs#648",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.BaseHadoopJobTask",
        "signature": "luigi.contrib.hadoop.BaseHadoopJobTask.jobconfs(self)",
        "snippet": "    def jobconfs(self):\n        jcs = []\n        jcs.append('mapred.job.name=%s' % self.task_id)\n        if self.mr_priority != NotImplemented:\n            jcs.append('mapred.job.priority=%s' % self.mr_priority())\n        pool = self._get_pool()\n        if pool is not None:\n            # Supporting two schedulers: fair (default) and capacity using the same option\n            scheduler_type = configuration.get_config().get('hadoop', 'scheduler', 'fair')\n            if scheduler_type == 'fair':\n                jcs.append('mapred.fairscheduler.pool=%s' % pool)\n            elif scheduler_type == 'capacity':\n                jcs.append('mapred.job.queue.name=%s' % pool)\n        return jcs",
        "begin_line": 648,
        "end_line": 661,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00032754667540124465,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hadoop.BaseHadoopJobTask.init_local#663",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.BaseHadoopJobTask",
        "signature": "luigi.contrib.hadoop.BaseHadoopJobTask.init_local(self)",
        "snippet": "    def init_local(self):\n        \"\"\"\n        Implement any work to setup any internal datastructure etc here.\n\n        You can add extra input using the requires_local/input_local methods.\n\n        Anything you set on the object will be pickled and available on the Hadoop nodes.\n        \"\"\"\n        pass",
        "begin_line": 663,
        "end_line": 671,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00030543677458766036,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hadoop.BaseHadoopJobTask.run#679",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.BaseHadoopJobTask",
        "signature": "luigi.contrib.hadoop.BaseHadoopJobTask.run(self, tracking_url_callback=None)",
        "snippet": "    def run(self, tracking_url_callback=None):\n        # The best solution is to store them as lazy `cached_property`, but it\n        # has extraneous dependency. And `property` is slow (need to be\n        # calculated every time when called), so we save them as attributes\n        # directly.\n        self.serialize = DataInterchange[self.data_interchange_format]['serialize']\n        self.internal_serialize = DataInterchange[self.data_interchange_format]['internal_serialize']\n        self.deserialize = DataInterchange[self.data_interchange_format]['deserialize']\n\n        self.init_local()\n        try:\n            self.job_runner().run_job(self, tracking_url_callback=tracking_url_callback)\n        except TypeError as ex:\n            if 'unexpected keyword argument' not in ex.message:\n                raise\n            self.job_runner().run_job(self)",
        "begin_line": 679,
        "end_line": 694,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hadoop.BaseHadoopJobTask.requires_local#696",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.BaseHadoopJobTask",
        "signature": "luigi.contrib.hadoop.BaseHadoopJobTask.requires_local(self)",
        "snippet": "    def requires_local(self):\n        \"\"\"\n        Default impl - override this method if you need any local input to be accessible in init().\n        \"\"\"\n        return []",
        "begin_line": 696,
        "end_line": 700,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hadoop.BaseHadoopJobTask.requires_hadoop#702",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.BaseHadoopJobTask",
        "signature": "luigi.contrib.hadoop.BaseHadoopJobTask.requires_hadoop(self)",
        "snippet": "    def requires_hadoop(self):\n        return self.requires()  # default impl",
        "begin_line": 702,
        "end_line": 703,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.hadoop.BaseHadoopJobTask.deps#711",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.BaseHadoopJobTask",
        "signature": "luigi.contrib.hadoop.BaseHadoopJobTask.deps(self)",
        "snippet": "    def deps(self):\n        # Overrides the default implementation\n        return luigi.task.flatten(self.requires_hadoop()) + luigi.task.flatten(self.requires_local())",
        "begin_line": 711,
        "end_line": 713,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.sqla.SQLAlchemyTarget.__init__#166",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.SQLAlchemyTarget",
        "signature": "luigi.contrib.sqla.SQLAlchemyTarget.__init__(self, connection_string, target_table, update_id, echo=False, connect_args={})",
        "snippet": "    def __init__(self, connection_string, target_table, update_id, echo=False, connect_args={}):\n        \"\"\"\n        Constructor for the SQLAlchemyTarget.\n\n        :param connection_string: SQLAlchemy connection string\n        :type connection_string: str\n        :param target_table: The table name for the data\n        :type target_table: str\n        :param update_id: An identifier for this data set\n        :type update_id: str\n        :param echo: Flag to setup SQLAlchemy logging\n        :type echo: bool\n        :param connect_args: A dictionary of connection arguments\n        :type connect_args: dict\n        :return:\n        \"\"\"\n        self.target_table = target_table\n        self.update_id = update_id\n        self.connection_string = connection_string\n        self.echo = echo\n        self.connect_args = connect_args\n        self.marker_table_bound = None",
        "begin_line": 166,
        "end_line": 187,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002452783909737552,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.sqla.SQLAlchemyTarget.engine#190",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.SQLAlchemyTarget",
        "signature": "luigi.contrib.sqla.SQLAlchemyTarget.engine(self)",
        "snippet": "    def engine(self):\n        \"\"\"\n        Return an engine instance, creating it if it doesn't exist.\n\n        Recreate the engine connection if it wasn't originally created\n        by the current process.\n        \"\"\"\n        pid = os.getpid()\n        conn = SQLAlchemyTarget._engine_dict.get(self.connection_string)\n        if not conn or conn.pid != pid:\n            # create and reset connection\n            engine = sqlalchemy.create_engine(\n                self.connection_string,\n                connect_args=self.connect_args,\n                echo=self.echo\n            )\n            SQLAlchemyTarget._engine_dict[self.connection_string] = self.Connection(engine, pid)\n        return SQLAlchemyTarget._engine_dict[self.connection_string].engine",
        "begin_line": 190,
        "end_line": 207,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002452783909737552,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.sqla.SQLAlchemyTarget.touch#209",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.SQLAlchemyTarget",
        "signature": "luigi.contrib.sqla.SQLAlchemyTarget.touch(self)",
        "snippet": "    def touch(self):\n        \"\"\"\n        Mark this update as complete.\n        \"\"\"\n        if self.marker_table_bound is None:\n            self.create_marker_table()\n\n        table = self.marker_table_bound\n        id_exists = self.exists()\n        with self.engine.begin() as conn:\n            if not id_exists:\n                ins = table.insert().values(update_id=self.update_id, target_table=self.target_table,\n                                            inserted=datetime.datetime.now())\n            else:\n                ins = table.update().where(sqlalchemy.and_(table.c.update_id == self.update_id,\n                                                           table.c.target_table == self.target_table)).\\\n                    values(update_id=self.update_id, target_table=self.target_table,\n                           inserted=datetime.datetime.now())\n            conn.execute(ins)\n        assert self.exists()",
        "begin_line": 209,
        "end_line": 228,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002772387025228722,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.sqla.SQLAlchemyTarget.exists#230",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.SQLAlchemyTarget",
        "signature": "luigi.contrib.sqla.SQLAlchemyTarget.exists(self)",
        "snippet": "    def exists(self):\n        row = None\n        if self.marker_table_bound is None:\n            self.create_marker_table()\n        with self.engine.begin() as conn:\n            table = self.marker_table_bound\n            s = sqlalchemy.select([table]).where(sqlalchemy.and_(table.c.update_id == self.update_id,\n                                                                 table.c.target_table == self.target_table)).limit(1)\n            row = conn.execute(s).fetchone()\n        return row is not None",
        "begin_line": 230,
        "end_line": 239,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00025157232704402514,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.sqla.SQLAlchemyTarget.create_marker_table#241",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.SQLAlchemyTarget",
        "signature": "luigi.contrib.sqla.SQLAlchemyTarget.create_marker_table(self)",
        "snippet": "    def create_marker_table(self):\n        \"\"\"\n        Create marker table if it doesn't exist.\n\n        Using a separate connection since the transaction might have to be reset.\n        \"\"\"\n        if self.marker_table is None:\n            self.marker_table = luigi.configuration.get_config().get('sqlalchemy', 'marker-table', 'table_updates')\n\n        engine = self.engine\n\n        with engine.begin() as con:\n            metadata = sqlalchemy.MetaData()\n            if not con.dialect.has_table(con, self.marker_table):\n                self.marker_table_bound = sqlalchemy.Table(\n                    self.marker_table, metadata,\n                    sqlalchemy.Column(\"update_id\", sqlalchemy.String(128), primary_key=True),\n                    sqlalchemy.Column(\"target_table\", sqlalchemy.String(128)),\n                    sqlalchemy.Column(\"inserted\", sqlalchemy.DateTime, default=datetime.datetime.now()))\n                metadata.create_all(engine)\n            else:\n                metadata.reflect(bind=engine)\n                self.marker_table_bound = metadata.tables[self.marker_table]",
        "begin_line": 241,
        "end_line": 263,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00026673779674579886,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.create_table#308",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.create_table(self, engine)",
        "snippet": "    def create_table(self, engine):\n        \"\"\"\n        Override to provide code for creating the target table.\n\n        By default it will be created using types specified in columns.\n        If the table exists, then it binds to the existing table.\n\n        If overridden, use the provided connection object for setting up the table in order to\n        create the table and insert data using the same transaction.\n        :param engine: The sqlalchemy engine instance\n        :type engine: object\n        \"\"\"\n        def construct_sqla_columns(columns):\n            retval = [sqlalchemy.Column(*c[0], **c[1]) for c in columns]\n            return retval\n\n        needs_setup = (len(self.columns) == 0) or (False in [len(c) == 2 for c in self.columns]) if not self.reflect else False\n        if needs_setup:\n            # only names of columns specified, no types\n            raise NotImplementedError(\"create_table() not implemented for %r and columns types not specified\" % self.table)\n        else:\n            # if columns is specified as (name, type) tuples\n            with engine.begin() as con:\n                metadata = sqlalchemy.MetaData()\n                try:\n                    if not con.dialect.has_table(con, self.table):\n                        sqla_columns = construct_sqla_columns(self.columns)\n                        self.table_bound = sqlalchemy.Table(self.table, metadata, *sqla_columns)\n                        metadata.create_all(engine)\n                    else:\n                        metadata.reflect(bind=engine)\n                        self.table_bound = metadata.tables[self.table]\n                except Exception as e:\n                    self._logger.exception(self.table + str(e))",
        "begin_line": 308,
        "end_line": 341,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.construct_sqla_columns#320",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.construct_sqla_columns(columns)",
        "snippet": "        def construct_sqla_columns(columns):\n            retval = [sqlalchemy.Column(*c[0], **c[1]) for c in columns]\n            return retval",
        "begin_line": 320,
        "end_line": 322,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00026968716289104636,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.update_id#343",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.update_id(self)",
        "snippet": "    def update_id(self):\n        \"\"\"\n        This update id will be a unique identifier for this insert on this table.\n        \"\"\"\n        return self.task_id",
        "begin_line": 343,
        "end_line": 347,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00025157232704402514,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.output#349",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.output(self)",
        "snippet": "    def output(self):\n        return SQLAlchemyTarget(\n            connection_string=self.connection_string,\n            target_table=self.table,\n            update_id=self.update_id(),\n            connect_args=self.connect_args,\n            echo=self.echo)",
        "begin_line": 349,
        "end_line": 355,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00025157232704402514,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.rows#357",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.rows(self)",
        "snippet": "    def rows(self):\n        \"\"\"\n        Return/yield tuples or lists corresponding to each row to be inserted.\n\n        This method can be overridden for custom file types or formats.\n        \"\"\"\n        with self.input().open('r') as fobj:\n            for line in fobj:\n                yield line.strip(\"\\n\").split(self.column_separator)",
        "begin_line": 357,
        "end_line": 365,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002842524161455372,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.run#367",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.run(self)",
        "snippet": "    def run(self):\n        self._logger.info(\"Running task copy to table for update id %s for table %s\" % (self.update_id(), self.table))\n        output = self.output()\n        engine = output.engine\n        self.create_table(engine)\n        with engine.begin() as conn:\n            rows = iter(self.rows())\n            ins_rows = [dict(zip((\"_\" + c.key for c in self.table_bound.c), row))\n                        for row in itertools.islice(rows, self.chunk_size)]\n            while ins_rows:\n                self.copy(conn, ins_rows, self.table_bound)\n                ins_rows = [dict(zip((\"_\" + c.key for c in self.table_bound.c), row))\n                            for row in itertools.islice(rows, self.chunk_size)]\n                self._logger.info(\"Finished inserting %d rows into SQLAlchemy target\" % len(ins_rows))\n        output.touch()\n        self._logger.info(\"Finished inserting rows into SQLAlchemy target\")",
        "begin_line": 367,
        "end_line": 382,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002772387025228722,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.copy#384",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.copy(self, conn, ins_rows, table_bound)",
        "snippet": "    def copy(self, conn, ins_rows, table_bound):\n        \"\"\"\n        This method does the actual insertion of the rows of data given by ins_rows into the\n        database. A task that needs row updates instead of insertions should overload this method.\n        :param conn: The sqlalchemy connection object\n        :param ins_rows: The dictionary of rows with the keys in the format _<column_name>. For example\n        if you have a table with a column name \"property\", then the key in the dictionary\n        would be \"_property\". This format is consistent with the bindparam usage in sqlalchemy.\n        :param table_bound: The object referring to the table\n        :return:\n        \"\"\"\n        bound_cols = dict((c, sqlalchemy.bindparam(\"_\" + c.key)) for c in table_bound.columns)\n        ins = table_bound.insert().values(bound_cols)\n        conn.execute(ins, ins_rows)",
        "begin_line": 384,
        "end_line": 397,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002772387025228722,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.target.CascadingClient.__init__#45",
        "src_path": "luigi/contrib/target.py",
        "class_name": "luigi.contrib.target.CascadingClient",
        "signature": "luigi.contrib.target.CascadingClient.__init__(self, clients, method_names=None)",
        "snippet": "    def __init__(self, clients, method_names=None):\n        self.clients = clients\n        if method_names is None:\n            method_names = self.ALL_METHOD_NAMES\n\n        for method_name in method_names:\n            new_method = self._make_method(method_name)\n            real_method = six.create_bound_method(new_method, self)\n            setattr(self, method_name, real_method)",
        "begin_line": 45,
        "end_line": 53,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00032754667540124465,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.target.CascadingClient.new_method#57",
        "src_path": "luigi/contrib/target.py",
        "class_name": "luigi.contrib.target.CascadingClient",
        "signature": "luigi.contrib.target.CascadingClient.new_method(self, *args, **kwargs)",
        "snippet": "        def new_method(self, *args, **kwargs):\n            return self._chained_call(method_name, *args, **kwargs)",
        "begin_line": 57,
        "end_line": 58,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00032754667540124465,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.target.CascadingClient._make_method#56",
        "src_path": "luigi/contrib/target.py",
        "class_name": "luigi.contrib.target.CascadingClient",
        "signature": "luigi.contrib.target.CascadingClient._make_method(cls, method_name)",
        "snippet": "    def _make_method(cls, method_name):\n        def new_method(self, *args, **kwargs):\n            return self._chained_call(method_name, *args, **kwargs)\n        return new_method",
        "begin_line": 56,
        "end_line": 59,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00032754667540124465,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.target.CascadingClient._chained_call#61",
        "src_path": "luigi/contrib/target.py",
        "class_name": "luigi.contrib.target.CascadingClient",
        "signature": "luigi.contrib.target.CascadingClient._chained_call(self, method_name, *args, **kwargs)",
        "snippet": "    def _chained_call(self, method_name, *args, **kwargs):\n        for i in range(len(self.clients)):\n            client = self.clients[i]\n            try:\n                result = getattr(client, method_name)(*args, **kwargs)\n                return result\n            except luigi.target.FileSystemException:\n                # For exceptions that are semantical, we must throw along\n                raise\n            except BaseException:\n                is_last_iteration = (i + 1) >= len(self.clients)\n                if is_last_iteration:\n                    raise\n                else:\n                    logger.warning('The %s failed to %s, using fallback class %s',\n                                   client.__class__.__name__, method_name, self.clients[i + 1].__class__.__name__)",
        "begin_line": 61,
        "end_line": 76,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.Failures.__init__#116",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Failures",
        "signature": "luigi.scheduler.Failures.__init__(self, window)",
        "snippet": "    def __init__(self, window):\n        \"\"\"\n        Initialize with the given window.\n\n        :param window: how long to track failures for, as a float (number of seconds).\n        \"\"\"\n        self.window = window\n        self.failures = collections.deque()\n        self.first_failure_time = None",
        "begin_line": 116,
        "end_line": 124,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002036659877800407,
            "pseudo_dstar_susp": 0.005813953488372093,
            "pseudo_tarantula_susp": 0.0013175230566534915,
            "pseudo_op2_susp": 0.005813953488372093,
            "pseudo_barinel_susp": 0.0013175230566534915
        }
    },
    {
        "name": "luigi.scheduler.Failures.add_failure#126",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Failures",
        "signature": "luigi.scheduler.Failures.add_failure(self)",
        "snippet": "    def add_failure(self):\n        \"\"\"\n        Add a failure event with the current timestamp.\n        \"\"\"\n        failure_time = time.time()\n\n        if not self.first_failure_time:\n            self.first_failure_time = failure_time\n\n        self.failures.append(failure_time)",
        "begin_line": 126,
        "end_line": 135,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000236630383341221,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.Failures.num_failures#137",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Failures",
        "signature": "luigi.scheduler.Failures.num_failures(self)",
        "snippet": "    def num_failures(self):\n        \"\"\"\n        Return the number of failures in the window.\n        \"\"\"\n        min_time = time.time() - self.window\n\n        while self.failures and self.failures[0] < min_time:\n            self.failures.popleft()\n\n        return len(self.failures)",
        "begin_line": 137,
        "end_line": 146,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00023719165085388995,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.Failures.clear#148",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Failures",
        "signature": "luigi.scheduler.Failures.clear(self)",
        "snippet": "    def clear(self):\n        \"\"\"\n        Clear the failure queue.\n        \"\"\"\n        self.failures.clear()",
        "begin_line": 148,
        "end_line": 152,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002772387025228722,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler._get_default#155",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler",
        "signature": "luigi.scheduler._get_default(x, default)",
        "snippet": "def _get_default(x, default):\n    if x is not None:\n        return x\n    else:\n        return default",
        "begin_line": 155,
        "end_line": 159,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002036659877800407,
            "pseudo_dstar_susp": 0.005813953488372093,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.005813953488372093,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "luigi.scheduler.Task.__init__#164",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Task",
        "signature": "luigi.scheduler.Task.__init__(self, task_id, status, deps, resources=None, priority=0, family='', module=None, params=None, disable_failures=None, disable_window=None, disable_hard_timeout=None, tracking_url=None)",
        "snippet": "    def __init__(self, task_id, status, deps, resources=None, priority=0, family='', module=None,\n                 params=None, disable_failures=None, disable_window=None, disable_hard_timeout=None,\n                 tracking_url=None):\n        self.id = task_id\n        self.stakeholders = set()  # workers ids that are somehow related to this task (i.e. don't prune while any of these workers are still active)\n        self.workers = set()  # workers ids that can perform task - task is 'BROKEN' if none of these workers are active\n        if deps is None:\n            self.deps = set()\n        else:\n            self.deps = set(deps)\n        self.status = status  # PENDING, RUNNING, FAILED or DONE\n        self.time = time.time()  # Timestamp when task was first added\n        self.updated = self.time\n        self.retry = None\n        self.remove = None\n        self.worker_running = None  # the worker id that is currently running the task or None\n        self.time_running = None  # Timestamp when picked up by worker\n        self.expl = None\n        self.priority = priority\n        self.resources = _get_default(resources, {})\n        self.family = family\n        self.module = module\n        self.params = _get_default(params, {})\n        self.disable_failures = disable_failures\n        self.disable_hard_timeout = disable_hard_timeout\n        self.failures = Failures(disable_window)\n        self.tracking_url = tracking_url\n        self.scheduler_disable_time = None\n        self.runnable = False",
        "begin_line": 164,
        "end_line": 192,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002036659877800407,
            "pseudo_dstar_susp": 0.005813953488372093,
            "pseudo_tarantula_susp": 0.0013175230566534915,
            "pseudo_op2_susp": 0.005813953488372093,
            "pseudo_barinel_susp": 0.0013175230566534915
        }
    },
    {
        "name": "luigi.scheduler.Task.add_failure#197",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Task",
        "signature": "luigi.scheduler.Task.add_failure(self)",
        "snippet": "    def add_failure(self):\n        self.failures.add_failure()",
        "begin_line": 197,
        "end_line": 198,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000236630383341221,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.Task.has_excessive_failures#200",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Task",
        "signature": "luigi.scheduler.Task.has_excessive_failures(self)",
        "snippet": "    def has_excessive_failures(self):\n        if (self.failures.first_failure_time is not None and\n                self.disable_hard_timeout):\n            if (time.time() >= self.failures.first_failure_time +\n                    self.disable_hard_timeout):\n                return True\n\n        if self.failures.num_failures() >= self.disable_failures:\n            return True\n\n        return False",
        "begin_line": 200,
        "end_line": 210,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.Task.can_disable#212",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Task",
        "signature": "luigi.scheduler.Task.can_disable(self)",
        "snippet": "    def can_disable(self):\n        return (self.disable_failures is not None or\n                self.disable_hard_timeout is not None)",
        "begin_line": 212,
        "end_line": 214,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0035587188612099642,
            "pseudo_dstar_susp": 0.0023094688221709007,
            "pseudo_tarantula_susp": 0.004739336492890996,
            "pseudo_op2_susp": 0.0023094688221709007,
            "pseudo_barinel_susp": 0.004739336492890996
        }
    },
    {
        "name": "luigi.scheduler.Task.pretty_id#217",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Task",
        "signature": "luigi.scheduler.Task.pretty_id(self)",
        "snippet": "    def pretty_id(self):\n        param_str = ', '.join('{}={}'.format(key, value) for key, value in self.params.items())\n        return '{}({})'.format(self.family, param_str)",
        "begin_line": 217,
        "end_line": 219,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016025641025641025,
            "pseudo_dstar_susp": 0.002932551319648094,
            "pseudo_tarantula_susp": 0.0015748031496062992,
            "pseudo_op2_susp": 0.002932551319648094,
            "pseudo_barinel_susp": 0.0015748031496062992
        }
    },
    {
        "name": "luigi.scheduler.Worker.__init__#227",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.__init__(self, worker_id, last_active=None)",
        "snippet": "    def __init__(self, worker_id, last_active=None):\n        self.id = worker_id\n        self.reference = None  # reference to the worker in the real world. (Currently a dict containing just the host)\n        self.last_active = last_active or time.time()  # seconds since epoch\n        self.last_get_work = None\n        self.started = time.time()  # seconds since epoch\n        self.tasks = set()  # task objects\n        self.info = {}\n        self.disabled = False",
        "begin_line": 227,
        "end_line": 235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015082956259426848,
            "pseudo_dstar_susp": 0.003472222222222222,
            "pseudo_tarantula_susp": 0.0010384215991692627,
            "pseudo_op2_susp": 0.003472222222222222,
            "pseudo_barinel_susp": 0.0010384215991692627
        }
    },
    {
        "name": "luigi.scheduler.Worker.add_info#237",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.add_info(self, info)",
        "snippet": "    def add_info(self, info):\n        self.info.update(info)",
        "begin_line": 237,
        "end_line": 238,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002369668246445498,
            "pseudo_dstar_susp": 0.004201680672268907,
            "pseudo_tarantula_susp": 0.002105263157894737,
            "pseudo_op2_susp": 0.004201680672268907,
            "pseudo_barinel_susp": 0.002105263157894737
        }
    },
    {
        "name": "luigi.scheduler.Worker.update#240",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.update(self, worker_reference, get_work=False)",
        "snippet": "    def update(self, worker_reference, get_work=False):\n        if worker_reference:\n            self.reference = worker_reference\n        self.last_active = time.time()\n        if get_work:\n            self.last_get_work = time.time()",
        "begin_line": 240,
        "end_line": 245,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017513134851138354,
            "pseudo_dstar_susp": 0.00390625,
            "pseudo_tarantula_susp": 0.0012391573729863693,
            "pseudo_op2_susp": 0.00390625,
            "pseudo_barinel_susp": 0.0012391573729863693
        }
    },
    {
        "name": "luigi.scheduler.Worker.prune#247",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.prune(self, config)",
        "snippet": "    def prune(self, config):\n        # Delete workers that haven't said anything for a while (probably killed)\n        if self.last_active + config.worker_disconnect_delay < time.time():\n            return True",
        "begin_line": 247,
        "end_line": 250,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024154589371980675,
            "pseudo_dstar_susp": 0.0013774104683195593,
            "pseudo_tarantula_susp": 0.004545454545454545,
            "pseudo_op2_susp": 0.0013774104683195593,
            "pseudo_barinel_susp": 0.004545454545454545
        }
    },
    {
        "name": "luigi.scheduler.Worker.get_pending_tasks#252",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.get_pending_tasks(self, state)",
        "snippet": "    def get_pending_tasks(self, state):\n        \"\"\"\n        Get PENDING (and RUNNING) tasks for this worker.\n\n        You have to pass in the state for optimization reasons.\n        \"\"\"\n        if len(self.tasks) < state.num_pending_tasks():\n            return six.moves.filter(lambda task: task.status in [PENDING, RUNNING],\n                                    self.tasks)\n        else:\n            return state.get_pending_tasks()",
        "begin_line": 252,
        "end_line": 262,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009699321047526673,
            "pseudo_dstar_susp": 0.0012953367875647669,
            "pseudo_tarantula_susp": 0.0009174311926605505,
            "pseudo_op2_susp": 0.0012953367875647669,
            "pseudo_barinel_susp": 0.0009174311926605505
        }
    },
    {
        "name": "luigi.scheduler.Worker.is_trivial_worker#264",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.is_trivial_worker(self, state)",
        "snippet": "    def is_trivial_worker(self, state):\n        \"\"\"\n        If it's not an assistant having only tasks that are without\n        requirements.\n\n        We have to pass the state parameter for optimization reasons.\n        \"\"\"\n        if self.assistant:\n            return False\n        return all(not task.resources for task in self.get_pending_tasks(state))",
        "begin_line": 264,
        "end_line": 273,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0031746031746031746,
            "pseudo_dstar_susp": 0.004651162790697674,
            "pseudo_tarantula_susp": 0.005050505050505051,
            "pseudo_op2_susp": 0.004651162790697674,
            "pseudo_barinel_susp": 0.005050505050505051
        }
    },
    {
        "name": "luigi.scheduler.Worker.assistant#276",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.assistant(self)",
        "snippet": "    def assistant(self):\n        return self.info.get('assistant', False)",
        "begin_line": 276,
        "end_line": 277,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015600624024961,
            "pseudo_dstar_susp": 0.003703703703703704,
            "pseudo_tarantula_susp": 0.0011061946902654867,
            "pseudo_op2_susp": 0.003703703703703704,
            "pseudo_barinel_susp": 0.0011061946902654867
        }
    },
    {
        "name": "luigi.scheduler.Worker.__str__#279",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.__str__(self)",
        "snippet": "    def __str__(self):\n        return self.id",
        "begin_line": 279,
        "end_line": 280,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001388888888888889,
            "pseudo_dstar_susp": 0.00102880658436214,
            "pseudo_tarantula_susp": 0.0021645021645021645,
            "pseudo_op2_susp": 0.00102880658436214,
            "pseudo_barinel_susp": 0.0021645021645021645
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.__init__#292",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.__init__(self, state_path)",
        "snippet": "    def __init__(self, state_path):\n        self._state_path = state_path\n        self._tasks = {}  # map from id to a Task object\n        self._status_tasks = collections.defaultdict(dict)\n        self._active_workers = {}  # map from id to a Worker object",
        "begin_line": 292,
        "end_line": 296,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001893939393939394,
            "pseudo_dstar_susp": 0.004830917874396135,
            "pseudo_tarantula_susp": 0.0011111111111111111,
            "pseudo_op2_susp": 0.004830917874396135,
            "pseudo_barinel_susp": 0.0011111111111111111
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_state#298",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_state(self)",
        "snippet": "    def get_state(self):\n        return self._tasks, self._active_workers",
        "begin_line": 298,
        "end_line": 299,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.set_state#301",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.set_state(self, state)",
        "snippet": "    def set_state(self, state):\n        self._tasks, self._active_workers = state",
        "begin_line": 301,
        "end_line": 302,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.dump#304",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.dump(self)",
        "snippet": "    def dump(self):\n        try:\n            with open(self._state_path, 'wb') as fobj:\n                pickle.dump(self.get_state(), fobj)\n        except IOError:\n            logger.warning(\"Failed saving scheduler state\", exc_info=1)\n        else:\n            logger.info(\"Saved state in %s\", self._state_path)",
        "begin_line": 304,
        "end_line": 311,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.load#314",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.load(self)",
        "snippet": "    def load(self):\n        if os.path.exists(self._state_path):\n            logger.info(\"Attempting to load state from %s\", self._state_path)\n            try:\n                with open(self._state_path, 'rb') as fobj:\n                    state = pickle.load(fobj)\n            except BaseException:\n                logger.exception(\"Error when loading state. Starting from clean slate.\")\n                return\n\n            self.set_state(state)\n            self._status_tasks = collections.defaultdict(dict)\n            for task in six.itervalues(self._tasks):\n                self._status_tasks[task.status][task.id] = task\n        else:\n            logger.info(\"No prior state file exists at %s. Starting with clean slate\", self._state_path)",
        "begin_line": 314,
        "end_line": 329,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_active_tasks#331",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_active_tasks(self, status=None)",
        "snippet": "    def get_active_tasks(self, status=None):\n        if status:\n            for task in six.itervalues(self._status_tasks[status]):\n                yield task\n        else:\n            for task in six.itervalues(self._tasks):\n                yield task",
        "begin_line": 331,
        "end_line": 337,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011135857461024498,
            "pseudo_dstar_susp": 0.001422475106685633,
            "pseudo_tarantula_susp": 0.0019801980198019802,
            "pseudo_op2_susp": 0.001422475106685633,
            "pseudo_barinel_susp": 0.0019801980198019802
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_running_tasks#339",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_running_tasks(self)",
        "snippet": "    def get_running_tasks(self):\n        return six.itervalues(self._status_tasks[RUNNING])",
        "begin_line": 339,
        "end_line": 340,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013812154696132596,
            "pseudo_dstar_susp": 0.0017241379310344827,
            "pseudo_tarantula_susp": 0.00141643059490085,
            "pseudo_op2_susp": 0.0017241379310344827,
            "pseudo_barinel_susp": 0.00141643059490085
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_pending_tasks#342",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_pending_tasks(self)",
        "snippet": "    def get_pending_tasks(self):\n        return itertools.chain.from_iterable(six.itervalues(self._status_tasks[status])\n                                             for status in [PENDING, RUNNING])",
        "begin_line": 342,
        "end_line": 344,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003134796238244514,
            "pseudo_dstar_susp": 0.00847457627118644,
            "pseudo_tarantula_susp": 0.0012755102040816326,
            "pseudo_op2_susp": 0.00847457627118644,
            "pseudo_barinel_susp": 0.0012755102040816326
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.num_pending_tasks#346",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.num_pending_tasks(self)",
        "snippet": "    def num_pending_tasks(self):\n        \"\"\"\n        Return how many tasks are PENDING + RUNNING. O(1).\n        \"\"\"\n        return len(self._status_tasks[PENDING]) + len(self._status_tasks[RUNNING])",
        "begin_line": 346,
        "end_line": 350,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009407337723424271,
            "pseudo_dstar_susp": 0.0012453300124533001,
            "pseudo_tarantula_susp": 0.0008718395815170009,
            "pseudo_op2_susp": 0.0012453300124533001,
            "pseudo_barinel_susp": 0.0008718395815170009
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_task#352",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_task(self, task_id, default=None, setdefault=None)",
        "snippet": "    def get_task(self, task_id, default=None, setdefault=None):\n        if setdefault:\n            task = self._tasks.setdefault(task_id, setdefault)\n            self._status_tasks[task.status][task.id] = task\n            return task\n        else:\n            return self._tasks.get(task_id, default)",
        "begin_line": 352,
        "end_line": 358,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001160092807424594,
            "pseudo_dstar_susp": 0.00267379679144385,
            "pseudo_tarantula_susp": 0.0009569377990430622,
            "pseudo_op2_susp": 0.00267379679144385,
            "pseudo_barinel_susp": 0.0009569377990430622
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.has_task#360",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.has_task(self, task_id)",
        "snippet": "    def has_task(self, task_id):\n        return task_id in self._tasks",
        "begin_line": 360,
        "end_line": 361,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009532888465204957,
            "pseudo_dstar_susp": 0.0012674271229404308,
            "pseudo_tarantula_susp": 0.0008833922261484099,
            "pseudo_op2_susp": 0.0012674271229404308,
            "pseudo_barinel_susp": 0.0008833922261484099
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.re_enable#363",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.re_enable(self, task, config=None)",
        "snippet": "    def re_enable(self, task, config=None):\n        task.scheduler_disable_time = None\n        task.failures.clear()\n        if config:\n            self.set_status(task, FAILED, config)\n            task.failures.clear()",
        "begin_line": 363,
        "end_line": 368,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002937720329024677,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.set_status#370",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.set_status(self, task, new_status, config=None)",
        "snippet": "    def set_status(self, task, new_status, config=None):\n        if new_status == FAILED:\n            assert config is not None\n\n        if new_status == DISABLED and task.status == RUNNING:\n            return\n\n        if task.status == DISABLED:\n            if new_status == DONE:\n                self.re_enable(task)\n\n            # don't allow workers to override a scheduler disable\n            elif task.scheduler_disable_time is not None and new_status != DISABLED:\n                return\n\n        if new_status == FAILED and task.can_disable() and task.status != DISABLED:\n            task.add_failure()\n            if task.has_excessive_failures():\n                task.scheduler_disable_time = time.time()\n                new_status = DISABLED\n                notifications.send_error_email(\n                    'Luigi Scheduler: DISABLED {task} due to excessive failures'.format(task=task.id),\n                    '{task} failed {failures} times in the last {window} seconds, so it is being '\n                    'disabled for {persist} seconds'.format(\n                        failures=config.disable_failures,\n                        task=task.id,\n                        window=config.disable_window,\n                        persist=config.disable_persist,\n                    ))\n        elif new_status == DISABLED:\n            task.scheduler_disable_time = None\n\n        if new_status != task.status:\n            self._status_tasks[task.status].pop(task.id)\n            self._status_tasks[new_status][task.id] = task\n            task.status = new_status\n            task.updated = time.time()",
        "begin_line": 370,
        "end_line": 406,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0056179775280898875,
            "pseudo_dstar_susp": 0.0028653295128939827,
            "pseudo_tarantula_susp": 0.006289308176100629,
            "pseudo_op2_susp": 0.0028653295128939827,
            "pseudo_barinel_susp": 0.006289308176100629
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.fail_dead_worker_task#408",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.fail_dead_worker_task(self, task, config, assistants)",
        "snippet": "    def fail_dead_worker_task(self, task, config, assistants):\n        # If a running worker disconnects, tag all its jobs as FAILED and subject it to the same retry logic\n        if task.status == RUNNING and task.worker_running and task.worker_running not in task.stakeholders | assistants:\n            logger.info(\"Task %r is marked as running by disconnected worker %r -> marking as \"\n                        \"FAILED with retry delay of %rs\", task.id, task.worker_running,\n                        config.retry_delay)\n            task.worker_running = None\n            self.set_status(task, FAILED, config)\n            task.retry = time.time() + config.retry_delay",
        "begin_line": 408,
        "end_line": 416,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011061946902654867,
            "pseudo_dstar_susp": 0.0014388489208633094,
            "pseudo_tarantula_susp": 0.0010976948408342481,
            "pseudo_op2_susp": 0.0014388489208633094,
            "pseudo_barinel_susp": 0.0010976948408342481
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.update_status#418",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.update_status(self, task, config)",
        "snippet": "    def update_status(self, task, config):\n        # Mark tasks with no remaining active stakeholders for deletion\n        if not task.stakeholders:\n            if task.remove is None:\n                logger.info(\"Task %r has stakeholders %r but none remain connected -> might remove \"\n                            \"task in %s seconds\", task.id, task.stakeholders, config.remove_delay)\n                task.remove = time.time() + config.remove_delay\n\n        # Re-enable task after the disable time expires\n        if task.status == DISABLED and task.scheduler_disable_time is not None:\n            if time.time() - task.scheduler_disable_time > config.disable_persist:\n                self.re_enable(task, config)\n\n        # Reset FAILED tasks to PENDING if max timeout is reached, and retry delay is >= 0\n        if task.status == FAILED and config.retry_delay >= 0 and task.retry < time.time():\n            self.set_status(task, PENDING, config)",
        "begin_line": 418,
        "end_line": 433,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002631578947368421,
            "pseudo_dstar_susp": 0.0014388489208633094,
            "pseudo_tarantula_susp": 0.004830917874396135,
            "pseudo_op2_susp": 0.0014388489208633094,
            "pseudo_barinel_susp": 0.004830917874396135
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.may_prune#435",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.may_prune(self, task)",
        "snippet": "    def may_prune(self, task):\n        return task.remove and time.time() > task.remove",
        "begin_line": 435,
        "end_line": 436,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011061946902654867,
            "pseudo_dstar_susp": 0.0014388489208633094,
            "pseudo_tarantula_susp": 0.0010976948408342481,
            "pseudo_op2_susp": 0.0014388489208633094,
            "pseudo_barinel_susp": 0.0010976948408342481
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.inactivate_tasks#438",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.inactivate_tasks(self, delete_tasks)",
        "snippet": "    def inactivate_tasks(self, delete_tasks):\n        # The terminology is a bit confusing: we used to \"delete\" tasks when they became inactive,\n        # but with a pluggable state storage, you might very well want to keep some history of\n        # older tasks as well. That's why we call it \"inactivate\" (as in the verb)\n        for task in delete_tasks:\n            task_obj = self._tasks.pop(task)\n            self._status_tasks[task_obj.status].pop(task)",
        "begin_line": 438,
        "end_line": 444,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005847953216374269,
            "pseudo_dstar_susp": 0.0013986013986013986,
            "pseudo_tarantula_susp": 0.00641025641025641,
            "pseudo_op2_susp": 0.0013986013986013986,
            "pseudo_barinel_susp": 0.00641025641025641
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_active_workers#446",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_active_workers(self, last_active_lt=None, last_get_work_gt=None)",
        "snippet": "    def get_active_workers(self, last_active_lt=None, last_get_work_gt=None):\n        for worker in six.itervalues(self._active_workers):\n            if last_active_lt is not None and worker.last_active >= last_active_lt:\n                continue\n            last_get_work = getattr(worker, 'last_get_work', None)\n            if last_get_work_gt is not None and (\n                    last_get_work is None or last_get_work <= last_get_work_gt):\n                continue\n            yield worker",
        "begin_line": 446,
        "end_line": 454,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014749262536873156,
            "pseudo_dstar_susp": 0.0013245033112582781,
            "pseudo_tarantula_susp": 0.00234192037470726,
            "pseudo_op2_susp": 0.0013245033112582781,
            "pseudo_barinel_susp": 0.00234192037470726
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_assistants#456",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_assistants(self, last_active_lt=None)",
        "snippet": "    def get_assistants(self, last_active_lt=None):\n        return filter(lambda w: w.assistant, self.get_active_workers(last_active_lt))",
        "begin_line": 456,
        "end_line": 457,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001838235294117647,
            "pseudo_dstar_susp": 0.004761904761904762,
            "pseudo_tarantula_susp": 0.0010869565217391304,
            "pseudo_op2_susp": 0.004761904761904762,
            "pseudo_barinel_susp": 0.0010869565217391304
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_worker_ids#459",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_worker_ids(self)",
        "snippet": "    def get_worker_ids(self):\n        return self._active_workers.keys()  # only used for unit tests",
        "begin_line": 459,
        "end_line": 460,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_worker#462",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_worker(self, worker_id)",
        "snippet": "    def get_worker(self, worker_id):\n        return self._active_workers.setdefault(worker_id, Worker(worker_id))",
        "begin_line": 462,
        "end_line": 463,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015220700152207,
            "pseudo_dstar_susp": 0.0035460992907801418,
            "pseudo_tarantula_susp": 0.0010449320794148381,
            "pseudo_op2_susp": 0.0035460992907801418,
            "pseudo_barinel_susp": 0.0010449320794148381
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.inactivate_workers#465",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.inactivate_workers(self, delete_workers)",
        "snippet": "    def inactivate_workers(self, delete_workers):\n        # Mark workers as inactive\n        for worker in delete_workers:\n            self._active_workers.pop(worker)\n        self._remove_workers_from_tasks(delete_workers)",
        "begin_line": 465,
        "end_line": 469,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024154589371980675,
            "pseudo_dstar_susp": 0.0013986013986013986,
            "pseudo_tarantula_susp": 0.004545454545454545,
            "pseudo_op2_susp": 0.0013986013986013986,
            "pseudo_barinel_susp": 0.004545454545454545
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState._remove_workers_from_tasks#471",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState._remove_workers_from_tasks(self, workers, remove_stakeholders=True)",
        "snippet": "    def _remove_workers_from_tasks(self, workers, remove_stakeholders=True):\n        for task in self.get_active_tasks():\n            if remove_stakeholders:\n                task.stakeholders.difference_update(workers)\n            task.workers.difference_update(workers)",
        "begin_line": 471,
        "end_line": 475,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011061946902654867,
            "pseudo_dstar_susp": 0.0014388489208633094,
            "pseudo_tarantula_susp": 0.0010976948408342481,
            "pseudo_op2_susp": 0.0014388489208633094,
            "pseudo_barinel_susp": 0.0010976948408342481
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.disable_workers#477",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.disable_workers(self, workers)",
        "snippet": "    def disable_workers(self, workers):\n        self._remove_workers_from_tasks(workers, remove_stakeholders=False)\n        for worker in workers:\n            self.get_worker(worker).disabled = True",
        "begin_line": 477,
        "end_line": 480,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00026441036488630354,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_necessary_tasks#482",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_necessary_tasks(self)",
        "snippet": "    def get_necessary_tasks(self):\n        necessary_tasks = set()\n        for task in self.get_active_tasks():\n            if task.status not in (DONE, DISABLED) or \\\n                    getattr(task, 'scheduler_disable_time', None) is not None:\n                necessary_tasks.update(task.deps)\n                necessary_tasks.add(task.id)\n        return necessary_tasks",
        "begin_line": 482,
        "end_line": 489,
        "comment": "",
        "is_bug": true,
        "susp": {
            "pseudo_ochiai_susp": 0.005847953216374269,
            "pseudo_dstar_susp": 0.0011135857461024498,
            "pseudo_tarantula_susp": 0.00641025641025641,
            "pseudo_op2_susp": 0.0011135857461024498,
            "pseudo_barinel_susp": 0.00641025641025641
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.__init__#499",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.__init__(self, config=None, resources=None, task_history_impl=None, **kwargs)",
        "snippet": "    def __init__(self, config=None, resources=None, task_history_impl=None, **kwargs):\n        \"\"\"\n        Keyword Arguments:\n        :param config: an object of class \"scheduler\" or None (in which the global instance will be used)\n        :param resources: a dict of str->int constraints\n        :param task_history_override: ignore config and use this object as the task history\n        \"\"\"\n        self._config = config or scheduler(**kwargs)\n        self._state = SimpleTaskState(self._config.state_path)\n\n        if task_history_impl:\n            self._task_history = task_history_impl\n        elif self._config.record_task_history:\n            from luigi import db_task_history  # Needs sqlalchemy, thus imported here\n            self._task_history = db_task_history.DbTaskHistory()\n        else:\n            self._task_history = history.NopHistory()\n        self._resources = resources or configuration.get_config().getintdict('resources')  # TODO: Can we make this a Parameter?\n        self._make_task = functools.partial(\n            Task, disable_failures=self._config.disable_failures,\n            disable_hard_timeout=self._config.disable_hard_timeout,\n            disable_window=self._config.disable_window)\n        self._worker_requests = {}",
        "begin_line": 499,
        "end_line": 521,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00196078431372549,
            "pseudo_dstar_susp": 0.005291005291005291,
            "pseudo_tarantula_susp": 0.001142857142857143,
            "pseudo_op2_susp": 0.005291005291005291,
            "pseudo_barinel_susp": 0.001142857142857143
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.load#523",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.load(self)",
        "snippet": "    def load(self):\n        self._state.load()",
        "begin_line": 523,
        "end_line": 524,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.dump#526",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.dump(self)",
        "snippet": "    def dump(self):\n        self._state.dump()",
        "begin_line": 526,
        "end_line": 527,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.prune#529",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.prune(self)",
        "snippet": "    def prune(self):\n        logger.info(\"Starting pruning of task graph\")\n        self._prune_workers()\n        self._prune_tasks()\n        logger.info(\"Done pruning task graph\")",
        "begin_line": 529,
        "end_line": 533,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001081081081081081,
            "pseudo_dstar_susp": 0.0013986013986013986,
            "pseudo_tarantula_susp": 0.0010695187165775401,
            "pseudo_op2_susp": 0.0013986013986013986,
            "pseudo_barinel_susp": 0.0010695187165775401
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._prune_workers#535",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._prune_workers(self)",
        "snippet": "    def _prune_workers(self):\n        remove_workers = []\n        for worker in self._state.get_active_workers():\n            if worker.prune(self._config):\n                logger.info(\"Worker %s timed out (no contact for >=%ss)\", worker, self._config.worker_disconnect_delay)\n                remove_workers.append(worker.id)\n\n        self._state.inactivate_workers(remove_workers)",
        "begin_line": 535,
        "end_line": 542,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024154589371980675,
            "pseudo_dstar_susp": 0.0013986013986013986,
            "pseudo_tarantula_susp": 0.004545454545454545,
            "pseudo_op2_susp": 0.0013986013986013986,
            "pseudo_barinel_susp": 0.004545454545454545
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._prune_tasks#544",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._prune_tasks(self)",
        "snippet": "    def _prune_tasks(self):\n        assistant_ids = set(w.id for w in self._state.get_assistants())\n        remove_tasks = []\n\n        if assistant_ids:\n            necessary_tasks = self._state.get_necessary_tasks()\n        else:\n            necessary_tasks = ()\n\n        for task in self._state.get_active_tasks():\n            self._state.fail_dead_worker_task(task, self._config, assistant_ids)\n            self._state.update_status(task, self._config)\n            if self._state.may_prune(task) and task.id not in necessary_tasks:\n                logger.info(\"Removing task %r\", task.id)\n                remove_tasks.append(task.id)\n\n        self._state.inactivate_tasks(remove_tasks)",
        "begin_line": 544,
        "end_line": 560,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005847953216374269,
            "pseudo_dstar_susp": 0.004739336492890996,
            "pseudo_tarantula_susp": 0.00641025641025641,
            "pseudo_op2_susp": 0.004739336492890996,
            "pseudo_barinel_susp": 0.00641025641025641
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.update#562",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.update(self, worker_id, worker_reference=None, get_work=False)",
        "snippet": "    def update(self, worker_id, worker_reference=None, get_work=False):\n        \"\"\"\n        Keep track of whenever the worker was last active.\n        \"\"\"\n        worker = self._state.get_worker(worker_id)\n        worker.update(worker_reference, get_work=get_work)\n        return not getattr(worker, 'disabled', False)",
        "begin_line": 562,
        "end_line": 568,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015360983102918587,
            "pseudo_dstar_susp": 0.0036101083032490976,
            "pseudo_tarantula_susp": 0.0010526315789473684,
            "pseudo_op2_susp": 0.0036101083032490976,
            "pseudo_barinel_susp": 0.0010526315789473684
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._update_priority#570",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._update_priority(self, task, prio, worker)",
        "snippet": "    def _update_priority(self, task, prio, worker):\n        \"\"\"\n        Update priority of the given task.\n\n        Priority can only be increased.\n        If the task doesn't exist, a placeholder task is created to preserve priority when the task is later scheduled.\n        \"\"\"\n        task.priority = prio = max(prio, task.priority)\n        for dep in task.deps or []:\n            t = self._state.get_task(dep)\n            if t is not None and prio > t.priority:\n                self._update_priority(t, prio, worker)",
        "begin_line": 570,
        "end_line": 581,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001160092807424594,
            "pseudo_dstar_susp": 0.00267379679144385,
            "pseudo_tarantula_susp": 0.0009569377990430622,
            "pseudo_op2_susp": 0.00267379679144385,
            "pseudo_barinel_susp": 0.0009569377990430622
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.add_task#583",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.add_task(self, task_id=None, status=PENDING, runnable=True, deps=None, new_deps=None, expl=None, resources=None, priority=0, family='', module=None, params=None, assistant=False, tracking_url=None, **kwargs)",
        "snippet": "    def add_task(self, task_id=None, status=PENDING, runnable=True,\n                 deps=None, new_deps=None, expl=None, resources=None,\n                 priority=0, family='', module=None, params=None,\n                 assistant=False, tracking_url=None, **kwargs):\n        \"\"\"\n        * add task identified by task_id if it doesn't exist\n        * if deps is not None, update dependency list\n        * update status of task\n        * add additional workers/stakeholders\n        * update priority when needed\n        \"\"\"\n        worker_id = kwargs['worker']\n        worker_enabled = self.update(worker_id)\n\n        if worker_enabled:\n            _default_task = self._make_task(\n                task_id=task_id, status=PENDING, deps=deps, resources=resources,\n                priority=priority, family=family, module=module, params=params,\n            )\n        else:\n            _default_task = None\n\n        task = self._state.get_task(task_id, setdefault=_default_task)\n\n        if task is None or (task.status != RUNNING and not worker_enabled):\n            return\n\n        # for setting priority, we'll sometimes create tasks with unset family and params\n        if not task.family:\n            task.family = family\n        if not getattr(task, 'module', None):\n            task.module = module\n        if not task.params:\n            task.params = _get_default(params, {})\n\n        if tracking_url is not None or task.status != RUNNING:\n            task.tracking_url = tracking_url\n\n        if task.remove is not None:\n            task.remove = None  # unmark task for removal so it isn't removed after being added\n\n        if expl is not None:\n            task.expl = expl\n\n        if not (task.status == RUNNING and status == PENDING) or new_deps:\n            # don't allow re-scheduling of task while it is running, it must either fail or succeed first\n            if status == PENDING or status != task.status:\n                # Update the DB only if there was a acctual change, to prevent noise.\n                # We also check for status == PENDING b/c that's the default value\n                # (so checking for status != task.status woule lie)\n                self._update_task_history(task, status)\n            self._state.set_status(task, PENDING if status == SUSPENDED else status, self._config)\n            if status == FAILED:\n                task.retry = self._retry_time(task, self._config)\n\n        if deps is not None:\n            task.deps = set(deps)\n\n        if new_deps is not None:\n            task.deps.update(new_deps)\n\n        if resources is not None:\n            task.resources = resources\n\n        if worker_enabled and not assistant:\n            task.stakeholders.add(worker_id)\n\n            # Task dependencies might not exist yet. Let's create dummy tasks for them for now.\n            # Otherwise the task dependencies might end up being pruned if scheduling takes a long time\n            for dep in task.deps or []:\n                t = self._state.get_task(dep, setdefault=self._make_task(task_id=dep, status=UNKNOWN, deps=None, priority=priority))\n                t.stakeholders.add(worker_id)\n\n        self._update_priority(task, priority, worker_id)\n\n        if runnable and status != FAILED and worker_enabled:\n            task.workers.add(worker_id)\n            self._state.get_worker(worker_id).tasks.add(task)\n            task.runnable = runnable",
        "begin_line": 583,
        "end_line": 661,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00234192037470726,
            "pseudo_dstar_susp": 0.002824858757062147,
            "pseudo_tarantula_susp": 0.002849002849002849,
            "pseudo_op2_susp": 0.002824858757062147,
            "pseudo_barinel_susp": 0.002849002849002849
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.add_worker#663",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.add_worker(self, worker, info, **kwargs)",
        "snippet": "    def add_worker(self, worker, info, **kwargs):\n        self._state.get_worker(worker).add_info(info)",
        "begin_line": 663,
        "end_line": 664,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002369668246445498,
            "pseudo_dstar_susp": 0.004201680672268907,
            "pseudo_tarantula_susp": 0.002105263157894737,
            "pseudo_op2_susp": 0.004201680672268907,
            "pseudo_barinel_susp": 0.002105263157894737
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.disable_worker#666",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.disable_worker(self, worker)",
        "snippet": "    def disable_worker(self, worker):\n        self._state.disable_workers({worker})",
        "begin_line": 666,
        "end_line": 667,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00026441036488630354,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.update_resources#669",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.update_resources(self, **resources)",
        "snippet": "    def update_resources(self, **resources):\n        if self._resources is None:\n            self._resources = {}\n        self._resources.update(resources)",
        "begin_line": 669,
        "end_line": 672,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00023860653781913624,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._has_resources#674",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._has_resources(self, needed_resources, used_resources)",
        "snippet": "    def _has_resources(self, needed_resources, used_resources):\n        if needed_resources is None:\n            return True\n\n        available_resources = self._resources or {}\n        for resource, amount in six.iteritems(needed_resources):\n            if amount + used_resources[resource] > available_resources.get(resource, 1):\n                return False\n        return True",
        "begin_line": 674,
        "end_line": 682,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009775171065493646,
            "pseudo_dstar_susp": 0.0013089005235602095,
            "pseudo_tarantula_susp": 0.0009398496240601503,
            "pseudo_op2_susp": 0.0013089005235602095,
            "pseudo_barinel_susp": 0.0009389671361502347
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._used_resources#684",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._used_resources(self)",
        "snippet": "    def _used_resources(self):\n        used_resources = collections.defaultdict(int)\n        if self._resources is not None:\n            for task in self._state.get_active_tasks(status=RUNNING):\n                if task.resources:\n                    for resource, amount in six.iteritems(task.resources):\n                        used_resources[resource] += amount\n        return used_resources",
        "begin_line": 684,
        "end_line": 691,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014749262536873156,
            "pseudo_dstar_susp": 0.0010395010395010396,
            "pseudo_tarantula_susp": 0.00234192037470726,
            "pseudo_op2_susp": 0.0010395010395010396,
            "pseudo_barinel_susp": 0.00234192037470726
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._rank#693",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._rank(self, task)",
        "snippet": "    def _rank(self, task):\n        \"\"\"\n        Return worker's rank function for task scheduling.\n\n        :return:\n        \"\"\"\n\n        return task.priority, -task.time",
        "begin_line": 693,
        "end_line": 700,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000946969696969697,
            "pseudo_dstar_susp": 0.001256281407035176,
            "pseudo_tarantula_susp": 0.000877963125548727,
            "pseudo_op2_susp": 0.001256281407035176,
            "pseudo_barinel_susp": 0.000877963125548727
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._schedulable#702",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._schedulable(self, task)",
        "snippet": "    def _schedulable(self, task):\n        if task.status != PENDING:\n            return False\n        for dep in task.deps:\n            dep_task = self._state.get_task(dep, default=None)\n            if dep_task is None or dep_task.status != DONE:\n                return False\n        return True",
        "begin_line": 702,
        "end_line": 709,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009737098344693282,
            "pseudo_dstar_susp": 0.0013020833333333333,
            "pseudo_tarantula_susp": 0.0009216589861751152,
            "pseudo_op2_susp": 0.0013020833333333333,
            "pseudo_barinel_susp": 0.0009216589861751152
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._retry_time#711",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._retry_time(self, task, config)",
        "snippet": "    def _retry_time(self, task, config):\n        return time.time() + config.retry_delay",
        "begin_line": 711,
        "end_line": 712,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00234192037470726,
            "pseudo_dstar_susp": 0.0019646365422396855,
            "pseudo_tarantula_susp": 0.002849002849002849,
            "pseudo_op2_susp": 0.0019646365422396855,
            "pseudo_barinel_susp": 0.002849002849002849
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.get_work#714",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.get_work(self, host=None, assistant=False, current_tasks=None, **kwargs)",
        "snippet": "    def get_work(self, host=None, assistant=False, current_tasks=None, **kwargs):\n        # TODO: remove any expired nodes\n\n        # Algo: iterate over all nodes, find the highest priority node no dependencies and available\n        # resources.\n\n        # Resource checking looks both at currently available resources and at which resources would\n        # be available if all running tasks died and we rescheduled all workers greedily. We do both\n        # checks in order to prevent a worker with many low-priority tasks from starving other\n        # workers with higher priority tasks that share the same resources.\n\n        # TODO: remove tasks that can't be done, figure out if the worker has absolutely\n        # nothing it can wait for\n\n        if self._config.prune_on_get_work:\n            self.prune()\n\n        worker_id = kwargs['worker']\n        # Return remaining tasks that have no FAILED descendants\n        self.update(worker_id, {'host': host}, get_work=True)\n        if assistant:\n            self.add_worker(worker_id, [('assistant', assistant)])\n\n        best_task = None\n        if current_tasks is not None:\n            ct_set = set(current_tasks)\n            for task in sorted(self._state.get_running_tasks(), key=self._rank):\n                if task.worker_running == worker_id and task.id not in ct_set:\n                    best_task = task\n\n        locally_pending_tasks = 0\n        running_tasks = []\n        upstream_table = {}\n\n        greedy_resources = collections.defaultdict(int)\n        n_unique_pending = 0\n\n        worker = self._state.get_worker(worker_id)\n        if worker.is_trivial_worker(self._state):\n            relevant_tasks = worker.get_pending_tasks(self._state)\n            used_resources = collections.defaultdict(int)\n            greedy_workers = dict()  # If there's no resources, then they can grab any task\n        else:\n            relevant_tasks = self._state.get_pending_tasks()\n            used_resources = self._used_resources()\n            activity_limit = time.time() - self._config.worker_disconnect_delay\n            active_workers = self._state.get_active_workers(last_get_work_gt=activity_limit)\n            greedy_workers = dict((worker.id, worker.info.get('workers', 1))\n                                  for worker in active_workers)\n        tasks = list(relevant_tasks)\n        tasks.sort(key=self._rank, reverse=True)\n\n        for task in tasks:\n            in_workers = (assistant and getattr(task, 'runnable', bool(task.workers))) or worker_id in task.workers\n            if task.status == RUNNING and in_workers:\n                # Return a list of currently running tasks to the client,\n                # makes it easier to troubleshoot\n                other_worker = self._state.get_worker(task.worker_running)\n                more_info = {'task_id': task.id, 'worker': str(other_worker)}\n                if other_worker is not None:\n                    more_info.update(other_worker.info)\n                    running_tasks.append(more_info)\n\n            if task.status == PENDING and in_workers:\n                upstream_status = self._upstream_status(task.id, upstream_table)\n                if upstream_status != UPSTREAM_DISABLED:\n                    locally_pending_tasks += 1\n                    if len(task.workers) == 1 and not assistant:\n                        n_unique_pending += 1\n\n            if best_task:\n                continue\n\n            if task.status == RUNNING and (task.worker_running in greedy_workers):\n                greedy_workers[task.worker_running] -= 1\n                for resource, amount in six.iteritems((task.resources or {})):\n                    greedy_resources[resource] += amount\n\n            if self._schedulable(task) and self._has_resources(task.resources, greedy_resources):\n                if in_workers and self._has_resources(task.resources, used_resources):\n                    best_task = task\n                else:\n                    workers = itertools.chain(task.workers, [worker_id]) if assistant else task.workers\n                    for task_worker in workers:\n                        if greedy_workers.get(task_worker, 0) > 0:\n                            # use up a worker\n                            greedy_workers[task_worker] -= 1\n\n                            # keep track of the resources used in greedy scheduling\n                            for resource, amount in six.iteritems((task.resources or {})):\n                                greedy_resources[resource] += amount\n\n                            break\n\n        reply = {'n_pending_tasks': locally_pending_tasks,\n                 'running_tasks': running_tasks,\n                 'task_id': None,\n                 'n_unique_pending': n_unique_pending}\n\n        if best_task:\n            self._state.set_status(best_task, RUNNING, self._config)\n            best_task.worker_running = worker_id\n            best_task.time_running = time.time()\n            self._update_task_history(best_task, RUNNING, host=host)\n\n            reply['task_id'] = best_task.id\n            reply['task_family'] = best_task.family\n            reply['task_module'] = getattr(best_task, 'module', None)\n            reply['task_params'] = best_task.params\n\n        return reply",
        "begin_line": 714,
        "end_line": 824,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0031746031746031746,
            "pseudo_dstar_susp": 0.00390625,
            "pseudo_tarantula_susp": 0.005050505050505051,
            "pseudo_op2_susp": 0.00390625,
            "pseudo_barinel_susp": 0.005050505050505051
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.ping#826",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.ping(self, **kwargs)",
        "snippet": "    def ping(self, **kwargs):\n        worker_id = kwargs['worker']\n        self.update(worker_id)",
        "begin_line": 826,
        "end_line": 828,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002320185614849188,
            "pseudo_dstar_susp": 0.001081081081081081,
            "pseudo_tarantula_susp": 0.004310344827586207,
            "pseudo_op2_susp": 0.001081081081081081,
            "pseudo_barinel_susp": 0.004310344827586207
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._upstream_status#830",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._upstream_status(self, task_id, upstream_status_table)",
        "snippet": "    def _upstream_status(self, task_id, upstream_status_table):\n        if task_id in upstream_status_table:\n            return upstream_status_table[task_id]\n        elif self._state.has_task(task_id):\n            task_stack = [task_id]\n\n            while task_stack:\n                dep_id = task_stack.pop()\n                dep = self._state.get_task(dep_id)\n                if dep:\n                    if dep.status == DONE:\n                        continue\n                    if dep_id not in upstream_status_table:\n                        if dep.status == PENDING and dep.deps:\n                            task_stack += [dep_id] + list(dep.deps)\n                            upstream_status_table[dep_id] = ''  # will be updated postorder\n                        else:\n                            dep_status = STATUS_TO_UPSTREAM_MAP.get(dep.status, '')\n                            upstream_status_table[dep_id] = dep_status\n                    elif upstream_status_table[dep_id] == '' and dep.deps:\n                        # This is the postorder update step when we set the\n                        # status based on the previously calculated child elements\n                        status = max((upstream_status_table.get(a_task_id, '')\n                                      for a_task_id in dep.deps),\n                                     key=UPSTREAM_SEVERITY_KEY)\n                        upstream_status_table[dep_id] = status\n            return upstream_status_table[dep_id]",
        "begin_line": 830,
        "end_line": 856,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00099601593625498,
            "pseudo_dstar_susp": 0.0013315579227696406,
            "pseudo_tarantula_susp": 0.0009891196834817012,
            "pseudo_op2_susp": 0.0013315579227696406,
            "pseudo_barinel_susp": 0.0009891196834817012
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._serialize_task#858",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._serialize_task(self, task_id, include_deps=True, deps=None)",
        "snippet": "    def _serialize_task(self, task_id, include_deps=True, deps=None):\n        task = self._state.get_task(task_id)\n        ret = {\n            'display_name': task.pretty_id,\n            'status': task.status,\n            'workers': list(task.workers),\n            'worker_running': task.worker_running,\n            'time_running': getattr(task, \"time_running\", None),\n            'start_time': task.time,\n            'last_updated': getattr(task, \"updated\", task.time),\n            'params': task.params,\n            'name': task.family,\n            'priority': task.priority,\n            'resources': task.resources,\n            'tracking_url': getattr(task, \"tracking_url\", None),\n        }\n        if task.status == DISABLED:\n            ret['re_enable_able'] = task.scheduler_disable_time is not None\n        if include_deps:\n            ret['deps'] = list(task.deps if deps is None else deps)\n        return ret",
        "begin_line": 858,
        "end_line": 878,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010351966873706005,
            "pseudo_dstar_susp": 0.001006036217303823,
            "pseudo_tarantula_susp": 0.001851851851851852,
            "pseudo_op2_susp": 0.001006036217303823,
            "pseudo_barinel_susp": 0.001851851851851852
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.graph#880",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.graph(self, **kwargs)",
        "snippet": "    def graph(self, **kwargs):\n        self.prune()\n        serialized = {}\n        seen = set()\n        for task in self._state.get_active_tasks():\n            serialized.update(self._traverse_graph(task.id, seen))\n        return serialized",
        "begin_line": 880,
        "end_line": 886,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._filter_done#888",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._filter_done(self, task_ids)",
        "snippet": "    def _filter_done(self, task_ids):\n        for task_id in task_ids:\n            task = self._state.get_task(task_id)\n            if task is None or task.status != DONE:\n                yield task_id",
        "begin_line": 888,
        "end_line": 892,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._traverse_graph#894",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._traverse_graph(self, root_task_id, seen=None, dep_func=None, include_done=True)",
        "snippet": "    def _traverse_graph(self, root_task_id, seen=None, dep_func=None, include_done=True):\n        \"\"\" Returns the dependency graph rooted at task_id\n\n        This does a breadth-first traversal to find the nodes closest to the\n        root before hitting the scheduler.max_graph_nodes limit.\n\n        :param root_task_id: the id of the graph's root\n        :return: A map of task id to serialized node\n        \"\"\"\n\n        if seen is None:\n            seen = set()\n        elif root_task_id in seen:\n            return {}\n\n        if dep_func is None:\n            def dep_func(t):\n                return t.deps\n\n        seen.add(root_task_id)\n        serialized = {}\n        queue = collections.deque([root_task_id])\n        while queue:\n            task_id = queue.popleft()\n\n            task = self._state.get_task(task_id)\n            if task is None or not task.family:\n                logger.warn('Missing task for id [%s]', task_id)\n\n                # NOTE : If a dependency is missing from self._state there is no way to deduce the\n                #        task family and parameters.\n                family_match = TASK_FAMILY_RE.match(task_id)\n                family = family_match.group(1) if family_match else UNKNOWN\n                params = {'task_id': task_id}\n                serialized[task_id] = {\n                    'deps': [],\n                    'status': UNKNOWN,\n                    'workers': [],\n                    'start_time': UNKNOWN,\n                    'params': params,\n                    'name': family,\n                    'display_name': task_id,\n                    'priority': 0,\n                }\n            else:\n                deps = dep_func(task)\n                if not include_done:\n                    deps = list(self._filter_done(deps))\n                serialized[task_id] = self._serialize_task(task_id, deps=deps)\n                for dep in sorted(deps):\n                    if dep not in seen:\n                        seen.add(dep)\n                        queue.append(dep)\n\n            if task_id != root_task_id:\n                del serialized[task_id]['display_name']\n            if len(serialized) >= self._config.max_graph_nodes:\n                break\n\n        return serialized",
        "begin_line": 894,
        "end_line": 953,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.dep_func#910",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.dep_func(t)",
        "snippet": "            def dep_func(t):\n                return t.deps",
        "begin_line": 910,
        "end_line": 911,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002725538293813028,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.dep_graph#955",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.dep_graph(self, task_id, include_done=True, **kwargs)",
        "snippet": "    def dep_graph(self, task_id, include_done=True, **kwargs):\n        self.prune()\n        if not self._state.has_task(task_id):\n            return {}\n        return self._traverse_graph(task_id, include_done=include_done)",
        "begin_line": 955,
        "end_line": 959,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.inverse_dep_graph#961",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.inverse_dep_graph(self, task_id, include_done=True, **kwargs)",
        "snippet": "    def inverse_dep_graph(self, task_id, include_done=True, **kwargs):\n        self.prune()\n        if not self._state.has_task(task_id):\n            return {}\n        inverse_graph = collections.defaultdict(set)\n        for task in self._state.get_active_tasks():\n            for dep in task.deps:\n                inverse_graph[dep].add(task.id)\n        return self._traverse_graph(\n            task_id, dep_func=lambda t: inverse_graph[t.id], include_done=include_done)",
        "begin_line": 961,
        "end_line": 970,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.task_list#972",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.task_list(self, status, upstream_status, limit=True, search=None, **kwargs)",
        "snippet": "    def task_list(self, status, upstream_status, limit=True, search=None, **kwargs):\n        \"\"\"\n        Query for a subset of tasks by status.\n        \"\"\"\n        self.prune()\n        result = {}\n        upstream_status_table = {}  # used to memoize upstream status\n        if search is None:\n            def filter_func(_):\n                return True\n        else:\n            terms = search.split()\n\n            def filter_func(t):\n                return all(term in t.pretty_id for term in terms)\n        for task in filter(filter_func, self._state.get_active_tasks(status)):\n            if (task.status != PENDING or not upstream_status or\n                    upstream_status == self._upstream_status(task.id, upstream_status_table)):\n                serialized = self._serialize_task(task.id, False)\n                result[task.id] = serialized\n        if limit and len(result) > self._config.max_shown_tasks:\n            return {'num_tasks': len(result)}\n        return result",
        "begin_line": 972,
        "end_line": 994,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012091898428053204,
            "pseudo_dstar_susp": 0.0010256410256410256,
            "pseudo_tarantula_susp": 0.0020876826722338203,
            "pseudo_op2_susp": 0.0010256410256410256,
            "pseudo_barinel_susp": 0.0020876826722338203
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.filter_func#980",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.filter_func(_)",
        "snippet": "            def filter_func(_):\n                return True",
        "begin_line": 980,
        "end_line": 981,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0023094688221709007,
            "pseudo_dstar_susp": 0.0033333333333333335,
            "pseudo_tarantula_susp": 0.0022172949002217295,
            "pseudo_op2_susp": 0.0033333333333333335,
            "pseudo_barinel_susp": 0.0022172949002217295
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.filter_func#985",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.filter_func(t)",
        "snippet": "            def filter_func(t):\n                return all(term in t.pretty_id for term in terms)",
        "begin_line": 985,
        "end_line": 986,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00023837902264600716,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._first_task_display_name#996",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._first_task_display_name(self, worker)",
        "snippet": "    def _first_task_display_name(self, worker):\n        task_id = worker.info.get('first_task', '')\n        if self._state.has_task(task_id):\n            return self._state.get_task(task_id).pretty_id\n        else:\n            return task_id",
        "begin_line": 996,
        "end_line": 1001,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.worker_list#1003",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.worker_list(self, include_running=True, **kwargs)",
        "snippet": "    def worker_list(self, include_running=True, **kwargs):\n        self.prune()\n        workers = [\n            dict(\n                name=worker.id,\n                last_active=worker.last_active,\n                started=getattr(worker, 'started', None),\n                first_task_display_name=self._first_task_display_name(worker),\n                **worker.info\n            ) for worker in self._state.get_active_workers()]\n        workers.sort(key=lambda worker: worker['started'], reverse=True)\n        if include_running:\n            running = collections.defaultdict(dict)\n            num_pending = collections.defaultdict(int)\n            num_uniques = collections.defaultdict(int)\n            for task in self._state.get_pending_tasks():\n                if task.status == RUNNING and task.worker_running:\n                    running[task.worker_running][task.id] = self._serialize_task(task.id, False)\n                elif task.status == PENDING:\n                    for worker in task.workers:\n                        num_pending[worker] += 1\n                    if len(task.workers) == 1:\n                        num_uniques[list(task.workers)[0]] += 1\n            for worker in workers:\n                tasks = running[worker['name']]\n                worker['num_running'] = len(tasks)\n                worker['num_pending'] = num_pending[worker['name']]\n                worker['num_uniques'] = num_uniques[worker['name']]\n                worker['running'] = tasks\n        return workers",
        "begin_line": 1003,
        "end_line": 1032,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.task_search#1069",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.task_search(self, task_str, **kwargs)",
        "snippet": "    def task_search(self, task_str, **kwargs):\n        \"\"\"\n        Query for a subset of tasks by task_id.\n\n        :param task_str:\n        :return:\n        \"\"\"\n        self.prune()\n        result = collections.defaultdict(dict)\n        for task in self._state.get_active_tasks():\n            if task.id.find(task_str) != -1:\n                serialized = self._serialize_task(task.id, False)\n                result[task.status][task.id] = serialized\n        return result",
        "begin_line": 1069,
        "end_line": 1082,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.re_enable_task#1084",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.re_enable_task(self, task_id)",
        "snippet": "    def re_enable_task(self, task_id):\n        serialized = {}\n        task = self._state.get_task(task_id)\n        if task and task.status == DISABLED and task.scheduler_disable_time:\n            self._state.re_enable(task, self._config)\n            serialized = self._serialize_task(task_id)\n        return serialized",
        "begin_line": 1084,
        "end_line": 1090,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.fetch_error#1092",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.fetch_error(self, task_id, **kwargs)",
        "snippet": "    def fetch_error(self, task_id, **kwargs):\n        if self._state.has_task(task_id):\n            task = self._state.get_task(task_id)\n            return {\"taskId\": task_id, \"error\": task.expl, 'displayName': task.pretty_id}\n        else:\n            return {\"taskId\": task_id, \"error\": \"\"}",
        "begin_line": 1092,
        "end_line": 1097,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._update_task_history#1099",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._update_task_history(self, task, status, host=None)",
        "snippet": "    def _update_task_history(self, task, status, host=None):\n        try:\n            if status == DONE or status == FAILED:\n                successful = (status == DONE)\n                self._task_history.task_finished(task, successful)\n            elif status == PENDING:\n                self._task_history.task_scheduled(task)\n            elif status == RUNNING:\n                self._task_history.task_started(task, host)\n        except BaseException:\n            logger.warning(\"Error saving Task history\", exc_info=True)",
        "begin_line": 1099,
        "end_line": 1109,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014903129657228018,
            "pseudo_dstar_susp": 0.002898550724637681,
            "pseudo_tarantula_susp": 0.0012755102040816326,
            "pseudo_op2_susp": 0.002898550724637681,
            "pseudo_barinel_susp": 0.0012755102040816326
        }
    },
    {
        "name": "luigi.tools.range.RangeBase.of_cls#112",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeBase",
        "signature": "luigi.tools.range.RangeBase.of_cls(self)",
        "snippet": "    def of_cls(self):\n        \"\"\"\n        DONT USE. Will be deleted soon. Use ``self.of``!\n        \"\"\"\n        if isinstance(self.of, six.string_types):\n            warnings.warn('When using Range programatically, dont pass \"of\" param as string!')\n            return Register.get_task_cls(self.of)\n        return self.of",
        "begin_line": 112,
        "end_line": 119,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00025471217524197657,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range.RangeBase._emit_metrics#149",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeBase",
        "signature": "luigi.tools.range.RangeBase._emit_metrics(self, missing_datetimes, finite_start, finite_stop)",
        "snippet": "    def _emit_metrics(self, missing_datetimes, finite_start, finite_stop):\n        \"\"\"\n        For consistent metrics one should consider the entire range, but\n        it is open (infinite) if stop or start is None.\n\n        Hence make do with metrics respective to the finite simplification.\n        \"\"\"\n        datetimes = self.finite_datetimes(\n            finite_start if self.start is None else min(finite_start, self.parameter_to_datetime(self.start)),\n            finite_stop if self.stop is None else max(finite_stop, self.parameter_to_datetime(self.stop)))\n\n        delay_in_jobs = len(datetimes) - datetimes.index(missing_datetimes[0]) if datetimes and missing_datetimes else 0\n        self.trigger_event(RangeEvent.DELAY, self.of_cls.task_family, delay_in_jobs)\n\n        expected_count = len(datetimes)\n        complete_count = expected_count - len(missing_datetimes)\n        self.trigger_event(RangeEvent.COMPLETE_COUNT, self.of_cls.task_family, complete_count)\n        self.trigger_event(RangeEvent.COMPLETE_FRACTION, self.of_cls.task_family, float(complete_count) / expected_count if expected_count else 1)",
        "begin_line": 149,
        "end_line": 166,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00025471217524197657,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range.RangeBase._format_datetime#168",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeBase",
        "signature": "luigi.tools.range.RangeBase._format_datetime(self, dt)",
        "snippet": "    def _format_datetime(self, dt):\n        return self.datetime_to_parameter(dt)",
        "begin_line": 168,
        "end_line": 169,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002842524161455372,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range.RangeBase._format_range#171",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeBase",
        "signature": "luigi.tools.range.RangeBase._format_range(self, datetimes)",
        "snippet": "    def _format_range(self, datetimes):\n        param_first = self._format_datetime(datetimes[0])\n        param_last = self._format_datetime(datetimes[-1])\n        return '[%s, %s]' % (param_first, param_last)",
        "begin_line": 171,
        "end_line": 174,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00025471217524197657,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range.RangeBase._instantiate_task_cls#176",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeBase",
        "signature": "luigi.tools.range.RangeBase._instantiate_task_cls(self, param)",
        "snippet": "    def _instantiate_task_cls(self, param):\n        if self.param_name is None:\n            return self.of_cls(param)\n        else:\n            kwargs = {self.param_name: param}\n            return self.of_cls(**kwargs)",
        "begin_line": 176,
        "end_line": 181,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range.RangeBase.requires#183",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeBase",
        "signature": "luigi.tools.range.RangeBase.requires(self)",
        "snippet": "    def requires(self):\n        # cache because we anticipate a fair amount of computation\n        if hasattr(self, '_cached_requires'):\n            return self._cached_requires\n\n        if not self.start and not self.stop:\n            raise ParameterException(\"At least one of start and stop needs to be specified\")\n        if not self.start and not self.reverse:\n            raise ParameterException(\"Either start needs to be specified or reverse needs to be True\")\n        if self.start and self.stop and self.start > self.stop:\n            raise ParameterException(\"Can't have start > stop\")\n        # TODO check overridden complete() and exists()\n\n        now = datetime.utcfromtimestamp(time.time() if self.now is None else self.now)\n\n        moving_start = self.moving_start(now)\n        finite_start = moving_start if self.start is None else max(self.parameter_to_datetime(self.start), moving_start)\n        moving_stop = self.moving_stop(now)\n        finite_stop = moving_stop if self.stop is None else min(self.parameter_to_datetime(self.stop), moving_stop)\n\n        datetimes = self.finite_datetimes(finite_start, finite_stop) if finite_start <= finite_stop else []\n\n        if datetimes:\n            logger.debug('Actually checking if range %s of %s is complete',\n                         self._format_range(datetimes), self.of_cls.task_family)\n            missing_datetimes = sorted(self._missing_datetimes(datetimes))\n            logger.debug('Range %s lacked %d of expected %d %s instances',\n                         self._format_range(datetimes), len(missing_datetimes), len(datetimes), self.of_cls.task_family)\n        else:\n            missing_datetimes = []\n            logger.debug('Empty range. No %s instances expected', self.of_cls.task_family)\n\n        self._emit_metrics(missing_datetimes, finite_start, finite_stop)\n\n        if self.reverse:\n            required_datetimes = missing_datetimes[-self.task_limit:]\n        else:\n            required_datetimes = missing_datetimes[:self.task_limit]\n        if required_datetimes:\n            logger.debug('Requiring %d missing %s instances in range %s',\n                         len(required_datetimes), self.of_cls.task_family, self._format_range(required_datetimes))\n        if self.reverse:\n            required_datetimes.reverse()  # TODO priorities, so that within the batch tasks are ordered too\n\n        self._cached_requires = [self._instantiate_task_cls(self.datetime_to_parameter(d)) for d in required_datetimes]\n        return self._cached_requires",
        "begin_line": 183,
        "end_line": 228,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range.RangeBase.missing_datetimes#230",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeBase",
        "signature": "luigi.tools.range.RangeBase.missing_datetimes(self, finite_datetimes)",
        "snippet": "    def missing_datetimes(self, finite_datetimes):\n        \"\"\"\n        Override in subclasses to do bulk checks.\n\n        Returns a sorted list.\n\n        This is a conservative base implementation that brutally checks completeness, instance by instance.\n\n        Inadvisable as it may be slow.\n        \"\"\"\n        return [d for d in finite_datetimes if not self._instantiate_task_cls(self.datetime_to_parameter(d)).complete()]",
        "begin_line": 230,
        "end_line": 240,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range.RangeBase._missing_datetimes#242",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeBase",
        "signature": "luigi.tools.range.RangeBase._missing_datetimes(self, finite_datetimes)",
        "snippet": "    def _missing_datetimes(self, finite_datetimes):\n        \"\"\"\n        Backward compatible wrapper. Will be deleted eventually (stated on Dec 2015)\n        \"\"\"\n        try:\n            return self.missing_datetimes(finite_datetimes)\n        except TypeError as ex:\n            if 'missing_datetimes()' in repr(ex):\n                warnings.warn('In your Range* subclass, missing_datetimes() should only take 1 argument (see latest docs)')\n                return self.missing_datetimes(self.of_cls, finite_datetimes)\n            else:\n                raise",
        "begin_line": 242,
        "end_line": 253,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range.RangeDailyBase.datetime_to_parameter#279",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeDailyBase",
        "signature": "luigi.tools.range.RangeDailyBase.datetime_to_parameter(self, dt)",
        "snippet": "    def datetime_to_parameter(self, dt):\n        return dt.date()",
        "begin_line": 279,
        "end_line": 280,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002842524161455372,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range.RangeDailyBase.parameter_to_datetime#282",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeDailyBase",
        "signature": "luigi.tools.range.RangeDailyBase.parameter_to_datetime(self, p)",
        "snippet": "    def parameter_to_datetime(self, p):\n        return datetime(p.year, p.month, p.day)",
        "begin_line": 282,
        "end_line": 283,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002842524161455372,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range.RangeDailyBase.moving_start#285",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeDailyBase",
        "signature": "luigi.tools.range.RangeDailyBase.moving_start(self, now)",
        "snippet": "    def moving_start(self, now):\n        return now - timedelta(days=self.days_back)",
        "begin_line": 285,
        "end_line": 286,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002842524161455372,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range.RangeDailyBase.moving_stop#288",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeDailyBase",
        "signature": "luigi.tools.range.RangeDailyBase.moving_stop(self, now)",
        "snippet": "    def moving_stop(self, now):\n        return now + timedelta(days=self.days_forward)",
        "begin_line": 288,
        "end_line": 289,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002842524161455372,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range.RangeDailyBase.finite_datetimes#291",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeDailyBase",
        "signature": "luigi.tools.range.RangeDailyBase.finite_datetimes(self, finite_start, finite_stop)",
        "snippet": "    def finite_datetimes(self, finite_start, finite_stop):\n        \"\"\"\n        Simply returns the points in time that correspond to turn of day.\n        \"\"\"\n        date_start = datetime(finite_start.year, finite_start.month, finite_start.day)\n        dates = []\n        for i in itertools.count():\n            t = date_start + timedelta(days=i)\n            if t >= finite_stop:\n                return dates\n            if t >= finite_start:\n                dates.append(t)",
        "begin_line": 291,
        "end_line": 302,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002937720329024677,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase.datetime_to_parameter#329",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase.datetime_to_parameter(self, dt)",
        "snippet": "    def datetime_to_parameter(self, dt):\n        return dt",
        "begin_line": 329,
        "end_line": 330,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00030543677458766036,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase.parameter_to_datetime#332",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase.parameter_to_datetime(self, p)",
        "snippet": "    def parameter_to_datetime(self, p):\n        return p",
        "begin_line": 332,
        "end_line": 333,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002937720329024677,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase.moving_start#335",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase.moving_start(self, now)",
        "snippet": "    def moving_start(self, now):\n        return now - timedelta(hours=self.hours_back)",
        "begin_line": 335,
        "end_line": 336,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002937720329024677,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase.moving_stop#338",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase.moving_stop(self, now)",
        "snippet": "    def moving_stop(self, now):\n        return now + timedelta(hours=self.hours_forward)",
        "begin_line": 338,
        "end_line": 339,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002937720329024677,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase.finite_datetimes#341",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase.finite_datetimes(self, finite_start, finite_stop)",
        "snippet": "    def finite_datetimes(self, finite_start, finite_stop):\n        \"\"\"\n        Simply returns the points in time that correspond to whole hours.\n        \"\"\"\n        datehour_start = datetime(finite_start.year, finite_start.month, finite_start.day, finite_start.hour)\n        datehours = []\n        for i in itertools.count():\n            t = datehour_start + timedelta(hours=i)\n            if t >= finite_stop:\n                return datehours\n            if t >= finite_start:\n                datehours.append(t)",
        "begin_line": 341,
        "end_line": 352,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00030543677458766036,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase._format_datetime#354",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase._format_datetime(self, dt)",
        "snippet": "    def _format_datetime(self, dt):\n        return luigi.DateHourParameter().serialize(dt)",
        "begin_line": 354,
        "end_line": 355,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002937720329024677,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range._constrain_glob#358",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range._constrain_glob(glob, paths, limit=5)",
        "snippet": "def _constrain_glob(glob, paths, limit=5):\n    \"\"\"\n    Tweaks glob into a list of more specific globs that together still cover paths and not too much extra.\n\n    Saves us minutes long listings for long dataset histories.\n\n    Specifically, in this implementation the leftmost occurrences of \"[0-9]\"\n    give rise to a few separate globs that each specialize the expression to\n    digits that actually occur in paths.\n    \"\"\"\n\n    def digit_set_wildcard(chars):\n        \"\"\"\n        Makes a wildcard expression for the set, a bit readable, e.g. [1-5].\n        \"\"\"\n        chars = sorted(chars)\n        if len(chars) > 1 and ord(chars[-1]) - ord(chars[0]) == len(chars) - 1:\n            return '[%s-%s]' % (chars[0], chars[-1])\n        else:\n            return '[%s]' % ''.join(chars)\n\n    current = {glob: paths}\n    while True:\n        pos = list(current.keys())[0].find('[0-9]')\n        if pos == -1:\n            # no wildcard expressions left to specialize in the glob\n            return list(current.keys())\n        char_sets = {}\n        for g, p in six.iteritems(current):\n            char_sets[g] = sorted(set(path[pos] for path in p))\n        if sum(len(s) for s in char_sets.values()) > limit:\n            return [g.replace('[0-9]', digit_set_wildcard(char_sets[g]), 1) for g in current]\n        for g, s in six.iteritems(char_sets):\n            for c in s:\n                new_glob = g.replace('[0-9]', c, 1)\n                new_paths = list(filter(lambda p: p[pos] == c, current[g]))\n                current[new_glob] = new_paths\n            del current[g]",
        "begin_line": 358,
        "end_line": 395,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00032754667540124465,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range.digit_set_wildcard#369",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range.digit_set_wildcard(chars)",
        "snippet": "    def digit_set_wildcard(chars):\n        \"\"\"\n        Makes a wildcard expression for the set, a bit readable, e.g. [1-5].\n        \"\"\"\n        chars = sorted(chars)\n        if len(chars) > 1 and ord(chars[-1]) - ord(chars[0]) == len(chars) - 1:\n            return '[%s-%s]' % (chars[0], chars[-1])\n        else:\n            return '[%s]' % ''.join(chars)",
        "begin_line": 369,
        "end_line": 377,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range.most_common#398",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range.most_common(items)",
        "snippet": "def most_common(items):\n    \"\"\"\n    Wanted functionality from Counters (new in Python 2.7).\n    \"\"\"\n    counts = {}\n    for i in items:\n        counts.setdefault(i, 0)\n        counts[i] += 1\n    return max(six.iteritems(counts), key=operator.itemgetter(1))",
        "begin_line": 398,
        "end_line": 406,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002842524161455372,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range._get_per_location_glob#409",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range._get_per_location_glob(tasks, outputs, regexes)",
        "snippet": "def _get_per_location_glob(tasks, outputs, regexes):\n    \"\"\"\n    Builds a glob listing existing output paths.\n\n    Esoteric reverse engineering, but worth it given that (compared to an\n    equivalent contiguousness guarantee by naive complete() checks)\n    requests to the filesystem are cut by orders of magnitude, and users\n    don't even have to retrofit existing tasks anyhow.\n    \"\"\"\n    paths = [o.path for o in outputs]\n    # naive, because some matches could be confused by numbers earlier\n    # in path, e.g. /foo/fifa2000k/bar/2000-12-31/00\n    matches = [r.search(p) for r, p in zip(regexes, paths)]\n\n    for m, p, t in zip(matches, paths, tasks):\n        if m is None:\n            raise NotImplementedError(\"Couldn't deduce datehour representation in output path %r of task %s\" % (p, t))\n\n    n_groups = len(matches[0].groups())\n    # the most common position of every group is likely\n    # to be conclusive hit or miss\n    positions = [most_common((m.start(i), m.end(i)) for m in matches)[0] for i in range(1, n_groups + 1)]\n\n    glob = list(paths[0])  # FIXME sanity check that it's the same for all paths\n    for start, end in positions:\n        glob = glob[:start] + ['[0-9]'] * (end - start) + glob[end:]\n    # chop off the last path item\n    # (wouldn't need to if `hadoop fs -ls -d` equivalent were available)\n    return ''.join(glob).rsplit('/', 1)[0]",
        "begin_line": 409,
        "end_line": 437,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range._get_filesystems_and_globs#440",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range._get_filesystems_and_globs(datetime_to_task, datetime_to_re)",
        "snippet": "def _get_filesystems_and_globs(datetime_to_task, datetime_to_re):\n    \"\"\"\n    Yields a (filesystem, glob) tuple per every output location of task.\n\n    The task can have one or several FileSystemTarget outputs.\n\n    For convenience, the task can be a luigi.WrapperTask,\n    in which case outputs of all its dependencies are considered.\n    \"\"\"\n    # probe some scattered datetimes unlikely to all occur in paths, other than by being sincere datetime parameter's representations\n    # TODO limit to [self.start, self.stop) so messages are less confusing? Done trivially it can kill correctness\n    sample_datetimes = [datetime(y, m, d, h) for y in range(2000, 2050, 10) for m in range(1, 4) for d in range(5, 8) for h in range(21, 24)]\n    regexes = [re.compile(datetime_to_re(d)) for d in sample_datetimes]\n    sample_tasks = [datetime_to_task(d) for d in sample_datetimes]\n    sample_outputs = [flatten_output(t) for t in sample_tasks]\n\n    for o, t in zip(sample_outputs, sample_tasks):\n        if len(o) != len(sample_outputs[0]):\n            raise NotImplementedError(\"Outputs must be consistent over time, sorry; was %r for %r and %r for %r\" % (o, t, sample_outputs[0], sample_tasks[0]))\n            # TODO fall back on requiring last couple of days? to avoid astonishing blocking when changes like that are deployed\n            # erm, actually it's not hard to test entire hours_back..hours_forward and split into consistent subranges FIXME?\n        for target in o:\n            if not isinstance(target, FileSystemTarget):\n                raise NotImplementedError(\"Output targets must be instances of FileSystemTarget; was %r for %r\" % (target, t))\n\n    for o in zip(*sample_outputs):  # transposed, so here we're iterating over logical outputs, not datetimes\n        glob = _get_per_location_glob(sample_tasks, o, regexes)\n        yield o[0].fs, glob",
        "begin_line": 440,
        "end_line": 467,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range._list_existing#470",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range._list_existing(filesystem, glob, paths)",
        "snippet": "def _list_existing(filesystem, glob, paths):\n    \"\"\"\n    Get all the paths that do in fact exist. Returns a set of all existing paths.\n\n    Takes a luigi.target.FileSystem object, a str which represents a glob and\n    a list of strings representing paths.\n    \"\"\"\n    globs = _constrain_glob(glob, paths)\n    time_start = time.time()\n    listing = []\n    for g in sorted(globs):\n        logger.debug('Listing %s', g)\n        if filesystem.exists(g):\n            listing.extend(filesystem.listdir(g))\n    logger.debug('%d %s listings took %f s to return %d items',\n                 len(globs), filesystem.__class__.__name__, time.time() - time_start, len(listing))\n    return set(listing)",
        "begin_line": 470,
        "end_line": 486,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range.infer_bulk_complete_from_fs#489",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range.infer_bulk_complete_from_fs(datetimes, datetime_to_task, datetime_to_re)",
        "snippet": "def infer_bulk_complete_from_fs(datetimes, datetime_to_task, datetime_to_re):\n    \"\"\"\n    Efficiently determines missing datetimes by filesystem listing.\n\n    The current implementation works for the common case of a task writing\n    output to a FileSystemTarget whose path is built using strftime with format\n    like '...%Y...%m...%d...%H...', without custom complete() or exists().\n\n    (Eventually Luigi could have ranges of completion as first-class citizens.\n    Then this listing business could be factored away/be provided for\n    explicitly in target API or some kind of a history server.)\n    \"\"\"\n    filesystems_and_globs_by_location = _get_filesystems_and_globs(datetime_to_task, datetime_to_re)\n    paths_by_datetime = [[o.path for o in flatten_output(datetime_to_task(d))] for d in datetimes]\n    listing = set()\n    for (f, g), p in zip(filesystems_and_globs_by_location, zip(*paths_by_datetime)):  # transposed, so here we're iterating over logical outputs, not datetimes\n        listing |= _list_existing(f, g, p)\n\n    # quickly learn everything that's missing\n    missing_datetimes = []\n    for d, p in zip(datetimes, paths_by_datetime):\n        if not set(p) <= listing:\n            missing_datetimes.append(d)\n\n    return missing_datetimes",
        "begin_line": 489,
        "end_line": 513,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00032754667540124465,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range.RangeDaily.missing_datetimes#530",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeDaily",
        "signature": "luigi.tools.range.RangeDaily.missing_datetimes(self, finite_datetimes)",
        "snippet": "    def missing_datetimes(self, finite_datetimes):\n        try:\n            complete_parameters = self.of_cls.bulk_complete(map(self.datetime_to_parameter, finite_datetimes))\n            return set(finite_datetimes) - set(map(self.parameter_to_datetime, complete_parameters))\n        except NotImplementedError:\n            return infer_bulk_complete_from_fs(\n                finite_datetimes,\n                lambda d: self._instantiate_task_cls(self.datetime_to_parameter(d)),\n                lambda d: d.strftime('(%Y).*(%m).*(%d)'))",
        "begin_line": 530,
        "end_line": 538,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.tools.range.RangeHourly.missing_datetimes#557",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourly",
        "signature": "luigi.tools.range.RangeHourly.missing_datetimes(self, finite_datetimes)",
        "snippet": "    def missing_datetimes(self, finite_datetimes):\n        try:\n            # TODO: Why is there a list() here but not for the RangeDaily??\n            complete_parameters = self.of_cls.bulk_complete(list(map(self.datetime_to_parameter, finite_datetimes)))\n            return set(finite_datetimes) - set(map(self.parameter_to_datetime, complete_parameters))\n        except NotImplementedError:\n            return infer_bulk_complete_from_fs(\n                finite_datetimes,\n                lambda d: self._instantiate_task_cls(self.datetime_to_parameter(d)),\n                lambda d: d.strftime('(%Y).*(%m).*(%d).*(%H)'))",
        "begin_line": 557,
        "end_line": 566,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalProgramTask.program_args#58",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalProgramTask",
        "signature": "luigi.contrib.external_program.ExternalProgramTask.program_args(self)",
        "snippet": "    def program_args(self):\n        \"\"\"\n        Override this method to map your task parameters to the program arguments\n\n        :return: list to pass as ``args`` to :py:class:`subprocess.Popen`\n        \"\"\"\n        raise NotImplementedError",
        "begin_line": 58,
        "end_line": 64,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalProgramTask.program_environment#66",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalProgramTask",
        "signature": "luigi.contrib.external_program.ExternalProgramTask.program_environment(self)",
        "snippet": "    def program_environment(self):\n        \"\"\"\n        Override this method to control environment variables for the program\n\n        :return: dict mapping environment variable names to values\n        \"\"\"\n        env = os.environ.copy()\n        return env",
        "begin_line": 66,
        "end_line": 73,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002725538293813028,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalProgramTask.always_log_stderr#76",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalProgramTask",
        "signature": "luigi.contrib.external_program.ExternalProgramTask.always_log_stderr(self)",
        "snippet": "    def always_log_stderr(self):\n        \"\"\"\n        When True, stderr will be logged even if program execution succeeded\n\n        Override to False to log stderr only when program execution fails.\n        \"\"\"\n        return True",
        "begin_line": 76,
        "end_line": 82,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalProgramTask._clean_output_file#84",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalProgramTask",
        "signature": "luigi.contrib.external_program.ExternalProgramTask._clean_output_file(self, file_object)",
        "snippet": "    def _clean_output_file(self, file_object):\n        file_object.seek(0)\n        return ''.join(map(lambda s: s.decode('utf-8'), file_object.readlines()))",
        "begin_line": 84,
        "end_line": 86,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002573340195573855,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalProgramTask.run#88",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalProgramTask",
        "signature": "luigi.contrib.external_program.ExternalProgramTask.run(self)",
        "snippet": "    def run(self):\n        args = list(map(str, self.program_args()))\n\n        logger.info('Running command: %s', ' '.join(args))\n        tmp_stdout, tmp_stderr = tempfile.TemporaryFile(), tempfile.TemporaryFile()\n        env = self.program_environment()\n        proc = subprocess.Popen(\n            args,\n            env=env,\n            stdout=tmp_stdout,\n            stderr=tmp_stderr\n        )\n\n        try:\n            with ExternalProgramRunContext(proc):\n                proc.wait()\n            success = proc.returncode == 0\n\n            stdout = self._clean_output_file(tmp_stdout)\n            stderr = self._clean_output_file(tmp_stderr)\n\n            if stdout:\n                logger.info('Program stdout:\\n{}'.format(stdout))\n            if stderr:\n                if self.always_log_stderr or not success:\n                    logger.info('Program stderr:\\n{}'.format(stderr))\n\n            if not success:\n                raise ExternalProgramRunError(\n                    'Program failed with return code={}:'.format(proc.returncode),\n                    args, env=env, stdout=stdout, stderr=stderr)\n        finally:\n            tmp_stderr.close()\n            tmp_stdout.close()",
        "begin_line": 88,
        "end_line": 121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalProgramRunContext.__init__#125",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalProgramRunContext",
        "signature": "luigi.contrib.external_program.ExternalProgramRunContext.__init__(self, proc)",
        "snippet": "    def __init__(self, proc):\n        self.proc = proc",
        "begin_line": 125,
        "end_line": 126,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00025157232704402514,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalProgramRunContext.__enter__#128",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalProgramRunContext",
        "signature": "luigi.contrib.external_program.ExternalProgramRunContext.__enter__(self)",
        "snippet": "    def __enter__(self):\n        self.__old_signal = signal.getsignal(signal.SIGTERM)\n        signal.signal(signal.SIGTERM, self.kill_job)\n        return self",
        "begin_line": 128,
        "end_line": 131,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00025157232704402514,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalProgramRunContext.__exit__#133",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalProgramRunContext",
        "signature": "luigi.contrib.external_program.ExternalProgramRunContext.__exit__(self, exc_type, exc_val, exc_tb)",
        "snippet": "    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is KeyboardInterrupt:\n            self.kill_job()\n        signal.signal(signal.SIGTERM, self.__old_signal)",
        "begin_line": 133,
        "end_line": 136,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalProgramRunContext.kill_job#138",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalProgramRunContext",
        "signature": "luigi.contrib.external_program.ExternalProgramRunContext.kill_job(self, captured_signal=None, stack_frame=None)",
        "snippet": "    def kill_job(self, captured_signal=None, stack_frame=None):\n        self.proc.kill()\n        if captured_signal is not None:\n            # adding 128 gives the exit code corresponding to a signal\n            sys.exit(128 + captured_signal)",
        "begin_line": 138,
        "end_line": 142,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalProgramRunError.__init__#146",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalProgramRunError",
        "signature": "luigi.contrib.external_program.ExternalProgramRunError.__init__(self, message, args, env=None, stdout=None, stderr=None)",
        "snippet": "    def __init__(self, message, args, env=None, stdout=None, stderr=None):\n        super(ExternalProgramRunError, self).__init__(message, args, env, stdout, stderr)\n        self.message = message\n        self.args = args\n        self.env = env\n        self.out = stdout\n        self.err = stderr",
        "begin_line": 146,
        "end_line": 152,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalProgramRunError.__str__#154",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalProgramRunError",
        "signature": "luigi.contrib.external_program.ExternalProgramRunError.__str__(self)",
        "snippet": "    def __str__(self):\n        info = self.message\n        info += '\\nCOMMAND: {}'.format(' '.join(self.args))\n        info += '\\nSTDOUT: {}'.format(self.out or '[empty]')\n        info += '\\nSTDERR: {}'.format(self.err or '[empty]')\n        env_string = None\n        if self.env:\n            env_string = ' '.join(['='.join([k, '\\'{}\\''.format(v)]) for k, v in self.env.items()])\n        info += '\\nENVIRONMENT: {}'.format(env_string or '[empty]')\n        return info",
        "begin_line": 154,
        "end_line": 163,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.external_program.ExternalPythonProgramTask.program_environment#186",
        "src_path": "luigi/contrib/external_program.py",
        "class_name": "luigi.contrib.external_program.ExternalPythonProgramTask",
        "signature": "luigi.contrib.external_program.ExternalPythonProgramTask.program_environment(self)",
        "snippet": "    def program_environment(self):\n        env = super(ExternalPythonProgramTask, self).program_environment()\n\n        if self.extra_pythonpath:\n            pythonpath = ':'.join([self.extra_pythonpath, env.get('PYTHONPATH', '')])\n            env.update({'PYTHONPATH': pythonpath})\n\n        if self.virtualenv:\n            # Make the same changes to the env that a normal venv/bin/activate script would\n            path = ':'.join(['{}/bin'.format(self.virtualenv), env.get('PATH', '')])\n            env.update({\n                'PATH': path,\n                'VIRTUAL_ENV': self.virtualenv\n            })\n            # remove PYTHONHOME env variable, if it exists\n            env.pop('PYTHONHOME', None)\n\n        return env",
        "begin_line": 186,
        "end_line": 203,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.util.common_params#34",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util",
        "signature": "luigi.util.common_params(task_instance, task_cls)",
        "snippet": "def common_params(task_instance, task_cls):\n    \"\"\"\n    Grab all the values in task_instance that are found in task_cls.\n    \"\"\"\n    if not isinstance(task_cls, task.Register):\n        raise TypeError(\"task_cls must be an uninstantiated Task\")\n\n    task_instance_param_names = dict(task_instance.get_params()).keys()\n    task_cls_param_names = dict(task_cls.get_params()).keys()\n    common_param_names = list(set.intersection(set(task_instance_param_names), set(task_cls_param_names)))\n    common_param_vals = [(key, dict(task_cls.get_params())[key]) for key in common_param_names]\n    common_kwargs = dict([(key, task_instance.param_kwargs[key]) for key in common_param_names])\n    vals = dict(task_instance.get_param_values(common_param_vals, [], common_kwargs))\n    return vals",
        "begin_line": 34,
        "end_line": 47,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.util.Wrapped.clone_parent#94",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util.Wrapped",
        "signature": "luigi.util.Wrapped.clone_parent(_self, **args)",
        "snippet": "            def clone_parent(_self, **args):\n                return _self.clone(cls=self.task_to_inherit, **args)",
        "begin_line": 94,
        "end_line": 95,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002842524161455372,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.util.Wrapped.requires#116",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util.Wrapped",
        "signature": "luigi.util.Wrapped.requires(_self)",
        "snippet": "            def requires(_self):\n                return _self.clone_parent()",
        "begin_line": 116,
        "end_line": 117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.util.Wrapped.run#147",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util.Wrapped",
        "signature": "luigi.util.Wrapped.run(_self)",
        "snippet": "            def run(_self):\n                i, o = _self.input(), _self.output()\n                f = o.open('w')  # TODO: assert that i, o are Target objects and not complex datastructures\n                for line in i.open('r'):\n                    f.write(line)\n                f.close()",
        "begin_line": 147,
        "end_line": 152,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.util.delegates#157",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util",
        "signature": "luigi.util.delegates(task_that_delegates)",
        "snippet": "def delegates(task_that_delegates):\n    \"\"\" Lets a task call methods on subtask(s).\n\n    The way this works is that the subtask is run as a part of the task, but\n    the task itself doesn't have to care about the requirements of the subtasks.\n    The subtask doesn't exist from the scheduler's point of view, and\n    its dependencies are instead required by the main task.\n\n    Example:\n\n    .. code-block:: python\n\n        class PowersOfN(luigi.Task):\n            n = luigi.IntParameter()\n            def f(self, x): return x ** self.n\n\n        @delegates\n        class T(luigi.Task):\n            def subtasks(self): return PowersOfN(5)\n            def run(self): print self.subtasks().f(42)\n    \"\"\"\n    if not hasattr(task_that_delegates, 'subtasks'):\n        # This method can (optionally) define a couple of delegate tasks that\n        # will be accessible as interfaces, meaning that the task can access\n        # those tasks and run methods defined on them, etc\n        raise AttributeError('%s needs to implement the method \"subtasks\"' % task_that_delegates)\n\n    @task_wraps(task_that_delegates)\n    class Wrapped(task_that_delegates):\n\n        def deps(self):\n            # Overrides method in base class\n            return task.flatten(self.requires()) + task.flatten([t.deps() for t in task.flatten(self.subtasks())])\n\n        def run(self):\n            for t in task.flatten(self.subtasks()):\n                t.run()\n            task_that_delegates.run(self)\n\n    return Wrapped",
        "begin_line": 157,
        "end_line": 196,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.util.Wrapped.deps#187",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util.Wrapped",
        "signature": "luigi.util.Wrapped.deps(self)",
        "snippet": "        def deps(self):\n            # Overrides method in base class\n            return task.flatten(self.requires()) + task.flatten([t.deps() for t in task.flatten(self.subtasks())])",
        "begin_line": 187,
        "end_line": 189,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.util.Wrapped.run#191",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util.Wrapped",
        "signature": "luigi.util.Wrapped.run(self)",
        "snippet": "        def run(self):\n            for t in task.flatten(self.subtasks()):\n                t.run()\n            task_that_delegates.run(self)",
        "begin_line": 191,
        "end_line": 194,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.util.previous#199",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util",
        "signature": "luigi.util.previous(task)",
        "snippet": "def previous(task):\n    \"\"\"\n    Return a previous Task of the same family.\n\n    By default checks if this task family only has one non-global parameter and if\n    it is a DateParameter, DateHourParameter or DateIntervalParameter in which case\n    it returns with the time decremented by 1 (hour, day or interval)\n    \"\"\"\n    params = task.get_params()\n    previous_params = {}\n    previous_date_params = {}\n\n    for param_name, param_obj in params:\n        param_value = getattr(task, param_name)\n\n        if isinstance(param_obj, parameter.DateParameter):\n            previous_date_params[param_name] = param_value - datetime.timedelta(days=1)\n        elif isinstance(param_obj, parameter.DateMinuteParameter):\n            previous_date_params[param_name] = param_value - datetime.timedelta(minutes=1)\n        elif isinstance(param_obj, parameter.DateHourParameter):\n            previous_date_params[param_name] = param_value - datetime.timedelta(hours=1)\n        elif isinstance(param_obj, parameter.DateIntervalParameter):\n            previous_date_params[param_name] = param_value.prev()\n        else:\n            previous_params[param_name] = param_value\n\n    previous_params.update(previous_date_params)\n\n    if len(previous_date_params) == 0:\n        raise NotImplementedError(\"No task parameter - can't determine previous task\")\n    elif len(previous_date_params) > 1:\n        raise NotImplementedError(\"Too many date-related task parameters - can't determine previous task\")\n    else:\n        return task.clone(**previous_params)",
        "begin_line": 199,
        "end_line": 232,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.util.get_previous_completed#235",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util",
        "signature": "luigi.util.get_previous_completed(task, max_steps=10)",
        "snippet": "def get_previous_completed(task, max_steps=10):\n    prev = task\n    for _ in xrange(max_steps):\n        prev = previous(prev)\n        logger.debug(\"Checking if %s is complete\", prev)\n        if prev.complete():\n            return prev\n    return None",
        "begin_line": 235,
        "end_line": 242,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.pyspark_runner.PySparkRunner.__init__#41",
        "src_path": "luigi/contrib/pyspark_runner.py",
        "class_name": "luigi.contrib.pyspark_runner.PySparkRunner",
        "signature": "luigi.contrib.pyspark_runner.PySparkRunner.__init__(self, job, *args)",
        "snippet": "    def __init__(self, job, *args):\n        with open(job, \"rb\") as fd:\n            self.job = pickle.load(fd)\n        self.args = args",
        "begin_line": 41,
        "end_line": 44,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.pyspark_runner.PySparkRunner.run#46",
        "src_path": "luigi/contrib/pyspark_runner.py",
        "class_name": "luigi.contrib.pyspark_runner.PySparkRunner",
        "signature": "luigi.contrib.pyspark_runner.PySparkRunner.run(self)",
        "snippet": "    def run(self):\n        from pyspark import SparkContext, SparkConf\n        conf = SparkConf()\n        self.job.setup(conf)\n        with SparkContext(conf=conf) as sc:\n            self.job.setup_remote(sc)\n            self.job.main(sc, *self.args)",
        "begin_line": 46,
        "end_line": 52,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.execution_summary._partition_tasks#35",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._partition_tasks(worker)",
        "snippet": "def _partition_tasks(worker):\n    \"\"\"\n    Takes a worker and sorts out tasks based on their status.\n    Still_pending_not_ext is only used to get upstream_failure, upstream_missing_dependency and run_by_other_worker\n    \"\"\"\n    task_history = worker._add_task_history\n    pending_tasks = {task for(task, status, ext) in task_history if status == 'PENDING'}\n    set_tasks = {}\n    set_tasks[\"completed\"] = {task for (task, status, ext) in task_history if status == 'DONE' and task in pending_tasks}\n    set_tasks[\"already_done\"] = {task for (task, status, ext) in task_history\n                                 if status == 'DONE' and task not in pending_tasks and task not in set_tasks[\"completed\"]}\n    set_tasks[\"failed\"] = {task for (task, status, ext) in task_history if status == 'FAILED'}\n    set_tasks[\"still_pending_ext\"] = {task for (task, status, ext) in task_history\n                                      if status == 'PENDING' and task not in set_tasks[\"failed\"] and task not in set_tasks[\"completed\"] and not ext}\n    set_tasks[\"still_pending_not_ext\"] = {task for (task, status, ext) in task_history\n                                          if status == 'PENDING' and task not in set_tasks[\"failed\"] and task not in set_tasks[\"completed\"] and ext}\n    set_tasks[\"run_by_other_worker\"] = set()\n    set_tasks[\"upstream_failure\"] = set()\n    set_tasks[\"upstream_missing_dependency\"] = set()\n    set_tasks[\"upstream_run_by_other_worker\"] = set()\n    set_tasks[\"unknown_reason\"] = set()\n    return set_tasks",
        "begin_line": 35,
        "end_line": 56,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008613264427217916,
            "pseudo_dstar_susp": 0.000946969696969697,
            "pseudo_tarantula_susp": 0.0008064516129032258,
            "pseudo_op2_susp": 0.000946969696969697,
            "pseudo_barinel_susp": 0.0008064516129032258
        }
    },
    {
        "name": "luigi.execution_summary._populate_unknown_statuses#59",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._populate_unknown_statuses(set_tasks)",
        "snippet": "def _populate_unknown_statuses(set_tasks):\n    \"\"\"\n    Add the \"upstream_*\" and \"unknown_reason\" statuses my mutating set_tasks.\n    \"\"\"\n    visited = set()\n    for task in set_tasks[\"still_pending_not_ext\"]:\n        _depth_first_search(set_tasks, task, visited)",
        "begin_line": 59,
        "end_line": 65,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000757002271006813,
            "pseudo_dstar_susp": 0.000757002271006813,
            "pseudo_tarantula_susp": 0.0007616146230007616,
            "pseudo_op2_susp": 0.000757002271006813,
            "pseudo_barinel_susp": 0.0007616146230007616
        }
    },
    {
        "name": "luigi.execution_summary._depth_first_search#68",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._depth_first_search(set_tasks, current_task, visited)",
        "snippet": "def _depth_first_search(set_tasks, current_task, visited):\n    \"\"\"\n    This dfs checks why tasks are still pending.\n    \"\"\"\n    visited.add(current_task)\n    if current_task in set_tasks[\"still_pending_not_ext\"]:\n        upstream_failure = False\n        upstream_missing_dependency = False\n        upstream_run_by_other_worker = False\n        for task in current_task._requires():\n            if task not in visited:\n                _depth_first_search(set_tasks, task, visited)\n            if task in set_tasks[\"failed\"] or task in set_tasks[\"upstream_failure\"]:\n                set_tasks[\"upstream_failure\"].add(current_task)\n                upstream_failure = True\n            if task in set_tasks[\"still_pending_ext\"] or task in set_tasks[\"upstream_missing_dependency\"]:\n                set_tasks[\"upstream_missing_dependency\"].add(current_task)\n                upstream_missing_dependency = True\n            if task in set_tasks[\"run_by_other_worker\"] or task in set_tasks[\"upstream_run_by_other_worker\"]:\n                set_tasks[\"upstream_run_by_other_worker\"].add(current_task)\n                upstream_run_by_other_worker = True\n        if not upstream_failure and not upstream_missing_dependency and \\\n                not upstream_run_by_other_worker and current_task not in set_tasks[\"run_by_other_worker\"]:\n            set_tasks[\"unknown_reason\"].add(current_task)",
        "begin_line": 68,
        "end_line": 91,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.execution_summary._get_str#94",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._get_str(task_dict, extra_indent)",
        "snippet": "def _get_str(task_dict, extra_indent):\n    \"\"\"\n    This returns a string for each status\n    \"\"\"\n    summary_length = execution_summary().summary_length\n\n    lines = []\n    task_names = sorted(task_dict.keys())\n    for task_family in task_names:\n        tasks = task_dict[task_family]\n        tasks = sorted(tasks, key=lambda x: str(x))\n        prefix_size = 8 if extra_indent else 4\n        prefix = ' ' * prefix_size\n\n        line = None\n\n        if summary_length > 0 and len(lines) >= summary_length:\n            line = prefix + \"...\"\n            lines.append(line)\n            break\n        if len(tasks[0].get_params()) == 0:\n            line = prefix + '- {0} {1}()'.format(len(tasks), str(task_family))\n        elif _get_len_of_params(tasks[0]) > 60 or len(str(tasks[0])) > 200 or \\\n                (len(tasks) == 2 and len(tasks[0].get_params()) > 1 and (_get_len_of_params(tasks[0]) > 40 or len(str(tasks[0])) > 100)):\n            \"\"\"\n            This is to make sure that there is no really long task in the output\n            \"\"\"\n            line = prefix + '- {0} {1}(...)'.format(len(tasks), task_family)\n        elif len((tasks[0].get_params())) == 1:\n            attributes = {getattr(task, tasks[0].get_params()[0][0]) for task in tasks}\n            param_class = tasks[0].get_params()[0][1]\n            first, last = _ranging_attributes(attributes, param_class)\n            if first is not None and last is not None and len(attributes) > 3:\n                param_str = '{0}...{1}'.format(param_class.serialize(first), param_class.serialize(last))\n            else:\n                param_str = '{0}'.format(_get_str_one_parameter(tasks))\n            line = prefix + '- {0} {1}({2}={3})'.format(len(tasks), task_family, tasks[0].get_params()[0][0], param_str)\n        else:\n            ranging = False\n            params = _get_set_of_params(tasks)\n            unique_param_keys = list(_get_unique_param_keys(params))\n            if len(unique_param_keys) == 1:\n                unique_param, = unique_param_keys\n                attributes = params[unique_param]\n                param_class = unique_param[1]\n                first, last = _ranging_attributes(attributes, param_class)\n                if first is not None and last is not None and len(attributes) > 2:\n                    ranging = True\n                    line = prefix + '- {0} {1}({2}'.format(len(tasks), task_family, _get_str_ranging_multiple_parameters(first, last, tasks, unique_param))\n            if not ranging:\n                if len(tasks) == 1:\n                    line = prefix + '- {0} {1}'.format(len(tasks), tasks[0])\n                if len(tasks) == 2:\n                    line = prefix + '- {0} {1} and {2}'.format(len(tasks), tasks[0], tasks[1])\n                if len(tasks) > 2:\n                    line = prefix + '- {0} {1} ...'.format(len(tasks), tasks[0])\n        lines.append(line)\n    return '\\n'.join(lines)",
        "begin_line": 94,
        "end_line": 151,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001392757660167131,
            "pseudo_dstar_susp": 0.0009514747859181732,
            "pseudo_tarantula_susp": 0.00398406374501992,
            "pseudo_op2_susp": 0.0009514747859181732,
            "pseudo_barinel_susp": 0.00398406374501992
        }
    },
    {
        "name": "luigi.execution_summary._get_len_of_params#154",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._get_len_of_params(task)",
        "snippet": "def _get_len_of_params(task):\n    return sum(len(param[0]) for param in task.get_params())",
        "begin_line": 154,
        "end_line": 155,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009124087591240876,
            "pseudo_dstar_susp": 0.0009871668311944718,
            "pseudo_tarantula_susp": 0.0010030090270812437,
            "pseudo_op2_susp": 0.0009871668311944718,
            "pseudo_barinel_susp": 0.0010030090270812437
        }
    },
    {
        "name": "luigi.execution_summary._get_str_ranging_multiple_parameters#158",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._get_str_ranging_multiple_parameters(first, last, tasks, unique_param)",
        "snippet": "def _get_str_ranging_multiple_parameters(first, last, tasks, unique_param):\n    row = ''\n    str_unique_param = '{0}...{1}'.format(unique_param[1].serialize(first), unique_param[1].serialize(last))\n    for param in tasks[0].get_params():\n        row += '{0}='.format(param[0])\n        if param[0] == unique_param[0]:\n            row += '{0}'.format(str_unique_param)\n        else:\n            row += '{0}'.format(param[1].serialize(getattr(tasks[0], param[0])))\n        if param != tasks[0].get_params()[-1]:\n            row += \", \"\n    row += ')'\n    return row",
        "begin_line": 158,
        "end_line": 170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.execution_summary._get_set_of_params#173",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._get_set_of_params(tasks)",
        "snippet": "def _get_set_of_params(tasks):\n    params = {}\n    for param in tasks[0].get_params():\n        params[param] = {getattr(task, param[0]) for task in tasks}\n    return params",
        "begin_line": 173,
        "end_line": 177,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015772870662460567,
            "pseudo_dstar_susp": 0.0010570824524312897,
            "pseudo_tarantula_susp": 0.0026041666666666665,
            "pseudo_op2_susp": 0.0010570824524312897,
            "pseudo_barinel_susp": 0.0026041666666666665
        }
    },
    {
        "name": "luigi.execution_summary._get_unique_param_keys#180",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._get_unique_param_keys(params)",
        "snippet": "def _get_unique_param_keys(params):\n    for param_key, param_values in params.items():\n        if len(param_values) > 1:\n            yield param_key",
        "begin_line": 180,
        "end_line": 183,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010183299389002036,
            "pseudo_dstar_susp": 0.0008952551477170994,
            "pseudo_tarantula_susp": 0.0026041666666666665,
            "pseudo_op2_susp": 0.0008952551477170994,
            "pseudo_barinel_susp": 0.0026041666666666665
        }
    },
    {
        "name": "luigi.execution_summary._ranging_attributes#186",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._ranging_attributes(attributes, param_class)",
        "snippet": "def _ranging_attributes(attributes, param_class):\n    \"\"\"\n    Checks if there is a continuous range\n    \"\"\"\n    next_attributes = {param_class.next_in_enumeration(attribute) for attribute in attributes}\n    in_first = attributes.difference(next_attributes)\n    in_second = next_attributes.difference(attributes)\n    if len(in_first) == 1 and len(in_second) == 1:\n        for x in attributes:\n            if {param_class.next_in_enumeration(x)} == in_second:\n                return next(iter(in_first)), x\n    return None, None",
        "begin_line": 186,
        "end_line": 197,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002573340195573855,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.execution_summary._get_str_one_parameter#200",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._get_str_one_parameter(tasks)",
        "snippet": "def _get_str_one_parameter(tasks):\n    row = ''\n    count = 0\n    for task in tasks:\n        if (len(row) >= 30 and count > 2 and count != len(tasks) - 1) or len(row) > 200:\n            row += '...'\n            break\n        param = task.get_params()[0]\n        row += '{0}'.format(param[1].serialize(getattr(task, param[0])))\n        if count < len(tasks) - 1:\n            row += ','\n        count += 1\n    return row",
        "begin_line": 200,
        "end_line": 212,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00031575623618566466,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.execution_summary._get_number_of_tasks_for#219",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._get_number_of_tasks_for(status, group_tasks)",
        "snippet": "def _get_number_of_tasks_for(status, group_tasks):\n    if status == \"still_pending\":\n        return (_get_number_of_tasks(group_tasks[\"still_pending_ext\"]) +\n                _get_number_of_tasks(group_tasks[\"still_pending_not_ext\"]))\n    return _get_number_of_tasks(group_tasks[status])",
        "begin_line": 219,
        "end_line": 223,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00078125,
            "pseudo_dstar_susp": 0.00078125,
            "pseudo_tarantula_susp": 0.0007886435331230284,
            "pseudo_op2_susp": 0.00078125,
            "pseudo_barinel_susp": 0.0007886435331230284
        }
    },
    {
        "name": "luigi.execution_summary._get_number_of_tasks#226",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._get_number_of_tasks(task_dict)",
        "snippet": "def _get_number_of_tasks(task_dict):\n    return sum(len(tasks) for tasks in task_dict.values())",
        "begin_line": 226,
        "end_line": 227,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000864304235090752,
            "pseudo_dstar_susp": 0.0009505703422053232,
            "pseudo_tarantula_susp": 0.0007886435331230284,
            "pseudo_op2_susp": 0.0009505703422053232,
            "pseudo_barinel_susp": 0.0007886435331230284
        }
    },
    {
        "name": "luigi.execution_summary._get_comments#230",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._get_comments(group_tasks)",
        "snippet": "def _get_comments(group_tasks):\n    \"\"\"\n    Get the human readable comments and quantities for the task types.\n    \"\"\"\n    comments = {}\n    for status, human in _COMMENTS:\n        num_tasks = _get_number_of_tasks_for(status, group_tasks)\n        if num_tasks:\n            space = \"    \" if status in _PENDING_SUB_STATUSES else \"\"\n            comments[status] = '{space}* {num_tasks} {human}:\\n'.format(\n                space=space,\n                num_tasks=num_tasks,\n                human=human)\n    return comments",
        "begin_line": 230,
        "end_line": 243,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008084074373484236,
            "pseudo_dstar_susp": 0.0008084074373484236,
            "pseudo_tarantula_susp": 0.0008169934640522876,
            "pseudo_op2_susp": 0.0008084074373484236,
            "pseudo_barinel_susp": 0.0008169934640522876
        }
    },
    {
        "name": "luigi.execution_summary._get_run_by_other_worker#274",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._get_run_by_other_worker(worker)",
        "snippet": "def _get_run_by_other_worker(worker):\n    \"\"\"\n    This returns a set of the tasks that are being run by other worker\n    \"\"\"\n    task_sets = _get_external_workers(worker).values()\n    return functools.reduce(lambda a, b: a | b, task_sets, set())",
        "begin_line": 274,
        "end_line": 279,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000757002271006813,
            "pseudo_dstar_susp": 0.000757002271006813,
            "pseudo_tarantula_susp": 0.0007616146230007616,
            "pseudo_op2_susp": 0.000757002271006813,
            "pseudo_barinel_susp": 0.0007616146230007616
        }
    },
    {
        "name": "luigi.execution_summary._get_external_workers#282",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._get_external_workers(worker)",
        "snippet": "def _get_external_workers(worker):\n    \"\"\"\n    This returns a dict with a set of tasks for all of the other workers\n    \"\"\"\n    worker_that_blocked_task = collections.defaultdict(set)\n    get_work_response_history = worker._get_work_response_history\n    for get_work_response in get_work_response_history:\n        if get_work_response['task_id'] is None:\n            for running_task in get_work_response['running_tasks']:\n                other_worker_id = running_task['worker']\n                other_task_id = running_task['task_id']\n                other_task = worker._scheduled_tasks.get(other_task_id)\n                if other_worker_id == worker._id or not other_task:\n                    continue\n                worker_that_blocked_task[other_worker_id].add(other_task)\n    return worker_that_blocked_task",
        "begin_line": 282,
        "end_line": 297,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007961783439490446,
            "pseudo_dstar_susp": 0.0007961783439490446,
            "pseudo_tarantula_susp": 0.0008045052292839903,
            "pseudo_op2_susp": 0.0007961783439490446,
            "pseudo_barinel_susp": 0.0008045052292839903
        }
    },
    {
        "name": "luigi.execution_summary._group_tasks_by_name_and_status#300",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._group_tasks_by_name_and_status(task_dict)",
        "snippet": "def _group_tasks_by_name_and_status(task_dict):\n    \"\"\"\n    Takes a dictionary with sets of tasks grouped by their status and\n    returns a dictionary with dictionaries with an array of tasks grouped by\n    their status and task name\n    \"\"\"\n    group_status = {}\n    for task in task_dict:\n        if task.task_family not in group_status:\n            group_status[task.task_family] = []\n        group_status[task.task_family].append(task)\n    return group_status",
        "begin_line": 300,
        "end_line": 311,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008084074373484236,
            "pseudo_dstar_susp": 0.0008084074373484236,
            "pseudo_tarantula_susp": 0.0008169934640522876,
            "pseudo_op2_susp": 0.0008084074373484236,
            "pseudo_barinel_susp": 0.0008169934640522876
        }
    },
    {
        "name": "luigi.execution_summary._summary_dict#314",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._summary_dict(worker)",
        "snippet": "def _summary_dict(worker):\n    set_tasks = _partition_tasks(worker)\n    set_tasks[\"run_by_other_worker\"] = _get_run_by_other_worker(worker)\n    _populate_unknown_statuses(set_tasks)\n    return set_tasks",
        "begin_line": 314,
        "end_line": 318,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000757002271006813,
            "pseudo_dstar_susp": 0.000757002271006813,
            "pseudo_tarantula_susp": 0.0007616146230007616,
            "pseudo_op2_susp": 0.000757002271006813,
            "pseudo_barinel_susp": 0.0007616146230007616
        }
    },
    {
        "name": "luigi.execution_summary._summary_format#321",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._summary_format(set_tasks, worker)",
        "snippet": "def _summary_format(set_tasks, worker):\n    group_tasks = {}\n    for status, task_dict in set_tasks.items():\n        group_tasks[status] = _group_tasks_by_name_and_status(task_dict)\n    comments = _get_comments(group_tasks)\n    num_all_tasks = sum([len(set_tasks[\"already_done\"]),\n                         len(set_tasks[\"completed\"]), len(set_tasks[\"failed\"]),\n                         len(set_tasks[\"still_pending_ext\"]),\n                         len(set_tasks[\"still_pending_not_ext\"])])\n    str_output = ''\n    str_output += 'Scheduled {0} tasks of which:\\n'.format(num_all_tasks)\n    for status in _ORDERED_STATUSES:\n        if status not in comments:\n            continue\n        str_output += '{0}'.format(comments[status])\n        if status != 'still_pending':\n            str_output += '{0}\\n'.format(_get_str(group_tasks[status], status in _PENDING_SUB_STATUSES))\n    ext_workers = _get_external_workers(worker)\n    group_tasks_ext_workers = {}\n    for ext_worker, task_dict in ext_workers.items():\n        group_tasks_ext_workers[ext_worker] = _group_tasks_by_name_and_status(task_dict)\n    if len(ext_workers) > 0:\n        str_output += \"\\nThe other workers were:\\n\"\n        count = 0\n        for ext_worker, task_dict in ext_workers.items():\n            if count > 3 and count < len(ext_workers) - 1:\n                str_output += \"    and {0} other workers\".format(len(ext_workers) - count)\n                break\n            str_output += \"    - {0} ran {1} tasks\\n\".format(ext_worker, len(task_dict))\n            count += 1\n        str_output += '\\n'\n    if num_all_tasks == len(set_tasks[\"already_done\"]) + len(set_tasks[\"still_pending_ext\"]) + len(set_tasks[\"still_pending_not_ext\"]):\n        if len(ext_workers) == 0:\n            str_output += '\\n'\n        str_output += 'Did not run any tasks'\n    smiley = \"\"\n    reason = \"\"\n    if set_tasks[\"failed\"]:\n        smiley = \":(\"\n        reason = \"there were failed tasks\"\n    elif set_tasks[\"still_pending_ext\"]:\n        smiley = \":|\"\n        reason = \"there were missing external dependencies\"\n    else:\n        smiley = \":)\"\n        reason = \"there were no failed tasks or missing external dependencies\"\n    str_output += \"\\nThis progress looks {0} because {1}\".format(smiley, reason)\n    if num_all_tasks == 0:\n        str_output = 'Did not schedule any tasks'\n    return str_output",
        "begin_line": 321,
        "end_line": 370,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001455604075691412,
            "pseudo_dstar_susp": 0.0009107468123861566,
            "pseudo_tarantula_susp": 0.004545454545454545,
            "pseudo_op2_susp": 0.0009107468123861566,
            "pseudo_barinel_susp": 0.004545454545454545
        }
    },
    {
        "name": "luigi.execution_summary._summary_wrap#373",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary._summary_wrap(str_output)",
        "snippet": "def _summary_wrap(str_output):\n    return textwrap.dedent(\"\"\"\n    ===== Luigi Execution Summary =====\n\n    {str_output}\n\n    ===== Luigi Execution Summary =====\n    \"\"\").format(str_output=str_output)",
        "begin_line": 373,
        "end_line": 380,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00078125,
            "pseudo_dstar_susp": 0.00078125,
            "pseudo_tarantula_susp": 0.0007886435331230284,
            "pseudo_op2_susp": 0.00078125,
            "pseudo_barinel_susp": 0.0007886435331230284
        }
    },
    {
        "name": "luigi.execution_summary.summary#383",
        "src_path": "luigi/execution_summary.py",
        "class_name": "luigi.execution_summary",
        "signature": "luigi.execution_summary.summary(worker)",
        "snippet": "def summary(worker):\n    \"\"\"\n    Given a worker, return a human readable summary of what the worker have\n    done.\n    \"\"\"\n    return _summary_wrap(_summary_format(_summary_dict(worker), worker))",
        "begin_line": 383,
        "end_line": 388,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00078125,
            "pseudo_dstar_susp": 0.00078125,
            "pseudo_tarantula_susp": 0.0007886435331230284,
            "pseudo_op2_susp": 0.00078125,
            "pseudo_barinel_susp": 0.0007886435331230284
        }
    },
    {
        "name": "luigi.contrib.hdfs.config.load_hadoop_cmd#63",
        "src_path": "luigi/contrib/hdfs/config.py",
        "class_name": "luigi.contrib.hdfs.config",
        "signature": "luigi.contrib.hdfs.config.load_hadoop_cmd()",
        "snippet": "def load_hadoop_cmd():\n    return hadoopcli().command.split()",
        "begin_line": 63,
        "end_line": 64,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00032754667540124465,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.ssh.RemoteCalledProcessError.__init__#56",
        "src_path": "luigi/contrib/ssh.py",
        "class_name": "luigi.contrib.ssh.RemoteCalledProcessError",
        "signature": "luigi.contrib.ssh.RemoteCalledProcessError.__init__(self, returncode, command, host, output=None)",
        "snippet": "    def __init__(self, returncode, command, host, output=None):\n        super(RemoteCalledProcessError, self).__init__(returncode, command, output)\n        self.host = host",
        "begin_line": 56,
        "end_line": 58,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.ssh.RemoteContext.__init__#67",
        "src_path": "luigi/contrib/ssh.py",
        "class_name": "luigi.contrib.ssh.RemoteContext",
        "signature": "luigi.contrib.ssh.RemoteContext.__init__(self, host, **kwargs)",
        "snippet": "    def __init__(self, host, **kwargs):\n        self.host = host\n        self.username = kwargs.get('username', None)\n        self.key_file = kwargs.get('key_file', None)\n        self.connect_timeout = kwargs.get('connect_timeout', None)\n        self.port = kwargs.get('port', None)\n        self.no_host_key_check = kwargs.get('no_host_key_check', False)\n        self.sshpass = kwargs.get('sshpass', False)\n        self.tty = kwargs.get('tty', False)",
        "begin_line": 67,
        "end_line": 75,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.ssh.RemoteContext._host_ref#87",
        "src_path": "luigi/contrib/ssh.py",
        "class_name": "luigi.contrib.ssh.RemoteContext",
        "signature": "luigi.contrib.ssh.RemoteContext._host_ref(self)",
        "snippet": "    def _host_ref(self):\n        if self.username:\n            return \"{0}@{1}\".format(self.username, self.host)\n        else:\n            return self.host",
        "begin_line": 87,
        "end_line": 91,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.ssh.RemoteContext._prepare_cmd#93",
        "src_path": "luigi/contrib/ssh.py",
        "class_name": "luigi.contrib.ssh.RemoteContext",
        "signature": "luigi.contrib.ssh.RemoteContext._prepare_cmd(self, cmd)",
        "snippet": "    def _prepare_cmd(self, cmd):\n        connection_cmd = [\"ssh\", self._host_ref(), \"-o\", \"ControlMaster=no\"]\n        if self.sshpass:\n            connection_cmd = [\"sshpass\", \"-e\"] + connection_cmd\n        else:\n            connection_cmd += [\"-o\", \"BatchMode=yes\"]  # no password prompts etc\n        if self.port:\n            connection_cmd.extend([\"-p\", self.port])\n\n        if self.connect_timeout is not None:\n            connection_cmd += ['-o', 'ConnectTimeout=%d' % self.connect_timeout]\n\n        if self.no_host_key_check:\n            connection_cmd += ['-o', 'UserKnownHostsFile=/dev/null',\n                               '-o', 'StrictHostKeyChecking=no']\n\n        if self.key_file:\n            connection_cmd.extend([\"-i\", self.key_file])\n\n        if self.tty:\n            connection_cmd.append('-t')\n        return connection_cmd + cmd",
        "begin_line": 93,
        "end_line": 114,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.ssh.RemoteContext.Popen#116",
        "src_path": "luigi/contrib/ssh.py",
        "class_name": "luigi.contrib.ssh.RemoteContext",
        "signature": "luigi.contrib.ssh.RemoteContext.Popen(self, cmd, **kwargs)",
        "snippet": "    def Popen(self, cmd, **kwargs):\n        \"\"\"\n        Remote Popen.\n        \"\"\"\n        prefixed_cmd = self._prepare_cmd(cmd)\n        return subprocess.Popen(prefixed_cmd, **kwargs)",
        "begin_line": 116,
        "end_line": 121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.ssh.RemoteContext.check_output#123",
        "src_path": "luigi/contrib/ssh.py",
        "class_name": "luigi.contrib.ssh.RemoteContext",
        "signature": "luigi.contrib.ssh.RemoteContext.check_output(self, cmd)",
        "snippet": "    def check_output(self, cmd):\n        \"\"\"\n        Execute a shell command remotely and return the output.\n\n        Simplified version of Popen when you only want the output as a string and detect any errors.\n        \"\"\"\n        p = self.Popen(cmd, stdout=subprocess.PIPE)\n        output, _ = p.communicate()\n        if p.returncode != 0:\n            raise RemoteCalledProcessError(p.returncode, cmd, self.host, output=output)\n        return output",
        "begin_line": 123,
        "end_line": 133,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "dummy_test_module.not_imported.UnimportedTask.complete#5",
        "src_path": "dummy_test_module/not_imported.py",
        "class_name": "dummy_test_module.not_imported.UnimportedTask",
        "signature": "dummy_test_module.not_imported.UnimportedTask.complete(self)",
        "snippet": "    def complete(self):\n        return False",
        "begin_line": 5,
        "end_line": 6,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.rdbms.CopyToTable.update_id#99",
        "src_path": "luigi/contrib/rdbms.py",
        "class_name": "luigi.contrib.rdbms.CopyToTable",
        "signature": "luigi.contrib.rdbms.CopyToTable.update_id(self)",
        "snippet": "    def update_id(self):\n        \"\"\"\n        This update id will be a unique identifier for this insert on this table.\n        \"\"\"\n        return self.task_id",
        "begin_line": 99,
        "end_line": 103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.rdbms.Query.update_id#193",
        "src_path": "luigi/contrib/rdbms.py",
        "class_name": "luigi.contrib.rdbms.Query",
        "signature": "luigi.contrib.rdbms.Query.update_id(self)",
        "snippet": "    def update_id(self):\n        \"\"\"\n        Override to create a custom marker table 'update_id' signature for Query subclass task instances\n        \"\"\"\n        return self.task_id",
        "begin_line": 193,
        "end_line": 197,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.simulate.RunAnywayTarget.__init__#63",
        "src_path": "luigi/contrib/simulate.py",
        "class_name": "luigi.contrib.simulate.RunAnywayTarget",
        "signature": "luigi.contrib.simulate.RunAnywayTarget.__init__(self, task_obj)",
        "snippet": "    def __init__(self, task_obj):\n        self.task_id = task_obj.task_id\n\n        if self.unique.value == 0:\n            with self.unique.get_lock():\n                if self.unique.value == 0:\n                    self.unique.value = os.getpid()  # The PID will be unique for every execution of the pipeline\n\n        # Deleting old files > temp_time\n        if os.path.isdir(self.temp_dir):\n            import shutil\n            import time\n            limit = time.time() - self.temp_time\n            for fn in os.listdir(self.temp_dir):\n                path = os.path.join(self.temp_dir, fn)\n                if os.path.isdir(path) and os.stat(path).st_mtime < limit:\n                    shutil.rmtree(path)\n                    logger.debug('Deleted temporary directory %s', path)",
        "begin_line": 63,
        "end_line": 80,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.simulate.RunAnywayTarget.get_path#82",
        "src_path": "luigi/contrib/simulate.py",
        "class_name": "luigi.contrib.simulate.RunAnywayTarget",
        "signature": "luigi.contrib.simulate.RunAnywayTarget.get_path(self)",
        "snippet": "    def get_path(self):\n        \"\"\"\n        Returns a temporary file path based on a MD5 hash generated with the task's name and its arguments\n        \"\"\"\n        md5_hash = hashlib.md5(self.task_id.encode()).hexdigest()\n        logger.debug('Hash %s corresponds to task %s', md5_hash, self.task_id)\n\n        return os.path.join(self.temp_dir, str(self.unique.value), md5_hash)",
        "begin_line": 82,
        "end_line": 89,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.simulate.RunAnywayTarget.exists#91",
        "src_path": "luigi/contrib/simulate.py",
        "class_name": "luigi.contrib.simulate.RunAnywayTarget",
        "signature": "luigi.contrib.simulate.RunAnywayTarget.exists(self)",
        "snippet": "    def exists(self):\n        \"\"\"\n        Checks if the file exists\n        \"\"\"\n        return os.path.isfile(self.get_path())",
        "begin_line": 91,
        "end_line": 95,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.simulate.RunAnywayTarget.done#97",
        "src_path": "luigi/contrib/simulate.py",
        "class_name": "luigi.contrib.simulate.RunAnywayTarget",
        "signature": "luigi.contrib.simulate.RunAnywayTarget.done(self)",
        "snippet": "    def done(self):\n        \"\"\"\n        Creates temporary file to mark the task as `done`\n        \"\"\"\n        logger.info('Marking %s as done', self)\n\n        fn = self.get_path()\n        os.makedirs(os.path.dirname(fn), exist_ok=True)\n        open(fn, 'w').close()",
        "begin_line": 97,
        "end_line": 105,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.interface.setup_interface_logging#43",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface.setup_interface_logging(conf_file=None)",
        "snippet": "def setup_interface_logging(conf_file=None):\n    # use a variable in the function object to determine if it has run before\n    if getattr(setup_interface_logging, \"has_run\", False):\n        return\n\n    if conf_file is None:\n        logger = logging.getLogger('luigi-interface')\n        logger.setLevel(logging.DEBUG)\n\n        stream_handler = logging.StreamHandler()\n        stream_handler.setLevel(logging.DEBUG)\n\n        formatter = logging.Formatter('%(levelname)s: %(message)s')\n        stream_handler.setFormatter(formatter)\n\n        logger.addHandler(stream_handler)\n    else:\n        logging.config.fileConfig(conf_file, disable_existing_loggers=False)\n\n    setup_interface_logging.has_run = True",
        "begin_line": 43,
        "end_line": 62,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008312551953449709,
            "pseudo_dstar_susp": 0.0008312551953449709,
            "pseudo_tarantula_susp": 0.0008481764206955047,
            "pseudo_op2_susp": 0.0008312551953449709,
            "pseudo_barinel_susp": 0.0008481764206955047
        }
    },
    {
        "name": "luigi.interface._WorkerSchedulerFactory.create_local_scheduler#133",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface._WorkerSchedulerFactory",
        "signature": "luigi.interface._WorkerSchedulerFactory.create_local_scheduler(self)",
        "snippet": "    def create_local_scheduler(self):\n        return scheduler.CentralPlannerScheduler(prune_on_get_work=True, record_task_history=False)",
        "begin_line": 133,
        "end_line": 134,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008453085376162299,
            "pseudo_dstar_susp": 0.0008453085376162299,
            "pseudo_tarantula_susp": 0.0008628127696289905,
            "pseudo_op2_susp": 0.0008453085376162299,
            "pseudo_barinel_susp": 0.0008628127696289905
        }
    },
    {
        "name": "luigi.interface._WorkerSchedulerFactory.create_remote_scheduler#136",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface._WorkerSchedulerFactory",
        "signature": "luigi.interface._WorkerSchedulerFactory.create_remote_scheduler(self, url)",
        "snippet": "    def create_remote_scheduler(self, url):\n        return rpc.RemoteScheduler(url)",
        "begin_line": 136,
        "end_line": 137,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002725538293813028,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.interface._WorkerSchedulerFactory.create_worker#139",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface._WorkerSchedulerFactory",
        "signature": "luigi.interface._WorkerSchedulerFactory.create_worker(self, scheduler, worker_processes, assistant=False)",
        "snippet": "    def create_worker(self, scheduler, worker_processes, assistant=False):\n        return worker.Worker(\n            scheduler=scheduler, worker_processes=worker_processes, assistant=assistant)",
        "begin_line": 139,
        "end_line": 141,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008368200836820083,
            "pseudo_dstar_susp": 0.0008368200836820083,
            "pseudo_tarantula_susp": 0.0008539709649871904,
            "pseudo_op2_susp": 0.0008368200836820083,
            "pseudo_barinel_susp": 0.0008539709649871904
        }
    },
    {
        "name": "luigi.interface._schedule_and_run#144",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface._schedule_and_run(tasks, worker_scheduler_factory=None, override_defaults=None)",
        "snippet": "def _schedule_and_run(tasks, worker_scheduler_factory=None, override_defaults=None):\n    \"\"\"\n    :param tasks:\n    :param worker_scheduler_factory:\n    :param override_defaults:\n    :return: True if all tasks and their dependencies were successfully run (or already completed);\n             False if any error occurred.\n    \"\"\"\n\n    if worker_scheduler_factory is None:\n        worker_scheduler_factory = _WorkerSchedulerFactory()\n    if override_defaults is None:\n        override_defaults = {}\n    env_params = core(**override_defaults)\n    # search for logging configuration path first on the command line, then\n    # in the application config file\n    logging_conf = env_params.logging_conf_file\n    if logging_conf is not None and not os.path.exists(logging_conf):\n        raise Exception(\n            \"Error: Unable to locate specified logging configuration file!\"\n        )\n\n    if not configuration.get_config().getboolean(\n            'core', 'no_configure_logging', False):\n        setup_interface_logging(logging_conf)\n\n    kill_signal = signal.SIGUSR1 if env_params.take_lock else None\n    if (not env_params.no_lock and\n            not(lock.acquire_for(env_params.lock_pid_dir, env_params.lock_size, kill_signal))):\n        raise PidLockAlreadyTakenExit()\n\n    if env_params.local_scheduler:\n        sch = worker_scheduler_factory.create_local_scheduler()\n    else:\n        if env_params.scheduler_url is not None:\n            url = env_params.scheduler_url\n        else:\n            url = 'http://{host}:{port:d}/'.format(\n                host=env_params.scheduler_host,\n                port=env_params.scheduler_port,\n            )\n        sch = worker_scheduler_factory.create_remote_scheduler(url=url)\n\n    worker = worker_scheduler_factory.create_worker(\n        scheduler=sch, worker_processes=env_params.workers, assistant=env_params.assistant)\n\n    success = True\n    logger = logging.getLogger('luigi-interface')\n    with worker:\n        for t in tasks:\n            success &= worker.add(t, env_params.parallel_scheduling)\n        logger.info('Done scheduling tasks')\n        if env_params.workers != 0:\n            success &= worker.run()\n    logger.info(execution_summary.summary(worker))\n    return dict(success=success, worker=worker)",
        "begin_line": 144,
        "end_line": 199,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009115770282588879,
            "pseudo_dstar_susp": 0.0008710801393728223,
            "pseudo_tarantula_susp": 0.002070393374741201,
            "pseudo_op2_susp": 0.0008710801393728223,
            "pseudo_barinel_susp": 0.002070393374741201
        }
    },
    {
        "name": "luigi.interface.run#209",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface.run(*args, **kwargs)",
        "snippet": "def run(*args, **kwargs):\n    return _run(*args, **kwargs)['success']",
        "begin_line": 209,
        "end_line": 210,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0019723865877712033,
            "pseudo_dstar_susp": 0.001072961373390558,
            "pseudo_tarantula_susp": 0.0031847133757961785,
            "pseudo_op2_susp": 0.001072961373390558,
            "pseudo_barinel_susp": 0.0031847133757961785
        }
    },
    {
        "name": "luigi.interface._run#213",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface._run(cmdline_args=None, main_task_cls=None, worker_scheduler_factory=None, use_dynamic_argparse=None, local_scheduler=False)",
        "snippet": "def _run(cmdline_args=None, main_task_cls=None,\n         worker_scheduler_factory=None, use_dynamic_argparse=None, local_scheduler=False):\n    \"\"\"\n    Please dont use. Instead use `luigi` binary.\n\n    Run from cmdline using argparse.\n\n    :param cmdline_args:\n    :param main_task_cls:\n    :param worker_scheduler_factory:\n    :param use_dynamic_argparse: Deprecated and ignored\n    :param local_scheduler:\n    \"\"\"\n    if use_dynamic_argparse is not None:\n        warnings.warn(\"use_dynamic_argparse is deprecated, don't set it.\",\n                      DeprecationWarning, stacklevel=2)\n    if cmdline_args is None:\n        cmdline_args = sys.argv[1:]\n\n    if main_task_cls:\n        cmdline_args.insert(0, main_task_cls.task_family)\n    if local_scheduler:\n        cmdline_args.insert(0, '--local-scheduler')\n\n    with CmdlineParser.global_instance(cmdline_args) as cp:\n        return _schedule_and_run([cp.get_task_obj()], worker_scheduler_factory)",
        "begin_line": 213,
        "end_line": 238,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018248175182481751,
            "pseudo_dstar_susp": 0.0010683760683760685,
            "pseudo_tarantula_susp": 0.002976190476190476,
            "pseudo_op2_susp": 0.0010683760683760685,
            "pseudo_barinel_susp": 0.002976190476190476
        }
    },
    {
        "name": "luigi.interface.build#241",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface.build(tasks, worker_scheduler_factory=None, **env_params)",
        "snippet": "def build(tasks, worker_scheduler_factory=None, **env_params):\n    \"\"\"\n    Run internally, bypassing the cmdline parsing.\n\n    Useful if you have some luigi code that you want to run internally.\n    Example:\n\n    .. code-block:: python\n\n        luigi.build([MyTask1(), MyTask2()], local_scheduler=True)\n\n    One notable difference is that `build` defaults to not using\n    the identical process lock. Otherwise, `build` would only be\n    callable once from each process.\n\n    :param tasks:\n    :param worker_scheduler_factory:\n    :param env_params:\n    :return: True if there were no scheduling errors, even if tasks may fail.\n    \"\"\"\n    if \"no_lock\" not in env_params:\n        env_params[\"no_lock\"] = True\n\n    return _schedule_and_run(tasks, worker_scheduler_factory, override_defaults=env_params)['success']",
        "begin_line": 241,
        "end_line": 264,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002332089552238806,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.file.atomic_file.move_to_final_destination#38",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.atomic_file",
        "signature": "luigi.file.atomic_file.move_to_final_destination(self)",
        "snippet": "    def move_to_final_destination(self):\n        os.rename(self.tmp_path, self.path)",
        "begin_line": 38,
        "end_line": 39,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002457002457002457,
            "pseudo_dstar_susp": 0.002012072434607646,
            "pseudo_tarantula_susp": 0.003125,
            "pseudo_op2_susp": 0.002012072434607646,
            "pseudo_barinel_susp": 0.003125
        }
    },
    {
        "name": "luigi.file.atomic_file.generate_tmp_path#41",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.atomic_file",
        "signature": "luigi.file.atomic_file.generate_tmp_path(self, path)",
        "snippet": "    def generate_tmp_path(self, path):\n        return path + '-luigi-tmp-%09d' % random.randrange(0, 1e10)",
        "begin_line": 41,
        "end_line": 42,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022624434389140274,
            "pseudo_dstar_susp": 0.0019230769230769232,
            "pseudo_tarantula_susp": 0.0027624309392265192,
            "pseudo_op2_susp": 0.0019230769230769232,
            "pseudo_barinel_susp": 0.0027624309392265192
        }
    },
    {
        "name": "luigi.file.LocalFileSystem.exists#52",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalFileSystem",
        "signature": "luigi.file.LocalFileSystem.exists(self, path)",
        "snippet": "    def exists(self, path):\n        return os.path.exists(path)",
        "begin_line": 52,
        "end_line": 53,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024330900243309003,
            "pseudo_dstar_susp": 0.001996007984031936,
            "pseudo_tarantula_susp": 0.0030581039755351682,
            "pseudo_op2_susp": 0.001996007984031936,
            "pseudo_barinel_susp": 0.0030581039755351682
        }
    },
    {
        "name": "luigi.file.LocalFileSystem.mkdir#55",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalFileSystem",
        "signature": "luigi.file.LocalFileSystem.mkdir(self, path, parents=True, raise_if_exists=False)",
        "snippet": "    def mkdir(self, path, parents=True, raise_if_exists=False):\n        if self.exists(path):\n            if raise_if_exists:\n                raise FileAlreadyExists()\n            elif not self.isdir(path):\n                raise NotADirectory()\n            else:\n                return\n\n        if parents:\n            os.makedirs(path)\n        else:\n            if not os.path.exists(os.path.dirname(path)):\n                raise MissingParentDirectory()\n            os.mkdir(path)",
        "begin_line": 55,
        "end_line": 69,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.file.LocalFileSystem.isdir#71",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalFileSystem",
        "signature": "luigi.file.LocalFileSystem.isdir(self, path)",
        "snippet": "    def isdir(self, path):\n        return os.path.isdir(path)",
        "begin_line": 71,
        "end_line": 72,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00026968716289104636,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.file.LocalFileSystem.listdir#74",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalFileSystem",
        "signature": "luigi.file.LocalFileSystem.listdir(self, path)",
        "snippet": "    def listdir(self, path):\n        for dir_, _, files in os.walk(path):\n            assert dir_.startswith(path)\n            for name in files:\n                yield os.path.join(dir_, name)",
        "begin_line": 74,
        "end_line": 78,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.file.LocalFileSystem.remove#80",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalFileSystem",
        "signature": "luigi.file.LocalFileSystem.remove(self, path, recursive=True)",
        "snippet": "    def remove(self, path, recursive=True):\n        if recursive and self.isdir(path):\n            shutil.rmtree(path)\n        else:\n            os.remove(path)",
        "begin_line": 80,
        "end_line": 84,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.file.LocalFileSystem.move#86",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalFileSystem",
        "signature": "luigi.file.LocalFileSystem.move(self, old_path, new_path, raise_if_exists=False)",
        "snippet": "    def move(self, old_path, new_path, raise_if_exists=False):\n        if raise_if_exists and os.path.exists(new_path):\n            raise RuntimeError('Destination exists: %s' % new_path)\n        d = os.path.dirname(new_path)\n        if d and not os.path.exists(d):\n            self.fs.mkdir(d)\n        os.rename(old_path, new_path)",
        "begin_line": 86,
        "end_line": 92,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002842524161455372,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.file.LocalTarget.__init__#98",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalTarget",
        "signature": "luigi.file.LocalTarget.__init__(self, path=None, format=None, is_tmp=False)",
        "snippet": "    def __init__(self, path=None, format=None, is_tmp=False):\n        if format is None:\n            format = get_default_format()\n\n        if not path:\n            if not is_tmp:\n                raise Exception('path or is_tmp must be set')\n            path = os.path.join(tempfile.gettempdir(), 'luigi-tmp-%09d' % random.randint(0, 999999999))\n        super(LocalTarget, self).__init__(path)\n        self.format = format\n        self.is_tmp = is_tmp",
        "begin_line": 98,
        "end_line": 108,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0023923444976076554,
            "pseudo_dstar_susp": 0.001984126984126984,
            "pseudo_tarantula_susp": 0.0030303030303030303,
            "pseudo_op2_susp": 0.001984126984126984,
            "pseudo_barinel_susp": 0.0030303030303030303
        }
    },
    {
        "name": "luigi.file.LocalTarget.makedirs#110",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalTarget",
        "signature": "luigi.file.LocalTarget.makedirs(self)",
        "snippet": "    def makedirs(self):\n        \"\"\"\n        Create all parent folders if they do not exist.\n        \"\"\"\n        normpath = os.path.normpath(self.path)\n        parentfolder = os.path.dirname(normpath)\n        if parentfolder:\n            try:\n                os.makedirs(parentfolder)\n            except OSError:\n                pass",
        "begin_line": 110,
        "end_line": 120,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00234192037470726,
            "pseudo_dstar_susp": 0.0019646365422396855,
            "pseudo_tarantula_susp": 0.002849002849002849,
            "pseudo_op2_susp": 0.0019646365422396855,
            "pseudo_barinel_susp": 0.002849002849002849
        }
    },
    {
        "name": "luigi.file.LocalTarget.open#122",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalTarget",
        "signature": "luigi.file.LocalTarget.open(self, mode='r')",
        "snippet": "    def open(self, mode='r'):\n        rwmode = mode.replace('b', '').replace('t', '')\n        if rwmode == 'w':\n            self.makedirs()\n            return self.format.pipe_writer(atomic_file(self.path))\n\n        elif rwmode == 'r':\n            fileobj = FileWrapper(io.BufferedReader(io.FileIO(self.path, mode)))\n            return self.format.pipe_reader(fileobj)\n\n        else:\n            raise Exception('mode must be r/w (got:%s)' % mode)",
        "begin_line": 122,
        "end_line": 133,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022624434389140274,
            "pseudo_dstar_susp": 0.0019230769230769232,
            "pseudo_tarantula_susp": 0.0027624309392265192,
            "pseudo_op2_susp": 0.0019230769230769232,
            "pseudo_barinel_susp": 0.0027624309392265192
        }
    },
    {
        "name": "luigi.file.LocalTarget.move#135",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalTarget",
        "signature": "luigi.file.LocalTarget.move(self, new_path, raise_if_exists=False)",
        "snippet": "    def move(self, new_path, raise_if_exists=False):\n        self.fs.move(self.path, new_path, raise_if_exists=raise_if_exists)",
        "begin_line": 135,
        "end_line": 136,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00031575623618566466,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.file.LocalTarget.remove#141",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalTarget",
        "signature": "luigi.file.LocalTarget.remove(self)",
        "snippet": "    def remove(self):\n        self.fs.remove(self.path)",
        "begin_line": 141,
        "end_line": 142,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002937720329024677,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.file.LocalTarget.copy#144",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalTarget",
        "signature": "luigi.file.LocalTarget.copy(self, new_path, raise_if_exists=False)",
        "snippet": "    def copy(self, new_path, raise_if_exists=False):\n        if raise_if_exists and os.path.exists(new_path):\n            raise RuntimeError('Destination exists: %s' % new_path)\n        tmp = LocalTarget(new_path + '-luigi-tmp-%09d' % random.randrange(0, 1e10), is_tmp=True)\n        tmp.makedirs()\n        shutil.copy(self.path, tmp.fn)\n        tmp.move(new_path)",
        "begin_line": 144,
        "end_line": 150,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.file.LocalTarget.fn#153",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalTarget",
        "signature": "luigi.file.LocalTarget.fn(self)",
        "snippet": "    def fn(self):\n        return self.path",
        "begin_line": 153,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.file.LocalTarget.__del__#156",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalTarget",
        "signature": "luigi.file.LocalTarget.__del__(self)",
        "snippet": "    def __del__(self):\n        if self.is_tmp and self.exists():\n            self.remove()",
        "begin_line": 156,
        "end_line": 158,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002937720329024677,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.file.File.__init__#162",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.File",
        "signature": "luigi.file.File.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        warnings.warn(\"File has been renamed LocalTarget\", DeprecationWarning, stacklevel=2)\n        super(File, self).__init__(*args, **kwargs)",
        "begin_line": 162,
        "end_line": 164,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.cmdline.luigi_run#9",
        "src_path": "luigi/cmdline.py",
        "class_name": "luigi.cmdline",
        "signature": "luigi.cmdline.luigi_run(argv=sys.argv[1:])",
        "snippet": "def luigi_run(argv=sys.argv[1:]):\n    run_with_retcodes(argv)",
        "begin_line": 9,
        "end_line": 10,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002544529262086514,
            "pseudo_dstar_susp": 0.0009199632014719411,
            "pseudo_tarantula_susp": 0.0058823529411764705,
            "pseudo_op2_susp": 0.0009199632014719411,
            "pseudo_barinel_susp": 0.0058823529411764705
        }
    },
    {
        "name": "luigi.contrib.opener.OpenerRegistry.get_opener#86",
        "src_path": "luigi/contrib/opener.py",
        "class_name": "luigi.contrib.opener.OpenerRegistry",
        "signature": "luigi.contrib.opener.OpenerRegistry.get_opener(self, name)",
        "snippet": "    def get_opener(self, name):\n        \"\"\"Retrieve an opener for the given protocol\n\n        :param name: name of the opener to open\n        :type name: string\n        :raises NoOpenerError: if no opener has been registered of that name\n\n        \"\"\"\n        if name not in self.registry:\n            raise NoOpenerError(\"No opener for %s\" % name)\n        index = self.registry[name]\n        return self.openers[index]",
        "begin_line": 86,
        "end_line": 97,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.opener.OpenerRegistry.open#112",
        "src_path": "luigi/contrib/opener.py",
        "class_name": "luigi.contrib.opener.OpenerRegistry",
        "signature": "luigi.contrib.opener.OpenerRegistry.open(self, target_uri, **kwargs)",
        "snippet": "    def open(self, target_uri, **kwargs):\n        \"\"\"Open target uri.\n\n        :param target_uri: Uri to open\n        :type target_uri: string\n\n        :returns: Target object\n\n        \"\"\"\n        target = urlsplit(target_uri, scheme=self.default_opener)\n\n        opener = self.get_opener(target.scheme)\n        query = opener.conform_query(target.query)\n\n        target = opener.get_target(\n            target.scheme,\n            target.path,\n            target.fragment,\n            target.username,\n            target.password,\n            target.hostname,\n            target.port,\n            query,\n            **kwargs\n        )\n        target.opener_path = target_uri\n\n        return target",
        "begin_line": 112,
        "end_line": 139,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002937720329024677,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.opener.Opener.conform_query#154",
        "src_path": "luigi/contrib/opener.py",
        "class_name": "luigi.contrib.opener.Opener",
        "signature": "luigi.contrib.opener.Opener.conform_query(cls, query)",
        "snippet": "    def conform_query(cls, query):\n        \"\"\"Converts the query string from a target uri, uses\n        cls.allowed_kwargs, and cls.filter_kwargs to drive logic.\n\n        :param query: Unparsed query string\n        :type query: urllib.parse.unsplit(uri).query\n        :returns: Dictionary of parsed values, everything in cls.allowed_kwargs\n            with values set to True will be parsed as json strings.\n\n        \"\"\"\n        query = parse_qs(query, keep_blank_values=True)\n\n        # Remove any unexpected keywords from the query string.\n        if cls.filter_kwargs:\n            query = {x: y for x, y in query.items() if x in cls.allowed_kwargs}\n\n        for key, vals in query.items():\n            # Multiple values of the same name could be passed use first\n            # Also params without strings will be treated as true values\n            if cls.allowed_kwargs.get(key, False):\n                val = json.loads(vals[0] or 'true')\n            else:\n                val = vals[0] or 'true'\n\n            query[key] = val\n\n        return query",
        "begin_line": 154,
        "end_line": 180,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.opener.MockOpener.get_target#209",
        "src_path": "luigi/contrib/opener.py",
        "class_name": "luigi.contrib.opener.MockOpener",
        "signature": "luigi.contrib.opener.MockOpener.get_target(cls, scheme, path, fragment, username, password, hostname, port, query, **kwargs)",
        "snippet": "    def get_target(cls, scheme, path, fragment, username,\n                   password, hostname, port, query, **kwargs):\n        full_path = (hostname or '') + path\n        query.update(kwargs)\n        return MockTarget(full_path, **query)",
        "begin_line": 209,
        "end_line": 213,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.opener.LocalOpener.get_target#234",
        "src_path": "luigi/contrib/opener.py",
        "class_name": "luigi.contrib.opener.LocalOpener",
        "signature": "luigi.contrib.opener.LocalOpener.get_target(cls, scheme, path, fragment, username, password, hostname, port, query, **kwargs)",
        "snippet": "    def get_target(cls, scheme, path, fragment, username,\n                   password, hostname, port, query, **kwargs):\n        full_path = (hostname or '') + path\n        query.update(kwargs)\n        return LocalTarget(full_path, **query)",
        "begin_line": 234,
        "end_line": 238,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.opener.S3Opener.get_target#258",
        "src_path": "luigi/contrib/opener.py",
        "class_name": "luigi.contrib.opener.S3Opener",
        "signature": "luigi.contrib.opener.S3Opener.get_target(cls, scheme, path, fragment, username, password, hostname, port, query, **kwargs)",
        "snippet": "    def get_target(cls, scheme, path, fragment, username,\n                   password, hostname, port, query, **kwargs):\n        query.update(kwargs)\n        return S3Target('{scheme}://{hostname}{path}'.format(\n            scheme=scheme, hostname=hostname, path=path), **query)",
        "begin_line": 258,
        "end_line": 262,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.bigquery.BQTable.dataset#63",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BQTable",
        "signature": "luigi.contrib.bigquery.BQTable.dataset(self)",
        "snippet": "    def dataset(self):\n        return BQDataset(project_id=self.project_id, dataset_id=self.dataset_id)",
        "begin_line": 63,
        "end_line": 64,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigqueryTarget.__init__#339",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigqueryTarget",
        "signature": "luigi.contrib.bigquery.BigqueryTarget.__init__(self, project_id, dataset_id, table_id, client=None)",
        "snippet": "    def __init__(self, project_id, dataset_id, table_id, client=None):\n        self.table = BQTable(project_id=project_id, dataset_id=dataset_id, table_id=table_id)\n        self.client = client or BigqueryClient()",
        "begin_line": 339,
        "end_line": 341,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00030543677458766036,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigqueryTarget.exists#352",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigqueryTarget",
        "signature": "luigi.contrib.bigquery.BigqueryTarget.exists(self)",
        "snippet": "    def exists(self):\n        return self.client.table_exists(self.table)",
        "begin_line": 352,
        "end_line": 353,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigqueryTarget.__str__#355",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigqueryTarget",
        "signature": "luigi.contrib.bigquery.BigqueryTarget.__str__(self)",
        "snippet": "    def __str__(self):\n        return str(self.table)",
        "begin_line": 355,
        "end_line": 356,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003484320557491289,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.bigquery.MixinBigqueryBulkComplete.bulk_complete#369",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.MixinBigqueryBulkComplete",
        "signature": "luigi.contrib.bigquery.MixinBigqueryBulkComplete.bulk_complete(cls, parameter_tuples)",
        "snippet": "    def bulk_complete(cls, parameter_tuples):\n        if len(parameter_tuples) < 1:\n            return\n\n        # Instantiate the tasks to inspect them\n        tasks_with_params = [(cls(p), p) for p in parameter_tuples]\n\n        # Grab the set of BigQuery datasets we are interested in\n        datasets = set([t.output().table.dataset for t, p in tasks_with_params])\n        logger.info('Checking datasets %s for available tables', datasets)\n\n        # Query the available tables for all datasets\n        client = tasks_with_params[0][0].output().client\n        available_datasets = filter(client.dataset_exists, datasets)\n        available_tables = {d: set(client.list_tables(d)) for d in available_datasets}\n\n        # Return parameter_tuples belonging to available tables\n        for t, p in tasks_with_params:\n            table = t.output().table\n            if table.table_id in available_tables.get(table.dataset, []):\n                yield p",
        "begin_line": 369,
        "end_line": 389,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigqueryRunQueryTask.write_disposition#457",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigqueryRunQueryTask",
        "signature": "luigi.contrib.bigquery.BigqueryRunQueryTask.write_disposition(self)",
        "snippet": "    def write_disposition(self):\n        \"\"\"What to do if the table already exists. By default this will fail the job.\n\n           See :py:class:`WriteDisposition`\"\"\"\n        return WriteDisposition.WRITE_TRUNCATE",
        "begin_line": 457,
        "end_line": 461,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigqueryRunQueryTask.create_disposition#464",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigqueryRunQueryTask",
        "signature": "luigi.contrib.bigquery.BigqueryRunQueryTask.create_disposition(self)",
        "snippet": "    def create_disposition(self):\n        \"\"\"Whether to create the table or not. See :py:class:`CreateDisposition`\"\"\"\n        return CreateDisposition.CREATE_IF_NEEDED",
        "begin_line": 464,
        "end_line": 466,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigqueryRunQueryTask.flatten_results#469",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigqueryRunQueryTask",
        "signature": "luigi.contrib.bigquery.BigqueryRunQueryTask.flatten_results(self)",
        "snippet": "    def flatten_results(self):\n        \"\"\"Flattens all nested and repeated fields in the query results.\n        allowLargeResults must be true if this is set to False.\"\"\"\n        return True",
        "begin_line": 469,
        "end_line": 472,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigqueryRunQueryTask.query_mode#480",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigqueryRunQueryTask",
        "signature": "luigi.contrib.bigquery.BigqueryRunQueryTask.query_mode(self)",
        "snippet": "    def query_mode(self):\n        \"\"\"The query mode. See :py:class:`QueryMode`.\"\"\"\n        return QueryMode.INTERACTIVE",
        "begin_line": 480,
        "end_line": 482,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigqueryRunQueryTask.run#484",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigqueryRunQueryTask",
        "signature": "luigi.contrib.bigquery.BigqueryRunQueryTask.run(self)",
        "snippet": "    def run(self):\n        output = self.output()\n        assert isinstance(output, BigqueryTarget), 'Output should be a bigquery target, not %s' % (output)\n\n        query = self.query\n        assert query, 'No query was provided'\n\n        bq_client = output.client\n\n        logger.info('Launching Query')\n        logger.info('Query destination: %s (%s)', output, self.write_disposition)\n        logger.info('Query SQL: %s', query)\n\n        job = {\n            'projectId': output.table.project_id,\n            'configuration': {\n                'query': {\n                    'query': query,\n                    'priority': self.query_mode,\n                    'destinationTable': {\n                        'projectId': output.table.project_id,\n                        'datasetId': output.table.dataset_id,\n                        'tableId': output.table.table_id,\n                    },\n                    'allowLargeResults': True,\n                    'createDisposition': self.create_disposition,\n                    'writeDisposition': self.write_disposition,\n                    'flattenResults': self.flatten_results\n                }\n            }\n        }\n\n        bq_client.run_job(output.table.project_id, job, dataset=output.table.dataset)",
        "begin_line": 484,
        "end_line": 516,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigqueryCreateViewTask.complete#534",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigqueryCreateViewTask",
        "signature": "luigi.contrib.bigquery.BigqueryCreateViewTask.complete(self)",
        "snippet": "    def complete(self):\n        output = self.output()\n        assert isinstance(output, BigqueryTarget), 'Output must be a bigquery target, not %s' % (output)\n\n        if not output.exists():\n            return False\n\n        existing_view = output.client.get_view(output.table)\n        return existing_view == self.view",
        "begin_line": 534,
        "end_line": 542,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0003795066413662239,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.contrib.bigquery.BigqueryCreateViewTask.run#544",
        "src_path": "luigi/contrib/bigquery.py",
        "class_name": "luigi.contrib.bigquery.BigqueryCreateViewTask",
        "signature": "luigi.contrib.bigquery.BigqueryCreateViewTask.run(self)",
        "snippet": "    def run(self):\n        output = self.output()\n        assert isinstance(output, BigqueryTarget), 'Output must be a bigquery target, not %s' % (output)\n\n        view = self.view\n        assert view, 'No view was provided'\n\n        logger.info('Create view')\n        logger.info('Destination: %s', output)\n        logger.info('View SQL: %s', view)\n\n        output.client.update_view(output.table, view)",
        "begin_line": 544,
        "end_line": 555,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.six._import_module#83",
        "src_path": "luigi/six.py",
        "class_name": "luigi.six",
        "signature": "luigi.six._import_module(name)",
        "snippet": "def _import_module(name):\n    \"\"\"Import module, returning the module after the last dot.\"\"\"\n    __import__(name)\n    return sys.modules[name]",
        "begin_line": 83,
        "end_line": 86,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.six._LazyDescr.__get__#94",
        "src_path": "luigi/six.py",
        "class_name": "luigi.six._LazyDescr",
        "signature": "luigi.six._LazyDescr.__get__(self, obj, tp)",
        "snippet": "    def __get__(self, obj, tp):\n        result = self._resolve()\n        setattr(obj, self.name, result) # Invokes __set__.\n        try:\n            # This is a bit ugly, but it avoids running this again by\n            # removing this descriptor.\n            delattr(obj.__class__, self.name)\n        except AttributeError:\n            pass\n        return result",
        "begin_line": 94,
        "end_line": 103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.six.MovedAttribute._resolve#162",
        "src_path": "luigi/six.py",
        "class_name": "luigi.six.MovedAttribute",
        "signature": "luigi.six.MovedAttribute._resolve(self)",
        "snippet": "    def _resolve(self):\n        module = _import_module(self.mod)\n        return getattr(module, self.attr)",
        "begin_line": 162,
        "end_line": 164,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.six._SixMetaPathImporter.find_module#185",
        "src_path": "luigi/six.py",
        "class_name": "luigi.six._SixMetaPathImporter",
        "signature": "luigi.six._SixMetaPathImporter.find_module(self, fullname, path=None)",
        "snippet": "    def find_module(self, fullname, path=None):\n        if fullname in self.known_modules:\n            return self\n        return None",
        "begin_line": 185,
        "end_line": 188,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.030303030303030304,
            "pseudo_dstar_susp": 0.003389830508474576,
            "pseudo_tarantula_susp": 0.014705882352941176,
            "pseudo_op2_susp": 0.003389830508474576,
            "pseudo_barinel_susp": 0.014705882352941176
        }
    },
    {
        "name": "luigi.six.itervalues#559",
        "src_path": "luigi/six.py",
        "class_name": "luigi.six",
        "signature": "luigi.six.itervalues(d, **kw)",
        "snippet": "    def itervalues(d, **kw):\n        return iter(d.values(**kw))",
        "begin_line": 559,
        "end_line": 560,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015552099533437014,
            "pseudo_dstar_susp": 0.003676470588235294,
            "pseudo_tarantula_susp": 0.0010893246187363835,
            "pseudo_op2_susp": 0.003676470588235294,
            "pseudo_barinel_susp": 0.0010893246187363835
        }
    },
    {
        "name": "luigi.six.iteritems#562",
        "src_path": "luigi/six.py",
        "class_name": "luigi.six",
        "signature": "luigi.six.iteritems(d, **kw)",
        "snippet": "    def iteritems(d, **kw):\n        return iter(d.items(**kw))",
        "begin_line": 562,
        "end_line": 563,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004878048780487805,
            "pseudo_dstar_susp": 0.02857142857142857,
            "pseudo_tarantula_susp": 0.0019646365422396855,
            "pseudo_op2_susp": 0.02857142857142857,
            "pseudo_barinel_susp": 0.0019646365422396855
        }
    },
    {
        "name": "luigi.six.assertCountEqual#643",
        "src_path": "luigi/six.py",
        "class_name": "luigi.six",
        "signature": "luigi.six.assertCountEqual(self, *args, **kwargs)",
        "snippet": "def assertCountEqual(self, *args, **kwargs):\n    return getattr(self, _assertCountEqual)(*args, **kwargs)",
        "begin_line": 643,
        "end_line": 644,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.00031575623618566466,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.notifications.email_type#71",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.email_type()",
        "snippet": "def email_type():\n    return configuration.get_config().get('core', 'email-type', 'plain')",
        "begin_line": 71,
        "end_line": 72,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014619883040935672,
            "pseudo_dstar_susp": 0.0010330578512396695,
            "pseudo_tarantula_susp": 0.002304147465437788,
            "pseudo_op2_susp": 0.0010330578512396695,
            "pseudo_barinel_susp": 0.002304147465437788
        }
    },
    {
        "name": "luigi.notifications.generate_email#75",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.generate_email(sender, subject, message, recipients, image_png)",
        "snippet": "def generate_email(sender, subject, message, recipients, image_png):\n    import email\n    import email.mime\n    import email.mime.multipart\n    import email.mime.text\n    import email.mime.image\n\n    msg_root = email.mime.multipart.MIMEMultipart('related')\n\n    msg_text = email.mime.text.MIMEText(message, email_type())\n    msg_text.set_charset('utf-8')\n    msg_root.attach(msg_text)\n\n    if image_png:\n        with open(image_png, 'rb') as fp:\n            msg_image = email.mime.image.MIMEImage(fp.read(), 'png')\n        msg_root.attach(msg_image)\n\n    msg_root['Subject'] = subject\n    msg_root['From'] = sender\n    msg_root['To'] = ','.join(recipients)\n\n    return msg_root",
        "begin_line": 75,
        "end_line": 97,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002937720329024677,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.notifications.wrap_traceback#100",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.wrap_traceback(traceback)",
        "snippet": "def wrap_traceback(traceback):\n    \"\"\"\n    For internal use only (until further notice)\n    \"\"\"\n    if email_type() == 'html':\n        try:\n            from pygments import highlight\n            from pygments.lexers import PythonTracebackLexer\n            from pygments.formatters import HtmlFormatter\n            with_pygments = True\n        except ImportError:\n            with_pygments = False\n\n        if with_pygments:\n            formatter = HtmlFormatter(noclasses=True)\n            wrapped = highlight(traceback, PythonTracebackLexer(), formatter)\n        else:\n            wrapped = '<pre>%s</pre>' % traceback\n    else:\n        wrapped = traceback\n\n    return wrapped",
        "begin_line": 100,
        "end_line": 121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.015384615384615385,
            "pseudo_dstar_susp": 0.001221001221001221,
            "pseudo_tarantula_susp": 0.047619047619047616,
            "pseudo_op2_susp": 0.001221001221001221,
            "pseudo_barinel_susp": 0.047619047619047616
        }
    },
    {
        "name": "luigi.notifications.send_email_smtp#124",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.send_email_smtp(config, sender, subject, message, recipients, image_png)",
        "snippet": "def send_email_smtp(config, sender, subject, message, recipients, image_png):\n    import smtplib\n\n    smtp_ssl = config.getboolean('core', 'smtp_ssl', False)\n    smtp_without_tls = config.getboolean('core', 'smtp_without_tls', False)\n    smtp_host = config.get('core', 'smtp_host', 'localhost')\n    smtp_port = config.getint('core', 'smtp_port', 0)\n    smtp_local_hostname = config.get('core', 'smtp_local_hostname', None)\n    smtp_timeout = config.getfloat('core', 'smtp_timeout', None)\n    kwargs = dict(host=smtp_host, port=smtp_port, local_hostname=smtp_local_hostname)\n    if smtp_timeout:\n        kwargs['timeout'] = smtp_timeout\n\n    smtp_login = config.get('core', 'smtp_login', None)\n    smtp_password = config.get('core', 'smtp_password', None)\n    smtp = smtplib.SMTP(**kwargs) if not smtp_ssl else smtplib.SMTP_SSL(**kwargs)\n    smtp.ehlo_or_helo_if_needed()\n    if smtp.has_extn('starttls') and not smtp_without_tls:\n        smtp.starttls()\n    if smtp_login and smtp_password:\n        smtp.login(smtp_login, smtp_password)\n\n    msg_root = generate_email(sender, subject, message, recipients, image_png)\n\n    smtp.sendmail(sender, recipients, msg_root.as_string())",
        "begin_line": 124,
        "end_line": 148,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.notifications.send_email_ses#151",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.send_email_ses(config, sender, subject, message, recipients, image_png)",
        "snippet": "def send_email_ses(config, sender, subject, message, recipients, image_png):\n    \"\"\"\n    Sends notification through AWS SES.\n\n    Does not handle access keys.  Use either\n      1/ configuration file\n      2/ EC2 instance profile\n\n    See also http://boto3.readthedocs.org/en/latest/guide/configuration.html.\n    \"\"\"\n    from boto3 import client as boto3_client\n\n    client = boto3_client('ses')\n\n    msg_root = generate_email(sender, subject, message, recipients, image_png)\n    response = client.send_raw_email(Source=sender,\n                                     Destinations=recipients,\n                                     RawMessage={'Data': msg_root.as_string()})\n\n    logger.debug((\"Message sent to SES.\\nMessageId: {},\\nRequestId: {},\\n\"\n                 \"HTTPSStatusCode: {}\").format(response['MessageId'],\n                                               response['ResponseMetadata']['RequestId'],\n                                               response['ResponseMetadata']['HTTPStatusCode']))",
        "begin_line": 151,
        "end_line": 173,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.notifications.send_email_sendgrid#176",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.send_email_sendgrid(config, sender, subject, message, recipients, image_png)",
        "snippet": "def send_email_sendgrid(config, sender, subject, message, recipients, image_png):\n    import sendgrid\n    client = sendgrid.SendGridClient(config.get('email', 'SENDGRID_USERNAME', None),\n                                     config.get('email', 'SENDGRID_PASSWORD', None),\n                                     raise_errors=True)\n    to_send = sendgrid.Mail()\n    to_send.add_to(recipients)\n    to_send.set_from(sender)\n    to_send.set_subject(subject)\n    if email_type() == 'html':\n        to_send.set_html(message)\n    else:\n        to_send.set_text(message)\n    if image_png:\n        to_send.add_attachment(image_png)\n\n    client.send(to_send)",
        "begin_line": 176,
        "end_line": 192,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.notifications._email_disabled#195",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications._email_disabled()",
        "snippet": "def _email_disabled():\n    if email_type() == 'none':\n        logger.info(\"Not sending email when email-type is none\")\n        return True\n    elif configuration.get_config().getboolean('email', 'force-send', False):\n        return False\n    elif sys.stdout.isatty():\n        logger.info(\"Not sending email when running from a tty\")\n        return True\n    elif DEBUG:\n        logger.info(\"Not sending email when running in debug mode\")\n    else:\n        return False",
        "begin_line": 195,
        "end_line": 207,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.notifications.send_email_sns#210",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.send_email_sns(config, sender, subject, message, topic_ARN, image_png)",
        "snippet": "def send_email_sns(config, sender, subject, message, topic_ARN, image_png):\n    \"\"\"\n    Sends notification through AWS SNS. Takes Topic ARN from recipients.\n\n    Does not handle access keys.  Use either\n      1/ configuration file\n      2/ EC2 instance profile\n\n    See also http://boto3.readthedocs.org/en/latest/guide/configuration.html.\n    \"\"\"\n    from boto3 import resource as boto3_resource\n\n    sns = boto3_resource('sns')\n    topic = sns.Topic(topic_ARN[0])\n\n    # Subject is max 100 chars\n    if len(subject) > 100:\n        subject = subject[0:48] + '...' + subject[-49:]\n\n    response = topic.publish(Subject=subject, Message=message)\n\n    logger.debug((\"Message sent to SNS.\\nMessageId: {},\\nRequestId: {},\\n\"\n                 \"HTTPSStatusCode: {}\").format(response['MessageId'],\n                                               response['ResponseMetadata']['RequestId'],\n                                               response['ResponseMetadata']['HTTPStatusCode']))",
        "begin_line": 210,
        "end_line": 234,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.notifications.send_email#237",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.send_email(subject, message, sender, recipients, image_png=None)",
        "snippet": "def send_email(subject, message, sender, recipients, image_png=None):\n    \"\"\"\n    Decides whether to send notification. Notification is cancelled if there are\n    no recipients or if stdout is onto tty or if in debug mode.\n\n    Dispatches on config value email.type.  Default is 'smtp'.\n    \"\"\"\n    config = configuration.get_config()\n    notifiers = {'ses': send_email_ses,\n                 'sendgrid': send_email_sendgrid,\n                 'smtp': send_email_smtp,\n                 'sns': send_email_sns}\n\n    subject = _prefix(subject)\n    if not recipients or recipients == (None,):\n        return\n    if _email_disabled():\n        return\n\n    # Clean the recipients lists to allow multiple error-email addresses, comma\n    # separated in luigi.cfg\n    recipients_tmp = []\n    for r in recipients:\n        recipients_tmp.extend([a.strip() for a in r.split(',') if a.strip()])\n\n    # Replace original recipients with the clean list\n    recipients = recipients_tmp\n\n    # Get appropriate sender and call it to send the notification\n    email_sender_type = config.get('email', 'type', None)\n    email_sender = notifiers.get(email_sender_type, send_email_smtp)\n    email_sender(config, sender, subject, message, recipients, image_png)",
        "begin_line": 237,
        "end_line": 268,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.notifications._email_recipients#271",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications._email_recipients(additional_recipients=None)",
        "snippet": "def _email_recipients(additional_recipients=None):\n    config = configuration.get_config()\n    receiver = config.get('core', 'error-email', None)\n    recipients = [receiver] if receiver else []\n    if additional_recipients:\n        if isinstance(additional_recipients, str):\n            recipients.append(additional_recipients)\n        else:\n            recipients.extend(additional_recipients)\n    return recipients",
        "begin_line": 271,
        "end_line": 280,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.notifications.send_error_email#283",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.send_error_email(subject, message, additional_recipients=None)",
        "snippet": "def send_error_email(subject, message, additional_recipients=None):\n    \"\"\"\n    Sends an email to the configured error-email.\n\n    If no error-email is configured, then a message is logged.\n    \"\"\"\n    config = configuration.get_config()\n    recipients = _email_recipients(additional_recipients)\n    if recipients:\n        sender = config.get('core', 'email-sender', DEFAULT_CLIENT_EMAIL)\n        logger.info(\"Sending warning email to %r\", recipients)\n        send_email(\n            subject=subject,\n            message=message,\n            sender=sender,\n            recipients=recipients\n        )\n    else:\n        logger.info(\"Skipping error email. Set `error-email` in the `core` \"\n                    \"section of the luigi config file or override `owner_email`\"\n                    \"in the task to receive error emails.\")",
        "begin_line": 283,
        "end_line": 303,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.0002842524161455372,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.notifications._prefix#306",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications._prefix(subject)",
        "snippet": "def _prefix(subject):\n    \"\"\"\n    If the config has a special prefix for emails then this function adds\n    this prefix.\n    \"\"\"\n    config = configuration.get_config()\n    email_prefix = config.get('core', 'email-prefix', None)\n    if email_prefix is not None:\n        subject = \"%s %s\" % (email_prefix, subject)\n    return subject",
        "begin_line": 306,
        "end_line": 315,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003399048266485384,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0003399048266485384,
            "pseudo_op2_susp": 0.000550357732526142,
            "pseudo_barinel_susp": 0.0003399048266485384
        }
    },
    {
        "name": "luigi.notifications.format_task_error#318",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.format_task_error(headline, task, formatted_exception=None)",
        "snippet": "def format_task_error(headline, task, formatted_exception=None):\n    \"\"\"\n    Format a message body for an error email related to a luigi.task.Task\n\n    :param headline: Summary line for the message\n    :param task: `luigi.task.Task` instance where this error occurred\n    :param formatted_exception: optional string showing traceback\n\n    :return: message body\n    \"\"\"\n\n    typ = email_type()\n    if formatted_exception:\n        formatted_exception = wrap_traceback(formatted_exception)\n    else:\n        formatted_exception = \"\"\n\n    if typ == 'html':\n        msg_template = textwrap.dedent('''\n        <html>\n        <body>\n        <h2>{headline}</h2>\n\n        <table style=\"border-top: 1px solid black; border-bottom: 1px solid black\">\n        <thead>\n        <tr><th>name</th><td>{name}</td></tr>\n        </thead>\n        <tbody>\n        {param_rows}\n        </tbody>\n        </table>\n        </pre>\n\n        <h2>Traceback</h2>\n        {traceback}\n        </body>\n        </html>\n        ''')\n\n        str_params = task.to_str_params()\n        params = '\\n'.join('<tr><th>{}</th><td>{}</td></tr>'.format(*items) for items in str_params.items())\n        body = msg_template.format(headline=headline, name=task.task_family, param_rows=params,\n                                   traceback=formatted_exception)\n    else:\n        msg_template = textwrap.dedent('''\\\n        {headline}\n\n        Name: {name}\n\n        Parameters:\n        {params}\n\n        {traceback}\n        ''')\n\n        str_params = task.to_str_params()\n        max_width = max([0] + [len(x) for x in str_params.keys()])\n        params = '\\n'.join('  {:{width}}: {}'.format(*items, width=max_width) for items in str_params.items())\n        body = msg_template.format(headline=headline, name=task.task_family, params=params,\n                                   traceback=formatted_exception)\n\n    return body",
        "begin_line": 318,
        "end_line": 379,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.03225806451612903,
            "pseudo_dstar_susp": 0.0034129692832764505,
            "pseudo_tarantula_susp": 0.047619047619047616,
            "pseudo_op2_susp": 0.0034129692832764505,
            "pseudo_barinel_susp": 0.047619047619047616
        }
    }
]